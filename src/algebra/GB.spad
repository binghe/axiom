)abbrev package GB GroebnerPackage
++ Authors: Gebauer, Trager
++ Date Created: 12-1-86
++ Date Last Updated: 2-28-91
++ References:
++ Normxx Notes 13: How to Compute a Groebner Basis
++ Coxx07 Ideals, varieties and algorithms
++ Description: 
++ \spadtype{GroebnerPackage} computes groebner
++ bases for polynomial ideals. The basic computation provides a distinguished
++ set of generators for polynomial ideals over fields. This basis allows an 
++ easy test for membership: the operation \spadfun{normalForm}
++ returns zero on ideal members. When the provided coefficient domain, Dom,
++ is not a field, the result is equivalent to considering the extended
++ ideal with \spadtype{Fraction(Dom)} as coefficients, but considerably more
++ efficient since all calculations are performed in Dom. Additional 
++ argument "info" and "redcrit" can be given to provide incremental 
++ information during computation. Argument "info" produces a computational 
++ summary for each s-polynomial.
++ Argument "redcrit" prints out the reduced critical pairs. The term ordering
++ is determined by the polynomial type used. Suggested types include
++ \spadtype{DistributedMultivariatePolynomial},
++ \spadtype{HomogeneousDistributedMultivariatePolynomial},
++ \spadtype{GeneralDistributedMultivariatePolynomial}.
 
GroebnerPackage(Dom, Expon, VarSet, Dpol) : SIG == CODE where
  Dom : GcdDomain
  Expon : OrderedAbelianMonoidSup
  VarSet : OrderedSet
  Dpol : PolynomialCategory(Dom, Expon, VarSet)
 
  SIG ==> with
 
    groebner : List(Dpol) -> List(Dpol)
      ++ groebner(lp) computes a groebner basis for a polynomial ideal
      ++ generated by the list of polynomials lp.
      ++
      ++X s1:DMP([w,p,z,t,s,b],FRAC(INT)):= 45*p + 35*s - 165*b - 36
      ++X s2:DMP([w,p,z,t,s,b],FRAC(INT)):= 35*p + 40*z + 25*t - 27*s
      ++X s3:DMP([w,p,z,t,s,b],FRAC(INT)):= 15*w+25*p*s+30*z - 18*t - 165*b**2
      ++X s4:DMP([w,p,z,t,s,b],FRAC(INT)):= -9*w + 15*p*t + 20*z*s
      ++X s5:DMP([w,p,z,t,s,b],FRAC(INT)):= w*p + 2*z*t - 11*b**3
      ++X s6:DMP([w,p,z,t,s,b],FRAC(INT)):= 99*w - 11*b*s + 3*b**2
      ++X s7:DMP([w,p,z,t,s,b],FRAC(INT)):= b**2 + 33/50*b + 2673/10000
      ++X sn7:=[s1,s2,s3,s4,s5,s6,s7]
      ++X groebner(sn7)

    groebner : ( List(Dpol), String ) -> List(Dpol)
      ++ groebner(lp, infoflag) computes a groebner basis 
      ++ for a polynomial ideal
      ++ generated by the list of polynomials lp.
      ++ Argument infoflag is used to get information on the computation.
      ++ If infoflag is "info", then summary information
      ++ is displayed for each s-polynomial generated.
      ++ If infoflag is "redcrit", the reduced critical pairs are displayed.
      ++ If infoflag is any other string, 
      ++ no information is printed during computation.
      ++
      ++X s1:DMP([w,p,z,t,s,b],FRAC(INT)):= 45*p + 35*s - 165*b - 36
      ++X s2:DMP([w,p,z,t,s,b],FRAC(INT)):= 35*p + 40*z + 25*t - 27*s
      ++X s3:DMP([w,p,z,t,s,b],FRAC(INT)):= 15*w+25*p*s+30*z - 18*t - 165*b**2
      ++X s4:DMP([w,p,z,t,s,b],FRAC(INT)):= -9*w + 15*p*t + 20*z*s
      ++X s5:DMP([w,p,z,t,s,b],FRAC(INT)):= w*p + 2*z*t - 11*b**3
      ++X s6:DMP([w,p,z,t,s,b],FRAC(INT)):= 99*w - 11*b*s + 3*b**2
      ++X s7:DMP([w,p,z,t,s,b],FRAC(INT)):= b**2 + 33/50*b + 2673/10000
      ++X sn7:=[s1,s2,s3,s4,s5,s6,s7]
      ++X groebner(sn7,"info")
      ++X groebner(sn7,"redcrit")

    groebner : ( List(Dpol), String, String ) -> List(Dpol)
      ++ groebner(lp, "info", "redcrit") computes a groebner basis
      ++ for a polynomial ideal generated by the list of polynomials lp,
      ++ displaying both a summary of the critical pairs considered ("info")
      ++ and the result of reducing each critical pair ("redcrit").
      ++ If the second or third arguments have any other string value,
      ++ the indicated information is suppressed.
      ++
      ++X s1:DMP([w,p,z,t,s,b],FRAC(INT)):= 45*p + 35*s - 165*b - 36
      ++X s2:DMP([w,p,z,t,s,b],FRAC(INT)):= 35*p + 40*z + 25*t - 27*s
      ++X s3:DMP([w,p,z,t,s,b],FRAC(INT)):= 15*w + 25*p*s + 30*z - 18*t - 165*b**2
      ++X s4:DMP([w,p,z,t,s,b],FRAC(INT)):= -9*w + 15*p*t + 20*z*s
      ++X s5:DMP([w,p,z,t,s,b],FRAC(INT)):= w*p + 2*z*t - 11*b**3
      ++X s6:DMP([w,p,z,t,s,b],FRAC(INT)):= 99*w - 11*b*s + 3*b**2
      ++X s7:DMP([w,p,z,t,s,b],FRAC(INT)):= b**2 + 33/50*b + 2673/10000
      ++X sn7:=[s1,s2,s3,s4,s5,s6,s7]
      ++X groebner(sn7,"info","redcrit")
       
    if Dom has Field then

      normalForm : (Dpol, List(Dpol))  -> Dpol
        ++ normalForm(poly,gb) reduces the polynomial poly modulo the
        ++ precomputed groebner basis gb giving a canonical representative
        ++ of the residue class.
        ++
        ++X f:HDMP([x,y],FRAC INT) := x^3 + 3*y^2
        ++X g:HDMP([x,y],FRAC INT) := x^2 + y
        ++X h:HDMP([x,y],FRAC INT) := x + 2*x*j
        ++X normalForm(f,[g,h])
        ++X Lex := DMP([x,y],FRAC INT)
        ++X normalForm(f::Lex,[g::Lex,h::Lex])

  CODE ==> add

   import OutputForm
   import GroebnerInternalPackage(Dom,Expon,VarSet,Dpol)
 
   if Dom has Field then

     monicize(p: Dpol):Dpol ==
       ((lc := leadingCoefficient p) = 1) => p
       inv(lc)*p

     normalForm(p : Dpol, l : List(Dpol)) : Dpol ==
       redPol(p,map(monicize,l))
 
   ------    MAIN ALGORITHM GROEBNER ------------------------
 
   groebner( Pol: List(Dpol) ) ==
     Pol=[] => Pol
     Pol:=[x for x in Pol | x ^= 0]
     Pol=[] => [0]
     minGbasis(sort((x,y) +->  degree x > degree y, gbasis(Pol,0,0)))
 
   groebner( Pol: List(Dpol), xx1: String) ==
     Pol=[] => Pol
     Pol:=[x for x in Pol | x ^= 0]
     Pol=[] => [0]
     xx1 = "redcrit" =>
       minGbasis(sort((x,y) +->  degree x > degree y, gbasis(Pol,1,0)))
     xx1 = "info" =>
       minGbasis(sort((x,y) +-> degree x > degree y, gbasis(Pol,2,1)))
     messagePrint("   ")
     messagePrint("WARNING: options are - redcrit and/or info - ")
     messagePrint("         you didn't type them correct")
     messagePrint("         please try again")
     messagePrint("   ")
     []
 
   groebner( Pol: List(Dpol), xx1: String, xx2: String) ==
     Pol=[] => Pol
     Pol:=[x for x in Pol | x ^= 0]
     Pol=[] => [0]
     (xx1 = "redcrit" and xx2 = "info") or
      (xx1 = "info" and xx2 = "redcrit")   =>
       minGbasis(sort((x,y) +-> degree x > degree y, gbasis(Pol,1,1)))
     xx1 = "redcrit" and xx2 = "redcrit" =>
       minGbasis(sort((x,y) +-> degree x > degree y, gbasis(Pol,1,0)))
     xx1 = "info" and xx2 = "info" =>
       minGbasis(sort((x,y) +-> degree x > degree y, gbasis(Pol,2,1)))
     messagePrint("   ")
     messagePrint("WARNING:  options are - redcrit and/or info - ")
     messagePrint("          you didn't type them correctly")
     messagePrint("          please try again ")
     messagePrint("   ")
     []


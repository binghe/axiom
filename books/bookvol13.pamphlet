\documentclass[dvipdfm]{book}
\newcommand{\VolumeName}{Volume 13: Proving Axiom Correct}
\usepackage{bbold}
\usepackage{amsmath}
\usepackage{turnstile}
\usepackage{mathrsfs}

% For writing math symbols in verbatim-like environments (lstlisting)
\usepackage{listings}
\lstset{
  basicstyle=\ttfamily,
  mathescape
}

\input{bookheader.tex}
\pagenumbering{arabic}
\mainmatter
\setcounter{chapter}{0} % Chapter 1
Ultimately we would like Axiom to be able to prove that an
algorithm generates correct results. There are many steps
between here and that goal, including proving one Axiom
algorithm correct through all of the levels from Spad code,
to the Lisp code, to the C code, to the machine code; a 
daunting task of its own. 

The proof of a single Axiom algorithm is done with an eye toward
automating the process. Automated machine proofs are not possible
in general but will exist for known algorithms. 

\begin{quote}
{\bf This is an exercise in Omphaloskepsis}\\
-- Tim Daly
\end{quote}

\begin{quote}
{\bf The use of a program to prove the 4-color theorem will not 
change mathematics -- it merely demonstrates that the theorem,
a challenge for a century, is probably not important to mathematics.}\\
-- Alan J. Perlis 
\end{quote}

\begin{quote}
{\bf Thinking, analyzing, and inventing are not anomalous acts; they
are the normal respiration of the intelligence.}\\
-- Zero HP Lovecraft (The Gig Economy)
\end{quote}

\begin{quote}
{\bf You have to have an intrinsic drive, intrinsic interest in doing
research.  You've got to be willing to suffer, go away from a problem,
come back to it later. Doing research in theory is kind of terrifying
because you never know if the problem you're trying to solve you can
solve or not.}\\
-- Robert E. Tarjan
\end{quote}

\begin{quote}
{\bf The truth of an arithmetic statement is independent from its proof}\\
-- Kurt G\"odel
\end{quote}

\begin{quote}
{\bf Coq is the tactical nuclear weapons of programming.  You need to be
quite clever to use them. And indeed, when people first start to use
them you don't hear from them for two years, they sort of 'go dark'
and then they emerge with all their pain receptors destroyed and they
say Coq the only way to live, to do everything in Coq. "I don't write
programs anymore, I just write Coq proofs"}\\
-- Simon Peyton-Jones \cite{Peyt17}
\end{quote}

\begin{quote}
{\bf Research is to see what everybody else has seen and to think what
nobody has thought}\\
-- Max Jammer \cite{Jamm66}
\end{quote}

\begin{quote}
{\bf It is an intrinsic part of the duty of everyone who professes to
compose algorithms to supply a proof that his text indeed represents a
proper algorithm.}\\
-- Edsgar Dijkstra \cite{Dijk71}
\end{quote}

\begin{quote}
When correctness concerns come as an afterthought and correctness
proofs have to be given once the program is already completed, the
programmer can indeed expect severe troubles. If, however, he adheres
to the discipline to produce the correctness proofs as he programs
along [my italics], he will produce program and proof with less effort
than programming alone would have taken.
-- Edsgar Dijkstra \cite{Dijk70}
\end{quote}

\begin{quote}
{\bf If what you are working on is not important, why are you working on it?}\\
-- Richard Hamming \cite{Hamm95}
\end{quote}

\begin{quote}
{\bf Q: Why bother doing proofs about programming languages? They are almost
always boring if the definitions are right.}

{\bf A: The definitions are almost always wrong.}
\end{quote}

\begin{quote}
{\bf The Misfortunes of a Trio of Mathematicians Using Computer Algebra
Systems: Can We Trust In Them?}\\
-- Dur{\'a}n, P{\'e}rez, and Varona \cite{Dura14}\\
{\bf Certainly not.} -- Tim Daly\\
{\bf Yeah, well, that's just, like, your opinion, man}\\
-- Jeff Bridges, The Big Lebowski
\end{quote}

\begin{quote}
{\bf If programming is understood not as the writing of instructions for
this or that computing machine but as the design of methods of
computation that it is the computer's duty to execute, then it no
longer seems possible to distinguish the discipline of programming
from constructive mathematics.}\\
-- Per Martin-L\"of \cite{Mart79}
\end{quote}

\begin{quote}
{\bf Our basic premise is that the ability to construct and modify programs
will not improve without a new and comprehensive look at the entire
programming process. Past theoretical research, say, in the logic of
programs, has tended to focus on methods for reasoning about
individual programs; little has been done, it seems to us, to develop
a sound understanding of the process of programming -- the process by
which programs evolve in concept and in practice. At present, we lack
the means to describe the techniques of program construction and
improvement in ways that properly link verification, documentation and
adaptability.}\\
-- Scherlis and Scott (1983) in \cite{Maso86}
\end{quote}

\begin{quote}
{\bf The intrinsically discrete nature of symbol processing makes
programming such a tricky job that the application of formal
techniques becomes a necessity.}\\
-- Edsger W. Dijkstra \cite{Dijk83}
\end{quote}

\begin{quote}
{\bf The notion of a proof serves not only to organize information,
but to direct the analysis of a problem and produce the necessary
insights. It is as much an analytical tool as it is a final product.}\\
-- Bates and Constable \cite{Bate85}
\end{quote}

\begin{quote}
{\bf By June 1949 people had begun to realize that it was not so easy to
get programs right as at one time appeared. ... the realization came
over me with full force that a good part of the remainder of my life
was going to be spent in finding errors in my own programs.}\\
-- Maurice Wilkes \cite{Wilk85a}
\end{quote}

\begin{quote}
{\bf I believe the hard part of building software to be the
specification, design, and testing of this conceptual construct, not
the labor of representing it and testing the fidelity of the
representation. If this is true, building software will always be
hard. There is inherently no silver bullet.}\\
-- Fredrick P. Brooks Jr. \cite{Broo87}
\end{quote}

\begin{quote}
{\bf I hold the opinion that the construction of computer programs is
a mathematical activity like the solution of differential equations,
that programs can be derived from their specifications through
mathematical insight, calculation, and proof, using algebraic laws as
simple and elegant as those of elementary arithmetic.}\\
-- C. A. R. Hoare \cite{Fetz88}
\end{quote}

\begin{quote}
{\bf It might be said that programs are conjectures, while executions are
attempted refutations.}\\
-- James Fetzer \cite{Fetz88}
\end{quote}

\begin{quote}
{\bf The existence of the computer is giving impetus to the discovery of
algorithms that generate proofs. I can still hear the echos of the
collective sigh of relief that greeted the announcement in 1970 that
there is no general algorithm to test for integer solutions to
polynomial Diophantine equations; Hilbert's tenth problem has no
solution. Yet, as I look at my own field, I see that creating
algorithms that generate proofs constitutes some of the most important
mathematics being done. The all-purpose proof machine may be dead, but
tightly targeted machines are thriving.}\\
-- Dave Bressoud \cite{Bres93}
\end{quote}

\begin{quote}
{\bf In contrast to humans, computers are good at performing formal
processes. There are people working hard on the project of actually
formalizing parts of mathematics by computer, with actual formally
correct formal deductions. I think this is a very big but very
worthwhile project, and I am confident that we will learn a lot from
it. The process will help simplify and clarify mathematics. In not too
many years, I expect that we will have interactive computer programs
that can help people compile significant chunks of formally complete
and correct mathematics (based on a few perhaps shaky but at least
explicit assumptions) and that they will become part of the standard
mathematician's working environment.}\\
-- William P. Thurston \cite{Thur94}
\end{quote}

\begin{quote}
{\bf ...constructive mathematics provides a way of viewing the language of
logical propositions as a {\sl specification} language for
programs. An ongoing thrust of work in computer science has been to
develop program specification languages and formalisms for
systematically deriving programs from specifications. For constructive
mathematics to provide such a methodology, techniques are needed for
systematically extracting programs from constructive proofs. Early work
in this field includes that of Bishop and Constable \cite{Cons98}. What
distinguished Martin-L\"of's '82 type theory was that the method it
suggested for program synthesis was exceptionally simple: a direct
correspondence was set up between the constructs of mathematical
logic, and the constructs of a functional programming
language. Specifically, every proposition was considered to be
isomorphic to a type expression, and the proof of a proposition would
suggest precisely how to construct an inhabitant of the type, which
would be a term in a functional programming language. The term that
inhabits the type corresponding to a proposition is often referred to as
the {\sl computational content} of the proposition.}\\
-- Paul Bernard Jackson \cite{Jack95}
\end{quote}

\begin{quote}
{\bf Writing is nature's way of letting you know how sloppy your
thinking is. }\\
-- Guindon \cite{Lamp02}
\end{quote}

\begin{quote}
{\bf Mathematics is nature's way of letting you know how sloppy
your writing is.}\\
-- Leslie Lamport \cite{Lamp02}
\end{quote}

\begin{quote}
{\bf Type theory is nothing short of a grand unified theory of computation
unified with mathematics so ultimately there is no difference between
math and the code.}\\
-- Robert Harper \cite{Harp13}
\end{quote}

\begin{quote}
{\bf Informal proofs are algorithms. Formal proofs are code.}\\
-- Benjamin Pierce \cite{Pier17}
\end{quote}

\chapter{Why this effort will not succeed}

\begin{quote}
When something is important enough, you do it even if the odds
are not in your favor.\\
-- Elon Musk
\end{quote}

\begin{quote}
{\bf The ancient Greeks gave (western) civilization quite a few
gifts, but we should beware of Greeks bearing gifts. The gifts of theatre
and democracy were definitely good ones, and perhaps even the gift of
philosophy, but the 'gift' of the so-called 'axiomatic method' and the
notion of 'rigorous' proof did much more harm than good. If we want
to maximize Mathematical Knowledge, and its Management, we have to
return to Euclid this dubious gift, and give-up our fanatical insistence
on perfect rigor. Of course, we should not go to the other extreme, of
demanding that everything should be non-rigorous. We should encourage
diversity of proof-styles and rigor levels, and remember that nothing is
absolutely sure in this world, and there does not exist an absolutely
rigorous proof, nor absolute certainty, and 'truth' has many shades and
levels.}\\
-- Doron Zeilberger \cite{Zeil10}
\end{quote}

\begin{quote}
{\bf The thing that differentiates scientist is purely an artistic
ability to discern what is a good idea, what is a beautiful idea, what
is worth spending time on, and most importantly, what is a problem
that is sufficiently interesting, yet sufficiently difficult, that it
hasn't yet been solved, but the time for solving it has come now.}\\
-- Savas Dimopoulos; Stanford University
\end{quote}

\begin{quote}
{\bf Every morning one should wake up and reflect on the conceptual
and foundational significance of one's work.}\\
-- Harvey Friedman
\end{quote}

This is an effort to prove Axiom correct. That is, we wish to prove
that the algorithms provide correct, trustworthy answers.

All prior attempts at combinining a Computer Algebra system and a
Proof system raise the issue that the CAS is untrustworthy.

Axiom tries to encode mathematical algorithms. Unlike other systems it
is built on the scaffold of group theory which provides a sound
mathematical foundation. As such, it seems only reasonable that the
algorithms in Axiom can be proven correct, hence the project to Prove
Axiom Sane (PAS).

The PAS project will not succeed. This is perfectly obvious from the
outset. But, given the law of the excluded middle (that is, 
$A \lor ~A$) is not applicable in this case, the fact that the project
"does not succeed" does not imply failure. Learning will occur.

That said, we can list quite a few reasons why PAC will not succeed,
most of which are explained in more detail in \cite{Cyph17}. We
provide useful names for the likely criticisms presented there and
paraphrase those criticisms applied to our context.
\begin{enumerate}
\item {\bf Leap of Faith} All of these efforts either require making a
leap of faith to go from verified code to a real-world problem, or
required the use of an artificially restricted system in order to
function (the NewSpeak approach, create a language in which it is
impossible to think bad thoughts), indicating that formal verification
down to the binary code level is unlikely to be practical in any
generally accepted formal methods sense.
\item {\bf Tools for Toy Problems} The tools used to support formal
methods arose from an academic research envvironment characterised by
a small number of highly skilled users. The tools were tested on small
problems (usually referred to somewhat disparagingly as ``toy
problems'') which were targeted more at exercising the tools than
exercising the problem.
\item {\bf Opaque Specifications} Another factor which complicates the
use of formal methods is that the mathematical methods available to
software engineers are often very difficult to use and plagued by
notation which is cumbersome and hard to read and understand.
\item {\bf Too Large a Task} The national technology base for this
level of task is essentially non-existent. There do not appear to be
even 20 people in the world that have undertaken the essential
steps. ``In order to get a system with excellent system integrity, you
must ensure that it is designed and built by geniuses. Geniuses are in
short supply'' \cite{Blak96}.
\item {\bf False Axioms} Problems occur when a proof has to be
manually augmented with ``self-vidient'' truths which sometimes turn
out to be false and end up misguiding the prover.
\item {\bf Intellectual Cost} Requiring a proof of an algorithm adds to the
already outsized cost of creating the algorithm in Axiom, given the
steep intellectual hill such a system already presents.
\item {\bf Ripple Cost} Multiple layers of abstraction are required to
go from a proof to its implementation and a change in any of the
layers can result in a ripple effect as changes propagate. If a change
manages to propagate its way into a formally proven section, portions
of, or possibly all of, the proof might need to be redone.
\item {\bf Informal Implementation Details} Current techniques rarely
reach down any further than the high-level specificaiton resulting in
large amounts of time and energy being poured into producing a design
specification which is void of any implementation details.
\item {\bf Specification Mismatch} Formal proofs that a specification
is correct don't show that the assumptions made in the proof are
correct in the actual physical system. If the code which is supposed
to implement the formal specification doesn't quite conform to it or
the compiler can't produce an executable which quite matches what was
intended in the code then no amount of formal proving will be able to
guarantee the execution behaviour of the code.
\item {\bf Natural / Formal Mismatch} Natural language descriptions of
what is intended may mismatch the formal language descriptions. In
many cases ``common sense'' assumptions come into play which are never
formally stated.
\item {\bf Specification Flaws} The code may implement a specification
exactly as stated but the specification can be flawed.
\item {\bf Mis-implemented Specifications} The specification may be
correct but the implementation does not match the specification.
\item {\bf Specification Narrowing} The specification language may not
be sufficient to state all of the required concepts so a ``narrowing''
of the specification is made to approximate the intent.
\item {\bf Specification Widening} The specification language may
generalize the required concepts so a ``widening'' of the
specification is made beyond the required intent.
\item {\bf Specification Impedence Mismatch} The specification
language does not cover the concepts in the domain of interest,
requiring considerable effort to ``model'' the domain.
\item {\bf Specification Blindness} The specification writers can't
take into account every eventuality which will arise. As a result, an
implemention of a specification doesn't just implement it, it alters
it in order to fit real-world constraints which weren't foreseen by
the original authors of the specification.
\item {\bf Contradictory Proofs} If the system is inconsistent, it would
be possible to find two contradictory proofs. It is likely that such
an inconsistency will not be detected and only one of the proofs will
be accepted since the other one is never generated.
\item {\bf Likely to be Ignored} There are thousands of proofs published,
most of which are ``write only'' and are never checked. This is likely
to be the case with Axiom's proofs.
\item {\bf Proven Programs are Wrong} It is possible to prove a
program correct and still get wrong results. Testing is still
required.
\item {\bf Proofs are a Social Process} Axiom's ``social circle'' is
vanishingly small.
\item {\bf Chicken and Egg} Do proofs follow from programs or programs
follow from proofs? 
\item {\bf Boiling the Ocean} The task is much too large.
\item {\bf MetaTheory Cost} There is a cost to developing theories for
new data types; these are unnecessary ``meta'' costs.
\item {\bf Partial Functions} Not all of the functions are total so it
is difficult to prove theorems about them.
\item {\bf Undecidable Theories} Some theories are known to be
undecidable so there will be problems with their proofs.
\end{enumerate}

Fenton \cite{Fent93} states that there is no hard evidence to show that
\begin{enumerate}
\item formal methods have been used cost effectively on a real
safety-critical system development
\item the use of formal methods can deliver reliability more cost
effectively than traditional structured methods with enhanced testing
\item sufficient numbers of either developers or users can ever be
trained to make proper use of formal methods
\end{enumerate}

Calude, et al. \cite{Calu07} take a quite different attack on the idea
of proving and programming, specifically
\begin{enumerate}
\item Theorems (in mathematics) correspond to algorithms and not
programs (in computer science); algorithms are subject to mathematical
proofs (for example correctness)
\item The role of proof in mathematical modeling is very small:
adequacy is the main issue
\item Programs (in computer science) correspond to mathematical
models. They are not subject to proofs, but to an adequacy and
relevance analysis; in this type of analysis, some proofs may
appear. Correctness proofs in computer science (if any) are not
cost-effective. 
\item Rigour in programming is superior to rigour in mathematical
proofs.
\item Programming gives mathematics a new form of understanding
\item Although the Hilbertian notion of proof has few chances to
change, future proofs will be of various types and will play different
roles, and their truth will be checked differently.
\item In general, correctness is undecidable
\item for most non-trivial cases, correctness is a monumental task
which gives an added confidence at a disproportionate cost.
\end{enumerate}

Still another attack comes from Hoare \cite{Hoar96} which states that
"By surveying current software engineering practice, this paper
reveals that the techniques employed to achieve reliability are little
different from those which have proved effective in all other branches
of modern engineering: rigorous management of procedures for design
inspection and review; quality assurance based on a wide range of
targeted tests; continuous evolution by removal of errors from
products already in widespread use; and defensive programming, among
other forms of deliberate over-engineering. Formal methods and proof
play a small direct role in large scale programming; but they do
provide a conceptual framework and basic understanding to promote the
best of current practice, and point directions for future
improvement."

Fetzer \cite{Fetz88} adds
"The notion of program verification appears to trade upon an
equvocation. Algorithms, as logical structures, are appropriate
subjects for deductive verification. Programs, as causal models of
those structures, are not. The success of program verification as a
generally applicable and completely reliable method for guaranteeing
program performance is not even a theoretical possibility."

An unnamed letter writer to the CACM says "It is time somebody said it
-- loud and clear -- the formal approach to software verification does
not work now and probably never will." \cite{Glas02}

DeMillo et al. \cite{Demi79} says
"It is argued that formal verifications of programs, no matter how
obtained, will not play the same key role in the development of 
computer science and software engineering as proofs do in mathematics.
Furthermore the absence of continuity, the inevitability of change, and
the complexity of specification of significantly many real programs
make the formal verification process difficult to justify and manage.
It is felt that ease of formal verification should not dominate program
language design.",

DeMillo argues that proofs are social constructs. "Mathematiical
proofs increase our confidence in the truth of mathematical statements
only after they have been subjected to the social mechanisms of the
mathematical community. These same mechanisms doom the so-called
proofs of software, the long formal verifications that correspond, not
to the working mathematical proof, but to the imaginary logical
structure that the mathematician conjures up to describe his feeling
of belief. Verifications are not messages, a person who ran out into
the hall to communicate his latest verification would rapidly find
himself a social pariah. Verifications cannot really be read; a reader
can flay himself through one of the shorter ones by dint of heroic
effort, but that's not reading. Being unreadable and -- literally --
unspeakable, verifications cannot be internalized, transformed,
generalized, used, connected to other disciplines, and eventually
incorporated into a community consciousness. They cannot acquire
credibility gradually, as a mathematical theorem does; one either
believes them blindly, as a pure act of faith, or not at all."

And still more with "There is a fundamental logical objection to
verification, an objection on its own ground of formalistic
rigor. Since the requirement for a program is informal and the program
is formal, there must be a transition, and the transition itself must
necessarily be informal."

And "So, having for the moment suspended all rational disbelief, let
us suppose that the programmer gets the message ``VERIFIED.'' And let
us suppose further that the message does not result from a failure on
the part of the verifying system. What does the programmer know? He
knows that his program is formally, logically, provably, certifiably
correct. He does not know, however, to what extent it is reliable,
dependable, trustworthy, safe; he does not know within what limits it
will work; he does not know what happens when it exceeds those
limits. And yet he has that mystical stamp of approval ``VERIFIED.''"

Manna and Waldinger \cite{Mann78} mentions
\begin{enumerate}
\item We can never be sure that the specifications are correct
\item No verification system can verify every correct program
\item We can never be certain that a verification system is correct
\end{enumerate}

Hall \cite{Hall90} presents 7 myths of formal methods.
\begin{enumerate}
\item Formal methods can guarantee that software is perfect.
\item They work by proving that programs are correct.
\item Only highly critical systems benefit from their use.
\item They involve complex mathematics.
\item They increase the cost of development.
\item They are incomprehensible to clients.
\item Nobody uses them for real projects.
\end{enumerate}

Bowen and Hinchey \cite{Bowe95} follow up with 7 more myths.
\begin{enumerate}
\item Formal methods delay the developent process
\item Formal methods lack tools
\item Formal methods replace traditional engineering design methods
\item Formal methods only apply to software
\item Formal methods are unnecessary
\item Formal methods are not supported
\item Formal methods people always use formal methods
\end{enumerate}

Murray and Oorschot \cite{Murr18} provide comments that, while they
are indented for security-related proofs, also apply to proofs in
general. We paraphrase the comments that we feel are relevant to all
proofs. 

Proofs have been used as a means to aid the development of systems for
at least the past five decades. There has been much debate about
proof's role in developing software and systems, including its
practicality for mainstream software and relevance for reasoning about
the real-world.

There has been a rash of large-scale software verification projects
that have resulted in the construction of software systems, whose
assurance is backed by (machine-checked) proofs about the software's
behaviour.

As an assurance mechanism proof remains poorly understood expecially
outside of formal verification practitioners and researchers.

Proof surely delivers many benefits, and examples abound of defects
and vulnerabilities found during the process of proving (a property
about) a system that led to improvements in the system that might have
been unlikely otherwise. Proof also brings with it its own 
{\sl side effects} (code changes and deployment constraints), not all
of which may be positive for the system and some of which might even
be negative (aside from on performance).

There is both confusion, and wide veriety of interpretations by
different stakeholders and communities, about the value and role of
formal proofs in the construction of systems.

What is the value of a formal proof if it cannot establish properties
of the real system?

The most common interpretation of the meaning of a proof is that it
provides {\sl guarantees} about a system. This perspective is perhaps
strongest {\sl outside} of the formal methods community. {\sl Within}
the formal methods community -- i.e., those practising formal
verification -- things are more nuanced. This apparent contraiction --
frequent in the literature, and not to be discounted as a source of
confusion -- is resolved by observing that a proof provides guarantees
subject to the accuracy of the model and proof assumptions, i.e.,
provides guarantees about the real world when, and only when, the
formal model of the system matches the system's real-world behaviour
with respect tot he property being proven.

All proofs have assumptions. Yet, as noted by DeMillo, Lipton, and
Perlis in their infamous critique of formal methods \cite{Demi79},
what sets formal verification of software apart from proofs in pure
mathematics is their sheer volume of assumptions.

One conclusion about the value of formal proofs is that they allow an
evaluator to concentrate their efforts on validating the accuracy of
the proof's assumptions, enabling them to ignore large partf of the
implementation. The value of a formal guarantee is that it
concentrates remaining doubt on the assumptions.

An alternaitve perspective is that the value in proofs is not to
provide (qualified) guarantees, but instead to force careful and
rigorous understanding of a systme and its operation. There is no
question that proof processes generate more robust code. Yet the
general consensus seems to be that this robustness is much more an
emergent consequence of rigorously understanding the problem than a
result of the proof discharge. If discharging the entire proof is
merely a side effect, we note that under this point of view even
{\sl partial} proofs have value. The same is less clear for the
viewpoint of proofs as qualified guarantees, since an unfinished proof
provides no quarantees about the formal object under study.

Interative proofs provide a critical mechanism for performing
structured, interactive exploration of a system (via a formal
model). Carrying out the proof forces the human to carefully examine
each part of the system model, and allows human intuition to bring to
light issues that might be missed by the proof itself.

Proofs have some established ideas on their benefits: providing
qualified guarantees, allowing auditors to concentrate effor on
validating proof assumptions and the formal model; providing a means
for structured exploration of a system to better understand and
improve it. 

Yet against these benefits stand proof's disadvantages, which as with
proof itself, remain poorly understood expecially outside the formal
methods community. One is proof {\sl brittleness}: e.g., changing one
line of code can potentially invalidate large amounts of formal
reasoning. It is difficult to judge the guarantees provided by a proof
when even {\sl one} proof assumption deviates from reality. Another is
a dearth of techniques for reliably predicting the cost of formal
methods. Still another is the difficulty that both non-experts and
experts have in discerning precisely the nature of the formal property
that a proof establishes, and the difficulty of validating implicit
assumptions in large-scale mormal models on which such proofs
rest. This leaves plenty of room for gaps between what non-expert
might {\sl think} has been proven and the precise formal property 
{\sl acutally} proven.

There are effects {\sl on the system}, both beneficial and otherwise,
for which proof is a proximate cause -- i.e., concrete effects on the
system brought about directly as a result of performing the proof. We
refer to these as the {\sl side effects} of a proof.

A proof might {\sl induce} two kinds of side effects on the system.
One is {\sl changes to the code} either to fix a bug found during the
proof or to modify some aspect of the design or implementation to open
a path enabling a proof. A second is {\sl deployment constraints}
imposed on the system to enforce {\sl environmental assumptions}
necessary for proofs.

\section{General problems with formal verification}

In Moy and Wallenburg \cite{Moyx10} we find:
\begin{enumerate}
\item Formal verification is not applied to all parts of a
system. Around a formally verified core, there are usually parts of
the system that cannot be verified formally, because they deal with
interfacing with other systems or a user, or because it would be too
costly to verify them (effort/time/money). The cost/benefit ratio of
formal verification is parricularly important to take into account for
those less critical parts.
\item Formal verification is only as strong as the specification
is. When formally verifying the absence of run-time errors in
programs, the specification is given by the semantics of the
programming language. However, in general there is no way to ``guess''
the intended meaning of some part of a system, but the developer has
to indicate it in a specificaiton. Writing specifications can be as
error-prone as writing programs. In practice, these specifcations are
not complete functional specifications, as this would be much too
costly. Only the properties that a developer specified can be formally
verified. 
\item Formal verification techniques do not target all desirable
properties of programs. Most formal verification frameworks verify the
absence of run-time errors, and perperties expressed by developers are
invariants or function contracts. In particular, formal verification
techniques are not usually good at detecting dead code and ``strange''
code (inefficient or unidiomatic code), or covert channels.
\item The formal verification method itself may be flawed, for example
if the immplementation of the underlying theorem prover or static
analyzer contains problems.
\end{enumerate}

\chapter{Progress Will Occur}

At the very lowest level there have been some truly impressive steps
toward formal verification of low-level implmentation details.

Reid \cite{Reid17} has created and verified a huge specification (over
1/2 Million nodes) of the ARM processor. The specification passes
almost every test in their huge (11k) test suite. Using the
specification with an SMT Solver allows the ability to do things like
ask what input will give the known output, for example.

Chlipala has done both machine-level \cite{Chli17a} and higher-level
 \cite{Chli17} formal proofs. He claims that within 10 years it will be
normal to have deployed computer systems with top-to-bottom correctness
proofs which were checked algorithmically.

Establishing that the algorithm is correct (e.g. Groebner) is clearly
in the proof side of coputational math.

Establishing that there is an implementation of Groebner is clearly in
the computer algebra side of computational math.

The game is to unite the two.

Such a proof becomes a {\bf part} of the specification of a program
that implements the algorithm, such as in Axiom.

The definitions and axioms of the proof have to be put into the system
both at the category and domain levels They need to be available at
the implementation code.

On the other hand, there are non-logical 'axioms' of categories and
domains, such as limits to the size of a floating point number.

The Axiom approach is to have many FLOAT domains, such as Gustafson's
UNUM \cite{Gust16a}.

An alternative is to have a symbolic Integer domain that uses symbols
rather than numbers.

There are non-logical limits to the implementation, such as
intermediate expression swell that uses up all of memory. It isn't
possible to write a specification that can detect all of these kinds
of failures before they occur. But there are logical ways to handle
such boundaries.

In logic there are ``product types'' which are basically multi-field
records. There are ``sum types'' which are disjoint unions.

Axiom's approach to reaching limits of computation is to return a
sum-type that is either the result or ``failed''. The failed result
needs to be explicitly carried in the proof. Because failed is a valid
result, the specification can be expanded to include this as a valid
result. 

Just because a program can fail there is no reason to say that it
can't be proven, given that ``failed'' is a valid result.

One could even expand the sum types to include inforation about the
failure so that ``failed'' would be a product type that said why it
failed. That allows another domain to be used. 

In fact, one could introduce a FAILED domain in Axiom with a 'why?'
function. Local domains could extend FAILED with their own 'why?'
function specific to their possible failures.

Axiom has the ability to have multile domains that can overcome
limits, e.g. small floats, large floats, unums. These would allow
users to 'retry' a computation with different assumptions.

The issue, as raised by william Sit, is important. Some algorithms in
Axiom have ``hand waving'' specifications that need to be expanded to
properly return 'failed' when that is expected. This is a 'good thing'
and a useful by-product of combining proof and computer algebra.

\chapter{Here is a problem}

\begin{quote}
The world needs both logicians and verifiers, and we need one
another. Logicians need verifiers to keep their work relevant, and
verifiers need logicians to keep them honest. (In typical human
fashion, most logicians think they know all they need to about real
verification problems for developing theories, and most verifiers
think they know enough about logic to verify programs. They're
probably both wrong.)\\
-- Lamport and Owicki \cite{Lamp81}
\end{quote}

Axiom has a domain-specific language for mathematical computation
called Spad. This is implemented in Common Lisp. Our version of
Common Lisp compiles to C. The C code is then compiled to machine
code. The machine code is executed by a physical machine.

There are various attacks on each of these areas. We will be 
addressing them all at some point, from the mathematical specification,
through the Spad code all the way down to the hardware timing signals. 

One useful technique to exploit is mentioned by Myreen, Slind, and
Gordon \cite{Myre09a}. They 'forward compile' the code to $f$, collect
the result as $f^\prime$, and then prove the $f=f^\prime$. This proof
is sufficient to show that the compile step is correct.

\section{Proving the Algebra}
\subsection{Defining the Spad syntax}
\subsection{Defining the Spad semantics}

Gordon \cite{Gord89} describes formal reasoning about programs that
can be based directly on the semantics of the programming language, or
done in a special purpose logic like Hoare logic.

O'Donnell \cite{Odon81} raises questions about the logical soundness
of rules used in Hoare logic reasoning.

Manna and Waldinger \cite{Mann78a} introduce the notion of 
{\sl sometime} as a conditional invariant that sometimes is true.

Floyd \cite{Floy67}, Back \cite{Back81}, Caldwell \cite{Cald97},
Filliatre \cite{Fill03}, Filliatre and Paskevich \cite{Fill13}

\subsection{Type Resolution}

In Kaes \cite{Kaes88} we find that there is a semantical difference
between overloading and polymorphism: in the case of the overloaded
$+$ operator, we would expect different code to be executed for
integer and real addition respectively, whereas we expect the code of
$len$ to be usable for lists of any type. This distinction has led to
the name ``adhoc polymorphism''.

{\bf Parametric Polymorphism}: One semantic object can have different
types at each usage, all being instances of a single type expression
over variables.

{\bf Overloading} (``adhoc polymorphism''): A single name can be used
to denote different semantic objects, the types of these objects being
completely unrelated.

{\bf Parametric Overloading}: A single name can be used to denote
several objects, the types of these objects being instances of a
single type expression over some extended set of type variables.

Cardelli and Wegner \cite{Card85} refines Strachey by introducing a
new form of polymorphism called {\sl inclusion polymorphism} to model
subtypes and inheritance. Parametric and inclusion polymorphism are
classified as the two major subcategories of ``universal
polymorphism'' which is contrasted with nonuniversal or ad-hoc
polymorphism. 
\begin{verbatim}
                               |- parametric
                 |- universal -|
                 |             |- inclusion
   polymorphism -|                 
                 |             |- overloading
                 |- ad hoc    -|
                               |- coercion
\end{verbatim}

Parametric polymorphism is so called because the uniformity of type
structure is normally achieved by type parameters, but uniformity can
be achieved in different ways, and this more general concept is called 
{\sl universal polymorphism}. Universally polymorphic functions will
normally work on an infinite number of types (all the types having a
given common structure), whereas an ad-hoc polymorphic function will
only work on a finite set of different and potentially unrelated
types.

In {\sl parametric polymorphism}, a polymorphic function has an
implicit or explicit type parameter which determines the type of the
argument for each application of that function. In {\sl inclusion
polymorphism} an object can be viewed as belonging to many different
classes that need not be disjoint; that is, there may be inclusion of
classes. 

There are at least 4 kinds of escapes from a monomorphic type.
\begin{itemize}
\item {\sl Overloading}: Integer constants may have both type integer
and real.
\item {\sl Coercion}: An integer value can be used where a real is
expected, and vice versa.
\item {\sl Subtyping}: Elements of a subrange type also belong to
superrange types. 
\item {\sl Value Sharing}: {\tt nil} in Pascal is a constant that is
shared by all the pointer types.
\end{itemize}

Wadler and Blott \cite{Wadl88} point out that it would be nice if
polymorphic equality could be extended to include user-defined
equality operations over abstract types. To implement this, we would
need to require that every object carry with it a pointer to a 
{\sl method}, a procedure for performing the equality test. If we are
to have more than one operation with this property, then each object
should carry with it a pointer to a {\sl dictionary} of appropriate
methods. 

In the case of polymorphic equality, this means that {\sl both}
arguments of the equality function will contain a pointer to the same
dictionary (since they are both of the same type). This suggests that
perhaps dictionaries should be passed around independently of objects,
now polymorphic equality would be passed one dictionary and two
objects (minus dictionaries). This is the intuition behind type
classes and the translation method they describe.

It is natural to think of adding assertions to the class declaration,
specifying properties that each instance must satisfy:
\begin{verbatim}
   class EQ a where
     (==) :: a -> a -> Bool
     % (==) is an equivalence relation

   class Num a where
     zero, one :: a
     (+), (*) :: a -> a -> a
     negate :: a -> a
     % (zero, one, (+), (*), negate) form a ring

\end{verbatim}

It is valid for any proof to rely on these properties, so long as one
proves that they hold for each instance declaration. Here the
assertions have simply been written as comments; a more sophisticated
system could perhaps verify or use such assertions.

It is reasonable to allow a class to apply to more than one type
variable. For instance, we might have 
\begin{verbatim}
   class Coerce a b where
     coerce :: a -> b

   instance Coerce Int Float where
     coerce - convertIntToFloat

\end{verbatim}

In this case, the assertion {\tt Coerce a b} might be taken as
equivalent to the assertion that {\tt a} is a subtype of {\tt b}. This
suggests a relation between this work and work on bounded
quantification and on subtypes.

\section{Proving the Logic}

Soundness has two aspects, closed world and open world. \cite{Bonn18}

Closed world soundness assumes all progremas are type checked by the
same type system. Open world soundness not only require closed world
soundness, but also that the guarantees upheld under closed world
assumptions cannot be broken by foreign code. The introduction and
consideration of foreign code is the essential difference between
open-world and closed world soundness. See gradual-typing.

Proving programs correct involves working with a second programming
language, the proof language, that is well-founded on some theory.
Proofs (programs), can be reduced (compiled) in this new language
to the primitive constructs (machine language).

The ideal case would be that the programming language used, such as
Spad, can be isomorphic, or better yet, syntactically the same as
the proof language. Unfortunately that is not (yet?) the case with Spad.

The COQ system language, Gallina, is the closest match to Spad.

Barras and Werner \cite{Barr18} formalize the definition and the
metatheory of the Calculus of Constructions (CC) using the proof
assistant Coq. In particular, we prove strong normalization and
decidability of type inference. From the latter proof, we extract
a certified Objective Caml program which performs type inference
in CC and use this code to build a small-scale certified proof-checker.

Gordon \cite{Gord89} derives the rules of Hoare logic
{\sl mechanically} from the semantics of a simple imperative
programming language.

Igarashi et al. \cite{Igar75} 
defined a program to compute the
subgoals from a program and its post-condition.

Katz and Manna \cite{Katz75} look at various methods of proving
termination including
\begin{itemize}
\item using the 'no-infinitely-descending-chain property of
well-founded sets (Floyd's approach)
\item bounding a counter associated with each loop ({\sl loop}
approach)
\item showing that some exit of each loop must be taken ({\sl exit}
approach)
\item inducting on the structure of the data domain (Burstall's
approach)
\end{itemize}

Davis \cite{Davi09},
Myreen and Davis \cite{Myre11}, Myreen and Davis \cite{Myre14},
Davis and Myreen \cite{Davi15}

\subsection{Typing and Subtyping}

Dolan's PhD Thesis \cite{Dola16} on Algebraic Subtyping. 
Henri Tuhola \cite{Tuho18} notes that
solving the problem of subtyping does not directly solve the problem
of coercion. Coercion extends the type and doesn't narrow it. 

Dolan and Mycroft \cite{Dola17} note that, given
\begin{verbatim}
   select p v d = if (p v) then v else d
\end{verbatim}
only by ignoring the
orientation of the data flows could we conclude that $d$'s type flows
to the argument of $p$, even though $p$ never mentions $d$. ML's type
inference turns data flows into equality constraints between types so
information about the {\sl direction} of data flow is ignored. Since
equality is symmetric, data flow is treated as unidirectional. But
support for subtyping cares about the direction of data flow. With
subtyping, a source of data must provide at least the guarantees that
the destination requires, but is free to provide more.

\subsection{Defining the Algebra specifications}

Talpin and Jouvelot \cite{Talp92}

\subsection{Termination}

Hughes \cite{Hugh90} talks about a lazy approach to termination, while
gluing programs together. Functional languages allow whole progams to
be glued together. A complete functional program is just a function
from its inputs to its output. If $f$ and $g$ are such programs, then 
$(g \cdot f)$ is a program that, when applied to its input, computes
\[g (f {\rm\ input})\]
The program $f$ computes its output, which is used as the input to
program $g$. This might be implemented conventionally by storing the
output from $f$ in a temporary file. The problem with this is that the
temporary file might occupy so much memory that it is impractical to
glue the programs together in this way. Functional languages provde a
solution to this problem. The two programs $f$ and $g$ are run
together in strict synchronization. Program $f$ is started only when
$g$ is trying to read. Then $f$ is suspended and $g$ is run until it
ties to read another input. As an added bonus, if $g$ terminates
without reading all of $f$'s output, then $f$ is aborted. Program $f$
can even be a nonterminating program, producing an infinite amount of
output, since it will be terminated forcibly as soon as $g$ is
finished. This allows termination conditions to be separated from loop
bodies -- a powerful modularization.

Since this method of evaluation runs $f$ as little as possible, it is
called ``lazy evaluation''. It makes it practical to modularize a
program as a generator that constructs a large number of possible
answers, and a selector that chooses the appropriate one.

{\bf IDEA:} write (lazy $f$) for non-terminating programs to simplify
proofs. 

Sites \cite{Site74} offers some thoughts on proving clean termination
of programs.

Katz and Manna \cite{Katz75} take a closer look at termination.

\section{Proving the Lisp}

Guttman, et al. \cite{Gutt95} in the VL!SP project showed how to
produce a comprehensively verified implementation for a
programming language, namely Scheme.

Leroy \cite{Lero09} describes the development and formal verification
(proof of semantic preservation) of a compiler back-end from Cminor 
(a simple imperative intermediate language) to PowerPC assembly code,
using the Coq proof assistant.

Manolios and Moore \cite{Mano03} describe a method for introducing
'partial functions' in to ACL2. This is necessary for Common Lisp
as most functions are not total.

Myreen \cite{Myre12}

\section{Proving the Compiler}

Myreen \cite{Myre10}

\section{Proving to the metal}

Myreen, Slind, and Gordon \cite{Myre09a} presents a compiler which
produces machine code from functions defined in the logic of a theorem
prover, and at the same time proves that the generated code executes
the source functions.

Myreen and Gordon \cite{Myre09}, 

Gordon, et al. \cite{Gord06} describes a compiler that automatically 
translates recursive function definitions in higher order logic to 
clocked synchronous hardware Compilation is by mechanised proof in 
the HOL4 system. In particular, this models functions as circuits.

Domipheus \cite{Domi18} provides a VHDL (hardware description language)
CPU which provides the actual electrical timing of signals all the way
up to a machine language which consists of

\begin{tabular}{ll}
\hline
OPERATION & FUNCTION\\
\hline
Add & D = A + B\\
Substrct & D = A - B\\
Bitwise Or & D = A or B\\
Bitwise Xor & D = A xor B\\
Bitwise And & D = A and B\\
Bitwise Not & B = not A\\
Read & D = Memory[A]\\
Write & Memory[A] = B\\
Load & D = 8-bit immediate value\\
Compare & D = cmp(A,B)\\
Shift Left & D = A $<<$ B\\
Shift Right & D = A $>>$ B\\
Jump/Branch & PC = A Register or Immediate Value\\
Jump/Brance conditionally & PC = Register if (condition) else nop\\
\hline
\end{tabular}

\section{Setting up the problem}

The GCD function will be our first example of a proof.

The goal is to prove that Axiom's implementation of 
the Euclidean GCD algorithm is correct.

We need to be clear about what is to be proven. In this case, we
need to show that, given GCD(a,b),
\begin{enumerate}
\item {\bf GCD} is a function from $a\times b \Rightarrow c$
\item {\bf a} and {\bf b} are elements of the correct type
\item {\bf c}, the result, is the correct type
\item the meaning of {\bf divisor}
\item the meaning of a {\bf common divisor}
\item {\bf GCD} terminates
\end{enumerate}

We next need to set up the things we know in "the global environment",
generally referred to as {\bf E} in Coq.

Axiom's GCD is categorically defined to work over any Euclidean domain.
This means that the axioms of a Euclidean domain are globally available.
In fact, this is stronger than we need since
\begin{itemize}
\item commutative rings $\subset$ integral domains
\item integral domains $\subset$ integrally closed domains
\item integrally closed domains  $\subset$ GCD domains
\item GCD domains $\subset$ unique factorization domains
\item unique factorization domains $\subset$ principal ideal domains
\item principal ideal domains $\subset$ Euclidean domains
\end{itemize}

A Euclidean function on $R$ is a function $f$ from $\mathbb{R}\\\{0\}$
to the non-negative integers satisfying the following fundamental 
division-with-remainder property \cite{WikiED}:

$D(a,b)$ = set of common divisors of $a$ and $b$.

$\gcd(a,b) = \max{D(a,b)}$


\section{Axiom NNI GCD}

NonNegativeInteger inherits {\tt gcd} from {\tt Integer} up the ``add chain''
since it is a subtype of {\tt Integer}. {\tt Integer} has {\tt EuclideanDomain}
as an ancestor \cite{Book103}:
\begin{verbatim}
(1) -> getAncestors "Integer"

   (1)
   {AbelianGroup, AbelianMonoid, AbelianSemiGroup, Algebra, BasicType,
    BiModule, CancellationAbelianMonoid, CharacteristicZero, CoercibleTo,
    CombinatorialFunctionCategory, CommutativeRing, ConvertibleTo,
    DifferentialRing, EntireRing, EuclideanDomain, GcdDomain,
    IntegerNumberSystem, IntegralDomain, LeftModule, LeftOreRing,
    LinearlyExplicitRingOver, Module, Monoid, OpenMath, OrderedAbelianGroup,
    OrderedAbelianMonoid, OrderedAbelianSemiGroup,
    OrderedCancellationAbelianMonoid, OrderedIntegralDomain, OrderedRing,
    OrderedSet, PatternMatchable, PrincipalIdealDomain, RealConstant,
    RetractableTo, RightModule, Ring, Rng, SemiGroup, SetCategory, StepThrough,
    UniqueFactorizationDomain}
                                                            Type: Set(Symbol)
\end{verbatim}

From category {\tt EuclideanDomain} (EUCDOM) we find the implementation of 
the Euclidean GCD algorithm \cite{Book102}:
\begin{verbatim}
      gcd(x,y) ==                --Euclidean Algorithm
         x:=unitCanonical x
         y:=unitCanonical y
         while not zero? y repeat
            (x,y):= (y,x rem y)
            y:=unitCanonical y   -- this doesn't affect the
                                 -- correctness of Euclid's algorithm,
                                 -- but
                                 -- a) may improve performance
                                 -- b) ensures gcd(x,y)=gcd(y,x)
                                 --    if canonicalUnitNormal
         x
\end{verbatim}
The {\tt unitCanonical} function comes from the category 
{\tt IntegralDomain} (INTDOM) where we find:
\begin{verbatim}
    unitNormal: % -> Record(unit:%,canonical:%,associate:%)
        ++ unitNormal(x) tries to choose a canonical element
        ++ from the associate class of x.
        ++ The attribute canonicalUnitNormal, if asserted, means that
        ++ the "canonical" element is the same across all associates of x
        ++ if \spad{unitNormal(x) = [u,c,a]} then
        ++ \spad{u*c = x}, \spad{a*u = 1}.
    unitCanonical: % -> %
        ++ \spad{unitCanonical(x)} returns \spad{unitNormal(x).canonical}.
\end{verbatim}
implemented as
\begin{verbatim}
      UCA ==> Record(unit:%,canonical:%,associate:%)
      if not (% has Field) then
        unitNormal(x) == [1$%,x,1$%]$UCA -- the non-canonical definition
      unitCanonical(x) == unitNormal(x).canonical -- always true
      recip(x) == if zero? x then "failed" else _exquo(1$%,x)
      unit?(x) == (recip x case "failed" => false; true)
      if % has canonicalUnitNormal then
         associates?(x,y) ==
           (unitNormal x).canonical = (unitNormal y).canonical
       else
         associates?(x,y) ==
           zero? x => zero? y
           zero? y => false
           x exquo y case "failed" => false
           y exquo x case "failed" => false
           true
\end{verbatim}

Coq proves the following GCD function:
\begin{verbatim}
  Fixpoint gcd a b :=
    match a with
      | 0 => b
      | S a' => gcd (b mod (S a')) (S a')
    end.
\end{verbatim}

This can be translated directly to working Spad code:
\begin{verbatim}
  GCD(x:NNI,y:NNI):NNI ==
    zero? x => y
    GCD(y rem x,x)
\end{verbatim}
with the test case results of:
\begin{verbatim}
(1) -> GCD(2415,945)
   Compiling function mygcd2 with type (NonNegativeInteger,
      NonNegativeInteger) -> NonNegativeInteger 

   (1)  105
                                                        Type: PositiveInteger
(2) -> GCD(0,945)

   (2)  945
                                                        Type: PositiveInteger
(3) -> GCD(2415,0)

   (3)  2415
                                                        Type: PositiveInteger
(4) -> GCD(17,15)

   (4)  1
                                                        Type: PositiveInteger
\end{verbatim}

\section{Mathematics}

From Buchberger \cite{Buch97},

Define ``divides''
\[ t\vert a \Longleftrightarrow \exists u (t \cdot u = a)\]

Define ``greatest common divisor''
\[ {\rm GCD}(a,b) = \forall t\ max(t\vert a \land t\vert b)\]

Theorem:
\[ (t\vert a \land t\vert b) \Longleftrightarrow t\vert (a-b) \land t\vert b\]

Euclid's Algorithm
\[ a > b \Rightarrow {\rm GCD}(a,b) = {\rm GCD}(a-b,b)\]

By the definition of GCD we need to show that
\[\forall t\ max(t\vert a \land t\vert b) =
  \forall t\ max(t\vert (a-b) \land t\vert b)\]

Thus we need to show that
\[(t\vert a \land t\vert b) \Longleftrightarrow (t\vert (a-b) \land t\vert b)\]

Let $t$ be arbitrary but fixed and assume
\begin{equation}\label{eq1}(t\vert a \land t\vert b)\end{equation}

We have to show
\begin{equation}\label{eq2}t\vert (a-b)\end{equation}

and
\begin{equation}\label{eq3}t\vert b\end{equation}

Equation \ref{eq3} follows propositionally. For equation \ref{eq2},
by definition of ``divides'', we have to find a $w$ such that
\begin{equation}\label{eq4}t \cdot w = a-b\end{equation}

From \ref{eq1}, by definition of ``divides'', we know that for certain
$u$ and $v$
\[t \cdot u = a\]

and
\[t \cdot v - b\]

Hence,
\[ a-b = t \cdot u - t \cdot v\]

But
\[t \cdot u - t \cdot v = t \cdot (u - v)\]

So we need to find
\[w = u - v\]

and 
\[\textrm{Find w such that }t \cdot u - t \cdot v = t \cdot w\]


\section{Approaches}
There are several systems that could be applied to approach the proof.

The plan is to initially look at Coq and ACL2.  Coq seems to be
applicable at the Spad level. ACL2 seems to be applicable at the Lisp
level. Both levels are necessary for a proper proof.

Coq is very close to Spad in spirit so we can use it for the
high-level proofs.

ACL2 is a Lisp-level proof technology which can be used to prove
the Spad-to-Lisp level.

There is an LLVM to ACL2 translator which can be used to move from
the GCL Lisp level to the hardware since GCL compiles to C.
In particular, the "Vellvm: Verifying the LLVM" \cite{Zdan14}
project is important.

Quoting from Hardin \cite{Hard14}
\begin{quote}
LLVM is a register-based intermediate in Static Single Assignment
(SSA) form. As such, LLVM supports any number of registers, each of
which is only assigned once, statically (dynamically, of course, a
given register can be assigned any number of times). Appel has
observed that ``SSA form is a kind of functional programming''; this
observation, in turn, inspired us to build a translator from LLVM to
the applicative subset of Common Lisp accepted by the ACL2 theorem
prover. Our translator produces an executable ACL2 specification that
is able to efficiently support validation via testing, as the
generated ACL2 code features tail recursion, as well as in-place
updates via ACL2's single-threaded object (stobj) mechanism. In order
to ease the process of proving properties about these translated
functions, we have also developed a technique for reasoning about
tail-recursive ACL2 functions that execute in-place, utilizing a
formally proven ``bridge'' to primitive-recursive versions of those
functions operating on lists.
\end{quote}

{\center{\includegraphics{ps/v13llvmtoacl2.eps}}}

Hardin \cite{Hard13} describes the toolchain thus:
\begin{quote}
Our translation toolchain architecture is shown in Figure 1. The left
side of the figure depicts a typical compiler frontend producing LLVM
intermediate code. LLVM output can be produced either as a binary
``bitcode'' (.bc) file, or as text (.ll file). We chose to parse the
text form, producing an abstract syntax tree (AST) representation of
the LLVM program. Our translator then converts the AST to ACL2
source. The ACL2 source file can then be admitted into an ACL2
session, along with conjectures that one wishes to prove about the
code, which ACL2 processes mostly automatically. In addition to
proving theorems about the translated LLVM code, ACL2 can also be used
to execute test vectors at reasonable speed.
\end{quote}

Note that you can see the intermediate form from clang with
\begin{verbatim}
clang -O4 -S -emit-llvm foo.c
\end{verbatim}

Both Coq and the Hardin translator use OCAML \cite{OCAM14} so we will have to
learn that language.

\chapter{Theory}
The proof of the Euclidean algorithm has been known since Euclid.
We need to study an existing proof and use it to guide our use of
Coq along the same lines, if possible. Some of the ``obvious''
natural language statements may require Coq lemmas.

From WikiProof \cite{Wiki14a} we quote:

Let \[a, b \in \Z\] and $a \ne 0$ or $b \ne 0$.

The steps of the algorithm are:
\begin{enumerate}
\item Start with $(a,b)$ such that $\abs{a} \ge \abs{b}$.
If $b = 0$ then the task is complete and the GCD is $a$.
\item if $b \ne 0$ then you take the remainder $r$ of $a/b$.
\item set $a \leftarrow b$, $b \leftarrow r$ (and thus
$\abs{a} \ge \abs{b}$ again).
\item repeat these steps until $b = 0$
\end{enumerate}
Thus the GCD of $a$ and $b$ is the value of the variable $a$ 
at the end of the algorithm.

The proof is:

Suppose \[a, b \in \Z\] and $a or b \ne 0$.

From the {\bf division theorem}, $a = qb + r$ 
where $0 \le r \le \abs{b}$

From {\bf GCD with Remainder}, the GCD of $a$ and $b$ is also the GCD
of $b$ and $r$.

Therefore we may search instead for the $gcd(b,r)$.

Since $\abs{r} \ge \abs{b}$ and \[b \in \Z\],
we will reach $r = 0$ after finitely many steps.

At this point, $gcd(r,0) = r$ from {\bf GCD with Zero}.

We quote the {\bf Division Theorem} proof \cite{Wiki14b}:

For every pair of integers $a$, $b$ where $b \ne 0$, there exist unique
integers $q,r$ such that $a = qb + r$ and $0 \le r \le \abs{b}$.

\subsection{Hoare's axioms and gcd proof}
From Hoare \cite{Hoar69}

\begin{tabular}{rll}
A1 & $x+y = y+x$ & addition is commutative\\
A2 & $x\times y = y\times x$ & multiplication is commutative\\
A3 & $(x+y)+z = x+(y+z)$ &  addition is associative\\
A4 & $(x\times y)\times z = x\times (y\times z)$ &
multiplication is associative\\
A5 & $x\times (y+z) = x\times y + x\times z$ &
multiplication distributes through addition\\
A6 & $y \le x \to (x-y) + y = x$ & addition cancels subtraction\\
A7 & $x + 0 = x$ &\\
A8 & $x\times 0 = 0$ &\\
A9 & $x\times 1 = x$ &\\
\end{tabular}

{\bf D0 Axiom of Assignment}
\[\vdash P_0 \{x:=f\} P\]
where
\begin{itemize}
\item $x$ is a variable identifier
\item $f$ is an expression
\item $P_0$ is obtained from $P$ by substituting $f$ for all
occurrences of $x$
\end{itemize}

\section{The Division Algorithm}
From Judson \cite{Juds15},

An Application of the Principle of Well-Ordering that we will use
often is the division algorithm.

{\bf Theorem 2.9 Division Algorithm} Let $a$ and $b$ be integers, with
$b > 0$. Then there exists unique integers $q$ and $r$ such that
\[a=bq+r\]
where $0 \le r < b$.

{\bf Proof}

Let $a$ and $b$ be integers. If $b = ak$ for some integer $k$, we write
$a \vert b$. An integer $d$ is called a {\sl common divisor} of $a$ and
\index{common divisor}
$b$ if $d \vert a$ and $d \vert b$. The {\sl greatest common divisor}
\index{greatest common divisor}
of integers $a$ and $b$ is a positive integer $d$ such that $d$ is
a common divisor of $a$ and $b$ and if $d^{'}$ is any other common
divisor of $a$ and $b$, then $d^{'} \vert d$. We write $d=gcd(a,b)$;
for example, $gcd(24,36)=12$ and $gcd(120,102)=6$. We say that two
integers $a$ and $b$ are {\sl relatively prime} if $gcd(a,b)=1$.
\index{relatively prime}

{\bf Theorem 2.10} Let $a$ and $b$ be nonzero integers. Then there
exist integers $r$ and $s$ such that
\[gcd(a,b)=ar+bs\]
Furthermore, the greatest common divisor of $a$ and $b$ is unique.

{\bf Proof}

{\bf Corollary 2.11} Let $a$ and $b$ be two integers that are relatively
prime. Then there exist integers $r$ and $s$ such that
\[ar+bs=1\]

{\bf The Euclidean Algorithm}
\index{The Euclidean Algorithm}

Among other things, Theorem 2.10 allows us to compute the greatest 
common divisor of two integers.

{\bf Example 2.1.2} Let us compute the greatest common divisor of 945 and
2415. First observe that
\[
\begin{array}{rcl}
2415 & = & 945 \cdot 2 + 525\\
945 & = & 525 \cdot 1 + 420\\
525 & = & 420 \cdot 1 + 105\\
420 & = & 105 \cdot 4 + 0\\
\end{array}
\]

Reversing our steps, 105 divides 420, 105 divides 525, 105 divides 945,
and 105 divides 2415. Hence, 105 divides both 945 and 2415. If $d$ were
another common divisor of 945 and 2415, then $d$ would also have to
divide 105. Therefore, $gcd(945,2415)=105$.

If we work backward through the above sequence of equations, we can also
obtain numbers $r$ and $s$ such that
\[945r + 2415s = 105\]

\[
\begin{array}{rcl}
105 & = & 525 + (-1)\cdot 420\\
105 & = & 525 + (-1)\cdot [945+(-1)\cdot 525]\\
105 & = & 2\cdot 525+(-1)\cdot 945\\
105 & = & 2\cdot[2415+(-2)\cdot 945]+(-1)\cdot 945\\
105 & = & 2*2415+(-5)\cdot 945
\end{array}
\]
So $r=-5$ and $s-2$. Notice the $r$ and $s$ are not unique, since
$r=41$ and $s=-16$ would also work.

To compute $gcd(a,b)=d$, we are using repeated divisions to obtain
a decreasing sequence of positive integers
$r_1 > r_2 > \ldots > r_n = d$; that is

\[
\begin{array}{rcl}
b & = & aq_1+r_1\\
a & = & r_1q_2+r_2\\
r_1 & = & r_2q_3+r_3\\
\vdots\\
r_{n-2} & = & r_{n-1}q_n+r_n\\
r_{n-1} & = & r_nq_{n+1}
\end{array}
\]

To find $r$ and $s$ such that $ar+bs=d$, we begin with the last equation
and substitute results obtained from the previous equations:

\[
\begin{array}{rcl}
d & = & r_n\\
d & = & r_{n-2} - r_{n-1}q_n\\
d & = & r_{n-2} - q_n(r_{n-3}-q_{n-1}r_{n-2}\\
d & = & -q_nr_{n-3}+(1+q_nq_{n-1})r_{n-2}\\
\vdots\\
d & = & ra+sb
\end{array}
\]

\section{Floating Point Proofs}

Bagnara, Bagnara, Biselli, Chiara, and Gori \cite{Bagn19}
{\bf Correct Approximation of IEEE 754 Floating-Point Arithmetic 
for Program Verification}

\chapter{GCD in Miranda by Broda, et al.}

In Broda, et al. \cite[p. 55]{Brod94} they consider the greatest
common divisor, {\tt gcd}, of two natural numbers:
\begin{verbatim}
   gcd :: num -> num -> num
   ||pre:   nat(x) & nat(y)
   ||post:  nat(z) & z|x & z|y (ie z is a common divisor)
   ||       &(A)n:nat(n|x & n|y -> n|z) 
   ||            (ie any other common divisor divides it)
   ||       where z = (gcd x y)
\end{verbatim}

We have introduced some notation in the pre and post-conditions:
\begin{itemize}
\item (A) just means $\forall$, that is 'for all', written in standard
keyboard characters. $\exists$ would be (E). 
\item $|$ means 'divides', or 'is a factor of'. (Note that it is not
the same symbol as the division sign '$/$'.)
\[z~|~x \Leftrightarrow \exists y: nat. (x=z \times y)\]
\item When we write '$y:nat$', we are using the predicate $nat$ as
though it were a Miranda type, though it is not. You can think of 
'$nat(y)$' and '$y:nat$' as meaning exactly the same, namely that $y$
is a natural number. But the type-style notation is particularly
useful with quantifiers:
\[\begin{array}{lr}
\exists y : nat, P & {\rm means\ }\exists y. (nat(y) \land P)\\
&({\rm 'there\ is\ a\ natural\ number\ } y {\rm\ for\ which\ }
P {\rm\ holds}')\\
\forall y : nat, P & {\rm means\ }\forall y. (nat(y) \implies P)\\
&({\rm 'for\ all\ natural\ numbers\ } y, P {\rm\ holds}')\\
\end{array}\]
\end{itemize}

Be sure to understnad these, and in particular why it is that
$\exists$ goes naturally with $\land$, and $\forall$ with
$\implies$. They are patterns that arise very frequently when you are
translating from English into logic.

There is a small unexpected feature. You might expect the
post-condition to say that any other common divisor is {\sl less} than
$z$, rather than dividing it: in other words that $z$ is indeed the
{\sl greatest} common divisor. There is just a single case where this
makes a difference, namely when $x$ and $y$ are both 0. All numbers
divide 0, so amongst the common divisors of $x$ and $y$ there is no
greatest one. The specification as given has the effect of specifying
\begin{verbatim}
   gcd 0 0 = 0
\end{verbatim}

{\bf Proposition 1}: For any two natural numbers $x$ and $y$, there is
at most one $z$ satifying the specification for $(gcd x y)$.

{\bf Proof}: Lex $z1$ and $z2$ be two values satisfying the
specification for $(gcd x y)$; we must show that they are equal. All
common divisors of $x$ and $y$ divide $z2$, so, in particular, $z1$
does. Similiarly, $z2$ divides $z1$. Hence for some positive natural
numbers $p$ and $q$, we have $z1=z2 \times p$, $z2=z1 \times q$, so 
$z1 = z1 \times p \times q$. It follow that either $z1 = 0$, in which
case also $z2=0$, or $p\times q=1$, in which case $p=q=1$. In either
case, $z1=z2$.

Note that we have not actually proved that there is {\sl any} value
$z$ satisfying the specification; only that there cannot be more than
one. But we shall soon have an implementation showing how to find a
suitable $z$, so then we shall know that there is exactly one possible
result. 

{\sl Euclid's algorithm} relies on the following fact.

{\bf Proposition 2}: Let $x$ and $y$ be natural numbers, $y\ne
0$. Then the common divisors of $x$ and $y$ are the same as those of
$y$ and $(x{\rm\ mod\ }y)$.

{\bf Proof}: For natural numbers $x$ and $y$ there are two fundamental
properties of integer division, which in fact are enough to specify it
uniquely: if $y\ne 0$ (pre-condition), the (post-condition)
\[x=u\times (x{\rm\ div\ }y) + (x{\rm\ mod\ }y)\]
\[0 \le (x{\rm\ mod\ }y) < y\]
Suppose $n$ is a common divisor of $y$ and $(x{\rm\ mod\ y}y)$. That
is, there is a $p$ such that $y=n\times p$ and a $q$ such that
$(x{\rm\ mod\ }y)=n\times q$. Then
\[x=y\times(x{\rm\ div\ }y)+(x{\rm\ mod\ }y)=
n\times (p\times (x{\rm\ div\ }y)+q)\]
so $n$ also divides $z$. Hence every common divisor of $y$ and
$(x{\rm\ mod\ }y)$ is also a common divisor of $x$ and $y$. The
converse is also true, by a similar proof. $\quad\blacksquare$

It follows that, provided $y\ne 0$, $(gcd x y)$ must equal
$(gcd y (x{\rm\ mod\ }y))$. On the other hand, $(gcd x 0)$ must be
$x$. This is because $x~|~x$ and $x~|~0$, and any common divisor of
$x$ and 0 obviously divides $x$, so $x$ satisfies the specification
for $(gcd x 0)$. We can therefore write the following definition:
\[\begin{array}{rcl}
gcd x y & = x                        & {\rm if\ }y=0\\
        & = gcd y (x {\rm\ mod\ } y) & {\rm otherwise}
\end{array}\]

{\tt Question}: Does this definition satisfy the specification?

Let $x$ and $y$ be natural numbers, and let $z=(gcd x y)$. We must
show that $z$ has the properties given by the post-condition, and
there are two cases corresponding to the two clauses in the
definition:

$y=0 : z = x$ We have already noted that this satisfies the
specification.

$y\ne 0 : z = (gcd y (x{\rm\ mod\ }y))$ What we have seen shows that
{\sl provided that z} satisfies the specification for
$(gcd y (x{\rm\ mod\ }y))$, then it also satisfies the specification
for $(gcd x y)$ as required. $\quad\blacksquare$

But how do we know that the recursive call gives the right answer? How
do we know that it gives any answer at all? (conceivably, the
recursion might never bottom out.) Apparently, we have having to 
{\sl assume} that {\tt gcd} satisfies its specification in order to 
{\sl prove} that it satisfies its specification.

The answer is that we {\sl are} allowed to assume it! But there is a
catch. This apparently miraculous circular reasoning must be
justified, and the key is to notice that the recursive call uses
simpler arguments: the pair of arguments $y$ with $x{\rm\ mod\ }y)$ is 
'simpler' than the pair $x$ and $y$, in the sense that the second
argument is smaller: $x{\rm\ mod\ }y < y$.

As we go down the recursion, the second argument, always a natural
number, becomes smaller and smaller, but never negative. This cannot
go on for ever, so the recursion must eventually terminate. This at
least proves termination, but it also justifies the
{\sl circular reasoning}. For suppose that {\tt gcd} does not always
work correctly. What might be the smallest bad $y$ for which 
$gcd x y$ may go wrong (for some $x$)? Not 0 -- gcd x 0 always works
correctly. Suppose $Y$ is the smallest bad $y$, and $gcd X Y$ goes
wrong. Then $Y > 0$, so
\begin{verbatim}
   gcd X Y = gcd Y (X mod Y)
\end{verbatim}
But $X{\rm\ mod\ }Y$ is good (since $X{\rm\ mod\ }Y < Y$), so the
recursive call works correctly, so (we have already reasoned) 
$gcd X Y$ does also -- a contradiction.

We call the value $y$ in $gcd x y$ a {\sl recursion variant} for our
definition of {\tt gcd}. It is a rough measure of the depth of
recursion needed, and always decreases in the recursive calls. 

Let us now state this as a reasoning principle:
\begin{verbatim}
   In proving that a recursive function satisfies its specificaiton,
   you are allowed to assume that the recursive calls work correclty
   -- provided that you can define a recursion variant for the function. 
\end{verbatim}
 
A recursion variant for a function must obey the following rules:
\begin{itemize}
\item It is calculated from the arguments of the function
\item It is a natural number (at least when the pre-conditions of the
function hold). For instances, in {\tt gcd} the recursion variant of $y$. 
\item It is calculated (trivially) from the function's arguments 
$x$ and $y$)
\item It always decreases in the recursive calls. For the recursive
call $gcd y (x{\rm\ mod\ }y)$, the recursion variant $x{\rm\ mod\ }y$
is less than $y$, the variant for $gcd x y$.
\end{itemize}

\chapter{GCD in COQ}

\begin{verbatim}
Fixpoint Pgcdn (n: nat) (a b : positive) : positive :=
  match n with
    | O => 1
    | S n =>
      match a,b with
        | xH, _ => 1
        | _, xH => 1
        | xO a, xO b => xO (Pgcdn n a b)
        | a, xO b => Pgcdn n a b
        | xO a, b => Pgcdn n a b
        | xI a', xI b' =>
          match Pcompare a' b' Eq with
            | Eq => a
            | Lt => Pgcdn n (b'-a') a
            | Gt => Pgcdn n (a'-b') b
          end
      end
  end.

Definition Zgcd (a b : Z) : Z :=
  match a,b with
    | Z0,_ => Zabs b
    | _,Z0 => Zabs a
    | Zpos a, Zpos b => Zpos (Pgcd a b)
    | Zpos a, Zneg b => Zpos (Pgcd a b)
    | Zneg a, Zpos b => Zpos (Pgcd a b)
    | Zneg a, Zneg b => Zpos (Pgcd a b)
  end.

Lemma Zgcd_is_gcd : forall a b, Zis_gcd a b (Zgcd a b).

\end{verbatim}

\chapter{GCD in Nuprl by Anne Trostle}

Quoted from \cite{Tros13}:

Here we show how to use the Nuprl proof assistant to develop an existence
proof for the greatest common divisor of two natural numbers. We then
take the proof a step further and show that the greatest common divisor,
or GCD, can be calculated as a linear combination of the two numbers.
For each proof, we also show that Nuprl can extract a {\sl program}
from the proof that can be used to perform calculations.

The greatest common divisor is defined in Nuprl as follows:

{\bf Defintion 1: gcd\_p}

$GCD(m:n:g) == (g | m) \land (g | n) \land (\forall z:Z.
(((z | m) \land (z | m)) \to (z | g)))$

{\bf Defintion 2: divides}

$b | a == \exists c : Z. (a = (b * c))$

In words, Definition 1 means that $g$ is the greatest common divisor
of $m$ and $n$ when $g$ divides both $m$ and $n$, and any other common
divisor of $m$ and $n$ divides $g$.

To prove that the GCD exists, we are going to use Euclid's algorithm,
whicc is based on the property that for two integers $m$ and $n$, the
GCD of $m$ and $n$ is equivalent to the GCD of $n$ and the remainder
from $m \div n$:

{\bf Lemma 1: div\_rem\_gcd\_anne}

$\forall m:Z. \quad\forall n:\mathbb{Z}^{-0},\quad\forall g:\mathbb{Z}.
(GCD(m;n;g) \iff GCD(n;m {\rm\ rem\ } n;g))$

Another useful fact about the GCD is that the GCD of an integer $z$ and
0 is $z$. A proof of this property can be done by showing that each part
of Definition 1 is satisfied.

{\bf Lemma 2: gcd\_p\_zero}

$\forall z:\mathbb{Z}.\quad GCD(z;0;z)$

From these properties we can see a method for calculating the greatest
common divisor of two numbers: continue finding remainders until you
reach 0 and then use the fact that the GCD of an integer $z$ and 0 is $z$.
Since the GCD stays the same as you reduce the terms, $z$ is also the GCD
of the original pair of numbers. This is Euclid's algorithm. Here is an
example of how it works, using 18 and 12:

\begin{tabular}{rcl}
GCD(18;12;g) & = & GCD(12;18 rem 12;g)\\
             & = & GCD(12;6;g\\
             & = & GCD(6;12 rem 6;g)\\
             & = & GCD(6;0;g)\\
	     & $\to$ & g = 6
\end{tabular}

Using this idea we can not only prove that the GCD exists but we can also
construct a method for actually computing the GCD. A great feature of
Nuprl is that when we run a constructive existence proof, we can extract a
program from it and use the program to perform calculations. In the next
section we show in detail how to develop a constructive existence proof
for the GCD using induction. Induction proofs often to hand-in-hand with
recursive programs, and sure enough, a very clean recursive program can
be extracted from the proof, and this program follows exactly the method
we just came up with:

$\lambda n. letrc gcd(n) =\\
\quad \lambda m. if n = 0 then m\\
\quad\quad\quad else (gcd (m rem n) n)\\
\quad in gcd(n)$

The program here is an example of {\sl currying}: a function of $n$ that
results in another function which then uses $m$. This isn't necessarily
intuitive, since when we think of the GCD we think of a function of a
pair (or more) of numbers, so we might expect the program to start with
something like ``gcd$(m,n)=\ldots$''. But the proof that follows uses
natural induction on a single variable and flows very nicely, giving
reason to prefer the curried function here. To develop a proof that
produces a function of the pair $(m,n)$ would require induction on the
pair itself which isn't as intuitive or easy to understand as natural
induction on a single variable.

\chapter{Software Details}
\section{Installed Software}
Install CLANG, LLVM
\begin{verbatim}
http://llvm.org/releases/download.html
\end{verbatim}
Install OCAML
\begin{verbatim}
sudo apt-get install ocaml
\end{verbatim}

An OCAML version of gcd would be written 
\begin{verbatim}
let rec gcd a b = if b = 0 then a else gcd b (a mod b)
val gcd : int -> int -> int = <fun>
\end{verbatim}

\chapter{Temporal Logic of Actions (TLA)}
\begin{quote}
{\bf Sloppiness is easier than precision and rigor}
-- Leslie Lamport \cite{Lamp14a}
\end{quote}

Leslie Lamport \cite{Lamp14} \cite{Lamp16} on $21^{st}$ Century Proofs.

A method of writing proofs is described that makes it harder to prove
things that are not true. The method, based on hierarchical
structuring, is simple and practical. The author's twenty years of
experience writing such proofs is discussed.

Lamport points out that proofs need rigor and precision.
Structure and Naming are important. Every step of the proof
names the facts it uses. 

Quoting from \cite{Lamp16}:

Broadly speaking, a TLA+ proof is a collection of {\sl claims},
arranged in a hierarchical structure which we describe below, where
each claim has an {\sl assertion} that is either {\sl unjustified} or
justified by a collection of {\sl cited facts}. The purpose of TLAPS
is to check the user-provided proofs of theorems, that is, to check
that the hierarchy of claims indeed establishes the truth of the theorem
if the claims were true, and then to check that the assertion of every
justified claim indeed is implied {\sl by} its cited facts. If a TLA+
theorem has a proof with no unjustified claims, then, as a result of
checking the proof, TLAPS verifies the truth of the theorem.

\section{The algorithm}

The well-known Euclidean algorithm can be written in the PlusCal 
language as follows:
\begin{verbatim}
--algorithm Euclid {
  variables x \in 1..M, y \in 1..N, x0 = x, y0 = y;
  {
    while (x # y) {
      if (x < y) { y := y - x; }
      else { x := x-y; }
    };
    assert x = GCD(x0, y0) /\ y = GCD(x0, y0)
  }
\end{verbatim}

The PlusCal translator translates this algorithm into a TLA+ specification
that we could prove correct. However, in this tutorial, we shall write a
somewhat simpler specification of Euclid's algorithm directly in TLA+.

\subsection{Creating a new TLA+ module}

In order to get the definitions of arithmetic operators ($+$, $-$, etc.),
we shall make this specification {\sl extend} the {\tt Integers} 
standard module.

\begin{verbatim}
--------------------- Module Euclid ----------------------
EXTENDS Integers
\end{verbatim}

\subsection{Definitions}

We shall then define the GCD of two integers. For that purpose, let us
define the predicate ``p divides q'' as follows: p divides q iff there
exists some integer d in the interval 1..q such that q is equal to p
times d.

\begin{verbatim}
p | q == \E d \in 1..q : q = p * d
\end{verbatim}

We then define the set of divisors of an integer q as the sets of integers
which both belong to the interval 1..q and divide q:
\begin{verbatim}
Divisors(q) == {d \in 1..q : d | q}
\end{verbatim}

We define the maximum of a set S as one of the elements of this set which
is greater than or equal to all the other elements:
\begin{verbatim}
Maximum(S) == CHOOSE x \in S : \A y \in S : x >= y
\end{verbatim}

And finally, we define the GCD of two integers p and q to be the maximum
of the intersection of Divisors(p) and Divisors(a):
\begin{verbatim}
GCD(p,q) == Maximum(Divisors(p) \cap Divisors(q))
\end{verbatim}

For convenience, we shall also define the set of all positive integers as:
\begin{verbatim}
Number = Nat \ {0}
\end{verbatim}

\subsection{Constants and variables}
We then define the two constants and two variables needed to describe
the Euclidean algorithm, where M and N are the values whose GCD is to
be computed:
\begin{verbatim}
CONSTANTS M, N
VARIABLES x, y
\end{verbatim}

\subsection{The specification}
We define the initial state of the Euclidean algorithm as follows:
\begin{verbatim}
Init == (x = M) /\ (y = N)
\end{verbatim}

In the Euclidean algorithm, two actions can be performed:
\begin{itemize}
\item set the value of y to y - x if x $<$ y
\item set the value of x to x - y if x $>$ y
\end{itemize}

These actions are again written as a definition of {\tt Next}, which
specifies the next-state relation. In TLA+, a primed variable refers
to its value at the next state of the algorithm.
\begin{verbatim}
Next == \/ /\ x < y
           /\ y' = y - x
           /\ x' = x
        \/ /\ y < x
           /\ x' = x-y
           /\ y' = y
\end{verbatim}

The specification of the algorithm asserts that the variables have the
correct initial values and, in each execution step, either a {\tt Next}
action is performed or x and y keep the same values:
\begin{verbatim}
Spec == Init /\ [][Next]_<<x,y>>
\end{verbatim}

(For reasons that are irrelevant to this algorithm, TLA specifications
always allow {\sl stuttering steps} that leave all the variables
unchanged.)

We want to prove that the algorithm always satisfies the following
property:
\begin{verbatim}
ResultCorrect == (x = y) => x = GCD(M, N)
\end{verbatim}

Hence we want to prove the following theorem named Correctness:
\begin{verbatim}
THEOREM Correctness == Spec => []ResultCorrect
\end{verbatim}

\subsection{Summary}

\begin{verbatim}
--------------------- Module Euclid ----------------------
EXTENDS Integers

p | q == \E d \in 1..q : q = p * d
Divisors(q) == {d \in 1..q : d | q}
Maximum(S) == CHOOSE x \in S : \A y \in S : x >= y
GCD(p,q) == Maximum(Divisors(p) \cap Divisors(q))
Number == Nat \ {0}

CONSTANTS M, N
VARIABLES x, y

Init == (x = M) /\ (y = N)

Next == \/ /\ x < y
           /\ y' = y - x
           /\ x' = x
        \/ /\ y < x
           /\ x' = x-y
           /\ y' = y

Spec == Init /\ [][Next]_<<x,y>>

ResultCorrect == (x = y) => x = GCD(M,N)

THEOREM Correctness == Spec => []ResultCorrect
\end{verbatim}

\section{A simple proof}
\subsection{The invariant}

Intuitively, the theorem Correctness holds because the implementation
guarantees the following {\sl invariant}
\begin{verbatim}
InductiveInvariant == /\ x \in Number
                      /\ y \in Number
                      /\ GCD(x, y) = GCD(M, N)
\end{verbatim}

That is, {\tt InductiveInvariant} holds for the initial state (i.e.,
the state specified by {\tt Init}) and is preserved by the 
next-state relation {\tt [Next]\_}$<<x,y>>$

\subsection{Checking proofs}

First we need to assume that constants M and N are not equal to zero
\begin{verbatim}
ASSUME NumberAssumption == M \in Number /\ N \in Number
\end{verbatim}

Let us then prove that {\tt InductiveInvariant} holds for the initial state.
\begin{verbatim}
THEOREM InitProperty == Init => InductiveInvariant
\end{verbatim}

To check whether TLAPS can prove that theorem by itself, we declare
its proof obvious.
\begin{verbatim}
THEOREM InitProperty == Init => InductiveInvariant
  OBVIOUS
\end{verbatim}

We now ask TLAPS to prove that theorem. But TLAPS does not know how to
prove the proof obligation corresponding to that proof. It prints
that obligation and reports failures to three backends, Zenon, Isabelle,
and SMT. The default behavior of TLAPS is to send obligations first to
an SMT solver (by default CVC3), then if that fails to the automatic
prover Zenon, then if Zenon fails to Isabelle (with the tactic ``auto'').

\subsection{Using facts and definitions}
The obligation cannot be proved because TLAPS treats the symbols
{\tt Init} and {\tt InductiveInvariant} as opaque identifiers unless
it is explicitly instructed to expand their definitions using the
directive {\tt DEF}. The main purpose of this treatment of definitions
is to make proof-checking tractable, because expanding definitions can
arbitrarily increase the size of expressions. Explicit use of definitions
is also a good hint to the (human) reader to look only at the listed
definitions to understand a proof step. In that precise case, we can ask
TLAPS to expand definitions of {\tt Init} and {\tt InductiveInvariant},
by replacing the proof {\tt OBVIOUS} by the proof\\
{\tt BY DEF Init, InductiveInvariant}. In the obligations sent to the
backends, the definitions of {\tt Init} and {\tt InductiveInvariant}
have been expanded. 

Unfortunately, none of the back-ends could prove that obligation. As with
{\tt definitions}, we have to specify which facts are {\sl usable}. In this
case, we have to make the fact {\tt NumberAssumption} usable by changing
the proof to
\begin{verbatim}
THEOREM InitProperty == Init => InductiveInvariant
  BY NumberAssumption DEF Init, InductiveInvariant
\end{verbatim}

The general form of a {\tt BY} proof is:
\[ {\tt BY\ } e_1,\ldots,e_m {\tt \ DEF\ } d_1,\ldots,d_n\]
which claims that the assertion follows by assuming $e_1,\ldots,e_m$
and expanding the definitions $d_1,\ldots,d_n$. It is the job of TLAPS
to then check this claim, and also to check that the cited facts
$e_1,\ldots,e_m$ are indeed true. 

Finally, SMT succeeds in proving that obligation.
\begin{verbatim}
--------------------- Module Euclid ----------------------
EXTENDS Integers

p | q == \E d \in 1..q : q = p * d
Divisors(q) == {d \in 1..q : d | q}
Maximum(S) == CHOOSE x \in S : \A y \in S : x >= y
GCD(p,q) == Maximum(Divisors(p) \cap Divisors(q))
Number == Nat \ {0}

CONSTANTS M, N
VARIABLES x, y

Init == (x = M) /\ (y = N)

Next == \/ /\ x < y
           /\ y' = y - x
           /\ x' = x
        \/ /\ y < x
           /\ x' = x-y
           /\ y' = y

Spec == Init /\ [][Next]_<<x,y>>

ResultCorrect == (x = y) => x = GCD(M,N)

InductiveInvariant == /\ x \in Number
                      /\ y \in Number
                      /\ GCD(x, y) = GCD(M, N)

ASSUME NumberAssumption == M \in Number /\ N \in Number

THEOREM InitProperty == Init => InductiveInvariant
  BY NumberAssumption DEF Init, InductiveInvariant

THEOREM Correctness == Spec => []ResultCorrect
\end{verbatim}


\section{Divisibility Definition}
In Shoup \cite{Sho08} we find the divisibility definition.

Given the integers, $a$ and $b$
\[ a {\rm \ divides\ } b \implies az = b {\rm \ for\ some\ } z\]
so or all $a$,$b$, and $c$
\[ a | a,\quad 1 | a,\quad and \quad a | 0\]
because $a\cdot 1 = a$, $1\cdot a = a$, and $a\cdot 0 = 0$
\[ 0 | a \iff a = 0\]
\[a | b \iff -a | b \iff a | -b\]
\[ a | b {\rm \ and\ } a | c \implies a | (b+c)\]
\[a | b {\rm \ and\ } b | c \implies a | c\]
\[a | b {\rm \ and\ } b \ne 0 \implies 1 \le |a| \le |b|\]
\[az = b \ne 0 {\rm \ and\ } a \ne 0 {\rm \ and\ }z \ne 0 
\implies |a| \ge 1 {\rm \ and\ } |z| \ge 1\]
\[ a | b {\rm \ and\ } b | a \implies a = \pm b\]
proof: \[ a | b \implies |a| \le |b|; b | a \implies |b| \le |a|; 
{\rm \ therefore\ } |a|=|b| \implies a = \pm b\]
\[ a | 1 \iff a = \pm 1\]

\chapter{COQ proof of GCD}
\section{Basics of the Calculus of Constructions}
Coquand \cite{Coqu86} \cite{Wiki17} 
defines the Calculus of Constructions which can
be considered an extension of the Curry-Howard Isomorphism. The components
are
\subsection{Terms}
A {\sl term} in the calculus of constructions is constructed using the
following rules:
\begin{itemize}
\item {\bf T} is a term (also called {\sl Type})
\item {\bf P} is a term (also called {\sl Prop}, the type of all propositions)
\item Variables ($x,y,\ldots$) are terms
\item if {\bf A} and {\bf B} are terms, then so are
\begin{itemize}
\item {\bf $(A,B)$}
\item {\bf $(\lambda x: A,B)$}
\item {\bf $(\forall x: A,B)$}
\end{itemize}
\end{itemize}

The calculus of constructions has five kinds of objects:
\begin{enumerate}
\item {\sl proofs}, which are terms whose types are {\sl propositions}
\item {\sl propositions}, which are also known as {\sl small types}
\item {\sl predicates}, which are functions that return propositions
\item {\sl large types}, which are the types of predicates. {\bf P} is
an example of a large type)
\item {\bf T} itself, which is the type of large types.
\end{enumerate}

\subsection{Judgements}

The calculus of constructions allows proving {\bf typing judgements}
\[x_1:A_1, x_2:A_2, \ldots \vdash t:B\]
which can be read as the implication
\[{\rm\ if\ variables\ }x_1, x_2, \ldots, 
{\rm\ have\ types\ }A_1, A_2,\ldots,
{\rm\ then\ term\ }t{\rm\ has\ type\ }B\]

The valid judgements for the calculus of constructions are derivable
from a set of inference rules. In the following, we use $\Gamma$
to mean a sequence of type assignments
$x_1:A_1$, $x_2:A_2,\ldots$,
and we use {\bf K} to mean either {\bf P} or {\bf T}.
We shall write {\bf $A:B:C$} to mean 
"{\bf $A$} has type {\bf $B$}, and {\bf $B$} has type {\bf $C$}".
We shall write {\bf $B(x:=N)$} to mean the result of substituting
the term {\bf $N$} for the variable {\bf $x$} in the term {\bf $B$}.

An inference rule is written in the form
\[\frac{{\bf \Gamma} \vdash {\bf A : B}}
{{\bf \Gamma^\prime} \vdash {\bf C : D}}\]
which means
\[{\rm\ if\ }{\bf \Gamma} \vdash {\bf A : B}
{\rm\ is\ a\ valid\ judgement,\ then\ so\ is\ }
{\bf \Gamma^\prime} \vdash {\bf C : D}\]

\subsection{Inference Rules}

In Frade \cite{Frad08} we find:

\[\begin{array}{lcl}

({\rm axiom}) &
() \vdash s_1 : s_2 
& {\rm\ if\ }(s_1,s_2)\in A\\
&&\\

({\rm start}) &
\displaystyle{\frac{\Gamma \vdash A : s}{\Gamma,x : A \vdash x : A}}
& {\rm\ if\ }x\notin {\rm\ dom}(\Gamma) \\
&&\\

({\rm weakening}) &
\displaystyle{\frac{\Gamma \vdash M : A\quad\quad\Gamma\vdash B : s}
{\Gamma,x : B \vdash M : A}}
& {\rm\ if\ }x\notin {\rm\ dom}(\Gamma) \\
&&\\

({\rm product}) &
\displaystyle{\frac{\Gamma\vdash A : s_1\quad\quad\Gamma,x : A\vdash B : s_2}
{\Gamma\vdash(\prod x:A. B) : s_3}}
& {\rm\ if\ }(s_1,s_2,s_3) \in \mathbb{R}\\
&&\\

({\rm application}) &
\displaystyle{\frac{\Gamma\vdash M:(\prod x : A. B)\quad\quad\Gamma \vdash N:A}
{\Gamma \vdash MN : B[x:=N]}} & \\
&&\\

({\rm abstraction}) & 
\displaystyle{\frac{\Gamma,x:A\vdash M:B\quad\quad\Gamma\vdash(\prod x:A. B):s}
{\Gamma\vdash\lambda x : A.M : (\prod x:A.B)}} & \\
&&\\

({\rm conversion}) &
\displaystyle{\frac{\Gamma\vdash M : A\quad\quad\Gamma\vdash B : s}
{\Gamma\vdash M : B}}
& {\rm\ if\ }A =_\beta B\\

\end{array}\]

\subsection{Defining Logical Operators}

\[\begin{array}{cccc}
A\Rightarrow B & \equiv & \forall x:A.B & (x\notin B)\\
A\wedge B & \equiv & \forall C:P.(A\Rightarrow B\Rightarrow C)\Rightarrow C &\\
A\vee B & \equiv & \forall C:P.(A\Rightarrow C)\Rightarrow(B\Rightarrow C)
\Rightarrow C &\\
\neg A & \equiv & \forall C : P.(A\Rightarrow C) &\\
\exists x : A. B & \equiv & \forall C : P.(\forall x : A.(B\Rightarrow C))
\Rightarrow C &\\
\end{array}\]

\subsection{Defining Types}

The basic data types used in computer science can be defined within the
Calculus of Constructions:

{\bf Booleans}

\[\forall A : P.A \Rightarrow A \Rightarrow A\]

{\bf Naturals}

\[\forall A : P.(A \Rightarrow A) \Rightarrow (A \Rightarrow A)\]

{\bf Product} $A\times B$

\[A \wedge B\]

{\bf Disjoint Union} $A + B$

\[A \vee B\]

Note that Booleans and Naturals are defined in the same way as in
Church encoding. However additional problems raise from propositional
extensionality and proof irrelevance.

\section{Why does COQ have Prop?}

From a stackexchange post \cite{Stac17} we find the question:

"Coq has a type {\tt Prop} of proof irrelevant propositions which are discarded
during extraction. What are the reasons for having this if we use Coq only
for proofs? Prop is impredicative, however, Coq automatically infers
universe indexes and we can use {\tt Type(i)} instead everywhere. 
It seems {\tt Prop} complicates everything a lot."

Prop is very useful for program extraction because it allows us to 
delete parts of code that are useless. For example, to extract a sorting
algorithm we would prove the statement ``for every list $l$ there
is a list $k$ such that $k$ is ordered and $k$ is a permutation of $l$''.
If we write this down in Coq and extract without using Prop, we will get:
\begin{enumerate}
\item ``for all $l$ there is a $k$'' which gives us a map {\bf sort} which
takes lists to lists,
\item ``such that $k$ is ordered'' will give a function {\bf verify} which
runs through $k$ and checks that it is sorted, and
\item ``$k$ is a permutation of $l$ will give a permutation {\bf p1} which
takes $l$ to $k$. Note that {\bf p1} is not just a mapping, but also the
inverse mapping together with programs verifying that the two maps really
are inverses.
\end{enumerate}

While the extra stuff is not totally useless, in many applications we want
to get ride of it and keep just {\bf sort}. This can be accomplished if we
use {\tt Prop} to state ``$k$ is ordered'' and ``$k$ is a permutation of $l$'',
but {\sl not} ``for all $l$ there is $k$''.

In general, a common way to extract code is to consider a statement of the
form
\[\forall x : A. \exists y : B. \phi(x,y)\]
where $x$ is input, $y$ is output, and $\phi(x,y)$ explains what it means
for $y$ to be a correct output. (In the above example $A$ and $B$ are the
types of lists and $\phi(l,k)$ is ''$k$ is ordered and $k$ is a permutation
of $l$.'') if $\phi$ is in {\tt Prop} then extraction gives a map 
$f : A\Rightarrow B$ such that $\phi(x,f(x))$ holds for all $x\in A$. 
If $\phi$ is in {\tt Set} then we also get a function $g$ such that $g(x)$
is the proof that $\phi(x,f(x))$ holds, for all $x\in A$. Often the proof
is computationally useless and we prefer to get rid of it, especially when
it is nested deeply inside some other statement. {\tt Prop} gives use the
possibility to do so.

There is a question whether we could avoid {\tt Prop} altogether by
automatically optimizing away ``useless extracted code''. To some extent
we can do that, for instance all code extracted from the negative fragment
of logic (stuff build from the empty type, unit type, products) is useless
as it just shuffles around the unit. But there are genuine design decisions
one has to make when using {\tt Prop}. Here is a simple example, where
$\sum$ means that we are in {\tt Type} and $\exists$ means we are in 
{\tt Prop}. If we extract from
\[\prod_{n:N}\sum_{b:[0,1]}\sum_{k:N}\quad n=2\cdot k+b\]
we will get an inductivea program which decomposes $n$ 
into its lowest bit $b$ and 
the remaining bits $k$, i.e., it computes everything. If we extract from
\[\prod_{n:N}
\sum_{b:[0,1]}
\underset{k:N}{\scalebox{2}{\raisebox{-2pt}{\ensuremath{\exists}}}}
\quad n=2\cdot k+b\]

then the program will only compute the lowest bit $b$. The machine cannot
tell which is the correct one, the user has to tell it what he wants.

\section{Source code of COQ GCD Proof}
This is the proof of GCD \cite{Coqu16a} in the COQ \cite{Coqu16} sources:
\begin{verbatim}
Library Coq.ZArith.Znumtheory

Require Import ZArith_base.
Require Import ZArithRing.
Require Import Zcomplements.
Require Import Zdiv.
Require Import Wf_nat.

For compatibility reasons, this Open Scope isn't local as it should

Open Scope Z_scope.

This file contains some notions of number theory upon Z numbers:

    a divisibility predicate Z.divide
    a gcd predicate gcd
    Euclid algorithm euclid
    a relatively prime predicate rel_prime
    a prime predicate prime
    properties of the efficient Z.gcd function


Notation Zgcd := Z.gcd (compat "8.3").
Notation Zggcd := Z.ggcd (compat "8.3").
Notation Zggcd_gcd := Z.ggcd_gcd (compat "8.3").
Notation Zggcd_correct_divisors := Z.ggcd_correct_divisors (compat "8.3").
Notation Zgcd_divide_l := Z.gcd_divide_l (compat "8.3").
Notation Zgcd_divide_r := Z.gcd_divide_r (compat "8.3").
Notation Zgcd_greatest := Z.gcd_greatest (compat "8.3").
Notation Zgcd_nonneg := Z.gcd_nonneg (compat "8.3").
Notation Zggcd_opp := Z.ggcd_opp (compat "8.3").

The former specialized inductive predicate Z.divide is now a generic existential predicate.

Notation Zdivide := Z.divide (compat "8.3").

Its former constructor is now a pseudo-constructor.

Definition Zdivide_intro a b q (H:b=q*a) : Z.divide a b := ex_intro _ q H.

Results concerning divisibility

Notation Zdivide_refl := Z.divide_refl (compat "8.3").
Notation Zone_divide := Z.divide_1_l (compat "8.3").
Notation Zdivide_0 := Z.divide_0_r (compat "8.3").
Notation Zmult_divide_compat_l := Z.mul_divide_mono_l (compat "8.3").
Notation Zmult_divide_compat_r := Z.mul_divide_mono_r (compat "8.3").
Notation Zdivide_plus_r := Z.divide_add_r (compat "8.3").
Notation Zdivide_minus_l := Z.divide_sub_r (compat "8.3").
Notation Zdivide_mult_l := Z.divide_mul_l (compat "8.3").
Notation Zdivide_mult_r := Z.divide_mul_r (compat "8.3").
Notation Zdivide_factor_r := Z.divide_factor_l (compat "8.3").
Notation Zdivide_factor_l := Z.divide_factor_r (compat "8.3").

Lemma Zdivide_opp_r a b : (a | b) -> (a | - b).

Lemma Zdivide_opp_r_rev a b : (a | - b) -> (a | b).

Lemma Zdivide_opp_l a b : (a | b) -> (- a | b).

Lemma Zdivide_opp_l_rev a b : (- a | b) -> (a | b).

Theorem Zdivide_Zabs_l a b : (Z.abs a | b) -> (a | b).

Theorem Zdivide_Zabs_inv_l a b : (a | b) -> (Z.abs a | b).

Hint Resolve Z.divide_refl Z.divide_1_l Z.divide_0_r: zarith.
Hint Resolve Z.mul_divide_mono_l Z.mul_divide_mono_r: zarith.
Hint Resolve Z.divide_add_r Zdivide_opp_r Zdivide_opp_r_rev Zdivide_opp_l
  Zdivide_opp_l_rev Z.divide_sub_r Z.divide_mul_l Z.divide_mul_r
  Z.divide_factor_l Z.divide_factor_r: zarith.

Auxiliary result.

Lemma Zmult_one x y : x >= 0 -> x * y = 1 -> x = 1.

Only 1 and -1 divide 1.

Notation Zdivide_1 := Z.divide_1_r (compat "8.3").

If a divides b and b divides a then a is b or -b.

Notation Zdivide_antisym := Z.divide_antisym (compat "8.3").
Notation Zdivide_trans := Z.divide_trans (compat "8.3").

If a divides b and b<>0 then |a| <= |b|.

Lemma Zdivide_bounds a b : (a | b) -> b <> 0 -> Z.abs a <= Z.abs b.

Z.divide can be expressed using Z.modulo.

Lemma Zmod_divide : forall a b, b<>0 -> a mod b = 0 -> (b | a).

Lemma Zdivide_mod : forall a b, (b | a) -> a mod b = 0.

Z.divide is hence decidable

Lemma Zdivide_dec a b : {(a | b)} + {~ (a | b)}.

Theorem Zdivide_Zdiv_eq a b : 0 < a -> (a | b) -> b = a * (b / a).

Theorem Zdivide_Zdiv_eq_2 a b c :
 0 < a -> (a | b) -> (c * b) / a = c * (b / a).

Theorem Zdivide_le: forall a b : Z,
 0 <= a -> 0 < b -> (a | b) -> a <= b.

Theorem Zdivide_Zdiv_lt_pos a b :
 1 < a -> 0 < b -> (a | b) -> 0 < b / a < b .

Lemma Zmod_div_mod n m a:
 0 < n -> 0 < m -> (n | m) -> a mod n = (a mod m) mod n.

Lemma Zmod_divide_minus a b c:
 0 < b -> a mod b = c -> (b | a - c).

Lemma Zdivide_mod_minus a b c:
 0 <= c < b -> (b | a - c) -> a mod b = c.

Greatest common divisor (gcd).
There is no unicity of the gcd; hence we define the predicate Zis_gcd a b g expressing that g is a gcd of a and b. (We show later that the gcd is actually unique if we discard its sign.)

Inductive Zis_gcd (a b g:Z) : Prop :=
 Zis_gcd_intro :
  (g | a) ->
  (g | b) ->
  (forall x, (x | a) -> (x | b) -> (x | g)) ->
  Zis_gcd a b g.

Trivial properties of gcd

Lemma Zis_gcd_sym : forall a b d, Zis_gcd a b d -> Zis_gcd b a d.

Lemma Zis_gcd_0 : forall a, Zis_gcd a 0 a.

Lemma Zis_gcd_1 : forall a, Zis_gcd a 1 1.

Lemma Zis_gcd_refl : forall a, Zis_gcd a a a.

Lemma Zis_gcd_minus : forall a b d, Zis_gcd a (- b) d -> Zis_gcd b a d.

Lemma Zis_gcd_opp : forall a b d, Zis_gcd a b d -> Zis_gcd b a (- d).

Lemma Zis_gcd_0_abs a : Zis_gcd 0 a (Z.abs a).

Hint Resolve Zis_gcd_sym Zis_gcd_0 Zis_gcd_minus Zis_gcd_opp: zarith.

Theorem Zis_gcd_unique: forall a b c d : Z,
 Zis_gcd a b c -> Zis_gcd a b d -> c = d \/ c = (- d).

Extended Euclid algorithm.
Euclid's algorithm to compute the gcd mainly relies on the following property.

Lemma Zis_gcd_for_euclid :
  forall a b d q:Z, Zis_gcd b (a - q * b) d -> Zis_gcd a b d.

Lemma Zis_gcd_for_euclid2 :
  forall b d q r:Z, Zis_gcd r b d -> Zis_gcd b (b * q + r) d.

We implement the extended version of Euclid's algorithm, i.e. the one computing Bezout's coefficients as it computes the gcd. We follow the algorithm given in Knuth's "Art of Computer Programming", vol 2, page 325.

Section extended_euclid_algorithm.

  Variables a b : Z.

The specification of Euclid's algorithm is the existence of u, v and d such that ua+vb=d and (gcd a b d).

  Inductive Euclid : Set :=
    Euclid_intro :
    forall u v d:Z, u * a + v * b = d -> Zis_gcd a b d -> Euclid.

The recursive part of Euclid's algorithm uses well-founded recursion of non-negative integers. It maintains 6 integers u1,u2,u3,v1,v2,v3 such that the following invariant holds: u1*a+u2*b=u3 and v1*a+v2*b=v3 and gcd(u3,v3)=gcd(a,b).

  Lemma euclid_rec :
    forall v3:Z,
      0 <= v3 ->
      forall u1 u2 u3 v1 v2:Z,
        u1 * a + u2 * b = u3 ->
        v1 * a + v2 * b = v3 ->
        (forall d:Z, Zis_gcd u3 v3 d -> Zis_gcd a b d) -> Euclid.

We get Euclid's algorithm by applying euclid_rec on 1,0,a,0,1,b when b>=0 and 1,0,a,0,-1,-b when b<0.

  Lemma euclid : Euclid.

End extended_euclid_algorithm.

Theorem Zis_gcd_uniqueness_apart_sign :
  forall a b d d':Z, Zis_gcd a b d -> Zis_gcd a b d' -> d = d' \/ d = - d'.

Bezout's coefficients

Inductive Bezout (a b d:Z) : Prop :=
  Bezout_intro : forall u v:Z, u * a + v * b = d -> Bezout a b d.

Existence of Bezout's coefficients for the gcd of a and b

Lemma Zis_gcd_bezout : forall a b d:Z, Zis_gcd a b d -> Bezout a b d.

gcd of ca and cb is c gcd(a,b).

Lemma Zis_gcd_mult :
  forall a b c d:Z, Zis_gcd a b d -> Zis_gcd (c * a) (c * b) (c * d).

Relative primality

Definition rel_prime (a b:Z) : Prop := Zis_gcd a b 1.

Bezout's theorem: a and b are relatively prime if and only if there exist u and v such that ua+vb = 1.

Lemma rel_prime_bezout : forall a b:Z, rel_prime a b -> Bezout a b 1.

Lemma bezout_rel_prime : forall a b:Z, Bezout a b 1 -> rel_prime a b.

Gauss's theorem: if a divides bc and if a and b are relatively prime, then a divides c.

Theorem Gauss : forall a b c:Z, (a | b * c) -> rel_prime a b -> (a | c).

If a is relatively prime to b and c, then it is to bc

Lemma rel_prime_mult :
  forall a b c:Z, rel_prime a b -> rel_prime a c -> rel_prime a (b * c).

Lemma rel_prime_cross_prod :
  forall a b c d:Z,
    rel_prime a b ->
    rel_prime c d -> b > 0 -> d > 0 -> a * d = b * c -> a = c /\ b = d.

After factorization by a gcd, the original numbers are relatively prime.

Lemma Zis_gcd_rel_prime :
  forall a b g:Z,
    b > 0 -> g >= 0 -> Zis_gcd a b g -> rel_prime (a / g) (b / g).

Theorem rel_prime_sym: forall a b, rel_prime a b -> rel_prime b a.

Theorem rel_prime_div: forall p q r,
 rel_prime p q -> (r | p) -> rel_prime r q.

Theorem rel_prime_1: forall n, rel_prime 1 n.

Theorem not_rel_prime_0: forall n, 1 < n -> ~ rel_prime 0 n.

Theorem rel_prime_mod: forall p q, 0 < q ->
 rel_prime p q -> rel_prime (p mod q) q.

Theorem rel_prime_mod_rev: forall p q, 0 < q ->
 rel_prime (p mod q) q -> rel_prime p q.

Theorem Zrel_prime_neq_mod_0: forall a b, 1 < b -> rel_prime a b -> a mod b <> 0.

Primality

Inductive prime (p:Z) : Prop :=
  prime_intro :
    1 < p -> (forall n:Z, 1 <= n < p -> rel_prime n p) -> prime p.

The sole divisors of a prime number p are -1, 1, p and -p.

Lemma prime_divisors :
  forall p:Z,
    prime p -> forall a:Z, (a | p) -> a = -1 \/ a = 1 \/ a = p \/ a = - p.

A prime number is relatively prime with any number it does not divide

Lemma prime_rel_prime :
  forall p:Z, prime p -> forall a:Z, ~ (p | a) -> rel_prime p a.

Hint Resolve prime_rel_prime: zarith.

As a consequence, a prime number is relatively prime with smaller numbers

Theorem rel_prime_le_prime:
 forall a p, prime p -> 1 <= a < p -> rel_prime a p.

If a prime p divides ab then it divides either a or b

Lemma prime_mult :
  forall p:Z, prime p -> forall a b:Z, (p | a * b) -> (p | a) \/ (p | b).

Lemma not_prime_0: ~ prime 0.

Lemma not_prime_1: ~ prime 1.

Lemma prime_2: prime 2.

Theorem prime_3: prime 3.

Theorem prime_ge_2 p : prime p -> 2 <= p.

Definition prime' p := 1<p /\ (forall n, 1<n<p -> ~ (n|p)).

Lemma Z_0_1_more x : 0<=x -> x=0 \/ x=1 \/ 1<x.

Theorem prime_alt p : prime' p <-> prime p.

Theorem square_not_prime: forall a, ~ prime (a * a).

Theorem prime_div_prime: forall p q,
 prime p -> prime q -> (p | q) -> p = q.

we now prove that Z.gcd is indeed a gcd in the sense of Zis_gcd.

Notation Zgcd_is_pos := Z.gcd_nonneg (compat "8.3").

Lemma Zgcd_is_gcd : forall a b, Zis_gcd a b (Z.gcd a b).

Theorem Zgcd_spec : forall x y : Z, {z : Z | Zis_gcd x y z /\ 0 <= z}.

Theorem Zdivide_Zgcd: forall p q r : Z,
 (p | q) -> (p | r) -> (p | Z.gcd q r).

Theorem Zis_gcd_gcd: forall a b c : Z,
 0 <= c -> Zis_gcd a b c -> Z.gcd a b = c.

Notation Zgcd_inv_0_l := Z.gcd_eq_0_l (compat "8.3").
Notation Zgcd_inv_0_r := Z.gcd_eq_0_r (compat "8.3").

Theorem Zgcd_div_swap0 : forall a b : Z,
 0 < Z.gcd a b ->
 0 < b ->
 (a / Z.gcd a b) * b = a * (b/Z.gcd a b).

Theorem Zgcd_div_swap : forall a b c : Z,
 0 < Z.gcd a b ->
 0 < b ->
 (c * a) / Z.gcd a b * b = c * a * (b/Z.gcd a b).

Notation Zgcd_comm := Z.gcd_comm (compat "8.3").

Lemma Zgcd_ass a b c : Z.gcd (Z.gcd a b) c = Z.gcd a (Z.gcd b c).

Notation Zgcd_Zabs := Z.gcd_abs_l (compat "8.3").
Notation Zgcd_0 := Z.gcd_0_r (compat "8.3").
Notation Zgcd_1 := Z.gcd_1_r (compat "8.3").

Hint Resolve Z.gcd_0_r Z.gcd_1_r : zarith.

Theorem Zgcd_1_rel_prime : forall a b,
 Z.gcd a b = 1 <-> rel_prime a b.

Definition rel_prime_dec: forall a b,
 { rel_prime a b }+{ ~ rel_prime a b }.

Definition prime_dec_aux:
 forall p m,
  { forall n, 1 < n < m -> rel_prime n p } +
  { exists n, 1 < n < m /\ ~ rel_prime n p }.

Definition prime_dec: forall p, { prime p }+{ ~ prime p }.

Theorem not_prime_divide:
 forall p, 1 < p -> ~ prime p -> exists n, 1 < n < p /\ (n | p).
 
\end{verbatim}

\chapter{LEAN proof of GCD}
This is the proof of GCD \cite{Avig14} in the LEAN \cite{Avig16} sources:
\begin{lstlisting}
/-
Copyright (c) 2014 Jeremy Avigad. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jeremy Avigad, Leonardo de Moura

Definitions and properties of gcd, lcm, and coprime.
-/
import .div
open eq.ops well_founded decidable prod

namespace nat

/- gcd -/

private definition pair_nat.lt : nat $\times$ nat $\rightarrow$ nat $\times$ nat $\rightarrow$ Prop := measure pr$_2$
private definition pair_nat.lt.wf : well_founded pair_nat.lt :=
intro_k (measure.wf pr$_2$) 20  -- we use intro_k to be able to execute gcd efficiently in the kernel

local attribute pair_nat.lt.wf [instance]      -- instance will not be saved in .olean
local infixl ` $\prec$ `:50 := pair_nat.lt

private definition gcd.lt.dec (x y$_1$ : nat) : (succ y$_1$, x % succ y$_1$) $\prec$ (x, succ y$_1$) :=
!mod_lt (succ_pos y$_1$)

definition gcd.F : $\Pi$ (p$_1$ : nat $\times$ nat), ($\Pi$ p$_2$ : nat $\times$ nat, p$_2$ $\prec$ p$_1$ $\rightarrow$ nat) $\rightarrow$ nat
| (x, 0)      f := x
| (x, succ y) f := f (succ y, x % succ y) !gcd.lt.dec

definition gcd (x y : nat) := fix gcd.F (x, y)

theorem gcd_zero_right [simp] (x : nat) : gcd x 0 = x := rfl

theorem gcd_succ [simp] (x y : nat) : gcd x (succ y) = gcd (succ y) (x % succ y) :=
well_founded.fix_eq gcd.F (x, succ y)

theorem gcd_one_right (n : $\mathbb{N}$) : gcd n 1 = 1 :=
calc gcd n 1 = gcd 1 (n % 1)  : gcd_succ
         ... = gcd 1 0        : mod_one

theorem gcd_def (x : $\mathbb{N}$) : $\Pi$ (y : $\mathbb{N}$), gcd x y = if y = 0 then x else gcd y (x % y)
| 0        := !gcd_zero_right
| (succ y) := !gcd_succ $\cdot$ (if_neg !succ_ne_zero)$^{-1}$


theorem gcd_self : $\Pi$ (n : $\mathbb{N}$), gcd n n = n
| 0         := rfl
| (succ n$_1$) := calc
    gcd (succ n$_1$) (succ n$_1$) = gcd (succ n$_1$) (succ n$_1$ % succ n$_1$) : gcd_succ
                      ...   = gcd (succ n$_1$) 0                     : mod_self

theorem gcd_zero_left : $\Pi$ (n : $\mathbb{N}$), gcd 0 n = n
| 0         := rfl
| (succ n$_1$) := calc
    gcd 0 (succ n$_1$) = gcd (succ n$_1$) (0 % succ n$_1$) : gcd_succ
                ... = gcd (succ n$_1$) 0               : zero_mod

theorem gcd_of_pos (m : $\mathbb{N}$) {n : $\mathbb{N}$} (H : n > 0) : gcd m n = gcd n (m % n) :=
gcd_def m n $\cdot$ if_neg (ne_zero_of_pos H)

theorem gcd_rec (m n : $\mathbb{N}$) : gcd m n = gcd n (m % n) :=
by_cases_zero_pos n
  (calc
          m = gcd 0 m       : gcd_zero_left
        ... = gcd 0 (m % 0) : mod_zero)
  (take n, assume H : 0 < n, gcd_of_pos m H)

theorem gcd.induction {P : $\mathbb{N}$ $\rightarrow$ $\mathbb{N}$ $\rightarrow$ Prop}
                   (m n : $\mathbb{N}$)
                   (H0 : $\forall$m, P m 0)
                   (H1 : $\forall$m n, 0 < n $\rightarrow$ P n (m % n) $\rightarrow$ P m n) :
                 P m n :=
induction (m, n) (prod.rec ($\lambda$m, nat.rec ($\lambda$ IH, H0 m)
   ($\lambda$ n$_1$ v (IH : $\forall$p$_2$, p$_2$ $\prec$ (m, succ n$_1$) $\rightarrow$ P (pr$_1$ p$_2$) (pr$_2$ p$_2$)),
      H1 m (succ n$_1$) !succ_pos (IH _ !gcd.lt.dec))))

theorem gcd_dvd (m n : $\mathbb{N}$) : (gcd m n $|$ m) $\wedge$ (gcd m n $|$ n) :=
gcd.induction m n
  (take m, and.intro (!one_mul $\triangleright$ !dvd_mul_left) !dvd_zero)
  (take m n (npos : 0 < n), and.rec
     (assume (IH$_1$ : gcd n (m % n) $|$ n) (IH$_2$ : gcd n (m % n) $|$ (m % n)),
    have H : (gcd n (m % n) $|$ (m / n * n + m % n)), from
      dvd_add (dvd.trans IH$_1$ !dvd_mul_left) IH$_2$,
    have H1 : (gcd n (m % n) $|$ m), from !eq_div_mul_add_mod$^{-1}$ $\triangleright$ H,
    show (gcd m n $|$ m) $\wedge$ (gcd m n $|$ n), from !gcd_rec$^{-1}$ $\triangleright$ (and.intro H1 IH$_1$)))

theorem gcd_dvd_left (m n : $\mathbb{N}$) : gcd m n $|$ m := and.left !gcd_dvd

theorem gcd_dvd_right (m n : $\mathbb{N}$) : gcd m n $|$ n := and.right !gcd_dvd

theorem dvd_gcd {m n k : $\mathbb{N}$} : k $|$ m $\rightarrow$ k $|$ n $\rightarrow$ k $|$ gcd m n :=
gcd.induction m n (take m, imp.intro)
  (take m n (npos : n > 0)
    (IH : k $|$ n $\rightarrow$ k $|$ m % n $\rightarrow$ k $|$ gcd n (m % n))
    (H1 : k $|$ m) (H2 : k $|$ n),
    have H3 : k $|$ m / n * n + m % n, from !eq_div_mul_add_mod $\triangleright$ H1,
    have H4 : k $|$ m % n, from nat.dvd_of_dvd_add_left H3 (dvd.trans H2 !dvd_mul_left),
    !gcd_rec$^{-1}$ $\triangleright$ IH H2 H4)

theorem gcd.comm (m n : $\mathbb{N}$) : gcd m n = gcd n m :=
dvd.antisymm
  (dvd_gcd !gcd_dvd_right !gcd_dvd_left)
  (dvd_gcd !gcd_dvd_right !gcd_dvd_left)

theorem gcd.assoc (m n k : $\mathbb{N}$) : gcd (gcd m n) k = gcd m (gcd n k) :=
dvd.antisymm
  (dvd_gcd
    (dvd.trans !gcd_dvd_left !gcd_dvd_left)
    (dvd_gcd (dvd.trans !gcd_dvd_left !gcd_dvd_right) !gcd_dvd_right))
  (dvd_gcd
    (dvd_gcd !gcd_dvd_left (dvd.trans !gcd_dvd_right !gcd_dvd_left))
    (dvd.trans !gcd_dvd_right !gcd_dvd_right))

theorem gcd_one_left (m : $\mathbb{N}$) : gcd 1 m = 1 :=
!gcd.comm $\cdot$ !gcd_one_right

theorem gcd_mul_left (m n k : $\mathbb{N}$) : gcd (m * n) (m * k) = m * gcd n k :=
gcd.induction n k
  (take n, calc gcd (m * n) (m * 0) = gcd (m * n) 0 : mul_zero)
  (take n k,
    assume H : 0 < k,
    assume IH : gcd (m * k) (m * (n % k)) = m * gcd k (n % k),
    calc
      gcd (m * n) (m * k) = gcd (m * k) (m * n % (m * k)) : !gcd_rec
                      ... = gcd (m * k) (m * (n % k))     : mul_mod_mul_left
                      ... = m * gcd k (n % k)             : IH
                      ... = m * gcd n k                   : !gcd_rec)

theorem gcd_mul_right (m n k : $\mathbb{N}$) : gcd (m * n) (k * n) = gcd m k * n :=
calc
  gcd (m * n) (k * n) = gcd (n * m) (k * n) : mul.comm
                  ... = gcd (n * m) (n * k) : mul.comm
                  ... = n * gcd m k         : gcd_mul_left
                  ... = gcd m k * n         : mul.comm

theorem gcd_pos_of_pos_left {m : $\mathbb{N}$} (n : $\mathbb{N}$) (mpos : m > 0) : gcd m n > 0 :=
pos_of_dvd_of_pos !gcd_dvd_left mpos

theorem gcd_pos_of_pos_right (m : $\mathbb{N}$) {n : $\mathbb{N}$} (npos : n > 0) : gcd m n > 0 :=
pos_of_dvd_of_pos !gcd_dvd_right npos

theorem eq_zero_of_gcd_eq_zero_left {m n : $\mathbb{N}$} (H : gcd m n = 0) : m = 0 :=
or.elim (eq_zero_or_pos m)
  (assume H1, H1)
  (assume H1 : m > 0, absurd H$^{-1}$ (ne_of_lt (!gcd_pos_of_pos_left H1)))

theorem eq_zero_of_gcd_eq_zero_right {m n : $\mathbb{N}$} (H : gcd m n = 0) : n = 0 :=
eq_zero_of_gcd_eq_zero_left (!gcd.comm $\triangleright$ H)

theorem gcd_div {m n k : $\mathbb{N}$} (H1 : k $|$ m) (H2 : k $|$ n) :
  gcd (m / k) (n / k) = gcd m n / k :=
or.elim (eq_zero_or_pos k)
  (assume H3 : k = 0, by subst k; rewrite *nat.div_zero)
  (assume H3 : k > 0, (nat.div_eq_of_eq_mul_left H3 (calc
        gcd m n = gcd m (n / k * k)             : nat.div_mul_cancel H2
            ... = gcd (m / k * k) (n / k * k) : nat.div_mul_cancel H1
            ... = gcd (m / k) (n / k) * k     : gcd_mul_right))$^{-1}$)

theorem gcd_dvd_gcd_mul_left (m n k : $\mathbb{N}$) : gcd m n $|$ gcd (k * m) n :=
dvd_gcd (dvd.trans !gcd_dvd_left !dvd_mul_left) !gcd_dvd_right

theorem gcd_dvd_gcd_mul_right (m n k : $\mathbb{N}$) : gcd m n $|$ gcd (m * k) n :=
!mul.comm $\triangleright$ !gcd_dvd_gcd_mul_left

theorem gcd_dvd_gcd_mul_left_right (m n k : $\mathbb{N}$) : gcd m n $|$ gcd m (k * n) :=
dvd_gcd  !gcd_dvd_left (dvd.trans !gcd_dvd_right !dvd_mul_left)

theorem gcd_dvd_gcd_mul_right_right (m n k : $\mathbb{N}$) : gcd m n $|$ gcd m (n * k) :=
!mul.comm $\triangleright$ !gcd_dvd_gcd_mul_left_right

/- lcm -/

definition lcm (m n : $\mathbb{N}$) : $\mathbb{N}$ := m * n / (gcd m n)

theorem lcm.comm (m n : $\mathbb{N}$) : lcm m n = lcm n m :=
calc
  lcm m n = m * n / gcd m n : rfl
      ... = n * m / gcd m n : mul.comm
      ... = n * m / gcd n m : gcd.comm
      ... = lcm n m           : rfl

theorem lcm_zero_left (m : $\mathbb{N}$) : lcm 0 m = 0 :=
calc
  lcm 0 m = 0 * m / gcd 0 m : rfl
      ... = 0 / gcd 0 m     : zero_mul
      ... = 0                 : nat.zero_div

theorem lcm_zero_right (m : $\mathbb{N}$) : lcm m 0 = 0 := !lcm.comm $\triangleright$ !lcm_zero_left

theorem lcm_one_left (m : $\mathbb{N}$) : lcm 1 m = m :=
calc
  lcm 1 m = 1 * m / gcd 1 m : rfl
      ... = m / gcd 1 m     : one_mul
      ... = m / 1           : gcd_one_left
      ... = m                 : nat.div_one

theorem lcm_one_right (m : $\mathbb{N}$) : lcm m 1 = m := !lcm.comm $\triangleright$ !lcm_one_left

theorem lcm_self (m : $\mathbb{N}$) : lcm m m = m :=
have H : m * m / m = m, from
  by_cases_zero_pos m !nat.div_zero (take m, assume H1 : m > 0, !nat.mul_div_cancel H1),
calc
  lcm m m = m * m / gcd m m : rfl
      ... = m * m / m       : gcd_self
      ... = m                 : H

theorem dvd_lcm_left (m n : $\mathbb{N}$) : m $|$ lcm m n :=
have H : lcm m n = m * (n / gcd m n), from nat.mul_div_assoc _ !gcd_dvd_right,
dvd.intro H$^{-1}$

theorem dvd_lcm_right (m n : $\mathbb{N}$) : n $|$ lcm m n :=
!lcm.comm $\triangleright$ !dvd_lcm_left

theorem gcd_mul_lcm (m n : $\mathbb{N}$) : gcd m n * lcm m n = m * n :=
eq.symm (nat.eq_mul_of_div_eq_right (dvd.trans !gcd_dvd_left !dvd_mul_right) rfl)

theorem lcm_dvd {m n k : $\mathbb{N}$} (H1 : m $|$ k) (H2 : n $|$ k) : lcm m n $|$ k :=
or.elim (eq_zero_or_pos k)
  (assume kzero : k = 0, !kzero$^{-1}$ $\triangleright$ !dvd_zero)
  (assume kpos : k > 0,
    have mpos : m > 0, from pos_of_dvd_of_pos H1 kpos,
    have npos : n > 0, from pos_of_dvd_of_pos H2 kpos,
    have gcd_pos : gcd m n > 0, from !gcd_pos_of_pos_left mpos,
    obtain p (km : k = m * p), from exists_eq_mul_right_of_dvd H1,
    obtain q (kn : k = n * q), from exists_eq_mul_right_of_dvd H2,
    have ppos : p > 0, from pos_of_mul_pos_left (km $\triangleright$ kpos),
    have qpos : q > 0, from pos_of_mul_pos_left (kn $\triangleright$ kpos),
    have H3 : p * q * (m * n * gcd p q) = p * q * (gcd m n * k), from
    calc
      p * q * (m * n * gcd p q)
            = m * p * (n * q * gcd p q)       : by rewrite [*mul.assoc, *mul.left_comm q,
                                                             mul.left_comm p]
        ... = k * (k * gcd p q)               : by rewrite [-kn, -km]
        ... = k * gcd (k * p) (k * q)         : by rewrite gcd_mul_left
        ... = k * gcd (n * q * p) (m * p * q) : by rewrite [-kn, -km]
        ... = k * (gcd n m * (p * q))         : by rewrite [*mul.assoc, mul.comm q, gcd_mul_right]
        ... = p * q * (gcd m n * k)           : by rewrite [mul.comm, mul.comm (gcd n m), gcd.comm,
                                                             *mul.assoc],
    have H4 : m * n * gcd p q = gcd m n * k,
      from !eq_of_mul_eq_mul_left (mul_pos ppos qpos) H3,
    have H5 : gcd m n * (lcm m n * gcd p q) = gcd m n * k,
      from !mul.assoc $\triangleright$ !gcd_mul_lcm$^{-1}$ $\triangleright$ H4,
    have H6 : lcm m n * gcd p q = k,
      from !eq_of_mul_eq_mul_left gcd_pos H5,
    dvd.intro H6)

theorem lcm.assoc (m n k : $\mathbb{N}$) : lcm (lcm m n) k = lcm m (lcm n k) :=
dvd.antisymm
  (lcm_dvd
    (lcm_dvd !dvd_lcm_left (dvd.trans !dvd_lcm_left !dvd_lcm_right))
    (dvd.trans !dvd_lcm_right !dvd_lcm_right))
  (lcm_dvd
    (dvd.trans !dvd_lcm_left !dvd_lcm_left)
    (lcm_dvd (dvd.trans !dvd_lcm_right !dvd_lcm_left) !dvd_lcm_right))

/- coprime -/

definition coprime [reducible] (m n : $\mathbb{N}$) : Prop := gcd m n = 1

lemma gcd_eq_one_of_coprime {m n : $\mathbb{N}$} : coprime m n $\rightarrow$ gcd m n = 1 :=
$\lambda$ h, h

theorem coprime_swap {m n : $\mathbb{N}$} (H : coprime n m) : coprime m n :=
!gcd.comm $\triangleright$ H

theorem dvd_of_coprime_of_dvd_mul_right {m n k : $\mathbb{N}$} (H1 : coprime k n) (H2 : k $|$ m * n) : k $|$ m :=
have H3 : gcd (m * k) (m * n) = m, from
  calc
    gcd (m * k) (m * n) = m * gcd k n : gcd_mul_left
                    ... = m * 1       : H1
                    ... = m           : mul_one,
have H4 : (k $|$ gcd (m * k) (m * n)), from dvd_gcd !dvd_mul_left H2,
H3 $\triangleright$ H4

theorem dvd_of_coprime_of_dvd_mul_left {m n k : $\mathbb{N}$} (H1 : coprime k m) (H2 : k $|$ m * n) : k $|$ n :=
dvd_of_coprime_of_dvd_mul_right H1 (!mul.comm $\triangleright$ H2)

theorem gcd_mul_left_cancel_of_coprime {k : $\mathbb{N}$} (m : $\mathbb{N}$) {n : $\mathbb{N}$} (H : coprime k n) :
   gcd (k * m) n = gcd m n :=
have H1 : coprime (gcd (k * m) n) k, from
  calc
    gcd (gcd (k * m) n) k
         = gcd (k * gcd 1 m) n : by rewrite [-gcd_mul_left, mul_one, gcd.comm, gcd.assoc]
     ... = 1                   : by rewrite [gcd_one_left, mul_one, $\uparrow$coprime at H, H],
dvd.antisymm
  (dvd_gcd (dvd_of_coprime_of_dvd_mul_left H1 !gcd_dvd_left) !gcd_dvd_right)
  (dvd_gcd (dvd.trans !gcd_dvd_left !dvd_mul_left) !gcd_dvd_right)

theorem gcd_mul_right_cancel_of_coprime (m : $\mathbb{N}$) {k n : $\mathbb{N}$} (H : coprime k n) :
   gcd (m * k) n = gcd m n :=
!mul.comm $\triangleright$ !gcd_mul_left_cancel_of_coprime H

theorem gcd_mul_left_cancel_of_coprime_right {k m : $\mathbb{N}$} (n : $\mathbb{N}$) (H : coprime k m) :
   gcd m (k * n) = gcd m n :=
!gcd.comm $\triangleright$ !gcd.comm $\triangleright$ !gcd_mul_left_cancel_of_coprime H

theorem gcd_mul_right_cancel_of_coprime_right {k m : $\mathbb{N}$} (n : $\mathbb{N}$) (H : coprime k m) :
   gcd m (n * k) = gcd m n :=
!gcd.comm $\triangleright$ !gcd.comm $\triangleright$ !gcd_mul_right_cancel_of_coprime H

theorem coprime_div_gcd_div_gcd {m n : $\mathbb{N}$} (H : gcd m n > 0) :
  coprime (m / gcd m n) (n / gcd m n) :=
calc
  gcd (m / gcd m n) (n / gcd m n) = gcd m n / gcd m n : gcd_div !gcd_dvd_left !gcd_dvd_right
     ... = 1 : nat.div_self H

theorem not_coprime_of_dvd_of_dvd {m n d : $\mathbb{N}$} (dgt1 : d > 1) (Hm : d $|$ m) (Hn : d $|$ n) :
  ¬ coprime m n :=
assume co : coprime m n,
have d $|$ gcd m n, from dvd_gcd Hm Hn,
have d $|$ 1, by rewrite [$\uparrow$coprime at co, co at this]; apply this,
have d $\leq$ 1, from le_of_dvd dec_trivial this,
show false, from not_lt_of_ge `d $\leq$ 1` `d > 1`

theorem exists_coprime {m n : $\mathbb{N}$} (H : gcd m n > 0) :
  exists m' n', coprime m' n' $\wedge$ m = m' * gcd m n $\wedge$ n = n' * gcd m n :=
have H1 : m = (m / gcd m n) * gcd m n, from (nat.div_mul_cancel !gcd_dvd_left)$^{-1}$,
have H2 : n = (n / gcd m n) * gcd m n, from (nat.div_mul_cancel !gcd_dvd_right)$^{-1}$,
exists.intro _ (exists.intro _ (and.intro (coprime_div_gcd_div_gcd H) (and.intro H1 H2)))

theorem coprime_mul {m n k : $\mathbb{N}$} (H1 : coprime m k) (H2 : coprime n k) : coprime (m * n) k :=
calc
  gcd (m * n) k = gcd n k : !gcd_mul_left_cancel_of_coprime H1
            ... = 1       : H2

theorem coprime_mul_right {k m n : $\mathbb{N}$} (H1 : coprime k m) (H2 : coprime k n) : coprime k (m * n) :=
coprime_swap (coprime_mul (coprime_swap H1) (coprime_swap H2))

theorem coprime_of_coprime_mul_left {k m n : $\mathbb{N}$} (H : coprime (k * m) n) : coprime m n :=
have H1 : (gcd m n $|$ gcd (k * m) n), from !gcd_dvd_gcd_mul_left,
eq_one_of_dvd_one (H $\triangleright$ H1)

theorem coprime_of_coprime_mul_right {k m n : $\mathbb{N}$} (H : coprime (m * k) n) : coprime m n :=
coprime_of_coprime_mul_left (!mul.comm $\triangleright$ H)

theorem coprime_of_coprime_mul_left_right {k m n : $\mathbb{N}$} (H : coprime m (k * n)) : coprime m n :=
coprime_swap (coprime_of_coprime_mul_left (coprime_swap H))

theorem coprime_of_coprime_mul_right_right {k m n : $\mathbb{N}$} (H : coprime m (n * k)) : coprime m n :=
coprime_of_coprime_mul_left_right (!mul.comm $\triangleright$ H)

theorem comprime_one_left : $\forall$ n, coprime 1 n :=
$\lambda$ n, !gcd_one_left

theorem comprime_one_right : $\forall$ n, coprime n 1 :=
$\lambda$ n, !gcd_one_right

theorem exists_eq_prod_and_dvd_and_dvd {m n k : nat} (H : k $|$ m * n) :
  $\exists$ m' n', k = m' * n' $\wedge$ m' $|$ m $\wedge$ n' $|$ n :=
or.elim (eq_zero_or_pos (gcd k m))
 (assume H1 : gcd k m = 0,
    have H2 : k = 0, from eq_zero_of_gcd_eq_zero_left H1,
    have H3 : m = 0, from eq_zero_of_gcd_eq_zero_right H1,
    have H4 : k = 0 * n, from H2 $\cdot$ !zero_mul$^{-1}$,
    have H5 : 0 $|$ m, from H3$^{-1}$ $\triangleright$ !dvd.refl,
    have H6 : n $|$ n, from !dvd.refl,
    exists.intro _ (exists.intro _ (and.intro H4 (and.intro H5 H6))))
  (assume H1 : gcd k m > 0,
    have H2 : gcd k m $|$ k, from !gcd_dvd_left,
    have H3 : k / gcd k m $|$ (m * n) / gcd k m, from nat.div_dvd_div H2 H,
    have H4 : (m * n) / gcd k m = (m / gcd k m) * n, from
      calc
        m * n / gcd k m = n * m / gcd k m   : mul.comm
                      ... = n * (m / gcd k m) : !nat.mul_div_assoc !gcd_dvd_right
                      ... = m / gcd k m * n   : mul.comm,
    have H5 : k / gcd k m $|$ (m / gcd k m) * n, from H4 $\triangleright$ H3,
    have H6 : coprime (k / gcd k m) (m / gcd k m), from coprime_div_gcd_div_gcd H1,
    have H7 : k / gcd k m $|$ n, from dvd_of_coprime_of_dvd_mul_left H6 H5,
    have H8 : k = gcd k m * (k / gcd k m), from (nat.mul_div_cancel' H2)$^{-1}$,
    exists.intro _ (exists.intro _ (and.intro H8 (and.intro !gcd_dvd_right H7))))

end nat

\end{lstlisting}

\chapter{Formal Pre- and Post-conditions}
In Boldo \cite{Bold11} we find an effort to verify floating point software
using preconditions, postconditions, and assertions. Quoting:

``These conjectures can be described formally by annotations as follows.
\begin{verbatim}
/*@ requires \abs(x) <= 0x1p-5;
  @ ensures \abs(\result - \cos(x)) <= 0x1p-23;
  @*/
float my_cosine(float x) {
  //@ assert \abs(1.0 - x*x*0.5 - \cos(x)) < 0x1p-24;
  return 1.0f - x * x * 0.5f;
}
\end{verbatim}
The {\sl precondition}, introduced by {\bf requires}, states that we expect
argument {\sl x} in the interval [-1/32; 1/32]. The {\sl postcondition},
introduced by {\bf ensures}, states that the distance between the value
returned by the function, denoted by the keyword {\bf \verb|\result|}, and the
model of the program, which is here the true mathematical cosine function
denoted by {\bf \verb|\cos|} in ACSL, is not greater than $2^{-23}$. It is
important to notice that in annotations the operators like $+$ or $*$
denote operations on real numbers and not on floating-point numbers. In
particular, there is no rounding error and no overflow in annotations,
unlike in the early Leavens' proposal. The C variables of type {\tt float},
like {\tt x} and {\tt \verb|\result|} in this example, are interpreted as the
real number they represent. Thus, the last annotation, given as an
assertion inside the code, is a way to make explicit the reasoning we made
above, making the total error the sum of the method error and the rounding
error: it states that the method error is less than $2^{-24}$. Again, it
is thanks to the choice of having exact operations in the annotations that
we are able to state a property of the method error.''

In Boldo \cite{Bold07,Bold07a} we find 'search in an array' annotated:
\begin{verbatim}
/*@ requires \valid_range(t,0,n-1)
  @ ensures
  @  (0 <= \result < n => t[\result] == v) &&
  @  (\result == n =>
  @    \forall int i; 0 <= i < n => t[i] != v) */
int index(int t[], int n, int v) {
  int i = 0;
  /*@ invariant 0 <= i &&
    @  \forall int k; 0 <= k <i => t[k] != v
    @ variant n - i */
  while (i < n) {
    if (t[i] == v) break;
    i++;
  }
  return i;
}
\end{verbatim}

\chapter{Types and Signatures}

We need to start from a base of the existing types in Common Lisp,
eventually providing Axiom combinations or specializations.
Common Lisp has these standard type specifier symbols.
\begin{center}
{\bf Common Lisp Type Hierarchy} \cite{Pfei12}\\
\includegraphics[scale=0.5]{ps/v13cltypehierarchy.eps}
\end{center}

Axiom adds these types:
\begin{itemize}
\item Command = String
\end{itemize}

From Carette, et al. \cite{Care11a} we find:
\begin{verbatim}
LeftNearSemiRing := Theory {
  U : type;
  * : (U, U) -> U;
  + : (U, U) -> U;
  0 : U;
  axiom right_Identity_+_0: forall x : U. x + 0 = x;
  axiom leftIdentity_+_0 := forall x : U. 0 + x = x;
  axiom leftDistributive_*_+ :=
    forall x,y,z : U. x * (y + z) = (x * y) + (x * z);
  axiom left0 := forall x : U. 0 * x = 0;
  axiom associative_+ :=
    forall x,y,z : U. (x + y) + z = x + (y + z);
  axiom associative_* :=
    forall x,y,z : U. (x * y) * z = x * (y * z);
\end{verbatim}

\chapter{COQ nat vs Axiom NNI}

COQ's nat domain includes a proof of GCD.

We would like to show an isomorphism between types in Coq and
types in Axiom. Having such an isomorphism will make lemmas
available and simplify future proofs.

Note that Coq's {\tt nat} domain stops at O (a symbolic 0)
as does Axiom's NNI. The Axiom interpreter will promote a
subtraction to Integer whereas Coq will not.

COQ's nat domain \cite{COQnat} is

\subsection{Library Coq.Init.Nat}

\begin{verbatim}
Require Import Notations Logic Datatypes.

Local Open Scope nat_scope.
\end{verbatim}

{\bf Peano natural numbers, definitions of operations}

This file is meant to be used as a whole module, without importing it,
leading to qualified definitions (e.g. Nat.pred)

\begin{verbatim}
Definition t := nat.
\end{verbatim}

{\bf Constants}

\begin{verbatim}
Definition zero := 0.
Definition one := 1.
Definition two := 2.
\end{verbatim}

{\bf Basic operations}

\begin{verbatim}
Definition succ := S.

Definition pred n :=
  match n with
    | 0 => n
    | S u => u
  end.

Fixpoint add n m :=
  match n with
  | 0 => m
  | S p => S (p + m)
  end

where "n + m" := (add n m) : nat_scope.

Definition double n := n + n.

Fixpoint mul n m :=
  match n with
  | 0 => 0
  | S p => m + p * m
  end

where "n * m" := (mul n m) : nat_scope.

\end{verbatim}

Note that Axiom's NNI domain will be automatically promoted to Integer
when the subtraction result is negative. Coq returns O when this occurs.

\begin{verbatim}
Truncated subtraction: n-m is 0 if n<=m

Fixpoint sub n m :=
  match n, m with
  | S k, S l => k - l
  | _, _ => n
  end

where "n - m" := (sub n m) : nat_scope.

\end{verbatim}
{\bf Comparisons}
\begin{verbatim}

Fixpoint eqb n m : bool :=
  match n, m with
    | 0, 0 => true
    | 0, S _ => false
    | S _, 0 => false
    | S n', S m' => eqb n' m'
  end.

Fixpoint leb n m : bool :=
  match n, m with
    | 0, _ => true
    | _, 0 => false
    | S n', S m' => leb n' m'
  end.

Definition ltb n m := leb (S n) m.

Infix "=?" := eqb (at level 70) : nat_scope.
Infix "<=?" := leb (at level 70) : nat_scope.
Infix "<?" := ltb (at level 70) : nat_scope.

Fixpoint compare n m : comparison :=
  match n, m with
   | 0, 0 => Eq
   | 0, S _ => Lt
   | S _, 0 => Gt
   | S n', S m' => compare n' m'
  end.

Infix "?=" := compare (at level 70) : nat_scope.

\end{verbatim}
{\bf Minimum, maximum}
\begin{verbatim}

Fixpoint max n m :=
  match n, m with
    | 0, _ => m
    | S n', 0 => n
    | S n', S m' => S (max n' m')
  end.

Fixpoint min n m :=
  match n, m with
    | 0, _ => 0
    | S n', 0 => 0
    | S n', S m' => S (min n' m')
  end.

\end{verbatim}
{\bf Parity tests}
\begin{verbatim}

Fixpoint even n : bool :=
  match n with
    | 0 => true
    | 1 => false
    | S (S n') => even n'
  end.

Definition odd n := negb (even n).

\end{verbatim}
{\bf Power}
\begin{verbatim}

Fixpoint pow n m :=
  match m with
    | 0 => 1
    | S m => n * (n^m)
  end

where "n ^ m" := (pow n m) : nat_scope.

\end{verbatim}
{\bf Euclidean division}
\begin{verbatim}
This division is linear and tail-recursive. In divmod, y is the 
predecessor of the actual divisor, and u is y minus the real remainder

Fixpoint divmod x y q u :=
  match x with
    | 0 => (q,u)
    | S x' => match u with
                | 0 => divmod x' y (S q) y
                | S u' => divmod x' y q u'
              end
  end.

Definition div x y :=
  match y with
    | 0 => y
    | S y' => fst (divmod x y' 0 y')
  end.

Definition modulo x y :=
  match y with
    | 0 => y
    | S y' => y' - snd (divmod x y' 0 y')
  end.

Infix "/" := div : nat_scope.
Infix "mod" := modulo (at level 40, no associativity) : nat_scope.

\end{verbatim}
{\bf Greatest common divisor} 
\begin{verbatim}
We use Euclid algorithm, which is normally not structural, but Coq is 
now clever enough to accept this (behind modulo there is a subtraction, 
which now preserves being a subterm)

Fixpoint gcd a b :=
  match a with
   | O => b
   | S a' => gcd (b mod (S a')) (S a')
  end.

\end{verbatim}
{\bf Square}
\begin{verbatim}

Definition square n := n * n.

\end{verbatim}
{\bf Square root}
\begin{verbatim} 

The following square root function is linear (and tail-recursive). 
With Peano representation, we can't do better. For faster algorithm, 
see Psqrt/Zsqrt/Nsqrt...  We search the square root of 
n = k + p^2 + (q - r) with q = 2p and 0<=r<=q. We start with
p=q=r=0, hence looking for the square root of n = k. Then we
progressively decrease k and r. When k = S k' and r=0, it means we can
use (S p) as new sqrt candidate, since (S k')+p^2+2p = k'+(S
p)^2. When k reaches 0, we have found the biggest p^2 square contained
in n, hence the square root of n is p.

Fixpoint sqrt_iter k p q r :=
  match k with
    | O => p
    | S k' => match r with
                | O => sqrt_iter k' (S p) (S (S q)) (S (S q))
                | S r' => sqrt_iter k' p q r'
              end
  end.

Definition sqrt n := sqrt_iter n 0 0 0.

\end{verbatim}
{\bf Log2} 
\begin{verbatim}
This base-2 logarithm is linear and tail-recursive.  In
log2_iter, we maintain the logarithm p of the counter q, while r is
the distance between q and the next power of 2, more precisely q + S r
= 2^(S p) and r<2^p. At each recursive call, q goes up while r goes
down. When r is 0, we know that q has almost reached a power of 2, and
we increase p at the next call, while resetting r to q.  Graphically
(numbers are q, stars are r) :

                    10
                  9
                8
              7   *
            6       *
          5           ...
        4
      3   *
    2       *
  1   *       *
0   *   *       *

We stop when k, the global downward counter reaches 0. At that moment,
q is the number we're considering (since k+q is invariant), and p its
logarithm.

Fixpoint log2_iter k p q r :=
  match k with
    | O => p
    | S k' => match r with
                | O => log2_iter k' (S p) (S q) q
                | S r' => log2_iter k' p (S q) r'
              end
  end.

Definition log2 n := log2_iter (pred n) 0 1 0.

Iterator on natural numbers

Definition iter (n:nat) {A} (f:A->A) (x:A) : A :=
 nat_rect (fun _ => A) x (fun _ => f) n.

Bitwise operations We provide here some bitwise operations for unary
numbers. Some might be really naive, they are just there for
fullfiling the same interface as other for natural representations. As
soon as binary representations such as NArith are available, it is
clearly better to convert to/from them and use their ops.

Fixpoint div2 n :=
  match n with
  | 0 => 0
  | S 0 => 0
  | S (S n') => S (div2 n')
  end.

Fixpoint testbit a n : bool :=
 match n with
   | 0 => odd a
   | S n => testbit (div2 a) n
 end.

Definition shiftl a := nat_rect _ a (fun _ => double).
Definition shiftr a := nat_rect _ a (fun _ => div2).

Fixpoint bitwise (op:bool->bool->bool) n a b :=
 match n with
  | 0 => 0
  | S n' =>
    (if op (odd a) (odd b) then 1 else 0) +
    2*(bitwise op n' (div2 a) (div2 b))
 end.

Definition land a b := bitwise andb a a b.
Definition lor a b := bitwise orb (max a b) a b.
Definition ldiff a b := bitwise (fun b b' => andb b (negb b')) a a b.
Definition lxor a b := bitwise xorb (max a b) a b.
\end{verbatim}

\chapter{Binary Power in COQ by Casteran and Sozeau}

From Casteran and Sozeau \cite{Cast16}:

\begin{verbatim}
(* About integer powers (monomorphic version) *)

Set Implicit Arguments.
Require Import ZArith.
Require Import Div2.
Require Import Program.
Open Scope Z_scope.
\end{verbatim}

Let us consider a simple arithmetic operation: raising some integer $x$
to the $n$-th power, where $n$ is a natural number. The following
function definition is a direct translation of the mathematical
concept:
\begin{verbatim}
Fixpoint power (a:Z)(n:nat) :=
  match n with 0%nat => 1
             | S p =>  a * power a p
  end.

Eval vm_compute in power 2 40.
 = 1099511627776 : Z
\end{verbatim}

This definition can be considered as a very naive way of programming,
since computing $x^n$ requires $n$ multiplications. Nevertheless, this
definition is very simple to read, and everyone can admit that it is
correct with respect to the mathematical definition. Thus, we can consider
it as a {\sl specification}: when we write more efficient but less readable
functions for exponentiation, we should be able to prove their correctness
by proving in Coq their equivalence with the naive power function.

The following function allows one to compute $x^n$, with a number of
multiplications proportional to $\log_2(n)$:
\begin{verbatim}
Program
Fixpoint binary_power_mult (acc x:Z) (n:nat) {measure (fun i=>i) n} : Z
  (* acc * (power x n) *) :=
  match n with 
    | 0%nat => acc
    | _ => if Even.even_odd_dec n
           then binary_power_mult acc (x * x) (div2 n)
           else binary_power_mult (acc * x) (x * x) (div2 n)
  end.

Solve Obligations with program_simpl; intros; apply lt_div2; auto with arith.

Definition binary_power (x:Z)(n:nat) := binary_power_mult 1 x n.

Eval vm_compute in binary_power 2 40.
 = 1099511627776 : Z

Goal binary_power 2 234 = power 2 234.
reflexivity.
Qed.
\end{verbatim}

We want now to {\sl prove} {\tt binary\_power's} correctness, i.e. that
this function and the naive {\tt power} function are pointwise equivalent.

Proving this equivalence in Coq may require a lot of work. Thus it is not
worth at all writing a proof dedicated only to powers of integers. In fact, 
the correctness of {\tt binary\_power} with respect to {\tt power} holds
in any structure composed of an associative binary operation on some domain, 
that admits a neutral element. For instance, we can compute powers of square
matrices using the most efficient of both algorithms.

Thus, let us throw away our previous definition, and try to define them in
a more generic framework.

\section{On Monoids}

{\bf Definition 2.1} {\sl A monoid is a mathematical structure composed of}
\begin{itemize}
\item {\sl a carrier A}
\item {\sl a binary, associative operation} $\circ$ {\sl on A}
\item {\sl a neutral element} $1 \in A$ {\sl for} $\circ$
\end{itemize}

Such a mathematical structure can be defined in Coq as a type class.
 \cite{Soze08}. In the following definition, parameterized by a type $A$
(implicit), a binary operation {\tt dot} and a neutral element {\tt unit},
three fields describe the properties that {\tt dot} and {\tt unit} must
satisfy.
\begin{verbatim}
Class Monoid {A:Type}(dot : A -> A -> A)(one : A) : Prop := {
  dot_assoc : forall x y z:A, dot x (dot y z) = dot (dot x y) z;
  unit_left : forall x, dot one x = x;
  unit_right : forall x, dot x one = x }.
\end{verbatim}

Note that other definitions could have been given for representing this
mathematical structure. 

From an implementational point of view, such a type class is just a record
type, i.e. an inductive type with a single constructor {\tt Build\_Monoid}
\begin{verbatim}
Print Monoid.

Record Monoid (A:Type)(dot : A -> A -> A)(one : A) : Prop := Build_Monoid
  { dot_assoc : forall x y z:A, dot x (dot y z) = dot (dot x y) z;
    one_left : forall x, dot one x = x;
    one_right : forall x, dot x one = x }

For Monoid: Argument A is implicit and maximally inserted
For Build_Monoid: Argument A is implicit
For Monoid: Argument scopes are [type_scope _ _]
For Build_Monoid: Argument scopes are [type_scope _ _ _ _ _]
\end{verbatim}

Nevertheless, implementation of type classes by M. Sozeau provides several
specific tools --- dedicated tactics for instance --, and we advise the
reader not to replace the {\tt Class} keyword with {\tt Record} or
{\tt Inductive}.

With the command {\tt About}, we can see the polymorphic type of the 
fields of the class {\tt Monoid}:
\begin{verbatim}
About one_left

one_left:
forall (A : Type) (dot : A -> A -> A) (one : A),
Monoid dot one -> forall x : A, dot one x = x

Arguments A, dot, one, Monoid are implicit and maximally inserted
Argument scopes are [type_scope _ _ _ _]
one_left is transparent
\end{verbatim}

\subsection{Classes and Instances}

Members of a given class are called {\sl instances} of this class. 
Instances are defined to the Coq system through the {\tt Instance}
keyword. Our first example is a definition of the monoid structure
on the set $\mathbb{Z}$ of integers, provided with integer multiplication,
with 1 as the neutral element. Thus we give these parameters to the
{\tt Monoid} class (note that $\mathbb{Z}$ is implicitly given).
\begin{verbatim}
Instance ZMult : Monoid Zmult 1
\end{verbatim}

For this instance to be created, we need to prove that the binary
operation {\tt Zmult} is associative and admits 1 as the neutral
element. Applying the constructor {\tt Build\_Monoid} -- for instance
with the tactic {\tt split} -- generates three subgoals.
\begin{verbatim}
split.
3 subgoals
 =================================================
  forall x y z : Z, x * (y * z) = x * y * z

subgoal 2 is:
  forall x : Z, 1 * x = x
subgoal 3 is:
  forall x : Z, x * 1 = x
\end{verbatim}

Each subgoal is easily solved by {\tt intros; ring}.

When the proof is finished, we register our instance with a simple {\tt Qed}.
Note that we used {\tt Qed} because we consider a class of sort {\tt Prop}.
In some cases where instances must store some information constants,
ending an instance construction with {\tt Defined} may be necessary.

\begin{verbatim}
Check Zmult.
ZMult : Monoid Zmult 1
\end{verbatim}

We explained on the preceding page why it is better to use the {\tt Class}
keyword than {\tt Record} or {\tt Inductive}. For the same reason, the 
definition of an instance of some class should be written using 
{\tt Instance} and not {\tt Lemma}, {\tt Theorem}, {\tt Example}, etc.
nor {\tt Definition}.

\subsection{A generic definition of {\tt power}}

We are now able to give a definition of the function {\tt power} than can
be applied with any instance of class {\tt Monoid}:

A first definition could be
\begin{verbatim}
Fixpoint power {A:Type}{dot:A->A->A}{one:A}{M: Monoid dot one}
               (a:A)(n:nat) :=
  match n with 0:nat => one
             | S p => dot a (power a p)
  end.

Compute power 2 10.
 = 1024 : Z
\end{verbatim}

Happily, we can make the declaration of the three first arguments
implicit, by using the {\tt Generalizable Variables} command:
\begin{verbatim}
Reset power.

Generalizable Variables A dot one.

Fixpoint power `{M: Monoid A dot one}(a:A)(n:nat) :=
  match n with 0%nat => one
             | S p => dot a (power a p)
  end.

Compute power 2 10.
 = 1024 : Z
\end{verbatim}

The variables {\tt A dot one} appearing in the binder for {\tt M} are
implicitly bound before the binder for {\tt M} and their types are
inferred from the {\tt Monoid A dot one} type. This syntactic sugar
helps abbreviate bindings for classes with parameters. The resulting
internal Coq term is exactly the same as the first definition above.

\subsection{Instance Resolution}

The attentive reader has certainly noticed that in the last
computation, the binary operation {\tt Zmult} and the neutral element 1
need not to be given explicitly. The mechanism that allows Coq to infer
all the arguments needed by the {\tt power} function to be applied is called
{\sl instance resolution}.

In order to understand how it operates, let's have a look at {\tt power}'s
type:
\begin{verbatim}
About power.
power :
forall (A : Type) (dot : A -> A -> A) (one : A),
Monoid dot one -> A -> nat -> A

Arguments A, dot, one, M are implicit and maximally inserted

Compute power 2 100.
= 1267650600228229401496703205376 : Z

Set Printing Implicit.
Check power 2 100.
@power Z Zmult 1 Zmult 2 100 : Z
Unset Printing Implicit.
\end{verbatim}

We see that the {\sl instance} {\tt ZMult} has been inferred from the
type of 2. We are in the simple case where only one monoid of carrier {\tt Z}
has been declared as an instance of the {\tt Monoid} class.

The implementation of type classes in Coq can retrieve the instance
{\tt ZMult} from the type {\tt Z}, then filling the arguments {\tt ZMult}
and 1 from {\tt ZMult}'s definition.

\section{More Monoids}
\subsection{Matrices over some ring}

We all know that multiplication of square matrices is associative and
admits identity matrices as neutral elements. For simplicity's sake let us
restrict our study to $2\times 2$ matrices over some ring.

We first load the {\tt Ring} library, then open a section with some useful
declarations and notations. 
\begin{verbatim}
Require Import Ring.

Section matrices.
  Variables (A:Type)
            (zero one : A)
            (plus mult minus : A -> A -> A)
            (sym : A -> A).
  Notation "0" := zero.
  Notation "1" := one.
  Notation "x + y" := (plus x y).
  Notation "x * y" := (mult x y).

  Variable rt : ring_theory zero one plus mult minus sym (@eq A).

  Add Ring Aring : rt.
\end{verbatim}

We can now define a carrier type for $2\times 2$-matrices, as well as
matrix multiplication and the identity matrix.
\begin{verbatim}
Structure M2 : Type := {c00 : A; c01 : A; c10 : A; c11 : A}.

Definition Id2 : M2 := Build_M2 1 0 0 1.

Definition M2_mult (m m':M2) : M2 :=
  Build_M2 (c00 m * c00 m' + c01 m * c10 m')
           (c00 m * c01 m' + c01 m * c11 m')
           (c10 m * c00 m' + c11 m * c10 m')
           (c10 m * c01 m' + c11 m * c11 m').
\end{verbatim}

As for multiplication of integers, we can now define an instance of
{\tt Monoid} for the type {\tt M2}.
\begin{verbatim}
Global Instance M2_Monoid : Monoid (M2_mult plus mult) (Id2 0 1).
split.
destruct x; destruct y; destruct z; simpl.
unfold M2_mult. apply M2_eq_intros; simpl; ring.
destruct x; simpl;
unfold M2_mult; apply M2_eq_intros; simpl; ring.
destruct x; simpl;
unfold M2_mult; apply M2_eq_intros; simpl; ring.
Qed.

End matrices.
\end{verbatim}

We want now to play with $2\times 2$ matrices over $\mathbb{Z}$.
We declare an instance {\bf M2Z} for this purpose, and can use directly
the function {\tt power}.
\begin{verbatim}
Instance M2Z : Monoid _ _ := M2_Monoid Zth.

Compute power (Build_M2 1 1 1 0) 40.
 = {|
     c00 := 165580141;
     c01 := 102334155;
     c10 := 102334155;
     c11 := 63245986 |}
   : M2 Z

Definition fibonacci (n:nat) :=
  C00 (power (Build_M2 1 1 1 0) n).

Compute fibonacci 20.
 = 10946
 :Z
\end{verbatim}

\section{Reasoning within a Type Class}

We are now able to consider again the equivalence between two functions
for computing powers. Let use define the binary algorithm for any monoid.

First, we define an auxiliary function. We use the {\tt Program} 
extension to define an efficient version of exponentiation using an
accumulator. The function is defined by well-founded recursion on 
the exponent $n$.
\begin{verbatim}
Function binary_power_mult (A:Type) (dot:A->A->A) (one:A)
     (M: @Monoid A dot one) (acc x:A)(n:nat){measure (fun i=>i) n} : A
  (* acc * (x ** n) *) :=
  match n with 
    | 0%nat => acc
    | _ => if Even.even_odd_dec n
             then binary_power_mult _ acc (dot x x) (div2 n)
             else binary_power_mult _ (dot acc x) (dot x x) (div2 n)
  end.
intros; apply lt_div2; auto with arith.
intros; apply l2_div2; auto with arith.
Defined.

Definition binary_power `{M:Monoid} x n := binary_power_mult M one x n.

Compute binary_power 2 100.
 = 1267650600228229401496703205376 : Z
\end{verbatim}

\subsection{The Equivalence Proof}

The proof of equivalence between {\tt power} and {\tt binary\_power}
is quite long, and can be split in several lemmas. Thus, it is useful
to open a section, in which we fix some arbitrary monoid M. Such a
declaration is made with the {\tt Context} command, which can be 
considered as a version of {\tt Variables} for declaring arbitrary
instances of a given class.
\begin{verbatim}

Section About_power.

Require Import Arith.
 Context `(M:Monoid A dot one ).
\end{verbatim}

It is good practice to define locally some specialized notations and 
tactics.
\begin{verbatim}

Ltac monoid_rw :=
    rewrite (@one_left A dot one M) || 
    rewrite (@one_right A dot one M)|| 
    rewrite (@dot_assoc A dot one M).


Ltac monoid_simpl := repeat monoid_rw.

Local Infix "*" := dot.
Local Infix "**" := power (at level 30, no associativity).
\end{verbatim}

\subsection{Some Useful Lemmas About {\tt power}}

We start by proving some well-known equalities about powers in a monoid.
Some of these equalities are integrated later in simplification tactics.

\begin{verbatim}
Lemma power_x_plus : forall x n p, x ** (n + p) =  x ** n *  x ** p.
Proof.
 induction n as [| p IHp];simpl.
   intros;  monoid_simpl;trivial.
  intro q;rewrite (IHp q);  monoid_simpl;trivial. 
Qed.

Ltac power_simpl := repeat (monoid_rw || rewrite <- power_x_plus).

Lemma power_commute : forall x n p,  
               x ** n * x ** p = x ** p * x ** n. 
Proof.
  intros x n p;power_simpl; rewrite (plus_comm n p);trivial.
Qed.

Lemma power_commute_with_x : forall x n ,  
        x * x ** n = x ** n * x.
Proof.
  induction n;simpl;power_simpl;trivial.
  repeat rewrite <- (@dot_assoc A dot one M); rewrite IHn; trivial.
Qed.

Lemma power_of_power : forall x n p,  (x ** n) ** p = x ** (p * n).
Proof.
   induction p;simpl;[| rewrite power_x_plus; rewrite IHp]; trivial.
Qed.

Lemma power_S : forall x n, x *  x ** n = x ** S n.
Proof. intros;simpl;auto. Qed.

Lemma sqr : forall x, x ** 2 =  x * x.
Proof.
 simpl;intros;monoid_simpl;trivial.
Qed.

Ltac factorize := repeat (
                rewrite <- power_commute_with_x ||
                rewrite  <- power_x_plus  ||
                rewrite <- sqr ||
                rewrite power_S ||
                rewrite power_of_power).

Lemma power_of_square : forall x n, (x * x) ** n = x ** n * x ** n.
  induction n;simpl;monoid_simpl;trivial.
  repeat rewrite dot_assoc;rewrite IHn; repeat rewrite dot_assoc.
 factorize; simpl;trivial.
Qed.
\end{verbatim}

\subsection{Final Steps}

We are now able to prove that the auxiliary function
{\tt binary\_power\_mult} satisfies its intuitive meaning. 
The proof uses well-founded induction and the lemmas proven in the
previous section.

\begin{verbatim}
Lemma binary_power_mult_ok :
  forall n a x,  binary_power_mult a x n = a * x ** n.
Proof.
  intro n; pattern n;apply lt_wf_ind.
  clear n; intros n Hn;   destruct n.
   intros;simpl; monoid_simpl;  trivial.
  intros; rewrite binary_power_mult_equation. 
     destruct (Even.even_odd_dec (S n)).
   rewrite Hn.   rewrite power_of_square;  factorize.
   pattern (S n) at 3;replace (S n) with (div2 (S n) + div2 (S n))%nat;auto.
   generalize (even_double _ e);simpl;auto. 
   apply lt_div2;auto with arith.
   rewrite Hn. 
  rewrite power_of_square ; factorize.
  pattern (S n) at 3;replace (S n) with (S (div2 (S n) + div2 (S n)))%nat;auto.

  rewrite <- dot_assoc; factorize;auto.
  generalize (odd_double _ o);intro H;auto.
  apply lt_div2;auto with arith.
Qed.
\end{verbatim}

Then the main theorem follows immediately:
\begin{verbatim}
Lemma binary_power_ok : forall (x:A) (n:nat), binary_power x n = x ** n.
Proof.
  intros n x;unfold binary_power;rewrite binary_power_mult_ok;
  monoid_simpl;auto.
Qed.
\end{verbatim}

\subsection{Discharging the Context}

It is time to close the section we opened for writing our proof of
equivalence. The theorem {\tt binary\_power\_ok} is now provided
with a universal quantification over all the parameters of any monoid.

\begin{verbatim}
End About_power.

About binary_power_ok.
binary_power_ok :
forall (A : Type) (dot : A -> A -> A) (one : A) (M : Monoid dot one)
  (x : A) (n : nat), binary_power x n = power x n

Arguments A, dot, one M are implicit and maximally inserted
Argument scopes are [type_scope _ _ _ _ nat_scope]
binary_power_ok is opaque
Expands to Constant Top.binary_power_ok

Check binary_power_ok 2 20.
binary_power_ok 2 20
  : binary_power 2 20 = power 2 20

Let Mfib := Build_M2  1 1 1 0.

Check  binary_power_ok Mfib 56.
binary_power_ok Mfib 56
  : binary_power Mfib 56 = power Mfib 56

\end{verbatim}

\subsection{Subclasses}

We could prove many useful equalities in the section {\tt about\_power}.
Nevertheless, we couldn't prove the equality $(xy)^n=x^ny^n$ because it
is false in general -- consider for instance the free monoid of strings,
or simply matrix multiplication. But this equality holds in every 
commutative (a.k.a Abelian) monoid.

Thus we say that Abelian monoids form a {\sl subclass} of the class of
monoids, and prove this equality in a context declaring an arbitrary 
instance of this subclass.

Structurally, we parameterize the new class {\tt Abelian\_Monoid} by an
arbitrary instance {\sl M} of {\tt Monoid}, and add a new field stating
the commutativity of {\tt dot}. Please keep in mind that we declared
{\tt A}, {\tt dot}, and {\tt one} as {\sl generalizable variables},
hence we can use the backquote symbol here.

\begin{verbatim}
Class Abelian_Monoid `(M:Monoid A dot one) := {
  dot_comm : forall x y, dot x y = dot y x}.
\end{verbatim}

A quick look at the representation of {\sl Abelian\_Monoid} as a record
type helps us understand how this class is implemented.
\begin{verbatim}
Print Abelian_Monoid.
Record Abelian_Monoid (A : Type) (dot : A -> A -> A)
  (one : A) (M : Monoid dot one) : Prop := Build_Abelian_Monoid
  {dot_comm : forall x y : A, dot x y = dot y x }

For Abelian_Monoid: Arguments A, dot, one are implicit and maximally inserted
For Build_Abelian_Monoid: Arguments A, dot, one are implicit
For Abelian_Monoid: Arguemnt scopes are [type_scope _ _ _]
For Build_Abelian_Monoid: Argument scopes are [type_scope _ _ _ _]
\end{verbatim}

For building an instance of {\tt Abelian\_Monoid} we can start from
{\tt ZMult}, the monoid on {\tt Z}, adding a proof that integer
multiplication is commutative.
\begin{verbatim}
Instance ZMult_Abelian : Abelian_Monoid ZMult.
split. 
 exact Zmult_comm.
Qed.
\end{verbatim}

We can now prove our equality by building an appropriate context. Note
that we can specify just the parameters of the monoid here in the binder
of the Abelian monoid, an instance of monoid on those same parameters is
automatically generalized. Superclass parameters are automatically
generalized inside quote binders. Again, this is simply syntactic sugar.
\begin{verbatim}
Section Power_of_dot.
 Context `{M: Monoid A} {AM:Abelian_Monoid M}.
 
Theorem power_of_mult : forall n x y, 
    power (dot x y)  n =  dot (power x  n) (power y n). 
Proof.
 induction n;simpl.
 rewrite one_left;auto.
 intros; rewrite IHn; repeat rewrite dot_assoc.
  rewrite <- (dot_assoc  x y (power x n)); rewrite (dot_comm y (power x n)).
 repeat rewrite dot_assoc;trivial.
Qed.

End Power_of_dot.

Check power_of_mult 3 4 5.
power_of_mult 3 4 5
     : power (4 * 5) 3 = power 4 3 * power 5 3
\end{verbatim}

\chapter{Proof Tower Layer: C11 using CH$_2$O}

From Krebbers \cite{Kreb17}

{\bf Module example\_gcd}

Require Import String axiomatic\_simple.

Section gcd.\\
Context `\{EnvSpec K\}.

Hint Extern 10 (Some Readable $\subseteq$ \_) $\Rightarrow$ transitivity (Some Writable).\\
Hint Extern 0 (perm\_locked \_ = \_) $\Rightarrow$\\
\hspace*{0.5cm}apply perm\_Readable\_locked; auto : typeclass\_instances.\\

Hint Resolve ax\_load' ax\_var' assert\_memext\_l' assert\_eval\_int\_cast\_self'\\
\hspace*{0.5cm}assert\_memext\_r' assert\_and\_l assert\_singleton\_eval assert\_int\_typed\_eval\\
\hspace*{0.5cm}assert\_eval\_singleton\_r assert\_eval\_singleton\_l assert\_and\_intro : exec.

Ltac exec :=\\
\hspace*{0.5cm}repeat match goal with A := \_ : assert \_ $\vdash$ \_ $\Rightarrow$ progress unfold A end;\\
\hspace*{0.5cm}simpl; eauto 20 with exec.

Definition gcd\_stmt : stmt K :=\\
\hspace*{0.5cm}"l" :; if\{load (var 1)\} local\{uintT\} (\\
\hspace*{1.0cm}!(var 2 ::= (\\
\hspace*{1.5cm}var 0 ::= load (var 1) @\{ArithOp ModOp\} load (var 2),,\\
\hspace*{1.5cm}var 1 ::= load (var 2),,\\
\hspace*{1.5cm}load (var 0)));;\\
\hspace*{1.0cm}goto "l"\\
\hspace*{0.5cm}) else skip.
  
Lemma gcd\_typed : ($\varnothing$,$\varnothing$,[uintT\%T;uintT\%T]) $\vdash$ gcd\_stmt : (false,None).\\
Proof.\\
Lemma gcd\_correct $\Gamma$ $\delta$ R J T C y z $\mu$1 $\gamma$1 $\mu$2 $\gamma$2 :\\
\hspace*{0.5cm}sep\_valid $\gamma$1 $\to$ Some Writable $\subseteq$ perm\_kind $\gamma$1 $\to$\\
\hspace*{0.5cm}sep\_valid $\gamma$2 $\to$ Some Writable $\subseteq$ perm\_kind $\gamma$2 $\to$\\
\hspace*{0.5cm}J "l"\%string $\equiv$ \{$\Gamma$,$\delta$\} ($\exists$ y' z',\\
\hspace*{1.0cm}$\ulcorner$ Z.gcd y' z' = Z.gcd y z $\urcorner$\%Z $\bigstar$\\
\hspace*{1.0cm}var 0 $\mapsto$ \{$\mu$1,$\gamma$1\} \#intV\{uintT\} y' : uintT $\bigstar$\\
\hspace*{1.0cm}var 1 $\mapsto$ \{$\mu$2,$\gamma$2\} \#intV\{uintT\} z' : uintT)\%A $\to$\\
\hspace*{0.5cm}$\Gamma$\ $\delta$\ R\ J\ T\ C $\models_s$\\
\hspace*{1.0cm}\{\{ var 0 $\mapsto$ \{$\mu$1,$\gamma$1\} \#intV\{uintT\} y : uintT $\bigstar$\\
\hspace*{1.5cm}var 1 $\mapsto$ \{$\mu$2,$\gamma$2\} \#intV\{uintT\} z : uintT \}\}\\
\hspace*{1.5cm}gcd\_stmt\\
\hspace*{1.0cm}\{\{ var 0 $\mapsto$ \{$\mu$1,$\gamma$1\} \#intV\{uintT\} (Z.gcd y z) : uintT $\bigstar$\\
\hspace*{1.5cm}var 1 $\mapsto$ \{$\mu$2,$\gamma$2\} \#intV\{uintT\} 0 : uintT \}\}.\\
Proof.\\
End gcd.\\

\chapter{Other Ideas to Explore}

\section{Aczel \cite{Acze13}} 
Homotopy Type Theory

\section{Chlipala \cite{Chli15}} 
gives a pragmatic approach to COQ.

\section{Dijkstra \cite{Dijk72a}}

Unlike later texts, Dijkstra does not require a descreasing value to
do induction. Instead, he says

Let us consider the sequence of values
\[d_0,d_1,d_2,d_3,\ldots\eqno{1}\]
given by 
\[{\rm for\ }i=0 d_i=D\eqno{2a}\]
\[{\rm for\ }i>0 d_i=f(d_{i-1}\eqno{2b}\]
where $D$ is a given value and $f$ a given (computable) function. It
is asked to make the value of the variable ``$d$'' equal to the first
value $d_k$ in the sequence that satisfies a given (computable)
condition ``prop''. It is given that such a value exists for finite
$k$. A more formal definition of the requirement is to establish the
relation
\[d=d_k\eqno{3}\]
where $k$ is given by the (truth of the) expressions
\[prop(d_k)\eqno{4}\]
and
\[{\rm {\bf non}\ prop} (d_i){\rm\ for\ all\ }i{\rm\ satisfying\ }
0 \le i < k\eqno{5}\]

We now consider the following program part:
\[\begin{array}{l}
``d:=D ;\\
{\rm {\bf\ while\ non}\ prop} (d){\rm\ do\ }d:=f(d)\\
\end{array}\]
in which the first line represents the initialization and the second
one the loop, controlled by the (hopefully self-explanatory)
repetition {\bf while...do}. 

A more formal definition of the semantics of the repetition clause is
by stating that
\[``{\bf while\ }B{\bf\ do\ }S''\]
is semantically equivalent with
\[``{\bf if\ }B{\bf\ do\ begin\ }S;{\bf\ while\ }B{\bf\ do\ }S{\bf\
end}''\]
expressing that ``{\bf non} B'' is the necessary and sufficient
condition for the repetition to terminate.)

\section{Feferman \cite{Fefe95}}

Questions of definedness are ubiquitous in mathematics. Informally,
these involve reasoning about expressions which may or may not have a
value. This paper surveys work on logics in which such reasoning can
be carried out directly, especially in conputational contexts. It
begins with a general logic of ``partial terms'', continues with
partial combinatory and lambda calculi, and concludes with an
expressively right theory of partial functions and polymorphic types,
where termination of functional programs can be established in a
natural way.

In recursion theory and conputer science, questions of definedness
usually have to deal with termination of an algorithm; typically, this
is given recursively rather than explicitly, for example in Euclid's
algorithm for $gcd(a,b)$ of natural numbers $a,b$:
\[gcd(a,b)=[a {\rm\ if\ }b=0 {\rm\ else\ }gcd(b,rem(a,b))]\eqno{(1)}\]
One proves by complete induction on $b$ that
\[{\rm forall\ }a, gcd(a,b){\rm\ is\ defined}\]
Of course, justification of such reasoning presupposes a semantical
account of recursive definitions. In particular, on the face of it,
(1) requires definition of the functional 
$F(b)=\lambda a.gcd(a,b)$ by recursion of the form
\[F(b)=G(b,F~\uparrow~b)\]
and justification of {\sl that} requires proof by induction on the
natural numbers of the statement that for each $x$ there is a unique
function(al) $F_x$ with domain $[0,x]$ such that for all $y\le x$
\[F_x(y)=G(y,F_x~\uparrow~y)\]
then $F(b)$ is defined to be $F_b(b)$ for the unique such $F_b$ with 
${\rm dom}(F_b)=[0,b]$. 

\subsection{Homann  \cite{Homa94}}
algorithm schemata 

Name: gcd(?a,?b)=?g\\
Signature: ?A $\times$ ?A $\rightarrow$ ?A\\
Constraints: (?A, EuclideanRing)\\
Definition: $(?g \vert ?a)\land(?g \vert ?b) \land 
(\forall c \in ?A: (c \vert ?a) \land 
(c \vert ?b)\Rightarrow (c\vert ?g))$\\
Theorems:\\
gcd(u,v) = gcd(v,u)\\
gcd(u,v) = gcd(v, u mod v)\\
gcd(u,0) = u

\section{Igarashi et al. [Igar75]}

Igarashi et al. \cite{Igar75}

The genera idea of how to go about verifying an asserted program is to
reduce this problem to questions about whether certain associated
logical conditions are true of theorems in various standard
first-order theories.

It will become evident from the examples that a great deal of
elementary simplification of verification conditions is both necessary
and easy to do. The truth of many of the conditions will be
established at the simplification stage.

What has become evident is that the Verification Condition Generator (VCG)
is not a trivial element in this type of verification system. In order
to make such a system practical, the amount of documentation the user
is required to supply with his program should be restricted to what
would be considered natural for human understanding of what the
program and its sub-programs do. 

In the logic of programs containing assertions they are of three kinds
\begin{enumerate}
\item assertions
\item statements of the form P\{A\}Q where P, Q are assertions and A
is a program or asserted program. P\{A\}Q means ``if P is true of the
input state and A halts then Q is true of the output state''
\item procedure declarations of the form $p(x;y)$ PROC K where $p$ is
a procedure name, $x$ and $y$ are lists of variable and value
parameters respectively, and $K$ is a program or asserted program (the
procedure body), in which the variables designated by $y$ do not occur
in the left-hand side of an assignment statement, nor occur as a
variable parameter in a procedure statement. 
\end{enumerate}

If a primitive procedure name, say $q$, occurs in a program about
which we are to prove a certain theorem, we have to either give a set
of (nonlogical) axioms of the form $P\{q(x;y)\}R$ or a defining axiom
for $q$. 

Here we study the properties of the set V of axioms and rules of
inference used by VCG. One of our main concerns is that the rules of
inference in V should be unambiguous in the sense that only one rule
is applicable to generate subgoals from any given goal. This will
certainly be the case if no two rules have conclusoins which have
common substitution instances, a property which is true of V.

The core rules:

\begin{tabular}{ll}
{\sl Axioms} &\\
C1. assignment axioms: & $\displaystyle
P\vert_t^x\{x\leftarrow t\}P$\\
&\\
C2. frame axioms: & $\displaystyle
P\{q(x;t)\}P$ provided $\lnot(x\in VAR(P))$\\
&\\
C3. procedure declarations: & $\displaystyle
p(x;y)$ PROC K\\
&\\
C4. logical theorems: & $P$ for all $P$ s.t. $\vdash P$\\
&\\
{\sl Rules}&\\
C5. consequence: & 
$\displaystyle\frac{P\supset Q\quad Q\{A\}R}{P\{A\}R}\quad
\displaystyle\frac{P\{A\}Q\quad Q\supset R}{P\{A\}R}$\\
&\\
C6. and/or: &
$\displaystyle\frac{P\{A\}Q\quad R\{A\}S}{P\land R\{A\}Q\land S}\quad
\displaystyle\frac{P\{A\}Q\quad R\{A\}S}{P\lor R\{A\}Q\lor S}$\\
&\\
C7. composition: &
$\displaystyle\frac{P\{A\}Q\quad Q\{B\}R}{P\{A;B\}R}$\\
&\\
C8.conditional: &
$\displaystyle\frac{P\land R\{A\}Q\quad P\land\lnot R\{B\}Q}
{P\{if\ R\ then\ A\ else\ B\}Q}$\\
&\\
C9. substitution: 
& $\displaystyle(L)\quad\frac{P(x;y)\{q(x;y)\}Q(x;y)}
{P(z;y)\{q(z;y)\}Q(z;y)}$\\
&\\
& $\displaystyle(R)\quad\frac{P(x;y)\{q(x;y)\}Q(x;y)}
{P(x;s)\{q(x;s)\}Q(x;s)}$\\
&\\
C10. procedure call: &
$\displaystyle\frac{p(x;y){\rm\ PROC\ }K(p)\quad P\{r(x;y)\}Q 
\dststile{}{} P\{K(r)\}Q}
{P\{p(x;y)\}Q}$\\
\end{tabular}

Note that in C9 (1) $s$ does not contain members of $x$;
(ii) members of $x$ must be distinct and $x$ must contain no variable
occurring in $P(x;y)$ or $Q(x;y)$ except possibly members of $x$.

Note that in C10 $p$ does not occur in the proof of the right hand
premiss, and $r$ does not occur in any other assumption in that proof.

The rules in the following table are stated in the form in which they
are used to generate subgoals. Thus, for example in the case of the
assignment rule V1, the axiom $Q(e)\{x\leftarrow e\}Q(x)$ is ommitted
from the premisses since it is true and therefore not generated as a
subgoal. The composition rule is not used to generate subgoals (it
would be a source of ambiguity) but is included in the other
rules. VCG does not require assertions at conditional statements. It
'marks' the conditional tests in the subgoals of the conditional rule,
and uses them as assertions that permit a slightly different rule of
consequence. The normal rule of consequence, V3 (ii) would usually
lead to a verification condition of the form $Q\supset R^\prime$
where $R^\prime$ is some formula involving $R$. Most likely the proof
of $R^\prime$ would depend on the premiss $P$ and in such a case
$Q\supset R^\prime$ is unlikely to be provable.

V1. {\sl Simple assignment}
\[\frac{P\{A\}Q(e)}{P\{A;x\leftarrow e\}Q(x)}\]

V2. Array assignment
\[\frac{P\{A\}R (if\ i=j\ then\ e\ else\ B[i])}
{P\{A;B[j]\leftarrow e\}R(B[i])}\]

V3. Consequence
\[(i)\frac{P\supset Q}{P\{Null\}Q^\prime}
\quad\frac{P\{A\}Q\quad Q\supset R}{P\{A;Q\}R}
\quad\frac{P\{A\}Q\supset R}{P\{A;Q-if\}R}\]

V4. Iteration
\[\frac{P\{A\}R\quad R\land S\{B\}R\quad R\land\lnot S\supset Q}
{P\{A; R;\ while\ S\ do\ B\}Q}\quad{\rm\ where\ R\ is\ an\ assertion}\]

V5. Conditional
\[\frac{P\{A; Q-if; B\}R\quad P\{A;\lnot Q-if; C\}R}
{P\{A;\ if\ Q\ then\ B\ else\ C\}R}\]

V6. Goto
\[\frac{P\{A\}\ assertion\ (L)}{P\{A; goto\ L\}Q}\]

V7. Procedure call
\[U(x;v)\{q(x;v)\}W(x;v)\dststile{}{}
\frac{P\{A\}U(a;e)\land\forall a(W(a;e)\supset R)}
{P\{A;q(a;e)\}R}\]

V8. Procedure declaration
\[\frac{P\{q(x;v)\}R\dststile{}{} P\{K\}R}
{P\{procedure\ q(x;v); K\}R}\]

Notation: P,Q,R,S are Boolean Assertions. Null denotes the empty
program. Q(e) denotes the substitution of e for x in Q(x). In V6,
'assertion (L)' denotes the assertion at label L.

B[i] denotes the $i^{th}$ element in array B. In each of the rules A
can be Null. Q-if denotes a 'marked' Boolean assertion Q.

\section{Kamareddine [Kama15]}

Kamareddine \cite{Kama15}
Computerising Mathematical Text explores various ways of 
capturing mathematical reasoning. 

\section{Mahboubi \cite{Mahb18}} 
Mathematical Components. This book contains a
proof of the Euclidean algorithm using COQ.

\section{Medina-Bulo et al. \cite{Bulo04}} 
gives a formal verification of
Buchberger's algorithm using ACL2 and Common Lisp.

\section{Pierce \cite{Pier15}} 
has a Software Foundations course in COQ with
downloaded files in Pier15.tgz.

\section{Santas \cite{Sant95}} 
A Type System for Computer Algebra

\section{Spitters \cite{Spit11}} 
Type Classes for Mathematics in Coq. Also see
\verb|http://www.eelis.net/research/math-classes/|

\section{Th\'ery \cite{Ther01}} 
used COQ to check an implementation of Buchberger's
algorithm.

\appendix

\chapter{The Global Environment}

Let $S$ be a set. Let $\circ$ be a binary operation. 
Let $+$ be an additive operation. Let $*$ be a multiplicative operation.

\begin{axiom}[Magma]
A {\bf Magma} is the
set $S$ with a {\bf closed binary operation} 
$S \circ S \rightarrow S$ such that
\[\forall a,b \in S \Rightarrow a \circ b \in S\].
\end{axiom}

\begin{axiom}[Semigroup]
A {\bf Semigroup} is a
{\bf Magma} with the operation $\circ$ that is {\bf associative} such that
\[\forall a,b,c \in S \Rightarrow (a \circ b) \circ c = a \circ (b \circ c)\]
\end{axiom}

\begin{axiom}[Abelian Semigroup]
An {\bf Abelian Semigroup} is a {\bf Semigroup} with the operation 
$\circ$ that is {\bf commutative} such that
\[\forall a,b \in S \Rightarrow a \circ b = b \circ a\]
\end{axiom}

\begin{axiom}[Monoid]
A {\bf Monoid} is a
{\bf Semigroup} with an {\bf identity element} $e \in S$ such that
\[\forall a \in S \Rightarrow e \circ a = a \circ e = a\]
\end{axiom}

\begin{axiom}[Group]
A {\bf Group} is a {\bf Monoid} with an {\bf inverse element} $b \in S$
and an identity element $i \in S$
such that
\[\forall a \in S~\exists b \in S \Rightarrow a \circ b = b \circ a = i\]
\end{axiom}

\begin{axiom}[Group Unique Identity]
A {\bf Group} has a {\bf unique identity element} $e \in S$ such that
\[\exists e \land \forall a,b \in S \land a \ne e \land b \ne e \Rightarrow 
a \circ b \ne e\]
\end{axiom}

\begin{axiom}[Group Unique Inverse]
A {\bf Group} has a {\bf unique inverse element} $i \in S$ such that
\[\exists i \land \forall a,b \in S \land a \ne i \land b \ne i \Rightarrow 
a \circ b \ne i\]
\end{axiom}

\begin{axiom}[Group Right Quotient]
A {\bf Group} has a {\bf Right Quotient} (right division) such that
\[x \circ a = b \Rightarrow x \circ a \circ a^{-1} = b \circ a^{-1} 
\Rightarrow x = b \circ a^{-1}\]
\end{axiom}

\begin{axiom}[Group Left Quotient]
A {\bf Group} has a {\bf Left Quotient} (left division) such that
\[a \circ x = b \Rightarrow a^{-1} \circ a \circ x = a^{-1} \circ b
\Rightarrow x = a^{-1} \circ b\]
\end{axiom}

\begin{axiom}[Abelian Group]
An {\bf Abelian Group} is a {\bf Group} with the operation $\circ$ that is
{\bf commutative} such that
\[\forall a,b \in S \Rightarrow a \circ b = b \circ a\]
\end{axiom}

\begin{axiom}[Abelian Group Quotient]
An {\bf Abelian Group} has a {\bf Quotient} (division) such that
\[a^{-1} \circ a \circ x = a \circ a^{-1} \circ x\]
\end{axiom}



\begin{axiom}[Euclidean Domain]
Let $R$ be an integral domain. Let $f$ be a function from
$R\backslash \{0\}$ to the NonNegativeInteger domain.
If $a$ and $b$ are in $R$ and $b$ is nonzero, then there are
$q$ and $r$ in $R$ such that $a=bq+r$ and either $r=0$ or
$f(r)<f(b)$ 
\end{axiom}

\chapter{Related work}

\section{Overview of related work}

\subsection{Adams \cite{Adam01}}

\subsection{Ballarin \cite{Ball95}}

\subsection{Basu, Pollack,and Roy \cite{Basu10}}

\subsection{Cloostermans \cite{Cloo12}}

Quasi-Linear GCD Computation and Factoring RSA Moduli

\subsubsection{Euclidean Division and Greatest Common Divisor} 

We study euclidean division, compute greatest divisors, and show how
to use them to decide whether or not a basic constructible set of C is
empty. 

In this section, C is an algebraically closed field, D a subring of C
and K the quotient field of D. One can take as a typical example of
this situation the field $\mathbb{C}$ of complex numbers, the ring
$\mathbb{Z}$ of integers, and the field $\mathbb{Q}$ of rational
numbers. 

Let $P$ be a non-zero polynomial 
\[P=a_pX^p+\ldots+a_1X+a_0\in D[X]\]
with $a_p\ne 0$.

We denote the {\bf degree} of $P$, which is $p$ by deg($P$). By
convention, the degree of the zero polynomial is defined to be
$-\infty$. If $P$ is non-zero, we write ${\rm cof}_j(P)=a_j$ for the
{\bf coefficient} of $X^j$ in $P$ (which is equal to 0 if 
$j>{\rm deg}(P))$ and lcof($P$) for its 
{\bf leading coefficient} $a_p={\rm cof}_{{\rm deg}(P)}(P)$. By
convention ${\rm lcof}(0)=1$.

Suppose that $P$ and $Q$ are two polynomials in $D[X]$. The polynomial
$Q$ is a {\bf divisor of} $P$ if $P=AQ$ for some $A\in K[X]$. Thus,
while every $P$ divides 0, 0 divides 0 and no other polynomial.

If $Q\ne 0$, the {\bf remainder} in the {\bf euclidean division of}
$P$ {\bf by} $Q$, denoted ${\rm Rem}(P,Q)$, is the unique polynomial 
$R\in K[X]$ of degree smaller than the degree of $Q$ such that
$P=AQ+R$ with $A\in K[X]$. The {\bf quotient} in the euclidean
division of $P$ by $Q$, denoted ${\rm Quo}(P,Q)$, is $A$.

{\bf Exercise} Prove that, if $Q\ne 0$, there exists a unique pair
$(R,A)$ of polynomials in $K[X]$ such that $P=AQ+R$,
${\rm deg}(R)<{\rm deg}(Q)$.

Clearly, ${\rm Rem}(aP,bQ)=a{\rm Rem}(P,Q)$, for any $a,b\in K$
with $b\ne 0$. At a root $x$ of $Q$, ${\rm Rem}(P,Q)(x)=P(x)$.

{\bf Exercise}:
Prove that $x$ is a root of $P$ in $K$ if and only if $X-x$ is a
divisor of $P$ in $K[X]$.

{\bf Exercise}:
Prove that if $C$ is algebraically closed, every $P\in C[X]$ can be
written uniquely as
\[P=a(X-x_1)^{\mu_1}\cdots(X-x_k)^{\mu_k}\]
with $x_1,\ldots,x_k$ distinct elements of $C$.

A {\bf greatest common divisor of} $P$ {\bf and} $Q$, denoted 
$gcd(P,Q)$, is a polynomial $G\in K[X]$ such that $G$ is a divisor of
both $P$ and $Q$, and any divisor of both $P$ and $Q$ is a divisor of
$G$. Observe that this definition implies that $P$ is a greatest
common divisor of $P$ and 0. Clearly, any two greatest common divisors
(say $G_1$, $G_2$) of $P$ and $Q$ must divide each other and have
equal degree. Hence $G_1=aG_2$ for some $a\in K$. Thus, any two
greatest common divisors of $P$ and $Q$ are proportional by an element
in $K\backslash \{0\}$. Two polynomials are {\bf coprime} if their greatest
common divisor is an element of $K\backslash \{0\}$.

A {\bf least common multiple of} $P$ {\bf and} $Q$, lcm($P,Q$) is a
polynomial $G\in K[X]$ such that $G$ is a multiple of both $P$ and
$Q$, and any multiple of both $P$ and $Q$ is a multiple of both
$G$. Clearly, any two least common multiples $L_1$, $L_2$ of $P$ and
$Q$ must divide each other and have equal degree. Hence, 
$L_1=aL_2$ for some $a\in K$. Thus, any two least common multiple of
$P$ and $Q$ are proportional by an element in $K\backslash \{0\}$.

It follows immediately from the definitions that:

{\bf Proposition}: {\sl Let $P\in K[X]$ and $Q\in K[X]$, not both
zero. Then $PQ/G$ is a least common multiple of $P$ and $Q$.}

{\bf Corollary}: 
\[{\rm deg}({\rm lcm}(P,Q))={\rm deg}(P)+{\rm deg}(Q)
-{\rm deg}({\rm gcd}(P,Q))\]

We now prove that greatest common divisors and least common multiple
exist by using euclidean division repeatedly.

{\bf Definition} {\bf [Signed remainder sequence]} Given 
$P,Q\in K[X]$, not both 0, we define the 
{\bf signed remainder sequence of} $P$ {\bf and} $Q$.
\[{\rm SRemS}(P,Q)={\rm SRemS}_0(P,Q), {\rm SRemS}_1(P,Q),
\ldots,{\rm SRemS}_k(P,Q)\]
by
\[\begin{array}{rcl}
{\rm SRemS}_0(P,Q) & = & P\\
{\rm SRemS}_1(P,Q) & = & Q\\
{\rm SRemS}_2(P,Q) & = & 
-{\rm Rem}({\rm SRemS}_0(P,Q), {\rm SRemS}_1(P,Q))\\
\vdots\\
{\rm SRemS}_k(P,Q) & = & 
-{\rm Rem}({\rm SRemS}_{k-2}(P,Q), 
{\rm SRemS}_{k-1}(P,Q))\ne 0\\
{\rm SRemS}_{k+1}(P,Q) & = & 
-{\rm Rem}({\rm SRemS}_{k-1}(P,Q), 
{\rm SRemS}_k(P,Q))=0\\
\end{array}\]

The signs introduced here are unimportant in the algebraically closed
case. They play an important role when we consider analogous problems
over real closed fields.

In the above, each ${\rm SRemS}_i(P,Q)$ is the negative of the
remainder in the euclidean division of 
${\rm SRemS}_{i-2}(P,Q)$ by ${\rm SRemS}_{i-1}(P,Q)$ for
$2\le i\le k+1$, and the sequence ends with 
${\rm SRemS}_k(P,Q)$ when ${\rm SRemS}_{k+1}(P,Q)=0$,
for $k\ge 0$.

{\bf Proposition}: {\sl The polynomial ${\rm SRemS}_k(P,Q)$ is a
greatest common divisor of $P$ and $Q$}

{\bf Proof}: Observe that if a polynomial $A$ divides two polynomials
$B,C$ then it also divides $UB+VC$ for arbitrary polynomials
$U,V$. Since 
\[{\rm SRemS}_{k+1}(P,Q)=
-{\rm Rem}({\rm SRemS}_{k-1}(P,Q),{\rm SRemS}_k(P,Q))=0\]
${\rm SRemS}_k(P,Q)$ divides ${\rm SRemS}_{k-1}(P,Q)$ and since,
\[{\rm SRemS}_{k-2}(P,Q)=
-{\rm SRemS}_k(P,Q)+A{\rm SRemS}_{k-1}(P,Q)\]

${\rm SRemS}_k(P,Q)$ divides ${\rm SRemS}_{k-2}(P,Q)$ using the above
observation. Continuing this process one obtains that
${\rm SRemS}_k(P,Q)$ divides ${\rm SRemS}_1(P,Q)=Q$ and
${\rm SRemS}_0(P,Q)=P$

Also, if any polynomial divides ${\rm SRemS}_0(P,Q)$,
${\rm SRemS}_1(P,Q)$ (that is $P$, $Q$ then it divides
${\rm SRemS}_2(P,Q)$ and hence ${\rm SRemS}_3(P,Q)$ and so on.
Hence, it divides ${\rm SRemS}_k(P,Q)$.

Note that the signed remainder sequence of $P$ and 0 is $P$ and when
$Q$ is not 0, the signed remaineder sequence of 0 and $Q$ is 0, $Q$.

Also, note that by unwinding the definitions of the 
${\rm SRemS}_i(P,Q)$, we can express
${\rm SRemS}_k(P,Q)=gcd(P,Q)$ as $UP+VQ$ for some polynomials $U$, $V$
in $K[X]$. We prove bounds on the degrees of $U$, $V$ by elucidating
the preceding remark.

{\bf Proposition}: {\sl If $G$ is a greatest common divisor of $P$ and
$Q$, then there exist $U$ and $V$ with}
\[UP+VQ=G\]
{\sl Moreover, if ${\rm deg}(G)=g$, $U$ and $V$ can be chosen so that
${\rm deg}(U)<q-g$, ${\rm deg}(V)<p-g$.}

The proof uses the extended signed remainder sequence defined as
follows:

{\bf Definition}: {\bf [Extended signed remainder sequence]}

Given $P,Q\in K[X]$, not both 0, let

\[\begin{array}{rcl}
{\rm SRemU}_0(P,Q) & = & 1\\
{\rm SRemV}_0(P,Q) & = & 0\\
{\rm SRemU}_1(P,Q) & = & 0\\
{\rm SRemV}_1(P,Q) & = & 1\\
A_{i+1} & = & {\rm Quo}({\rm SRemS}_{i-1}(P,Q),{\rm SRemS}_i(P,Q))\\
{\rm SRemS}_{i+1}(P,Q) & = & 
-{\rm SRemS}_{i-1}(P,Q) + A_{i+1}{\rm SRemS}_i(P,Q)\\
{\rm SRemU}_{i+1}(P,Q) & = & 
-{\rm SRemU}_{i-1}(P,Q) + A_{i+1}{\rm SRemU}_i(P,Q)\\
{\rm SRemV}_{i+1}(P,Q) & = & 
-{\rm SRemV}_{i-1}(P,Q) + A_{i+1}{\rm SRemV}_i(P,Q)\\
\end{array}\]

for $0 \le i \le k$ where $k$ is the least non-negative integer such
that ${\rm SRemS}_{k+1}(P,Q)=0$.

The {\bf extended signed remainder sequence} ${\rm Ex}(P,Q)$ of $P$
and $Q$ is ${\rm Ex}_0(P,Q),\ldots,{\rm Ex}_k(P,Q)$ with
\[{\rm Ex}_i(P,Q)=({\rm SRemS}_i(P,Q),{\rm SRemU}_i(P,Q),
{\rm SRemV}_i(P,Q))\]

The proof uses the following lemma

{\bf Lemma} {\sl For} $0\le i \le k+1$
\[{\rm SRemS}_i(P,Q)={\rm SRemU}_i(P,Q)P+{\rm SRemV}_i(P,Q)Q\]

{\sl Let $d_i={\rm deg}({\rm SRemU}_i(P,Q))$. 
For $1\le i\le k$, ${\rm deg}({\rm SRemV}_{i+1}(P,Q))=q-d_i$,
and ${\rm deg}({\rm SRemV}_{i+1}(P,Q))=p-d_i$.} 

{\bf Proof}: It is easy to verify by induction on $i$ that, for
$0 \le i \le k+1$
\[{\rm SRemS}_i(P,Q)={\rm SRemU}_i(P,Q)P + {\rm SRemV}_i(P,Q)Q\]

Note that $d_i < d_{i-1}$. The proof of the claim on the degrees 
proceeds by induction. Clearly since
\[\begin{array}{rcl}
{\rm SRemU}_2(P,Q) & = & -1\\
{\rm SRemU}_3(P,Q) & = & -{\rm Quo}({\rm SRemS}_1(P,Q),{\rm SRemP}_2(P,Q))
\end{array}\]

\[\begin{array}{rcl}
{\rm deg}({\rm SRemU}_2(P,Q)) & = & q - d_1\\
{\rm deg}({\rm SRemU}_3(P,Q)) & = & q - d_2\\
\end{array}\]

Similarly,

\[\begin{array}{rcl}
{\rm deg}({\rm SRemV}_2(P,Q)) & = & p - d_1\\
{\rm deg}({\rm SRemV}_3(P,Q)) & = & p - d_2\\
\end{array}\]

Using the definitions of ${\rm SRemU}_{i+1}(P,Q)$, ${\rm SRemV}_{i+1}(P,Q)$
and the induction hypothesis, we get

\[\begin{array}{rcl}
{\rm deg}({\rm SRemU}_{i-1}(P,Q)) & = & q-d_{i-2}\\
{\rm deg}({\rm SRemU}_i(P,Q)) & = & q-d_{i-1}\\
{\rm deg}(A_{i+1}{\rm SRemU}_i(P,Q)) & = & d_{i-1} - d_i + q - d_{i-1}\\
& = & q - d_i > q - d_{i-2}\\
\end{array}\]

Hence, ${\rm deg}({\rm SRemU}_{i+1}) = q - d_i$, Simlarly,

\[\begin{array}{rcl}
{\rm deg}({\rm SRemV}_{i-1}(P,Q)) & = & p-d_{i-2}\\
{\rm deg}({\rm SRemV}_i(P,Q)) & = & p-d_{i-1}\\
{\rm deg}(A_{i+1}{\rm SRemV}_i(P,Q)) & = & d_{i-1} - d_i + p - d_{i-1}\\
& = & p - d_i > p - d_{i-2}\\
\end{array}\]

Hence, ${\rm deg}({\rm SRemV}_{i+1}) = p - d_i$.

{\bf Proof}: The claim follows from the Lemma and Proposition since
${\rm SRemS}_k(P,Q)$ is the gcd of $P$ and $Q$, taking
\[U={\rm SRemU}_k(P,Q), V={\rm SRemV}_k(P,Q)\]
and noting that $p-d_{k-1} < p-g$, $q-d_{k-1} < q-g$.

The extended signed remainder sequence also provides a least common
multiple of $P$ and $Q$.

{\bf Proposition} {\sl The equality}
\[{\rm SRemU}_{k+1}(P,Q) P = -{\rm SRemV}_{k+1}(P,Q) Q\]
{\sl holds and ${\rm SRemU}_{k+1}(P,Q)P = -{\rm SRemV}_{k+1}(P,Q) Q$
is a least common multiple of $P$ and $Q$.}

{\bf Proof:} Since $d_k={\rm deg}({\rm gcd}(P,Q))$,
${\rm deg}({\rm SRemU}_{k+1}(P,Q))=q-d_k$,
${\rm deg}({\rm SRemV}_k(P.Q))=p-d_k$ and
\[{\rm SRemU}_{k+1}(P,Q) P + {\rm SRemV}_{k+1}(P,Q) Q = 0\]
it follows that
\[{\rm SRemU}_{k+1}(P,Q) P - {\rm SRemV}_{k+1}(P,Q) Q \]
is a common multiple of $P$ and $Q$ of degree $p+q-d_k$, hence a least
common multiple of $P$ and $Q$.

{\bf Definition} {\bf [Greatest common divisor of a family]}
A {\bf greatest common divisor of a finite family of polynomials} is a
divisor of all the polynomials in the family that is also a multiple of
any polynomial that divides every polynomial in the family. A greatest
common divisor of a family can be obtained inductively on the number
of elements of the family by
\[\begin{array}{rcl}
{\rm gcd}(\emptyset) & = & 0\\
{\rm gcd}(\mathcal{P} \cup \{P\}) & = & 
{\rm gcd}(P,{\rm gcd}(\mathcal{P}))
\end{array}
\]

Note that
\begin{itemize}
\item $x\in C$ is a root of every polynomial in $\mathcal{P}$ 
if and only if it is the root of gcd($\mathcal{P}$)
\item $x\in C$ is not a root of any polynomial in $\mathcal{Q}$ 
if and only if
it is not a root of $\prod_{Q\in \mathcal{Q}}Q$ 
(with the convention that the proeuct of the empy family is 1).
\item every root of $P$ in $C$ is a root of $Q$ if and only if 
${\rm gcd}(P,Q^{deg(\mathcal{P})})$ 
(with the convention that $Q^{deg(0)}=0)$.
\end{itemize}

WIth these observations the following lemma is clear:

{\bf Lemma} {\sl If $\mathcal{P}$,$\mathcal{Q}$
are two finite subsets of D[X], then there is
an $x\in C$ such that}
\[
\left(\bigwedge_{P\in \mathcal{P}} P(x)=0\right)\land
\left(\bigwedge_{Q\in \mathcal{Q}} Q(x)\ne 0\right)
\]
if and only if
\[{\rm deg}({\rm gcd}({\rm gcd}(\mathcal{P}),
\prod_{Q\in \mathcal{Q}} Q^d))\ne {\rm deg}({\rm gcd}(\mathcal{P}))
\]
{\sl where $d$ is any integer greater than 
${\rm deg}({\rm gcd}(\mathcal{P}))$.}

Note that when $\mathcal{Q}=\emptyset$, 
since $\prod_{Q\in \emptyset}Q=1$, the lemma says
that there is an $x\in C$ such that 
$\bigwedge_{P\in \mathcal{P}}P(x)=0$ if and
only if ${\rm deg}({\rm deg}(\mathcal{P}))\ne 0$. Note also that when 
$\mathcal{P}=\emptyset$, the lemma says that there is an $x\in C$ such that
$\bigwedge_{Q\in \mathcal{Q}}Q(x)\ne 0$ if and only if
${\rm deg}(\prod_{Q\in \mathcal{Q}}Q)\ge 0$, i.e. $1\ne \mathcal{Q}$.

\subsection{Berger and Schwichtenberg \cite{Berg95}}

The Greatest Common Divisor: A Case Study for
Program Extraction from Classical Proofs.

{\bf Theorem}

\[\forall a_1,a_2 (0 < a_2 \rightarrow\\
\exists k_1,k_2 (abs(k_1a_1-k_2a_2)|a_1 \land
abs(k_1a_1-k_2a_2)|a_2 \land 0 < abs(k_1a_1-k_2a_2)))\]

{\bf Proof}
Let $a_1,a_2$ be given and assume $0 < a_2$. The ideal $(a_1,a_2)$
generated from $a_1,a_2$ has a least positive element $c$, since
$0 < a_2$. This element has a representation $c=abs(k_1a_1-k_2a_2)$
with $k_1,k_2\in \mathbb{N}$. It is a common divisor of $a_1$ and
$a_2$ since otherwise the remainder $f(a_i,c)$ would be a smaller
positive element of the ideal. The number $c\in (a_1,a_2)$ dividing
$a_1$ and $a_2$ is the greatest common divisor since any common
divisor of $a_1$ and $a_2$ must also be a divisor of $c$.

\begin{verbatim}
(lambda (a1)
 (lambda (a2)
   ((((((nat-rec-at '(arrow nat (arrow nat (start nat nat))))
        (lambda (k1) (lambda (k2) (cons n000 n000))))
       (lambda (n)
        (lambda (w)
         (lambda (k1)
          (lambda (2)
           ((((if-at '(star nat nat))
              ((<-strict-nat 0) r2))
                ((w L21) L22))
                ((((if-at '(star nat nat))
                  ((<-strict-nat 0) r1))
                  ((w L11 L12))
                 (cons k1 k2))))))))
           ((plus-nat a2) 1))
         0)
       1)))
\end{verbatim}

Here we have manually introduced r1,r2,L11,L12,L21,L22 for somewhat
lengthy terms corresponding to our abbreviations $r_1$,
$\over{\rightarrow}{l_1}$. The unbound variable n000 appearing
in the base case is a dummy variable used by the system when it
is asked to produce a realizing term for the instance
$\bot \rightarrow \exists k A(k)$ of ex-falso-quodlibet.
In our case, when the existential quantifier is of type nat
one might as well pick the constant 0 (as we did in the text).

\subsection{Cardelli \cite{Card85}}

Cardelli states that {\bf coercions} are a 
form of ad-hoc polymorphism.
Axiom allows ML-style type inference in the interpreter. Declaring a function
\begin{verbatim}
   f(n) == n + 1
\end{verbatim}
without specifying types is possible. The function types are inferred
when used and a type-specialized version of the function is
compiled. If called with different argument types it will compile a
new type-specialized version of the function as needed. Raises the
distinction between {\bf equivalence} and {\bf inclusion} as it occurs
in subtypes (p483). The FUN language defines {\bf Quantified Types} as

QuantifiedType ::=
\begin{itemize}
\item[\quad] $\forall$ A, Type $\vert$\hspace{5cm}Universal Quantification
\item[\quad] $\exists$ A. Type $\vert$\hspace{5cm}Existential Quantification
\item[\quad] $\forall$ A $\subseteq$ Type. Type $\vert$
$\exists$ A $\subseteq$ Type. Type\quad\quad{}Bounded Quantification
\end{itemize}

See p516 for the Classification of Type Systems diagram.

\subsection{Char \cite{Char84}}

    "The design of algorithms for polynomial GCD computation has been
    a continuing area of research since the beginning of the
    development of symbolic computation systems. The earliest efforts
    were mainly directed at PRS (Polynomial Remainder Sequence)
    algorithms which are a direct generalization of Euclid's
    algorithm. The main algorithms of this type are the Reduced PRS
    algorithm and the Subresultant PRS algorithm. Hearn discusses the
    use of trial divisions to further improve the performance of PRS
    algorithms. The first fundamentally different polynomial GCD
    algorithm was the modular algorithm. To amek the modular algorithm
    competative for sparse multivariate polynomals, Zippel developed
    the sparse modular algorithm. Another modular-type algorithm was
    the Hensel-based EZ GCD algorithm which was later improved as the
    EEZ GCD algorithm.

    the present paper discusses a new heuristic algorithm, GCDHEU,
    which is found to be very efficient for problems in a small number
    of variables. The heuristic algorithm can be viewed as
    amodular-type algorithm in that it uses evaluation and
    interpolation, but only a single evaluation per variable is
    used. The heuristic algorithm can be incorporated into a
    reorganized form of the EEZ GCD algorithm such that the base of
    the EEZ GCD algorithm, rather than a univariate GCD algorithm, is
    GCDHEU which is often successful for problems in up to four variables.",

\subsection{Chen \cite{Chen08}}

Computing Polynomial LCD and GCD in Lagrange Basis

\subsection{Chen \cite{Chen08a}}

    "Given two polynomials, we find a convergence property of the GCD of
    the rising factorial and the falling factorial. Based on this
    property, we present a unified approach to computing the universal
    denominators as given by Gosper's algorithm and Abramov's algorithm
    for finding rational solutions to linear difference equations with
    polynomial coefficients. Our approach easily extends to the
    q-analogues.",

\subsection{Clarke \cite{Clar91}}

Clarke shows several proofs

\newpage
\subsection{Crocker \cite{Croc14}}

\begin{center} 
{\bf Primary specification constructs}
\end{center}

\begin{tabular}{|l|l|}
\hline
{\bf pre}(expression-list) & Declares preconditions\\
\hline
{\bf post}(expression-list) & Declares postconditions\\
\hline
& Declares the value returned by a\\
& function. Equivalent to {\bf post(result)} ==\\
{\bf returns}(expression) & {\sl expression} except that recursion is\\
& permitted in {\sl expression}\\
\hline
{\bf assert}(expression-list) & Asserts conditions\\
\hline
& Used in class declarations to declare\\
{\bf invariant}(expression-list) & class invariants, and in {\bf typedef}\\
& declarations to declare constraints\\
\hline
{\bf keep}(expression-list) & Declares loop invariants\\
\hline
{\bf decrease}(expression-list) & Declares loop variant or recursion\\
& variant expressions\\
\hline
& Declares what non-local variables the\\
& function modifies. If a function is\\
{\bf writes}(lvalue-expression-list) 
& declared without a writes-clause, then\\
& a default writes-clause is constructed\\
& based on the signature of the function\\
\hline
{\bf assumes}(expression-list) & Declares predicates to be assumed\\
& without proof\\
\hline
{\bf ghost}(expression-list) & Declares ghost variables, functions\\
& parameters, etc.\\
\hline
\end{tabular}

\newpage
\begin{center}
{\bf Additional specification expressions}
\end{center}

\begin{tabular}{|l|l|}
\hline
{\bf exists} {\sl identifier} {\bf in} & Existential quantification over the\\
{\sl expression} :- {\sl predicate} 
& elements of {\sl expression} which must be\\
& an array or an abstract collection type\\
\hline
{\bf exists} {\sl type identifier} := & Existential quantification over all\\
{\sl predicate} & values of type\\
\hline
{\bf forall} {\sl identifier} {\bf in} & Universal quantification over the\\
{\sl expression} :- {\sl predicate} 
& elements of {\sl expression}, which must be \\
& an array or an abstract collection type\\
\hline
{\bf forall} {\sl type identifier} :- & Universal quantification over all\\
{\sl predicate} & values of type\\
\hline
& Applies the mapping function\\
{\bf for} {\sl identifier} {\bf in} {\sl expression1} 
& {\sl expression2} to each element of\\
{\bf yield} {\sl expression2} 
& collection {\sl expression1}, yielding a new\\
& collection\\
\hline
{\bf those} {\sl identifer} {\bf in} & Selects those elements of collection\\
{\sl expression1} :- {\sl predicate} 
& {\sl expression1} for which {\sl predicate} is\\
& true\\
\hline
{\bf that} {\sl identifier} {\bf in} & Selects the single element of the\\
{\sl expression1} :- {\sl predicate}
& collection {\sl expression1} for which\\
& {\sl predicate} is true\\
\hline
& Shorthand for {\bf exists} {\sl id} {\bf in} {\sl expression2}\\
{\sl expression1} {\bf in} {\sl expression2} 
& :- {\sl id} == {\sl expression1}, where {\sl id} is a new\\
& identifier\\
\hline
& {\sl expression} must have union type, and\\
& {\sl member} must be a member of that\\
{\sl expression} {\bf holds} {\sl member} 
& type. Yields true if and only if the\\
& value of {\sl expression} was defined by\\
& assignment or initialization through\\
& {\sl member}\\
\hline
& Yields true if and only if no two\\
& objects in the expression list have\\
{\bf disjoint}({\sl lvalue-expression-list}) 
& overlapping storage. Typically used\\
& in preconditions to state that parameters\\
& passed by pointer or reference refer to\\
& distinct objects\\
\hline
& Left-fold {\sl operator} over collection\\
{\sl operator} {\bf over} {\sl expression} 
& {\sl expression}. Used to express e.g.\\
& summation of the elements of an array\\
\hline
& When used in a postcondition, this\\
& referes to the value of {\sl expression} when\\
& the function was entered. When used\\
{\bf old}{\sl (expreesion)} & in a loop invariant, it refers to the\\
& value of {\sl expression} just before the\\
& first iteration of the loop.\\
\hline
\end{tabular}

\subsection{Davenport \cite{Dave85c}}

The work presented in this paper is a direct consequence of the
ideas set forth by Char et al (1984b) describing a new technique
for computing the greatest common divisor of polynomials.",

\subsection{Davenport \cite{Dave02}}

\subsection{Davenport \cite{Dave12b}}

\subsection{Davenport \cite{Dave18}}

The following definition is valid whenever we have a concept of
division. 

{\bf Definition} {\sl h is said to be a greatest commmon divisor, or
g.c.d, of f and g if, and only if
\begin{enumerate}
\item h divides both f and g
\item if h' divides both f and g, then h' divides h
\end{enumerate}

This definition clearly extends to any number of arguments. The g.c.d
is normally written gcd(f,g).}

Note that we have defined a g.c.d. whereas it is more common to talke
of {\sl the} g.c.d. However 'a' is correct. We normally say that 2 is
{\sl the} g.c.d of 4 and 6, but in fact $-2$ is equally a g.c.d. of 4
and 6.

{\bf Definition} {\sl if $a=u*b$ where $u$ is a unit, we say that $a$
and $b$ are associates.}

{\bf Proposition} {\sl if h and h' are greatest common divisors of a
and b, they are associates.}

{\bf Example} (Greatest common divisors need not exist) {\sl Consider
the set of all integers with $\sqrt{-5}$. 2 clearly divides both 6 and
$2+2\sqrt{-5}$. However, so does $1+\sqrt{-5}$ (since 
$6 = (1+\sqrt{-5})(1-\sqrt{-5})$), yet there is no multiple of both 2
and $1+\sqrt{-5}$ which divides both.}

{\bf Definition} {\sl A ring R is said to be an integral domain if
there is a neutral element 1 such that $1*a=a$ and, whenever
$a*b=0$ at least one of a and b are zero.}

{\bf Definition} {\sl An integral docmain is which any two elements
have a greatest common divisor is known as a g.c.d. domain.}

If $R$ is a g.c.d domain, then the elements of the field of fractions
can be simplified by cancelling a g.c.d. between numerator and
denomiator, oftan called ``reducing to lowest terms''. While this
simplifies fractions, it does not guarantee that they are normal or
canonical. One might think that $\frac{0}{1}$ was the unique
representation of zero required for normality, but what of
$\frac{0}{-1}$? Equally, $\frac{-1}{2}=\frac{1}{-2}$, and in general
we have to remove the ambiguity caused by units. In the case of
rational numbers, we do this automatically by making the denominator
positive, but the general case is more difficult.

{\sl Definition} {\sl h is said to be a least common multiple, or
l.c.m. of f and g if, and only if
\begin{enumerate}
\item both f and g divide h
\item if both f and g divide h', the h divides h'
\end{enumerate}}

This definition clearly extends to any number of arguments. The
l.c.m. is normally written lcm(f,g).

{\bf Proposition} {\sl If gcd(f,g) exists, then $fg/gcd(f,g)$ is a
least common multiple of f and g.}

This result is normally written as $fg=gcd(f,g)lcm(f,g)$, but this is
only true up to associates. We should also note that this result does
not extend to any number of arguments: in general
$fgh \ne gcd(f,g,g)lcm(f,g,h)$.

\subsection{Davis \cite{Davi09}}

Davis creates a verified proof checker by creating a simple, obviously
correct ``level 1'' checker based on a few rules. A ``level 2''
checker is implemented and verified by level 1. This bootsrap process
continues up to level 11 which has significant power. Every level 11
proof can be reduced to a level 1 proof, giving a solid foundation.


\subsection{Dominus \cite{Domi19}}

  lcm(a,b) * gcd(a,b) = ab

\subsection{Filliatre \cite{Fill03}}

A formal method to establish software correctness can involve several
steps. The first one is the {\sl specification}. A second one is a
method to generate some {\sl proof obligations}. And a third one is a
framework to {\sl establish their validity}.

Type theory identifies types with propositions and terms with proofs,
through the widely known Curry-Howard isomorphism. There is no real
difference between the usual first-order objects of the mathematical
discourse -- such as naturals, sets, and so forth -- and the proof
objects. The natural 2 is a first-order object of type {\tt nat}, and
a proof that 2 is even is a first-order object of type {\sl
even}(2). One can define a function $f$ taking as arguments a natural
$n$ and a proof that $n$ is even, and its type would be something like
$\forall n:{\tt nat}.even(n)\rightarrow\tau$. Such a function
represents a {\sl partial function} on naturals, where the proof of
{\sl even(n)} may be seen as a {\sl precondition}. Similarly, one can
define a function returning a proof term. For instance, the function
$f$ could return a natural $p$ and a proof that $n=2\times
p$. Finally, the type of $f$ will look like 
\[\forall n:{\tt nat}.even(n)\rightarrow\exists p:{\tt nat}.n=2\times p\]
where the proof of $n=2\times p$ may be seen as a {\sl
postcondition}. More generally, a type of the form
\[forall x : nat. P(x)\rightarrow\exists y:nat.Q(x,y)\]
is the type of a function with a precondition $P$ and a postcondition
$Q$. Building a term of this type is exactly like building a function
together with a proof of its correctness, and consequently type theory
appears as naturally suited for the proof of purely functional
programs.

We propose an interpretation of the Hoare triple $\{P\}e\{Q\}$ as a
proof of the above proposition and then define a systematic
construction of this proof from a given annotated program, where the
lacking proof terms are the so-called proof obligations.

The Coq {\bf Correctness} tactic takes an annotated program as
argument and generates a set of goals, which are logical propositions
to be proved by the user. Given an annotated program $e$, the tactic 
{\bf Correctness} applies the following steps:
\begin{enumerate}
\item It determines the type of computation of $\kappa$ of $e$ by the
typing algorithm
\item proposition $\hat{\kappa}$ is computed and declared as a goal
\item The partial proof term $\hat{e}$ is computed following
Definition 8 and is given to the proof engine, using the {\tt Refine}
tactic developed on purpose, and each hole in $\hat{e}$ leads to a
subgoal 
\item Once the proofs are completed, the program is added to the
environment and may be used in other programs
\end{enumerate}

Some features have been added to simplify the specification of
programs -- mainly, the possibility of inserting labels in the
programs and referring in annotations to the value that a reference
had at the program points corresponding to those labels. In
particular, a loop invariant may mention the values of the references
at some point before the loop using such a label.

\subsection{Frege \cite{Freg1891}}

 Function and Concept seminal paper

Fr\"uhwirht \cite{Frue91} details optimistic type systems for logic
programs.

\subsection{Gianni and Trager \cite{Gian85a}}

    "This paper shows how Grobner basis computations can be used to
    compute multivariate gcds, perform Hensel lifting, and reduce
    multivariate factorization to univariate. The essential idea is to
    produce an ideal containing the desired polynomial as an element
    of least degree. The construction is somewhat analogous to the
    recent lattice algorithms for polynomial factorization. A major
    difference is that we don't need to perform the hensel lifting as
    a separate step; one Brobner basis computation is sufficient to
    find the desired multivariate factor or gcd. We produce algorithms
    which are vary simple and may be of use on small systems where
    code size is critical. We feel that these results demonstrate the
    fundamental importance of the Grobner basis in computer algebra.",


\subsection{Galligo, Pottier and Traverso \cite{Gall88}}

    "Our approach looks for analogies with these algorithms, but a
    general structure theorem is missing, hence our approach relies on
    a limited seqrch of coefficient simplifications. The basic idea is
    the following: since the GCD is usually costly, we can use in its
    place the ``greatest between the common divisors that are easy to
    compute'' (the GECD), this suggestion allowing different
    instances. A set of such instances is based on the remark that if
    you hve elements in factorized form, then many common divisors are
    immediately evident. Since irreducible factorization, even
    assuming that is exists in our domain, is costly, we use a partial
    factorization basically obtained using a ``lazy multiplication''
    technique, i.e. performing coefficient multiplications only if
    they are unavoidable. The resulting algorithms were tested with a
    ``simulatied'' implementation on the integers, and the results
    suggest that a complete implementation should be very efficient,
    at least when the coefficient domain is a multivariate rational
    function field."

\subsection{Geddes, Gonnet, and Smedley \cite{Gedd88}}

    "Algorithms for doing computations involving algebraic numbers
    have been known for quite some time [6,9,12] and implementations
    now exist in many computer algebra systems [1,4,11]. Many of these
    algorithms have been analysed and shown to run in polynomial time
    and space [7,8], but in spite of this many real problems take
    large amounts of time and space to solve. In this paper we
    describe a heuristic method which can be used for many operations
    involving algebraic numbers. We gie specifics for doing algebraic
    number inverses, and algebraic number polynomial exact division
    and greatest common divisor calculation. The heurist will not
    solve all instances of these problems, but it returns either the
    correct result or with failure very quickly, and succeeds for a
    very large number of problems. The heuristic method is similar to,
    and based on concepts in [3].",

\subsection{Gurevich \cite{Gure12}}

What is an Algorithm?

Turing's analysis of computation was a stroke of genius. 
The analysis is extremely famous and yet it is often misunderstood.

Some people think that every computable function, total or partial,
can be computed by a Turing machine. This is not so, and here are some
counter-examples. Consider Euclid's algorithm for computing the
greatest common divisor $d=gcd(a,b)$ of two natural numbers $a,b$.
\begin{verbatim}
   let M = max(a,b), m = min(a,b)
   while M > m do
     M,m := max(M-m,m, min(M-m,m)
   d := M
\end{verbatim}

The gcd function on natural numbers is of course Turing computable,
but the algorithm was also applied -- in theory and in practice -- to
the lengths of segments of a straight line, which gives rise to a
computable partial function (the algorithm does not terminate if the
two given lengths are incommensurate) that is not Turing computable
because you cannot place an arbitrary length on the Turing tape. More
generally, the functions computed by ruler-and-conpass algorithms are
not Turing computable. And let us emphasize that ruler and compass
were practical tools in ancient Greece and that a number of rule and
compass algorithms were practical algorithms.

Moschovakis \cite{Mosc84} discusses Euclid's algorithm for the greatest common divisor of two natural numbers. Then he says:

Following the drive of the discussion, we might be expected at this
point to simply identify the Euclidean algorithm with the funcitonal
gcd. We will not go quite that far, because the time0honored intuitive
concept of algorithm carries many linguistic and intensional
connotations (some of them tied up with implementations) with which we
have not concerned ourselves. Instead we will make the weaker (and
almost trivial) claim that {\sl the functional gcd embodies all the
essential mathematical properties of the Euclidean algorithm}.


\subsection{Harrison \cite[p13]{Harr98}}

There are several examples of computer algebra results which may be
checked relatively easily:
\begin{itemize}
\item factoring polynomials (or numbers)
\item finding GCDs of polynomials (or numbers)
\item solving equations (algebraic, simultaneous, differential,...)
\item finding antiderviatives
\item finding closed forms for summations
\end{itemize}

In most cases the certificate is simply the answer. An exception is
the GCD, where a slightly more elaborate certificate is better for our
purposes. If we ask to find the GCD of $x^2-1$ and $x^5+1$ using the
gcd function, for example, the respons is $x+1$. How can this result
be checked? It's certainly straightforward to check that this is 
{\sl a} common divisor. If we don't want to code polynomial division
ourselves in HOL, we can call the {\tt divide} function, and then
simply verify the quotient as above. But how can we prove that $x+1$
is the {\sl greatest} common divisor\footnote{The use of 
``greatest'' is a misnomer: in a general ring we say that $a$ is the
GCD of $b$ and $c$ iff it is a common divisor, and any other common
divisor of $b$ and $c$ divides $a$. For example, both 2 and -2 are
GCDs of 8 and 10 over $\mathbb{Z}$.} At first sight, there is no easy
way, short of replicating something like the Euclidean algorithm
inside the logic (although that isn't really a difficult prospect).

However, a variant GCD algorithm, called {\sl gcdex} will, given
polynomials $p$ and $q$, produce not just the GCD $d$, but also two
other polynomials $r$ and $s$ such that $d=pr+qs$. (Indeed, the
coefficients in this sort of Bezout identity follow easily from the
Euclidean GCD algorithm.) For example, applied to $x^2-1$ and 
$x^5+1$ we get the following equation:
\[(-x^3-x)(x^2-1)+1(x^5+1)=x+1\]
This again can be checked easily, and from that, the fact that $x+1$
is the {\sl greatest} common divisor follows by an easily proved
theorem, since obviously any common factor of $x^2-1$ and $x^5+1$
must, by the above equation, divide $x+1$ too. So here, given a
certificate slightly more elaborate than simply the answer, easy and
efficient checking is possible.

\subsection{Hearn \cite{Hear72}}

    "An improved non-modular algorithm for the calculation of the
    greatest common divisor of two multivariate polynomials is
    presented.",


\subsection{Hoare \cite{Hoar85}}

The Euclidean algorithm defines the greatest common divisor, and we
write 
\[\begin{array}{rcl}
gcd(m,n)& = &\\
&&(m>n \rightarrow gcd(n,m)\\
&&rem(n/m)=0 \rightarrow m\\
&&T \rightarrow gcd(rem(n/m),m))
\end{array}
\]

\subsection{Hoare \cite{Hoar87}}

Let us suppose first that they agree to confine attention to positive
whole numbers (exclusing zero). The required relationship between the
parameters ($x$,$y$) and the result ($z$) may be formalized as
follows: 
\begin{verbatim}
  D1.1  z divides x
  D1.2  z divides y
  D1.3  z is the greatest of the set of numbers satisfying both conditions
  D1.4  "p divides q" means "there exists a positive whole number w
        such that pw=q"
  D1.5  "p is the greatest member of the set S" means "p is in S, and no
        member of S is strictly greater than p"
\end{verbatim}

We need to check that for every pair of positive numbers $x$ and $y$
there exists a number $z$ with the properties specified in D1.3. A
proof of this has three steps.
\begin{verbatim}
  P1.1 The number one is a divisor of every number. So it is a common
       divisor of every pair of numbers. This shows that the set of
       common divisors of two numbers is non-empty.
  P1.2 Each number is its own greatest divisor, so every set of
       divisors is finite. The common subset of any two finite sets is
       also finite. So the set of common divisors of two nubers is
       both finite and non-empty.
  P1.3 Every finite non-empty set of integers has a greatest member.
       So the maximum used to define the greatest common divisor
       always exists.
\end{verbatim}

Here is an idealized logic program to compute the greatest common
divisor of two positive integers. To help in checking its correctness,
it has been designed to preserve as far as possible the structure and
clarity of the original requirements. We assume that ``isproduct'' and
``differsfrom'' are available as built-in predicates on positive
integers.

\begin{verbatim}
  L2.1 isdivisor(x,z) if there exists a w not greater than x such that
       isproduct(z,w,x) 
  L2.2 iscommutative(x,y,z) if isdivisor(x,z) and isdivisor(y,z)
  L2.3 isgcd(x,y,z) if iscommondiv(x,y.z) and for all w from z to x
       isnotcommondiv(x,y,z) 
  L2.4 isnotcommondiv(x,y,z) if isnotdiv(x,z) or isnotdiv(y,z)
  L2.5 isnotdiv(x,z) if for all w from 1 to x isnotproduct(z,w,x)
  L2.6 isnotproduct(z,w,x) if isproduct(z,w,y) and differsfrom(y,x)
\end{verbatim}

This program is a great deal more complicated than the requirements
specification in the preious section. The obvious reason is that the
absence of negation in the programming language requires explicit
programming of a search through all possibilities before a negative
answer is given. In order to ensure termination a finite range for
each search has to be specified, and setting this limit requires
knowledge of the application domain. For example, in L2.3 we rely on
the fact that the common divisor of two numbers cannot exceed either
number. 

When restricted from using disjunction and negation the algebraic
equations have to be derived as needed by mathematical reasoning from
the whole of the original specification. For gcd we see
\begin{verbatim}
  L3.1 The greatest divisor of x is x. So the greatest common divisor
       of x and x is also x.
          x = gcd(x,x) for all x
  L3.2 If z divides x and y, it also divides x+y. So every common 
       divisor of x and y is also a common divisor of x+y and y.
       Similarly, every common divisor of x+y and y is also a common
       divisor of x and y. So the greatest of these identical sets
       of common divisors are the same.
          gcd(x,y) = gcd(x+y,y) for all x,y
  L3.3 Every common divisor of x and y is also a common divisor of
       y and x.
          gcd(x,y) = gcd(y,x) for all x,y
\end{verbatim}

But are the laws a {\sl complete} specification, in the sense that
there is aonly one function satisfying them? Or do we need to look for
more laws? A proof of completeness has to show that for any given
positive numerals $p$ and $q$ there is a numeral $r$ such that the
equation
\[r=gcd(p,q)\]
can be proved solely from the algebraic specification and the
previously known laws of arithmetic.

This can be shown by mathematical induction: We assume the result for
all $p$ and $q$ strictly less than $N$, and prove it for all $p$ and
$q$ less than or equal to $N$. For such numbers, four cases can be
distinguished.
\begin{enumerate}
\item Both $p$ and $q$ are strictly less than $N$. In this case, what
we have to prove is the same as the induction hypothesis, which may be
assumed without proof.
\item Both $p$ and $q$ are equal to $N$. Then the result
\[N=gcd(p,q)\] 
is proved immediately by law L3.1
\item $p=N$ and $q<N$. It follows that $p-q$ is positive and less than
$N$. By the induction hypothesis, there is an $r$ such that
\[r=gcd(p-q,q)\]
is deducible from the algebraic laws. One application of L3.2 then
gives
\[r=gcd(p-q)+q,q)\]
which by the laws of arithmetic leads to the required conclusion
\[r=gcd(p,q)\]
\item $p<n$ and $q=N$. Then there is an $r$ such that
\[r=gcd(q,p)\]
is provable in the same way as in case (3) described above. One
application of L3.3 then gives
\[r=gcd(p,q)\]
That concludes the proof that the algebraic specification is complete.
\end{enumerate}

Clearly there is no structural correspondence between the three
clauses of the algebraic specification and the five clauses expressing
the original requirement. As a result, some mathematical ingenuity and
labour has been needed to prove that the two orthogonal specifications
describe (and completely describe) the same function. This labor could
be avoided by simply leaving out the original formalization of
requirements in the general notations of mathematics, and by starting
instead within the more restricted equational framework of algebra.

But this would be a mistake. The purpose of the specification is to
tell the user of a subroutine the properties of the result it
produces, and to do so in a manner conducive to the wider objectives
of the program as a whole. Clearly, the user of a subroutine to
compute the greatest common divisor will be very directly interested
in the fact that the result of every subroutine call divides each of
its two arguments exactly. But the algebraic law tells us only that
the same result have been obtained if the two arguments had been
permuted (L3.3) or added together (L3.2) before the call. These facts
by themselves seem a lot less directly useful.

It would also be a mistake to regard the different specification, the
abstract one and the algebraic one, as rivals or even as
alternatives. They are both needed; they are essentially
complementary, and the can be used for different purposes.

Here is a functional program to compute the greatest common divisor of
positive integers.

\begin{tabular}{lll}
F4.1 & $gcd(x,y)=x$ & if $x=y$\\
F4.2 & $gcd(x,y)=gcd(x-y,y)$ & if $x>y$\\
F4.3 & $gcd(x,y)=gcd(y,x)$ & if $x<y$\\
\end{tabular}

To compute the greatest common divisor of 10 and 6:

\begin{tabular}{rclr}
gcd(10,6) & = & gcd(4,6) & by F4.2\\
          & = & gcd(6,4) & by F4.3\\
          & = & gcd(2,4) & by F4.2\\
          & = & gcd(4,2) & by F4.3\\
          & = & gcd(2,2) & by F4.2\\
          & = & 2 & by F4.1\\
\end{tabular}

However, the responsibility for controlling this goal-directed
behavior is placed upon the programmer, who has to prove that there is
no infinite chain of substitutions. For example, as an algebraic
formula
\[gcd(x,y)=gcd(y,x)\]
is quite correct, but if this is executed as part of a functional
program, it leads to an infinite chain of substitutions.  In the
program shown above, this cycle is broken by ensuring that the
dangerous substitution is made only when $y$ is strictly greater than
$x$. 

We can optimize the search for the greatest common divisor
algebraically.
\begin{itemize}
\item L5.1 If $z$ divides $x$, the $2z$ divides $2x$. So if $z$ is the
greatest common divisor of $x$ and $y$, then $2z$ is a common divisor
of $2x$ and $2y$. It is therefore not greater than their greatest
common divisor
\[2 gcd(x,y) < gcd(2x,2y)\]
Conversely, if $z$ is the greatest common divisor of $2x$ and $2y$,
then $z$ is even and $z/2$ is a common divisor of $x$ and $y$.
\[gcd(2x,y2)/2 \le gcd(x,y)\]
From these two inequalities ti follows that
\[2 gcd(x,y)=gcd(2x,2y)\]
\item L5.2 All divisors of an odd number are odd, and if an odd number
divides $2x$ is also divides $x$. If $y$ is odd, the greatest common
divisor of $2x$ and $y$ is odd, so it is also a common divisor of $x$
and $y$
\[gcd(2x,y)\le gcd(x,y)\quad{\rm if\ }y{\rm\ is\ odd}\]
Conversely, every divisor of $x$ divides $2x$
\[gcd(x,y) \le gcd(2x,y)\]
From these two inequalities it follows that
\[gcd(2x,y)=gcd(x,y)\quad{\rm if\ }y{\rm\ is\ odd}\]
\item L5.3 If both $x$ and $y$ are odd, and $x$ is greater than $y$,
it follows that $x-y$ is positive and even. So under these conditions
\[gcd(x,y)=gcd((x-y)/2,x)\]
\end{itemize}
When these equations are coded as a functional program, it becomes
clear that the number of operations required when the argument of size
$2^N$ has been reduced to about $N$.

A Procedural program has some assertions, generally specified as
preconditions, invariants, and postconditions. 
\begin{itemize}
\item P6.1 $x>0 \land y > 0$ as a precondition
\item P6.2 $Z=gcd(x,y)$ as a postcondition
\item P6.3 $s^N gcd(X,Y)=gcd(x,y)$. The task of the first part is to
make P6.3 true on termination. That is easily accomplished by just one
multiple assignment
\[N,Z,Y:=0,x,y\] 
which can be proven by substitution
\[2^0 gcd(x,y) = gcd(x,y)\]
\item P6.4 We can show that
\[2^N Z=gcd(x,y)\]
This would be obviously true if $N$ were already zero. If $N$ is
non-zero, it can be made closer to zero by subtracting one. But ath
would amek P6.4 false, and therefore useless. Fortunately, the truth
of P6.4 can easily be restored if every subtraction of one from $N$ is
accompanied by a doubling of $Z$. This can be proven by
\[n>0 \land 2^N Z=gcd(x,y)\rightarrow 2^{N-1}(2Z)=gcd(x,y)\]
Since termination is obvious, we have proved the correctness of the
loop 
\[{\bf while}~N>0~{\bf do}~N,Z:=N-1,2X\]
On termination of this loop, the value of $N$ is zero and P6.4 is
still true. Consequently, the postcondition of the whole program has
been established.
\end{itemize}

Having completed the first and last of the three tasks, the time has
come to confess that the middle task is the most difficult. Its
precondition is P6.3 and its postcondition is P6.4. The task can be
split into four subtasks, in accordance with the following series of
intermediate assertions.

\begin{tabular}{rcl}
P6.3 & $\land$ & (X odd $\lor$ Y odd)\\
P6.3 & $\land$ & (Y add)\\
P6.3 & $\land$ & (Y odd) $\land$ X=Y\\
\end{tabular}

\subsection{Jenks \cite{Jenk75}}

Greatest Common Divisor. Integer algorithms: Euclid's algorithm;
improved versions; Extended Euclidean algorithm. Polynomial GCD:
definitions and basic theorems; division and pseudo-division;
polynomial remainder sequences. PRS algorithm: Euclidean, primitive,
reduced, and subresultant. Modular GCD algorithm: outline of
``general modular problem solver''; application to GCD; other
problems in GCD algorithm design and their solution; description
of univariate and multivariate algorithms; compute time analysis.

Hensel's Lemma and Algorithm Applications. Introduction: problems
with PRS GCD algorithms; schematic differences between modular and
Hensel approaches; an example. Background: p-adic representations of
integers and polynomials; general statement of Hensel's lemma;
application to solving diophantine univariate polynomial equations.
Hensel algorithm for univariate GCD and its generalization to
multivariate case; comparison with modular algorithm.

Hensel's Lemma and Algorithm Applications. The EZ GCD algorithm:
description; discussion of test comparisons with other algorithms;
leading coefficient blowup problem and its solution in the EZ
algorithm.

\subsection{Jenks \cite{Jenk84b}} Overview of Scratchpad.

\subsection{Kaltofen \cite{Kalt85f}}

Arithmetic in Quadratic Fields with Unique Factorization

In a quadratic field $\mathbb{Q}(\sqrt{D})$, $D$ a squarefree
integer, with class number 1 any algebraic integer can be
decomposed uniquely into primes but for only 21 domains Euclidean
algorithms are known. We prove that for $D \le -19$ even remainder
sequences with possibly non-decreasing norms cannot determine the
GCD of arbitrary inputs. We then show how to compute the greatest
common divisor of the algebraic integers in any fixed
$\mathbb{Q}(\sqrt{D})$ with class number 1 in $O(S^2)$ binary
steps where $S$ is the number of bits needed to encode the
inputs. We also prove that in any domain the computation of the
prime factorization of an algebraic integer can be reduced in
polynomial-time to factoring its norm into rational primes. Our
reduction is based on a constructive version of a theorem by
A. Thue. Finally we present another GCD algorithm for complex
quadratic fields based on a short lattice vector construction.

\subsection{Kaltofen \cite{Kalt85d}}

A new algorithm is introduced which computes the multivariate
leading coefficients of polynomial factors from their univariate
images. This algorithm is incorporated into a sparse Hensel
lifting scheme and only requires the factorization of a single
univariate image. The algorithm also provides the content of the
input polynomial in the main variable as a by-product. We show how
we can take advantage of this property when coputing the GCD of
multivariate polynomials by sparse Hensel lifting.",

\subsection{Kifer \cite{Kife91}} 

Typed Predicate Calculus giving declarative meaning to
logic programs with type declarations and type inference.

\subsection{Kowalski \cite{Kowa84}}

The Euclidean algorithm can be verified by the same technique of
deriving programs from specifications that was used to verify the
recurssive program for subset. For the Euclidean algorithm, however,
the program is significantly more efficient than the
specification. Here we use functional notation for the sake of
clarity.
\begin{verbatim}
(a) gcd(x y) = z if z divides x
                 and z divides y
                 and For all u [u <= z if u divides x
                                       and u divides y]
\end{verbatim}

Notice that, like the definition of subset, this definition is
expressed in the extended Horn clause subset of logic. However, the
Euclidean algorithm for gcd can be expressed in Horn cluase form:
\begin{verbatim}
(a) gcd(x y) = z if x divides y
    gcd(x y) = z if x <= y
                 and x divides y with remainder r
                 and r != 0
                 and gcd(r x) = z
\end{verbatim}

It can be shown that the specification  (in iff form together with
auxiliary properties of `divides', '<=', and the axioms of equality)
logically implies the program. However, the derivation requires
genuine mathematical ingenuity. Although both specification and
program are executable, the program is significanly more efficient.

Note:
\begin{enumerate}
\item The functional notation gcd(x y) = z an be rewritten in
relational notation as Gcd(x y z)
\item By exploiting functional notation, the second clause of the
program can be written more compactly as
\begin{verbatim}
   gcd(x y) = gcd(r x) if x <= y
                       and x divides y with remainder r
                       and r != 0
\end{verbatim}
\item For the sake of completeness we need to add a third clause
\begin{verbatim}
   gcd(x y) = gcd(y x) if y <= x
\end{verbatim}
\end{enumerate}

(from the questions): In this gcd example Kowalski seemed to
indicate that the seaarch for gcd(x y) would be limited to numbers
less than x and y. Putting a limit on the search requires either a
careful choice of the specification of divides (which must state more
or less explicitly that divides(x y) is false if $x > y$) or else a
lot of cleverness on the part of the compiler. The fact that some
specifications lead to non-terminating programs suggests that the
relation between specifications and programs is not as close as
Kowalski says.

(with the answer): There are two ways to 'execute' the specification
of gcd: by means of a standard theorem-prover for first-order logic or
by using negation by failure. Because negation by failure is
incomplete in the general case, it may be incomplete in a particular
case such as the specification of gcd, especially if the definition of
divides(x y) does not have some explicit or implicit constraint that
$x < y$.

However, if we use any complete theorem-prover for first-order logic
and the definition of gcd implies the existence of a gcd, for
paricular numbers x and y, then, by the completeness theorem for
first-order logic, the theorem-prover is guaranteed to terminate
successfully with an existence proof. Most theorem-provers, including
all theorem-provers based on the resolution principle, will construct
the gcd as a by-product of the proof. Thus, except for the
inefficiency involved in using a general-purpose theorem-prover for
computation, there is no difference in principle between a program and
a complete specification, except for efficiency.

\subsection{Kowalski \cite{Hoar85}}

The Euclidean algorithm can be verified by the same technique of
deriving programs from specifications that was used to verify the
recursive program for subset. For the Euclidean algorithm, however,
the program is significantly more efficient than the
specification. Here we use functional notation for the sake of
clarity.

\hspace*{0.1cm}gcd(x y) = z if z divides x\\
\hspace*{1.5cm}             and z divides y\\
\hspace*{1.5cm}             and For all u [u $\le$ z if u divides x\\
\hspace*{2.5cm}                                   and u divides y]

Notice that, like the definition of subset, this definition is
expressed in the extended Horn clause subset of logic. However, the
Euclidean algorithm for gcd can be expressed in Horn clause form.

\hspace*{0.1cm}gcd(x y) = z if x divides y\\
\hspace*{0.1cm}gcd(x y) = z if x $\le$ y\\
\hspace*{1.5cm}and x divides y with remainder r\\
\hspace*{1.5cm}and r $\ne$ 0\\
\hspace*{1.5cm}and gcd(r x) = z

It can be shown that the specification (in iff form together with
auxillary properties of 'divides', '$\le$', and the axioms of
equality) logically implies the program. However, the derivation
requires genuine mathematical ingenuity. Although both specification
and program are executable, the program is significanly more
efficient. 

Notes:

(1) The functional notation gcd(x y) = z can be rewritten in
relational notation as Gcd(x y z)

(2) By exploiting functional notation, the second clause of the
program can be written more compactly as

\hspace*{1.1cm}gcd(x y) = gcd(r x) if x $\le$ y\\
\hspace*{2.5cm}and x divides y with remainder r\\
\hspace*{2.5cm}and r $\ne$ 0

(3) for the sake of completeness we need to add a third clause

\hspace*{1.1cm}gcd(x y) = gcd(y x) if y $\le$ x

The use of functional notation simplifies the program, but is
inefficient if the equality symbol, $=$, is defined by means of the
axioms of equality. We shall show later how functional notation can be
transformed into relational notation without equality. Thus we can
have the convenience of functional notation whie retaining the
semantics of relations. Relational semantics gives us both partial
functions and non-deterministic functions as special cases.

\subsection{Lamport \cite{Lamp09}}

Euclid's Algorithm (pp 4--6)

The first example is a simple version of Euclid's algorithm from
Sedgewick's textbook \cite{Sedg88}. The algorithm computes the GCD of
two natural numbers $m$ and $n$ by setting $u$ to $m$ and $v$ to $m$
and executing the following pseudo-code:

\hspace*{0.5cm}while $u \ne 0$ do\\
\hspace*{1.0cm}if $u < v$ then $swap\ u\ and\ v$ end if;
\hspace*{1.0cm}u := u - v
\hspace*{0.5cm}end while

Upon termination, $v$ equals the GCD of $m$ and $n$. The PlusCal
version is

\hspace*{0.5cm}--algorithm EuclidSedgewick\\
\hspace*{0.5cm}variables $m\in 1\ldots K$, $n\in 1\ldots K$,
$u=m$, $v=n$\\
\hspace*{0.5cm}begin while $u\ne 0$ do\\
\hspace*{1.5cm}if $u < v$ then $u := v || v := u$ end if;\\
\hspace*{1.5cm}$u := u - v$\\
\hspace*{1.0cm}end while;\\
\hspace*{1.0cm}assert $IsGCD(v,m,n)$\\
\hspace*{0.5cm}end algorithm

The variable declarations assert that the initial values of $m$ and
$n$ are in the set $1\ldots K$ of integers from 1 through $K$, and
that $u$ and $v$ initially equal $m$ and $n$, respectively. (We will
later see wher $K$ is declared). Assignment statements separated by
$||$ form a multi-assignment, executed by first evaluating all the
right-hand expressions and then performing all the assignments. The 
{\bf assert} statement checks the correctness of the algorith, where 
$IsGCD(v,m,n)$ will be defined to be true iff $v$ is the GCD of $m$
and $n$, for natural numbers $v$, $m$, and $n$.

The algorithm appears in a comment in a TLA+ module:

\hspace*{3.0cm}MODULE Euclid\\
\hspace*{0.5cm}EXTENDS $Naturals$, TLC
\hspace*{0.5cm}CONSTANT $K$
\hspace*{0.5cm}$Divides(i,j)\over{\Delta}{=} \exists k\in 0\ldots j :
j = i*k$\\
\hspace*{0.5cm}$ISGCD(i,j,k)\over{\Delta}{=} Divides(i,j)$\\
\hspace*{2.0cm}$\land Divides(i,j)$\\
\hspace*{2.0cm}$\land \forall r\in 0..j \cup 0..k :$\\
\hspace*{2.5cm}$Divides(r,j)\land Divides(r,k) \Rightarrow Divides(r,i)$\\
\hspace*{0.5cm}(* --algorithm $EuclidSedgewick$\\
\hspace*{1.0cm}$\ldots$\\
\hspace*{0.5cm}end algorithm *)\\
\hspace*{0.5cm}\\* BEGIN TRANSLATION\\
\hspace*{1.0cm}Translator puts TLA+ specification here\\
\hspace*{0.5cm}\\* END TRANSLATION

The mdoule's EXTENDS statement imports the $Naturals$ module, which
defines arithmetic operators like subtraction and ``$\ldots$'', and a
speclal TLC module that is needed because of the algorithms
{\bf assert} statement. The CONSTANT declaration declares the
algorithm parameter $K$. The module next defines $Divides(i,j)$ to be
true for natural numbers $i$ and $j$ iff $i$ divides $j$, and it uses
$Divides$ to define $IsGCD$.

The translator inserts the algorithm's translation, which is a TLA+
specification, between the BEGIN and END TRANSLATION comment lines,
replacing any previous version. The translator also writes a
configuration file that controls the TLC model checker. We must add to
that file a command that specifies the value of $K$. TLC checks that
the assertion is satisfied and that execution terminates for all $K^2$
possible choices of the variables' inital values. 

REMARKS

The operation of swapping $u$ and $v$ can of course be expressed
without a multiple assignment by declaring an additional variable $t$
and writing:

\hspace*{0.5cm}$t:=u; u:=v; v:=t$

It can also be written as follows

\hspace*{0.5cm}with $t = u$ do $u:=v$; $v:=t$ end with

The WITH statement declares $t$ to be local to the DO clause.

Instead of restricting $m$ and $n$ to be in the range $1\ldots K$, it
would be more natural to allow them to be any positive integers. We do
this by replacing $1\ldots K$ with the set of positive integers, here
are three ways to express that set in TLA+, where $Nat$ is defined in
the $Naturals$ module to be the set of all natural numbers.

\hspace*{0.5cm}\[Nat \\ \{0\}\quad 
\{i\in Nat : i > 0\}\quad
\{i+1 : i\in Nat\}\]

To check the resulting algorithm, we would tell TLC to substitute a
finite set of numbers for $Nat$.

As this example shows, PlusCal is untyped. Type correctness is an
invariance property of an algorithm asserting that, throughout any
execution, the values of the variables belong to certain sets. A type
invariant for algorithm $EuclidSedgewick$ is that the values of $u$
and $v$ are integers. For a type invariant like this whose proof is
trivial, a typed language allows type correctness to be verified by
type checking. If the proof is not completely trivial, as for the type
invariant that $u$ and $v$ are natural number, type correctness annot
be verified by ordinary type checking. (If $natural\ number$ is a
type, the type checking is undecidable for a Turing complete language
with subtraction.) These type invariants are easily checked by TLC.

The translation from PlusCal to TLA+ is 

\hspace*{0.5cm}--algorithm EuclidSedgewick\\
\hspace*{0.5cm}variables $m\in 1\ldots K$, $n\in 1\ldots K$, $u=m$,
$v=n$\\ 
\hspace*{0.5cm}begin $L1$: while $u\ne 0$ do\\
\hspace*{2.5cm}if $u < v$ then $u:=v || v:=u$ end if;\\
\hspace*{2.3cm}$L2$: $u:=u-v$\\
\hspace*{2.0cm}end while;\\
\hspace*{2.0cm}assert $IsGCD(v,m,n)$\\
\hspace*{0.7cm}$Done$:\\
\hspace*{0.5cm}end algorithm

\subsection{lion137 \cite{lion137}} 

{\bf Fundamental Algorithms: Polynomial GCD}

Another one in the series on fundamental algorithms; today: polynomial
division. We assume that polynomial is over some field, this is a good
thing, we have lots of nice properties in those, explicitly. If $a$
and $b$ are in the field and $b$ is not zero, than there always exists
an element of the field $c$, such that $a=bc$.

So division is easy, just ``push it'' over the field, like division in
base, or multi precision division. Algorithm, Knuth ``The Art of
Computer Programming Vol 4'' and the others.

\begin{verbatim}
# input: coefficients of polynomials as a lists u, v != 0
# in order u[0] = free coefficient of u(x), ....
# returns polynomials q, r such that u = vq + r(rest)
# length u >= length v >= 0
def poly_divide(u, v)
  m = len(u) - 1
  n = len(v) - 1
  q = [0] * (m - n + 1)
  lim = m - n
  for k in range (lim, -1, -1):
    q[k] = u[n + k] / v[n]
    for j in range(n + k - 1, k - 1, -1):
      u[j] = u[j] - q[k] * v[j - k]
  return q, u[:n]
\end{verbatim}

Having division, we can compute the Great Common Divisor, showing that
Euclidean Domain is larger than expected.

\begin{verbatim}
def poly_gcd(u, v):
  if not any(v): return u
  else: return poly_gcd(v,poly_mod(u,v))
\end{verbatim}

$poly\_mod$ it's just a rest returned from division algorithm.

\begin{verbatim}
# a polynomial u modulo v
def poly_mod(u, v):
  return poly_divide(u,v)[1]
\end{verbatim}

\subsection{Makkai \cite{Makk07}}

Gives a formal definition of the GCD

\subsection{Manna and Waldinger \cite{Mann78a}}

{\bf Greatest Common Divisor of Two Numbers}

In the previous two examples, we have applied the
intermittent-assertion method to programs involving only one loop. The
following program, which computes the greatest common divisor (gcd) of
two positive integers, is introduced to show how the
intermittent-assertion method is applied to a program with more
complex loop structure.

We define $gcd(y,y)$, where $x$ and $y$ are positive integers, as the
greatest integer that divides both $x$ and $y$, that is
\[gcd(x,y) = max\{u:u~\vert~x and u~\vert~y\}\]

For instance, $gcd(9,12)=3$ and $gcd(12,25)=1$. The program is
\begin{verbatim}
       input(x,y)
start:
more:  if x = y
       then finish: output(y)
       else reducex: if x > y
                     then x <- x - y
                          goto reducex
            reducey: if y > x
                     then y <- y - x
                          goto reducey
            goto more
\end{verbatim}

This program is motivated by the following properties of the $gcd$: 
\[\begin{array}{l}
gcd(x,y) = y{\rm\ if\ } x = y\\
gcd(x,y) = gcd(x-y,y){\rm\ if\ } x > y\\
gcd(x,y) = gcd(x,y-x){\rm\ if\ } y > x
\end{array}\]

We would like to use the intermittent-assertion method to prove the
total correctness of this program. The total correctness can be
expressed as follows:

{\bf Theorem}: If {\sl sometime} $x=a$, $y=b$ and $b>0$ at start
then {\sl sometime} $y=gcd(a,b)$ at finish.

To prove this theorem, we need a lessa that describes the internal
behaavior of the program.

{\bf Lemma}: If\\
{\sl sometime} $x=a$, $y=b$, and $a,b > 0$ at {\tt more} or \\
{\sl sometime} $x=a$, $y=b$, and $a,b > 0$ at {\tt reducex} or\\
{\sl sometime} $x=a$, $y=b$, and $a,b > 0$ at {\tt reducey},\\
then {\sl sometime} $y=gcd(a,b)$ at {\tt finish}

To show that the lemma implies the theorem, we assume that

{\sl sometime} $x=a$, $y-b$, and $a,b > 0$ at {\tt start}.

Then control passes to {\tt more}, so that

{\sl sometime} $x=a$, $y-b$, and $a,b > 0$ at {\tt more}.

But then the lemma implies that

{\sl sometime} $y=gcd(a,b)$ at {\tt finish},

which is the desired conclusion of the theorem.

It remains to prove the lemma. We suppose

{\sl sometime} $x=a$, $y=b$, and $a,b > 0$ at {\tt more} or \\
{\sl sometime} $x=a$, $y=b$, and $a,b > 0$ at {\tt reducex} or\\
{\sl sometime} $x=a$, $y=b$, and $a,b > 0$ at {\tt reducey},

The proof proceeds by induction on $a+b$; we assume inductively that
the lemma holds whenever $x=a^\prime$ and $y=b^\prime$, where
$a^\prime + b^\prime < a + b$, and show that

{\sl sometime} $y=gcd(a,b)$ at {\tt finish}.

We must distinguish between three cases.

{\bf Case $a = b$}. Regardless of whether control is at {\tt more},
{\tt reducex}, or {\tt reducey}, control passes to {\tt finish} with 
$y=b$, so that

{\sl sometime} $y=b$ at {\tt finish}

But in this case $b=gcd(a,b)$, by a given property of the $gcd$
function, so we have

{\sl sometime} $y=gcd(a,b)$ at {\tt finish}.

which is the desired conclusion of the lemma.

{\bf Case $a > b$}. Regardless of whether control is at {\tt more}, 
{\tt reducex}, or {\tt reducey}, control reaches {\tt reducex} and
passes around the top inner loop, resetting $x$ to $a-b$, so that

{\sl sometime} $x = a - b$ and $y = b$ at {\tt reducex}

For simplicity, let us denote $a-b$ and $b$ by $a^\prime$ and
$b^\prime$, respectively. Note that

$a^\prime, b^\prime > 0$\\
$a+b > a^\prime + b^\prime$, and\\
$gcd(a^\prime,b^\prime) = gcd(a-b,b) = gcd(a,b)$

This last condition follows by a given property of the $gcd$.

Because $a^\prime, b^\prime > 0$ and $a+b > a^\prime+b^\prime$, the
induction hypothesis implies that

{\sl sometime} $y=gcd(a^\prime,b^\prime)$ at {\tt finish}.

i.e., by the third condition above,

{\sl sometime} $y=gcd(a,b)$ at {\tt finish}.

{\bf Case $b > a$}. This case is disposed of in a manner symmetric to
the previous case.

This concludes the proof of the lemma. The total correctness of the
program is thus extablished. 

It is not difficult to prove the partial correctness of the above
program by using the conventional invariant-assertion method. For
instance, to prove that the program is partially correct with respect
to the input specification

$x_0 > 0$ and $y_0 > 0$

and output specification

$y=gcd(x_0,y_0)$

(where $x_0$ and $y_0$ are the initial values of $x$ and $y$), we can
use the same invariant assertion

$x,y > 0$ and $gcd(x,y) = gcd(x_0,y_0)$

at each of the labels {\tt more}, {\tt reducex} and {\tt reducey}.

In contrast, the termination of this program is awkward to prove by
the conventional well-founded ordering method, because it is possible
to pass from {\tt more} to {\tt reducex}, {\tt reducex} to 
{\tt reducey}, or from {\tt reducey} to {\tt more} without changing
any of the program variables. One of the simplest proofs of the
termination of the $gcd$ program by this method involves taking the
well-founded set to be the pairs of nonnegative integers ordered by
the regular lexicographic ordering. When the expresion corresponding
to the loop labels are taken to be

$(x+y,2)$ at {\tt more}\\
if $x\ne y$ then $(x+y,1)$ else $(x+y,4)$ at {\tt reducex}, and\\
if $x<y$ then $(x+y,0)$ else $(x+y,3)$ at {\tt reducey}

it can be shown that their successive values decrease as control
passes from one loop label to the next. 
Although this method is effective, it is not the most natural in
establishing the termination of the $gcd$ program.

\subsection{Mao \cite{Maox20}}

Let $a=bq+r$, where $a$, $b$, $q$, and $r$ are integers. Then 
$gcd(a,b)=gcd(b,r)$.

{\bf Proof}

Supposed $d\vert a$ and $d\vert b$, then we have
\[\begin{array}{rcl}
a & = & dk_1\\
b & = & dk_2\
\end{array}\]
for some $k_1,k_2 \in \mathbb{N}$
\[\begin{array}{rcl}
r & = & a-bq\\
  & = & dk_1 - dk_2q\\
  & = & d(k_1-k_2q)
\end{array}\]

This means that any common divisor for $a$ and $b$ must also be a
divisor for $r$, and further any common divisor for $a$ and $b$ must
also be a common divisor for $b$ and $r$. So one of the common
divisors for $a$ and $b$, $gcd(a,b)$, is a common divisor for $b$ and
$r$. Since the greatest common divisor for $b$ and $r$ is $gcd(b,r)$,
then we have $gcd(a,b)\le gcd(b,r)$.

Similarly, we could prove that any common divisor for $b$ and $r$ must
also be a divisor for $a$, and further any common divisor for $b$ and
$r$ must also be a common divisor for $a$ and $b$. So one of the
common divisors for $b$ and $r$, $gcd(b,r)$, is a common divisor for
$a$ and $b$. Since the greatest common divisor for $a$ and $b$ is
$gcd(a,b)$, then we have $gcd(b,r)\le gcd(a,b)$.

Because $gcd(a,b)\le gcd(b,r)$ and
$gcd(b,r)\le gcd(a,b)$, we must have
$gcd(a,b)=gcd(b,r)$.

{\bf QED}

\subsection{McAllester, D. and Arkondas, K., \cite{Mcal96}}

"Primitive recursion is a well known syntactic restriction on
recursion definitions which guarantees termination. Unfortunately
many natural definitions, such as the most common definition of
Euclid's GCD algorithm, are not primitive recursive. Walther has
recently given a proof system for verifying termination of a
broader class of definitions. Although Walther's system is highly
automatible, the class of acceptable definitions remains only
semi-decidable. Here we simplify Walther's calculus and give a
syntactic criteria generalizes primitive recursion and handles
most of the examples given by Walthar. We call the corresponding
class of acceptable defintions ``Walther recursive''.",

\subsection{McCarthy \cite{Mcca63}}


Let $I$ be the set of non-negative integers $\{0,1,2,\ldots\}$ and
denote the successor of an integer $n$ by $n^\prime$ and denote the
equality of integers $n_1$ and $n_2$ by $n_1=n_2$. If we define
functions $succ$ and $eq$ by
\[succ(n)=n^\prime\]

\[eq(n_1,n_2)=
\left\{
\begin{array}{c}
{\tt T} {\tt\ if\ } n_1=n_2\\
{\tt F} {\tt\ if\ } n_1\ne n_2\\
\end{array}
\right.\]

then we write $\mathcal{F}=\{succ,eq\}$. We are interested in 
$\mathcal{C\{F\}}$. Clearly all functions in $\mathcal{C\{F\}}$ will
have either integers or truth values as values.

First we define the predecessor function $pred$ (not defined for
$n=0$) by 
\[pred(n)=pred2(n,0)\]

\[pred2(n,m)=(m^\prime=n\rightarrow m,
{\tt T}\rightarrow pred2(n,m^\prime))\]

We shall denote $pred(n)$ by $n^-$

Now we define the sum
\[m+n=(n=0\rightarrow m,~{\tt T}\rightarrow m^\prime+n^\prime)\]
the product
\[mn=(n=0\rightarrow 0,~{\tt T}\rightarrow m+mn^-)\]
the difference
\[m-n=(n=0\rightarrow m,~{\tt T}\rightarrow m^- -n^-)\]
which is defined only for $m\ge n$. The inequality predicate $m\le n$
is defined by
\[m\le n=(m=0)\lor(\sim{}(n=0\land(m^-\le n^-))\]
The strict inequality $m<n$ is defined by
\[m<n=(m\le n)\land\sim{}(m=n)\]
The integer valued quotient $m/n$ is defined by
\[m/n=(m<n\rightarrow 0,~{\tt T}\rightarrow((m-n)/n)^\prime)\]
The remainder on dividing $m$ by $n$ is defined by
\[rem(m/n)=(m<n\rightarrow m,~{\tt T}\rightarrow rem((m-n)/n))\]
and the divisibility of a number $n$ by a number $m$,
\[m|n=(n=0)\lor((n\ge m)\land(m|(n-m)))\]
The primeness of a number is defined by
\[prime(n)=(n\ne 0)\land(n\ne 1)\land prime2(n,2)\]
where
\[prime2(m,n)=(m=n)\lor(\sim{}(m|n)\land prime2(n,m^\prime))\]

The Euclidean algorithm defines the greatest common divisor, and we
write 
\[gcd(m,n)=(m>n\rightarrow gcd(n,m),
rem(n/m)=0\rightarrow m,
{\tt T}\rightarrow gcd(rem(n/m,m))\]
and we can define Euler's $\varphi$-function by
\[\varphi(n)=\varphi_2(n,n)\]
where
\[\varphi_2(n,m)=(m=1\rightarrow 1,
gcd(n,m)=1\rightarrow \varphi_2(n,m^-)^\prime,
{\tt T}\rightarrow\varphi_2(n,m^-))\]
$\varphi(n)$ is the number of numbers less than $n$ and relatively
prime to $n$.

\subsection{Meshveliani \cite{Mesh16a}}

{\bf Prejudice 1}: ``Proof by contradiction is not possible in
constructive mathematics''

In fact: {\sl it is possible} -- when the relation has a 
{\bf decision algorithm}.

{\bf Example}: In most domains in computer algebra the equality
relation has a decision algorithm \verb|_=?_|. Respecitvely, a program of
the kind.
\[{\rm case\ x\ } =? {\rm\ y\ of\ } \backslash{} 
\{ (yes x\approx y)\rightarrow\ldots;
({\rm\ no\ }x\ne y)\rightarrow\ldots\}\]
actually applies the {\sl excluded third law} to this relation.

{\bf Prejudice 2}: ``Programs in the verified programming tools (like
Coq, Agda) do not provide a proof itself, instead they provide an
algorithm to build a proof witness for each concrete data''.

I claim: {\sl they also provide a proof in its ordinary meaning}
(this is so in Agda, and I expect, the same is with Coq).

\subsection{Myreen \cite{Mimr20}}

Of course, if we want to prove richer properties of programs (or use
programs to prove more interesting formulas), we should use a logic
which is more expressive than propositional logic. In this couse, we
will present {\sl dependent types} which achieve this, while keeping
the proof-as-program correspondence. For instance the euclidean
division, which computes the quotient and remainder of two integers is
usually given the type
\begin{verbatim}
   int -> int -> int * int
\end{verbatim}
stating that it takes two integers as argument and returns a pair of
integer. This typing is very weak, in the sense that there are many
different functions which also have this type. With dependent types,
we will be able to give it the type
\[(m:{\tt int}) \rightarrow (n:{\tt int}) \rightarrow
\sum{(q:({\tt int})}.\sum{(r:({\tt int})}.((m=nq+r)\times (r<n))\]
which can be read as the formula
\[\forall m\in {\tt int}.
\forall n\in {\tt int}.
\exists q\in {\tt int}.
\exists r\in {\tt int}.
((m=nq+r)\land(r<n))\]

\subsection{Myreen \cite{Myre10}}

GCD is used as a benchmark example of a verified JIT Compiler
on p 111.

\subsection{Neuper \cite{Neup13}} 

The case study was motivated by a master's thesis at RISC
Linz, which implemented a CA algorithm for the greatest common divisor
of multivariate polynomials in SML \cite{Mein13}.

\subsection{Nordstr\"om, Petersson, and Smith \cite{Nord90}}

In recent years several formalisms for program construction have been
introduced. One such formalism is the type theory developed by Per
Martin-L\"{o}f. It is well suited as a theory for program construction
since it is possible to express both specifications and programs
within the same formalism. Furthermore, the proof rules can be used to
derive a correct program from a specification as well as to verify
that a given program has a certain property. This book contains an
introduction to type theory as a theory for program construction.

As a programming language, type theory is similar to typed functional
languages such as Hope [18] and ML [44], but a major difference is
that {\bf the evaluation of a well-typed program always terminates}. In
type theory it is also possible to write specifications of programming
tasks as well as to develop provably correct programs. Type theory
is therefore more than a programming language and it should not be
compared with programming languages, but with formalized programming
logics such as LCF and PL/CV.

A proposition is interpreted as a set whose elements represent the
proofs of the proposition. Hence, a false proposition is interpreted
as the empty set and a true proposition as a non-empty set. Chapter 2
contains a detailed explanation of how the logical constants
correspond to sets, thus explaining how a proposition could be
interpreted as a set. A set cannot only be viewed as a proposition; it
is also possible to see a set as a problem description.  This
possibility is important for programming, because if a set can be seen
as a description of a problem, it can, in particular, be used as a
specification of a programming problem. When a set is seen as a
problem, the elements of the set are the possible solutions to the
problem; or similarly if we see the set as a specification, the
elements are the programs that satisfy the specification. Hence, set
membership and program correctness are the same problem in type
theory, and because all programs terminate, correctness means total
correctness

\subsection{O'Donnell \cite{Odon81}}

Several different definitions of the correctness of a system of
reasoning, which are equivalent for the Predicate Calculus, are not
equivalent for the Hoare language.

Consistency refers to the inability of a system to derive an explicit
contradiction, while the stronger notion of soundness says that
everything derived in a system is in some sense true.

Consistency is defined as:
\begin{itemize}
\item Assume that a relation {\bf contradictory($\phi$)} has been
defined on finite sets $\phi$ of formulae in a language so that 
{\bf contradictory($\phi$)} captures the intuitive notion that the formulae
in $\phi$ are explicitly contradictory.
\item A logical system of reasoning is {\bf strongly consistent} if it
is not possible to prove all of the formulae in a set $\phi$ such that
{\bf contradictory($\phi$)}.
\item A logical system of reasoning is {\bf weakly consistent} if it
is not possible to prove a single formula $F$ such that
{\bf contradictory($\phi$)}.
\end{itemize}
Strong consistency certainly implies weak consistency.

In Hoare logics, two formulae $A\{P\}B$ and $C\{Q\}D$ cannot be
combined with a symbol like \&. So weak and strong consistency might
not be equivalent for systems of reasoning in Hoare languages. 

Strong consistency, for some reasonable definition of contradictory,
is intuitively a necessary condition for the correctness of a logical
system, but it is not in general a sufficient condition, since a
system might prove a formula which is false but does not contradict
any other provable formula.

\begin{itemize}
\item A set of formulae $\phi$ {\bf implies} a formula $F$ if $F$ is
true in every world in which all the formulae in $\phi$ are true.
\item A logical system is {\bf theorem sound} if every provable
formula is true
\item A logical system is {\bf inferentially sound} if, for every set
of formulae $\phi$ and every formulae $F$, if $F$ can be proved from
assumptions in $\phi$, the $\phi$ implies $F$.
\end{itemize}
In any system where contradictory formulae cannot all be true, theorem
soundness implies strong consistency. By letting $\phi$ be the empty
set, we see that inferential soundness implies theorem soundness.

ALthough theorem soundness seems at first glance to be enough for an
intuitive claim of correctness, this weaker form of soundness only
justifies the theorems of a system, not the methods of reasoning.

Defintion: A Hoare triple $A\{P\}B$ is a {\bf true partial correctness
formula} if, whenever the program segment P begins execution with
its first command, in a state for which $A$ is true, and $P$
terminates normally by executing its last command, then $B$ is true of
the resulting final state.

The soundness of rules for function definition is a slippery issue
when function bodies fail, since the normal interpretation of the
Predicate Calculus does not allow for partial functions.

Partial correctness reasoning in the Hoare language is very natural
for programs with only conditionals and loops for control structures,
but not for programs with defined functions and/or GoTos. Defined
functions tangle partial correctness and termination together to such
an extent that it is no longer convenient to separate them. Since it
is essential to prove termination anyway, we should use total
correctness logics for reasoning about function definitions.

\subsection{Paulson \cite{Paul96}}

Consider Euclid's Algorithm, which is defined by recursion, for
computing the Greatest Common Divisor (GCD) of two natural numbers:
\begin{verbatim}
   gcd(0,n) = n
   gcd(m,n) = gcd(n mod m,m)       for m > 0
\end{verbatim}

Here it is in Standard ML as a functional program:
\begin{verbatim}
   fun gcd(m,n) = if m=0 then n else gcd(n mod m,m);
\end{verbatim}

\subsection{Sanuki, Inaba, and Sasaki \cite{Sanu15}}

Computation of GCD of Sparse Multivariate Polynomials by Extended
Hensel Construction

    "Let $F(x,u_1,\ldots,u_i)$ be a squarefree multivariate polynomial
    in main variable $x$ and sub-variables $u_1\ldots u_i$. We say
    that the leading coefficient (LC) of $F$ is singular if it
    vanishes at the origin of the sub-variables. A representative
    algorithm for non-sparse multivariate polynomial GCD is the EZ-GCD
    algorithm, which is based on the generalized Hensel construction
    (GHC). In order to apply the GHC easily, we requires 1) the LC of
    $F$ is non-singular, 2) $F(x,0,\ldots,0)$ is squarefree, and 3)
    the initial Hensel factor of GCD is ``lucky''. These requirements
    are usually satisfied by the ``nonzero substitution'', i.e. to
    shift the origin of sub-variables. However, the nonzero
    substitution may cause a drastic increase of the number of terms
    of $F$ if $F$ is sparse. In 1993, Sasaki and Kako proposed the
    extended Hensel construction (EHC) which does not perform the
    nonzero substitution even if the LC is singular. Using the EHC,
    Inaba implemented an algorithm of multivariate polynomial
    factorization and verified that it is very useful for sparse
    polynomials. In this paper, we apply the EHC for the computation
    of GCD of sparse multivariate polynomials. In order to find a
    lucky initial factor, we utilize the weighting of sub-variables,
    etc. Our naive implementation in Maple shows that our algorithm is
    comparable in performance to Maple's GCD routine base on the
    sparse interpolation.",

\subsection{Scott and Strachey \cite{Scot71}}

Monotonic functions on complete lattices always have fixed points.
They even have least fixed points. This makes their use most
convenient for our purposes. Actually the functions we use -- and
which are appropriate to computational theory -- hae an even stronger
property: they are continuous. We shall assume this stronger property
but shall not go into the technical details in this paper. The reader
should only be assured that normal functions are automatically
continuous. 

What does all this theory have to do with the subject of semantics?
Step by step the relevance is this: Commands (programs) are naturally
thought of as defining state transformations. Recursive commands
require partial functions. Solving for these partial functions is just
finding (minimal) fixed points in certain functional equations. In
general the existence of fixed points is justified by a
lattice-theoretic argument. Therefore, if we can see the connection
between lattices and partial functions, the relevance of the theory
will be established.

\subsection{Smolka \cite{Smol89a}} 

details the foundations for relational logic programming
with polymorphically order-sorted data types.

\subsection{Stepanov and McJones \cite{Step09}}

Chapter 5

\subsection{Strub, Pierre Yves}
\begin{verbatim}
Formal Proofs and Decision Procedures  (Strub, Pierre Yves)
htps://www.youtube.com/watch?v=YgOoDNIT8A8
year = "2016"

Prop is a type containing other types
The inhabitants of Prop are proof types or propositions
If A:Prop and B:Prop are proof types then A->B is a proof type (implication)
A proof type is valid if there exists a program of that type
(fun (x:A) => x) is a proof of (A -> A)

Elimination of the \forall connector
   \forall x,P 
   --------
   P{x \mapsto t}
 We want to express a proof of (\forall x,P) by a function taking a t
 and returning a proof of P(t)
 The result type depends on the input
    Dependent typ: type that depends on a value

Arithmetic (P. Cregut)
Real Arithmetic (L Pottier)
First Order Logic (P Corbineau)
Polynomial Systems (B Barras, B Gregoire, A Mahboubi)
External Oracles (N Ayache JC Filliatre)

two terms are computationally equal are considered identical

Fact fact1 A B C : (A -> B -> C) -> (A -> B) -> A -> C
fact1 = fun (A B C : Type) (HABC : A -> B -> C) (HAB : A -> B) (HA : A) =>
HABC HA (HAB HA) : forall A B C : Type, (A -> B -> C) -> (A -> B) -> A -> C

Fact fact2 A B C : (A -> B -> C) -> (A -> B) -> A -> C
fact2 = fun (A B C : Type) (X : A -> B -> C) (X0 : A -> B) (X1 : A) =>
let X2 := X X1 in let X3 := X0 X1 in unkeyed (X2 X3)
  : forall A B C : (A -> B -> C) -> (A -> B) -> A -> C

Fact fact3 (m n:Z) : (1 + 2 * m <> 2 * n)%Z
fact3 - fun (m n : Z) (H : (1 + 2 * M)%Z = (2 * n)%Z) =>
let H0 :=
  fact_Zmult comm 2 m (fun x : Z => (1 + x + - (2 * n))%Z = 0%Z -> False)
   (fast_Zplus_comm 1 (m * 2)
     (fun x : Z => (x + - (2 * n))%Z = 0%Z -> False)
     (fast _Zmult_comm 2 n (fun x :Z => (M * 2 + 1 - x)%Z = 0%Z -> False)
       (fast_Zopp_mult disr r n 2
         (fun x : Z => (m * 2 + 1 + x)%Z = 0%Z -> False)
	 (fast_Zplus_comm (m * 2 + 1) (n * -2)
	   (fun x : Z => x = 0%Z -> False)
	   (fun Omega0 : (n * -2 + (m * 2 + 1))%Z = 0%Z =>
	     let H0 := erefl Gt in
	     (let H1 := erefl Gt in
	      fun auxiliary_1 : (1 > 0)%Z =>
	      OMEGA4 1 2 (n * -1 + (m * 1 + 0)) auxiliary_1 H1
	        (fast_OMEGA11 n (-1) (m * 1 + 0) 1 2
		  (eq^- 0%Z)
		    (fast_OMEGA11 m 1 0 1 2
		      (fun x : Z => (n * (-1 * 2) + x)%Z = 0%Z)

Fact fact4: 2 + 2 = 4
fact4 =
 eq_ind_r (eq^ - 4)
  (eq_ind_r (fun _pattern_value : nat => _pattern_value_.+1 = 4)
      (eq_ind_r (fun _pattern_value : nat => _pattern_value_.+2 = 4) (erefl 4) (addn0 2))
      (addnS 2 0))
  (addnS 2 1) : 2 + 2 = 4

 \forall x,x+0 = x   \forall x y, x+S(y)=S(x+y)

2+2 = 4 is proved by

 |- \forall x,x+S(y)=S(x+y)         |- \forall x,x+S(y)=S(x+y)
 ---------------------        ---------------------
   |- 2+2 = S(2+1)                      |- S(2+1) = S(S(2+0))           |- \forall x,x+0 = x
   -----------------------------------------         ----------------
                              |- 2+2 = S(2+0)                                       |- S(2+0) = 4
			      -------------------------------------------
			              |- 2+2 = 4

Calculus of Construction (Coquand, Huet, 1985)
  \beta convertibility
Calculus of Inductive Construction (Coquand, Paulin, 1990)
  \beta convertibility + recursors for inductive types
Extensional Calculus of Construction (Oury 05)
  \beta + convertible
  "any terms which can be proven equal are convertible"
   (BUT proof checking isn't decidable because convertibility is not decidable)
Coq Modulo Theory (TCS'08, CSL'10, LICS'11) (Strub, Pierre Yves)
  add decision procedure to conversion rule
Calculus of Presburger Constructions
  \beta conversions (function evaluation)
  recursor for natural numbers (def. by induction of functions and types)
  a decision procedure for Presburger arithmetic in its conversion
  an extraction from the proof environment of arithmtic equations
  whose proof checking is decidable

    \Gamma |- t:T   \Gamma |- T':s'   T ~r T'
    --------------------------------
           \Gamma |- t:T'

   where ~r will include
     \beta-convertibility (function evaluation)
     recursor for natural numbers (fixpoint+match evaluation)
     validity entailment of the Presburger arithmetic
         At least, the conversion must consider equal
	 any pair of Presburger-equal algebraic terms
	   Algebraic terms are all terms built from 0, S,+ and variables with the right arity
	   This solves our motivation examples
	       list n + m ~ list m + n
	   because n + m and m + n are algebraic and P-equal
	   BUT this does not define a sound logic
	   


\end{verbatim}

\subsection{Sutor \cite{Suto87}} 

Type inference and coercion in Scratchpad II.

\subsection{Tsuji \cite{Tsuj09}}

An Improved EZ-GCD Algorithm for Multivariate Polynomials

    "The EZ-GCD algorithm often has a bad-zero problem, which has a
    remarkable influence on polynomials with higher-degree terms. In
    this paper, by applying special ideals, the EZ-GCD algorithm for
    sparse polynomials is improved. This improved algorithm greatly
    reduces computational complexity because of the sparseness of
    polynomials. The author expects that the use of these ideals will
    be useful as a resolution for obtaining a GCD of sparse
    multivariate polynomials with higher-degree terms.",


\subsection{Wang \cite{Wang80}}

The EEZ-GCD algorithm

   "An enhanced gcd algorithm based on the EX-GCD algorithm is
    described. Implementational aspects are emphasized. It is
    generally faster and is particularly suited for computing gcd of
    sparse multivariate polynomials. The EEZ-GCD algorithm is
    characterized by the following features:
    \begin{enumerate}
    \item avoiding unlucky evaluations,
    \item predetermining the correct leading coefficient of the
    desired gcd,
    \item using the sparsity of the given polynomials to determine
    terms in the gcd and
    \item direct methods for dealing with the ``common divisor problem.''
    \end{enumerate}
    The common divisor problem occurs when the gcd has a different
    common divisor with each of the cofactors. The EZ-GCD algorithm
    does a square-free decomposition in this case. It can be avoided
    resulting in increased speed. One method is to use parallel p-adic
    construction of more than two factors. Machine examples with
    timing data are included.",

\subsection{Watt \cite{Watt85a}}

Watt has a Survey of GCD Algorithms.

\subsection{Wijngaarden \cite[Section 6, p95]{Wijn68}}

ALGOL 68 has carefully defined rules for coercion, using dereferencing, deproceduring,
widening, rowing, uniting, and voiding to transform values to the type required
for further computation. 

\appendix

\chapter{Untyped Lambda in Common Lisp}
See Garret \cite{Garr14}

This is a compiler for the untyped lambda calculus.
\begin{chunk}{lambda}
(defmacro ulambda (args body)
  (if (and args (atom args)) (setf args (list args)))
  (if (and (consp body) (consp (car body))) (push 'funcall body))
  (if (null args)
    body
    `(lambda (&rest args1)
  (let ((,(first args) (first args1)))
    (declare (ignorable ,(first args)))
    (flet ((,(first args) (&rest args2) (apply ,(first args) args2)))
      (if (rest args1)
        (apply (ulambda ,(rest args) ,body) (rest args1))
        (ulambda ,(rest args) ,body)))))))

\end{chunk}

The factorial function.
\begin{chunk}{factorial}
(ulambda (n f) 
  (n (ulambda (c i)
       (i (c (ulambda (f x)
               (i f (f x))))))
     (ulambda x f)
     (ulambda x x)))

\end{chunk}

The factorial of 10. factorial of 3, add 4, compute factorial of that.
\begin{chunk}(factorial10}
(ulambda ()
  ((ulambda (f s) (f (s (s (s (s (f (s (s (s (ulambda (f x) x)))))))))))
   (ulambda (n f) (n (ulambda (c i) (i (c (ulambda (f x) (i f (f x))))))
                   (ulambda x f) (ulambda x x)))
   (ulambda (n f x) ((n f) (f x)))
   '1+ 0))

\end{chunk}

\subsection{Weber \cite{Webe95a}}

Since the greatest common divisor (GCD) of two integers is a
basic arithmetic operation, used in many mathematical software
systems, new algorithsm for its computation are of widespread
interest. The accelerated integer GCD algorithm discussed here is
based on a reduction step proposed by Sorenson (k-ary reduction),
coupled with the dmod operation similar to Norton's smod. Some
practical limitations of Sorenson's reduction have been
eliminated. Worst-case complexity is still $O(n^2)$ for $n$-bit
input, but actual implementations given input about 4000 bits long
perform over 5.5 times as fast as the binary GCD on one computer
architecture having a multiply instruction. Independent research
by Jebelean points to the same conclusion. 

\subsection{LeanProver}

On the LeanProver chat \cite{Lean19}, agro1986 wrote:

\begin{flalign*}
{\tt variables}~\{a~b~c~d:~\mathbb{Z}\}&&
\end{flalign*}

\noindent
${\tt def}~{\tt divides}~(a~b:~\mathbb{Z}):~{\tt Prop}~:=
~\exists(d:~\mathbb{Z}),~b~=~a~*~d$\\

\noindent
${\tt def}~{\tt gcd}~(a~b~d:~\mathbb{Z}):~{\tt Prop}~:=$\\
\hspace*{0.2cm} $\lnot(a~=~0~\land~b~=~0)~\land$\\
\hspace*{0.2cm} ${\tt divides}~d~a~\land$\\
\hspace*{0.2cm} ${\tt divides}~d~b~\land$\\
\hspace*{0.2cm} $\forall~(c:~\mathbb{Z}),~{\tt divides}~c~a~\land
~~{\tt divides}~c~b\rightarrow c~\le~d$

\noindent
${\tt theorem}~{\tt gcd\_sym}~(h:~{\tt gcd}~a~b~d):~{\tt gcd}~b~a~d~:=$\\
\hspace*{0.2cm}${\tt begin}$\\
\hspace*{0.4cm}${\tt let\ hnonzero\ }:={\tt \ h.left},
\quad\qquad\qquad -- \lnot(a~=~0~\land~b~=~0)$\\
\hspace*{0.4cm}${\tt let\ hda\ }:={\tt \ h.right.left},
\quad\qquad\qquad -- {\tt divides\ }d~a~\land$\\
\hspace*{0.4cm}${\tt let\ hdb\ }:={\tt \ h.right.right.left},
\qquad -- {\tt divides\ }d~b~\land$\\
\hspace*{0.4cm}${\tt let\ }{\tt hgreatest\ }:={\tt \ h.right.right.right},$\\
\hspace*{0.4cm}${\tt apply\ and.intro},$\\
\hspace*{0.6cm}${\tt exact\ }({\tt assume\ hzero}:~b~=~0~\land~a~=~0,$\\
\hspace*{0.8cm}${\tt hnonzero\ (hzero.right,\ hzero.left))},$\\
\hspace*{0.4cm}${\tt apply\ and.intro},$\\
\hspace*{0.6cm}${\tt assumption},$\\
\hspace*{0.4cm}${\tt apply\ and.intro},$\\
\hspace*{0.6cm}${\tt assumption},$\\
\hspace*{0.4cm}${\tt assume\ c},$\\
\hspace*{0.6cm}${\tt let\ hc\_lt\_d\ (hc\_divides.right,
\ hc\_divides.left)}$\\
${\tt end}$

Kevin Buzzard replied with a {\bf tactics mode} proof:

\noindent
${\tt theorem}~{\tt gcd\_sym}~(h:~{\tt gcd}~a~b~d):~{\tt gcd}~b~a~d~:=$\\
\hspace*{0.2cm}${\tt begin}$\\
\hspace*{0.4cm}${\tt rcases\ h\ with\ (hne0,\ hda,\ hdb,\ hdmin),}$\\
\hspace*{0.4cm}${\tt split,\ exact\ mt\ and.comm.mp\ hne0,}$\\
\hspace*{0.4cm}${\tt split,\ assumption,}$\\
\hspace*{0.4cm}${\tt split,\ assumption,}$\\
\hspace*{0.4cm}${\tt rintros\ }c{\tt \ (ha,\ hb)},$\\
\hspace*{0.4cm}${\tt exact\ hdmin\ }c{\tt \ (hb,\ ha)}$\\
${\tt end}$

and here's a {\bf term proof}

\noindent
${\tt theorem}~{\tt gcd\_sym}~(h:~{\tt gcd}~a~b~d):~{\tt gcd}~b~a~d~:=$\\
${\tt (mt\ and.comm.mp\ h.1,\ h.2.2.1,\ h.2.1,\ }\lambda~c~{\tt hc},
{\tt \ h.2.2.2\ \_\ (hc.2\ hc.1))}$\\

Reid Barton says a better definition would conclude

\noindent
$\forall~(c:~\mathbb{Z}),{\tt \ divides\ }c~a~\land~
{\tt \ divides\ }c~b~\rightarrow
{\tt \ divides\ }c~d$

Then assume $d\ge 0$. You don't need the
$\lnot(a~=~0~\land~b~=~0)$ part.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{axiom}
\bibliography{axiom}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cleardoublepage
\phantomsection
%\addcontentsline{toc}{chapter}{Index}
\printindex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}

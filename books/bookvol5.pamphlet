\documentclass[dvips]{book}
\newcommand{\VolumeName}{Volume 5: Axiom Interpreter}
\input{bookheader.tex}
\pagenumbering{arabic}
\mainmatter
\setcounter{chapter}{0} % Chapter 1

\chapter{Type Inference and Coercion}
\section{Introduction}

The Axiom system is centered on a strongly typed abstract datatype
programming language with multiple inheritance. The compiler for this
language produces a library of packages of polynomorpic functions and
parameterized abstract datatypes. The system interpreter provides an
interface to the compiler and library and supports a subset of the
Axiom language. The design of the interpreter includes extensive
datatype inferences and coercion facilities to ease the burden of
working with a strongly typed language and a library containing over
1100 Categories, Domains, and Packages.

The Axiom interpreter is unusual because 
\begin{itemize}
\item Axiom has an infinite number of datatypes and packages
\item each generic operation generally has an infinite number of
interpretations
\item datatypes and packages are instantiated dynamically in response
to user input, and
\item operation interpretation is done by pattern matching on modemaps.
\end{itemize}

The design philosophy is that the interpreter language equals the
compiler language minus the constraints. 

This means that declarations are largely optional and that automatic
datatype conversions may take place when they are deemed appropriate.

In Axiom we use the term {\sl conversion} to mean the transformation
an object of one datatype into an object of another datatype. A special
kind of conversion is {\sl coercion}, where we further require that
transformation is reasonable (usually in an algebraic or 
non-information-losing sense). Examples of coercions involve changing
integers into rational numbers, rational numbers into (constant)
polynomials with rational number coefficients, lists of lists into
two dimensional arrays, etc.

Conversion is done through two operations, {\bf coerce} and {\bf
convert} which are otherwise ordinary operations exported by the
abstract datatypes of the system. The interpreter is allowed to
perform conversions named {\bf coerce} whenever it determines they are
necessary. Most coercions are reversible and their application does
not lose information. An example of a conversion that is not a
coercion is the transformation of a rational number into a floating
point number. Having an automatic conversion from an exact to an
inexact object is not acceptable.

All atomic expressions (as produced by the parser) have default
datatypes. These are {\bf Boolean}, {\bf Float}, {\bf Integer}, 
{\bf String}, {\bf Symbol}, and {\bf List(None)} (for an empty list). If
these are assigned in declared variables or used as arguments to
functions, coercions are often performed to create objects of other
datatypes.

Coercion is combined with the {\sl type resolve facility} to
determine the result datatype of an expression presented to the
interpreter. Datatypes {\bf T1} and {\bf T2} {\sl resolve} to a
datatype {\bf T3} if all objects belonging to {\bf T1} and {\bf T2}
can be coerced to {\bf T3}. In Axiom, the resolve facility is driven
by a rule system, by information about coercions, and by the structure
of the datatypes involved.

\section{Overview of the Abstract Datatype System}

It is not within the scope of this chapter to fully discuss the Axiom
abstract datatype system. This section is an overview of those terms
and concepts needed to describe the implemention of the interpreter. 
Other sources are available that contain more detailed discussions. 
\cite{Jenk81}\cite{Lisk79}\cite{Fort85}\cite{Swee86}
\cite{Jenk86}\cite{Watt87}

The Axiom library consists of compiled code that creates
``categories'', ``domains'', and ``packages''. A {\sl domain} is a
datatype, a {\sl package} is a collection of functions, and a 
{\sl category} is a collection of operation signatures and attributes, as
shown below. These are created by special functions called 
{\sl constructors}, which are generally parameterized.

Domains and packages implement the functions in categories. Categories
serve to separate the contract from the implementation. However,
default implementations can be given in categories by assuming the
existence of other implemented operations. For example, a default
implementation of binary ``-" can be given by using unary ``-'' and
binary ``+"".

\subsection{Categories}

A domain is an instance of an abstract datatype specified by one or
more categories. Categories serve to group together domains with
common properties (e.g. operations). A basic category in Axiom is {\bf
Set} which has the definition:
\begin{verbatim}
   Set(): Category == with
     "=" : ($,$) -> Boolean
     coerce : $  -> Expression
\end{verbatim}

The syntax means the following. {\bf Set} is a category constructor
having no parameters. Lines 2 and 3 of the definition present {\sl
signatures} for the two operations that are exported by {\bf Set}:
an operation ``$=$'' that takes 2 elements of the set and returns a
{\bf Boolean}, and an operation {\bf coerce} that takes an element 
of the set and returns a printable representation of it. The symbol
``\$'' refers to the set itself. All domains which belong to {\bf Set}
contain ``$=$'' and {\bf coerce} among their operations (though it is
possible that they are not implemented).

Categories may be extended. A semigroup is a set that has an
associative multiplication operation. Given such a mulitplication, it
is easy to define an exponentiation by positive integers 
($x**1=x$, $x**2=x*x$, $x**3=x*x**2$,\ldots). The definition of the
{\bf SemiGroup} constructor in Axiom is
\begin{verbatim}
   SemiGroup(): Category == Set with
     "*" : ($,$) -> $
     "**" : ($, PositiveInteger) => $
     associate("*")
\end{verbatim}

The last line of this definition presents an {\sl attribute} declaring
that multiplication is associative. Attributes declare properties of
the operations or the datatype.

As an example, {\bf Integer} belongs to {\sl SemiGroup} which means 
that it should have everything from {\bf Set} plus the listed
mutiplication and exponentiation operators. Multiplication is 
asserted to be associative and so this may be assumed for {\bf Integer}.
If a category {\bf C2} extends a category {\bf C1}, any domain that
belongs to {\bf C2} also belongs to {\bf C1}.

Categories may be parameterized.
\begin{verbatim}
   ListCategory(S: Set): Category == Set with
     first : $ -> $
     rest :  $ -> $
     null :  $ -> Boolean
     . . .
\end{verbatim}
presumably describes the operations and attributes that any abstract
datatype that purports to act like a linked list should have. The
parameter {\bf S} can be any domain that belongs to {\bf Set}. If
we defined a special version of this
\begin{verbatim}
   SemiGroupListCategory(S: SemiGroup): Category == Set
     with
       first : $ -> $
       rest :  $ -> $
       null :  $ -> Boolean
       . . .
\end{verbatim}
then {\bf S} must have been explicitly declared to belong to 
{\bf SemiGroup}. Category membership is by name: a domain having the
operations and attributes of {\bf SemiGroup} does not belong to this
category unless it has been explicitly declared to belong to 
{\bf SemiGroup} or one of its extensions.

Categories allow multiple inheritance.
\begin{verbatim}
   FiniteList(S: Set): Category ==
     Join(Finite, ListCategory(S))
\end{verbatim}
defines a category constructor that contains all operation signatures
and attributes from both the categories {\bf Finite} and
{\bf ListCategory(S)}.

\subsection{Domains}

Domains are created by domain constructors and are objects. They
provide a representation for an instance of an abstract datatype,
implement the operations of the categories to which they belong, and
presumably satisfy the attributes of the categories. The
representation of a domain does not depend at all on the categories to
which the domain belongs.

In the implementation of {\bf Integer}, the following category definition
is given and specifies the behavior of the domain:
\begin{verbatim}
   Integer(): Join(UniqueFactorizationDomain,
     EuclideanDomain, OrderedRing, DifferentialRing)
       with
         oddp : $ -> Boolean
         random : () -> $
         numberOfDigits : ($,$) -> $
         abs : $ -> $
         canonicalUnitNormal
\end{verbatim}

The category of {\bf Integer} is not one named category but, instead,
is composed of several pieces. The full category is that obtained by
joining 4 named categories, 4 additional operations, and 1 additional
attribute. Note, though, that {\bf Integer} belongs to each of the 4
named categories, {\sl plus} their ancestors. In particular, 
{\bf Integer} is a {\bf SemiGroup} because it is a {\bf DifferentialRing},
which is a {\bf Ring}, which is a {\bf SemiGroup}. In fact, the 
{\bf Join} creates several paths back to the category {\bf SemiGroup}. 
{\bf Integer} may be used anywhere a {\bf SemiGroup} is required.

Domains may provide functions for objects other than those which they
create. For example, {\bf RationalNumber} implements a ``$/$'' for
two {\bf Integer} arguments.

Two domain constructors that are particularly useful in representing
other domains are {\bf Record} and {\bf Union}. A record is similar to
structures of the same name in many other languages: it has one or
more fields accessed via selector names. The objects in the fields can
be of any datatype. The construtor {\bf Union} creates 
{\sl discriminated} unions: an object of {\bf Union(Integer,String)}
belongs either to the {\bf Integer} branch or the {\bf String} branch
of the union. The {\bf case} function is used to test for membership
in branches.

The constructor {\bf Mapping} creates the datatypes of functions.
Declaring {\bf oddp : Mapping(Boolean,Integer)} states that {\bf oddp}
is a function taking one integer argument and returning a boolean.
A convenient alternative notation for this is 
{\bf oddp:~Integer~$\rightarrow$~Boolean}. Functions are first-class
objects and can be passed to other functions.

The Axiom language design completely separates the concrete 
implementation inheritance from the abstract specification inheritance.
Domains can inherit implementations from their representations, but
the external view of them is only determined by the categories to
which they belong. The idea of {\sl subtype} in languages such
Trellis/Owl\footnote{Trellis is a trademark of Digital Equipment
Corporation} \cite{Scha86} is replaced in Axiom by the two notions of category
and domain.

In addition to providing an organizational hierarchy, categories allow
Axiom to have extra information about domains. Thus, for example, the
compiler knows where operations will be located in domains and can
compile efficient function calls. This information is part of a
structure associated with each operation called a {\sl modemap}.

\subsection{Packages}

A package is a special kind of domain in that it provides no new
objects to the system (other than the package itself). It consists of
a category listing operations and attributes and implementations of
the operations. Because they may be parameterized, packages can be
used to implement algorithms at their most natural level of
abstraction. For example, a repeating-squaring algorithm may be
contained in a package that is parameterized by a domain that is a
{\bf SemiGroup}.

Packages provide an excellent vehicle to implement both
domain-specific and category-general algorithms. They can be used to
implement algorithms that are not included in other domains for
reasons of convenience or necessity. For example, the repeated squaring
algorithm and the integration algorithms are implemented in
packages. They also require extra work by the interpreter because
argument datatypes give no simple clue to the possible location of a
package function. For example, in the expression $2+9$ the operation
``$+$'' is found in the domain {\bf Integer}, which is the common
datatype of the two arguments. However, the function {\bf solve} in
{\tt solve(x**3-1,x)} is not present in either the domain 
{\bf Polynomial(Integer)} of the first argument or the domain {\bf Symbol}
of the second. This, along with the last example of the previous
section, demonstrates the need for a systematic search mechanism of
the Axiom library.

\subsection{Modemaps}

A {\sl modemap} is a syntactic specification of an operation. It gives
the name of the operation, source and target datatypes for its
parameters, and the name of the datatype or package exporting the
operation. For example, the modemap
\begin{verbatim}
   oddp : Integer -> Boolean from Integer
\end{verbatim}
specifies an operation from type {\sl Integer} which takes an integer
argument and returns a boolean value. The ``from''-clause indicates
the {\sl domain of implementation} of the operation (in this case,
{\bf Integer}).

When the datatype or package is parameterized, the conditions on their
parameters appear in an ``if''-clause for the modemap. For example,
every domain created by domain constructor {\bf Matrix} exports a
trace operation:
\begin{verbatim}
   trace: Matrix(R) -> $ if R has Ring from Matrix(R)
\end{verbatim}

The domain constructor {\bf Matrix} takes one parameter {\bf R}
which is required to belong to the category {\bf Ring}.

Operations may also be conditionally exported by a domain constructor.
For example, domains created by {\bf Matrix} export a {\sl {\bf determinant}}
operation only if the homogeneous multiplication ``*'' in the underlying
domain is commutative, that is, {\bf R} has {\sl {\bf commutative("*")}}.
The modemap for {\sl {\bf determinant}} is
\begin{verbatim}
   determinant: Matrix(R) -> $ if R has Ring
     and R has commutative("*") from Matrix(R)
\end{verbatim}

Similarly, datatypes creaated by {\bf Matrix} export an {\sl {\bf inverse}}
operation only if their argument domain belongs to {\bf Field}. Since
the requirement ``{\bf R} has {\bf Field}'' implies
``{\bf R} has {\bf Ring}'' the modemap for {\sl {\bf inverse}} is
\begin{verbatim}
   inverse: Matrix(R) -> Union(R,"failed")
      if R has Field from Matrix(R)
\end{verbatim}

The collection of modemaps from all abstract datatypes and packages
constitutes the {\sl global modemap database} for Axiom. To standardize
the presentation of modemaps, arguments and other parameters are 
prefaced by ``pattern variables'', here called {\bf *1}, {\bf *2}, etc.
The resulting form of the modemap for {\bf Matrix} {\sl {\bf inverse}}
in the modemap database is, for example,
\begin{verbatim}
   inverse: *1 -> Union(*1,"failed")
      if *1 is Matrix(*2) and *2 has Field from *1
\end{verbatim}

In addition to this general modemap database, each domain or package has
a {\sl local modemap database} for all its exported operations. Note
that the pattern variables and ``if''-clauses of the above global
modemaps depend on the parameters to a domain or package constructor.
For a domain or package itself, all parameters to the constructor are
known. Thus local modemaps have no patterns. Predicates reduce to
{\sl true} or {\sl false}. All modemaps in a local modemap database 
for a domain or package {\bf D} therefore have the general form
\begin{verbatim}
   f: S -> T if true from D
\end{verbatim}

Those having a predicate of {\tt false} simply do not exist for a
given domain or package. For example, {\bf Matrix(RationalNumber)}
will have an {\sl {\bf inverse}} operation whereas {\bf Matrix(Integer)}
will not, since {\bf RationalNumber} is a field but {\bf Integer} is not.

\subsection{Interpretation}

The role of the interpreter is to evaluate input expressions entered
by the user. In addition to computations, these expressions may be
declarations, function definitions, or system commands. A value in Axiom
is described by a pair $<a$,A$>$ where $a$ is an object and A is its type.

Evaluation of an operator-operand expression $f(x,y,\ldots)$,
with $n$ $(n > 1)$ arguments $x,y,\ldots$, is done in a bottom-up
manner. The interpreter will evaluate the arguments to produce a 
corresponding $n$-tuple of argument values $<a$,A$>$, $<b$,B$>$,
$\ldots$. At this point an attempt will be made to select an
applicable modemap for $f$. If this modemap has a return type of {\bf T},
$f$ is applied to the (possibly coerced) arguments to yield a result $t$
and subsequent value pair $<t$,T$>$.

\subsection{Modemap Selection}

Given a function call $f(x,y,\ldots)$ and evaluated arguments $<a$,A$>$,
$<b$,B$>$, $\ldots$ as in the previous section, the interpreter 
tries to find an appropriate $f$ to apply. The first attempt involves
constructing a list of the domains A, B, ... of the evaluated arguments,
plus the target type of the function call, if it exists,\footnote{
As an example of a target type, consider the expression 
{\tt m:Matrix(Integer):=f(x,y,z)}. The target type of the function
call is {\tt Matrix(Integer)}.}
plus those types contained in any of the argument types if they are
constructed from {\bf Record}, {\bf Union}, or {\bf Mapping}. Duplicates
are removed from the list and domains and packages in the list are
searched for an applicable $f$. If a modemap is found of the form
\begin{verbatim}
   f: (A,B,...) -> T from C
\end{verbatim}
with arity $n$, for some {\bf T} and {\bf C}, the function is gotten
from {\bf C} and applied to $a,b,\ldots$ to yield a result {\sl t}
and subsequent value pair $<t$,T$>$.

This kind of search for an applicable $f$ generalizes the idea of a 
{\sl controlling object} in a function call \cite{Lisk79}\cite{Scha86}. 
In Axiom, though,
the arguments in a function call need not give any hint to the actual
location of the function to be applied. If there is no applicable 
modemap to be found among the argument domains of a function, a two-stage
search for a suitable modemap is made in the global modemap database. A
set $M$ of candidate modemaps is constructed, each of the form:
\begin{verbatim}
   f:(D,E,...) -> T if p from C
\end{verbatim}
for some result type {\bf T} and domain of implementation {\bf C},
each of arity $n$ and each generally containing pattern variables and
predicates $p$. The set $M$ is partitioned into two subsets: those
modemaps coming from domains or packages whose names contain those of
any of the arguments of the function, and those that do not. The
modemaps in the first subset are examined for applicability and, if
one is found, it is returned. Otherwise, those in the second subset
are checked for applicability.

At first this partitioning may seem odd, but it reflects a naming
convention for domains and packages in the Axiom library. As an 
example, the constructor {\bf ListPackage1} takes one {\bf Set}
argument and implements several functions that could be but are not
now implemented in the {\bf List} domain. The constructor
{\bf ListPackage2} takes two domain arguments, each belonging to the
category {\bf Set}. The functions in this package implement operations
that requires lists with two different element types. For example,
the function
\begin{verbatim}
   map: (S -> T, List(S)) -> List(T)
\end{verbatim}
which maps a function from {\bf S} to {\bf T} across the elements
of {\bf List(S)}, producing an object of {\bf List(T)}, is implemented
in {\bf ListPackage2(S,T)}. Looking at the modemaps in the first
partition of $M$ reflects an extension of the search method that
looks for applicable functions in the domains of the function 
arguments. In the future we anticipate using attributes in such
associated packages to determine the first subset of the general
candidate modemaps. That is, {\bf ListPackage2} will contain the
attribute {\bf associated("List")} in its category.

For our purposes here, it suffices to regard the predicate of a
modemap as a conjunction of simple predicates of two kinds:
\begin{verbatim}
   X is Y
   X has Y
\end{verbatim}

Predicates of the first kinds state that pattern $X$ matches
only the explicit domain {\tt Y}. If a modemap only has predicates
of the first kind, patterns are replaced by the domain or package
names to produce a new modemap free of patterns.

When the modemap has predicates of the second kind, substitutions
are sought for the pattern variables such that the predicate is
satisfied. Here {\tt Y} is a category or an attribute. Pattern
variables are given initial substitutions based on the value pairs
of the arguments. Any pattern variable $X$ for which there is a 
predicate ``$X$ is {\tt Y}'' has {\tt Y} assigned as a {\sl permanent}
substitution. Other substitutions are labeled {\sl tentative}. To
satisfy the predicate, any or all the operations of {\sl coercing},
{\sl resolving}, and {\sl forcing} (see below) may be necessary. As
above, if pattern variable $X$ has permanent substitution {\tt Y},
any argument value of $f$ of type {\bf Z} must be coerced to type {\tt Y}.

The {\sl resolve} of two types {\bf T1} and {\bf T2} will always succeed.
It produces a third type {\bf T3} to which all objects of type {\bf T1}
and {\bf T2} can be coerced. The type {\bf Any} is used for {\bf T3}
if a less general type cannot be found. Resolving is necessary to use 
a modemap with homogeneous arguments. For example, the modemap
\begin{verbatim}
   "+":(*1,*1) -> *1 if *1 has AbelianMonoid from *1
\end{verbatim}
is used for addition in most algebraic domains in Axiom. Given an
expression $1+(2/3)$, a bottom-up analysis will first produce
$<$1,Integer$>$ and $<$2/3,RationalNumber$>$ as the values of the
two operands of ``$+$''. The resolve of {\bf Integer} and
{\bf RationalNumber} is defined to be {\bf RationalNumber}. This
causes the integer object $1$ to be coerced to the rational number
object $1/1$. {\bf RationalNumber} now matches *1 in the above
modemap, the predicate evaluates to true, and the corresponding
function is gotten from {\bf RationalNumber} and applied to produce
the result $5/3$ and pair $<$5/3,RationalNumber$>$.

A {\sl force} is an operation performed on one or more types to satisfy
a predicate. For example, the predicate ``*1 has {\bf Field}'' where
*1 has a tentative substitution {\bf Integer} results in the forcing
of {\bf Integer} to {\bf RationalNumber} by the application of
{\bf QuotientField}, i.e. {\bf QuotientField(Integer)} is equivalent
to {\bf RationalNumber}. As another example, $x$ has default type
{\bf Symbol}. When appearing in a sum (e.g. $x+1$), the modemap of $x$
requires its argument to be from a domain which belongs to the category
{\bf AbelianMonoid}. As a result, {\bf Symbol} is forced to 
{\bf Polynomial(Integer)}.

A list of all applicable modemaps is produced together with a list of
required coercions on the source parameters. Duplicates and modemaps
subsumed by others are discarded. Each modemap is assigned a cost based
on the required coercions and the target type of the operation. By
definition of the cost function, any modemap which directly matches
the argument types (e.g. {\bf A=D}, {B=E}, etc.) will have the 
cheapest cost.

\subsection{Ambiguity}

Two remaining modemaps are said to be {\sl ambiguous} unless there are
coercions to and from the respective substitution datatypes for the
pattern variables *1,*2,... . If there are no ambiguities, the cheapest
modemap is selected and applied.

As a practical matter, users can always use a ``package call'' to avoid
ambiguities, e.g. {\tt x *\$D y} and {\tt foo\$D(x,y)} direct the
interpreter to apply the functions ``*'' and {\sl foo} from the 
domain or package {\bf D}. Package calling is the only way to identify
uniquely functions of no arguments if they are ambiguous.

\subsection{Modes}

If the explicit conversion {\tt p::P} or {\tt p::P(?)} is given, 
{\tt p} is converted to a polynomial. The datatype of coefficients
may be any domain which satisfies the categorical requirements of the
argument to the domain constructor {\tt Polynomial}. The form {\tt P(?)}
is a {\sl mode} specification rather than a {\sl type} specification: 
the interpreter is free to choose what replaces the {\tt ?}.

A mode is a partial type specification in that zero or more arguments
in a domain constructor call are replaced by {\tt ?}. The process
of {\sl merging} takes a type {\bf T1} and a mode {\bf M} and
determines type substitutions for the {\tt ?}'s in {\bf M} to 
create a new type {\bf T2} to which {\bf T1} is coercable. For example,
the merger of {\bf RationalNumber} and {\bf Polynomial(?)} is
{\bf Polynomial{RationalNumber}}. If the mode {\bf M} has no {\tt ?}'s,
it is a type and the merger will only succeed if {\bf T1} is coercable
to {\bf M}. Thus merging a type and a mode may fail, unlike resolving
two types. If {\bf M} is simply {\tt ?}, then the result of the merger
is {\bf T1}.

Axiom now only supports modes with at most one {\tt ?}, and that
must be in the innermost constructor call position (e.g.
{\bf List(Polynomial(?))}. In our experience, this restriction has
not seemed burdensome, though a future area of research might be the
extension of the merging process to more general modes.

\section{The Coerce Facility}

Our goal in the design of the coerce facility is to have as much as
possible controlled by modemap selection of compiled Axiom
functions. This allows the domain and package writer maximum control
over the behaviour of the interpreter and removes the requirement of
having a system developer tune the interpreter for dealing with new
datatypes. The coerce facility has several components.

\subsection{Coerce by Function}

The interpreter does modemap selection for an operation named
{\sl {\bf coerce}} that has the appropriate argument and target
types. This is the easist way for a programmer to control the
coerce facility. For example, the category {\bf Ring} provides
a modemap
\begin{verbatim}
   coerce: Integer -> R from R
\end{verbatim}
where {\bf R} is the ring being defined. Thus any ring has a coercion
from {\bf Integer} and, in fact, this operation has a default 
categorical definition.

Coercions can sometimes be defined in domains but are often defined in
packages. A coercion of the form
\begin{verbatim}
   coerce: Polynomial(QuotientField(R)) ->
     QuotientField(Polynomial(R))
       if R has IntegralDomain
\end{verbatim}
would typically be defined in a package parameterized by the domain
{\bf R}. On the other hand, it is not feasible to have so many 
explicit coercions being written and, in fact, there are general
methods that will perform these kinds of coercions.

It is not now possible to define a coercion of the form
\begin{verbatim}
   coerce: List(S) -> List(T)
\end{verbatim}
in the domain constructor {\bf List}. This is because {\bf List} is
parameterized by only one set ({\bf S} or {\bf T}) and the modemap
cannot, therefore, be part of the category of {\bf List}. Such an
explicit coercion can be provided in a package, but is, in fact,
handled by the general mechanism described in the next section.

\subsection{Coerce by Mapping}

When the interpreter encounters a coercion of the form
\begin{verbatim}
   D(T1) -> D(T2)
\end{verbatim}
where {\bf D} is a domain constructor with a parameter (for reasons
of exposition, we here omit the case of {\bf D} having multiple
parameters), it looks for a function
\begin{verbatim}
   map: (T1 -> T2, D(T1)) -> D(T2)
\end{verbatim}
that takes a function from {\bf T1} to {\bf T2} and an object of
{\bf D(T1)} and produces an object of {\bf D(T2)}. It then creates
a function stub that coerces objects of {\bf T1} to those of {\bf T2}
and passes it to {\sl {\bf map}}, along with the original argument.

Since the function {\sl {\bf map}} is part of the library of Axiom
compiled code, it allows the package writer to automatically provide
an interpreter mechanism of ``lifting'' coercions from {\bf T1} to
{\bf T1} to {\bf D(T1)} and {\bf D(T2)}.

\subsection{Coerce by Internal System Code}

Some special cases of coercions are handled by internal system code
rather than compiled Axiom code. These typically involve polynomials
where the variable ordering is changed or distributed across a tower
of parameterized domains. It will eventually be moved into Axiom code
as the pattern matching facilities are improved.

Another case that is now handled internally involves rearrangement
of a tower of paramterized domains. The domain constructor {\bf Gaussian}
creates domains with objects similar to the complex numbers in that they
contain real and imaginary parts. The coercion
\begin{verbatim}
   Gaussian(Polynomial(RationalNumber)) ->
      QuotientField(Polynomial(Gaussian(Integer)))
\end{verbatim}
is performed in the following steps. The type {\bf RationalNumber}
is changed into the equivalent type {\bf QuotientField(Integer)} and
the {\bf QuotientField} is bubbled to the top of the original type to
get {\bf QuotientField(Gaussian(Polynomial(Integer)))}. This new type
and the old target now have the same top level constructor 
({\bf QuotientField}) and the coerce facility is called recursively
on the underlying domains {\bf Gaussian(Polynomial(Integer))} and
{\bf Polynomial(Gaussian(Integer))}.

\subsection{Coercion of Algebraic Constants}

Several categories specify the existence of constants. For example,
{\bf AbelianMonoid} specifies the operation ``$+$'':\$ $\rightarrow$ \$'' and
the constant $0:\$$. If {\bf T1} and {\bf T2} each belong to a common
category with specified constants and the object of {\bf T1} to be
coerced is one of the constants, the corresponding constant in {\bf T2}
may be extacted and returned.

\subsection{Retraction}

A retraction is a coercion of an object of a domain to a more specific
(degenerate) domain. Unlike other forms of coercion where the target
type is known, retraction involves examining an operand pair $<t$,T$>$
to see if there exists a degenerate form of {\bf T} to which $t$ can
be coerced. For example, $<$7/1,RationalNumber$>$ retracts to 
$<$7,Integer$>$ and $<$1,Polynomial(Integer)$>$ retracts to $<$1,Integer$>$.
Retraction can occur multiple times, so arbitrarily long sructures collapse
to their simplest forms, e.g. $<$1,Polynomial(RationalNumber)$>$ to 
$<$1,Integer$>$.

If no applicable modemap is found in modemap selection, retraction is
done on the arguments and then selection is attempted again. Retraction
is also attempted when a coercion is requested from a domain to its
underlying domain. For example, if {\tt p} is an element of
{\bf Polynomial(Integer)}, the statement {\tt p::I} will cause the
interpreter to try to retract {\tt p} to an element of {\bf Integer}.

For the most part, retraction can be accomplished by functions in the
Axiom library. The category {\bf RetractWithUnderDomain(R)} specifies
two operations
\begin{verbatim}
   retractable? : $ -> Boolean
   retract :      $ -> R
\end{verbatim}

In our example of polynomials above, the function {\sl {\bf retractable?}}
would be called to see if the object was a constant polynomial. If the
result was {\sl true}, {\sl {\bf retract}} can be called to extract the
constant.

\subsection{Coercion Query}

There are situations where one wishes to know ahead of time whether it
is possible to coerce an object of type {\bf T1} to one of type 
{\bf T2}. The Axiom interpreter provides this information, for example, to
the type resolve and modemap selection facilities. The facility is
used when one needs to know absolutely when a coercion will be
successful. An answer of ``no'', however, does not guarantee that a
coercion could not be performed for specific data. For example the
system will respond ``no'' when asked whether an object of 
{\bf Polynomial(Integer)} can be coerced to an object of {\bf Integer}.
As we saw above, though, retractions can be performed for constant
polynomials.

\section{The Resolve Facility}

The resolve facility is used to determine a type {\bf T3} to which two
types {\bf T1} and {\bf T2} can be coerced. It is used when an
operation has homogeneous arguments (such as ``$+$'') or when a
statement has several exit points and they must all return the same
type ({\tt then} and {\tt else} clauses of an {\tt if} statement, or
multiple {\tt return} statements in a function).

The resolve facility is symmetric: {\tt resolve({\bf T1},{\bf T2})} $=$
{\tt resolve({\bf T2},{\bf T1})}. The resolve facility is always successful
because type {\bf Any} is returned if a less general type cannot be found.
{\bf Any} is represented by a record with two components, the first being
the original type of the object and the second being the object itself.
Thus anything can be coerced to an object of type {\bf Any} and
{\tt resolve({\bf Any},{\bf T})} $=$ {\bf Any} for all {\bf T}.

Two other types have special resolve rules. Type {\bf Void} has but 
one object and is the type returned by such operations as variable
declaration, function definition, {\tt if} statements without {\tt else}
clauses and {\tt repeat} loops. Several functions also return the object
of type {\bf Void}, including those that display things in two dimensional
algebaic, 
TeX\footnote{TeX is a trademark of the American Mathematical Society} 
and FORTRAN forms. Like {\bf Any}, {\tt resolve({\bf Void},{\bf T})}
$=$ {\bf Void} for all {\bf T}. Type {\bf Exit} is used for {\tt return}
statements and error statements. Its rule is 
{\tt resolve({\bf Exit},{\bf T})} $=$ {\bf T} for all {\bf T}.

After some checks for special cases, the resolve facility has three
components.

\subsection{Resolve by Coercion Query}

If {\bf T1} $=$ {\bf T2}, then the resolve of the pair is just {\bf T1}.
If {\bf T1} can be coerced to {\bf T2} and {\bf T2} cannot be coerced to
{\bf T1}, then {\tt resolve({\bf T1},{\bf T2})} $=$ {\bf T2}. If {\bf T1}
and {\bf T2} are coercable to one another, an arbitrary but canonical
choice is made and returned.

\subsection{Resolve by Rules}

The interpreter has an internal database of rules which it tries to use
to resolve two types. The rules are not complete, as they only attempt
to take care of cases that cannot be dealt with in a more general way.
Almost all of the rules deal with polynomials. For example, one rule is
\begin{verbatim}
   resolve(Polynomial(T1),UnivariatePoly(x,T2))=
      resolve(Polynomial(T1),T2)
\end{verbatim}

The variable of {\bf UnivariatePoly} can be absorbed into the general
constructor {\bf Polynomial} and then the resolve facility is called
again with different arguments. The second call may or may not use
the rule system. 

\subsection{Resolve by Type Destructuring}

This type of resolution is similar to the process involved in the
coercion described in the last paragraph of ``Coerce by Internal
System Code''. Given two towers of parameterized types, the
interpreter tries to rearrange the towers and create a new type to
which both of the original types are coerceable. This is a recursive
process and involves using the coercion query facility to determine
what tower rearrangements are possible.

\section{An Example}
As an example of coerce and resolve, we describe the inference involved
in determining that the expression $x+1/2$ evaluates to an object of the
datatype {\bf Polynomial(RationalNumber)}. We assume $x$ has not 
previously been given a value.

\begin{itemize}
\item Choose a default datatype of {\bf Symbol} for $x$
\item Choose the datatype of {\bf Integer} for 1 and 2
\item Look for an operation ``$/$'' in {\bf Integer} that has two
arguments, each an integer. It is not found.
\item Start a general search in the library for an operation ``$/$''
with two {\bf Integer} arguments. One is found in 
{\bf RationalNumber} and applied
\item Look for a ``$+$'' that takes a {\bf Symbol} and a 
{\bf RationalNumber}. None is found.
\item Force $x$ to an object of type {\bf Polynomial(Integer)}
\item Look for a ``$+$'' that takes a {\bf Polynomial(Integer)} and
a {\bf RationalNumber}. None is found.
\item Start a general search in the library for ``$+$'' operations.
The only ones found take two arguments, each of the same datatype.
Resolve {\bf Polynomial(Integer)} and {\bf RationalNumber} to get the
datatype {\bf Polynomial(RationalNumber)}
\item Do the coercions
\begin{verbatim}
   Polynomial(Integer) -> Polynomial(RationalNumber)
   RationalNumber -> Polynomial(RationalNumber)
\end{verbatim}
\item Apply the ``$+$'' in the datatype {\bf Polynomial(RationalNumber)}
and return the result
\end{itemize}

\section{Acknowledgement}

In addition to the authors, Richard Jenks and Robert Sutor, three people
\index{Jenks, Richard}
\index{Sutor, Robert}
have contributed significantly to the development of the Axiom interpreter.
Scott C. Morrison
\index{Morrison, Scott C.}
(University of California, Berkeley) is responsible for the overall
structure of the interpreter as it is today, having largely rewritten
this part of the system in 1984. Albrecht Fortenbacher
\index{Fortenbacher, Albrecht}
(University of Karlsruhe) rewrote and greatly extended the resolve 
and coerce facilities in 1985. Michael Lucks
\index{Lucks, Michael}
(Southern Methodist University) contributed to the coerce and modemap
selection facilities in 1986.



\chapter{The Interpreter}
The Axiom interpreter is a large common lisp program. 
It has several forms of interaction and run from
terminal in a standalone fashion, run under the control of a
session handler program, run as a web server, or run in a unix
pipe. 
\chapter{The Fundamental Data Structures}

\defdollar{PatternVariableList}
These are temporary variable names that will be replaced by 
FormalMapVariableList.
\begin{chunk}{initvars}
(defvar |$PatternVariableList|
  '(*1 *2 *3 *4 *5 *6 *7 *8 *9 *10 *11 *12 *13 *14 *15 *16 *17 *18 *19 *20
    *21 *22 *23 *24 *25 *26 *27 *28 *29 *30 *31 *32 *33 *34 *35 *36 *37 *38
    *39 *40 *41 *42 *43 *44 *45 *46 *47 *48 *49 *50))

\end{chunk}

\defdollar{FormalMapVariableList}
\begin{chunk}{initvars}
(defvar |$FormalMapVariableList|
  '(|#1| |#2| |#3| |#4| |#5| |#6| |#7| |#8| |#9| |#10|
    |#11| |#12| |#13| |#14| |#15| |#16| |#17| |#18| |#19| |#20|
    |#21| |#22| |#23| |#24| |#25| |#26| |#27| |#28| |#29| |#30|
    |#31| |#32| |#33| |#34| |#35| |#36| |#37| |#38| |#39| |#40|
    |#41| |#42| |#43| |#44| |#45| |#46| |#47| |#48| |#49| |#50|))

\end{chunk}

\section{Frames and the Interpreter Frame Ring}
\label{TheFrameMechanism}

Axiom has the notion of ``frames''. A frame is a data structure which
holds all the vital data from an Axiom session. 

The list of frames is structured as a ring.
New frames can be added which will hold computations of independent
information. The interpreter {\bf )frame} command allows operations
on frames. From the command line the user can create, modify, change,
and delete frames.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{frame.help}
====================================================================
A.11.  )frame
====================================================================
 
User Level Required:  interpreter
 
Command Syntax: 
 
  - )frame  new  frameName
  - )frame  drop  [frameName]
  - )frame  next
  - )frame  last
  - )frame  names
  - )frame  import frameName [objectName1 [objectName2 ...] ]
  - )set message frame on | off
  - )set message prompt frame
 
Command Description: 
 
A frame can be thought of as a logical session within the physical session
that you get when you start the system. You can have as many frames as you
want, within the limits of your computer's storage, paging space, and so on.
Each frame has its own step number, environment and history. You can have a
variable named a in one frame and it will have nothing to do with anything
that might be called a in any other frame.
 
Some frames are created by the HyperDoc program and these can have pretty
strange names, since they are generated automatically. To find out the names
of all frames, issue
 
)frame names
 
It will indicate the name of the current frame.
 
You create a new frame ``quark'' by issuing
 
)frame new quark
 
The history facility can be turned on by issuing either )set history on or
)history )on. If the history facility is on and you are saving history
information in a file rather than in the AXIOM environment then a history
file with filename quark.axh will be created as you enter commands. If you
wish to go back to what you were doing in the ``initial'' frame, use
 
)frame next
 
or
 
)frame last
 
to cycle through the ring of available frames to get back to ``initial''.
 
If you want to throw away a frame (say ``quark''), issue
 
)frame drop quark
 
If you omit the name, the current frame is dropped.
 
If you do use frames with the history facility on and writing to a file, you
may want to delete some of the older history files. These are directories, so
you may want to issue a command like rm -r quark.axh to the operating system.
 
You can bring things from another frame by using )frame import. For example,
to bring the f and g from the frame ``quark'' to the current frame, issue
 
)frame import quark f g
 
If you want everything from the frame ``quark'', issue
 
)frame import quark
 
You will be asked to verify that you really want everything.
 
There are two )set flags to make it easier to tell where you are.
 
)set message frame on | off
 
will print more messages about frames when it is set on. By default, it is
off.
 
)set message prompt frame
 
will give a prompt that looks like
 
initial (1) ->
 
when you start up. In this case, the frame name and step make up the prompt.
 
Also See: 
o )history
o )set
 
\end{chunk} 
\footnote{
\fnref{history}
\fnref{set}}

The frame mechanism uses several dollar variables.

Primary variables are those which exist solely to make the frame
mechanism work. 

The \$interpreterFrameName contains a symbol which is the name
of the current frame in use. 

The \$interpreterFrameRing contains a list of all of the existing
frames. The first frame on the list is the ``current'' frame. When
Axiom is started directly there is only one frame named ``initial''.

If the system is started under sman (using the axiom shell script,
for example), there are two frames, ``initial'' and ``frame0''. In
this case, ``frame0'' is the current frame. This can cause subtle
problems because functions defined in the axiom initialization file
(.axiom.input) will be defined in frame ``initial'' but the current
frame will be ``frame0''. They will appear to be undefined. However,
if the user does ``)frame next'' they can switch to the ``initial''
frame and see the functions correctly defined.

The \$frameMessages variable controls when frame messages will be
displayed. The variable is initially NIL. It can be set on (T) or off (NIL)
using the system command:
\begin{verbatim}
    )set message frame on | off
\end{verbatim}
Setting frame messages on will output a line detailing the 
current frame after every output is complete. 

See the {\bf set message frame}\refto{setmessageframe} section
for more details.

The frame collects and uses a few top level variables. These are:
\$InteractiveFrame, \$IOindex, \$HiFiAccess, \$HistList, \$HistListLen,
\$HistListAct, \$HistRecord, \$internalHistoryTable, and \$localExposureData.

These variables can also be changed by the frame mechanism when the user
requests changing to a different frame.

\section{Data Structures}

The interpreter information is kept in a frame which is a 10 part data
structure of the form (see \ref{emptyInterpreterFrame}).
The parts of a frame and their initial, default values are:
\begin{enumerate}
\item {\bf \$interpreterFrameName}\refto{interpreterFrameName}, 
a string, is the name of the current frame. 
\item {\bf \$InteractiveFrame}\refto{InteractiveFrame}
which defaults to ((nil))
\item {\bf \$IOindex}\refto{IOindex}
also known as the step number, which defaults to 1
\item {\bf \$HiFiAccess}\refto{HiFiAccess}
\item {\bf \$HistList}\refto{HistList}
\item {\bf \$HistListLen}\refto{HistListLen}
\item {\bf \$HistListAct}\refto{HistListAct}
\item {\bf \$HistRecord}\refto{HistRecord}
\item {\bf \$internalHistoryTable}\refto{internalHistoryTable} 
which defaults to nil 
\item {\bfref{localExposureDataDefault}} is a copy of the current 
local exposure data
\end{enumerate}

There are a set of functions to manipulate frames.
The internal set of frame functions are
\begin{itemize}
\item {\bfref{initializeInterpreterFrameRing}} creates the original
frame ring, inserts an initial frame, and updates all the global
variables from the initial frame.
\item {\bfref{emptyInterpreterFrame}} creates a new, empty frame.
\item {\bfref{createCurrentInterpreterFrame}} collects the environment
into a frame.
\item {\bfref{updateFromCurrentInterpreterFrame}} sets all of the
global variables from the current frame.
\item {\bfref{frameEnvironment}} returns the frameInteractive
component of a named frame or a new, empty environment.
\item {\bfref{findFrameInRing}} given the name, find the named frame
\item {\bfref{updateCurrentInterpreterFrame}} collects the normal 
contents of the world into a frame object, places it first on the frame 
list, and then sets the current values of the world from the frame object. 
\item {\bfref{nextInterpreterFrame}} updates the current frame to make 
sure all of the current information is recorded. If there are more frame 
elements in the list then this will destructively move the current frame
to the end of the list, that is, assume the frame list reads (1 2 3)
this function will destructively change it to (2 3 1).
\item {\bfref{previousInterpreterFrame}} moves to the previous 
frame in the ring.
\item {\bfref{changeToNamedInterpreterFrame}} change to the named
frame.
\item {\bfref{addNewInterpreterFrame}} update the current frame,
initialize the history, make a new empty frame, and initialize all of the
global variables from the empty frame.
\item {\bfref{closeInterpreterFrame}} when there is more than one
frame, delete the current frame and initialize all the global variables
from the next frame in the ring.
\item {\bfref{displayFrameNames}} print all the frame names and
indicate which one is the current frame.
\item {\bfref{importFromFrame}} imports items from a different
frame into the current frame
\end{itemize}

\section{Frame Access Macros}

First Frame Component -- frameName
\defmacro{frameName}
\sig{type}{FrameName}{Symbol}
\sig{frameName}{Frame}{FrameName}
\begin{chunk}{defmacro frameName 0}
(defmacro frameName (frame)
 `(first ,frame)) 

\end{chunk}

Second Frame Component -- frameInteractive
\defmacro{frameInteractive}
\sig{frameInteractive}{Frame}{Interactive}
\begin{chunk}{defmacro frameInteractive 0}
(defmacro frameInteractive (frame)
 `(second ,frame))

\end{chunk}

Third Frame Component -- frameIOIndex
\defmacro{frameIOIndex}
\sig{frameIOIndex}{Frame}{IOIndex}
\begin{chunk}{defmacro frameIOIndex 0}
(defmacro frameIOIndex (frame)
 `(third ,frame))

\end{chunk}

Fourth Frame Component -- frameHiFiAccess
\defmacro{frameHiFiAccess}
\sig{frameHiFiAcecss}{Frame}{HiFiAccess}
\begin{chunk}{defmacro frameHiFiAccess 0}
(defmacro frameHiFiAccess (frame)
 `(fourth ,frame))

\end{chunk}

Fifth Frame Component -- frameHistList
\defmacro{frameHistList}
\sig{frameHistList}{Frame}{HistList}
\begin{chunk}{defmacro frameHistList 0}
(defmacro frameHistList (frame)
 `(fifth ,frame))

\end{chunk}

Sixth Frame Component -- frameHistListLen
\defmacro{frameHistListLen}
\sig{type}{HistListLen}{NonNegativeInteger}
\sig{frameHistListLen}{Frame}{HistListLen}
\begin{chunk}{defmacro frameHistListLen 0}
(defmacro frameHistListLen (frame)
 `(sixth ,frame))

\end{chunk}

Seventh Frame Component -- frameHistListAct
\defmacro{frameHistListAct}
\sig{frameHistListAct}{Frame}{HistListAct}
\begin{chunk}{defmacro frameHistListAct 0}
(defmacro frameHistListAct (frame)
 `(seventh ,frame))

\end{chunk}

Eighth Frame Component -- frameHistRecord
\defmacro{frameHistRecord}
\sig{frameHistRecord}{Frame}{HistRecord}
\begin{chunk}{defmacro frameHistRecord 0}
(defmacro frameHistRecord (frame)
 `(eighth ,frame))

\end{chunk}

Ninth Frame Component -- frameHistoryTable
\defmacro{frameHistoryTable}
\sig{frameHistoryTable}{Frame}{HistoryTable}
\begin{chunk}{defmacro frameHistoryTable 0}
(defmacro frameHistoryTable (frame)
 `(ninth ,frame))

\end{chunk}

Tenth Frame Component -- frameExposureData
\defmacro{frameExposureData}
\sig{frameExposureData}{Frame}{ExposureData}
\sig{enum}{FrameArgs}{(nil,drop,import,last,names,new,next)}
\sig{frameSpad2Cmd}{FrameArgs}{nil}
\begin{chunk}{defmacro frameExposureData 0}
(defmacro frameExposureData (frame)
 `(tenth ,frame))

\end{chunk}

\section{Functions to manipulate frames}

\Defun{frame}{The top level frame command}
\calls{frame}{frameSpad2Cmd}
\sig{Frame}{nil}{nil}
\begin{chunk}{defun frame}
(defun |frame| (l)
 "The top level frame command"
 (|frameSpad2Cmd| l)) 

\end{chunk}

\Defun{frameSpad2Cmd}{The top level frame command handler}
\calls{frameSpad2Cmd}{throwKeyedMsg}
\calls{frameSpad2Cmd}{helpSpad2Cmd}
\calls{frameSpad2Cmd}{selectOptionLC}
\calls{frameSpad2Cmd}{qcdr}
\calls{frameSpad2Cmd}{qcar}
\calls{frameSpad2Cmd}{object2Identifier}
\seebook{frameSpad2Cmd}{drop}{9}
\calls{frameSpad2Cmd}{closeInterpreterFrame}
\calls{frameSpad2Cmd}{import}
\calls{frameSpad2Cmd}{importFromFrame}
\calls{frameSpad2Cmd}{last}
\calls{frameSpad2Cmd}{previousInterpreterFrame}
\calls{frameSpad2Cmd}{names}
\calls{frameSpad2Cmd}{displayFrameNames}
\calls{frameSpad2Cmd}{new}
\calls{frameSpad2Cmd}{addNewInterpreterFrame}
\calls{frameSpad2Cmd}{next}
\calls{frameSpad2Cmd}{nextInterpreterFrame}
\usesdollar{frameSpad2Cmd}{options}
\begin{chunk}{defun frameSpad2Cmd}
(defun |frameSpad2Cmd| (args)
 "The top level frame command handler"
 (let (frameArgs arg a)
  (declare (special |$options|))
  (setq frameArgs '(|drop| |import| |last| |names| |new| |next|))
  (cond
   (|$options|
    (|throwKeyedMsg| "The %1 system command takes arguments but no options."
     (cons ")frame" nil)))
   ((null args) (|helpSpad2Cmd| (cons '|frame| nil)))
   (t
     (setq arg (|selectOptionLC| (car args) frameArgs '|optionError|))
     (setq args (cdr args))
     (when (and (consp args) 
            (eq (qcdr args) nil)
            (progn (setq a (qcar args)) t))
        (setq args a))
     (when (atom args) (setq args (|object2Identifier| args)))
     (case arg
      (|drop|
        (if (and args (consp args))
          (|throwKeyedMsg| "%1 is not a valid frame name."
             (cons args nil))
          (|closeInterpreterFrame| args)))
      (|import| (|importFromFrame| args))
      (|last|   (|previousInterpreterFrame|))
      (|names|  (|displayFrameNames|))
      (|new|
        (if (and args (consp args))
          (|throwKeyedMsg| "%1 is not a valid frame name."
             (cons args nil))
          (|addNewInterpreterFrame| args)))
      (|next| (|nextInterpreterFrame|))
      (t nil))))))

\end{chunk}

\Defun{initializeInterpreterFrameRing}{Initializing the Interpreter Frame Ring}

There can be multiple frames and these live in a top-level variable called
{\bf \$interpreterFrameRing}. This variable holds a circular list of frames.

This function creates an empty, initial frame named ``initial'' and
creates a list of frames containing an empty frame. This list is the
interpreter frame ring and is not actually circular but is managed as
a circular list.

As a final step we update the world from this frame. This has the
side-effect of resetting all the important global variables to their
initial values.

\calls{initializeInterpreterFrameRing}{emptyInterpreterFrame}
\calls{initializeInterpreterFrameRing}{updateFromCurrentInterpreterFrame}
\usesdollar{initializeInterpreterFrameRing}{interpreterFrameName}
\usesdollar{initializeInterpreterFrameRing}{interpreterFrameRing}
\sig{emptyInterpreterFrame}{Symbol}{Frame}
\begin{chunk}{defun initializeInterpreterFrameRing}
(defun |initializeInterpreterFrameRing| ()
 "Initializing the Interpreter Frame Ring"
 (declare (special |$interpreterFrameName| |$interpreterFrameRing|))
 (setq |$interpreterFrameName| '|initial|)
 (setq |$interpreterFrameRing|
   (list (|emptyInterpreterFrame| |$interpreterFrameName|)))
 (|updateFromCurrentInterpreterFrame|)
 nil) 

\end{chunk}

\Defun{emptyInterpreterFrame}{Create a new, empty Interpreter Frame}
\usesdollar{emptyInterpreterFrame}{HiFiAccess}
\usesdollar{emptyInterpreterFrame}{HistList}
\usesdollar{emptyInterpreterFrame}{HistListLen}
\usesdollar{emptyInterpreterFrame}{HistListAct}
\usesdollar{emptyInterpreterFrame}{HistRecord}
\usesdollar{emptyInterpreterFrame}{localExposureDataDefault}
\sig{emptyInterpreterFrame}{Symbol}{Frame}
\begin{chunk}{defun emptyInterpreterFrame 0}
(defun |emptyInterpreterFrame| (name)
 "Create a new, empty Interpreter Frame"
 (declare (special |$HiFiAccess| |$HistList| |$HistListLen| |$HistListAct| 
   |$HistRecord| |$localExposureDataDefault|))
 (list name                                 ; frame name
   (list (list nil))                        ; environment
   1                                        ; $IOindex
   |$HiFiAccess|                        
   |$HistList| 
   |$HistListLen| 
   |$HistListAct| 
   |$HistRecord| 
   nil                                      ; $internalHistoryTable
   (copy-seq |$localExposureDataDefault|))) ; $localExposureData

\end{chunk}

\Defun{frameNames}{Create a list of all of the frame names}
This function simply walks across the frame in the frame ring and
returns a list of the name of each frame. 
\usesdollar{frameNames}{interpreterFrameRing}
\sig{frameNames}{nil}{List Symbol}
\begin{chunk}{defun frameNames 0}
(defun |frameNames| () 
 "Creating a List of all of the Frame Names"
 (declare (special |$interpreterFrameRing|))
 (mapcar #'(lambda (f) (frameName f)) |$interpreterFrameRing|))

\end{chunk}

\Defun{displayFrameNames}{Display the frame name list message}
\calls{displayFrameNames}{bright}
\calls{displayFrameNames}{framename}
\usesdollar{displayFrameNames}{interpreterFrameRing}
\sig{displayFrameNames}{nil}{nil}
\begin{chunk}{defun displayFrameNames 0}
(defun |displayFrameNames| ()
 "Display the Frame Names"
 (declare (special |$interpreterFrameRing|))
 (format t "   The names of the existing frames are:~%")
 (format t "~{            ~a ~%~^~}" (|frameNames|))
 (format t "      The current frame is the first one listed.~%"))

\end{chunk}

\Defun{createCurrentInterpreterFrame}
{Collect the global variables into a Frame}

We can collect up all the current environment information into
one frame element with this call. It creates a list of the current
values of the global variables and returns this as a frame element.

\usesdollar{createCurrentInterpreterFrame}{interpreterFrameName}
\usesdollar{createCurrentInterpreterFrame}{InteractiveFrame}
\usesdollar{createCurrentInterpreterFrame}{IOindex}
\usesdollar{createCurrentInterpreterFrame}{HiFiAccess}
\usesdollar{createCurrentInterpreterFrame}{HistList}
\usesdollar{createCurrentInterpreterFrame}{HistListLen}
\usesdollar{createCurrentInterpreterFrame}{HistListAct}
\usesdollar{createCurrentInterpreterFrame}{HistRecord}
\usesdollar{createCurrentInterpreterFrame}{internalHistoryTable}
\usesdollar{createCurrentInterpreterFrame}{localExposureData}
\sig{createCurrentInterpreterFrame}{nil}{Frame}
\begin{chunk}{defun createCurrentInterpreterFrame 0}
(defun |createCurrentInterpreterFrame| ()
 "Collecting up the Environment into a Frame"
 (declare (special |$interpreterFrameName| |$InteractiveFrame| |$IOindex| 
   |$HiFiAccess| |$HistList| |$HistListLen| |$HistListAct| |$HistRecord| 
   |$internalHistoryTable| |$localExposureData|))
 (list 
   |$interpreterFrameName| 
   |$InteractiveFrame| 
   |$IOindex| 
   |$HiFiAccess| 
   |$HistList| 
   |$HistListLen| 
   |$HistListAct| 
   |$HistRecord| 
   |$internalHistoryTable| 
   |$localExposureData|)) 

\end{chunk}

\Defun{updateFromCurrentInterpreterFrame}
{Update global variables from the Current Frame}
The frames are kept on a circular list. The first element on that
list is known as ``the current frame''. This will initialize all
of the interesting interpreter data structures from that frame.
\calls{updateFromCurrentInterpreterFrame}{sayMessage}
\usesdollar{updateFromCurrentInterpreterFrame}{interpreterFrameRing}
\usesdollar{updateFromCurrentInterpreterFrame}{interpreterFrameName}
\usesdollar{updateFromCurrentInterpreterFrame}{InteractiveFrame}
\usesdollar{updateFromCurrentInterpreterFrame}{IOindex}
\usesdollar{updateFromCurrentInterpreterFrame}{HiFiAccess}
\usesdollar{updateFromCurrentInterpreterFrame}{HistList}
\usesdollar{updateFromCurrentInterpreterFrame}{HistListLen}
\usesdollar{updateFromCurrentInterpreterFrame}{HistListAct}
\usesdollar{updateFromCurrentInterpreterFrame}{HistRecord}
\usesdollar{updateFromCurrentInterpreterFrame}{internalHistoryTable}
\usesdollar{updateFromCurrentInterpreterFrame}{localExposureData}
\usesdollar{updateFromCurrentInterpreterFrame}{frameMessages}
\sig{updateFromCurrentInterpreterFrame}{nil}{nil}
\begin{chunk}{defun updateFromCurrentInterpreterFrame}
(defun |updateFromCurrentInterpreterFrame| ()
 "Update from the Current Frame"
 (let (tmp1)
  (declare (special |$interpreterFrameRing| |$interpreterFrameName|
    |$InteractiveFrame| |$IOindex| |$HiFiAccess| |$HistList| |$HistListLen|
    |$HistListAct| |$HistRecord| |$internalHistoryTable| |$localExposureData|
    |$frameMessages|))
  (setq tmp1 (first |$interpreterFrameRing|))
  (setq |$interpreterFrameName| (frameName tmp1))
  (setq |$InteractiveFrame|     (frameInteractive tmp1))
  (setq |$IOindex|              (frameIOIndex tmp1))
  (setq |$HiFiAccess|           (frameHiFiAccess tmp1))
  (setq |$HistList|             (frameHistList tmp1))
  (setq |$HistListLen|          (frameHistListLen tmp1))
  (setq |$HistListAct|          (frameHistListAct tmp1))
  (setq |$HistRecord|           (frameHistRecord tmp1))
  (setq |$internalHistoryTable| (frameHistoryTable tmp1))
  (setq |$localExposureData|    (frameExposureData tmp1))
  (when |$frameMessages| 
   (format t "   Current interpreter frame is called ~a" 
     |$interpreterFrameName|))))

\end{chunk}

\Defun{updateCurrentInterpreterFrame}
{Replace the current frame and update from the globals}
This function collects the normal contents of the world into a 
frame object, places it first on the frame list, and then sets
the current values of the world from the frame object. 

\calls{updateCurrentInterpreterFrame}{createCurrentInterpreterFrame}
\calls{updateCurrentInterpreterFrame}{updateFromCurrentInterpreterFrame}
\usesdollar{updateCurrentInterpreterFrame}{interpreterFrameRing}
\sig{updateCurrentInterpreterFrame}{nil}{nil}
\begin{chunk}{defun updateCurrentInterpreterFrame}
(defun |updateCurrentInterpreterFrame| ()
  "Update the Current Interpreter Frame"
  (declare (special |$interpreterFrameRing|))
  (rplaca |$interpreterFrameRing| (|createCurrentInterpreterFrame|))
  (|updateFromCurrentInterpreterFrame|))

\end{chunk}

\Defun{frameEnvironment}{Get Named Frame Environment (aka Interactive)}
If the frame is found we return the environment portion of the frame
otherwise we construct an empty environment and return it.
The initial values of an empty frame are created here. This function
returns a single frame that will be placed in the frame ring.

\calls{frameEnvironment}{frameInteractive}
\sig{frameEnvironment}{FrameName}{nil}
\begin{chunk}{defun frameEnvironment}
(defun |frameEnvironment| (fname)
 "Get Named Frame Environment (aka Interactive)"
 (let ((frame (|findFrameInRing| fname)))
  (if frame
   (frameInteractive frame)
   (list (list nil)))))

\end{chunk}

\Defun{findFrameInRing}{Find a Frame in the Frame Ring by Name}
Each frame contains its name as the 0th element.  We simply walk all
the frames and if we find one we return it.
\calls{findFrameInRing}{boot-equal}
\calls{findFrameInRing}{frameName}
\usesdollar{findFrameInRing}{interpreterFrameRing}
\sig{findFrameInRing}{FrameName}{Union(Frame,nil)}
\begin{chunk}{defun findFrameInRing 0}
(defun |findFrameInRing| (name)
 "Find a Frame in the Frame Ring by Name"
  (declare (special |$interpreterFrameRing|))
  (dolist (frame |$interpreterFrameRing|)
    (when (eq (frameName frame) name) (return frame))))

\end{chunk}

\Defun{changeToNamedInterpreterFrame}{Change to the Named Interpreter Frame}
\calls{changeToNamedInterpreterFrame}{updateCurrentInterpreterFrame}
\calls{changeToNamedInterpreterFrame}{findFrameInRing}
\calls{changeToNamedInterpreterFrame}{updateFromCurrentInterpreterFrame}
\usesdollar{changeToNamedInterpreterFrame}{interpreterFrameRing}
\sig{changeToNamedInterpreterFrame}{FrameName}{nil}
\begin{chunk}{defun changeToNamedInterpreterFrame}
(defun |changeToNamedInterpreterFrame| (name)
 "Change to the Named Interpreter Frame"
 (let (frame)
 (declare (special |$interpreterFrameRing|))
   (|updateCurrentInterpreterFrame|)
   (setq frame (|findFrameInRing| name))
   (when frame
     (setq |$interpreterFrameRing|
       (cons frame (delete |$interpreterFrameRing| frame :test #'equal)))
     (|updateFromCurrentInterpreterFrame|))))

\end{chunk}

\Defun{nextInterpreterFrame}{Move to the next Interpreter Frame in Ring}
This function updates the current frame to make sure all of the
current information is recorded. If there are more frame elements
in the list then this will destructively move the current frame
to the end of the list, that is, assume the frame list reads (1 2 3)
this function will destructively change it to (2 3 1).

\calls{nextInterpreterFrame}{updateFromCurrentInterpreterFrame}
\usesdollar{nextInterpreterFrame}{interpreterFrameRing}
\sig{nextInterpreterFrame}{nil}{nil}
\begin{chunk}{defun nextInterpreterFrame}
(defun |nextInterpreterFrame| ()
  "Move to the next Interpreter Frame in Ring"
  (declare (special |$interpreterFrameRing|))
  (when (cdr |$interpreterFrameRing|)
   (setq |$interpreterFrameRing|
    (nconc (cdr |$interpreterFrameRing|) (list (car |$interpreterFrameRing|))))
   (|updateFromCurrentInterpreterFrame|)))

\end{chunk}

\Defun{previousInterpreterFrame}
{Move to the previous Interpreter Frame in Ring}
\calls{previousInterpreterFrame}{updateCurrentInterpreterFrame}
\calls{previousInterpreterFrame}{updateFromCurrentInterpreterFrame}
\usesdollar{previousInterpreterFrame}{interpreterFrameRing}
\sig{previousInterpreterFrame}{nil}{nil}
\begin{chunk}{defun previousInterpreterFrame}
(defun |previousInterpreterFrame| ()
 "Move to the previous Interpreter Frame in Ring"
 (let (tmp1 l b)
 (declare (special |$interpreterFrameRing|))
  (|updateCurrentInterpreterFrame|)
  (when  (cdr |$interpreterFrameRing|)
    (setq tmp1 (reverse |$interpreterFrameRing|))
    (setq l (car tmp1))
    (setq b (nreverse (cdr tmp1)))
    (setq |$interpreterFrameRing| (nconc (cons l nil) b))
    (|updateFromCurrentInterpreterFrame|))))

\end{chunk}

\Defun{addNewInterpreterFrame}{Add a New Interpreter Frame}
\calls{addNewInterpreterFrame}{boot-equal}
\calls{addNewInterpreterFrame}{framename}
\calls{addNewInterpreterFrame}{throwKeyedMsg}
\calls{addNewInterpreterFrame}{updateCurrentInterpreterFrame}
\calls{addNewInterpreterFrame}{initHistList}
\calls{addNewInterpreterFrame}{emptyInterpreterFrame}
\calls{addNewInterpreterFrame}{updateFromCurrentInterpreterFrame}
\callsdollar{addNewInterpreterFrame}{erase}
\calls{addNewInterpreterFrame}{histFileName}
\usesdollar{addNewInterpreterFrame}{interpreterFrameRing}
\begin{chunk}{defun addNewInterpreterFrame}
(defun |addNewInterpreterFrame| (name)
 "Add a New Interpreter Frame"
 (declare (special |$interpreterFrameRing|))
 (if (null name)
   (|throwKeyedMsg| "You must provide a name for the new frame." nil)
   (progn
     (|updateCurrentInterpreterFrame|)
     (dolist (f |$interpreterFrameRing|)
       (when (eq name (frameName f)) ; existing frame with same name
         (|throwKeyedMsg| 
          (format nil
            " You cannot use the name %1 for a new frame because an existing ~
              frame already has that name.")
          (list name))))
     (|initHistList|)
     (setq |$interpreterFrameRing|
       (cons (|emptyInterpreterFrame| name) |$interpreterFrameRing|))
     (|updateFromCurrentInterpreterFrame|)
     ($erase (|histFileName|)))))

\end{chunk}

\Defun{importFromFrame}{Import items from another frame}
\calls{importFromFrame}{member}
\calls{importFromFrame}{frameNames}
\calls{importFromFrame}{throwKeyedMsg}
\calls{importFromFrame}{boot-equal}
\calls{importFromFrame}{framename}
\calls{importFromFrame}{frameEnvironment}
\calls{importFromFrame}{upcase}
\calls{importFromFrame}{queryUserKeyedMsg}
\calls{importFromFrame}{string2id-n}
\calls{importFromFrame}{importFromFrame}
\calls{importFromFrame}{sayKeyedMsg}
\calls{importFromFrame}{clearCmdParts}
\calls{importFromFrame}{seq}
\calls{importFromFrame}{exit}
\calls{importFromFrame}{putHist}
\calls{importFromFrame}{get}
\calls{importFromFrame}{getalist}
\usesdollar{importFromFrame}{interpreterFrameRing}
\begin{chunk}{defun importFromFrame}
(defun |importFromFrame| (args)
 "Import items from another frame"
 (prog (temp1 fname fenv x v props vars plist prop val m)
 (declare (special |$interpreterFrameRing|))
  (when (and args (atom args)) (setq args (cons args nil))) 
  (if (null args)
   (|throwKeyedMsg|
    (format nil ")frame import must be followed by the frame name. The names~
     of objects in that frame can then optionally follow the frame name.~
     For example,~
     %ceon )frame import calculus %ceoff ~
     imports all objects in the calculus frame, and ~
     %ceon )frame import calculus epsilon delta %ceoff ~
     imports the objects named epsilon and delta from the ~
     frame calculus. ~
     Please note that if the current frame contained any information ~
     about objects with these names, then that information would be ~
     cleared before the import took place.")
    nil)
   (progn
     (setq temp1 args)
     (setq fname (car temp1))
     (setq args (cdr temp1))
     (cond
      ((null (|member| fname (|frameNames|)))
        (|throwKeyedMsg| 
         (format nil " You cannot import anything from the frame %1 because ~
                       that is not the name of an existing frame.")
         (cons fname nil))) 
      ((boot-equal fname (frameName (car |$interpreterFrameRing|)))
        (|throwKeyedMsg| 
         "You cannot import from the current frame (nor is there a need!)."
         nil))
      (t
        (setq fenv (|frameEnvironment| fname))
        (cond
         ((null args)
           (setq x
             (upcase (|queryUserKeyedMsg|
              (format nil "Do you really want to import everything from the ~
                           frame %1? If so, please enter y or yes :")
              (cons fname nil))))
           (cond
            ((member (string2id-n x 1) '(y yes))
              (setq vars nil)
              (do ((tmp0 (caar fenv) (cdr tmp0)) (tmp1 nil))
                  ((or (atom tmp0) 
                       (progn (setq tmp1 (car tmp0)) nil)
                       (progn 
                        (progn 
                         (setq v (car tmp1))
                         (setq props (cdr tmp1))
                         tmp1)
                        nil))
                    nil)
               (cond
                ((eq v '|--macros|)
                  (do ((tmp2 props (cdr tmp2))
                       (tmp3 nil))
                      ((or (atom tmp2) 
                           (progn (setq tmp3 (car tmp2)) nil)
                           (progn 
                            (progn (setq m (car tmp3)) tmp3)
                            nil))
                         nil)
                     (setq vars (cons m vars))))
                (t (setq vars (cons v vars)))))
              (|importFromFrame| (cons fname vars)))
            (t
              (|sayKeyedMsg| "AXIOM will not import everything from frame %1."
               (cons fname nil)))))
         (t
          (do ((tmp4 args (cdr tmp4)) (v nil))
              ((or (atom tmp4) (progn (setq v (car tmp4)) nil)) nil)
           (seq
            (exit
             (progn
              (setq plist (getalist (caar fenv) v))
              (cond
               (plist 
                (|clearCmdParts| (cons '|propert| (cons v nil)))
                (do ((tmp5 plist (cdr tmp5)) (tmp6 nil))
                    ((or (atom tmp5)
                         (progn (setq tmp6 (car tmp5)) nil)
                         (progn 
                          (progn 
                           (setq prop (car tmp6))
                           (setq val (cdr tmp6))
                           tmp6)
                          nil))
                       nil)
                 (seq
                  (exit (|putHist| v prop val |$InteractiveFrame|)))))
               ((setq m (|get| '|--macros--| v fenv))
                 (|putHist| '|--macros--| v m |$InteractiveFrame|))
               (t 
                 (|sayKeyedMsg|
                  (format nil "AXIOM cannot import %1 from frame %2 because ~
                               it cannot be found.")
                   (cons v (cons fname nil)))))))))
          (|sayKeyedMsg|
            (format nil "Import from frame %1 is complete. Please issue ~
                         )display all if you wish to see the contents of ~
                         the current frame.")
            (cons fname nil))))))))))

\end{chunk}

\Defun{closeInterpreterFrame}{Close an Interpreter Frame}
\calls{closeInterpreterFrame}{framename}
\calls{closeInterpreterFrame}{throwKeyedMsg}
\callsdollar{closeInterpreterFrame}{erase}
\calls{closeInterpreterFrame}{makeHistFileName}
\calls{closeInterpreterFrame}{updateFromCurrentInterpreterFrame}
\usesdollar{closeInterpreterFrame}{interpreterFrameRing}
\usesdollar{closeInterpreterFrame}{interpreterFrameName}
\sig{closeInterpreterFrame}{FrameName}{nil}
\begin{chunk}{defun closeInterpreterFrame}
(defun |closeInterpreterFrame| (name)
 "Close an Interpreter Frame"
 (declare (special |$interpreterFrameRing| |$interpreterFrameName|))
 (let (ifr found)
    (if (null (cdr |$interpreterFrameRing|))
     (if (and name (not (equal name |$interpreterFrameName|)))
       (|throwKeyedMsg| 
        (format nil "There is only one frame active and therefore that ~
         cannot be closed. Furthermore, the frame name you gave is not ~
         the name of the current frame. The current frame is called %1.")
          (cons |$interpreterFrameName| nil))
       (|throwKeyedMsg|
        (format nil "The current frame is the only active one. Issue ~
                     )clear all to clear its contents.")
        nil))
     (progn
       (if (null name)
        (setq |$interpreterFrameRing| (cdr |$interpreterFrameRing|))
        (progn
          (setq found nil)
          (setq ifr nil)
          (dolist (f |$interpreterFrameRing|)
            (if (or found (not (equal name (frameName f))))
              (setq ifr (cons f ifr)))
              (setq found t))
          (if (null found) 
           (|throwKeyedMsg|
             "There is no frame called %1. Your command cannot be processed."
            (cons name nil))
           (progn
             ($erase (|makeHistFileName| name))
             (setq |$interpreterFrameRing| (nreverse ifr))))))
       (|updateFromCurrentInterpreterFrame|)))))

\end{chunk}

\section{Global variables associated with the frame}
\defdollar{interpreterFrameRing}
All existing frames are kept in a ring held in this variable.
\begin{chunk}{initvars}
(defvar |$interpreterFrameRing| nil "The ring of all frames")

\end{chunk}

\defdollar{interpreterFrameName}
The \verb|$interpreterFrameName| variable, set in 
initializeInterpreterFrameRing to the constant
initial to indicate that this is the initial (default) frame.

Frames are structures that capture all of the variables defined in a
session. There can be multiple frames and the user can freely switch
between them. Frames are kept in a ring data structure so you can 
move around the ring.

\begin{chunk}{initvars}
(defvar |$interpreterFrameName| '|initial|)

\end{chunk}

\defdollar{InteractiveFrame}
{\bf \verb|$InteractiveFrame|} is the environment where the user
values are stored.  Any side effects of evaluation of a top-level
expression are stored in this environment.  It is always used as
the starting environment for interpretation.

This variable is set in the {\bf restart} function as the value returned
by {\bf makeInitialModemapFrame|}.

\begin{chunk}{initvars}
(defvar |$InteractiveFrame| nil)

\end{chunk}

The \verb|$IOindex| variable is the number associated with the input prompt.
Every successful expression evaluated increments this number until a
\verb|)clear all| resets it. Here we set it to the initial value.

\defdollar{IOindex}
\begin{chunk}{initvars}
(defvar $IOindex 1 "The current Axiom prompt number")

\end{chunk}

\section{Interpreter Functions using Frames}

The {\bf \ref{restart}} function

The {\bfref undoSteps} function, part of the undo mechanism can
reset the \verb|$InteractiveFrame|.

\chapter{The Message Mechanism}
Throughout the interpreter there are messages printed using a symbol
for a database lookup. This was done to enable translation of these
messages languages other than English.

Axiom messages are read from a flat file database and returned
as one long string.  They are preceded in the database by a key and
this is how they are referenced from code.  For example, one key is
S2IL0001 which means:
\begin{verbatim}
   S2          Scratchpad II designation
   I           from the interpreter
   L           originally from LISPLIB BOOT
   0001        a sequence number
\end{verbatim}

Each message may contain formatting codes and and parameter codes.
The formatting codes are:
\begin{verbatim}
   %ceoff      turn off centering
   %ceon       turn on centering
   %d          turn off bright printing
   %f          user defined printing
   %i          start indentation of 3 more spaces
   %l          start a new line
   %m          math-print an expression
   %rjoff      turn off right justification (actually ragged left)
   %rjon       turn on right justification (actually ragged left)
   %s          pretty-print as an S-expression
   %u          unindent 3 spaces
   %x#         insert # spaces
\end{verbatim}

The parameter codes look like \%1, \%2b, \%3p, \%4m, \%5bp, \%6s where the
digit is the parameter number and the letters following indicate
additional formatting. You can indicate as many additional formatting
qualifiers as you like, to the degree they make sense. 
\begin{itemize}
\item The ``p'' code means to call prefix2String on the parameter, 
a standard way of printing abbreviated types.  
\item The ``P'' operator maps prefix2String over its arguments.  
\item The ``o'' operation formats the argument as an operation name.  
\item The ``b'' means to print that parameter in a bold (bright) font. 
\item The ``c'' means to center that parameter on a new line.
\item The ``r'' means to right justify (ragged left) the argument.
\item The ``f'' means that the parameter is a list [fn, :args]
and that ``fn'' is to be called on ``args'' to get the text. 
\end{itemize}

\defdollar{msgAlist}
\begin{chunk}{initvars}
(defvar |$msgAlist| nil) 

\end{chunk}

\defdollar{testingErrorPrefix}
\begin{chunk}{initvars}
(defvar |$testingErrorPrefix| "Daly Bug")

\end{chunk}

\defdollar{msgdbPrims}
\begin{chunk}{initvars}
(defvar |$msgdbPrims|
 '(|%b| |%d| |%l| |%i| |%u| %U |%n| |%x| |%ce| |%rj| "%U" "%b" "%d"
   "%l" "%i" "%u" "%U" "%n" "%x" "%ce" "%rj"))

\end{chunk}

\defdollar{msgdbPunct}
\begin{chunk}{initvars}
(defvar |$msgdbPunct|
  '(|.| |,| ! |:| |;| ? ] |)| "." "," "!" ":" ";" "?" "]" ")"))

\end{chunk}

\defdollar{msgdbNoBlanksBeforeGroup}
\begin{chunk}{initvars}
(defvar |$msgdbNoBlanksBeforeGroup|
 `(" " | | "%" % ,@|$msgdbPrims| ,@|$msgdbPunct|))

\end{chunk}

\defdollar{msgdbNoBlanksAfterGroup}
\begin{chunk}{initvars}
(defvar |$msgdbNoBlanksAfterGroup|
 `(" " | | "%" % ,@|$msgdbPrims| [ |(| "[" "("))

\end{chunk}

\defun{sayKeyedMsg}{Say a message using a keyed lookup}
\calls{sayKeyedMsg}{sayKeyedMsgLocal}
\begin{chunk}{defun sayKeyedMsg}
(defun |sayKeyedMsg| (key args)
  (|sayKeyedMsgLocal| key args))

\end{chunk}

\defun{sayKeyedMsgLocal}{Handle msg formatting and print to file}
\calls{sayKeyedMsgLocal}{segmentKeyedMsg}
\calls{sayKeyedMsgLocal}{substituteSegmentedMsg}
\calls{sayKeyedMsgLocal}{flowSegmentedMsg}
\calls{sayKeyedMsgLocal}{sayMSG2File}
\calls{sayKeyedMsgLocal}{sayMSG}
\usesdollar{sayKeyedMsgLocal}{printMsgsToFile}
\usesdollar{sayKeyedMsgLocal}{linelength}
\usesdollar{sayKeyedMsgLocal}{margin}
\usesdollar{sayKeyedMsgLocal}{displayMsgNumber}
\begin{chunk}{defun sayKeyedMsgLocal}
(defun |sayKeyedMsgLocal| (key args)
 (let (msg msgp)
 (declare (special |$printMsgsToFile| $linelength $margin |$displayMsgNumber|))
  (setq msg (|segmentKeyedMsg| key))
  (setq msg (|substituteSegmentedMsg| msg args))
  (when |$displayMsgNumber| (setq msg `(,key |:| . ,msg)))
  (setq msgp (|flowSegmentedMsg| msg $linelength $margin))
  (when |$printMsgsToFile| (|sayMSG2File| msgp))
  (|sayMSG| msgp)))

\end{chunk}

\defun{segmentKeyedMsg}{Break a message into words}
\calls{segmentKeyedMsg}{string2Words}
\begin{chunk}{defun segmentKeyedMsg}
(defun |segmentKeyedMsg| (msg) (|string2Words| msg)) 

\end{chunk}

\defun{sayMSG2File}{Write a msg into spadmsg.listing file}
\calls{sayMSG2File}{makePathname}
\calls{sayMSG2File}{defiostream}
\calls{sayMSG2File}{sayBrightly1}
\calls{sayMSG2File}{shut}
\begin{chunk}{defun sayMSG2File}
(defun |sayMSG2File| (msg)
 (let (file str)
  (setq file (|makePathname| '|spadmsg| '|listing| 'a))
  (setq str (defiostream `((mode . output) (file . ,file)) 255 0))
  (sayBrightly1 msg str)
  (shut str)))
 
\end{chunk}

\defun{sayMSG}{sayMSG}
\calls{saymsg}{saybrightly1}
\usesdollar{sayMSG}{algebraOutputStream}
\begin{chunk}{defun sayMSG}
(defun |sayMSG| (x)
 (declare (special |$algebraOutputStream|))
 (when x (sayBrightly1 x |$algebraOutputStream|)))

\end{chunk}

\chapter{The History Mechanism}
\defdollar{HiFiAccess}
The \verb|$HiFiAccess| is set by initHist to T. It is a flag
used by the history mechanism to record whether the history function
is currently on. It can be reset by using the axiom
command
\begin{verbatim}
  )history off
\end{verbatim}
It appears that the name means ``History File Access''.

The \verb|$HiFiAccess| variable is used by historySpad2Cmd to check
whether history is turned on. T means it is, NIL means it is not.
This is remembered in the current frame.

\begin{chunk}{initvars}
(defvar |$HiFiAccess| nil "Is the history function on?")

\end{chunk}

\defdollar{HistList}
Thie \verb|$HistList| variable is set by initHistList to an initial
value of NIL elements. The last element of the list is smashed to
point to the first element to make the list circular.
This is a circular list of length \verb|$HistListLen|.
This is remembered in the current frame.

\begin{chunk}{initvars}
(defvar |$HistList| nil "A circular list of history elements")

\end{chunk}

\defdollar{HistListLen}
The \verb|$HistListLen| variable is set by initHistList to 20.
This is the length of a circular list maintained in the variable
\verb|$HistList|.
This is remembered in the current frame.

\begin{chunk}{initvars}
(defvar |$HistListLen| 0 "The length of the circular history list")

\end{chunk}

\defdollar{HistListAct}
The \verb|$HistListAct| variable is set by initHistList to 0.
This variable holds the actual number of elements in the history list.
This is the number of ``undoable'' steps.
This is remembered in the current frame.

\begin{chunk}{initvars}
(defvar |$HistLIstAct| 0 "The number of un-doable steps")

\end{chunk}

\defdollar{internalHistoryTable}
The \verb|$internalHistoryTable| variable is set at load time by a call to
initvars to a value of NIL.
It is part of the history mechanism.
This is remembered in the current frame.

\begin{chunk}{initvars}
(defvar |$internalHistoryTable| nil)

\end{chunk}

\defdollar{HistRecord}
The \verb|$HistRecord| variable is set by initHistList to NIL.
\verb|$HistRecord| collects the input line, all variable bindings
and the output of a step, before it is written to the file named by
the function histFileName.

\begin{chunk}{initvars}
(defvar |$HistRecord| nil)

\end{chunk}

\defdollar{historyFileType}
The \verb|$historyFileType| is set at load time by a call to 
initvars to a value of ``axh''. It appears that this
is intended to be used as a filetype extension.
It is part of the history mechanism. It is used in makeHistFileName
as part of the history file name.

\begin{chunk}{initvars}
(defvar |$historyFileType| nil)

\end{chunk}

\chapter{The undo mechanism}
\section{Data Structures}
\verb|$frameRecord = [delta1, delta2,... ]| where
delta(i) contains changes in the ``backwards'' direction.
Each delta(i) has the form \verb|((var . proplist)...)| where
proplist denotes an ordinary proplist. For example, an entry
of the form \verb|((x (value) (mode (Integer)))...)| indicates that
to undo 1 step, x's value is cleared and its mode should be set
to (Integer).

A delta(i) of the form (systemCommand . delta) is a special
delta indicating changes due to system commands executed between
the last command and the current command. By recording these deltas
separately, it is possible to undo to either BEFORE or AFTER
the command. These special delta(i)s are given ONLY when a
a system command is given which alters the environment.

recordFrame('system) is called before a command is executed, and
recordFrame('normal) is called after (see processInteractive1).
If no changes are found for former, no special entry is given.

The \verb|$previousBindings| is a copy of the 
\verb|CAAR $InteractiveFrame|. This is used to
compute the delta(i)s stored in \verb|$frameRecord|.

\section{Initial Undo Variables}

\defdollar{frameRecord}
\begin{chunk}{initvars}
(defvar |$frameRecord| nil "a list of value changes") 

\end{chunk}

\defdollar{previousBindings}
\begin{chunk}{initvars}
(defvar |$previousBindings| nil "a copy of Interactive Frame info for undo") 

\end{chunk}

\defdollar{reportundo}
\begin{chunk}{initvars}
(defvar |$reportundo| nil "t means we report the steps undo takes")

\end{chunk}

\section{The undo functions}
\defun{undo}{undo}
\calls{undo}{stringPrefix?}
\calls{undo}{pname}
\calls{undo}{read}
\calls{undo}{userError}
\calls{undo}{qcdr}
\calls{undo}{qcar}
\calls{undo}{identp}
\calls{undo}{undoSteps}
\calls{undo}{undoCount}
\usesdollar{undo}{options}
\usesdollar{undo}{InteractiveFrame}
\begin{chunk}{defun undo}
(defun |undo| (l)
 (let (tmp1 key s undoWhen n)
 (declare (special |$options| |$InteractiveFrame|))
  (setq undoWhen '|after|)
  (when
    (and (consp |$options|)
         (eq (qcdr |$options|) nil)
         (progn
          (setq tmp1 (qcar |$options|))
          (and (consp tmp1)
               (eq (qcdr tmp1) nil)
               (progn (setq key (qcar tmp1)) t)))
     (cond
      ((|stringPrefix?| (setq s (pname key)) "redo")
        (setq |$options| nil) 
        (|read| '(|redo.input|)))
      ((null (|stringPrefix?| s "before"))
        (|userError| "only option to undo is \")redo\""))
      (t 
        (setq undoWhen '|before|)))))
  (if (null l)
    (setq n (- 1))
    (setq n (car l)))
  (when (identp n)
    (setq n (parse-integer (pname n)))
    (unless (integerp n)
      (|userError| "undo argument must be an integer")))
  (setq |$InteractiveFrame| (|undoSteps| (|undoCount| n) undoWhen))
  nil))

\end{chunk}

\defun{undoSteps}{undoSteps}
\begin{verbatim}
-- undoes m previous commands; if )before option, then undo one extra at end
--Example: if $IOindex now is 6 and m = 2 then general layout of $frameRecord,
--  after the call to recordFrame below will be:
--  (<change for systemcommands>
--  (<change for #5> <change for system commands>
--  (<change for #4> <change for system commands>
--  (<change for #3> <change for system commands>
--   <change for #2> <change for system commands>
--   <change for #1> <change for system commands>) where system
--  command entries are optional and identified by (systemCommand . change).
--  For a ")undo 3 )after", m = 2 and undoStep swill restore the environment
--  up to, but not including <change for #3>.
--  An "undo 3 )before" will additionally restore <change for #3>.
--  Thus, the later requires one extra undo at the end.
\end{verbatim}
\calls{undoSteps}{writeInputLines}
\calls{undoSteps}{recordFrame}
\calls{undoSteps}{copy}
\calls{undoSteps}{undoSingleStep}
\calls{undoSteps}{qcdr}
\calls{undoSteps}{qcar}
\usesdollar{undoSteps}{IOindex}
\usesdollar{undoSteps}{InteractiveFrame}
\usesdollar{undoSteps}{frameRecord}
\begin{chunk}{defun undoSteps}
(defun |undoSteps| (m beforeOrAfter)
 (let (tmp1 tmp2 systemDelta lastTailSeen env)
 (declare (special |$IOindex| |$InteractiveFrame| |$frameRecord|))
  (|writeInputLines| '|redo| (- |$IOindex| m))
  (recordFrame 'normal)
  (setq env (copy (caar |$InteractiveFrame|)))
  (do ((i 0 (1+ i)) (framelist |$frameRecord| (cdr framelist)))
      ((or (> i m) (atom framelist)) nil)
    (setq env (|undoSingleStep| (CAR framelist) env))
    (if (and (consp framelist) 
            (progn
             (setq tmp1 (qcdr framelist))
             (and (consp tmp1) 
                  (progn
                   (setq tmp2 (qcar tmp1))
                   (and (consp tmp2)
                        (eq (qcar tmp2) '|systemCommand|)
                        (progn 
                         (setq systemDelta (qcdr tmp2))
                         t))))))
      (progn
        (setq framelist (cdr framelist))
        (setq env (|undoSingleStep| systemDelta env)))
      (setq lastTailSeen framelist)))
  (cond
   ((eq beforeOrAfter '|before|)
     (setq env (|undoSingleStep| (car (cdr lastTailSeen)) env))))
  (setq |$frameRecord| (cdr |$frameRecord|))
  (setq |$InteractiveFrame| (list (list env)))))

\end{chunk}

\defun{undoSingleStep}{undoSingleStep}
\begin{verbatim}
undoSingleStep(changes,env) ==
--Each change is a name-proplist pair. For each change:
--  (1) if there exists a proplist in env, then for each prop-value change:
--      (a) if the prop exists in env, RPLAC in the change value
--      (b) otherwise, CONS it onto the front of prop-values for that name
--  (2) add change to the front of env
--  pp '"----Undoing 1 step--------"
--  pp changes
\end{verbatim}
\calls{undoSingleStep}{assq}
\calls{undoSingleStep}{seq}
\calls{undoSingleStep}{exit}
\calls{undoSingleStep}{lassoc}
\calls{undoSingleStep}{undoLocalModemapHack}
\begin{chunk}{defun undoSingleStep}
(defun |undoSingleStep| (changes env)
 (prog (name changeList pairlist proplist prop value node)
  (return
   (seq
    (progn
     (do ((tmp0 changes (cdr tmp0)) (|change| nil))
         ((or (atom tmp0) 
              (progn (setq |change| (car tmp0)) nil)
              (progn 
               (progn 
                (setq name (car |change|))
                (setq changeList (cdr |change|))
                |change|)
               nil))
             nil)
      (seq
       (exit
        (progn
         (when (lassoc '|localModemap| changeList)
           (setq changeList (|undoLocalModemapHack| changeList)))
         (cond
          ((setq pairlist (assq name env))
            (cond
             ((setq proplist (cdr pairlist))
               (do ((tmp1 changeList (cdr tmp1)) (pair nil))
                   ((or (atom tmp1) 
                        (progn (setq pair (car tmp1)) nil)
                        (progn
                         (progn
                          (setq prop (car pair))
                          (setq value (cdr pair))
                          pair)
                          nil))
                        nil)
                (seq
                 (exit
                  (cond
                   ((setq node (assq prop proplist))
                     (rplacd node value))
                   (t
                     (rplacd proplist
                       (cons (car proplist) (cdr proplist)))
                     (rplaca proplist pair)))))))
             (t (rplacd pairlist changeList))))
          (t 
            (setq env (cons |change| env))))))))
     env))))) 

\end{chunk}

\defun{undoLocalModemapHack}{undoLocalModemapHack}
\calls{undoLocalModemapHack}{seq}
\calls{undoLocalModemapHack}{exit}
\begin{chunk}{defun undoLocalModemapHack}
(defun |undoLocalModemapHack| (changeList)
 (prog (name value)
  (return
   (seq
    (prog (tmp0)
     (setq tmp0 nil)
     (return
      (do ((tmp1 changeList (cdr tmp1)) (pair nil))
          ((or (atom tmp1) 
               (progn (setq pair (car tmp1)) nil)
               (progn
                (progn
                 (setq name (car pair))
                 (setq value (cdr pair))
                 pair)
                nil))
              (nreverse0 tmp0))
       (seq
        (exit
         (cond
          ((cond
             ((eq name '|localModemap|) (cons name nil))
             (t pair))
           (setq tmp0 
            (cons 
             (cond 
              ((eq name '|localModemap|) (cons name nil))
              (t pair)) tmp0))))))))))))) 

\end{chunk}

\Defun{removeUndoLines}{Remove undo lines from history write}
Removing undo lines from \verb|)hist )write linelist|
\calls{removeUndoLines}{stringPrefix?}
\calls{removeUndoLines}{seq}
\calls{removeUndoLines}{exit}
\calls{removeUndoLines}{trimString}
\calls{removeUndoLines}{substring}
\calls{removeUndoLines}{charPosition}
\calls{removeUndoLines}{maxindex}
\calls{removeUndoLines}{undoCount}
\calls{removeUndoLines}{concat}
\usesdollar{removeUndoLines}{currentLine}
\usesdollar{removeUndoLines}{IOindex}
\begin{chunk}{defun removeUndoLines}
(defun |removeUndoLines| (u)
 "Remove undo lines from history write"
 (prog (xtra savedIOindex s s1 m s2 x code c n acc)
 (declare (special |$currentLine| |$IOindex|))
  (return
   (seq
    (progn
     (setq xtra 
      (cond
       ((stringp |$currentLine|) (cons |$currentLine| nil))
       (t (reverse |$currentLine|))))
     (setq xtra
      (prog (tmp0)
       (setq tmp0 nil)
       (return
        (do ((tmp1 xtra (cdr tmp1)) (x nil))
            ((or (atom tmp1)
                 (progn (setq x (car tmp1)) nil))
               (nreverse0 tmp0))
         (seq
          (exit
           (cond
            ((null (|stringPrefix?| ")history" x))
              (setq tmp0 (cons x tmp0))))))))))
     (setq u (append u xtra))
     (cond
      ((null
        (prog (tmp2)
         (setq tmp2 nil)
         (return
          (do ((tmp3 nil tmp2) (tmp4 u (cdr tmp4)) (x nil))
              ((or tmp3 (atom tmp4) (progn (setq x (car tmp4)) nil)) tmp2)
           (seq
            (exit
             (setq tmp2 
               (or tmp2 (|stringPrefix?| ")undo" x))))))))) u)
      (t
        (setq savedIOindex |$IOindex|)
        (setq |$IOindex| 1)
        (do ((y u (cdr y)))
            ((atom y) nil)
         (seq
          (exit
           (cond
            ((eql (elt (setq x (car y)) 0) #\) )
              (cond
               ((|stringPrefix?| ")undo"
                                 (setq s (|trimString| x)))
                (setq s1 (|trimString| (substring s 5 nil)))
                (cond
                  ((not (string= s1 ")redo"))
                    (setq m (|charPosition| #\) s1 0))
                    (setq code
                     (cond
                       ((> (maxindex s1) m) (elt s1 (1+ m)))
                       (t #\a)))
                    (setq s2 (|trimString| (substring s1 0 m)))))
                (setq n
                 (cond
                  ((string= s1 ")redo")
                     0)
                  ((not (string= s2 ""))
                    (|undoCount| (parse-integer s2)))
                  (t -1)))
                (rplaca y
                  (concat ">" code (princ-to-string n))))
               (t nil)))
            (t (setq |$IOindex| (1+ |$IOindex|)))))))
        (setq acc nil)
        (do ((y (nreverse u) (cdr y)))
            ((atom y) nil)
         (seq
          (exit
           (cond
            ((eql (elt (setq x (car y)) 0) #\>)
              (setq code (elt x 1))
              (setq n (parse-integer (substring x 2 nil)))
              (setq y (cdr y))
              (do () 
                  ((null y) nil)
               (seq
                (exit
                 (progn
                  (setq c (car y))
                  (cond 
                   ((or (eql (elt c 0) #\))
                        (eql (elt c 0) #\>))
                     (setq y (cdr y)))
                   ((eql n 0)
                     (return nil))
                   (t
                     (setq n (- n 1))
                     (setq y (cdr y))))))))
              (cond
               ((and y (not (eql code #\b)))
                 (setq acc (cons c acc)))))
            (t (setq acc (cons x acc)))))))
        (setq |$IOindex| savedIOindex)
        acc)))))))

\end{chunk}

\defun{reportUndo}{reportUndo}
This function is enabled by setting \verb|$reportundo| to a non-nil value.
An example of the output generated is:
\begin{verbatim}
r := binary(22/7)
 

           ___
   (1)  11.001
                                                        Type: BinaryExpansion
Properties of % ::
  value was: NIL
  value is:  ((|BinaryExpansion|) WRAPPED . #(1 (1 1) NIL (0 0 1)))
Properties of r ::
  value was: NIL
  value is:  ((|BinaryExpansion|) WRAPPED . #(1 (1 1) NIL (0 0 1)))

\end{verbatim}

\calls{reportUndo}{seq}
\calls{reportUndo}{exit}
\calls{reportUndo}{sayBrightly}
\calls{reportUndo}{concat}
\calls{reportUndo}{pname}
\calls{reportUndo}{lassoc}
\calls{reportUndo}{sayBrightlyNT}
\calls{reportUndo}{pp}
\usesdollar{reportundo}{InteractiveFrame}
\begin{chunk}{defun reportUndo}
(defun |reportUndo| (acc)
 (prog (name proplist curproplist prop value)
 (declare (special |$InteractiveFrame|))
  (return
   (seq
    (do ((tmp0 acc (cdr tmp0)) (tmp1 nil))
        ((or (atom tmp0) 
             (progn (setq tmp1 (car tmp0)) nil)
             (progn
              (progn
               (setq name (car tmp1))
               (setq proplist (cdr tmp1))
               tmp1)
              nil))
            nil)
     (seq
      (exit
       (progn
        (|sayBrightly|
          (concat '|Properties of | (pname name) " ::"))
        (setq curproplist (lassoc name (caar |$InteractiveFrame|)))
        (do ((tmp2 proplist (cdr tmp2)) (tmp3 nil))
            ((or (atom tmp2) 
                 (progn (setq tmp3 (car tmp2)) nil)
                 (progn 
                  (progn 
                   (setq prop (car tmp3))
                   (setq value (cdr tmp3))
                   tmp3)
                  nil))
                nil)
         (seq
          (exit
           (progn
            (|sayBrightlyNT|
             (cons "  " (cons prop (cons " was: " nil))))
            (|pp| value)
            (|sayBrightlyNT| 
             (cons "  " (cons prop (cons " is:  " nil))))
            (|pp| (lassoc prop curproplist)))))))))))))) 

\end{chunk}

\Defun{undoCount}{Undo previous n commands}
\calls{undoCount}{userError}
\calls{undoCount}{concat}
\usesdollar{undoCount}{IOindex}
\begin{chunk}{defun undoCount}
(defun |undoCount| (n)
 "Undo previous n commands"
 (prog (m)
 (declare (special |$IOindex|))
  (return
   (progn
    (setq m 
     (cond 
       ((>= n 0) (- (- |$IOindex| n) 1))
       (t (- n))))
    (cond
     ((>= m |$IOindex|)
       (|userError| 
        (concat "Magnitude of undo argument must be less than step number ("
           (princ-to-string |$IOindex|) ").")))
     (t m)))))) 

\end{chunk}

\chapter{Tracing}
\section{The help text}
\begin{chunk}{trace.help}
====================================================================
A.26.  )trace
====================================================================
 
User Level Required:  interpreter
 
Command Syntax: 
 
  - )trace
  - )trace )off
 
  - )trace function [options]
  - )trace constructor [options]
  - )trace domainOrPackage [options]
 
where options can be one or more of
 
  - )after S-expression
  - )before S-expression
  - )break after
  - )break before
  - )cond S-expression
  - )count
  - )count n
  - )depth n
  - )local op1 [... opN]
  - )nonquietly
  - )nt
  - )off
  - )only listOfDataToDisplay
  - )ops
  - )ops op1 [... opN ]
  - )restore
  - )stats
  - )stats reset
  - )timer
  - )varbreak
  - )varbreak var1 [... varN ]
  - )vars
  - )vars var1 [... varN ]
  - )within executingFunction
 
Command Description: 
 
This command is used to trace the execution of functions that make up the
AXIOM system, functions defined by users, and functions from the system
library. Almost all options are available for each type of function but
exceptions will be noted below.
 
To list all functions, constructors, domains and packages that are traced,
simply issue
 
)trace
 
To untrace everything that is traced, issue
 
)trace )off
 
When a function is traced, the default system action is to display the
arguments to the function and the return value when the function is exited.
Note that if a function is left via an action such as a THROW, no return
value will be displayed. Also, optimization of tail recursion may decrease
the number of times a function is actually invoked and so may cause less
trace information to be displayed. Other information can be displayed or
collected when a function is traced and this is controlled by the various
options. Most options will be of interest only to AXIOM system developers. If
a domain or package is traced, the default action is to trace all functions
exported.
 
Individual interpreter, lisp or boot functions can be traced by listing their
names after )trace. Any options that are present must follow the functions to
be traced.
 
)trace f
 
traces the function f. To untrace f, issue
 
)trace f )off
 
Note that if a function name contains a special character, it will be
necessary to escape the character with an underscore
 
)trace _/D_,1
 
To trace all domains or packages that are or will be created from a
particular constructor, give the constructor name or abbreviation after
)trace.
 
)trace MATRIX
)trace List Integer
 
The first command traces all domains currently instantiated with Matrix. If
additional domains are instantiated with this constructor (for example, if
you have used Matrix(Integer) and Matrix(Float)), they will be automatically
traced. The second command traces List(Integer). It is possible to trace
individual functions in a domain or package. See the )ops option below.
 
The following are the general options for the )trace command.
 
  )break after
    causes a Lisp break loop to be entered after exiting the traced function.
 
  )break before
    causes a Lisp break loop to be entered before entering the traced
    function.
 
  )break
    is the same as )break before.
 
  )count
    causes the system to keep a count of the number of times the traced
    function is entered. The total can be displayed with )trace )stats and
    cleared with )trace )stats reset.
 
  )count n
    causes information about the traced function to be displayed for the
    first n executions. After the nth execution, the function is untraced.
 
  )depth n
    causes trace information to be shown for only n levels of recursion of
    the traced function. The command
 
    )trace fib )depth 10
 
    will cause the display of only 10 levels of trace information for the
    recursive execution of a user function fib.
 
  )math
    causes the function arguments and return value to be displayed in the
    AXIOM monospace two-dimensional math format.
 
  )nonquietly
    causes the display of additional messages when a function is traced.
 
  )nt
    This suppresses all normal trace information. This option is useful if
    the )count or )timer options are used and you are interested in the
    statistics but not the function calling information.
 
  )off
    causes untracing of all or specific functions. Without an argument, all
    functions, constructors, domains and packages are untraced. Otherwise,
    the given functions and other objects are untraced. To immediately
    retrace the untraced functions, issue )trace )restore.
 
  )only listOfDataToDisplay
    causes only specific trace information to be shown. The items are listed
    by using the following abbreviations:
 
    a        display all arguments
    v        display return value
    1        display first argument
    2        display second argument
    15       display the 15th argument, and so on
 
  )restore
    causes the last untraced functions to be retraced. If additional options
    are present, they are added to those previously in effect.
 
  )stats
    causes the display of statistics collected by the use of the )count and
    )timer options.
 
  )stats reset
    resets to 0 the statistics collected by the use of the )count and )timer
    options.
 
  )timer
    causes the system to keep a count of execution times for the traced
    function. The total can be displayed with )trace )stats and cleared with
    )trace )stats reset.
 
  )varbreak var1 [... varN]
    causes a Lisp break loop to be entered after the assignment to any of the
    listed variables in the traced function.
 
  )vars
    causes the display of the value of any variable after it is assigned in
    the traced function. Note that library code must have been compiled (see
    description of command )compile ) using the )vartrace option in order to
    support this option.
 
  )vars var1 [... varN]
    causes the display of the value of any of the specified variables after
    they are assigned in the traced function. Note that library code must
    have been compiled (see description of command )compile ) using the
    )vartrace option in order to support this option.
 
  )within executingFunction
    causes the display of trace information only if the traced function is
    called when the given executingFunction is running.
 
The following are the options for tracing constructors, domains and packages.
 
  )local [op1 [... opN] ]
    causes local functions of the constructor to be traced. Note that to
    untrace an individual local function, you must use the fully qualified
    internal name, using the escape character _ before the semicolon.
 
    )trace FRAC )local
    )trace FRAC_;cancelGcd )off
 
  )ops op1 [... opN]
    By default, all operations from a domain or package are traced when the
    domain or package is traced. This option allows you to specify that only
    particular operations should be traced. The command
 
    )trace Integer )ops min max _+ _-
 
    traces four operations from the domain Integer. Since + and - are special
    characters, it is necessary to escape them with an underscore.
 
Also See: 
o )lisp
o )ltrace
 
\end{chunk} 
\footnote{
\fnref{lisp}
\fnref{ltrace}}

\section{The trace global variables}

\defdollar{breakCondition}
\begin{chunk}{initvars}
(defvar |$breakCondition| nil)

\end{chunk}

\defdollar{constructors}
\begin{chunk}{initvars}
(defvar |$constructors| nil)

\end{chunk}

\defdollar{constructors}
\begin{chunk}{initvars}
(defvar |$constructors| nil)

\end{chunk}

\defdollar{countList}
\begin{chunk}{initvars}
(defvar |$countList| nil "A list of traced functions to count")

\end{chunk}

\defdollar{depthAlist}
\begin{chunk}{initvars}
(defvar |$depthAlist| nil)

\end{chunk}

\defdollar{domains}
\begin{chunk}{initvars}
(defvar |$domains| nil)

\end{chunk}

\defdollar{domainTraceNameAssoc}
This is an alist whose car is the domain and whose cdr is a gensym.
\begin{chunk}{initvars}
(defvar |$domainTraceNameAssoc| nil)

\end{chunk}

\defdollar{doNotAddEmptyModeIfTrue}
\begin{chunk}{initvars}
(defvar |$doNotAddEmptyModeIfTrue| nil)

\end{chunk}

\defdollar{embeddedFunctions}
\begin{chunk}{initvars}
(defvar |$embeddedFunctions| nil)

\end{chunk}

\defdollar{fromSpadTrace}
\begin{chunk}{initvars}
(defvar |$fromSpadTrace| nil)

\end{chunk}

\defdollar{lastUntraced}
\begin{chunk}{initvars}
(defvar |$lastUntraced| nil)

\end{chunk}

\defdollar{letAssoc}
\begin{chunk}{initvars}
(defvar |$letAssoc| nil)

\end{chunk}

\defdollar{mapSubNameAlist}
\begin{chunk}{initvars}
(defvar |$mapSubNameAlist| nil)

\end{chunk}

\defdollar{mathTrace}
\begin{chunk}{initvars}
(defvar |$mathTrace| nil)

\end{chunk}

\defdollar{mathTraceList}
\begin{chunk}{initvars}
(defvar |$mathTraceList| nil "A list of functions with math trace output")

\end{chunk}

\defdollar{monitorArgs}
\begin{chunk}{initvars}
(defvar |$monitorArgs| nil)

\end{chunk}

\defdollar{monitorCaller}
\begin{chunk}{initvars}
(defvar |$monitorCaller| nil)

\end{chunk}

\defdollar{monitorDepth}
\begin{chunk}{initvars}
(defvar |$monitorDepth| 0)

\end{chunk}

\defdollar{monitorFunDepth}
\begin{chunk}{initvars}
(defvar |$monitorFunDepth| nil)

\end{chunk}

\defdollar{monitorName}
\begin{chunk}{initvars}
(defvar |$monitorName| nil)

\end{chunk}

\defdollar{monitorPretty}
\begin{chunk}{initvars}
(defvar |$monitorPretty| nil)

\end{chunk}

\defdollar{monitorValue}
\begin{chunk}{initvars}
(defvar |$monitorValue| nil)

\end{chunk}

\defdollar{optionAlist}
\begin{chunk}{initvars}
(defvar |$optionAlist| nil) 

\end{chunk}

\defdollar{options}
\begin{chunk}{initvars}
(defvar |$options| nil) 

\end{chunk}

\defdollar{OutputForm}
\begin{chunk}{initvars}
(defvar |$OutputForm| nil) 

\end{chunk}

\defdollar{packages}
\begin{chunk}{initvars}
(defvar |$packages| nil)

\end{chunk}

\defdollar{QuickLet}
\begin{chunk}{initvars}
(defvar |$QuickLet| nil)

\end{chunk}

\defdollar{reportSpadtrace}
This reports the traced functions
\begin{chunk}{initvars}
(defvar |$reportSpadtrace| nil) 

\end{chunk}

\defdollar{spaceList}
\begin{chunk}{initvars}
(defvar |$spaceList| nil "A list of traced functions to calculate space used")

\end{chunk}

\defdollar{streamCount}
\begin{chunk}{initvars}
(defvar |$streamCount| t)

\end{chunk}

\defdollar{timerList}
\begin{chunk}{initvars}
(defvar |$timerList| nil "A list of traced functions to time")

\end{chunk}

\defdollar{tracedMapSignatures}
\begin{chunk}{initvars}
(defvar |$tracedMapSignatures| nil) 

\end{chunk}

\defdollar{traceDomains}
\begin{chunk}{initvars}
(defvar |$traceDomains| t)

\end{chunk}

\defdollar{traceErrorStack}
\begin{chunk}{initvars}
(defvar |$traceErrorStack| t)

\end{chunk}

\defdollar{TraceFlag}
\begin{chunk}{initvars}
(defvar |$TraceFlag| t)

\end{chunk}

\defdollar{traceletflag}
\begin{chunk}{initvars}
(defvar $traceletflag nil)

\end{chunk}

\defdollar{traceletFunctions}
\begin{chunk}{initvars}
(defvar |$traceletFunctions| nil)

\end{chunk}

\defdollar{traceNames}
\begin{chunk}{initvars}
(defvar |$traceNames| nil "The names of traced domains and packages")

\end{chunk}

\defdollar{traceNoisely}
This decides when to give trace and untrace messages.
\begin{chunk}{initvars}
(defvar |$traceNoisely| nil) 

\end{chunk}

\defdollar{traceOptionList}
\begin{chunk}{initvars}
(defvar |$traceOptionList|
 '(|after| |before| |break| |cond| |count| |depth| |local| |mathprint| 
   |nonquietly| |nt| |of| |only| |ops| |restore| |timer| |varbreak| 
   |vars| |within|))

\end{chunk} 

\defdollar{tracedSpadModemap}
\begin{chunk}{initvars}
(defvar |$tracedSpadModemap| nil)

\end{chunk}

\defdollar{traceSize}
This is the size limit of output during tracing. See \ref{smallEnough}
\begin{chunk}{initvars}
(defvar |$traceSize| nil "size limit of output during tracing")

\end{chunk}

\defdollar{traceStream}
\begin{chunk}{initvars}
(defvar |$traceStream| *standard-output*)

\end{chunk}

\section{The trace initialization}
\begin{chunk}{postvars}
(eval-when (eval load)
 (put '|coerce| '/TRANSFORM '(& & *))
 (put '|comp| '/TRANSFORM '(& * * &))
 (put '|compIf| '/TRANSFORM '(& * * &))
 ; by having no transform for the 3rd argument, it is simply not printed
 (put '|compFormWithModemap| '/TRANSFORM '(& * * & &)))

\end{chunk}

\section{The trace functions}
\defun{trace}{The Top Level )trace Command Handler}
\calls{trace}{traceSpad2Cmd}
\begin{chunk}{defun trace}
(defun |trace| (l)
 (traceSpad2Cmd l)) 

\end{chunk}

\defun{traceSpad2Cmd}{traceSpad2Cmd}
\calls{traceSpad2Cmd}{getMapSubNames}
\calls{traceSpad2Cmd}{trace1}
\calls{traceSpad2Cmd}{augmentTraceNames}
\calls{traceSpad2Cmd}{traceReply}
\usesdollar{traceSpad2Cmd}{mapSubNameAlist}
\usesdollar{traceSpad2Cmd}{options}
\begin{chunk}{defun traceSpad2Cmd}
(defun traceSpad2Cmd (l)
 (declare (special |$mapSubNameAlist| |$options|))
  (when (eq (first l) '|Tuple|) (setq l (second l)))
  (setq |$mapSubNameAlist| (getMapSubNames l))
  (trace1 (augmentTraceNames l) |$options|)
  (traceReply))

\end{chunk}

\defun{augmentTraceNames}{augmentTraceNames}
If we have values on the {\bf localModemap} property of 
\index{localModemap}
\verb|$InteractiveFrame| we collect the names, otherwise we
\index{InteractiveFrame}
simply add the arguments to the result.
\calls{augmentTraceNames}{get}
\usesdollar{augmentTraceNames}{InteractiveFrame}
\begin{chunk}{defun augmentTraceNames}
(defun augmentTraceNames (arg)
 (let (mml res)
 (declare (special |$InteractiveFrame|))
 (loop for traceName in arg do
  (if (setq mml (|get| tracename '|localModemap| |$InteractiveFrame|))
   (setq res (append (loop for mm in mml collect (cadr mm)))) res)
   (setq res (cons tracename res)))
 res))

\end{chunk}

\defun{trace1}{trace1}
The trace1 function handles the options {\bf off}, {\bf stats},
{\bf restore}, and the {\bf help} options.
\calls{trace1}{hasOption}
\calls{trace1}{throwKeyedMsg}
\calls{trace1}{unabbrev}
\calls{trace1}{isFunctor}
\calls{trace1}{getTraceOption}
\calls{trace1}{untraceDomainLocalOps}
\calls{trace1}{qslessp}
\calls{trace1}{poundsign}
\calls{trace1}{untrace}
\calls{trace1}{ptimers}
\calls{trace1}{say}
\calls{trace1}{pcounters}
\calls{trace1}{selectOptionLC}
\calls{trace1}{resetSpacers}
\calls{trace1}{resetTimers}
\calls{trace1}{resetCounters}
\calls{trace1}{qcar}
\calls{trace1}{qcdr}
\calls{trace1}{vecp}
\calls{trace1}{sayKeyedMsg}
\calls{trace1}{devaluate}
\calls{trace1}{lassoc}
\calls{trace1}{trace1}
\calls{trace1}{delete}
\calls{trace1}{?t}
\calls{trace1}{seq}
\calls{trace1}{exit}
\calls{trace1}{transTraceItem}
\calls{trace1}{addassoc}
\calls{trace1}{getTraceOptions}
\calls{trace1}{/trace,0}
\calls{trace1}{saveMapSig}
\usesdollar{trace1}{traceNoisely}
\usesdollar{trace1}{options}
\usesdollar{trace1}{lastUntraced}
\usesdollar{trace1}{optionAlist}
\begin{chunk}{defun trace1}
(defun trace1 (l options)
 (prog (|$traceNoisely| varList y domainList optionList traceList
        opList newOptions oldL a opt constructor lops ops)
  (declare (special |$traceNoisely| |$options|))
  (setq |$traceNoisely| nil)
  (when (|hasOption| options '|nonquietly|) (setq |$traceNoisely| t))
  (cond
    ((|hasOption| options '|off|)
     (cond
      ((or (setq ops (|hasOption| options '|ops|))
           (setq lops (|hasOption| options '|local|)))
        (cond 
         ((null l) 
            (|throwKeyedMsg| 
             (format nil
              "If you use the )off option for )trace and you also use the ~
               )local or )ops option, you must specify the name of a ~
               constructor.  You have not done so.")
              nil))
         (t
           (setq constructor
             (|unabbrev|
               (cond
                ((atom l) l)
                ((null (cdr l))
                  (cond
                   ((atom (car l)) (car l))
                   (t (car (car l)))))
                (t nil))))
           (cond
            ((null (|isFunctor| constructor))
                (|throwKeyedMsg|
                 (format nil
                  "If you use the )off option for )trace and you also use ~
                   the )local or )ops option, you must specify the name ~
                   of a constructor. What you gave after )trace is not a ~
                   valid constructor name.")
                  nil))
            (t
              (when ops (setq ops (|getTraceOption| ops)) nil)
              (when lops 
               (setq lops (cdr (|getTraceOption| lops)))
               (|untraceDomainLocalOps| constructor lops)))))))
      ((and (< 1 (length options))
            (null (|hasOption| options '|nonquietly|)))
          (|throwKeyedMsg|
           (format nil
            "If you use the )off option for )trace then the only other ~
             options you can use are )nonquietly, )ops and )local.")
           nil))
      (t
        (|untrace| l)
        (|clearConstructorCaches|))))
    ((|hasOption| options '|stats|)
      (cond
        ((< 1 (length options))
          (|throwKeyedMsg| "%1 can have no other options."
            (cons ")trace ... )stats" nil)))
        (t
           (setq opt (cdar options))
           (cond
            ((null opt)
              (format t "~v,,,'-:@<~a~>~%" (- $linelength 2)
                " Traced function execution times ")
              (|ptimers|)
              (say " ")
              (format t "~v,,,'-:@<~a~>~%" (- $linelength 2)
                " Traced function execution counts ")
              (|pcounters|))
            (t
              (|selectOptionLC| (car opt) '(|reset|) '|optionError|)
              (|resetSpacers|)
              (|resetTimers|)
              (|resetCounters|)
              (|throwKeyedMsg|
               (format nil
                "Trace facility timers, space counts and execution counts ~
                 have been reset.")
                nil))))))
    ((setq a (|hasOption| options '|restore|))
      (cond
       ((null (setq oldL |$lastUntraced|)) nil)
       (t
         (setq newOptions (|delete| a options))
         (cond
           ((null l) (trace1 oldL options))
           (t
            (loop for x in l do
             (cond
              ((simple-vector-p (car x))
                (|sayKeyedMsg| "Please retrace the domain %1."
                  (list (|devaluate| (car x)))))
              (t
                (setq options
                  (append newOptions (lassoc x |$optionAlist|)))
                (trace1 (list x) options)))))))))
    ((null l) nil)
    ((and (consp l) (eq (cdr l) nil) (eq (car l) '?)) (|?t|))
    (t
      (setq traceList
       (or
        (loop for x in l collect (|transTraceItem| x))
        (return nil)))
      (loop for x in traceList do
        (setq |$optionAlist| (addassoc x options |$optionAlist|)))
      (setq optionList (getTraceOptions options))
      (cond
       ((setq domainList (lassoc '|of| optionList))
         (cond
          ((lassoc '|ops| optionList)
              (|throwKeyedMsg| 
               ")ops and )of cannot both be options to )trace"
               nil))
          (t
           (setq opList (when traceList (list (cons '|ops| traceList))))
           (setq varList
             (when
               (setq y (lassoc '|vars| optionList)) (list (cons '|vars| y))))
           (setq optionList (append opList varList))
           (setq traceList domainList)))))
      (loop for funName in traceList do
        (trace2 funName nil optionList))
       (|saveMapSig| traceList)))))

\end{chunk}

\defun{trace2}{trace2}
\calls{trace2}{trace3}
\begin{chunk}{defun trace2}
(defun trace2 (fn modemap options)
  (trace3 fn modemap options nil))

\end{chunk}

\defun{trace3}{trace3}
The {\bf trace3} examines the options to the top level trace command
and builds the lambda expression in the variable {\bf newdef}
\begin{verbatim}
  (lambda (&rest g6) (monitorx g6 fn ll))
\end{verbatim}
The {\bf fn} variable is an uninterned gensym name that is unique.
The {\bf ll} variable is a list of 
\begin{itemize}
\item tracename -- The spad internal name for a function from a
domain which can be found in the compiler output files. 
e.g. Polynomial.univariate.21
\item (when g4 'macro) -- most likely nil
\item tracecode -- a string controlling what tracing will occur 
where tracecode means
\begin{verbatim}
  ; 0:        Caller (0,1)           print caller if 1
  ; 1:        Value (0,1)            print value if 1
  ; 2...:     Arguments (0,...,9)    stop if 0; print ith if i; all if 9
\end{verbatim}
\item countnam -- 
\item timernam --
\item before -- An expression to execute before executing the function.
It defaults to 
\begin{verbatim}
  (eq nil nil)
\end{verbatim}
\item after --
\item condition --
\item break --
\item modemap -- The modemap for the function. For Polynomial.variables.15
it shows up as
\begin{verbatim}
  ((List (Symbol)) (Polynomial (Integer)))
\end{verbatim}
\item (list 'quote t) --
\end{itemize}
\calls{trace3}{untrace2}
\calls{trace3}{options2uc}
\calls{trace3}{isFunctor}
\calls{trace3}{traceDomainConstructor}
\calls{trace3}{rassoc}
\calls{trace3}{isSubForRedundantMapName}
\calls{trace3}{rassocSub}
\calls{trace3}{spadThrowBrightly}
\calls{trace3}{getTraceOption}
\calls{trace3}{tracelet}
\calls{trace3}{breaklet}
\calls{trace3}{isUncompiledMap}
\calls{trace3}{sayBrightly}
\calls{trace3}{isInterpOnlyMap}
\calls{trace3}{isDomainOrPackage}
\calls{trace3}{spadTrace}
\calls{trace3}{strconc}
\calls{trace3}{pname}
\calls{trace3}{trace2}
\calls{trace3}{adjoinEqual}
\calls{trace3}{embededFunction}
\calls{trace3}{embed2}
\usesdollar{trace3}{timerList}
\usesdollar{trace3}{countList}
\usesdollar{trace3}{fromSpadTrace}
\usesdollar{trace3}{traceNoisely}
\usesdollar{trace3}{mathTraceList}
\usesdollar{trace3}{mapSubNameAlist}
\usesdollar{trace3}{traceNames}
\usesdollar{trace3}{traceDomains}
\begin{chunk}{defun trace3}
(defun trace3 (fn modemap options binDef)
 (labels (
  (getTraceOption (traceopts opt)
   (loop for x in traceopts do (when (eq (car x) opt) (return x)))))
 (let (mathTrace vars break varbreak fnval u tracename letfuncode before
       after caller fromCondition condition withinCondition g countnam
       countCondition timernam depthCondition onlys f a v c nl buf
       tracecode g4 ll newDef oldDef)
    (declare (special |$traceNames| |$traceDomains| |$mapSubNameAlist|
              |$mathTraceList| |$traceNoisely| |$fromSpadTrace|
              |$countList| |$timerList|))
    (when (member fn |$traceNames| :test #'eq) (|untrace2| fn nil))
    (setq options (options2uc options))
    (cond
     ((and |$traceDomains| (|isFunctor| fn) (atom fn))
      (|traceDomainConstructor| fn options))
     (t
       (setq mathTrace (getTraceOption options 'mathprint))
       (when
        (and mathTrace 
             (null (eql (elt (symbol-name fn) 0) #\$))
             (null (gensymp fn)))
         (if (rassoc fn |$mapSubNameAlist|)
           (setq |$mathTraceList| (cons fn |$mathTraceList|)))
           (|spadThrowBrightly|
             (format nil "mathprint not available for ~A" fn)))
    (setq vars (getTraceOption options 'vars))
    (when vars
      (setq vars (unless (cdr vars) 'all (cdr vars)))
      (|tracelet| fn binDef vars))
    (setq break (getTraceOption options 'break))
    (setq varbreak (getTraceOption options 'varbreak))
    (when varbreak
      (setq vars (if (null (cdr varbreak)) 'all (cdr varbreak)))
      (|breaklet| fn binDef vars))
    (cond
      ((and (null bindef) (symbolp fn) (null (boundp fn)) (null (fboundp fn)))
        (cond
          ((|isUncompiledMap| fn)
           (|sayBrightly|
            (format nil
        "~A must be compiled before it may be traced -- invoke ~A to compile"
             fn fn)))
          ((|isInterpOnlyMap| fn)
           (|sayBrightly|
            (format nil
               "~A cannot be traced because it is an interpret-only function"
               fn)))
          (t
            (|sayBrightly| (format nil "~A is not a function" fn)))))
      ((and (null bindef) (symbolp fn) (boundp fn)
              (|isDomainOrPackage| (setq fnval (eval fn))))
        (|spadTrace| fnval options))
      (t
        (when (setq u (getTraceOption options 'mask=))
          (makeprop fn '/transform (elt u 1)))
        (setq |$traceNames|
          (if (and options (getTraceOption options 'alias))
            |$traceNames|
            (cons fn |$traceNames|)))
        (setq tracename
          (cond
            ((setq u (getTraceOption options 'alias))
              (princ-to-string (elt u 1)))
            (t
              (when (and |$traceNoisely| (null vars)
                         (null (|isSubForRedundantMapName| fn)))
                 (|sayBrightly|
                  (list (|rassocSub| fn |$mapSubNameAlist|) "traced")))
              (princ-to-string fn))))
        (cond
          (|$fromSpadTrace|
           (when mathTrace (push (intern tracename) |$mathTraceList|))
           (setq letfuncode (list 'eq nil nil))
           (setq before
            (if (setq u (getTraceOption options 'before))
              (list 'progn (elt u 1) letfuncode)
              letfuncode)))
          (t
           (setq before
            (when (setq u (getTraceOption options 'before)) (elt u 1)))))
        (setq after
          (when (setq u (getTraceOption options 'after)) (elt u 1)))
        (setq caller (getTraceOption options 'caller))
        (setq fromCondition
          (if (setq u (getTraceOption options 'from))
            (list 'eq '|#9| (list 'quote (elt u 1)))
            t))
        (setq condition
          (if (setq u (getTraceOption options 'when))
            (elt u 1)
            t))
        (setq withinCondition t)
        (when (setq u (getTraceOption options 'within))
          (setq g 
           (intern (strconc (symbol-name fn) "/" (symbol-name (elt u 1)))))
          (set g 0)
          (trace2 (elt u 1) nil
            (list (list 'when nil)
                  (list 'before (list 'setq g (list '1+ g)))
                  (list 'after (list 'setq g (list '1- g)))))
            (setq withinCondition (list '> g 0)))
        (when (getTraceOption options 'count)
          (setq countnam (intern (strconc tracename '|,COUNT|))))
        (setq countCondition
          (cond
            ((setq u (getTraceOption options 'count))
              (setq |$countList| (|adjoinEqual| tracename |$countList|))
              (cond
                ((and (cdr u) (integerp (elt u 1)))
                  (list 'cond (list (list '<= countnam (elt u 1)) t)
                        (list t (list '|untrace2| (mkq fn) nil) nil)))
                (t t)))
            (t t)))
        (when (getTraceOption options 'timer)
          (setq timernam (intern (strconc tracename ",TIMER")))
          (setq |$timerList| (|adjoinEqual| tracename |$timerList|)))
        (setq depthCondition
         (if (setq u (getTraceOption options 'depth))
          (if (and (cdr u) (integerp (elt u 1)))
            (list '<= '|$monitorFunDepth| (elt u 1))
            (traceOptionError 'depth))
          t))
        (setq condition
         (mkpf
           (list condition withinCondition fromCondition
                 countCondition depthCondition)
           'and))
        (setq onlys (getTraceOption options 'only))
        (setq tracecode
         (cond
          ((getTraceOption options 'nt) "000")
          (t
            (setq onlys
              (mapcar #'(lambda (x) (if (integerp x) x (upcase x))) onlys))
            (setq f (or   (member 'f onlys) (member 'full onlys)))
            (setq a (or f (member 'a onlys) (member 'args onlys)))
            (setq v (or f (member 'v onlys) (member 'value onlys)))
            (setq c (or f (member 'c onlys) (member 'caller onlys)))
            (setq nl
              (if a 
                (list #\9)
                (loop for x in onlys 
                      when (and (integerp x) (< 0 x) (< x 9))
                      collect (char (princ-to-string x) 0))))
            (cond
             ((null (or a v c nl))
               (if caller "119" "019"))
             (t
              (setq nl (append nl (list #\0)))
              (setq buf (|make_spaces| (cond (a 3) (t (+ 2 (length nl))))))
              (setf (elt buf 0) (if (or c caller) #\1 #\0))
              (setf (elt buf 1) (if v #\1 #\0))
              (cond
                (a
                 (setf (elt buf 2) #\9)
                 buf)
                (t
                 (loop for x in nl for i from 2 do (setf (elt buf i) x))
                 buf)))))))
        (setq g4 (macro-function fn))
        (when countnam (set countnam 0))
        (when timernam (set timernam 0))
        (setq ll
         (list 'quote
          (list (intern tracename) (when g4 'macro)
                tracecode countnam timernam before after
                condition break modemap (list 'quote t))))
        (setq newDef
         (list (if g4 'mlambda 'lambda) (list '&rest 'g6)
               (list 'monitorX 'g6 fn ll)))
        (cond
         (binDef (embededFunction fn newDef binDef))
         (t
          (setq oldDef (symbol-function fn))
          (setq newDef (embededFunction fn new_def old_def))
          (embed2 fn new_def old_def)
          fn)))))))))

\end{chunk}

\defun{embededFunction}{embededFunction}
\calls{embededFunction}{flatBvList}
\begin{chunk}{defun embededFunction}
(defun embededFunction (name newDef oldDef)
 (let (body op bv)
  (setq newDef
   (cond
    ((null (consp newDef)) newDef)
    (t
      (setq body (cddr newDef))
      (setq op (car newDef))
      (if (and body (setq bv (cadr newDef))
                    (or (eq op 'lambda) (eq op 'mlambda)))
         (if (null (member name (flatBvList bv)))
          (list op bv
            (list
              (cons 'lambda (cons (list name) body))
              (list 'quote oldDef)))
          newDef)
        (break)))))
  (coerce newDef 'function)))

\end{chunk}

\defun{embed2}{embed2}
\sig{embed2}{Symbol,Function,Function}{Symbol}
\begin{chunk}{defun embed2 0}
(defun embed2 (name newDef oldDef)
 (declare (special |$embeddedFunctions|))
  (setf (symbol-function name) newDef)
  (push (list name newDef oldDef) |$embeddedFunctions|)
  name)

\end{chunk}

\defun{flatBvList}{flatBvList}
\calls{flatBvList}{varp}
\calls{flatBvList}{refvecp}
\calls{flatBvList}{flatBvList}
\calls{flatBvList}{nconc}
\begin{chunk}{defun flatBvList}
(defun flatBvList (bvlist)
 (let (tmp1)
  (cond
   ((varp bvlist) (list bvlist))
   ((refvecp bvlist) (break))
   ((null (consp bvlist)) nil)
   ((eq '= (setq tmp1 (car bvlist)))
     (flatBvList (cdr bvlist)))
   ((varp tmp1) (cons tmp1 (flatBvList (cdr bvlist))))
   ((and (null (consp tmp1)) (null (refvecp tmp1)))
     (flatBvList (cdr bvlist)))
   (t
    (nconc (flatBvList tmp1) (flatBvList (cdr bvlist)))))))

\end{chunk}

\defun{varp}{varp}
\begin{chunk}{defun var}
(defun varp (testItem)
 (cond
  ((identp testItem) testItem)
  ((and (consp testItem)
        (or (eq (car testItem) 'fluid) (eq (car testItem) 'lex))
        (consp (cdr testItem)) (identp (cadr testItem)))
    testItem)
  (t nil)))

\end{chunk}

\defun{monitorX}{monitorX}
\calls{monitorX}{monitorXX}
\usesdollar{monitorX}{monitorDepth}
\usesdollar{monitorX}{depthAlist}
\begin{chunk}{defun monitorX}
(defun monitorX (args funct opts)
 (declare (special |$monitorDepth| |$depthAlist|))
  (monitorXX args funct opts |$monitorDepth| |$depthAlist|))))

\end{chunk}

\defun{monitorXX}{monitorXX}
\calls{monitorXX}{stopTimer}
\calls{monitorXX}{rassocSub}
\calls{monitorXX}{whocalled}
\calls{monitorXX}{moan}
\calls{monitorXX}{monitorEvalTran}
\calls{monitorXX}{monitorEnter}
\calls{monitorXX}{monitorEvalBefore}
\calls{monitorXX}{break}
\calls{monitorXX}{startTimer}
\calls{monitorXX}{timerValue}
\calls{monitorXX}{monitorEvalAfter}
\calls{monitorXX}{monitorExit}
\usesdollar{monitorXX}{monitorArgs}
\usesdollar{monitorXX}{monitorValue}
\usesdollar{monitorXX}{monitorFunDepth}
\usesdollar{monitorXX}{depthAlist}
\usesdollar{monitorXX}{monitorCaller}
\usesdollar{monitorXX}{breakCondition}
\usesdollar{monitorXX}{monitorName}
\usesdollar{monitorXX}{monitorDepth}
\usesdollar{monitorXX}{tracedSpadModemap}
\usesdollar{monitorXX}{mathTrace}
\usesdollar{monitorXX}{mapSubNameAlist}
\begin{chunk}{defun monitorXX}
(defun monitorXX (|$monitorArgs| funct opts oldDepth oldDepthAlist)
 (declare (special |$monitorArgs|))
 (let (|$monitorValue| |$monitorFunDepth| |$depthAlist| |$monitorCaller|
       |$breakCondition| |$monitorName| |$monitorDepth|
       |$tracedSpadModemap| |$mathTrace| evalTime initTime yes
       notTopLevel a v c name1 breakcondition tracedmodemap break
       condition after before timernam countnam tracecode type name)
    (declare
     (special |$monitorValue| |$monitorFunDepth| |$depthAlist|
      |$monitorCaller| |$breakCondition| |$monitorName| |$monitorDepth|
      |$tracedSpadModemap| |$mathTrace| |$mapSubNameAlist|))
  (|stopTimer|)
  (setq name (elt opts 0))
  (setq type (elt opts 1))
  (setq tracecode (elt opts 2))
  (setq countnam (elt opts 3))
  (setq timernam (elt opts 4))
  (setq before (elt opts 5))
  (setq after (elt opts 6))
  (setq condition (elt opts 7))
  (setq break (elt opts 8))
  (setq tracedmodemap (elt opts 9))
  (setq breakcondition (elt opts 10))
  (setq |$mathTrace| nil)
  (setq |$tracedSpadModemap| tracedmodemap)
  (setq |$monitorDepth| (+ oldDepth 1))
  (setq |$monitorName| (symbol-name name))
  (setq name1 (|rassocSub| name |$mapSubNameAlist|))
  (setq |$breakCondition| breakcondition)
  (setq |$monitorCaller| (|rassocSub| (whocalled 6) |$mapSubNameAlist|))
  ;TRACECODE meaning:
  ; 0:        Caller (0,1)           print caller if 1
  ; 1:        Value (0,1)            print value if 1
  ; 2...:     Arguments (0,...,9)    stop if 0; print ith if i; all if 9
  (cond
   ((null (stringp tracecode))
     (moan "set tracecode to \\'1911\\' and restart"))
   (t
     (setq c (digit-char-p (elt tracecode 0)))
     (setq v (digit-char-p (elt tracecode 1)))
     (setq a (digit-char-p (elt tracecode 2)))
     (when countnam (set countnam (+ (eval countnam) 1)))
     (setq |$depthAlist| (copy-tree oldDepthAlist))
     (setq notTopLevel (assoc name |$depthAlist|))
     (if (null notTopLevel)
        (setq |$depthAlist| (cons (cons name 1) |$depthAlist|))
        (rplacd notTopLevel (+ (cdr notTopLevel) 1)))
     (setq |$monitorFunDepth| (cdr (assoc name |$depthAlist|)))
     (setq condition (monitorEvalTran condition nil))
     (setq yes (eval condition))
     (when (member name |$mathTraceList|) (setq |$mathTrace| t))
     (when (and yes |$TraceFlag|) (monitorEnter tracecode c type name name1))
     (when before (monitorEvalBefore before))
     (when (member '|before| break)
       (|break| (list "Break on entering" (symbol-name name1) ":")))
     (when timernam (setq initTime (|startTimer|)))
     (setq |$monitorValue|
       (if (eq type 'macro) 
        (macroexpand funct |$monitorArgs|)
        (apply funct |$monitorArgs|)))
     (|stopTimer|)
     (setq evalTime nil)
     (when timernam (setq evalTime (- (|timerValue|) initTime)))
     (when (and timernam (null notTopLevel))
       (set timernam (+ (eval timernam) evalTime)))
     (when after (monitorEvalAfter after))
     (when (and yes |$TraceFlag|)
       (monitorExit tracecode name name1 V timernam evalTime))
     (when (member '|after| break)
       (|break| (list "Break on exiting" (symbol-name name1) ":")))
     (|startTimer|)
     |$monitorValue|))))

\end{chunk}

\defun{monitorEvalBefore}{monitorEvalBefore}
\calls{monitorEvalBefore}{monitorEvalTran}
\begin{chunk}{defun monitorEvalBefore}
(defun monitorEvalBefore (x)
  (eval (monitorEvalTran x nil)))

\end{chunk}

\defun{monitorEvalAfter}{monitorEvalAfter}
\calls{monitorEvalAfter}{monitorEvalTran}
\begin{chunk}{defun monitorEvalAfter}
(defun monitorEvalAfter (x)
  (eval (monitorEvalTran x nil)))

\end{chunk}

\defun{monitorEvalTran}{monitorEvalTran}
\calls{monitorEvalTran}{hasSharpVar}
\calls{monitorEvalTran}{monitorEvalTran1}
\begin{chunk}{defun monitorEvalTran}
(defun monitorEvalTran (x fg)
 (if (|hasSharpVar| x) (monitorEvalTran1 x fg) x))

\end{chunk}

\defun{monitorEvalTran1}{monitorEvalTran1}
\calls{monitorEvalTran1}{monitorEvalTran1}
\calls{monitorEvalTran1}{isSharpVarWithNum}
\calls{monitorEvalTran1}{monitorGetValue}
\begin{chunk}{defun monitorEvalTran1}
(defun monitorEvalTran1 (x fg)
 (let (n)
  (cond
   ((setq n (|isSharpVarWithNum| x)) (monitorGetValue n fg))
   ((atom x) x)
   (t
    (cons (monitorEvalTran1 (car x) fg)
          (monitorEvalTran1 (cdr x) fg))))))

\end{chunk}

\defun{hasSharpVar}{hasSharpVar}
\calls{hasSharpVar}{hasSharpVar}
\calls{hasSharpVar}{isSharpVar}
\begin{chunk}{defun hasSharpVar}
(defun |hasSharpVar| (x)
 (cond
  ((and (atom x) (|isSharpVar| x)) t) 
  ((atom x) nil)
  (t (or (|hasSharpVar| (car x)) (|hasSharpVar| (cdr x))))))

\end{chunk}

\defun{monitorGetValue}{monitorGetValue}
\calls{monitorGetValue}{mkq}
\calls{monitorGetValue}{spadThrowBrightly}
\usesdollar{monitorGetValue}{monitorValue}
\usesdollar{monitorGetValue}{monitorCaller}
\usesdollar{monitorGetValue}{monitorName}
\usesdollar{monitorGetValue}{monitorArgs}
\begin{chunk}{defun monitorGetValue}
(defun monitorGetValue (n fg)
  (cond
   ((eql n 0)
     (if fg
      (mkq |$monitorValue|)
      (|spadThrowBrightly| "cannot ask for value before execution")))
   ((eql n 9) (mkq |$monitorCaller|))
   ((not (< (size |$monitorArgs|) n)) (mkq (elt |$monitorArgs| (- n 1))))
   (t
    (|spadThrowBrightly|
     (list 'function |$monitorName| "does not have" n "arguments")))))

\end{chunk}

\defun{traceReply}{traceReply}
\calls{traceReply}{sayMessage}
\calls{traceReply}{sayBrightly}
\calls{traceReply}{qcar}
\calls{traceReply}{isDomainOrPackage}
\calls{traceReply}{addTraceItem}
\calls{traceReply}{isFunctor}
\calls{traceReply}{isgenvar}
\calls{traceReply}{userError}
\calls{traceReply}{seq}
\calls{traceReply}{exit}
\calls{traceReply}{isSubForRedundantMapName}
\calls{traceReply}{rassocSub}
\calls{traceReply}{poundsign}
\calls{traceReply}{sayMSG}
\calls{traceReply}{sayBrightlyLength}
\calls{traceReply}{flowSegmentedMsg}
\calls{traceReply}{concat}
\calls{traceReply}{prefix2String}
\calls{traceReply}{abbreviate}
\usesdollar{traceReply}{domains}
\usesdollar{traceReply}{packages}
\usesdollar{traceReply}{constructors}
\usesdollar{traceReply}{linelength}
\usesdollar{traceReply}{traceNames}
\begin{chunk}{defun traceReply}
(defun traceReply ()
 (let (|$domains| |$packages| |$constructors| d functionList displayList)
  (declare (special |$domains| |$packages| |$constructors| |$traceNames|
     $linelength))
     (setq |$domains| nil)
     (setq |$packages| nil)
     (setq |$constructors| nil)
     (cond
      ((null |$traceNames|) (|sayMessage| "   Nothing is traced now."))
      (t
        (|sayBrightly| " ")
        (loop for x in |$traceNames| do
         (cond
          ((and (consp x) (|isDomainOrPackage| (car x)))
               (|addTraceItem| (car x)))
          ((atom x)
            (cond
              ((|isFunctor| x) (|addTraceItem| x))
              ((isgenvar x) (|addTraceItem| (eval x)))
              (t (setq functionList (cons x functionList)))))
          (t (|userError| "bad argument to trace"))))))
     (setq functionList
          (prog (t1)
           (setq t1 nil)
           (return
            (do ((t2 functionList (cdr t2)) (x nil))
                ((or (atom t2) (progn (setq x (car t2)) nil)) t1)
              (seq
               (exit
                (cond 
                 ((null (|isSubForRedundantMapName| x))
                   (setq t1 
                    (append t1 
                     (cons (|rassocSub| x |$mapSubNameAlist|)
                           (cons " " nil))))))))))))
     (cond 
        (functionList 
         (cond 
          ((eql 2 (|#| functionList))
             (|sayMSG| (cons '|   Function traced: | functionList)))
          ((<= (+ 22 (|sayBrightlyLength| functionList)) $linelength)
             (|sayMSG| (cons '|   Functions traced: | functionList)))
          (t 
             (|sayBrightly| "   Functions traced:")
             (|sayBrightly|
              (|flowSegmentedMsg| functionList $linelength 6))))))
     (when |$domains|
      (setq displayList
       (|concat| (|prefix2String| (car |$domains|))
        (loop for x in (cdr |$domains|) append
         (|concat| ", " (|prefix2String| x)))))
      (when (atom displayList) (setq displayList (list displayList)))
      (|sayBrightly| "   Domains traced: ")
      (|sayBrightly| (|flowSegmentedMsg| displayList $linelength 6)))
     (when |$packages|
      (setq displayList
       (|concat| (|prefix2String| (car |$packages|))
        (loop for x in (cdr |$packages|) append
         (|concat| ", " (|prefix2String| x)))))
      (when (atom displayList) (setq displayList (list displayList)))
      (|sayBrightly| "   Packages traced: ")
      (|sayBrightly| (|flowSegmentedMsg| displayList $linelength 6)))
     (when |$constructors|
      (setq displayList
       (|concat| (|abbreviate| (car |$constructors|))
        (loop for x in (cdr |$constructors|) append
         (|concat| ", " (|abbreviate| x)))))
      (when (atom displayList) (setq displayList (list displayList)))
      (|sayBrightly| "   Parameterized constructors traced:")
      (|sayBrightly| (|flowSegmentedMsg| displayList $linelength 6)))))

\end{chunk}

\defun{/options}{/options}
\calls{/options}{/options}
\calls{/options}{isFunctor}
\begin{chunk}{defun /options}
(defun /options (x)
 (cond
  ((atom x) nil)
  ((or (atom (car x)) (|isFunctor| (caar x))) (/options (cdr x)))
  (x)))
 
\end{chunk}

\defun{trunclist}{Truncate list L at the point marked by TL.}
Truncate list L at the point marked by TL.
\begin{chunk}{defun trunclist}
(defun trunclist (l tl) 
 (labels (
  (trunclist-1 (l tl)
   (cond
    ((atom l) l)
    ((eql (cdr l) tl) (rplacd l nil))
    ((trunclist-1 (cdr l) tl)))))
 (let ((u l))
  (trunclist-1 l tl)
  u)))

\end{chunk}

\defun{resetTimers}{resetTimers}
\calls{resetTimers}{concat}
\usesdollar{resetTimers}{timerList}
\begin{chunk}{defun resetTimers}
(defun |resetTimers| ()
 (declare (special |$timerList|))
 (dolist (timer |$timerList|)
  (set (intern (concat timer ",TIMER")) 0)))

\end{chunk}

\defun{resetSpacers}{resetSpacers}
\calls{resetSpacers}{concat}
\usesdollar{resetSpacers}{spaceList}
\begin{chunk}{defun resetSpacers}
(defun |resetSpacers| ()
 (declare (special |$spaceList|))
 (dolist (spacer |$spaceList|)
   (set (intern (concat spacer ",SPACE")) 0)))

\end{chunk}
\defun{resetCounters}{resetCounters}
\calls{resetCounters}{concat}
\usesdollar{resetCounters}{countList}
\begin{chunk}{defun resetCounters}
(defun |resetCounters| ()
 (declare (special |$countList|))
 (dolist (k |$countList|)
  (set (intern (concat k ",COUNT")) 0)))

\end{chunk}

\defun{ptimers}{ptimers}
\calls{ptimers}{sayBrightly}
\calls{ptimers}{bright}
\calls{ptimers}{quotient}
\calls{ptimers}{concat}
\calls{ptimers}{float}
\usesdollar{ptimers}{timerList}
\usesdollar{ptimers}{timerTicksPerSecond}
\begin{chunk}{defun ptimers}
(defun |ptimers| ()
  (declare (special |$timerList| |$timerTicksPerSecond|))
  (if (null |$timerList|) 
   (|sayBrightly| "   no functions are timed")
   (dolist (timer |$timerList|)
     (|sayBrightly|
      `("  " ,@(|bright| timer) |:| " "
         ,(quotient (eval (intern (concat timer ",TIMER")))
            (float |$timerTicksPerSecond|)) " sec.")))))

\end{chunk}

\defun{pspacers}{pspacers}
\calls{pspacers}{sayBrightly}
\calls{pspacers}{bright}
\calls{pspacers}{concat}
\usesdollar{pspacers}{spaceList}
\begin{chunk}{defun pspacers}
(defun |pspacers| ()
 (declare (special |$spaceList|))
 (if (null |$spaceList|)
   (|sayBrightly| "   no functions have space monitored")
   (dolist (spacer |$spaceList|)
     (|sayBrightly|
      `("  " ,@(|bright| spacer) |: | 
        ,(eval (intern (concat spacer ",SPACE"))) " bytes")))))

\end{chunk}

\defun{pcounters}{pcounters}
\calls{pcounters}{sayBrightly}
\calls{pcounters}{bright}
\calls{pcounters}{concat}
\usesdollar{pcounters}{countList}
\begin{chunk}{defun pcounters}
(defun |pcounters| ()
 (declare (special |$countList|))
 (if (null |$countList|) 
   (|sayBrightly| "   no functions are being counted")
   (dolist (k |$countList|)
     (|sayBrightly|
      `("  " ,@(|bright| k) |:| " " ,(eval (intern (concat k ",COUNT")))
        " times")))))

\end{chunk}

\defun{transOnlyOption}{transOnlyOption}
\calls{transOnlyOption}{transOnlyOption}
\calls{transOnlyOption}{upcase}
\calls{transOnlyOption}{stackTraceOptionError}
\calls{transOnlyOption}{qcar}
\calls{transOnlyOption}{qcdr}
\begin{chunk}{defun transOnlyOption}
(defun |transOnlyOption| (arg)
 (let (y n)
  (when (and (consp arg) (progn (setq n (qcar arg)) (setq y (qcdr arg)) t))
    (cond
     ((integerp n) (cons n (|transOnlyOption| y)))
     ((member (setq n (upcase n)) '(v a c)) (cons n (|transOnlyOption| y)))
     (t 
        (|stackTraceOptionError|
         (cons
          "%1 The )trace option )only does not permit %2 as a legal option."
          (list (list n))))
        (|transOnlyOption| y))))))

\end{chunk}

\defun{stackTraceOptionError}{stackTraceOptionError}
\usesdollar{stackTraceOptionError}{traceErrorStack}
\begin{chunk}{defun stackTraceOptionError}
(defun |stackTraceOptionError| (x)
 (declare (special |$traceErrorStack|))
 (push x |$traceErrorStack|)
 nil)

\end{chunk}

\defun{removeOption}{removeOption}
\sig{removeOption}{Option}{List Option}
\begin{chunk}{defun removeOption 0}
(defun removeOption (op options)
 (loop for optentry in options 
  when (not (equal (car optentry) op))
  collect optentry))

\end{chunk}

\defun{domainToGenvar}{domainToGenvar}
For a call to trace, such as 
\begin{verbatim}
   )trace POLY(INT)
\end{verbatim}
This would be called with
\begin{verbatim}
   (POLY INT)
\end{verbatim}
which gets unabbreviated to the full form of
\begin{verbatim}
   (|Polynomail| (|Integer|))
\end{verbatim}

Since {\bf Polynomial} is a domain we call {\bf genDomainTraceName}
to add it to the global alist \verb|$domainTraceNameAssoc|, which
returns a unique new genvar, say \verb|$1|. We then set the value
of \verb|$1| to the domain (a vector), returning it as the result.
\calls{domainToGenvar}{unabbrevAndLoad}
\calls{domainToGenvar}{getdatabase}
\calls{domainToGenvar}{opOf}
\calls{domainToGenvar}{genDomainTraceName}
\calls{domainToGenvar}{evalDomain}
\usesdollar{domainToGenvar}{doNotAddEmptyModeIfTrue}
\begin{chunk}{defun domainToGenvar}
(defun |domainToGenvar| (arg)
 (let (|$doNotAddEmptyModeIfTrue| y g)
 (declare (special |$doNotAddEmptyModeIfTrue|))
  (setq |$doNotAddEmptyModeIfTrue| t)
  (when
   (and (setq y (|unabbrevAndLoad| arg))
        (eq (getdatabase (|opOf| y) 'constructorkind) '|domain|))
     (setq g (|genDomainTraceName| y))
     (set g (|evalDomain| y))
     g)))

\end{chunk}

\defun{subTypes}{subTypes}
\calls{subTypes}{lassoc}
\calls{subTypes}{seq}
\calls{subTypes}{exit}
\calls{subTypes}{subTypes}
\begin{chunk}{defun subTypes}
(defun |subTypes| (|mm| |sublist|)
 (prog (s)
  (return
   (seq
    (cond
     ((atom |mm|) 
       (cond ((setq s (lassoc |mm| |sublist|)) s) (t |mm|)))
     (t
      (prog (t0)
       (setq t0 nil)
       (return
        (do ((t1 |mm| (cdr t1)) (|m| nil))
            ((or (atom t1) (progn (setq |m| (car t1)) nil)) (nreverse0 t0))
         (seq
          (exit
           (setq t0 (cons (|subTypes| |m| |sublist|) t0))))))))))))) 

\end{chunk}

\defun{isListOfIdentifiers}{isListOfIdentifiers}
\calls{isListOfIdentifiers}{seq}
\calls{isListOfIdentifiers}{exit}
\calls{isListOfIdentifiers}{identp}
\begin{chunk}{defun isListOfIdentifiers}
(defun |isListOfIdentifiers| (arg)
 (prog () 
  (return
   (seq
    (prog (t0)
     (setq t0 t)
     (return
      (do ((t1 nil (null t0)) (t2 arg (cdr t2)) (x nil))
          ((or t1 (atom t2) (progn (setq x (car t2)) nil)) t0)
       (seq
        (exit
         (setq t0 (and t0 (identp x)))))))))))) 

\end{chunk}

\defun{isListOfIdentifiersOrStrings}{isListOfIdentifiersOrStrings}
\calls{isListOfIdentifiersOrStrings}{seq}
\calls{isListOfIdentifiersOrStrings}{exit}
\calls{isListOfIdentifiersOrStrings}{identp}
\begin{chunk}{defun isListOfIdentifiersOrStrings}
(defun |isListOfIdentifiersOrStrings| (arg)
 (prog () 
  (return
   (seq
    (prog (t0)
     (setq t0 t)
     (return
      (do ((t1 nil (null t0)) (t2 arg (cdr t2)) (x nil))
          ((or t1 (atom t2) (progn (setq x (car t2)) nil)) t0)
       (seq
        (exit
         (setq t0 (and t0 (or (identp x) (stringp x))))))))))))) 

\end{chunk}

\defun{getPreviousMapSubNames}{getPreviousMapSubNames}
\calls{getPreviousMapSubNames}{get}
\calls{getPreviousMapSubNames}{exit}
\calls{getPreviousMapSubNames}{seq}
\usesdollar{getPreviousMapSubNames}{InteractiveFrame}
\begin{chunk}{defun getPreviousMapSubNames}
(defun |getPreviousMapSubNames| (Names)
 (let (lmm subs)
 (declare (special |$InteractiveFrame|))
  (loop for mapName in (assocleft (caar |$InteractiveFrame|)) do
   (when (setq lmm (|get| mapname '|localModemap| |$InteractiveFrame|))
    (when (member (cadar lmm) Names)
     (loop for mm in lmm do
      (setq subs (cons (cons mapname (cadr mm)) subs))))))
  subs))

\end{chunk}

\defun{lassocSub}{lassocSub}
\calls{lassocSub}{lassq}
\begin{chunk}{defun lassocSub}
(defun |lassocSub| (x subs)
 (let (y) 
  (if (setq y (lassq x subs)) 
    y
    x)))

\end{chunk}

\defun{rassocSub}{rassocSub}
\calls{rassocSub}{rassoc}
\begin{chunk}{defun rassocSub}
(defun |rassocSub| (x subs)
 (let (y)
   (if (setq y (|rassoc| x subs)) 
    y
    x)))

\end{chunk}

\defun{isUncompiledMap}{isUncompiledMap}
\calls{isUncompiledMap}{get}
\usesdollar{isUncompiledMap}{InteractiveFrame}
\begin{chunk}{defun isUncompiledMap}
(defun |isUncompiledMap| (x)
 (let (y)
 (declare (special |$InteractiveFrame|))
  (when (setq y (|get| x '|value| |$InteractiveFrame|))
    (and
      (eq (caar y) 'map)
      (null (|get| x '|localModemap| |$InteractiveFrame|))))))

\end{chunk}

\defun{isInterpOnlyMap}{isInterpOnlyMap}
\calls{isInterpOnlyMap}{get}
\usesdollar{isInterpOnlyMap}{InteractiveFrame}
\begin{chunk}{defun isInterpOnlyMap}
(defun |isInterpOnlyMap| (map)
 (let (x)
 (declare (special |$InteractiveFrame|))
  (when (setq x (|get| map '|localModemap| |$InteractiveFrame|))
    (eq (caaar x) '|interpOnly|))))

\end{chunk}


\defun{isSubForRedundantMapName}{isSubForRedundantMapName}
\calls{isSubForRedundantMapName}{rassocSub}
\calls{isSubForRedundantMapName}{member}
\calls{isSubForRedundantMapName}{assocleft}
\usesdollar{isSubForRedundantMapName}{mapSubNameAlist}
\begin{chunk}{defun isSubForRedundantMapName}
(defun |isSubForRedundantMapName| (subname)
 (let (mapname tail)
 (declare (special |$mapSubNameAlist|))
  (when (setq mapname (|rassocSub| subname |$mapSubNameAlist|))
    (when (setq tail 
           (member (cons mapname subname) |$mapSubNameAlist| :test #'equalp))
      (member mapname (cdr (assocleft tail)))))))

\end{chunk}

\defun{untraceMapSubNames}{untraceMapSubNames}
\calls{untraceMapSubNames}{assocright}
\calls{untraceMapSubNames}{/untrace,2}
\calls{untraceMapSubNames}{setdifference}
\calls{untraceMapSubNames}{getPreviousMapSubNames}
\usesdollar{untraceMapSubNames}{mapSubNameAlist}
\usesdollar{untraceMapSubNames}{lastUntraced}
\usesdollar{untraceMapSubNames}{traceNames}
\begin{chunk}{defun untraceMapSubNames}
(defun |untraceMapSubNames| (names)
 (let (|$mapSubNameAlist| subs)
 (declare (special |$mapSubNameAlist| |$lastUntraced|))
  (if
   (null (setq |$mapSubNameAlist| (|getPreviousMapSubNames| names)))
   nil
   (dolist (name (setq subs (assocright |$mapSubNameAlist|)))
     (when (member name |$traceNames|)
       (|/UNTRACE,2| name nil)
       (setq |$lastUntraced| (setdifference |$lastUntraced| subs)))))))

\end{chunk}

\defun{funfind,LAM}{funfind,LAM}
\calls{funfind,LAM}{qcar}
\calls{funfind,LAM}{SEQ}
\calls{funfind,LAM}{isFunctor}
\calls{funfind,LAM}{exit}
\begin{chunk}{defun funfind,LAM}
(defun |funfind,LAM| (functor opname)
 (prog (ops tmp1)
  (return
   (seq
    (progn
     (setq ops (|isFunctor| functor))
     (prog (t0)
      (setq t0 nil)
      (return
       (do ((t1 ops (cdr t1)) (u nil))
           ((or (atom t1) (progn (setq u (car t1)) nil)) (nreverse0 t0))
        (seq
         (exit
          (cond
           ((and (consp u)
                 (progn
                  (setq tmp1 (qcar u))
                  (and (consp tmp1) (equal (qcar tmp1) opname))))
             (setq t0 (cons u t0)))))))))))))) 

\end{chunk}

\defmacro{funfind}
\begin{chunk}{defmacro funfind}
(defmacro |funfind| (&whole t0 &rest notused)
 (declare (ignore notused))
 (let (t1 t0)
  (cons '|funfind,LAM| (wrap (cdr t1) '(quote quote)))))

\end{chunk}

\defun{isDomainOrPackage}{isDomainOrPackage}
\calls{isDomainOrPackage}{refvecp}
\calls{isDomainOrPackage}{poundsign}
\calls{isDomainOrPackage}{isFunctor}
\calls{isDomainOrPackage}{opOf}
\begin{chunk}{defun isDomainOrPackage}
(defun |isDomainOrPackage| (dom)
 (and
  (refvecp dom)
  (> (|#| dom) 0)
  (|isFunctor| (|opOf| (elt dom 0))))) 

\end{chunk}

\defun{flattenOperationAlist}{flattenOperationAlist}
The operation alist for something like POLY(INT) is a list of
operations. Each operation, such as '*' is a list of all possible
signatures for '*'. For example, the operation alist looks like:
\begin{verbatim}
   (* (($ (|PositiveInteger|) $) NIL . (T . (ELT)))
      (($ $ $) NIL . (T . (ELT)))
      (($ $ |#1|) NIL . (T . (ELT)))
      (($ |#1| $) NIL . (T . (ELT)))
      (($ (|Fraction| (|Integer|))) NIL
       (|has| |#1| (|Algebra| (|Fraction| (|Integer|)))) . (ELT))
      ....)
\end{verbatim}
This function rearranges the operations so that each signature
is independent. Thus it becomes
\begin{verbatim}
   (* (($ (|PositiveInteger|) $) NIL . (T . (ELT))))
   (* (($ $ $) NIL . (T . (ELT))))
   (* (($ $ |#1|) NIL . (T . (ELT))))
   (* (($ |#1| $) NIL . (T . (ELT))))
   (* (($ (|Fraction| (|Integer|))) NIL
       (|has| |#1| (|Algebra| (|Fraction| (|Integer|)))) . (ELT)))
      ....
\end{verbatim}
\sig{flattenOperationAlist}{OperationAlist}{OperationAlist}
\begin{chunk}{defun flattenOperationAlist 0}
(defun flattenOperationAlist (opAlist)
 (let (res)
  (loop for t1 in opAlist do
   (setq res
    (append res (loop for mm in (cdr t1) collect (cons (car t1) mm)))))
  res))

\end{chunk}

\defun{letPrint}{letPrint}
\calls{letPrint}{lassoc}
\calls{letPrint}{isgenvar}
\calls{letPrint}{isSharpVarWithNum}
\calls{letPrint}{gensymp}
\calls{letPrint}{sayBrightlyNT}
\calls{letPrint}{bright}
\calls{letPrint}{shortenForPrinting}
\calls{letPrint}{hasPair}
\calls{letPrint}{pname}
\calls{letPrint}{break}
\usesdollar{letPrint}{letAssoc}
\begin{chunk}{defun letPrint}
(defun |letPrint| (x |val| |currentFunction|)
 (prog (y)
 (declare (special |$letAssoc|))
  (return
   (progn
    (cond ((and |$letAssoc| 
                (or
                 (setq y (lassoc |currentFunction| |$letAssoc|))
                 (setq y (lassoc '|all| |$letAssoc|))))
     (cond
      ((and (or (eq y '|all|)
                 (member x y))
            (null 
             (or (isgenvar x) (|isSharpVarWithNum| x) (gensymp x))))
        (|sayBrightlyNT| (append (|bright| x) (cons '|: | nil)))
        (prin1 (|shortenForPrinting| |val|))
        (terpri)))
     (cond
      ((and (setq y (|hasPair| 'break y))
            (or (eq y '|all|)
                (and (member x y)
                     (null (member (elt (pname x) 0) '($ |#|)))
                     (null (gensymp x)))))
       (|break|
        (append 
         (|bright| |currentFunction|)
         (cons "breaks after"
          (append
           (|bright| x)
           (cons ":= " (cons (|shortenForPrinting| |val|) nil)))))))
      (t nil))))
    |val|)))) 

\end{chunk}

\defun{isSharpVarWithNum}{Identifier beginning with a sharpsign-number?}
This tests if x is an identifier beginning with \verb|#| followed by a number.

\calls{isSharpVarWithNum}{isSharpVar}
\calls{isSharpVarWithNum}{pname}
\calls{isSharpVarWithNum}{qcsize}
\calls{isSharpVarWithNum}{digitp}
\calls{isSharpVarWithNum}{dig2fix}
\begin{chunk}{defun isSharpVarWithNum}
(defun |isSharpVarWithNum| (x)
 (let (p n d ok c)
  (cond
   ((null (|isSharpVar| x)) nil)
   ((> 2 (setq n (qcsize (setq p (pname x))))) nil)
   (t
    (setq ok t)
    (setq c 0)
    (do ((t1 (1- n)) (i 1 (1+ i)))
         ((or (> i t1) (null ok)) nil)
      (setq d (elt p i))
      (when (setq ok (digitp d))
        (setq c (+ (* 10 c) (dig2fix d)))))
    (when ok c)))))

\end{chunk}

\defun{isSharpVar}{Identifier beginning with a sharpsign?}
This tests if x is an identifier beginning with \verb|#|

\calls{isSharpVar}{identp}
\begin{chunk}{defun isSharpVar}
(defun |isSharpVar| (x)
 (and (symbolp x)
      (eql (elt (symbol-name x) 0) #\#)))
;      (integerp (parse-integer (symbol-name x) :start 1))))

\end{chunk}

\defun{letPrint2}{letPrint2}
\catches{letPrint2}{letPrint2}
\calls{letPrint2}{lassoc}
\calls{letPrint2}{isgenvar}
\calls{letPrint2}{isSharpVarWithNum}
\calls{letPrint2}{gensymp}
\calls{letPrint2}{mathprint}
\calls{letPrint2}{print}
\calls{letPrint2}{hasPair}
\calls{letPrint2}{pname}
\calls{letPrint2}{break}
\calls{letPrint2}{bright}
\usesdollar{letPrint2}{BreakMode}
\usesdollar{letPrint2}{letAssoc}
\begin{chunk}{defun letPrint2}
(defun |letPrint2| (x |printform| |currentFunction|)
 (prog (|$BreakMode| |flag| y)
  (declare (special |$BreakMode| |$letAssoc|))
  (return
   (progn
    (setq |$BreakMode| nil)
    (cond
     ((and |$letAssoc| 
           (or (setq y (lassoc |currentFunction| |$letAssoc|))
               (setq y (lassoc '|all| |$letAssoc|))))
      (cond
       ((and
          (or (eq y '|all|) (member x y))
          (null (or (isgenvar x) (|isSharpVarWithNum| x) (gensymp x))))
         (setq |$BreakMode| '|letPrint2|)
         (setq |flag| nil)
         (catch '|letPrint2| 
          (|mathprint| (cons '= (cons x (cons |printform| nil)))) |flag|)
         (cond 
          ((eq |flag| '|letPrint2|) (|print| |printform|))
          (t nil))))
      (cond 
       ((and 
         (setq y (|hasPair| 'break y))
         (or (eq y '|all|)
             (and 
              (member x y)
              (null (member (elt (pname x) 0) '($ |#|)))
              (null (gensymp x)))))
        (|break|
         (append
          (|bright| |currentFunction|)
          (cons "breaks after" 
           (append (|bright| x) (cons '|:= | (cons |printform| nil)))))))
       (t nil))))
    x)))) 

\end{chunk}

\defun{letPrint3}{letPrint3}
This is the version for use when we have our hands on a function
to convert the data into type "Expression"
\catches{letPrint3}{letPrint2}
\calls{letPrint3}{lassoc}
\calls{letPrint3}{isgenvar}
\calls{letPrint3}{isSharpVarWithNum}
\calls{letPrint3}{gensymp}
\calls{letPrint3}{mathprint}
\calls{letPrint3}{spadcall}
\calls{letPrint3}{print}
\calls{letPrint3}{hasPair}
\calls{letPrint3}{pname}
\calls{letPrint3}{break}
\calls{letPrint3}{bright}
\usesdollar{letPrint3}{BreakMode}
\usesdollar{letPrint3}{letAssoc}
\begin{chunk}{defun letPrint3}
(defun |letPrint3| (x |xval| |printfn| |currentFunction|)
 (prog (|$BreakMode| |flag| y)
  (declare (special |$BreakMode| |$letAssoc|))
  (return
   (progn
    (setq |$BreakMode| nil)
    (cond
     ((and |$letAssoc| 
       (or (setq y (lassoc |currentFunction| |$letAssoc|))
           (setq y (lassoc '|all| |$letAssoc|))))
       (cond
        ((and
           (or (eq y '|all|) (member x y))
           (null (or (isgenvar x) (|isSharpVarWithNum| x) (gensymp x))))
          (setq |$BreakMode| '|letPrint2|)
          (setq |flag| nil)
          (catch '|letPrint2|
           (|mathprint|
            (cons '= (cons x (cons (spadcall |xval| |printfn|) nil))))
           |flag|)
          (cond
           ((eq |flag| '|letPrint2|) (|print| |xval|))
           (t nil))))
       (cond
        ((and
          (setq y (|hasPair| 'break y))
          (or
           (eq y '|all|)
           (and
            (member x y)
            (null (member (elt (pname x) 0) '($ |#|)))
            (null (gensymp x)))))
          (|break|
           (append
            (|bright| |currentFunction|)
            (cons "breaks after"
             (append (|bright| x) (cons ":= " (cons |xval| nil)))))))
        (t nil))))
    x)))) 

\end{chunk}

\defun{hasPair}{hasPair}
\calls{hasPair}{qcar}
\calls{hasPair}{qcdr}
\calls{hasPair}{hasPair}
\begin{chunk}{defun hasPair}
(defun |hasPair| (key arg)
 (prog (tmp1 a)
  (return 
   (cond
    ((atom arg) nil)
    ((and (consp arg)
          (progn
           (setq tmp1 (qcar arg))
           (and (consp tmp1)
                (equal (qcar tmp1) key)
                (progn (setq a (qcdr tmp1)) t))))
       a)
    (t (|hasPair| key (cdr arg))))))) 

\end{chunk}

\defun{shortenForPrinting}{shortenForPrinting}
\calls{shortenForPrinting}{isDomainOrPackage}
\calls{shortenForPrinting}{devaluate}
\begin{chunk}{defun shortenForPrinting}
(defun |shortenForPrinting| (|val|)
 (if (|isDomainOrPackage| |val|)
  (|devaluate| |val|)
  |val|))

\end{chunk}

\defun{getOption}{getOption}
\calls{getOption}{assoc}
\begin{chunk}{defun getOption}
(defun getOption (opt l)
 (let (y)
  (when (setq y (|assoc| opt l))  (cdr y))))

\end{chunk}

\defun{orderBySlotNumber}{orderBySlotNumber}
\calls{orderBySlotNumber}{seq}
\calls{orderBySlotNumber}{assocright}
\calls{orderBySlotNumber}{orderList}
\calls{orderBySlotNumber}{exit}
\begin{chunk}{defun orderBySlotNumber}
(defun |orderBySlotNumber| (arg)
 (prog (n)
  (return 
   (seq
    (assocright
     (|orderList|
      (prog (t0)
       (setq t0 nil)
       (return
        (do ((t1 arg (cdr t1)) (x nil))
            ((or (atom t1)
                 (progn (setq x (car t1)) nil)
                 (progn (progn (setq n (caddr x)) x) nil))
               (nreverse0 t0))
         (seq
          (exit
           (setq t0 (cons (cons n x) t0))))))))))))) 

\end{chunk}

\defun{spadReply}{spadReply}
Collect all of the print names of the \verb|$traceNames|
\calls{spadReply}{isDomainOrPackage}
\usesdollar{spadReply}{traceNames}
\begin{chunk}{defun spadReply}
(defun |spadReply| ()
 (declare (special |$traceNames|))
 (loop for x in |$traceNames| collect 
  (if (and (consp x) (|isDomainOrPackage| (car x)))
   (|devaluate| (car x))
   x)))

\end{chunk}

\defun{remover}{remover}
\calls{remover}{remover}
\begin{chunk}{defun remover}
(defun remover (lst item)
 (cond
  ((null (consp lst)) (cond ((equal lst item) nil) (t lst)))
  ((equal (car lst) item) (cdr lst))
  (t
   (rplnode lst (remover (car lst) item) (remover (cdr lst) item))
   (rplaca lst (remover (car lst) item))
   (rplacd lst (remover (cdr lst) item))
   lst)))

\end{chunk}

\defun{stupidIsSpadFunction}{stupidIsSpadFunction}
\calls{stupidIsSpadFunction}{strpos}
\calls{stupidIsSpadFunction}{pname}
\begin{chunk}{defun stupidIsSpadFunction}
(defun |stupidIsSpadFunction| (fn)
 (strpos ";" (pname fn) 0 nil)) 

\end{chunk}

\defun{compileBoot}{compileBoot}
\calls{compileBoot}{/D,1}
\begin{chunk}{defun compileBoot}
(defun |compileBoot| (fn)
 (|/D,1| (list fn) '(/comp) nil nil)) 

\end{chunk}

\defun{getTraceOptions}{getTraceOptions}
\calls{getTraceOptions}{throwKeyedMsg}
\calls{getTraceOptions}{throwListOfKeyedMsgs}
\calls{getTraceOptions}{poundsign}
\calls{getTraceOptions}{seq}
\calls{getTraceOptions}{exit}
\calls{getTraceOptions}{getTraceOption}
\usesdollar{getTraceOptions}{traceErrorStack}
\begin{chunk}{defun getTraceOptions}
(defun getTraceOptions (options)
 (prog (|$traceErrorStack| optionlist temp1 key |parms|)
  (declare (special |$traceErrorStack|))
  (return
   (seq
    (progn
     (setq |$traceErrorStack| nil)
     (setq optionlist
      (prog (t0) 
       (setq t0 nil)
       (return
        (do ((t1 options (cdr t1)) (x nil))
            ((or (atom t1) (progn (setq x (car t1)) nil)) (nreverse0 t0))
         (seq
          (exit
           (setq t0 (cons (|getTraceOption| x) t0))))))))
     (cond
      (|$traceErrorStack|
       (cond
        ((null (cdr |$traceErrorStack|))
          (setq temp1 (car |$traceErrorStack|))
          (setq key (car temp1))
          (setq |parms| (cadr temp1))
          (|throwKeyedMsg| key (cons "" |parms|)))
        (t
          (|throwListOfKeyedMsgs| 
           "There are %1 problems with your )trace system command:"
           (cons (|#| |$traceErrorStack|) nil)
           (nreverse |$traceErrorStack|)))))
      (t optionlist))))))) 

\end{chunk}

\defun{saveMapSig}{saveMapSig}
\calls{saveMapSig}{rassoc}
\calls{saveMapSig}{addassoc}
\calls{saveMapSig}{getMapSig}
\usesdollar{saveMapSig}{tracedMapSignatures}
\usesdollar{saveMapSig}{mapSubNameAlist}
\begin{chunk}{defun saveMapSig}
(defun |saveMapSig| (funnames)
 (let (map)
 (declare (special |$tracedMapSignatures| |$mapSubNameAlist|))
  (dolist (name funnames)
   (when (setq map (|rassoc| name |$mapSubNameAlist|))
     (setq |$tracedMapSignatures|
       (addassoc name (|getMapSig| map name) |$tracedMapSignatures|))))))

\end{chunk}

\defun{getMapSig}{getMapSig}
\calls{getMapSig}{get}
\calls{getMapSig}{boot-equal}
\usesdollar{getMapSig}{InteractiveFrame}
\begin{chunk}{defun getMapSig}
(defun |getMapSig| (mapname subname)
 (let (lmms sig)
 (declare (special |$InteractiveFrame|))
  (when (setq lmms (|get| mapname '|localModemap| |$InteractiveFrame|))
    (do ((t0 lmms (cdr t0)) (mm nil) (t1 nil sig))
        ((or (atom t0) (progn (setq mm (car t0)) nil) t1) nil)
      (when (equal (cadr mm) subname) (setq sig (cdar mm))))
    sig)))

\end{chunk}

\defun{getTraceOption,hn}{getTraceOption,hn}
\calls{getTraceOption,hn}{seq}
\calls{getTraceOption,hn}{exit}
\calls{getTraceOption,hn}{isDomainOrPackage}
\calls{getTraceOption,hn}{stackTraceOptionError}
\calls{getTraceOption,hn}{domainToGenvar}
\begin{chunk}{defun getTraceOption,hn}
(defun |getTraceOption,hn| (x)
 (let (g)
  (cond
   ((and (atom x) (null (upper-case-p (elt (stringimage x) 0))))
     (cond
      ((|isDomainOrPackage| (eval x)) x)
      (t
       (|stackTraceOptionError|
        (cons
         (format nil
           "%1 The )trace option )of should be followed by the name of a ~
           domain and %2 is not one.")
          (list (list x)))))))
   ((setq g (|domainToGenvar| x)) g)
   (t (|stackTraceOptionError|
       (cons
        (format nil
         "%1 The )trace option )of should be followed by the name of a ~
          domain and %2 is not one.")
         (list (list x))))))))

\end{chunk}

\defun{getTraceOption}{getTraceOption}
\calls{getTraceOption}{seq}
\calls{getTraceOption}{exit}
\calls{getTraceOption}{selectOptionLC}
\calls{getTraceOption}{identp}
\calls{getTraceOption}{stackTraceOptionError}
\calls{getTraceOption}{concat}
\calls{getTraceOption}{object2String}
\calls{getTraceOption}{transOnlyOption}
\calls{getTraceOption}{qcdr}
\calls{getTraceOption}{qcar}
\calls{getTraceOption}{getTraceOption,hn}
\calls{getTraceOption}{isListOfIdentifiersOrStrings}
\calls{getTraceOption}{isListOfIdentifiers}
\calls{getTraceOption}{throwKeyedMsg}
\usesdollar{getTraceOption}{traceOptionList}
\begin{chunk}{defun getTraceOption}
(defun |getTraceOption| (arg)
 (prog (l opts key a n)
 (declare (special |$traceOptionList|))
  (return
   (seq
    (progn
     (setq key (car arg))
     (setq l (cdr arg))
     (setq key (|selectOptionLC| key |$traceOptionList| '|traceOptionError|))
     (setq arg (cons key l))
     (cond
      ((member key '(|nonquietly| |timer| |nt|)) arg)
      ((eq key '|break|)
       (cond
        ((null l) (cons '|break| (cons '|before| nil)))
        (t
          (setq opts
           (loop for y in l collect 
            (|selectOptionLC| y '(|before| |after|) nil)))
          (cond
           ((prog (t2)
             (setq t2 t)
             (return 
              (do ((t3 nil (null t2)) (t4 opts (cdr t4)) (y nil))
                  ((or t3 (atom t4) (progn (setq y (car t4)) nil)) t2)
                 (seq
                  (exit
                   (setq t2 (and t2 (identp y))))))))
              (cons '|break| opts))
           (t
            (|stackTraceOptionError| 
             (cons
              (format nil
               "%1 The )trace option )break can only have one or both of ~
               before and after as arguments.")
              (cons nil nil))))))))
      ((eq key '|restore|)
       (cond
        ((null l) arg)
        (t 
         (|stackTraceOptionError| 
          (cons "%1 The )trace option %2 can have no arguments."
           (cons (cons (concat ")" (|object2String| key)) nil) nil))))))
      ((eq key '|only|) (cons '|only| (|transOnlyOption| l)))
      ((eq key '|within|)
        (cond
         ((and (consp l) 
               (eq (qcdr l) nil)
               (progn (setq a (qcar l)) t)
               (identp a))
           arg)
         (t 
           (|stackTraceOptionError| 
            (cons 
             "%1 The )trace option %2 takes exactly one name as an argument."
             (cons (cons ")within" nil) nil))))))
      ((member key '(|cond| |before| |after|))
        (setq key 
         (cond 
          ((eq key '|cond|) '|when|)
          (t key)))
        (cond
         ((and (consp l) 
               (eq (qcdr l) nil)
               (progn (setq a (qcar l)) t))
            (cons key l))
         (t 
          (|stackTraceOptionError|
           (cons 
         "%1 The )trace option %2 takes exactly one expression as an argument."
            (cons
             (cons (concat ")"
              (|object2String| key)) nil) nil))))))
      ((eq key '|depth|)
        (cond 
         ((and (consp l) 
               (eq (qcdr l) nil)
               (progn (setq n (qcar l)) t)
               (integerp n))
           arg)
         (t 
          (|stackTraceOptionError| 
           (cons 
            "%1 The )trace option %2 takes exactly one integer argument."
            (cons (cons ")depth" nil) nil))))))
      ((eq key '|count|)
        (cond 
         ((or (null l) 
              (and (consp l) 
                   (eq (qcdr l) nil)
                   (progn (setq n (qcar l)) t)
                   (integerp n)))
            arg)
         (t 
          (|stackTraceOptionError|
            (cons 
             "%1 The )trace option %2 takes exactly one integer argument."
             (cons (cons ")count" nil) nil))))))
      ((eq key '|of|)
        (cons '|of| (loop for y in l collect (|getTraceOption,hn| y))))
      ((member key '(|local| ops vars))
        (cond
         ((or (null l)
              (and (consp l) (eq (qcdr l) nil) (eq (qcar l) '|all|)))
           (cons key '|all|))
         ((|isListOfIdentifiersOrStrings| l) arg)
         (t
           (|stackTraceOptionError|
            (cons
             "%1 The )trace option %2 should be followed by a list of names."
             (cons
              (cons (concat ")" (|object2String| key)) nil) nil))))))
      ((eq key '|varbreak|)
        (cond
         ((or (null l) 
              (and (consp l) (eq (qcdr l) nil) (eq (qcar l) '|all|)))
           (cons '|varbreak| '|all|))
         ((|isListOfIdentifiers| l) arg)
         (t
           (|stackTraceOptionError|
            (cons 
      "%1 The )trace option %2 should be followed by a list of variable names."
             (cons
              (cons (concat ")" (|object2String| key)) nil) nil))))))
      ((eq key '|mathprint|)
        (cond
         ((null l) arg)
         (t
           (|stackTraceOptionError|
            (cons "%1 The )trace option %2 can have no arguments."
             (cons
              (cons (concat ")" (|object2String| key)) nil) nil))))))
      (key (|throwKeyedMsg| "The %1 option is not implemented yet."
            (cons key nil))))))))) 

\end{chunk}

\defun{traceOptionError}{traceOptionError}
\calls{traceOptionError}{stackTraceOptionError}
\calls{traceOptionError}{commandAmbiguityError}
\begin{chunk}{defun traceOptionError}
(defun |traceOptionError| (opt keys)
 (if (null keys)
  (|stackTraceOptionError|
   (cons 
    "%1 Axiom does not understand the )trace option %2 which you used."
    (cons (cons opt nil) nil)))
  (|commandAmbiguityError| '|trace option| opt keys)))

\end{chunk}

\defun{genDomainTraceName}{genDomainTraceName}
This function maintains an alist whose car is the domain to trace
and the cdr is the genvar. So for POLY(INT) it is called with
\begin{verbatim}
   y == (|Polynomial| (|Integer|))
\end{verbatim}
which, if it is already traced would be in the alist as
\begin{verbatim}
   (((|Polynomial| (|Integer|)) . $1))
\end{verbatim}
If it is not already traced it would be cons with a new genvar
and added to the alist.
  
\calls{genDomainTraceName}{lassoc}
\calls{genDomainTraceName}{genvar}
\usesdollar{genDomainTraceName}{domainTraceNameAssoc}
\begin{chunk}{defun genDomainTraceName}
(defun |genDomainTraceName| (y)
 (let (u g)
 (declare (special |$domainTraceNameAssoc|))
   (if (setq u (lassoc y |$domainTraceNameAssoc|)) 
    u
    (progn
     (setq g (genvar))
     (setq |$domainTraceNameAssoc| (cons (cons y g) |$domainTraceNameAssoc|))
     g))))

\end{chunk}

\defun{untrace}{untrace}
\calls{untrace}{copy}
\calls{untrace}{transTraceItem}
\calls{untrace}{/untrace,0}
\calls{untrace}{lassocSub}
\calls{untrace}{removeTracedMapSigs}
\usesdollar{untrace}{lastUntraced}
\usesdollar{untrace}{mapSubNameAlist}
\usesdollar{untrace}{traceNames}
\begin{chunk}{defun untrace}
(defun |untrace| (arg)
 (let (untracelist)
 (declare (special |$lastUntraced| |$traceNames| |$mapSubNameAlist|))
  (if arg
   (setq |$lastUntraced| arg)
   (setq |$lastUntraced| (copy |$traceNames|)))
  (setq untracelist
   (do ((t1 arg (cdr t1)) (x nil) (t0 nil))
       ((or (atom t1) (progn (setq x (car t1)) nil))
      (nreverse0 t0))
     (push (|transTraceItem| x) t0)))
  (/untrace-0
   (do ((t3 untracelist (cdr t3)) (|funName| nil) (t2 nil))
       ((or (atom t3) (progn (setq |funName| (car t3)) nil))
     (nreverse0 t2))
    (push (|lassocSub| |funName| |$mapSubNameAlist|) t2)))
  (|removeTracedMapSigs| untracelist))) 

\end{chunk}

\defun{/untrace-0}{/untrace-0}
\calls{/untrace-0}{/options}
\calls{/untrace-0}{trunclist}
\calls{/untrace-0}{/untrace-1}
\begin{chunk}{defun /untrace-0}
(defun /untrace-0 (l)
 (let (optionl options fnl)
  (cond
   ((member '? l :test #'eq) (format t "Use )help trace~%"))
   (t
    (setq optionl (/options l))
    (setq fnl (trunclist l optionl))
    (setq options (if optionl (car optionl)))
    (/untrace-1 fnl options)))))

\end{chunk}

\defun{/untrace-1}{/untrace-1}
\calls{/untrace-1}{/untrace-2}
\calls{/untrace-1}{/untrace-reduce}
\calls{/untrace-1}{/tracereply}
\usesdollar{/untrace-1}{traceNames}
\begin{chunk}{defun /untrace-1}
(defun /untrace-1 (l options)
 (declare (special |$traceNames|))
 (cond
  ((not l)
    (unless (atom |$traceNames|)
     (mapcar #'(lambda (u) (/untrace-2 (/untrace-reduce u) options))
       (append |$traceNames| nil))))
  ((mapcar #'(lambda (x) (/untrace-2 x options)) l)))
 (/tracereply))

\end{chunk}

\defun{/untrace-reduce}{/untrace-reduce}
(CAR X) is now a domain
\sig{/untrace-reduce}{Union(Atom,List)}{Atom}
\begin{chunk}{defun /untrace-reduce 0}
(defun /untrace-reduce (x)
 (if (atom x) x (first x))) 

\end{chunk}

\defun{/untrace-2}{/untrace-2}
\calls{/untrace-2}{isFunctor}
\calls{/untrace-2}{untraceDomainConstructor}
\calls{/untrace-2}{isDomainOrPackage}
\calls{/untrace-2}{isDomain}
\calls{/untrace-2}{spadUntrace}
\calls{/untrace-2}{eqcar}
\calls{/untrace-2}{sayBrightly}
\calls{/untrace-2}{unembed}
\calls{/untrace-2}{isSubForRedundantMapName}
\calls{/untrace-2}{rassocSub}
\calls{/untrace-2}{isGenvar}
\calls{/untrace-2}{devaluate}
\calls{/untrace-2}{concat}
\usesdollar{/untrace-2}{traceNoisely}
\usesdollar{/untrace-2}{mapSubNameAlist}
\usesdollar{/untrace-2}{mathTraceList}
\usesdollar{/untrace-2}{timerList}
\usesdollar{/untrace-2}{traceNames}
\begin{chunk}{defun /untrace-2}
(defun /untrace-2 (x options)
 (declare (special |$traceNoisely| |$mapSubNameAlist| |$mathTraceList|
           |$timerList| |$traceNames|))
 (let (u y)
  (cond
   ((and (|isFunctor| X) (atom x))
     (|untraceDomainConstructor| X))
   ((or (|isDomainOrPackage| (setq u x))
        (and (symbolp X) (boundp X) (|isDomain| (setq u (eval x)))))
     (|spadUntrace| u options))
   ((eqcar options 'alias)
     (when |$traceNoisely|
       (|sayBrightly| (list (cadr options) '**untraced)))
     (setq |$timerList|
       (remove (princ-to-string (cadr options)) |$timerList| :test 'equal))
     (setq |$countList|
       (remove (princ-to-string (cadr options)) |$countList| :test 'equal))
     (setq |$mathTraceList|
       (remove (cadr options) |$mathTraceList| :test 'equal))
     (unembed x))
   ((and (not (member x |$traceNames|)) (not (|isSubForRedundantMapName| X)))
     (|sayBrightly| (list (|rassocSub| X |$mapSubNameAlist|) "not traced")))
   (t
     (setq |$traceNames| (remove x |$traceNames| :test 'equal))
     (setq |$mathTraceList|
       (remove (if (stringp x) (intern x) x) |$mathTraceList|))
     (setq |$letAssoc| (remove x |$letAssoc| :key #'car))
     (setq y (if (isGenvar x) (|devaluate| (eval x)) x))
     (setq |$timerList| (remove (princ-to-string y) |$timerList| :test 'equal))
     (set (intern (concat y ",TIMER")) 0)
     (setq |$countList| (remove (princ-to-string y) |$countList| :test 'equal))
     (set (intern (concat y ",COUNT")) 0)
     (when (and |$traceNoisely| (not (|isSubForRedundantMapName| y)))
        (|sayBrightly| (list (|rassocSub| Y |$mapSubNameAlist|) "untraced")))
     (unembed x)))))
 
\end{chunk}

\defun{isGenvar}{isGenvar}
\calls{isGenvar}{identp}
\calls{isGenvar}{size}
\calls{isGenvar}{digitp}
\begin{chunk}{defun isGenvar}
(defun isGenvar (x)
  (and (identp x)
       (let ((y (symbol-name x)))
         (and (char= #\$ (elt y 0)) (> (size y) 1) (digitp (elt y 1))))))
 
\end{chunk}

\defun{transTraceItem}{transTraceItem}
For a call to trace INT this return Integer. For a call to trace
\verb|POLY(INT)| this returns a genvar (e.g. \verb|$1|) which is
set to the domain to be traced, recorded on the alist
\verb|$domainTraceNameAssoc|. In either case, a symbol is returned.
\calls{transTraceItem}{get}
\calls{transTraceItem}{member}
\calls{transTraceItem}{objMode}
\calls{transTraceItem}{objVal}
\calls{transTraceItem}{domainToGenvar}
\calls{transTraceItem}{unabbrev}
\calls{transTraceItem}{constructor?}
\calls{transTraceItem}{vecp}
\calls{transTraceItem}{transTraceItem}
\calls{transTraceItem}{devaluate}
\calls{transTraceItem}{throwKeyedMsg}
\usesdollar{transTraceItem}{doNotAddEmptyModeIfTrue}
\sig{transTraceItem}{traceArgument}{symbol}
\begin{chunk}{defun transTraceItem}
(defun |transTraceItem| (x)
 (let (|$doNotAddEmptyModeIfTrue| |value| y)
  (declare (special |$doNotAddEmptyModeIfTrue|))
  (setq |$doNotAddEmptyModeIfTrue| t)
  (cond
   ((atom x)
     (cond
      ((and (setq |value| (|get| x '|value| |$InteractiveFrame|))
            (member (|objMode| |value|)
             '((|Mode|) (|Domain|) (|SubDomain| (|Domain|))) :test #'equalp))
        (setq x (|objVal| |value|))
        (cond 
         ((setq y (|domainToGenvar| x)) y)
         (t x)))
      ;; case for trace INT
      ((upper-case-p (elt (princ-to-string x) 0))
        (setq y (|unabbrev| x))
        (cond
         ((|constructor?| y) y)
         ((and (consp y) (|constructor?| (car y))) (car y))
         ((setq y (|domainToGenvar| x)) y)
         (t x)))
      (t x)))
   ((simple-vector-p (car x)) (|transTraceItem| (|devaluate| (car x))))
   ;; case for trace POLY(INT)
   ((setq y (|domainToGenvar| x)) y)
   (t (|throwKeyedMsg|
        "Axiom does not understand the use of %1 here." (list x))))))

\end{chunk}

\defun{removeTracedMapSigs}{removeTracedMapSigs}
\usesdollar{removeTracedMapSigs}{tracedMapSignatures}
\begin{chunk}{defun removeTracedMapSigs}
(defun |removeTracedMapSigs| (untraceList)
 (declare (special |$tracedMapSignatures|))
 (dolist (name untraceList)
   (remprop name |$tracedMapSignatures|)))

\end{chunk}

\defun{coerceTraceArgs2E}{coerceTraceArgs2E}
\calls{coerceTraceArgs2E}{spadsysnamep}
\calls{coerceTraceArgs2E}{pname}
\calls{coerceTraceArgs2E}{coerceSpadArgs2E}
\calls{coerceTraceArgs2E}{objValUnwrap}
\calls{coerceTraceArgs2E}{coerceInteractive}
\calls{coerceTraceArgs2E}{mkObjWrap}
\usesdollar{coerceTraceArgs2E}{OutputForm}
\usesdollar{coerceTraceArgs2E}{mathTraceList}
\usesdollar{coerceTraceArgs2E}{tracedMapSignatures}
\begin{chunk}{defun coerceTraceArgs2E}
(defun |coerceTraceArgs2E| (tracename subname args)
 (declare (ignore tracename))
 (let (name)
  (declare (special |$OutputForm| |$mathTraceList| |$tracedMapSignatures|))
  (cond
   ((member (setq name subname) |$mathTraceList|)
     (if (spadsysnamep (pname name))
      (|coerceSpadArgs2E| (reverse (cdr (reverse args))))
      (do ((t1 '(|arg1| |arg2| |arg3| |arg4| |arg5| |arg6| |arg7| |arg8| 
                 |arg9| |arg10| |arg11| |arg12| |arg13| |arg14| |arg15| 
                 |arg16| |arg17| |arg18| |arg19|) (cdr t1))
           (name nil)
           (t2 args (cdr t2))
           (arg nil)
           (t3 (cdr (lassoc subname |$tracedMapSignatures|)) (cdr t3))
           (type nil)
           (t0 nil))
          ((or (atom t1)
               (progn (setq name (car t1)) nil)
               (atom t2)
               (progn (setq arg (car t2)) nil)
               (atom t3)
               (progn (setq type (car t3)) nil)) 
             (nreverse0 t0))
          (setq t0
           (cons 
            (list '= name 
             (|objValUnwrap| 
              (|coerceInteractive|
               (mkObjWrap arg type) |$OutputForm|))) t0)))))
   ((spadsysnamep (pname name)) (reverse (cdr (reverse args))))
   (t args))))

\end{chunk}

\defun{coerceSpadArgs2E}{coerceSpadArgs2E}
\calls{coerceSpadArgs2E}{seq}
\calls{coerceSpadArgs2E}{exit}
\calls{coerceSpadArgs2E}{objValUnwrap}
\calls{coerceSpadArgs2E}{coerceInteractive}
\calls{coerceSpadArgs2E}{mkObjWrap}
\usesdollar{coerceSpadArgs2E}{streamCount}
\usesdollar{coerceSpadArgs2E}{OutputForm}
\usesdollar{coerceSpadArgs2E}{tracedSpadModemap}
\begin{chunk}{defun coerceSpadArgs2E}
(defun |coerceSpadArgs2E| (args)
 (let ((|$streamCount| 0))
  (declare (special |$streamCount| |$OutputForm| |$tracedSpadModemap|))
  (do ((t1 '(|arg1| |arg2| |arg3| |arg4| |arg5| |arg6| |arg7| |arg8| 
             |arg9| |arg10| |arg11| |arg12| |arg13| |arg14| |arg15| 
             |arg16| |arg17| |arg18| |arg19|) (cdr t1))
       (name nil)
       (t2 args (cdr t2))
       (arg nil)
       (t3 (cdr |$tracedSpadModemap|) (cdr t3))
       (type nil)
       (t0 nil))
      ((or (atom t1)
           (progn (setq name (car t1)) nil)
           (atom t2)
           (progn (setq arg (car t2)) nil)
           (atom t3)
           (progn (setq type (car t3)) nil))
        (nreverse0 t0))
    (seq
     (exit
      (setq t0
       (cons
        (cons '=
         (cons name
          (cons (|objValUnwrap|
            (|coerceInteractive| 
             (mkObjWrap arg type)
             |$OutputForm|)) nil)))
         t0)))))))

\end{chunk}

\defun{coerceTraceFunValue2E}{coerceTraceFunValue2E}
\calls{coerceTraceFunValue2E}{spadsysnamep}
\calls{coerceTraceFunValue2E}{pname}
\calls{coerceTraceFunValue2E}{coerceSpadFunValue2E}
\calls{coerceTraceFunValue2E}{lassoc}
\calls{coerceTraceFunValue2E}{objValUnwrap}
\calls{coerceTraceFunValue2E}{coerceInteractive}
\calls{coerceTraceFunValue2E}{mkObjWrap}
\usesdollar{coerceTraceFunValue2E}{tracedMapSignatures}
\usesdollar{coerceTraceFunValue2E}{OutputForm}
\usesdollar{coerceTraceFunValue2E}{mathTraceList}
\begin{chunk}{defun coerceTraceFunValue2E}
(defun |coerceTraceFunValue2E| (tracename subname |value|)
 (let (name u)
 (declare (special |$tracedMapSignatures| |$OutputForm| |$mathTraceList|))
   (if (member (setq name subname) |$mathTraceList|)
    (cond
     ((spadsysnamep (pname tracename)) (|coerceSpadFunValue2E| |value|))
     ((setq u (lassoc subname |$tracedMapSignatures|))
       (|objValUnwrap|
        (|coerceInteractive| (mkObjWrap |value| (car u)) |$OutputForm|)))
     (t |value|))
    |value|)))

\end{chunk}

\defun{coerceSpadFunValue2E}{coerceSpadFunValue2E}
\calls{coerceSpadFunValue2E}{objValUnwrap}
\calls{coerceSpadFunValue2E}{coerceInteractive}
\calls{coerceSpadFunValue2E}{mkObjWrap}
\usesdollar{coerceSpadFunValue2E}{streamCount}
\usesdollar{coerceSpadFunValue2E}{tracedSpadModemap}
\usesdollar{coerceSpadFunValue2E}{OutputForm}
\begin{chunk}{defun coerceSpadFunValue2E}
(defun |coerceSpadFunValue2E| (|value|)
 (let (|$streamCount|)
  (declare (special |$streamCount| |$tracedSpadModemap| |$OutputForm|))
  (setq |$streamCount| 0)
  (|objValUnwrap|
   (|coerceInteractive|
    (mkObjWrap |value| (car |$tracedSpadModemap|))
    |$OutputForm|))))

\end{chunk}

\defun{getMapSubNames}{getMapSubNames}
\calls{getMapSubNames}{get}
\calls{getMapSubNames}{union}
\calls{getMapSubNames}{getPreviousMapSubNames}
\calls{getMapSubNames}{unionq}
\usesdollar{getMapSubNames}{lastUntraced}
\usesdollar{getMapSubNames}{InteractiveFrame}
\usesdollar{getMapSubNames}{traceNames}
\begin{chunk}{defun getMapSubNames}
(defun getMapSubNames (arg)
 (let (lmm subs)
 (declare (special |$traceNames| |$lastUntraced| |$InteractiveFrame|))
  (setq subs nil)
  (dolist (mapname arg)
   (when (setq lmm (|get| mapname '|localModemap| |$InteractiveFrame|))
     (setq subs
      (append
        (do ((t2 lmm (cdr t2)) (t1 nil) (|mm| nil))
            ((or (atom t2)
                 (progn (setq |mm| (CAR t2)) nil)) (nreverse0 t1))
           (setq t1 (cons (cons mapname (cadr |mm|)) t1)))
       subs))))
  (|union| subs
    (|getPreviousMapSubNames| 
      (union |$traceNames| |$lastUntraced| :test #'eq)))))

\end{chunk}

\defun{spadTrace,g}{spadTrace,g}
\begin{chunk}{defun spadTrace,g}
(defun |spadTrace,g| (x)
  (if (stringp x) (intern x) x))

\end{chunk}

\defun{spadTrace,isTraceable}{spadTrace,isTraceable}
\calls{spadTrace,isTraceable}{seq}
\calls{spadTrace,isTraceable}{exit}
\calls{spadTrace,isTraceable}{gensymp}
\calls{spadTrace,isTraceable}{reportSpadTrace}
\calls{spadTrace,isTraceable}{bpiname}
\begin{chunk}{defun spadTrace,isTraceable}
(defun |spadTrace,isTraceable| (x domain)
 (prog (n |functionSlot|)
  (return
   (seq
    (progn
     (setq n (caddr x))
     x
     (seq
      (if (atom (elt domain n)) (exit nil))
      (setq |functionSlot| (car (elt domain n)))
      (if (gensymp |functionSlot|) 
       (exit (seq (|reportSpadTrace| '|Already Traced| x) (exit nil))))
      (if (null (bpiname |functionSlot|))
       (exit
        (seq
         (|reportSpadTrace| '|No function for| x)
         (exit nil))))
      (exit t))))))) 

\end{chunk}

\defun{spadTrace}{spadTrace}
\calls{spadTrace}{refvecp}
\calls{spadTrace}{aldorTrace}
\calls{spadTrace}{isDomainOrPackage}
\calls{spadTrace}{userError}
\calls{spadTrace}{seq}
\calls{spadTrace}{exit}
\calls{spadTrace}{spadTrace,g}
\calls{spadTrace}{getOption}
\calls{spadTrace}{removeOption}
\calls{spadTrace}{opOf}
\calls{spadTrace}{assoc}
\calls{spadTrace}{flattenOperationAlist}
\calls{spadTrace}{getOperationAlistFromLisplib}
\calls{spadTrace}{spadTrace,isTraceable}
\calls{spadTrace}{as-insert}
\calls{spadTrace}{bpiname}
\calls{spadTrace}{spadTraceAlias}
\calls{spadTrace}{subTypes}
\calls{spadTrace}{constructSubst}
\calls{spadTrace}{bpitrace}
\calls{spadTrace}{rplac}
\calls{spadTrace}{printDashedLine}
\calls{spadTrace}{reportSpadTrace}
\calls{spadTrace}{setletprintflag}
\calls{spadTrace}{spadReply}
\usesdollar{spadTrace}{tracedModemap}
\usesdollar{spadTrace}{fromSpadTrace}
\usesdollar{spadTrace}{letAssoc}
\usesdollar{spadTrace}{reportSpadTrace}
\usesdollar{spadTrace}{traceNoisely}
\usesdollar{spadTrace}{traceNames}
\begin{chunk}{defun spadTrace}
(defun |spadTrace| (domain options)
 (let (listOfOperations listOfVariables listOfBreakVars anyifTrue
       domainId currentEntry currentAlist opStructureList triple
       sigSlotNumberAlist fn alias tracedModemap dn1 fgg tf)
   (declare (special |$fromSpadTrace|))
   (setq |$fromSpadTrace| t)
   (cond
    ((null (|isDomainOrPackage| domain))
      (|userError| "bad argument to trace"))
    (t
      (setq listOfOperations
       (loop for x in (getOption 'ops options) 
        collect (if (stringp x) (intern x) x)))
      (when (setq listOfVariables (getOption 'vars options))
       (setq options (removeOption 'vars options)))
      (when (setq listOfBreakVars (getOption 'varbreak options))
       (setq options (removeOption 'varbreak options)))
      (setq anyifTrue (null listOfOperations))
      (setq domainId (|opOf| (elt domain 0)))
      (setq currentEntry (|assoc| domain |$traceNames|))
      (setq currentAlist (cdr currentEntry))
      (setq opStructureList
        (flattenOperationAlist (|getOperationAlistFromLisplib| domainId)))
;     new form is (<op> <signature> <slotNumber> <condition> <kind>)
      (setq sigSlotNumberAlist
       (loop for arg in opStructureList
         when
          (and (eq (fifth arg) 'elt)
               (or anyifTrue (member (car arg) listOfOperations))
               (integerp (third arg))
               (|spadTrace,isTraceable|
                 (setq triple (list (first arg) (second arg) (third arg)))
                 domain))
         collect triple))
      (when listOfVariables
        (loop for arg in sigSlotNumberAlist do
          (setq fn (car (elt domain (third arg))))
          (setq |$letAssoc| 
            (as-insert (bpiname fn) listOfVariables |$letAssoc|))))
      (when listOfBreakVars
        (loop for arg in sigSlotNumberAlist do
          (setq fn (car (elt domain (third arg))))
          (setq |$letAssoc|
            (as-insert (bpiname fn) (list (cons 'break listOfBreakVars))
              |$letAssoc|))))
      (loop for pair in sigSlotNumberAlist do
        (setq alias (|spadTraceAlias| domainId (first pair) (third pair)))
        (setq tracedModemap
          (|subTypes| (second pair) (|constructSubst| (elt domain 0))))
        (setq dn1 (car (elt domain (third pair))))
        (setq fgg #'|newGoGet|)
        (setq tf
         (if (equal dn1 fgg)
           (|goGetTracerHelper| (elt domain (third pair)) fgg
               pair alias options tracedModemap)
           (bpitrace dn1 alias tracedModemap options)))
        (nconc pair (list listOfVariables (car (elt domain (third pair)))))
        (|rplac| (car (elt domain (third pair))) tf))
      (setq sigSlotNumberAlist
        (loop for x in sigSlotNumberAlist 
          when (cdddr x)
          collect x))
      (when |$reportSpadTrace| 
        (when |$traceNoisely| (|printDashedLine|))
        (loop for x in (|orderBySlotNumber| sigSlotNumberAlist) do
          (|reportSpadTrace| 'tracing x)))
      (cond
       (currentEntry
         (|rplac| (cdr currentEntry) (append sigSlotNumberAlist currentAlist)))
       (t
         (setq |$traceNames|
           (cons (cons domain sigSlotNumberAlist) |$traceNames|))
         (|spadReply|)))))))

\end{chunk}

\defun{getOperationAlistFromLisplib}{getOperationAlistFromLisplib}
\calls{getOperationAlistFromLisplib}{getdatabase}
\calls{getOperationAlistFromLisplib}{addConsDB}
\calls{getOperationAlistFromLisplib}{markUnique}
\begin{chunk}{defun getOperationAlistFromLisplib}
(defun |getOperationAlistFromLisplib| (x)
 (let (opalist consdb)
  (setq opalist (getdatabase x 'operationalist))
  (cond
   ((null opalist) opalist)
   ((eq (caar opalist) '|$unique|) (cdr opalist))
   (t
    (setq consdb '(nil t elt))
    ((lambda (arg1 arg2)
     (loop
      (cond
       ((or (atom arg1) (progn (setq arg2 (car arg1)) nil))
         (return nil))
       (t
        (and (consp arg2)
             ((lambda (items)
              (loop
               (cond
                ((atom items) (return nil))
                (t
                 (cond
                  ((consp (cdar items))
                   (cond
                    ((consp (cddar items))
                      (cond
                       ((and (consp (cdddar items))
                             (eq (cdr (cdddar items)) nil)) nil)
                       (t (rplacd (cddar items) (cddr consdb)))))
                    (t (rplacd (cdar items) (cdr consdb)))))
                  (t (rplacd (car items) consdb)))
                 (rplaca items (car items))))
               (setq items (cdr items))))
              (cdr arg2)))))
      (setq arg1 (cdr arg1))))
     opalist nil)
    (and opalist (markUnique opalist))))))

\end{chunk}

\defun{markUnique}{markUnique}
\begin{chunk}{defun markUnique 0}
(defun markUnique (x)
 (let (u)
  (setq u (car x))
  (rplaca x '(|$unique|))
  (rplacd x (cons u (cdr x)))
  (cdr x)))

\end{chunk}

\defun{bpitrace}{bpitrace}
\calls{bpitrace}{trace3}
\begin{chunk}{defun bpitrace}
(defun bpitrace (binDef alias modemap options)
  (trace3 (gensym) modemap (cons (list 'alias alias) options) binDef))

\end{chunk}

\defun{traceDomainLocalOps}{traceDomainLocalOps}
\calls{traceDomainLocalOps}{sayMSG}
\begin{chunk}{defun traceDomainLocalOps}
(defun |traceDomainLocalOps| ()
  (|sayMSG| '("  The )local option has been withdrawn"))
  (|sayMSG| '("  Use )ltr to trace local functions.")))

\end{chunk}

\defun{untraceDomainLocalOps}{untraceDomainLocalOps}
\calls{untraceDomainLocalOps}{sayMSG}
\begin{chunk}{defun untraceDomainLocalOps}
(defun |untraceDomainLocalOps| ()
  (|sayMSG| '("  The )local option has been withdrawn"))
  (|sayMSG| '("  Use )ltr to trace local functions.")))

\end{chunk}

\defun{traceDomainConstructor}{traceDomainConstructor}
\calls{traceDomainConstructor}{getOption}
\calls{traceDomainConstructor}{seq}
\calls{traceDomainConstructor}{exit}
\calls{traceDomainConstructor}{spadTrace}
\calls{traceDomainConstructor}{concat}
\calls{traceDomainConstructor}{embed}
\calls{traceDomainConstructor}{mkq}
\calls{traceDomainConstructor}{loadFunctor}
\calls{traceDomainConstructor}{traceDomainLocalOps}
\usesdollar{traceDomainConstructor}{ConstructorCache}
\begin{chunk}{defun traceDomainConstructor}
(defun |traceDomainConstructor| (domainConstructor options)
 (prog (listOfLocalOps argl domain innerDomainConstructor)
 (declare (special |$ConstructorCache|))
  (return
   (seq
    (progn
     (|loadFunctor| domainConstructor)
     (setq listOfLocalOps (getOption 'local options))
     (when listOfLocalOps (|traceDomainLocalOps|))
     (cond 
      ((and listOfLocalOps (null (getOption 'ops options))) nil)
      (t
       (do ((t2 (hget |$ConstructorCache| domainConstructor) (cdr t2))
            (t3 nil))
           ((or (atom t2) 
                (progn (setq t3 (car t2)) nil)
                (progn 
                 (progn 
                  (setq argl (car t3))
                  (setq domain (cddr t3)) t3)
                 nil))
                nil)
         (seq
          (exit
           (|spadTrace| domain options))))
       (setq |$traceNames| (cons domainConstructor |$traceNames|))
       (setq innerDomainConstructor
         (intern (concat domainConstructor ";")))
       (cond
        ((fboundp innerDomainConstructor)
          (setq domainConstructor innerDomainConstructor)))
       (embed domainConstructor
        (cons 'lambda
         (cons 
          (cons '&rest
           (cons 'args nil))
          (cons
           (cons 'prog
            (cons
             (cons 'domain nil)
             (cons
              (cons 'setq
               (cons 'domain
                (cons
                 (cons 'apply (cons domainConstructor
                  (cons 'args nil))) nil)))
              (cons
               (cons '|spadTrace|
                (cons 'domain
                 (cons (mkq options) nil)))
               (cons (cons 'return (cons 'domain nil)) nil)))))
           nil))))))))))) 

\end{chunk}

\defun{untraceDomainConstructor,keepTraced?}{%
untraceDomainConstructor,keepTraced?}
\calls{untraceDomainConstructor,keepTraced?}{seq}
\calls{untraceDomainConstructor,keepTraced?}{qcar}
\calls{untraceDomainConstructor,keepTraced?}{isDomainOrPackage}
\calls{untraceDomainConstructor,keepTraced?}{boot-equal}
\calls{untraceDomainConstructor,keepTraced?}{devaluate}
\calls{untraceDomainConstructor,keepTraced?}{exit}
\calls{untraceDomainConstructor,keepTraced?}{/untrace,0}
\begin{chunk}{defun untraceDomainConstructor,keepTraced?}
(defun |untraceDomainConstructor,keepTraced?| (df domainConstructor)
 (prog (dc)
  (return
   (seq
    (if (and 
         (and
          (and (consp df) (progn (setq dc (qcar df)) t))
           (|isDomainOrPackage| dc))
         (boot-equal (ifcar (|devaluate| dc)) domainConstructor))
     (exit (seq (|/UNTRACE,0| (cons dc nil)) (exit nil))))
    (exit t))))) 

\end{chunk}

\defun{untraceDomainConstructor}{untraceDomainConstructor}
\calls{untraceDomainConstructor}{untraceDomainConstructor,keepTraced?}
\calls{untraceDomainConstructor}{unembed}
\calls{untraceDomainConstructor}{seq}
\calls{untraceDomainConstructor}{exit}
\calls{untraceDomainConstructor}{concat}
\calls{untraceDomainConstructor}{delete}
\usesdollar{untraceDomainConstructor}{traceNames}
\begin{chunk}{defun untraceDomainConstructor}
(defun |untraceDomainConstructor| (domainConstructor)
 (prog (innerDomainConstructor)
 (declare (special |$traceNames|))
  (return
   (seq
    (progn
     (setq |$traceNames|
      (prog (t0)
       (setq t0 nil)
       (return
        (do ((t1 |$traceNames| (cdr t1)) (df nil))
            ((or (atom t1) (progn (setq df (car t1)) nil)) (nreverse0 t0))
         (seq
          (exit
           (cond ((|untraceDomainConstructor,keepTraced?|
                    df domainConstructor)
             (setq t0 (cons df t0))))))))))
     (setq innerDomainConstructor
      (intern (concat domainConstructor ";")))
     (cond
      ((fboundp innerDomainConstructor) (unembed innerDomainConstructor))
      (t (unembed domainConstructor)))
     (setq |$traceNames| (|delete| domainConstructor |$traceNames|))))))) 

\end{chunk}

\defun{mapLetPrint}{mapLetPrint}
\calls{mapLetPrint}{getAliasIfTracedMapParameter}
\calls{mapLetPrint}{getBpiNameIfTracedMap}
\calls{mapLetPrint}{letPrint}
\begin{chunk}{defun mapLetPrint}
(defun |mapLetPrint| (x val currentFunction)
  (setq x (|getAliasIfTracedMapParameter| x currentFunction))
  (setq currentFunction (|getBpiNameIfTracedMap| currentFunction))
  (|letPrint| x val currentFunction))

\end{chunk}

\defun{getAliasIfTracedMapParameter}{getAliasIfTracedMapParameter}
\calls{getAliasIfTracedMapParameter}{isSharpVarWithNum}
\calls{getAliasIfTracedMapParameter}{get}
\calls{getAliasIfTracedMapParameter}{exit}
\calls{getAliasIfTracedMapParameter}{string2pint-n}
\calls{getAliasIfTracedMapParameter}{substring}
\calls{getAliasIfTracedMapParameter}{pname}
\calls{getAliasIfTracedMapParameter}{seq}
\usesdollar{getAliasIfTracedMapParameter}{InteractiveFrame}
\begin{chunk}{defun getAliasIfTracedMapParameter}
(defun |getAliasIfTracedMapParameter| (x |currentFunction|)
 (prog (|aliasList|)
 (declare (special |$InteractiveFrame|))
  (return
   (seq
    (cond
     ((|isSharpVarWithNum| x)
       (cond
        ((setq |aliasList|
           (|get| |currentFunction| 'alias |$InteractiveFrame|))
         (exit
          (elt |aliasList|
           (-
            (string2pint-n (substring (pname x) 1 nil) 1) 1))))))
     (t x)))))) 

\end{chunk}

\defun{getBpiNameIfTracedMap}{getBpiNameIfTracedMap}
\calls{getBpiNameIfTracedMap}{get}
\calls{getBpiNameIfTracedMap}{exit}
\calls{getBpiNameIfTracedMap}{seq}
\usesdollar{getBpiNameIfTracedMap}{InteractiveFrame}
\usesdollar{getBpiNameIfTracedMap}{traceNames}
\begin{chunk}{defun getBpiNameIfTracedMap}
(defun |getBpiNameIfTracedMap| (name)
 (prog (lmm bpiName)
 (declare (special |$InteractiveFrame| |$traceNames|))
  (return
   (seq
    (cond 
     ((setq lmm (|get| name '|localModemap| |$InteractiveFrame|))
       (cond
        ((member (setq bpiName (cadar lmm)) |$traceNames|)
           (exit bpiName))))
     (t name)))))) 

\end{chunk}

\defun{spadTraceAlias}{spadTraceAlias}
\calls{spadTraceAlias}{internl}
\begin{chunk}{defun spadTraceAlias}
(defun |spadTraceAlias| (domainid op n)
 (internl domainid (intern "." "boot") op '|,| (princ-to-string n))) 

\end{chunk}

\defun{reportSpadTrace}{reportSpadTrace}
\calls{reportSpadTrace}{qcar}
\calls{reportSpadTrace}{sayBrightly}
\usesdollar{reportSpadTrace}{traceNoisely}
\begin{chunk}{defun reportSpadTrace}
(defun |reportSpadTrace| (|header| t0)
 (prog (op sig n |t| |msg| |namePart| y |tracePart|)
 (declare (special |$traceNoisely|))
  (return 
   (progn
    (setq op (car t0))
    (setq sig (cadr t0))
    (setq n (caddr t0))
    (setq |t| (cdddr t0))
    (cond
     ((null |$traceNoisely|) nil)
     (t
      (setq |msg|
       (cons |header|
         (cons op
          (cons '|:|
            (cons (CDR sig)
             (cons '| -> |
              (cons (car sig)
               (cons '| in slot |
                (cons n nil)))))))))
      (setq |namePart| nil)
      (setq |tracePart|
       (cond
        ((and (consp |t|) (progn (setq y (qcar |t|)) t) (null (null y)))
          (cond
           ((eq y '|all|)
             (cons '|all| (cons '|vars| nil)))
           (t (cons '| vars: | (cons y nil)))))
        (t nil)))
      (|sayBrightly| (append |msg| (append |namePart| |tracePart|))))))))) 

\end{chunk}

\defun{/tracereply}{/tracereply}
\calls{/tracereply}{qcar}
\calls{/tracereply}{isDomainOrPackage}
\calls{/tracereply}{devaluate}
\calls{/tracereply}{seq}
\calls{/tracereply}{exit}
\usesdollar{/tracereply}{traceNames}
\begin{chunk}{defun /tracereply}
(defun /tracereply () 
 (prog (d domainlist |functionList|)
 (declare (special |$traceNames|))
  (return
   (seq
    (cond
     ((null |$traceNames|) "   Nothing is traced.")
     (t
       (do ((t0 |$traceNames| (cdr t0)) (x nil))
           ((or (atom t0) (progn (setq x (car t0)) nil)) nil)
        (seq
         (exit
          (cond
           ((and (consp x) 
                 (progn (setq d (qcar x)) t)
                 (|isDomainOrPackage| d))
              (setq domainlist (cons (|devaluate| d) domainlist)))
           (t 
            (setq |functionList| (cons x |functionList|)))))))
       (append |functionList|
        (append domainlist (cons '|traced| nil))))))))) 

\end{chunk}

\defun{spadUntrace}{spadUntrace}
\calls{spadUntrace}{isDomainOrPackage}
\calls{spadUntrace}{userError}
\calls{spadUntrace}{getOption}
\calls{spadUntrace}{devaluate}
\calls{spadUntrace}{assoc}
\calls{spadUntrace}{sayMSG}
\calls{spadUntrace}{bright}
\calls{spadUntrace}{prefix2String}
\calls{spadUntrace}{bpiname}
\calls{spadUntrace}{remover}
\calls{spadUntrace}{setletprintflag}
\calls{spadUntrace}{bpiuntrace}
\calls{spadUntrace}{rplac}
\calls{spadUntrace}{seq}
\calls{spadUntrace}{exit}
\calls{spadUntrace}{spadReply}
\usesdollar{spadUntrace}{letAssoc}
\usesdollar{spadUntrace}{traceNames}
\begin{chunk}{defun spadUntrace}
(defun |spadUntrace| (domain options)
 (prog (anyiftrue listofoperations domainid |pair| sigslotnumberalist 
        op sig n |lv| |bpiPointer| tracename alias |assocPair| 
        |newSigSlotNumberAlist|)
 (declare (special |$letAssoc| |$traceNames|))
  (return
   (seq
    (cond
     ((null (|isDomainOrPackage| domain))
       (|userError| "bad argument to untrace"))
     (t
      (setq anyiftrue (null options))
      (setq listofoperations (getOption '|ops:| options))
      (setq domainid (|devaluate| domain))
      (cond
       ((null (setq |pair| (|assoc| domain |$traceNames|)))
         (|sayMSG| 
          (cons "   No functions in" 
           (append
            (|bright| (|prefix2String| domainid))
            (cons "are now traced." nil)))))
       (t 
        (setq sigslotnumberalist (cdr |pair|))
        (do ((t0 sigslotnumberalist (cdr t0)) (|pair| nil))
            ((or (atom t0) 
                 (progn (setq |pair| (car t0)) nil)
                 (progn
                  (progn
                   (setq op (car |pair|))
                   (setq sig (cadr |pair|))
                   (setq n (caddr |pair|))
                   (setq |lv| (cadddr |pair|))
                   (setq |bpiPointer| (car (cddddr |pair|)))
                   (setq tracename (cadr (cddddr |pair|)))
                   (setq alias (caddr (cddddr |pair|)))
                   |pair|)
                  nil))
                 nil)
         (seq
          (exit
           (cond
            ((or anyiftrue (member op listofoperations))
              (progn
                (bpiuntrace tracename alias)
                (rplac (car (elt domain n)) |bpiPointer|)
                (rplac (cdddr |pair|) nil)
                (cond
                 ((setq |assocPair|
                     (|assoc| (bpiname |bpiPointer|) |$letAssoc|))
                   (setq |$letAssoc| (remover |$letAssoc| |assocPair|))
                   (cond 
                    ((null |$letAssoc|) (setletprintflag nil))
                    (t nil)))
                 (t nil))))))))
        (setq |newSigSlotNumberAlist|
         (prog (t1) 
          (setq t1 nil)
          (return
           (do ((t2 sigslotnumberalist (cdr t2)) (x nil))
               ((or (atom t2) (progn (setq x (car t2)) nil)) (nreverse0 t1))
             (seq
              (exit
               (cond ((cdddr x) (setq t1 (cons x t1))))))))))
        (cond 
         (|newSigSlotNumberAlist| 
          (rplac (cdr |pair|) |newSigSlotNumberAlist|))
         (t 
          (setq |$traceNames| (remove domain |$traceNames| :key #'car))
          (|spadReply|))))))))))) 

\end{chunk}

\defun{prTraceNames,fn}{prTraceNames,fn}
\calls{prTraceNames,fn}{seq}
\calls{prTraceNames,fn}{qcar}
\calls{prTraceNames,fn}{qcdr}
\calls{prTraceNames,fn}{isDomainOrPackage}
\calls{prTraceNames,fn}{exit}
\calls{prTraceNames,fn}{devaluate}
\begin{chunk}{defun prTraceNames,fn}
(defun |prTraceNames,fn| (x)
 (prog (|d| |t|)
  (return
   (seq
    (if (and (and (consp x) 
                  (progn (setq |d| (qcar x)) (setq |t| (qcdr x)) t))
              (|isDomainOrPackage| |d|))
      (exit (cons (|devaluate| |d|) |t|)))
    (exit x))))) 

\end{chunk}

\defun{prTraceNames}{prTraceNames}
\calls{prTraceNames}{seq}
\calls{prTraceNames}{exit}
\calls{prTraceNames}{prTraceNames,fn}
\usesdollar{prTraceNames}{traceNames}
\begin{chunk}{defun prTraceNames}
(defun |prTraceNames| ()
 (declare (special |$traceNames|))
 (seq
  (progn
   (do ((t0 |$traceNames| (cdr t0)) (x nil))
       ((or (atom t0) (progn (setq x (car t0)) nil)) nil)
    (seq
     (exit
      (print (|prTraceNames,fn| x))))) nil))) 

\end{chunk}

\defun{addTraceItem}{addTraceItem}
\calls{addTraceItem}{constructor?}
\calls{addTraceItem}{isDomain}
\calls{addTraceItem}{devaluate}
\calls{addTraceItem}{isDomainOrPackage}
\usesdollar{addTraceItem}{constructors}
\usesdollar{addTraceItem}{domains}
\usesdollar{addTraceItem}{packages}
\begin{chunk}{defun addTraceItem}
(defun |addTraceItem| (|d|)
 (declare (special |$constructors| |$domains| |$packages|))
 (cond
  ((|constructor?| |d|)
    (setq |$constructors| (cons |d| |$constructors|)))
  ((|isDomainOrPackage| |d|)
    (setq |$packages| (cons (|devaluate| |d|) |$packages|))))) 

\end{chunk}

\defun{?t}{?t}
\calls{?t}{isgenvar}
\calls{?t}{get}
\calls{?t}{sayMSG}
\calls{?t}{bright}
\calls{?t}{rassocSub}
\calls{?t}{qcar}
\calls{?t}{qcdr}
\calls{?t}{isDomainOrPackage}
\calls{?t}{isDomain}
\calls{?t}{reportSpadTrace}
\calls{?t}{take}
\calls{?t}{sayBrightly}
\calls{?t}{devaluate}
\usesdollar{?t}{mapSubNameAlist}
\usesdollar{?t}{InteractiveFrame}
\usesdollar{?t}{traceNames}
\begin{chunk}{defun ?t}
(defun |?t| ()
 (let (llm d suffix l)
  (declare (special |$traceNames| |$InteractiveFrame| |$mapSubNameAlist|))
  (if (null |$traceNames|) 
   (|sayMSG| (|bright| "nothing is traced"))
   (progn
    (dolist (x |$traceNames|)
     (cond
      ((and (atom x) (null (isgenvar x)))
       (progn
        (cond
         ((setq llm (|get| x '|localModemap| |$InteractiveFrame|))
           (setq x (list (cadar llm)))))
        (|sayMSG|
         `("Function" ,@(|bright| (|rassocSub| x |$mapSubNameAlist|))
           "traced"))))))
    (dolist (x |$traceNames|)
     (cond
      ((and (consp x) 
            (progn (setq d (qcar x)) (setq l (qcdr x)) t)
            (|isDomainOrPackage| d))
       (progn
        (setq suffix "package")
        (|sayBrightly|
         `("   Functions traced in " ,suffix ,(|devaluate| d) ":"))
        (dolist (x (|orderBySlotNumber| l))
          (|reportSpadTrace| '|   | (TAKE 4 x)))
        (terpri)))))))))

\end{chunk}

\defun{monitorEnter}{Handle traced function entry}
\calls{monitorEnter}{sayBrightlyNT2}
\calls{monitorEnter}{coerceTraceArgs2E}
\calls{monitorEnter}{spadsysnamep}
\calls{monitorEnter}{monitorPrintArgs}
\usesdollar{monitorEnter}{TraceFlag}
\usesdollar{monitorEnter}{traceStream}
\usesdollar{monitorEnter}{monitorDepth}
\usesdollar{monitorEnter}{monitorFunDepth}
\usesdollar{monitorEnter}{monitorCaller}
\usesdollar{monitorEnter}{mathTrace}
\begin{chunk}{defun monitorEnter}
(defun monitorEnter (tracecode c type name name1)
 (let (|$TraceFlag| cArgs)
  (declare (special |$TraceFlag| |$traceStream| |$monitorDepth|
            |$monitorFunDepth| |$monitorCaller| |$mathTrace|))
  (setq |$TraceFlag| nil)
  (cond
   ((equal tracecode "000") nil)
   (t
     (tab 0 |$traceStream|)
     (princ (make-string (- |$monitorDepth| 1) :initial-element #\space)
            |$traceStream|)
     (prin1 |$monitorFunDepth| |$traceStream|)
     (format |$traceStream| "<enter ~a " (symbol-name name1))
     (unless (eql c 0)
      (if (eq type 'macro)
        (print " expanded" |$traceStream|)
        (progn
         (print " from " |$traceStream|)
         (prin1 |$monitorCaller| |$traceStream|))))
     (setq cArgs (|coerceTraceArgs2E| name1 name |$monitorArgs|))
     (when (spadsysnamep (symbol-name name))
       (setq cArgs (nreverse (reverse cArgs))))
     (monitorPrintArgs cArgs tracecode (get name '/transform))
     (unless |$mathTrace| (terpri |$traceStream|))))))

\end{chunk}

\defun{monitorPrintArgs}{Print the arguments to a traced function}
Print the arguments to a traced function.
\calls{monitorPrintArgs}{monitorPrint}
\calls{monitorPrintArgs}{monitorPrintRest}
\calls{monitorPrintArgs}{monitorPrintArg}
\calls{monitorPrintArgs}{mkq}
\calls{monitorPrintArgs}{prinmathor0}
\usesdollar{monitorPrintArgs}{traceStream}
\usesdollar{monitorPrintArgs}{mathTrace}
\begin{chunk}{defun monitorPrintArgs}
(defun monitorPrintArgs (l code trans)
 (let (n)
  (cond
   ((eql (digit-char-p (elt code 2)) 0) nil)
   ((eql (digit-char-p (elt code 2)) 9)
    (cond
     (trans
      (loop for x in l for y in (cdr trans) do
       (cond
        ((eq y '*)
          (princ "\\ " |$traceStream|)
          (monitorPrint x |$traceStream|))
        ((eq y '&)
          (princ "\\\\" |$traceStream|)
          (terpri |$traceStream|)
          (print x |$traceStream|))
        ((null y)
          (princ "! " |$traceStream|))
        (t
          (princ "! " |$traceStream|)
          (monitorPrint (eval (subst (mkq x) '* y)) |$traceStream|)))))
     (t
       (princ ": " |$traceStream|)
       (unless (atom l)
          (when |$mathTrace| (terpri |$traceStream|))
          (monitorPrint (car l) |$traceStream|)
          (setq l (cdr l)))
       (loop for el in l do (monitorPrintRest el)))))
   (t
     (loop for istep from 2 to (1- (length code)) do
       (setq n (digit-char-p (elt code istep)))
       (unless (eql n 0)
         (princ "\\" |$traceStream|)
         (prinmathor0 n |$traceStream|)
         (princ ": " |$traceStream|)
         (monitorPrintArg l n)))))))

\end{chunk}

\defun{monitorPrintArg}{monitorPrintArg}
\calls{monitorPrintArg}{monitorPrint}
\usesdollar{monitorPrintArg}{traceStream}
\begin{chunk}{defun monitorPrintArg}
(defun monitorPrintArg (l n)
  (loop for el in l for k from 1 to n do
    (when (= k n) (monitorPrint el |$traceStream|))))

\end{chunk}

\defun{monitorPrint}{monitorPrint}
\calls{monitorPrint}{smallEnough}
\calls{monitorPrint}{limitedPrint1}
\calls{monitorPrint}{prinmathor0}
\usesdollar{monitorPrint}{monitorPretty}
\begin{chunk}{defun monitorPrint}
(defun monitorPrint (x tracestr)
 (cond
  ((null (smallEnough x)) (limitedPrint1 x tracestr))
  (|$monitorPretty| (prettyprint x tracestr))
  (t (prinmathor0 x tracestr))))

\end{chunk}

\defun{monitorPrintRest}{monitorPrintRest}
\calls{monitorPrintRest}{smallEnough}
\calls{monitorPrintRest}{monitorBlanks}
\calls{monitorPrintRest}{prinmathor0}
\usesdollar{monitorPrintRest}{traceStream}
\usesdollar{monitorPrintRest}{monitorDepth}
\usesdollar{monitorPrintRest}{monitorPretty}
\usesdollar{monitorPrintRest}{mathTrace}
\begin{chunk}{defun monitorPrintRest}
(defun monitorPrintRest (x)
 (cond
  ((null (smallEnough x))
    (terpri |$traceStream|)
    (monitorBlanks (+ |$monitorDepth| 1))
    (princ "\\" |$traceStream|)
    (print x |$traceStream|))
  (t
    (unless |$mathTrace| (princ "\\" |$traceStream|))
    (if |$monitorPretty|
     (prettyprint x |$traceStream|)
     (prinmathor0 x |$traceStream|)))))

\end{chunk}

\defun{prinmathor0}{prinmathor0}
\calls{prinmathor0}{maprinSpecial}
\calls{prinmathor0}{outputTran2}
\usesdollar{prinmathor0}{mathTrace}
\usesdollar{prinmathor0}{monitorDepth}
\begin{chunk}{defun prinmathor0}
(defun prinmathor0 (x tracestr)
 (if |$mathTrace|
  (|maprinSpecial| (|outputTran2| x) |$monitorDepth| 80)
  (prin1 x tracestr)))

\end{chunk}

\defun{monitorExit}{Handle traced function exit}
\calls{monitorExit}{tab}
\calls{monitorExit}{monitorPrintValue}
\calls{monitorExit}{coerceTraceFunValue2E}
\usesdollar{monitorExit}{TraceFlag}
\usesdollar{monitorExit}{traceStream}
\usesdollar{monitorExit}{monitorFunDepth}
\usesdollar{monitorExit}{mathTrace}
\usesdollar{monitorExit}{monitorValue}
\begin{chunk}{defun monitorExit}
(defun monitorExit (tracecode name name1 v timernam evalTime)
 (let (|$TraceFlag|)
  (declare (special |$TraceFlag|))
  (setq |$TraceFlag| nil)
  (cond
   ((equal tracecode "000") nil)
   (t
    (tab 0 |$traceStream|)
    (princ (make-string (- |$monitorDepth| 1) :initial-element #\space)
            |$traceStream|)
    (prin1 |$monitorFunDepth| |$traceStream|)
    (format |$traceStream| ">exit ~a " (symbol-name name1))
    (when timernam (format |$traceStream| "(~a sec)" (/ evalTime 60.0)))
    (when (eql v 1)
      (monitorPrintValue
       (|coerceTraceFunValue2E| name1 name |$monitorValue|)
       name1))
    (unless |$mathTrace| (terpri |$traceStream|))))))

\end{chunk}

\defun{monitorPrintValue}{monitorPrintValue}
\calls{monitorPrintValue}{eqcar}
\calls{monitorPrintValue}{mkq}
\calls{monitorPrintValue}{smallEnough}
\calls{monitorPrintValue}{limitedPrint1}
\calls{monitorPrintValue}{prinmathor0}
\usesdollar{monitorPrintValue}{traceStream}
\usesdollar{monitorPrintValue}{monitorPretty}
\usesdollar{monitorPrintValue}{mathTrace}
\begin{chunk}{defun monitorPrintValue}
(defun monitorPrintValue (val name)
 (let (u)
  (setq u (get name '/transform))
  (cond
   (u
    (cond
     ((eqcar u '&)
       (format |$traceStream| "//~a~%" val))
     (t
       (format |$traceStream| "! ~a~%" (eval (subst (mkq val) '* (car u)))))))
   (t
     (princ ": " |$traceStream|)
     (cond
      ((null (smallEnough val)) (limitedPrint1 val |$traceStream|))
      (|$monitorPretty| (prettyprint val |$traceStream|))
      (t
        (when |$mathTrace| (terpri |$traceStream|))
        (prinmathor0 val |$traceStream|)))))))

\end{chunk}

\defun{limitedPrint1}{limitedPrint1}
\uses{limitedPrint1}{*print-level*}
\uses{limitedPrint1}{*print-length*}
\begin{chunk}{defun limitedPrint1 0}
(defun limitedPrint1 (form stream)
 (let ((*print-level* 4) (*print-length* 4))
  (prin1 form stream) 
  (terpri stream)))

\end{chunk}

\defun{smallEnough}{smallEnough}
\begin{chunk}{defun smallEnough}
(defun smallEnough (x)
  (if |$traceSize|
   (< (smallEnoughCount x 0 |$traceSize|) |$traceSize|)
   t))

\end{chunk}

\defun{smallEnoughCount}{How big is an object?}
We need to know how many elements there are in the object $x$.
The $n$ argument should be 0 for a top-level call and $m$ is
the maximum length allowed.
\begin{chunk}{defun smallEnoughCount 0}
(defun smallEnoughCount (x n m)
 (cond
  ((null (< n m)) n)
  ((simple-vector-p x)
   (loop for i from 0 to (1- (length x)) while (< n m)
      do (setq n (smallEnoughCount (elt x i) (+ n 1) m)))
   n)
  ((atom x) n)
  (t
   (setq n (smallEnoughCount (car x) (+ n 1) m))
   (if (null (< n m)) n (smallEnoughCount (cdr x) n m)))))

\end{chunk}

\defun{tracelet}{tracelet}
\calls{tracelet}{stupidIsSpadFunction}
\calls{tracelet}{bpiname}
\calls{tracelet}{lassoc}
\calls{tracelet}{union}
\calls{tracelet}{isGenvar}
\calls{tracelet}{gensymp}
\calls{tracelet}{compileBoot}
\calls{tracelet}{delete}
\usesdollar{tracelet}{traceletflag}
\usesdollar{tracelet}{QuickLet}
\usesdollar{tracelet}{letAssoc}
\usesdollar{tracelet}{traceletFunctions}
\begin{chunk}{defun tracelet}
(defun |tracelet| (fn binDef vars)
 (let (|$QuickLet| $traceletflag l)
  (declare (special |$QuickLet| $traceletflag |$letAssoc| 
            |$traceletFunctions|))
  (when (and binDef (|stupidIsSpadFunction| binDef))
    (when (compiled-function-p binDef) (setq fn (bpiname binDef))))
  (cond ((eq fn '|Undef|) nil)
  (t
    (setq vars
      (cond
       ((eq vars '|all|) '|all|)
       ((setq l (lassoc fn |$letAssoc|)) (|union| vars l))
       (t vars)))
    (setq |$letAssoc| (cons (cons fn vars) |$letAssoc|))
    (setq $traceletflag t)
    (setq |$QuickLet| nil)
    (when (and (null (member fn |$traceletFunctions|))
               (null (isGenvar fn))
               (compiled-function-p (symbol-function fn))
               (null (|stupidIsSpadFunction| fn))
               (null (gensymp fn)))
       (setq |$traceletFunctions| (cons fn |$traceletFunctions|))
       (|compileBoot| fn)
       (setq |$traceletFunctions| (|delete| fn |$traceletFunctions|)))))))

\end{chunk}

\defun{breaklet}{breaklet}
\calls{breaklet}{gensymp}
\calls{breaklet}{stupidIsSpadFunction}
\calls{breaklet}{bpiname}
\calls{breaklet}{lassoc}
\calls{breaklet}{assoc}
\calls{breaklet}{union}
\calls{breaklet}{setletprintflag}
\calls{breaklet}{compileBoot}
\calls{breaklet}{delete}
\usesdollar{breaklet}{QuickLet}
\usesdollar{breaklet}{letAssoc}
\usesdollar{breaklet}{traceletFunctions}
\begin{chunk}{defun breaklet}
; vars is "all" or a list of variables
; $letAssoc ==> (.. (=fn .. (BREAK . all))) OR (.. (=fn .. (BREAK . vl)))
(defun |breaklet| (fn binDef vars)
 (let (|$QuickLet| pair fnEntry)
  (declare (special |$QuickLet| |$letAssoc| |$traceletFunctions|))
  (when (and binDef (|stupidIsSpadFunction| binDef))
    (when (compiled-function-p binDef) (setq fn (bpiname binDef))))
  (cond
   ((eq fn '|Undef|) nil)
   (t
    (setq fnEntry (lassoc fn |$letAssoc|))
    (setq vars
     (if (setq pair (|assoc| 'break fnEntry))
       (|union| vars (cdr pair))
       vars))
     (setq |$letAssoc|
      (cond
       ((null fnEntry)
          (cons (cons fn (list (cons 'break vars))) |$letAssoc|))
       (pair (rplacd pair vars) |$letAssoc|)))
     (setq |$QuickLet| nil)
     (when (and (null (member fn |$traceletFunctions|))
                (null (|stupidIsSpadFunction| fn))
                (null (gensymp fn)))
        (setq |$traceletFunctions| (cons fn |$traceletFunctions|))
        (|compileBoot| fn)
        (setq |$traceletFunctions| (|delete| fn |$traceletFunctions|)))))))

\end{chunk}

\defun{break}{break}
\calls{break}{MONITOR,EVALTRAN}
\calls{break}{sayBrightly}
\uses{break}{/breakcondition}
\begin{chunk}{defun break}
(defun |break| (msg)
 (let (condition)
  (declare (special /breakcondition))
   (setq condition (|MONITOR,EVALTRAN| /breakcondition nil))
   (when (eval condition) (|sayBrightly| msg))))

\end{chunk}

\chapter{Exposure groups}

\section{Functions to manipulate exposure}

\Defun{setExposeAddGroup}{Expose a group}
Note that \verb|$localExposureData| is a vector of lists.
It consists of [exposed groups,exposed constructors,hidden constructors]

\calls{setExposeAddGroup}{object2String}
\calls{setExposeAddGroup}{qcar}
\calls{setExposeAddGroup}{displayExposedGroups}
\calls{setExposeAddGroup}{sayMSG}
\calls{setExposeAddGroup}{displayExposedConstructors}
\calls{setExposeAddGroup}{displayHiddenConstructors}
\calls{setExposeAddGroup}{clearClams}
\calls{setExposeAddGroup}{getalist}
\calls{setExposeAddGroup}{sayKeyedMsg}
\calls{setExposeAddGroup}{member}
\calls{setExposeAddGroup}{msort}
\calls{setExposeAddGroup}{specialChar}
\calls{setExposeAddGroup}{namestring}
\calls{setExposeAddGroup}{pathname}
\calls{setExposeAddGroup}{sayAsManyPerLineAsPossible}
\usesdollar{setExposeAddGroup}{globalExposureGroupAlist}
\usesdollar{setExposeAddGroup}{localExposureData}
\usesdollar{setExposeAddGroup}{interpreterFrameName}
\usesdollar{setExposeAddGroup}{linelength}
\begin{chunk}{defun setExposeAddGroup}
(defun |setExposeAddGroup| (arg)
 "Expose a group"
 (declare (special |$globalExposureGroupAlist| |$localExposureData|
                   |$interpreterFrameName| $linelength))
 (if (null arg)
  (progn
   (format t "~v,,,'-:@<~a~>~%" (- $linelength 2) " The group Option ")
   (|displayExposedGroups|)
   (|sayMSG| " ")
   (|sayAsManyPerLineAsPossible|
    (mapcar #'(lambda (x) (|object2String| (first x))) 
      |$globalExposureGroupAlist|)))
  (dolist (x arg)
    (when (consp x) (setq x (qcar x)))
    (cond
     ((eq x '|all|)
      (setf (elt |$localExposureData| 0)
        (mapcar #'first |$globalExposureGroupAlist|))
      (setf (elt |$localExposureData| 1) nil)
      (setf (elt |$localExposureData| 2) nil)
      (|displayExposedGroups|)
      (|sayMSG| " ")
      (|displayExposedConstructors|)
      (|sayMSG| " ")
      (|displayHiddenConstructors|)
      (|clearClams|))
     ((null (getalist |$globalExposureGroupAlist| x))
      (|sayKeyedMsg| "%1 is not a known exposure group name." (cons x nil)))
     ((|member| x (elt |$localExposureData| 0))
      (|sayKeyedMsg| "%1 is already an exposure group for frame %2"
        (list x |$interpreterFrameName|)))
     (t
      (setf (elt |$localExposureData| 0)
        (msort (cons x (elt |$localExposureData| 0))))
      (|sayKeyedMsg| "%1 is now an exposure group for frame %2"
        (list x |$interpreterFrameName|))
      (|clearClams|))))))

\end{chunk}

\Defun{setExpose}{The top level set expose command handler}
\calls{setExpose}{displayExposedGroups}
\calls{setExpose}{sayMSG}
\calls{setExpose}{displayExposedConstructors}
\calls{setExpose}{displayHiddenConstructors}
\calls{setExpose}{sayKeyedMsg}
\calls{setExpose}{namestring}
\calls{setExpose}{pathname}
\calls{setExpose}{qcar}
\calls{setExpose}{qcdr}
\calls{setExpose}{selectOptionLC}
\calls{setExpose}{setExposeAdd}
\calls{setExpose}{setExposeDrop}
\calls{setExpose}{setExpose}
\begin{chunk}{defun setExpose}
(defun |setExpose| (arg)
 "The top level set expose command handler"
 (let (fnargs fn)
   (cond
    ((eq arg '|%initialize%|))
    ((eq arg '|%display%|) "...")
    ((or (null arg) (eq arg '|%describe%|) (eq (car arg) '?))
     (|displayExposedGroups|)
     (|sayMSG| " ")
     (|displayExposedConstructors|)
     (|sayMSG| " ")
     (|displayHiddenConstructors|)
     (|sayMSG| " "))
    ((and (consp arg)
          (progn (setq fn (qcar arg)) (setq fnargs (qcdr arg)) t)
          (setq fn (|selectOptionLC| fn '(|add| |drop|) nil)))
     (cond
      ((eq fn '|add|) (|setExposeAdd| fnargs))
      ((eq fn '|drop|) (|setExposeDrop| fnargs))
      (t nil)))
    (t (|setExpose| nil)))))

\end{chunk}

\Defun{setExposeAdd}{The top level set expose add command handler}
\calls{setExposeAdd}{specialChar}
\calls{setExposeAdd}{displayExposedGroups}
\calls{setExposeAdd}{sayMSG}
\calls{setExposeAdd}{displayExposedConstructors}
\calls{setExposeAdd}{sayKeyedMsg}
\calls{setExposeAdd}{qcar}
\calls{setExposeAdd}{qcdr}
\calls{setExposeAdd}{selectOptionLC}
\calls{setExposeAdd}{setExposeAddGroup}
\calls{setExposeAdd}{setExposeAddConstr}
\calls{setExposeAdd}{setExposeAdd}
\usesdollar{setExposeAdd}{linelength}
\begin{chunk}{defun setExposeAdd}
(defun |setExposeAdd| (arg)
 "The top level set expose add command handler"
 (declare (special $linelength))
 (let (fnargs fn)
   (cond
    ((null arg)
     (format t "~v,,,'-:@<~a~>~%" (- $linelength 2) " The add Option ")
     (|displayExposedGroups|)
     (|sayMSG| " ")
     (|displayExposedConstructors|)
     (|sayMSG| " ")
     (|sayKeyedMsg| 
      (format nil
       "When )set expose add is followed by no arguments, the information ~
        you now see is displayed. ~
        The arguments group and constructor are used to specify ~
        exposure groups or an explicit constructor to be added to the local ~
        frame exposure data. Issue ~
        %ceon )set expose add group %ceoff or ~
        %ceon )set expose add constructor %ceoff ~
        for more information.")
       nil))
    ((and (consp arg) 
          (progn (setq fn (qcar arg)) (setq fnargs (qcdr arg)) t)
          (setq fn (|selectOptionLC| fn '(|group| |constructor|) nil)))
     (cond
      ((eq fn '|group|) (|setExposeAddGroup| fnargs))
      ((eq fn '|constructor|) (|setExposeAddConstr| fnargs))
      (t nil)))
    (t (|setExposeAdd| nil))))) 

\end{chunk}

\Defun{setExposeAddConstr}{The top level set expose add constructor handler}
\calls{setExposeAddConstr}{unabbrev}
\calls{setExposeAddConstr}{qcar}
\calls{setExposeAddConstr}{getdatabase}
\calls{setExposeAddConstr}{sayKeyedMsg}
\calls{setExposeAddConstr}{member}
\calls{setExposeAddConstr}{delete}
\calls{setExposeAddConstr}{msort}
\calls{setExposeAddConstr}{clearClams}
\calls{setExposeAddConstr}{specialChar}
\calls{setExposeAddConstr}{displayExposedConstructors}
\usesdollar{setExposeAddConstr}{linelength}
\usesdollar{setExposeAddConstr}{localExposureData}
\usesdollar{setExposeAddConstr}{interpreterFrameName}
\begin{chunk}{defun setExposeAddConstr}
(defun |setExposeAddConstr| (arg)
 "The top level set expose add constructor handler"
 (declare (special $linelength |$localExposureData| |$interpreterFrameName|))
 (if (null arg)
   (progn
    (format t "~v,,,'-:@<~a~>~%" (- $linelength 2) " The constructor Option ")
    (|displayExposedConstructors|))
   (dolist (x arg)
     (setq x (|unabbrev| x))
     (when (consp x) (setq x (qcar x)))
     (cond
      ((null (getdatabase x 'constructorkind))
       (|sayKeyedMsg|
        (format nil "%1 is not a known constructor. ~
           You can make the constructor known to the system by loading it.")
         (list x)))
      ((|member| x (elt |$localExposureData| 1))
       (|sayKeyedMsg| "%1 is already explicitly exposed in frame %2"
         (list x |$interpreterFrameName| )))
      (t
       (when (|member| x (elt |$localExposureData| 2))
         (setf (elt |$localExposureData| 2)
          (|delete| x (elt |$localExposureData| 2))))
       (setf (elt |$localExposureData| 1)
        (msort (cons x (elt |$localExposureData| 1))))
       (|clearClams|)
       (|sayKeyedMsg| "%1 is now explicitly exposed in frame %2"
        (list x |$interpreterFrameName| )))))))

\end{chunk}

\Defun{setExposeDrop}{The top level set expose drop handler}
\calls{setExposeDrop}{specialChar}
\calls{setExposeDrop}{displayHiddenConstructors}
\calls{setExposeDrop}{sayMSG}
\calls{setExposeDrop}{sayKeyedMsg}
\calls{setExposeDrop}{qcar}
\calls{setExposeDrop}{qcdr}
\calls{setExposeDrop}{selectOptionLC}
\calls{setExposeDrop}{setExposeDropGroup}
\calls{setExposeDrop}{setExposeDropConstr}
\calls{setExposeDrop}{setExposeDrop}
\usesdollar{setExposeDrop}{linelength}
\begin{chunk}{defun setExposeDrop}
(defun |setExposeDrop| (arg)
 "The top level set expose drop handler"
 (declare (special $linelength))
 (let (fnargs fn)
   (cond
    ((null arg)
     (format t "~v,,,'-:@<~a~>~%" (- $linelength 2) " The drop Option ")
     (|displayHiddenConstructors|)
     (|sayMSG| " ")
     (|sayKeyedMsg|
      (format nil "When )set expose drop is followed by no arguments, the ~
       information you now see is displayed. The arguments group and ~
       constructor are used to specify exposure groups or an explicit ~
       constructor to be dropped from the local frame exposure data. Issue ~
       %ceon )set expose drop group %ceoff or %ceon )set expose drop ~
       constructor %ceoff for more information.")
      nil))
    ((and (consp arg) 
          (progn (setq fn (qcar arg)) (setq fnargs (qcdr arg)) t)
          (setq fn (|selectOptionLC| fn '(|group| |constructor|) nil)))
     (cond
      ((eq fn '|group|) (|setExposeDropGroup| fnargs))
      ((eq fn '|constructor|) (|setExposeDropConstr| fnargs))
      (t nil)))
    (t (|setExposeDrop| nil))))) 

\end{chunk}

\Defun{setExposeDropGroup}{The top level set expose drop group handler}
\calls{setExposeDropGroup}{qcar}
\calls{setExposeDropGroup}{displayExposedGroups}
\calls{setExposeDropGroup}{sayMSG}
\calls{setExposeDropGroup}{displayExposedConstructors}
\calls{setExposeDropGroup}{displayHiddenConstructors}
\calls{setExposeDropGroup}{clearClams}
\calls{setExposeDropGroup}{member}
\calls{setExposeDropGroup}{delete}
\calls{setExposeDropGroup}{sayKeyedMsg}
\calls{setExposeDropGroup}{getalist}
\calls{setExposeDropGroup}{specialChar}
\usesdollar{setExposeDropGroup}{linelength}
\usesdollar{setExposeDropGroup}{localExposureData}
\usesdollar{setExposeDropGroup}{interpreterFrameName}
\usesdollar{setExposeDropGroup}{globalExposureGroupAlist}
\begin{chunk}{defun setExposeDropGroup}
(defun |setExposeDropGroup| (arg)
 "The top level set expose drop group handler"
 (declare (special $linelength |$localExposureData| |$interpreterFrameName|
                   |$globalExposureGroupAlist|))
 (if (null arg)
  (progn
   (format t "~v,,,'-:@<~a~>~%" (- $linelength 2) " The group Option ")
   (|sayKeyedMsg| 
    (format nil "When followed by one or more exposure group names, this ~
                 option allows you to remove those groups from the local ~
                 frame exposure data.")
    nil)
   (|sayMSG| " ")
   (|displayExposedGroups|))
  (dolist (x arg)
    (when (consp x) (setq x (qcar x)))
    (cond
     ((eq x '|all|)
      (setf (elt |$localExposureData| 0) nil)
      (setf (elt |$localExposureData| 1) nil)
      (setf (elt |$localExposureData| 2) nil)
      (|displayExposedGroups|)
      (|sayMSG| " ")
      (|displayExposedConstructors|)
      (|sayMSG| " ")
      (|displayHiddenConstructors|)
      (|clearClams|))
     ((|member| x (elt |$localExposureData| 0))
      (setf (elt |$localExposureData| 0)
       (|delete| x (elt |$localExposureData| 0)))
      (|clearClams|)
      (|sayKeyedMsg| "%1 is no longer an exposure group for frame %2"
        (list x |$interpreterFrameName| )))
     ((getalist |$globalExposureGroupAlist| x)
      (|sayKeyedMsg| "%1 is already an exposure group for frame %2"
        (list x |$interpreterFrameName| )))
     (t (|sayKeyedMsg| "%1 is not a known exposure group name." (list x )))))))

\end{chunk}

\Defun{setExposeDropConstr}
{The top level set expose drop constructor handler}
\calls{setExposeDropConstr}{unabbrev}
\calls{setExposeDropConstr}{qcar}
\calls{setExposeDropConstr}{getdatabase}
\calls{setExposeDropConstr}{sayKeyedMsg}
\calls{setExposeDropConstr}{member}
\calls{setExposeDropConstr}{delete}
\calls{setExposeDropConstr}{msort}
\calls{setExposeDropConstr}{clearClams}
\calls{setExposeDropConstr}{specialChar}
\calls{setExposeDropConstr}{sayMSG}
\calls{setExposeDropConstr}{displayExposedConstructors}
\calls{setExposeDropConstr}{displayHiddenConstructors}
\usesdollar{setExposeDropConstr}{linelength}
\usesdollar{setExposeDropConstr}{localExposureData}
\usesdollar{setExposeDropConstr}{interpreterFrameName}
\begin{chunk}{defun setExposeDropConstr}
(defun |setExposeDropConstr| (arg)
 "The top level set expose drop constructor handler"
 (declare (special $linelength |$localExposureData| |$interpreterFrameName|))
 (if (null arg)
  (progn
   (format t "~v,,,'-:@<~a~>~%" (- $linelength 2) " The constructor Option ")
   (|sayKeyedMsg| 
    (format nil "When followed by one or more constructor names, this option ~
                 allows you to explicitly hide constructors in this frame.")
    nil)
   (|sayMSG| " ")
   (|displayExposedConstructors|)
   (|sayMSG| " ")
   (|displayHiddenConstructors|))
  (dolist (x arg)
    (setq x (|unabbrev| x))
    (when (consp x) (setq x (qcar x)))
    (cond
     ((null (getdatabase x 'constructorkind))
      (|sayKeyedMsg| 
       (format nil "%1 is not a known constructor. ~
        You can make the constructor known to the system by loading it.")
       (list x)))
     ((|member| x (elt |$localExposureData| 2))
      (|sayKeyedMsg| "%1 is already explicitly hidden in frame %2"
       (list x |$interpreterFrameName|)))
     (t
      (when (|member| x (elt |$localExposureData| 1))
       (setf (elt |$localExposureData| 1)
        (|delete| x (elt |$localExposureData| 1))))
      (setf (elt |$localExposureData| 2)
        (msort (cons x (elt |$localExposureData| 2))))
      (|clearClams|)
      (|sayKeyedMsg| "%1 is now explicitly hidden in frame %2"
       (list x |$interpreterFrameName|)))))))

\end{chunk}

\Defun{displayExposedGroups}{Display exposed groups}
\calls{displayExposedGroups}{sayKeyedMsg}
\usesdollar{displayExposedGroups}{interpreterFrameName}
\usesdollar{displayExposedGroups}{localExposureData}
\begin{chunk}{defun displayExposedGroups}
(defun |displayExposedGroups| ()
 "Display exposed groups"
 (declare (special |$interpreterFrameName| |$localExposureData|))
 (|sayKeyedMsg| 
  (format nil "The following groups are explicitly exposed in the current ~
               frame (called %1 ):")
  (list |$interpreterFrameName|))
 (if  (null (elt |$localExposureData| 0))
  (format t "~v:@<~a~>~%" (- $linelength 2) " there are no exposed groups ")
  (dolist (c (elt |$localExposureData| 0))
     (format t "~v:@<~a~>~%" (- $linelength 2) c))))

\end{chunk}

\Defun{displayExposedConstructors}{Display exposed constructors}
\calls{displayExposedConstructors}{sayKeyedMsg}
\usesdollar{displayExposedConstructors}{localExposureData}
\begin{chunk}{defun displayExposedConstructors}
(defun |displayExposedConstructors| ()
 "Display exposed constructors"
 (declare (special |$localExposureData|))
 (|sayKeyedMsg| 
  "The following constructors are explicitly exposed in the current frame:"
  nil)
 (if  (null (elt |$localExposureData| 1))
  (format t "~v:@<~a~>~%" (- $linelength 2) 
    "there are no explicitly exposed constructors")
  (dolist (c (elt |$localExposureData| 1))
    (format t "~v:@<~a~>~%" (- $linelength 2) c))))

\end{chunk}

\Defun{displayHiddenConstructors}{Display hidden constructors}
\calls{displayHiddenConstructors}{sayKeyedMsg}
\usesdollar{displayHiddenConstructors}{localExposureData}
\begin{chunk}{defun displayHiddenConstructors}
(defun |displayHiddenConstructors| ()
 "Display hidden constructors"
 (declare (special |$localExposureData|))
 (|sayKeyedMsg|
  "The following constructors are explicitly hidden in the current frame:"
  nil)
 (if (null (elt |$localExposureData| 2))
  (format t "~v:@<~a~>~%" (- $linelength 2)
      "there are no explicitly hidden constructors")
   (dolist (c (elt |$localExposureData| 2))
     (format t "~v:@<~a~>~%" (- $linelength 2) c))))

\end{chunk}

\section{Exposure Data Structures}
\defdollar{localExposureData}
\begin{chunk}{postvars}
(defvar |$localExposureData|  (copy-seq |$localExposureDataDefault|))

\end{chunk}

\defdollar{localExposureDataDefault}
\begin{chunk}{initvars}
(defvar |$localExposureDataDefault|
  (vector
    ;;These groups will be exposed 
   (list '|basic| '|categories| '|naglink| '|anna|)
    ;;These constructors will be explicitly exposed
   (list )
    ;;These constructors will be explicitly hidden
   (list )))

\end{chunk}

NOTE: If you add new algebra you must also update this list
otherwise the new algebra won't be loaded by the interpreter when needed.

\defdollar{globalExposureGroupAlist}
\begin{chunk}{initvars}
(defvar |$globalExposureGroupAlist|
 '(
 ;;define the groups |basic| |naglink| |anna| |categories| |Hidden| |defaults|
  (|basic| 
   (|AffineAlgebraicSetComputeWithGroebnerBasis| . AFALGGRO)
   (|AffineAlgebraicSetComputeWithResultant| . AFALGRES)
   (|AffinePlane| . AFFPL)
   (|AffinePlaneOverPseudoAlgebraicClosureOfFiniteField| . AFFPLPS)
   (|AffineSpace| . AFFSP)
   (|AlgebraicManipulations| . ALGMANIP)
   (|AlgebraicNumber| . AN)
   (|AlgFactor| . ALGFACT)
   (|AlgebraicMultFact| . ALGMFACT)
   (|AlgebraPackage| . ALGPKG)
   (|AlgebraGivenByStructuralConstants| . ALGSC)
   (|Any| . ANY)
   (|AnyFunctions1| . ANY1)
   (|ApplicationProgramInterface| . API)
   (|ArrayStack| . ASTACK)
   (|AssociatedJordanAlgebra| . JORDAN)
   (|AssociatedLieAlgebra| . LIE)
   (|AttachPredicates| . PMPRED)
   (|AxiomServer| . AXSERV)
   (|BalancedBinaryTree| . BBTREE)
   (|BasicStochasticDifferential| . BSD)
   (|BasicOperator| . BOP)
   (|BasicOperatorFunctions1| . BOP1)
   (|Bezier| . BEZIER)
   (|BinaryExpansion| . BINARY)
   (|BinaryFile| . BINFILE)
   (|BinarySearchTree| . BSTREE)
   (|BinaryTournament| . BTOURN)
   (|BinaryTree| . BTREE)
   (|Bits| . BITS)
   (|BlasLevelOne| . BLAS1)
   (|BlowUpPackage| . BLUPPACK)
   (|BlowUpWithHamburgerNoether| . BLHN)
   (|BlowUpWithQuadTrans| . BLQT)
   (|Boolean| . BOOLEAN)
   (|CardinalNumber| . CARD)
   (|CartesianTensor| . CARTEN)
   (|CartesianTensorFunctions2| . CARTEN2)
   (|Cell| .  CELL)
   (|Character| . CHAR)
   (|CharacterClass| . CCLASS)
   (|CharacteristicPolynomialPackage| . CHARPOL)
   (|CliffordAlgebra| . CLIF)
   (|Color| . COLOR)
   (|CommonDenominator| . CDEN)
   (|Commutator| . COMM)
   (|Complex| . COMPLEX)
   (|ComplexDoubleFloatMatrix| . CDFMAT)
   (|ComplexDoubleFloatVector| . CDFVEC)
   (|ComplexFactorization| . COMPFACT)
   (|ComplexFunctions2| . COMPLEX2)
   (|ComplexRootPackage| . CMPLXRT)
   (|ComplexTrigonometricManipulations| . CTRIGMNP)
   (|ContinuedFraction| . CONTFRAC)
   (|CoordinateSystems| . COORDSYS)
   (|CRApackage| . CRAPACK)
   (|CycleIndicators| . CYCLES)
   (|CylindricalAlgebraicDecompositionPackage| . CAD)
   (|CylindricalAlgebraicDecompositionUtilities| . CADU)
   (|Database| . DBASE)
   (|DataList| . DLIST)
   (|DecimalExpansion| . DECIMAL)
   (|DenavitHartenbergMatrix| . DHMATRIX)
   (|Dequeue| . DEQUEUE)
   (|DesingTree| . DSTREE)
   (|DesingTreePackage| . DTP)
   (|DiophantineSolutionPackage| . DIOSP)
   (|DirichletRing| . DIRRING)
   (|DirectProductFunctions2| . DIRPROD2)
   (|DisplayPackage| . DISPLAY)
   (|DistinctDegreeFactorize| . DDFACT)
   (|Divisor| . DIV)
   (|DoubleFloat| . DFLOAT)
   (|DoubleFloatMatrix| . DFMAT)
   (|DoubleFloatVector| . DFVEC)
   (|DoubleFloatSpecialFunctions| . DFSFUN)
   (|DrawComplex| . DRAWCX)
   (|DrawNumericHack| . DRAWHACK)
   (|DrawOption| . DROPT)
   (|EigenPackage| . EP)
   (|ElementaryFunctionDefiniteIntegration| . DEFINTEF)
   (|ElementaryFunctionLODESolver| . LODEEF)
   (|ElementaryFunctionODESolver| . ODEEF)
   (|ElementaryFunctionSign| . SIGNEF)
   (|ElementaryFunctionStructurePackage| . EFSTRUC)
   (|Equation| . EQ)
   (|EquationFunctions2| . EQ2)
   (|ErrorFunctions| . ERROR)
   (|EuclideanGroebnerBasisPackage| . GBEUCLID)
   (|Exit| . EXIT)
   (|Export3D| . EXP3D)
   (|Expression| . EXPR)
   (|ExpressionFunctions2| . EXPR2)
   (|ExpressionSolve| . EXPRSOL)
   (|ExpressionSpaceFunctions2| . ES2)
   (|ExpressionSpaceODESolver| . EXPRODE)
   (|ExpressionToOpenMath| . OMEXPR)
   (|ExpressionToUnivariatePowerSeries| . EXPR2UPS)
   (|Factored| . FR)
   (|FactoredFunctions2| . FR2)
  (|FactorisationOverPseudoAlgebraicClosureOfAlgExtOfRationalNumber| . FACTEXT)
   (|FactorisationOverPseudoAlgebraicClosureOfRationalNumber| . FACTRN)
   (|File| . FILE)
   (|FileName| . FNAME)
   (|FiniteAbelianMonoidRingFunctions2| . FAMR2)
   (|FiniteDivisorFunctions2| . FDIV2)
   (|FiniteField| . FF)
   (|FiniteFieldFactorization| . FFFACTOR)
   (|FiniteFieldFactorizationWithSizeParseBySideEffect| . FFFACTSE)
   (|FiniteFieldCyclicGroup| . FFCG)
   (|FiniteFieldPolynomialPackage2| . FFPOLY2)
   (|FiniteFieldNormalBasis| . FFNB)
   (|FiniteFieldHomomorphisms| . FFHOM)
   (|FiniteFieldSquareFreeDecomposition| . FFSQFR)
   (|FiniteLinearAggregateFunctions2| . FLAGG2)
   (|FiniteLinearAggregateSort| . FLASORT)
   (|FiniteSetAggregateFunctions2| . FSAGG2)
   (|FlexibleArray| . FARRAY)
   (|Float| . FLOAT)
   (|FloatingRealPackage| . FLOATRP)
   (|FloatingComplexPackage| . FLOATCP)
   (|FloatSpecialFunctions| . FSFUN)
   (|FourierSeries| . FSERIES)
   (|Fraction| . FRAC)
   (|FractionalIdealFunctions2| . FRIDEAL2)
   (|FractionFreeFastGaussian| . FFFG)
   (|FractionFreeFastGaussianFractions| . FFFGF)
   (|FractionFunctions2| . FRAC2)
   (|FreeNilpotentLie| . FNLA)
   (|FullPartialFractionExpansion| . FPARFRAC)
   (|FunctionFieldCategoryFunctions2| . FFCAT2)
   (|FunctionSpaceAssertions| . PMASSFS)
   (|FunctionSpaceAttachPredicates| . PMPREDFS)
   (|FunctionSpaceComplexIntegration| . FSCINT)
   (|FunctionSpaceFunctions2| . FS2)
   (|FunctionSpaceIntegration| . FSINT)
   (|FunctionSpacePrimitiveElement| . FSPRMELT)
   (|FunctionSpaceSum| . SUMFS)
   (|GaussianFactorizationPackage| . GAUSSFAC)
   (|GeneralPackageForAlgebraicFunctionField| . GPAFF)
   (|GeneralUnivariatePowerSeries| . GSERIES)
   (|GenerateUnivariatePowerSeries| . GENUPS)
   (|Graphviz| . GRAPHVIZ)
   (|GnuDraw| . GDRAW)
   (|GraphicsDefaults| . GRDEF)
   (|GroebnerPackage| . GB)
   (|GroebnerFactorizationPackage| . GBF)
   (|Guess| . GUESS)
   (|GuessAlgebraicNumber| . GUESSAN)
   (|GuessFinite| . GUESSF)
   (|GuessFiniteFunctions| . GUESSF1)
   (|GuessInteger| . GUESSINT)
   (|GuessOption| . GOPT)
   (|GuessPolynomial| . GUESSP)
   (|GuessUnivariatePolynomial| . GUESSUP)
   (|HallBasis| . HB)
   (|Heap| . HEAP)
   (|HexadecimalExpansion| . HEXADEC)
   (|HTMLFormat| . HTMLFORM)
   (|IdealDecompositionPackage| . IDECOMP)
   (|IndexCard| . ICARD)
   (|InfClsPt| . ICP)
   (|InfiniteProductCharacteristicZero| . INFPROD0)
   (|InfiniteProductFiniteField| . INPRODFF)
   (|InfiniteProductPrimeField| . INPRODPF)
   (|InfiniteTuple| . ITUPLE)
   (|InfiniteTupleFunctions2| . ITFUN2)
   (|InfiniteTupleFunctions3| . ITFUN3)
   (|InfinitlyClosePoint| . INFCLSPT)
   (|InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteField| . INFCLSPS)
   (|Infinity| . INFINITY)
   (|Integer| . INT)
   (|IntegerCombinatoricFunctions| . COMBINAT)
   (|IntegerLinearDependence| . ZLINDEP)
   (|IntegerNumberTheoryFunctions| . INTHEORY)
   (|IntegerPrimesPackage| . PRIMES)
   (|IntegerRetractions| . INTRET)
   (|IntegerRoots| . IROOT)
   (|IntegrationResultFunctions2| . IR2)
   (|IntegrationResultRFToFunction| . IRRF2F)
   (|IntegrationResultToFunction| . IR2F)
   (|InterfaceGroebnerPackage| . INTERGB)
   (|InterpolateFormsPackage| . INTFRSP)
   (|IntersectionDivisorPackage| . INTDIVP)
   (|Interval| . INTRVL)
   (|InventorDataSink| . IVDATA)
   (|InventorViewPort| . IVVIEW)
   (|InventorRenderPackage| . IVREND)
   (|InverseLaplaceTransform| . INVLAPLA)
   (|IrrRepSymNatPackage| . IRSN)
   (|KernelFunctions2| . KERNEL2)
   (|KeyedAccessFile| . KAFILE)
   (|LaplaceTransform| . LAPLACE)
   (|LazardMorenoSolvingPackage| . LAZM3PK)
   (|Library| . LIB)
   (|LieSquareMatrix| . LSQM)
   (|LinearOrdinaryDifferentialOperator| . LODO)
   (|LinearSystemMatrixPackage| . LSMP)
   (|LinearSystemMatrixPackage1| . LSMP1)
   (|LinearSystemFromPowerSeriesPackage| . LISYSER)
   (|LinearSystemPolynomialPackage| . LSPP)
   (|List| . LIST)
   (|LinesOpPack| . LOP)
   (|ListFunctions2| . LIST2)
   (|ListFunctions3| . LIST3)
   (|ListToMap| . LIST2MAP)
   (|LocalParametrizationOfSimplePointPackage| . LPARSPT)
   (|MakeFloatCompiledFunction| . MKFLCFN)
   (|MakeFunction| . MKFUNC)
   (|MakeRecord| . MKRECORD)
   (|MappingPackage1| . MAPPKG1)
   (|MappingPackage2| . MAPPKG2)
   (|MappingPackage3| . MAPPKG3)
   (|MappingPackage4| . MAPPKG4)
   (|MathMLFormat| . MMLFORM)
   (|Matrix| . MATRIX)
   (|MatrixCategoryFunctions2| . MATCAT2)
   (|MatrixCommonDenominator| . MCDEN)
   (|MatrixLinearAlgebraFunctions| . MATLIN)
   (|MatrixManipulation| . MAMA)
   (|MergeThing| . MTHING)
   (|ModularDistinctDegreeFactorizer| . MDDFACT)
   (|ModuleOperator| . MODOP)
   (|MonoidRingFunctions2| . MRF2)
   (|MoreSystemCommands| . MSYSCMD)
   (|MPolyCatFunctions2| . MPC2)
   (|MPolyCatRationalFunctionFactorizer| . MPRFF)
   (|Multiset| . MSET)
   (|MultivariateFactorize| . MULTFACT)
   (|MultivariatePolynomial| . MPOLY)
   (|MultFiniteFactorize| . MFINFACT)
   (|MyUnivariatePolynomial| . MYUP)
   (|MyExpression| . MYEXPR)
   (|NeitherSparseOrDensePowerSeries| . NSDPS)
   (|NewtonPolygon| . NPOLYGON)
   (|NoneFunctions1| . NONE1)
   (|NonNegativeInteger| . NNI)
   (|NottinghamGroup| . NOTTING)
   (|NormalizationPackage| . NORMPK)
   (|NormInMonogenicAlgebra| . NORMMA)
   (|NumberTheoreticPolynomialFunctions| . NTPOLFN)
   (|Numeric| . NUMERIC)
   (|NumericalOrdinaryDifferentialEquations| . NUMODE)
   (|NumericalQuadrature| . NUMQUAD)
   (|NumericComplexEigenPackage| . NCEP)
   (|NumericRealEigenPackage| . NREP)
   (|NumericContinuedFraction| . NCNTFRAC)
   (|Octonion| . OCT)
   (|OctonionCategoryFunctions2| . OCTCT2)
   (|OneDimensionalArray| . ARRAY1)
   (|OneDimensionalArrayFunctions2| . ARRAY12)
   (|OnePointCompletion| . ONECOMP)
   (|OnePointCompletionFunctions2| . ONECOMP2)
   (|OpenMathConnection| . OMCONN)
   (|OpenMathDevice| . OMDEV)
   (|OpenMathEncoding| . OMENC)
   (|OpenMathError| . OMERR)
   (|OpenMathErrorKind| . OMERRK)
   (|OpenMathPackage| . OMPKG)
   (|OpenMathServerPackage| . OMSERVER)
   (|OperationsQuery| . OPQUERY)
   (|OrderedCompletion| . ORDCOMP)
   (|OrderedCompletionFunctions2| . ORDCOMP2)
   (|OrdinaryDifferentialRing| . ODR)
   (|OrdSetInts| . OSI)
   (|OrthogonalPolynomialFunctions| . ORTHPOL)
   (|OutputPackage| . OUT)
   (|PackageForAlgebraicFunctionField| . PAFF)
   (|PackageForAlgebraicFunctionFieldOverFiniteField| . PAFFFF)
   (|PackageForPoly| . PFORP)
   (|PadeApproximantPackage| . PADEPAC)
   (|Palette| . PALETTE)
   (|PartialFraction| . PFR)
   (|PatternFunctions2| . PATTERN2)
   (|ParametricPlaneCurve| . PARPCURV)
   (|ParametricSpaceCurve| . PARSCURV)
   (|ParametricSurface| . PARSURF)
   (|ParametricPlaneCurveFunctions2| . PARPC2)
   (|ParametricSpaceCurveFunctions2| . PARSC2)
   (|ParametricSurfaceFunctions2| . PARSU2)
   (|ParametrizationPackage| . PARAMP)
   (|PartitionsAndPermutations| . PARTPERM)
   (|PatternMatch| . PATMATCH)
   (|PatternMatchAssertions| . PMASS)
   (|PatternMatchResultFunctions2| . PATRES2)
   (|PendantTree| . PENDTREE)
   (|Permanent| . PERMAN)
   (|PermutationGroupExamples| . PGE)
   (|PermutationGroup| . PERMGRP)
   (|Permutation| . PERM)
   (|Pi| . HACKPI)
   (|PiCoercions| . PICOERCE)
   (|Places| . PLACES)
   (|PlacesOverPseudoAlgebraicClosureOfFiniteField| . PLACESPS)
   (|Plcs| . PLCS)
   (|PointFunctions2| . PTFUNC2)
   (|PolyGroebner| . PGROEB)
   (|Polynomial| . POLY)
   (|PolynomialAN2Expression| . PAN2EXPR)
   (|PolynomialComposition| . PCOMP)
   (|PolynomialDecomposition| . PDECOMP)
   (|PolynomialFunctions2| . POLY2)
   (|PolynomialIdeals| . IDEAL)
   (|PolynomialPackageForCurve| . PLPKCRV)
   (|PolynomialToUnivariatePolynomial| . POLY2UP)
   (|PositiveInteger| . PI)
   (|PowerSeriesLimitPackage| . LIMITPS)
   (|PrimeField| . PF)
   (|PrimitiveArrayFunctions2| . PRIMARR2)
   (|PrintPackage| . PRINT)
   (|ProjectiveAlgebraicSetPackage| . PRJALGPK)
   (|ProjectivePlane| . PROJPL)
   (|ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteField| . PROJPLPS)
   (|ProjectiveSpace| . PROJSP)
   (|PseudoAlgebraicClosureOfAlgExtOfRationalNumber| . PACEXT)
   (|QuadraticForm| . QFORM)
   (|QuasiComponentPackage| . QCMPACK)
   (|Quaternion| . QUAT)
   (|QuaternionCategoryFunctions2| . QUATCT2)
   (|QueryEquation| . QEQUAT)
   (|Queue| . QUEUE)
   (|QuotientFieldCategoryFunctions2| . QFCAT2)
   (|RadicalEigenPackage| . REP)
   (|RadicalSolvePackage| . SOLVERAD)
   (|RadixExpansion| . RADIX)
   (|RadixUtilities| . RADUTIL)
   (|RandomNumberSource| . RANDSRC)
   (|RationalFunction| . RF)
   (|RationalFunctionDefiniteIntegration| . DEFINTRF)
   (|RationalFunctionFactor| . RFFACT)
   (|RationalFunctionFactorizer| . RFFACTOR)
   (|RationalFunctionIntegration| . INTRF)
   (|RationalFunctionLimitPackage| . LIMITRF)
   (|RationalFunctionSign| . SIGNRF)
   (|RationalFunctionSum| . SUMRF)
   (|RationalRetractions| . RATRET)
   (|RealClosure| . RECLOS)
   (|RealPolynomialUtilitiesPackage| . POLUTIL)
   (|RealZeroPackage| . REAL0)
   (|RealZeroPackageQ| . REAL0Q)
   (|RecurrenceOperator| . RECOP)
   (|RectangularMatrixCategoryFunctions2| . RMCAT2)
   (|RegularSetDecompositionPackage| . RSDCMPK)
   (|RegularTriangularSet| . REGSET)
   (|RegularTriangularSetGcdPackage| . RSETGCD)
   (|RepresentationPackage1| . REP1)
   (|RepresentationPackage2| . REP2)
   (|ResolveLatticeCompletion| . RESLATC)
   (|RewriteRule| . RULE)
   (|RightOpenIntervalRootCharacterization| . ROIRC) 
   (|RomanNumeral| . ROMAN)
   (|RootsFindingPackage| . RFP)
   (|Ruleset| . RULESET)
   (|ScriptFormulaFormat| . FORMULA)
   (|ScriptFormulaFormat1| . FORMULA1)
   (|Segment| . SEG)
   (|SegmentBinding| . SEGBIND)
   (|SegmentBindingFunctions2| . SEGBIND2)
   (|SegmentFunctions2| . SEG2)
   (|Set| . SET)
   (|SimpleAlgebraicExtensionAlgFactor| . SAEFACT)
   (|SimpleCell| . SCELL)
   (|SimplifyAlgebraicNumberConvertPackage| . SIMPAN)
   (|SingleInteger| . SINT)
   (|SmithNormalForm| . SMITH)
   (|SparseEchelonMatrix| . SEM)
   (|SparseUnivariatePolynomialExpressions| . SUPEXPR)
   (|SparseUnivariatePolynomialFunctions2| . SUP2)
   (|SpecialOutputPackage| . SPECOUT)
   (|SquareFreeRegularSetDecompositionPackage| . SRDCMPK)
   (|SquareFreeRegularTriangularSet| . SREGSET)
   (|SquareFreeRegularTriangularSetGcdPackage| . SFRGCD)
   (|SquareFreeQuasiComponentPackage| . SFQCMPK)
   (|Stack| . STACK)
   (|Stream| . STREAM)
   (|StreamFunctions1| . STREAM1)
   (|StreamFunctions2| . STREAM2)
   (|StreamFunctions3| . STREAM3)
   (|StreamTensor| . STNSR)
   (|StochasticDifferential| . SD)
   (|String| . STRING)
   (|SturmHabichtPackage| . SHP)
   (|Symbol| . SYMBOL)
   (|SymmetricGroupCombinatoricFunctions| . SGCF)
   (|SystemSolvePackage| . SYSSOLP)
   (|SAERationalFunctionAlgFactor| . SAERFFC)
   (|Tableau| . TABLEAU)
   (|TaylorSeries| . TS)
   (|TaylorSolve| . UTSSOL)
   (|TexFormat| . TEX)
   (|TexFormat1| . TEX1)
   (|TextFile| . TEXTFILE)
   (|ThreeDimensionalViewport| . VIEW3D)
   (|ThreeSpace| . SPACE3)
   (|Timer|  . TIMER)
   (|TopLevelDrawFunctions| . DRAW)
   (|TopLevelDrawFunctionsForAlgebraicCurves| . DRAWCURV)
   (|TopLevelDrawFunctionsForCompiledFunctions| . DRAWCFUN)
   (|TopLevelDrawFunctionsForPoints| .  DRAWPT )
   (|TopLevelThreeSpace| . TOPSP)
   (|TranscendentalManipulations| . TRMANIP)
   (|TransSolvePackage| . SOLVETRA)
   (|Tree| . TREE)
   (|TrigonometricManipulations| . TRIGMNIP)
   (|UnivariateLaurentSeriesFunctions2| . ULS2)
   (|UnivariateFormalPowerSeries| . UFPS)
   (|UnivariateFormalPowerSeriesFunctions| . UFPS1)
   (|UnivariatePolynomial| . UP)
   (|UnivariatePolynomialCategoryFunctions2| . UPOLYC2)
   (|UnivariatePolynomialCommonDenominator| . UPCDEN)
   (|UnivariatePolynomialFunctions2| . UP2)
   (|UnivariatePolynomialMultiplicationPackage| . UPMP)
   (|UnivariateTaylorSeriesCZero| . UTSZ)
   (|UnivariatePuiseuxSeriesFunctions2| . UPXS2)
   (|UnivariateTaylorSeriesFunctions2| . UTS2)
   (|UniversalSegment| . UNISEG)
   (|UniversalSegmentFunctions2| . UNISEG2)
   (|UserDefinedVariableOrdering| . UDVO)
   (|U8Matrix| . U8MAT)
   (|U16Matrix| . U16MAT)
   (|U32Matrix| . U32MAT)
   (|U8Vector| . U8VEC)
   (|U16Vector| . U16VEC)
   (|U32Vector| . U32VEC)
   (|U32VectorPolynomialOperations| . POLYVEC)
   (|Vector| . VECTOR)
   (|VectorFunctions2| . VECTOR2)
   (|ViewDefaultsPackage| . VIEWDEF)
   (|Void| . VOID)
   (|WuWenTsunTriangularSet| . WUTSET))
 (|naglink|
   (|Asp1| . ASP1)
   (|Asp4| . ASP4)
   (|Asp6| . ASP6)
   (|Asp7| . ASP7)
   (|Asp8| . ASP8)
   (|Asp9| . ASP9)
   (|Asp10| . ASP10)
   (|Asp12| . ASP12)
   (|Asp19| . ASP19)
   (|Asp20| . ASP20)
   (|Asp24| . ASP24)
   (|Asp27| . ASP27)
   (|Asp28| . ASP28)
   (|Asp29| . ASP29)
   (|Asp30| . ASP30)
   (|Asp31| . ASP31)
   (|Asp33| . ASP33)
   (|Asp34| . ASP34)
   (|Asp35| . ASP35)
   (|Asp41| . ASP41)
   (|Asp42| . ASP42)
   (|Asp49| . ASP49)
   (|Asp50| . ASP50)
   (|Asp55| . ASP55)
   (|Asp73| . ASP73)
   (|Asp74| . ASP74)
   (|Asp77| . ASP77)
   (|Asp78| . ASP78)
   (|Asp80| . ASP80)
   (|FortranCode| . FC)
   (|FortranCodePackage1| . FCPAK1)
   (|FortranExpression| . FEXPR)
   (|FortranMachineTypeCategory| . FMTC)
   (|FortranMatrixCategory| . FMC)
   (|FortranMatrixFunctionCategory| . FMFUN)
   (|FortranOutputStackPackage| . FOP)
   (|FortranPackage| . FORT)
   (|FortranProgramCategory| . FORTCAT)
   (|FortranProgram| . FORTRAN)
   (|FortranFunctionCategory| . FORTFN)
   (|FortranScalarType| . FST)
   (|FortranType| . FT)
   (|FortranTemplate| . FTEM)
   (|FortranVectorFunctionCategory| . FVFUN)
   (|FortranVectorCategory| . FVC)
   (|MachineComplex| . MCMPLX)
   (|MachineFloat| . MFLOAT)
   (|MachineInteger| . MINT)
   (|MultiVariableCalculusFunctions| . MCALCFN)
   (|NagDiscreteFourierTransformInterfacePackage| . NAGDIS)
   (|NagEigenInterfacePackage| . NAGEIG)
   (|NAGLinkSupportPackage| . NAGSP)
   (|NagOptimisationInterfacePackage| . NAGOPT)
   (|NagQuadratureInterfacePackage| . NAGQUA)
   (|NagResultChecks| . NAGRES)
   (|NagSpecialFunctionsInterfacePackage| . NAGSPE)
   (|NagPolynomialRootsPackage| . NAGC02)
   (|NagRootFindingPackage| . NAGC05)
   (|NagSeriesSummationPackage| . NAGC06)
   (|NagIntegrationPackage| . NAGD01)
   (|NagOrdinaryDifferentialEquationsPackage| . NAGD02)
   (|NagPartialDifferentialEquationsPackage| . NAGD03)
   (|NagInterpolationPackage| . NAGE01)
   (|NagFittingPackage| . NAGE02)
   (|NagOptimisationPackage| . NAGE04)
   (|NagMatrixOperationsPackage| . NAGF01)
   (|NagEigenPackage| . NAGF02)
   (|NagLinearEquationSolvingPackage| . NAGF04)
   (|NagLapack| . NAGF07)
   (|NagSpecialFunctionsPackage| . NAGS)
   (|PackedHermitianSequence| . PACKED)
   (|Result| . RESULT)
   (|SimpleFortranProgram| . SFORT)
   (|Switch| . SWITCH)
   (|SymbolTable| . SYMTAB)
   (|TemplateUtilities| . TEMUTL)
   (|TheSymbolTable| . SYMS)
   (|ThreeDimensionalMatrix| . M3D))
 (|anna|
   (|AnnaNumericalIntegrationPackage| . INTPACK)
   (|AnnaNumericalOptimizationPackage| . OPTPACK)
   (|AnnaOrdinaryDifferentialEquationPackage| . ODEPACK)
   (|AnnaPartialDifferentialEquationPackage| . PDEPACK)
   (|AttributeButtons| . ATTRBUT)
   (|BasicFunctions| . BFUNCT)
   (|d01ajfAnnaType| . D01AJFA)
   (|d01akfAnnaType| . D01AKFA)
   (|d01alfAnnaType| . D01ALFA)
   (|d01amfAnnaType| . D01AMFA)
   (|d01anfAnnaType| . D01ANFA)
   (|d01apfAnnaType| . D01APFA)
   (|d01aqfAnnaType| . D01AQFA)
   (|d01asfAnnaType| . D01ASFA)
   (|d01fcfAnnaType| . D01FCFA)
   (|d01gbfAnnaType| . D01GBFA)
   (|d01AgentsPackage| . D01AGNT)
   (|d01TransformFunctionType| . D01TRNS)
   (|d01WeightsPackage| . D01WGTS)
   (|d02AgentsPackage| . D02AGNT)
   (|d02bbfAnnaType| . D02BBFA)
   (|d02bhfAnnaType| . D02BHFA)
   (|d02cjfAnnaType| . D02CJFA)
   (|d02ejfAnnaType| . D02EJFA)
   (|d03AgentsPackage| . D03AGNT)
   (|d03eefAnnaType| . D03EEFA)
   (|d03fafAnnaType| . D03FAFA)
   (|e04AgentsPackage| . E04AGNT)
   (|e04dgfAnnaType| . E04DGFA)
   (|e04fdfAnnaType| . E04FDFA)
   (|e04gcfAnnaType| . E04GCFA)
   (|e04jafAnnaType| . E04JAFA)
   (|e04mbfAnnaType| . E04MBFA)
   (|e04nafAnnaType| . E04NAFA)
   (|e04ucfAnnaType| . E04UCFA)
   (|ExpertSystemContinuityPackage| . ESCONT)
   (|ExpertSystemContinuityPackage1| . ESCONT1)
   (|ExpertSystemToolsPackage| . ESTOOLS)
   (|ExpertSystemToolsPackage1| . ESTOOLS1)
   (|ExpertSystemToolsPackage2| . ESTOOLS2)
   (|NumericalIntegrationCategory| . NUMINT)
   (|NumericalIntegrationProblem| . NIPROB)
   (|NumericalODEProblem| . ODEPROB)
   (|NumericalOptimizationCategory| . OPTCAT)
   (|NumericalOptimizationProblem| . OPTPROB)
   (|NumericalPDEProblem| . PDEPROB)
   (|ODEIntensityFunctionsTable| . ODEIFTBL)
   (|IntegrationFunctionsTable| . INTFTBL)
   (|OrdinaryDifferentialEquationsSolverCategory| . ODECAT)
   (|PartialDifferentialEquationsSolverCategory| . PDECAT)
   (|RoutinesTable| . ROUTINE))
 (|categories| 
   (|AbelianGroup| . ABELGRP)
   (|AbelianMonoid| . ABELMON)
   (|AbelianMonoidRing| . AMR)
   (|AbelianSemiGroup| . ABELSG)
   (|AdditiveValuationAttribute| . ATADDVA)
   (|AffineSpaceCategory| . AFSPCAT)
   (|Aggregate| . AGG)
   (|Algebra| . ALGEBRA)
   (|AlgebraicallyClosedField| . ACF)
   (|AlgebraicallyClosedFunctionSpace| . ACFS)
   (|ApproximateAttribute| . ATAPPRO)
   (|ArbitraryExponentAttribute| . ATARBEX)
   (|ArbitraryPrecisionAttribute| . ATARBPR)
   (|ArcHyperbolicFunctionCategory| . AHYP)
   (|ArcTrigonometricFunctionCategory| . ATRIG)
   (|AssociationListAggregate| . ALAGG)
   (|AttributeRegistry| . ATTREG)
   (|BagAggregate| . BGAGG)
   (|BasicType| . BASTYPE)
   (|BiModule| . BMODULE)
   (|BinaryRecursiveAggregate| . BRAGG)
   (|BinaryTreeCategory| . BTCAT)
   (|BitAggregate| . BTAGG)
   (|BlowUpMethodCategory| . BLMETCT)
   (|CachableSet| . CACHSET)
   (|CancellationAbelianMonoid| . CABMON)
   (|CanonicalAttribute| . ATCANON)
   (|CanonicalClosedAttribute| . ATCANCL)
   (|CanonicalUnitNormalAttribute| . ATCUNOR)
   (|CentralAttribute| . ATCENRL)
   (|CharacteristicNonZero| . CHARNZ)
   (|CharacteristicZero| . CHARZ)
   (|CoercibleTo| . KOERCE)
   (|Collection| . CLAGG)
   (|CombinatorialFunctionCategory| . CFCAT)
   (|CombinatorialOpsCategory| . COMBOPC)
   (|CommutativeRing| . COMRING)
   (|CommutativeStarAttribute| . ATCS)
   (|Comparable| . COMPAR)
   (|ComplexCategory| . COMPCAT)
   (|ConvertibleTo| . KONVERT)
   (|DequeueAggregate| . DQAGG)
   (|DesingTreeCategory| . DSTRCAT)
   (|Dictionary| . DIAGG)
   (|DictionaryOperations| . DIOPS)
   (|DifferentialExtension| . DIFEXT)
   (|DifferentialPolynomialCategory| . DPOLCAT)
   (|DifferentialRing| . DIFRING)
   (|DifferentialVariableCategory| . DVARCAT)
   (|DirectProductCategory| . DIRPCAT)
   (|DivisionRing| . DIVRING)
   (|DivisorCategory| . DIVCAT)
   (|DoublyLinkedAggregate| . DLAGG)
   (|ElementaryFunctionCategory| . ELEMFUN)
   (|Eltable| . ELTAB)
   (|EltableAggregate| . ELTAGG)
   (|EntireRing| . ENTIRER)
   (|EuclideanDomain| . EUCDOM)
   (|Evalable| . EVALAB)
   (|ExpressionSpace| . ES)
   (|ExtensibleLinearAggregate| . ELAGG)
   (|ExtensionField| . XF)
   (|Field| . FIELD)
   (|FieldOfPrimeCharacteristic| . FPC)
   (|Finite| . FINITE)
   (|FileCategory| . FILECAT)
   (|FileNameCategory| . FNCAT)
   (|FiniteAbelianMonoidRing| . FAMR)
   (|FiniteAggregateAttribute| . ATFINAG)
   (|FiniteAlgebraicExtensionField| . FAXF)
   (|FiniteDivisorCategory| . FDIVCAT)
   (|FiniteFieldCategory| . FFIELDC)
   (|FiniteLinearAggregate| . FLAGG)
   (|FiniteRankNonAssociativeAlgebra| . FINAALG)
   (|FiniteRankAlgebra| . FINRALG)
   (|FiniteSetAggregate| . FSAGG)
   (|FloatingPointSystem| . FPS)
   (|FramedAlgebra| . FRAMALG)
   (|FramedNonAssociativeAlgebra| . FRNAALG)
   (|FramedNonAssociativeAlgebraFunctions2| . FRNAAF2)
   (|FreeAbelianMonoidCategory| . FAMONC)
   (|FreeLieAlgebra| . FLALG)
   (|FreeModuleCat| . FMCAT)
   (|FullyEvalableOver| . FEVALAB)
   (|FullyLinearlyExplicitRingOver| . FLINEXP)
   (|FullyPatternMatchable| . FPATMAB)
   (|FullyRetractableTo| . FRETRCT)
   (|FunctionFieldCategory| . FFCAT)
   (|FunctionSpace| . FS)
   (|GcdDomain| . GCDDOM)
   (|GradedAlgebra| . GRALG)
   (|GradedModule| . GRMOD)
   (|Group| . GROUP)
   (|HomogeneousAggregate| . HOAGG)
   (|HyperbolicFunctionCategory| . HYPCAT)
   (|IndexedAggregate| . IXAGG)
   (|IndexedDirectProductCategory| . IDPC)
   (|InfinitlyClosePointCategory| . INFCLCT)
   (|InnerEvalable| . IEVALAB)
   (|IntegerNumberSystem| . INS)
   (|IntegralDomain| . INTDOM)
   (|IntervalCategory| . INTCAT)
   (|KeyedDictionary| . KDAGG)
   (|JacobiIdentityAttribute| . ATJACID)
   (|LazyRepresentativeAttribute| . ATLR)
   (|LazyStreamAggregate| . LZSTAGG)
   (|LeftAlgebra| . LALG)
   (|LeftModule| . LMODULE)
   (|LeftOreRing| . LORER)
   (|LeftUnitaryAttribute| . ATLUNIT)
   (|LieAlgebra| . LIECAT)
   (|LinearAggregate| . LNAGG)
   (|LinearlyExplicitRingOver| . LINEXP)
   (|LinearOrdinaryDifferentialOperatorCategory| . LODOCAT)
   (|LiouvillianFunctionCategory| . LFCAT)
   (|ListAggregate| . LSAGG)
   (|LocalPowerSeriesCategory| . LOCPOWC)
   (|Logic| . LOGIC)
   (|ModularAlgebraicGcdOperations| . MAGCDOC)
   (|MatrixCategory| . MATCAT)
   (|Module| . MODULE)
   (|Monad| . MONAD)
   (|MonadWithUnit| . MONADWU)
   (|Monoid| . MONOID)
   (|MonogenicAlgebra| . MONOGEN)
   (|MonogenicLinearOperator| . MLO)
   (|MultiDictionary| . MDAGG)
   (|MultiplicativeValuationAttribute| . ATMULVA)
   (|MultisetAggregate| . MSETAGG)
   (|MultivariateTaylorSeriesCategory| . MTSCAT)
   (|NonAssociativeAlgebra| . NAALG)
   (|NonAssociativeRing| . NASRING)
   (|NonAssociativeRng| . NARNG)
   (|NormalizedTriangularSetCategory| . NTSCAT)
   (|NotherianAttribute| . ATNOTHR)
   (|NullSquareAttribute| . ATNULSQ)
   (|NoZeroDivisorsAttribute| . ATNZDIV)
   (|Object| . OBJECT)
   (|OctonionCategory| . OC)
   (|OneDimensionalArrayAggregate| . A1AGG)
   (|OpenMath| . OM)
   (|OrderedAbelianGroup| . OAGROUP)
   (|OrderedAbelianMonoid| . OAMON)
   (|OrderedAbelianMonoidSup| . OAMONS)
   (|OrderedAbelianSemiGroup| . OASGP)
   (|OrderedCancellationAbelianMonoid| . OCAMON)
   (|OrderedFinite| . ORDFIN)
   (|OrderedIntegralDomain| . OINTDOM)
   (|OrderedMonoid| . ORDMON)
   (|OrderedMultisetAggregate| . OMSAGG)
   (|OrderedRing| . ORDRING)
   (|OrderedSet| . ORDSET)
   (|PAdicIntegerCategory| . PADICCT)
   (|PartialDifferentialRing| . PDRING)
   (|PartiallyOrderedSetAttribute| . ATPOSET)
   (|PartialTranscendentalFunctions| . PTRANFN)
   (|Patternable| . PATAB)
   (|PatternMatchable| . PATMAB)
   (|PermutationCategory| . PERMCAT)
   (|PlacesCategory| . PLACESC)
   (|PlottablePlaneCurveCategory| . PPCURVE)
   (|PlottableSpaceCurveCategory| . PSCURVE)
   (|PointCategory| . PTCAT)
   (|PolynomialCategory| . POLYCAT)
   (|PolynomialFactorizationExplicit| . PFECAT)
   (|PolynomialSetCategory| . PSETCAT)
   (|PowerSeriesCategory| . PSCAT)
   (|PrimitiveFunctionCategory| . PRIMCAT)
   (|PrincipalIdealDomain| . PID)
   (|PriorityQueueAggregate| . PRQAGG)
   (|ProjectiveSpaceCategory| . PRSPCAT)
   (|PseudoAlgebraicClosureofAlgExtOfRationalNumberCategory| . PACEXTC)
   (|PseudoAlgebraicClosureOfFiniteField| . PACOFF)
   (|PseudoAlgebraicClosureOfFiniteFieldCategory| . PACFFC)
   (|PseudoAlgebraicClosureOfPerfectFieldCategory| . PACPERC)
   (|PseudoAlgebraicClosureOfRationalNumber| . PACRAT)
   (|PseudoAlgebraicClosureOfRationalNumberCategory| . PACRATC)
   (|QuaternionCategory| . QUATCAT)
   (|QueueAggregate| . QUAGG)
   (|QuotientFieldCategory| . QFCAT)
   (|RadicalCategory| . RADCAT)
   (|RealClosedField| . RCFIELD)
   (|RealConstant| . REAL)
   (|RealNumberSystem| . RNS)
   (|RealRootCharacterizationCategory| . RRCC)
   (|RectangularMatrixCategory| . RMATCAT)
   (|RecursiveAggregate| . RCAGG)
   (|RecursivePolynomialCategory| . RPOLCAT)
   (|RegularChain| . RGCHAIN)
   (|RegularTriangularSetCategory| . RSETCAT)
   (|RetractableTo| . RETRACT)
   (|RightModule| . RMODULE)
   (|Ring| . RING)
   (|RightUnitaryAttribute| . ATRUNIT)
   (|Rng| . RNG)
   (|SegmentCategory| . SEGCAT)
   (|SegmentExpansionCategory| . SEGXCAT)
   (|SemiGroup| . SGROUP)
   (|SetAggregate| . SETAGG)
   (|SetCategory| . SETCAT)
   (|SetCategoryWithDegree| . SETCATD)
   (|SExpressionCategory| . SEXCAT)
   (|ShallowlyMutableAttribute| . ATSHMUT)
   (|SpecialFunctionCategory| . SPFCAT)
   (|SquareFreeNormalizedTriangularSetCategory| . SNTSCAT)
   (|SquareFreeRegularTriangularSetCategory| . SFRTCAT)
   (|SquareMatrixCategory| . SMATCAT)
   (|StackAggregate| . SKAGG)
   (|StepThrough| . STEP)
   (|StreamAggregate| . STAGG)
   (|StringAggregate| . SRAGG)
   (|StringCategory| . STRICAT)
   (|StructuralConstantsPackage| . SCPKG)
   (|TableAggregate| . TBAGG)
   (|ThreeSpaceCategory| . SPACEC)
   (|TranscendentalFunctionCategory| . TRANFUN)
   (|TriangularSetCategory| . TSETCAT)
   (|TrigonometricFunctionCategory| . TRIGCAT)
   (|TwoDimensionalArrayCategory| . ARR2CAT)
   (|Type| . TYPE)
   (|UnaryRecursiveAggregate| . URAGG)
   (|UniqueFactorizationDomain| . UFD)
   (|UnitsKnownAttribute| . ATUNIKN)
   (|UnivariateLaurentSeriesCategory| . ULSCAT)
   (|UnivariateLaurentSeriesConstructorCategory| . ULSCCAT)
   (|UnivariatePolynomialCategory| . UPOLYC)
   (|UnivariatePowerSeriesCategory| . UPSCAT)
   (|UnivariatePuiseuxSeriesCategory| . UPXSCAT)
   (|UnivariatePuiseuxSeriesConstructorCategory| . UPXSCCA)
   (|UnivariateSkewPolynomialCategory| . OREPCAT)
   (|UnivariateTaylorSeriesCategory| . UTSCAT)
   (|VectorCategory| . VECTCAT)
   (|VectorSpace| . VSPACE)
   (|XAlgebra| . XALG)
   (|XFreeAlgebra| . XFALG)
   (|XPolynomialsCat| . XPOLYC)
   (|ZeroDimensionalSolvePackage| . ZDSOLVE))
 (|Hidden| 
   (|AlgebraicFunction| . AF)
   (|AlgebraicFunctionField| . ALGFF)
   (|AlgebraicHermiteIntegration| . INTHERAL)
   (|AlgebraicIntegrate| . INTALG)
   (|AlgebraicIntegration| . INTAF)
   (|AnonymousFunction| . ANON)
   (|AntiSymm| . ANTISYM)
   (|ApplyRules| . APPRULE)
   (|ApplyUnivariateSkewPolynomial| . APPLYORE)
   (|ArrayStack| . ASTACK)
   (|AssociatedEquations| . ASSOCEQ)
   (|AssociationList| . ALIST)
   (|Automorphism| . AUTOMOR)
   (|BalancedFactorisation| . BALFACT)
   (|BalancedPAdicInteger| . BPADIC)
   (|BalancedPAdicRational| . BPADICRT)
   (|BezoutMatrix| . BEZOUT)
   (|BoundIntegerRoots| . BOUNDZRO)
   (|BrillhartTests| . BRILL)
   (|ChangeOfVariable| . CHVAR)
   (|CharacteristicPolynomialInMonogenicalAlgebra| . CPIMA)
   (|ChineseRemainderToolsForIntegralBases| . IBACHIN)
   (|CoerceVectorMatrixPackage| . CVMP)
   (|CombinatorialFunction| . COMBF)
   (|CommonOperators| . COMMONOP)
   (|CommuteUnivariatePolynomialCategory| . COMMUPC)
   (|ComplexIntegerSolveLinearPolynomialEquation| . CINTSLPE)
   (|ComplexPattern| . COMPLPAT)
   (|ComplexPatternMatch| . CPMATCH)
   (|ComplexRootFindingPackage| . CRFP)
   (|ConstantLODE| . ODECONST)
   (|CyclicStreamTools| . CSTTOOLS)
   (|CyclotomicPolynomialPackage| . CYCLOTOM)
   (|DefiniteIntegrationTools| . DFINTTLS)
   (|DegreeReductionPackage| . DEGRED)
   (|DeRhamComplex| . DERHAM)
   (|DifferentialSparseMultivariatePolynomial| . DSMP)
   (|DirectProduct| . DIRPROD)
   (|DirectProductMatrixModule| . DPMM)
   (|DirectProductModule| . DPMO)
   (|DiscreteLogarithmPackage| . DLP)
   (|DistributedMultivariatePolynomial| . DMP)
   (|DoubleResultantPackage| . DBLRESP)
   (|DrawOptionFunctions0| . DROPT0)
   (|DrawOptionFunctions1| . DROPT1)
   (|ElementaryFunction| . EF)
   (|ElementaryFunctionsUnivariateLaurentSeries| . EFULS)
   (|ElementaryFunctionsUnivariatePuiseuxSeries| . EFUPXS)
   (|ElementaryIntegration| . INTEF)
   (|ElementaryRischDE| . RDEEF)
   (|ElementaryRischDESystem| . RDEEFS)
   (|EllipticFunctionsUnivariateTaylorSeries| . ELFUTS)
   (|EqTable| . EQTBL)
   (|EuclideanModularRing| . EMR)
   (|EvaluateCycleIndicators| . EVALCYC)
   (|ExponentialExpansion| . EXPEXPAN)
   (|ExponentialOfUnivariatePuiseuxSeries| . EXPUPXS)
   (|ExpressionSpaceFunctions1| . ES1)
   (|ExpressionTubePlot| . EXPRTUBE)
   (|ExtAlgBasis| . EAB)
   (|FactoredFunctions| . FACTFUNC)
   (|FactoredFunctionUtilities| . FRUTIL)
   (|FactoringUtilities| . FACUTIL)
   (|FGLMIfCanPackage| . FGLMICPK)
   (|FindOrderFinite| . FORDER)
   (|FiniteDivisor| . FDIV)
   (|FiniteFieldCyclicGroupExtension| . FFCGX)
   (|FiniteFieldCyclicGroupExtensionByPolynomial| . FFCGP)
   (|FiniteFieldExtension| . FFX)
   (|FiniteFieldExtensionByPolynomial| . FFP)
   (|FiniteFieldFunctions| . FFF)
   (|FiniteFieldNormalBasisExtension| . FFNBX)
   (|FiniteFieldNormalBasisExtensionByPolynomial| . FFNBP)
   (|FiniteFieldPolynomialPackage| . FFPOLY)
   (|FiniteFieldSolveLinearPolynomialEquation| . FFSLPE)
   (|FormalFraction| . FORMAL)
   (|FourierComponent| . FCOMP)
   (|FractionalIdeal| . FRIDEAL)
   (|FramedModule| . FRMOD)
   (|FreeAbelianGroup| . FAGROUP)
   (|FreeAbelianMonoid| . FAMONOID)
   (|FreeGroup| . FGROUP)
   (|FreeModule| . FM)
   (|FreeModule1| . FM1)
   (|FreeMonoid| . FMONOID)
   (|FunctionalSpecialFunction| . FSPECF)
   (|FunctionCalled| . FUNCTION)
   (|FunctionFieldIntegralBasis| . FFINTBAS)
   (|FunctionSpaceReduce| . FSRED)
   (|FunctionSpaceToUnivariatePowerSeries| . FS2UPS)
   (|FunctionSpaceToExponentialExpansion| . FS2EXPXP)
   (|FunctionSpaceUnivariatePolynomialFactor| . FSUPFACT)
   (|GaloisGroupFactorizationUtilities| . GALFACTU)
   (|GaloisGroupFactorizer| . GALFACT)
   (|GaloisGroupPolynomialUtilities| . GALPOLYU)
   (|GaloisGroupUtilities| . GALUTIL)
   (|GeneralHenselPackage| . GHENSEL)
   (|GeneralDistributedMultivariatePolynomial| . GDMP)
   (|GeneralPolynomialGcdPackage| . GENPGCD)
   (|GeneralSparseTable| . GSTBL)
   (|GenericNonAssociativeAlgebra| . GCNAALG)
   (|GenExEuclid| . GENEEZ)
   (|GeneralizedMultivariateFactorize| . GENMFACT)
   (|GeneralModulePolynomial| . GMODPOL)
   (|GeneralPolynomialSet| . GPOLSET)
   (|GeneralTriangularSet| . GTSET)
   (|GenUFactorize| . GENUFACT)
   (|GenusZeroIntegration| . INTG0)
   (|GosperSummationMethod| . GOSPER)
   (|GraphImage| . GRIMAGE)
   (|GrayCode| . GRAY)
   (|GroebnerInternalPackage| . GBINTERN)
   (|GroebnerSolve| . GROEBSOL)
   (|GuessOptionFunctions0| . GOPT0)
   (|HashTable| . HASHTBL)
   (|Heap| . HEAP)
   (|HeuGcd| . HEUGCD)
   (|HomogeneousDistributedMultivariatePolynomial| . HDMP)
   (|HyperellipticFiniteDivisor| . HELLFDIV)
   (|IncrementingMaps| . INCRMAPS)
   (|IndexedBits| . IBITS)
   (|IndexedDirectProductAbelianGroup| . IDPAG)
   (|IndexedDirectProductAbelianMonoid| . IDPAM)
   (|IndexedDirectProductObject| . IDPO)
   (|IndexedDirectProductOrderedAbelianMonoid| . IDPOAM)
   (|IndexedDirectProductOrderedAbelianMonoidSup| . IDPOAMS)
   (|IndexedExponents| . INDE)
   (|IndexedFlexibleArray| . IFARRAY)
   (|IndexedList| . ILIST)
   (|IndexedMatrix| . IMATRIX)
   (|IndexedOneDimensionalArray| . IARRAY1)
   (|IndexedString| . ISTRING)
   (|IndexedTwoDimensionalArray| . IARRAY2)
   (|IndexedVector| . IVECTOR)
   (|InnerAlgFactor| . IALGFACT)
   (|InnerAlgebraicNumber| . IAN)
   (|InnerCommonDenominator| . ICDEN)
   (|InnerFiniteField| . IFF)
   (|InnerFreeAbelianMonoid| . IFAMON)
   (|InnerIndexedTwoDimensionalArray| . IIARRAY2)
   (|InnerMatrixLinearAlgebraFunctions| . IMATLIN)
   (|InnerMatrixQuotientFieldFunctions| . IMATQF)
   (|InnerModularGcd| . INMODGCD)
   (|InnerMultFact| . INNMFACT)
   (|InnerNormalBasisFieldFunctions| . INBFF)
   (|InnerNumericEigenPackage| . INEP)
   (|InnerNumericFloatSolvePackage| . INFSP)
   (|InnerPAdicInteger| . IPADIC)
   (|InnerPolySign| . INPSIGN)
   (|InnerPolySum| . ISUMP)
   (|InnerPrimeField| . IPF)
   (|InnerSparseUnivariatePowerSeries| . ISUPS)
   (|InnerTable| . INTABL)
   (|InnerTaylorSeries| . ITAYLOR)
   (|InnerTrigonometricManipulations| . ITRIGMNP)
   (|InputForm| . INFORM)
   (|InputFormFunctions1| . INFORM1)
   (|IntegerBits| . INTBIT)
   (|IntegerFactorizationPackage| . INTFACT)
   (|IntegerMod| . ZMOD)
   (|IntegerSolveLinearPolynomialEquation| . INTSLPE)
   (|IntegralBasisPolynomialTools| . IBPTOOLS)
   (|IntegralBasisTools| . IBATOOL)
   (|IntegrationResult| . IR)
   (|IntegrationTools| . INTTOOLS)
   (|InternalPrintPackage| . IPRNTPK)
   (|InternalRationalUnivariateRepresentationPackage| . IRURPK)
   (|IrredPolyOverFiniteField| . IRREDFFX)
   (|Kernel| . KERNEL)
   (|Kovacic| . KOVACIC)
   (|LaurentPolynomial| . LAUPOL)
   (|LeadingCoefDetermination| . LEADCDET)
   (|LexTriangularPackage| . LEXTRIPK)
   (|LieExponentials| . LEXP)
   (|LiePolynomial| . LPOLY)
   (|LinearDependence| . LINDEP)
   (|LinearOrdinaryDifferentialOperatorFactorizer| . LODOF)
   (|LinearOrdinaryDifferentialOperator1| . LODO1)
   (|LinearOrdinaryDifferentialOperator2| . LODO2)
   (|LinearOrdinaryDifferentialOperatorsOps| . LODOOPS)
   (|LinearPolynomialEquationByFractions| . LPEFRAC)
   (|LinGroebnerPackage| . LGROBP)
   (|LiouvillianFunction| . LF)
   (|ListMonoidOps| . LMOPS)
   (|ListMultiDictionary| . LMDICT)
   (|LocalAlgebra| . LA)
   (|Localize| . LO)
   (|LyndonWord| . LWORD)
   (|Magma| . MAGMA)
   (|MakeBinaryCompiledFunction| . MKBCFUNC)
   (|MakeCachableSet| . MKCHSET)
   (|MakeUnaryCompiledFunction| . MKUCFUNC)
   (|MappingPackageInternalHacks1| . MAPHACK1)
   (|MappingPackageInternalHacks2| . MAPHACK2)
   (|MappingPackageInternalHacks3| . MAPHACK3)
   (|MeshCreationRoutinesForThreeDimensions| . MESH)
   (|ModMonic| . MODMON)
   (|ModularField| . MODFIELD)
   (|ModularHermitianRowReduction| . MHROWRED)
   (|ModularRing| . MODRING)
   (|ModuleMonomial| . MODMONOM)
   (|MoebiusTransform| . MOEBIUS)
   (|MonoidRing| . MRING)
   (|MonomialExtensionTools| . MONOTOOL)
   (|MPolyCatPolyFactorizer| . MPCPF)
   (|MPolyCatFunctions3| . MPC3)
   (|MRationalFactorize| . MRATFAC)
   (|MultipleMap| . MMAP)
   (|MultivariateLifting| . MLIFT)
   (|MultivariateSquareFree| . MULTSQFR)
   (|HomogeneousDirectProduct| . HDP)
   (|NewSparseMultivariatePolynomial| . NSMP)
   (|NewSparseUnivariatePolynomial| . NSUP)
   (|NewSparseUnivariatePolynomialFunctions2| . NSUP2)
   (|NonCommutativeOperatorDivision| . NCODIV)
   (|NewtonInterpolation| . NEWTON)
   (|None| . NONE)
   (|NonLinearFirstOrderODESolver| . NODE1)
   (|NonLinearSolvePackage| . NLINSOL)
   (|NormRetractPackage| . NORMRETR)
   (|NPCoef| . NPCOEF)
   (|NumberFormats| . NUMFMT)
   (|NumberFieldIntegralBasis| . NFINTBAS)
   (|NumericTubePlot| . NUMTUBE)
   (|ODEIntegration| . ODEINT)
   (|ODETools| . ODETOOLS)
   (|Operator| . OP)
   (|OppositeMonogenicLinearOperator| . OMLO)
   (|OrderedDirectProduct| . ODP)
   (|OrderedFreeMonoid| . OFMONOID)
   (|OrderedVariableList| . OVAR)
   (|OrderingFunctions| . ORDFUNS)
   (|OrderlyDifferentialPolynomial| . ODPOL)
   (|OrderlyDifferentialVariable| . ODVAR)
   (|OrdinaryWeightedPolynomials| . OWP)
   (|OutputForm| . OUTFORM)
   (|PadeApproximants| . PADE)
   (|PAdicInteger| . PADIC)
   (|PAdicRational| . PADICRAT)
   (|PAdicRationalConstructor| . PADICRC)
   (|PAdicWildFunctionFieldIntegralBasis| . PWFFINTB)
   (|ParadoxicalCombinatorsForStreams| . YSTREAM)
   (|ParametricLinearEquations| . PLEQN)
   (|PartialFractionPackage| . PFRPAC)
   (|Partition| . PRTITION)
   (|Pattern| . PATTERN)
   (|PatternFunctions1| . PATTERN1)
   (|PatternMatchFunctionSpace| . PMFS)
   (|PatternMatchIntegerNumberSystem| . PMINS)
   (|PatternMatchIntegration| . INTPM)
   (|PatternMatchKernel| . PMKERNEL)
   (|PatternMatchListAggregate| . PMLSAGG)
   (|PatternMatchListResult| . PATLRES)
   (|PatternMatchPolynomialCategory| . PMPLCAT)
   (|PatternMatchPushDown| . PMDOWN)
   (|PatternMatchQuotientFieldCategory| . PMQFCAT)
   (|PatternMatchResult| . PATRES)
   (|PatternMatchSymbol| . PMSYM)
   (|PatternMatchTools| . PMTOOLS)
   (|PlaneAlgebraicCurvePlot| . ACPLOT)
   (|Plot| . PLOT)
   (|PlotFunctions1| . PLOT1)
   (|PlotTools| . PLOTTOOL)
   (|Plot3D| . PLOT3D)
   (|PoincareBirkhoffWittLyndonBasis| . PBWLB)
   (|Point| . POINT)
   (|PointsOfFiniteOrder| . PFO)
   (|PointsOfFiniteOrderRational| . PFOQ)
   (|PointsOfFiniteOrderTools| . PFOTOOLS)
   (|PointPackage| . PTPACK)
   (|PolToPol| . POLTOPOL)
   (|PolynomialCategoryLifting| . POLYLIFT)
   (|PolynomialCategoryQuotientFunctions| . POLYCATQ)
   (|PolynomialFactorizationByRecursion| . PFBR)
   (|PolynomialFactorizationByRecursionUnivariate| . PFBRU)
   (|PolynomialGcdPackage| . PGCD)
   (|PolynomialInterpolation| . PINTERP)
   (|PolynomialInterpolationAlgorithms| . PINTERPA)
   (|PolynomialNumberTheoryFunctions| . PNTHEORY)
   (|PolynomialRing| . PR)
   (|PolynomialRoots| . POLYROOT)
   (|PolynomialSetUtilitiesPackage| . PSETPK)
   (|PolynomialSolveByFormulas| . SOLVEFOR)
   (|PolynomialSquareFree| . PSQFR)
   (|PrecomputedAssociatedEquations| . PREASSOC)
   (|PrimitiveArray| . PRIMARR)
   (|PrimitiveElement| . PRIMELT)
   (|PrimitiveRatDE| . ODEPRIM)
   (|PrimitiveRatRicDE| . ODEPRRIC)
   (|Product| . PRODUCT)
   (|PseudoRemainderSequence| . PRS)
   (|PseudoLinearNormalForm| . PSEUDLIN)
   (|PureAlgebraicIntegration| . INTPAF)
   (|PureAlgebraicLODE| . ODEPAL)
   (|PushVariables| . PUSHVAR)
   (|QuasiAlgebraicSet| . QALGSET)
   (|QuasiAlgebraicSet2| . QALGSET2)
   (|RadicalFunctionField| . RADFF)
   (|RandomDistributions| . RDIST)
   (|RandomFloatDistributions| . RFDIST)
   (|RandomIntegerDistributions| . RIDIST)
   (|RationalFactorize| . RATFACT)
   (|RationalIntegration| . INTRAT)
   (|RationalInterpolation| . RINTERP)
   (|RationalLODE| . ODERAT)
   (|RationalRicDE| . ODERTRIC)
   (|RationalUnivariateRepresentationPackage| . RURPK)
   (|RealSolvePackage| . REALSOLV)
   (|RectangularMatrix| . RMATRIX)
   (|ReducedDivisor| . RDIV)
   (|ReduceLODE| . ODERED)
   (|ReductionOfOrder| . REDORDER)
   (|Reference| . REF)
   (|RepeatedDoubling| . REPDB)
   (|RepeatedSquaring| . REPSQ)
   (|ResidueRing| . RESRING)
   (|RetractSolvePackage| . RETSOL)
   (|RuleCalled| . RULECOLD)
   (|SetOfMIntegersInOneToN| . SETMN)
   (|SExpression| . SEX)
   (|SExpressionOf| . SEXOF)
   (|SequentialDifferentialPolynomial| . SDPOL)
   (|SequentialDifferentialVariable| . SDVAR)
   (|SimpleAlgebraicExtension| . SAE)
   (|SingletonAsOrderedSet| . SAOS)
   (|SortedCache| . SCACHE)
   (|SortPackage| . SORTPAK)
   (|SparseMultivariatePolynomial| . SMP)
   (|SparseMultivariateTaylorSeries| . SMTS)
   (|SparseTable| . STBL)
   (|SparseUnivariatePolynomial| . SUP)
   (|SparseUnivariateSkewPolynomial| . ORESUP)
   (|SparseUnivariateLaurentSeries| . SULS)
   (|SparseUnivariatePuiseuxSeries| . SUPXS)
   (|SparseUnivariateTaylorSeries| . SUTS)
   (|SplitHomogeneousDirectProduct| . SHDP)
   (|SplittingNode| . SPLNODE)
   (|SplittingTree| . SPLTREE)
   (|SquareMatrix| . SQMATRIX)
   (|Stack| . STACK)
   (|StorageEfficientMatrixOperations| . MATSTOR)
   (|StreamInfiniteProduct| . STINPROD)
   (|StreamTaylorSeriesOperations| . STTAYLOR)
   (|StreamTranscendentalFunctions| . STTF)
   (|StreamTranscendentalFunctionsNonCommutative| . STTFNC)
   (|StringTable| . STRTBL)
   (|SubResultantPackage| . SUBRESP)
   (|SubSpace| . SUBSPACE)
   (|SubSpaceComponentProperty| . COMPPROP)
   (|SuchThat| . SUCH)
   (|SupFractionFactorizer| . SUPFRACF)
   (|SymmetricFunctions| . SYMFUNC)
   (|SymmetricPolynomial| . SYMPOLY)
   (|SystemODESolver| . ODESYS)
   (|Table| . TABLE)
   (|TableauxBumpers| . TABLBUMP)
   (|TabulatedComputationPackage| . TBCMPPK)
   (|TangentExpansions| . TANEXP)
   (|ToolsForSign| . TOOLSIGN)
   (|TranscendentalHermiteIntegration| . INTHERTR)
   (|TranscendentalIntegration| . INTTR)
   (|TranscendentalRischDE| . RDETR)
   (|TranscendentalRischDESystem| . RDETRS)
   (|TransSolvePackageService| . SOLVESER)
   (|TriangularMatrixOperations| . TRIMAT)
   (|TubePlot| . TUBE)
   (|TubePlotTools| . TUBETOOL)
   (|Tuple| . TUPLE)
   (|TwoDimensionalArray| . ARRAY2)
   (|TwoDimensionalPlotClipping| . CLIP)
   (|TwoDimensionalViewport| . VIEW2D)
   (|TwoFactorize| . TWOFACT)
   (|UnivariateFactorize| . UNIFACT)
   (|UnivariateLaurentSeries| . ULS)
   (|UnivariateLaurentSeriesConstructor| . ULSCONS)
   (|UnivariatePolynomialDecompositionPackage| . UPDECOMP)
   (|UnivariatePolynomialDivisionPackage| . UPDIVP)
   (|UnivariatePolynomialSquareFree| . UPSQFREE)
   (|UnivariatePuiseuxSeries| . UPXS)
   (|UnivariatePuiseuxSeriesConstructor| . UPXSCONS)
   (|UnivariatePuiseuxSeriesWithExponentialSingularity| . UPXSSING)
   (|UnivariateSkewPolynomial| . OREUP)
   (|UnivariateSkewPolynomialCategoryOps| . OREPCTO)
   (|UnivariateTaylorSeries| . UTS)
   (|UnivariateTaylorSeriesODESolver| . UTSODE)
   (|UserDefinedPartialOrdering| . UDPO)
   (|UTSodetools| . UTSODETL)
   (|Variable| . VARIABLE)
   (|ViewportPackage| . VIEW)
   (|WeierstrassPreparation| . WEIER)
   (|WeightedPolynomials| . WP)
   (|WildFunctionFieldIntegralBasis| . WFFINTBS)
   (|XDistributedPolynomial| . XDPOLY)
   (|XExponentialPackage| . XEXPPKG)
   (|XPBWPolynomial| . XPBWPOLY)
   (|XPolynomial| . XPOLY)
   (|XPolynomialRing| . XPR)
   (|XRecursivePolynomial| . XRPOLY))
 (|defaults| 
   (|AbelianGroup&| . ABELGRP-)
   (|AbelianMonoid&| . ABELMON-)
   (|AbelianMonoidRing&| . AMR-)
   (|AbelianSemiGroup&| . ABELSG-)
   (|Aggregate&| . AGG-)
   (|Algebra&| . ALGEBRA-)
   (|AlgebraicallyClosedField&| . ACF-)
   (|AlgebraicallyClosedFunctionSpace&| . ACFS-)
   (|ArcTrigonometricFunctionCategory&| . ATRIG-)
   (|BagAggregate&| . BGAGG-)
   (|BasicType&| . BASTYPE-)
   (|BinaryRecursiveAggregate&| . BRAGG-)
   (|BinaryTreeCategory&| . BTCAT-)
   (|BitAggregate&| . BTAGG-)
   (|Collection&| . CLAGG-)
   (|ComplexCategory&| . COMPCAT-)
   (|Dictionary&| . DIAGG-)
   (|DictionaryOperations&| . DIOPS-)
   (|DifferentialExtension&| . DIFEXT-)
   (|DifferentialPolynomialCategory&| . DPOLCAT-)
   (|DifferentialRing&| . DIFRING-)
   (|DifferentialVariableCategory&| . DVARCAT-)
   (|DirectProductCategory&| . DIRPCAT-)
   (|DivisionRing&| . DIVRING-)
   (|ElementaryFunctionCategory&| . ELEMFUN-)
   (|EltableAggregate&| . ELTAGG-)
   (|EuclideanDomain&| . EUCDOM-)
   (|Evalable&| . EVALAB-)
   (|ExpressionSpace&| . ES-)
   (|ExtensibleLinearAggregate&| . ELAGG-)
   (|ExtensionField&| . XF-)
   (|Field&| . FIELD-)
   (|FieldOfPrimeCharacteristic&| . FPC-)
   (|FiniteAbelianMonoidRing&| . FAMR-)
   (|FiniteAlgebraicExtensionField&| . FAXF-)
   (|FiniteDivisorCategory&| . FDIVCAT-)
   (|FiniteFieldCategory&| . FFIELDC-)
   (|FiniteLinearAggregate&| . FLAGG-)
   (|FiniteSetAggregate&| . FSAGG-)
   (|FiniteRankAlgebra&| . FINRALG-)
   (|FiniteRankNonAssociativeAlgebra&| . FINAALG-)
   (|FloatingPointSystem&| . FPS-)
   (|FramedAlgebra&| . FRAMALG-)
   (|FramedNonAssociativeAlgebra&| . FRNAALG-)
   (|FullyEvalableOver&| . FEVALAB-)
   (|FullyLinearlyExplicitRingOver&| . FLINEXP-)
   (|FullyRetractableTo&| . FRETRCT-)
   (|FunctionFieldCategory&| . FFCAT-)
   (|FunctionSpace&| . FS-)
   (|GcdDomain&| . GCDDOM-)
   (|GradedAlgebra&| . GRALG-)
   (|GradedModule&| . GRMOD-)
   (|Group&| . GROUP-)
   (|HomogeneousAggregate&| . HOAGG-)
   (|HyperbolicFunctionCategory&| . HYPCAT-)
   (|IndexedAggregate&| . IXAGG-)
   (|InnerEvalable&| . IEVALAB-)
   (|IntegerNumberSystem&| . INS-)
   (|IntegralDomain&| . INTDOM-)
   (|KeyedDictionary&| . KDAGG-)
   (|LazyStreamAggregate&| . LZSTAGG-)
   (|LeftAlgebra&| . LALG-)
   (|LieAlgebra&| . LIECAT-)
   (|LinearAggregate&| . LNAGG-)
   (|ListAggregate&| . LSAGG-)
   (|Logic&| . LOGIC-)
   (|LinearOrdinaryDifferentialOperatorCategory&| . LODOCAT-)
   (|MatrixCategory&| . MATCAT-)
   (|Module&| . MODULE-)
   (|Monad&| . MONAD-)
   (|MonadWithUnit&| . MONADWU-)
   (|Monoid&| . MONOID-)
   (|MonogenicAlgebra&| . MONOGEN-)
   (|NonAssociativeAlgebra&| . NAALG-)
   (|NonAssociativeRing&| . NASRING-)
   (|NonAssociativeRng&| . NARNG-)
   (|OctonionCategory&| . OC-)
   (|OneDimensionalArrayAggregate&| . A1AGG-)
   (|OrderedRing&| . ORDRING-)
   (|OrderedSet&| . ORDSET-)
   (|PartialDifferentialRing&| . PDRING-)
   (|PolynomialCategory&| . POLYCAT-)
   (|PolynomialFactorizationExplicit&| . PFECAT-)
   (|PolynomialSetCategory&| . PSETCAT-)
   (|PowerSeriesCategory&| . PSCAT-)
   (|QuaternionCategory&| . QUATCAT-)
   (|QuotientFieldCategory&| . QFCAT-)
   (|RadicalCategory&| . RADCAT-)
   (|RealClosedField&| . RCFIELD-)
   (|RealNumberSystem&| . RNS-)
   (|RealRootCharacterizationCategory&| . RRCC-)
   (|RectangularMatrixCategory&| . RMATCAT-)
   (|RecursiveAggregate&| . RCAGG-)
   (|RecursivePolynomialCategory&| . RPOLCAT-)
   (|RegularTriangularSetCategory&| . RSETCAT-)
   (|RetractableTo&| . RETRACT-)
   (|Ring&| . RING-)
   (|SemiGroup&| . SGROUP-)
   (|SetAggregate&| . SETAGG-)
   (|SetCategory&| . SETCAT-)
   (|SquareMatrixCategory&| . SMATCAT-)
   (|StreamAggregate&| . STAGG-)
   (|StringAggregate&| . SRAGG-)
   (|TableAggregate&| . TBAGG-)
   (|TranscendentalFunctionCategory&| . TRANFUN-)
   (|TriangularSetCategory&| . TSETCAT-)
   (|TrigonometricFunctionCategory&| . TRIGCAT-)
   (|TwoDimensionalArrayCategory&| . ARR2CAT-)
   (|UnaryRecursiveAggregate&| . URAGG-)
   (|UniqueFactorizationDomain&| . UFD-)
   (|UnivariateLaurentSeriesConstructorCategory&| . ULSCCAT-)
   (|UnivariatePolynomialCategory&| . UPOLYC-)
   (|UnivariatePowerSeriesCategory&| . UPSCAT-)
   (|UnivariatePuiseuxSeriesConstructorCategory&| . UPXSCCA-)
   (|UnivariateSkewPolynomialCategory&| . OREPCAT-)
   (|UnivariateTaylorSeriesCategory&| . UTSCAT-)
   (|VectorCategory&| . VECTCAT-)
   (|VectorSpace&| . VSPACE-))))

\end{chunk}

\chapter{The global variables}

\subsection{Credits}
Axiom has a very long history and many people have contributed to the
effort, some in large ways and some in small ways. Any and all effort
deserves recognition. There is no other criteria than contribution
of effort. We would like to acknowledge and thank the following people:
\defvar{creditlist}
\begin{chunk}{initvars}
(defvar creditlist '(
"An alphabetical listing of contributors to AXIOM:"
"Roy Adler              Christian Aistleitner  Michael Albaugh"
"Cyril Alberga          Jason Allen            Richard Anderson"
"George Andrews         Jerry Archibald        S.J. Atkins"
"Jeremy Avigad          Brent Baccala          Knut Bahr"
"Henry Baker            Martin Baker           Stephen Balzac"
"Yurij Baransky         David R. Barton        Thomas Baruchel"
"Gerald Baumgartner     Gilbert Baumslag       Michael Becker"
"Nelson H. F. Beebe     Jay Belanger           Siddharth Bhat"
"David Bindel           Fred Blair             Vladimir Bondarenko"
"Ed Borasky             Mark Botch             Raoul Bourquin"
"Alexandre Bouyer       Karen Braman           Wolfgang Brehm"
"Peter A. Broadbery     Martin Brock           Manuel Bronstein"
"Christopher Brown      Stephen Buchwald       Florian Bundschuh"
"Luanne Burns           William Burge          Ralph Byers"
"Quentin Carpent        Jacques Carette        Pierre Casteran"
"Robert Cavines         Pablo Cayuela          Bruce Char"
"Ondrej Certik          Tzu-Yi Chen            Bobby Cheng"
"Cheekai Chin           David V. Chudnovsky    Gregory V. Chudnovsky"
"Mark Clements          Roland Coeurjoly       Emil Cohen"
"Hirsh Cohen            Josh Cohen             James Cloos"
"Jia Zhao Cong          Christophe Conil       Don Coppersmith"
"George Corliss         Robert Corless         Gary Cornell"
"Frank Costa            Meino Cramer           Karl Crary"
"Jeremy Du Croz         David Cyganski         Nathaniel Daly"
"Timothy Daly Sr.       Timothy Daly Jr.       James H. Davenport"
"David Day              James Demmel           Didier Deshommes"
"Michael Dewar          Inderjit Dhillon       Jack Dongarra"
"Jean Della Dora        Gabriel Dos Reis       Claire DiCrescendo"
"Sam Dooley             Pierre Doucy           Nicolas James Doye"
"Zlatko Drmac           Lionel Ducos           Iain Duff"
"Lee Duhem              Martin Dunstan         Brian Dupee"
"Dominique Duval        Robert Edwards         Hans-Dieter Ehrich"
"Heow Eide-Goodman      Alexandra Elbakyan     Carl Engelman"
"Lars Erickson          Mark Fahey             William Farmer"
"Richard Fateman        Bertfried Fauser       Stuart Feldman"
"John Fletcher          Brian Ford             Albrecht Fortenbacher"
"George Frances         Constantine Frangos    Timothy Freeman"
"Korrinn Fu             Marc Gaetano           Rudiger Gebauer"
"Van de Geijn           Kathy Gerber           Patricia Gianni"
"Eitan Gurari           Gustavo Goertkin       Samantha Goldrich"
"Max Goldstein          Holger Gollan          Teresa Gomez-Diaz"
"Ralph Gomory           Laureano Gonzalez-Vega Stephen Gortler"
"Johannes Grabmeier     Matt Grayson           Martin Griss"
"Andrey G. Grozin       Klaus Ebbe Grue        James Griesmer"
"Vladimir Grinberg      Oswald Gschnitzer      Ming Gu"
"Fred Gustavson         Jocelyn Guidry         Gaetan Hache"
"Steve Hague            Satoshi Hamaguchi      Sven Hammarling"
"Mike Hansen            Richard Hanson         Richard Harke"
"Joseph Harry           Bill Hart              Vilya Harvey"
"Martin Hassner         Arthur S. Hathaway     Dan Hatton"
"Waldek Hebisch         Karl Hegbloom          Ralf Hemmecke"
"Tony Hearn             Henderson              Antoine Hersen"
"Nicholas J. Higham     Lou Hodes              Alan Hoffman"
"Hoon Hong              Roger House            Joris van der Hoeven"
"Gernot Hueber          Pietro Iglio           Joan Jaffe"
"Alejandro Jakubi       Richard Jenks          Bo Kagstrom"
"William Kahan          Kyriakos Kalorkoti     Kai Kaminski"
"Matt Kaufmann          Grant Keady            Tom Kelsey"
"Wilfrid Kendall        Tony Kennedy           David Kincaid"
"Keshav Kini            Knut Korsvold          Ted Kosan"
"Paul Kosinski          Igor Kozachenko        Fred Krogh"
"Klaus Kusche           Bernhard Kutzler       Tim Lahey"
"Larry Lambe            Magnus Larsson         Kaj Laurson"
"Charles Lawson         George L. Legendre     Franz Lehner"
"Frederic Lehobey       Michel Levaud          Howard Levy"
"J. Lewis               Ren-Cang Li            Xin Li"
"John Lipson            Rudiger Loos           Craig Lucas"
"Michael Lucks          Richard Luczak         Camm Maguire"
"Dave Mainey            Francois Maltey        William Martin"
"Ursula Martin          Dan Martins            Osni Marques"
"Alasdair McAndrew      Bob McElrath           Michael McGettrick"
"Roland McGrath         Paul McJones           Bob McNeill"
"Edi Meier              Ian Meikle             David Mentre"
"Simon Michael          Jonathan Millen        Victor S. Miller"
"Gerard Milmeister      William Miranker       Mohammed Mobarak"
"H. Michael Moeller     Michael Monagan        Marc Moreno-Maza"
"Scott Morrison         Joel Moses             Mark Murray"
"William Naylor         Patrice Naudin         C. Andrew Neff"
"John Nelder            Godfrey Nolan          Arthur Norman"
"Jinzhong Niu           Michael O'Connor       Summat Oemrawsingh"
"Kostas Oikonomou       Humberto Ortiz-Zuazaga Julian A. Padget"
"Bill Page              David Parnas           Igor Pashev"
"Norm Pass              Susan Pelzel           Michel Petitot"
"Didier Pinchon         Ayal Pinkus            Frederick H. Pitts"
"Frank Pfenning         Erik Poll              Jose Alfredo Portes"
"E. Quintana-Orti       Gregorio Quintana-Orti Beresford Parlett"
"A. Petitet             Andre Platzer          Peter Poromaas"
"Greg Puhak             Claude Quitte          Arthur C. Ralfs"
"Norman Ramsey          Anatoly Raportirenko   Guilherme Reis"
"Huan Ren               Albert D. Rich         Michael Richardson"
"Jason Riedy            Renaud Rioboo          Robert Risch"
"Wilken Rivera          Jean Rivlin            Nicolas Robidoux"
"Simon Robinson         Raymond Rogers         Michael Rothstein"
"Martin Rubey           Jeff Rutter            R.W Ryniker II"
"Philip Santas          Grigory Sarnitskiy     David Saunders"
"Aleksej Saushev        Alfred Scheerhorn      William Schelter"
"Gerhard Schneider      Martin Schoenert       Marshall Schor"
"Frithjof Schulze       Fritz Schwartz         Jens Axel Segaard"
"Steven Segletes        Srinivasan Seshan      V. Sima"
"Nick Simicich          Peter Simons           William Sit"
"Elena Smirnova         Jacob Nyffeler Smith   Matthieu Sozeau"
"Richard Stallman       Ken Stanley            William Stein"
"Jonathan Steinbach     Alexander Stepanov     Doug Stewart"
"Fabio Stumbo           Christine Sundaresan   Ben Collins-Sussman"
"Klaus Sutner           Robert Sutor           Moss E. Sweedler"
"Eugene Surowitz        Yong Kiam Tan          Max Tegmark"
"T. Doug Telford        James Thatcher         Laurent Thery"
"Balbir Thomas          Mike Thomas            Carol Thompson"
"Simon Thompson         Dylan Thurston         Francoise Tisseur"
"Steve Toleque          Dick Toupin            Raymond Toy"
"Barry Trager           Hale Trotter           Themos T. Tsikas"
"Gregory Vanuxem        Kresimir Veselic       Christof Voemel"
"E.G. Wagner            Bernhard Wall          Justin Walker"
"Paul Wang              Stephen Watt           Andreas Weber"
"Jaap Weel              Al Weis                Juergen Weiss"
"M. Weller              Mark Wegman            James Wen"
"Thorsten Werther       Michael Wester         R. Clint Whaley"
"James T. Wheeler       John M. Wiley          Berhard Will"
"Clifton J. Williamson  Stephen Wilson         Shmuel Winograd"
"Robert Wisbauer        Sandra Wityak          Waldemar Wiwianka"
"Knut Wolf              Hans Peter Wuermli     Yanyang Xiao"
"Liu Xiaojun            Clifford Yapp          David Yun"
"Qian Yun               Vadim Zhytnikov        Paul Zimmermann"
"Richard Zippel         Wolfgang Zocher        Evelyn Zoernack"
"Bruno Zuercher         Dan Zwillinger  "
))

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The \verb|$current-directory| variable is set to the current directory 
at startup. This is used by the \verb|)cd| function and some of the 
compile routines. This is the result of the \refto{get-current-directory}
function. This variable is used to set \verb|*default-pathname-defaults*|.
The \refto{reroot} function resets it to \verb|$spadroot|.

An example of a runtime value is:
\begin{verbatim}
$current-directory = "/research/test/"
\end{verbatim}

\defdollar{current-directory}
\begin{chunk}{initvars}
(defvar $current-directory nil)

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The \verb|$directory-list| is a runtime list of absolute pathnames.
This list is generated by \refto{reroot} from the list of
relative paths held in the variable
\verb|$relative-directory-list|. Each entry will be prefixed by
\verb|$spadroot|.

An example of a runtime value is:
\begin{verbatim}
$directory-list =
  ("/research/test/mnt/ubuntu/../../src/input/" 
   "/research/test/mnt/ubuntu/doc/msgs/" 
   "/research/test/mnt/ubuntu/../../src/algebra/" 
   "/research/test/mnt/ubuntu/../../src/interp/" 
   "/research/test/mnt/ubuntu/doc/spadhelp/")
\end{verbatim}

\defdollar{directory-list}
\begin{chunk}{initvars}
(defvar $directory-list nil)

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The \verb|$InitialModemapFrame| is used as the initial value.

See the function \fnref{makeInitialModemapFrame}.

An example of a runtime value is:
\begin{verbatim}
$InitialModemapFrame = '((nil))
\end{verbatim}

\defdollar{InitialModemapFrame}
\begin{chunk}{initvars}
(defvar |$InitialModemapFrame| '((nil)))

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The \verb|$library-directory-list| variable is the system-wide search
path for library files.  \refto{reroot} 
prepends the \verb|$spadroot| variable to the 
\verb|$relative-library-directory-list| variable.

An example of a runtime value is:
\begin{verbatim}
$library-directory-list =  ("/research/test/mnt/ubuntu/algebra/")
\end{verbatim}

\defdollar{library-directory-list}
\begin{chunk}{initvars}
(defvar $library-directory-list '("/algebra/"))

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The \verb|$msgDatabaseName| is a locally shared variable among the
message database routines.

An example of a runtime value is:
\begin{verbatim}
|$msgDatabaseName| = nil
\end{verbatim}

\defdollar{msgDatabaseName}
\begin{chunk}{initvars}
(defvar |$msgDatabaseName| nil)

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The \verb|$openServerIfTrue| It appears to control whether the interpreter
will be used as an open server, probably for OpenMath use.

If an open server is not requested then this variable to NIL

See the function \fnref{openserver}.

An example of a runtime value is:
\begin{verbatim}
$openServerIfTrue = nil
\end{verbatim}

\defdollar{openServerIfTrue}
\begin{chunk}{initvars}
(defvar $openServerIfTrue nil)

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The \verb|$relative-directory-list| variable contains a hand-generated
list of directories used in the Axiom system.  The relative directory
list specifies a search path for files for the current directory
structure. It has been changed from the NAG distribution back to the
original form.

This list is used by the \refto{reroot} function to generate the absolute list
of paths held in the variable \verb|$directory-list|. Each entry will be
prefixed by \verb|$spadroot|.

An example of a runtime value is:
\begin{verbatim}
$relative-directory-list =
  ("/../../src/input/" 
   "/doc/msgs/" 
   "/../../src/algebra/" 
   "/../../src/interp/" 
   "/doc/spadhelp/")
\end{verbatim}

\defdollar{relative-directory-list}
\begin{chunk}{initvars}
(defvar $relative-directory-list
  '("/../../src/input/"
    "/doc/msgs/"
    "/../../src/algebra/"
    "/../../src/interp/"  ; for lisp  files (helps fd)
    "/doc/spadhelp/" ))

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The \verb|$relative-library-directory-list| is a hand-generated list of 
directories containing algebra. The \refto{reroot} function will prefix every
path in this list with the value of the \verb|$spadroot| variable
to construct the \verb|$library-directory-list| variable.

An example of a runtime value is:
\begin{verbatim}
$relative-library-directory-list = ("/algebra/")
\end{verbatim}

\defdollar{relative-library-directory-list}
\begin{chunk}{initvars}
(defvar $relative-library-directory-list '("/algebra/"))

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The \verb|$spadroot| variable is the internal name for the AXIOM shell
variable.  It is set in reroot to the value of the argument. The value
is expected to be a directory name.  The \refto{initroot} function
uses this variable if the AXIOM shell variable is not set.  The
\refto{make-absolute-filename} function uses this path as a prefix to all of
the relative filenames to make them absolute.

An example of a runtime value is:
\begin{verbatim}
$spadroot = "/research/test/mnt/ubuntu"
\end{verbatim}

\defdollar{spadroot}
\begin{chunk}{initvars}
(defvar $spadroot nil)

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The \verb|$SpadServer| determines whether Axiom acts as a remote server.

See the function \fnref{openserver}.

An example of a runtime value is:
\begin{verbatim}
$SpadServer = nil
\end{verbatim}

\defdollar{SpadServer}
\begin{chunk}{initvars}
(defvar $SpadServer nil "t means Axiom acts as a remote server")

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The \verb|$SpadServerName| defines the name of the spad server socket.
In unix these exist in the tmp directory as names.

See the function \fnref{openserver}.

An example of a runtime value is:
\begin{verbatim}
$SpadServerName = "/tmp/.d"
\end{verbatim}

\defdollar{SpadServerName}
\begin{chunk}{initvars}
(defvar $SpadServerName "/tmp/.d" "the name of the spad server socket")

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Starting Axiom}

This chapter details the internal processing behind an Axiom console
session where the user types ``1'' and gets a result.

\begin{verbatim}
axiom -nox
                        AXIOM Computer Algebra System 
                        Version: Axiom (August 2014)
              Timestamp: Friday September 12, 2014 at 06:24:14 
-----------------------------------------------------------------------------
   Issue )copyright to view copyright notices.
   Issue )summary for a summary of useful system commands.
   Issue )quit to leave AXIOM and return to shell.
   Visit http://axiom-developer.org for more information
-----------------------------------------------------------------------------
 
   Re-reading interp.daase
   Re-reading operation.daase
   Re-reading category.daase
   Re-reading browse.daase
(1) -> 
(1) -> 1

   (1)  1
                                                        Type: PositiveInteger
(2) -> 
\end{verbatim}

By working through this example we introduce, motivate, and explain
how the interpreter works, where and why functions are called, how
the system transitions from input strings to algebra, how the databases
are used, and more.

If you plan to maintain or modify the interpreter this information is
necessary. If you really want to know how Axiom works, this information
is useful. 

Each function call we describe has a link to the actual function so 
you can read the detailed code and see why it reacts as it does to 
the given input.

I've taken the liberty of adding comments that show the function
signature. Some of the types only exist as unnamed data structures
in the interpreter (e.g. "Server", which is really just a small
integer). They are introduced without definition simply as a 
documentation aid but may sometimes be defined a Common Lisp
deftypes for performance reasons.

{\bf A Note on Common Lisp Circular Notation}

You may not be familiar with circular notation in Common Lisp.
If a list contains a pointer back to itself or a sublist then the 
output would be an infinite stream. In order to prevent this
the circular notation is used. So for a list X,
\begin{verbatim}
 +---|---+     +---|---+     +---|---+     +---|---+
 + A |   + --> + B |   + --> + C |   + --> + D | / +
 +---|---+     +---|---+     +---|---+     +---|---+
\end{verbatim}
which is the list (A . (B . (C . (D . ())))). The printing rule
says that if a period is followed by a parenthesis then both
are suppressed. So this would print as (A B C D). 
But it could be that we execute
\begin{verbatim}
   (rplaca (last X) (cdr X))
\end{verbatim}
so the list now is
\begin{verbatim}
 +---|---+     +---|---+     +---|---+     +---|---+
 + A |   + --> + B |   + --> + C |   + --> +   | / +
 +---|---+     +---|---+     +---|---+     +---|---+
                 ^                           |
                 +---------------------------+
\end{verbatim}
and now the list X is cicular. This prints as
\begin{verbatim}
   (A . #0=(B C #0#))
\end{verbatim}
As you can see the \verb|#0=| introduces a unique label for the
cons cell pointed at by (CDR A). We stored that address in the
CAR of the last node. So the last node in the list uses the
previously defined label with the notation \verb|#0#|.

Circular notation is used extensively in Axiom since a lot of the
structures are shared or self-referential. You have to be careful
because, as a result of structure sharing, changing something in one
place can change an apparently unrelated structure by side-effect.

Axiom starts by invoking a function value of the lisp symbol
\verb|*top-level-hook*| which is normally unbound. 
The normal function invocation path is:
\begin{verbatim}
axiom -nox

lisp
 -> restart
 -> |spad|
 -> |runspad|
 -> |ncTopLevel|
 -> |ncIntLoop|
 -> |intloop|
 -> |SpadInterpretStream|
 ->   mkprompt                  -- outputs "(1) ->" to the console
 ->   |intloopReadConsole|      -- the Read-Eval-Print loop function
 ->     |serverReadLine|        -- does the actual read to the console
 -> process the input and recursively call |intloopReadConsole|
\end{verbatim}

\bfref{SpadInterpretStream} is called with a third arguments, {\bf
interactive?} set to {\bf t} so it sets up an interactive loop to read
from the console.  The other two arguments are ignored on the main
interpreter path.

\bfref{SpadInterpretStream} can also be called by the compiler,
with the {\bf interactive?} argument {\bf nil} to read from 
a file. See bookvol9.

\bfref{mkprompt} puts one of several kinds of prompts on the screen. In
the default case we include the step number.  The return value is not
used.

The \bfref{intloopReadConsole} function does tail-recursive calls to
itself and never exits. It is the primary Read-Eval-Print-Loop (REPL).

\bfref{intloopReadConsole}
reads the next line and calls one of three kinds of processors
\begin{enumerate}
\item \bfref{intnplisp} to handle )lisp input
\item \bfref{ncloopCommand} to handle )command input
\item \bfref{intloopProcessString} to handle everything else
\end{enumerate}

There are only two ways out of the REPL, either using the command
"{\bf )fin}" which drops into lisp or closing the *standard-input* stream.
If dropped into lisp, the top level loop can be restarted by calling
{\bf (restart)}.

{\bf intloopReadConsole} takes 2 arguments. The first is a String {\bf
prefix} which is usually an empty string but might contain prior lines
that ended with an underscore, the Axiom continuation character. The
second is an Integer which will be the step number printed at the
prompt.

\section{An Overview of a Simple Input}
Here we walk through details of Axiom's default behavior when handling
a simple input, the number 1. Many details are skipped in order to 
provide a simple overview of the interpreter operation. Further
details can be found at the specific functions.

Axiom is in \bfref{intloopReadConsole}, the Read-Eval-Print-Loop (REPL) function and the user types ``1''.
\begin{verbatim}
  1> (|intloopReadConsole| "" 1)
       ; serverReadLine : Stream -> String
    2> (|serverReadLine| #<synonym stream to *TERMINAL-IO*>)
         ; is-console : Stream -> Boolean
      3> (IS-CONSOLE #<synonym stream to *TERMINAL-IO*>)
      <3 (IS-CONSOLE T)
         ; sockSendInt : (Purpose,Command) -> Integer
         ; Purpose 1 is SessionManager, Command 3 is EndOfOutput
         ; A return of 0 indicates success.
         ; see the socket types purpose list in bookvol7, chunk include/com.h
      3> (|sockSendInt| 1 3)
      <3 (|sockSendInt| 0)
         ; serverSwitch : Void -> Integer
         ; see server_switch in sockio.c
         ; this multiplexes the socket connection among front ends
         ; CallInterp is the constant 4 (see the table in sockio-c)
         ; CallInterp simply returns to the interpreter
      3> (|serverSwitch|)
1
      <3 (|serverSwitch| 4)
         ; the action for CallInterp is to call read-line
         ; read-line is defined in vmlisp.lisp
      3> (|read-line| #<synonym stream to *TERMINAL-IO*>)
      <3 (|read-line| "1" NIL)
    <2 (|serverReadLine| "1")
\end{verbatim}

Axiom calls \bfref{serverReadLine}
to read the integer from the console. First it calls {\bf is-console}
(bookvol9) to check that the console stream exists. 

{\bf sockSendInt} (see sockio.lisp, sockio-c.c) sends on socket 1
({\bf SessionManager}) a 3, meaning {\bf EndOfOutput}, i.e. a newline.

{\bf serverSwitch} (see sockio-c in bookvol7) multitasks among the different 
sockets and finds the interpreter socket is available, returning
4 ({\bf CallInterp}) (see sockio-c commands sent table and bookvol8).

\bfref{serverReadLine} has a cond switch for action {\bf \$CallInterp}.
In that case it calls {\bf read-line} (see vmlisp.lisp) to read the 
input line and returns the result, in this case, the string "1".

\begin{verbatim}
    2> (|intloopPrefix?| ")fi" "1")
    <2 (|intloopPrefix?| NIL)
    2> (|intloopPrefix?| ")" "1")
    <2 (|intloopPrefix?| NIL)
    2> (CONCAT "" "1")
    <2 (CONCAT "1")
    2> (|ncloopEscaped| "1")
    <2 (|ncloopEscaped| NIL)
\end{verbatim}

\bfref{intloopReadConsole} checks for various
possible special kinds of input. Axiom returned a non-zero length
string. Before processing it we need to check for the ``{\bf )fin}''
command, which fails. We need to check for a leading ``{\bf )}'',
meaning it is some kind of command input, which fails. We might
have an existing string in the {\bf prefix} argument so we
concatentate it to the input. The {\bf prefix} might contain
text from a previous continued line. Next we check whether the input
line has a trailing underscore, meaning an Axiom line is being
continued, and if so, we recurse in order to read the next line.

\bfref{intloopPrefix?} which will return NIL if there is no
match of the prefix characters, otherwise it returns the string
without any leading blanks.

None of these special cases occur with the input ``1''.
Axiom calls \bfref{intloopProcessString}
which calls \bfref{setCurrentLine} to add the
input line to the history which is stored in {\bf \$currentLine}.

\begin{verbatim}
    2> (|intloopProcessString| "1" 1)
      3> (|setCurrentLine| "1")
      <3 (|setCurrentLine| ("1"))
\end{verbatim}

$\cdots$all the magic happens here$\cdots$

$\cdots$ and then {\bf intloopProcessString} will eventually
return the new step number 2. Then Axiom puts up a prompt
and waits for further input.

\begin{verbatim}
    <2 (|intloopProcessString| 2)
    2> (MKPROMPT)
      3> (CONCAT "(" "2" ") -> ")
      <3 (CONCAT "(2) -> ")
    <2 (MKPROMPT "(2) -> ")
(2) -> 
    2> (|serverReadLine| #<synonym stream to *TERMINAL-IO*>)
      3> (IS-CONSOLE #<synonym stream to *TERMINAL-IO*>)
      <3 (IS-CONSOLE T)
      3> (|sockSendInt| 1 3)
      <3 (|sockSendInt| 0)
      3> (|serverSwitch|)

\end{verbatim}
Now Axiom is ready for the next input.

\section{Parsing the input}
We now examine the magic portion above which has several phases.
The first phase constructs a data structure called a Delay. This
data structure is the core data structure of the ``zipper'' parser.

The ``zipper'' parser is unique to Axiom. It was invented by Bill
Burge who did research in recursive techniques, including parsing.
For insight, see his article on Stream Procesing Functions \cite{Burg74}.

\subsection{Creating a Delay -- incString}
The \bfref{intloopProcessString} has the nested function call
\begin{verbatim}
 (|intloopProcess| n t
  (|next| #'|ncloopParse|
   (|next| #'|lineoftoks| (|incString| s))))
\end{verbatim}
which according to lisp semantics is processed inside out. First we
examine the call to \bfref{incString} which is passed the input
string ``1''.

The \bfref{incString} function gets the string from Axiom's input
line, in this case ``1'' and constructs a set of nested function calls
to process the input line.

\begin{verbatim}
      3> (|incString| "1")
\end{verbatim}

The \bfref{incString} function calls \bfref{Delay} which changes the
function call into a simple list object prefixed by the symbol tag
{\bf nonnullstream}.

\begin{verbatim}
        4> (|incLude| 0 ("1") 0 ("strings") (1))
          5> (|Delay| |incLude1|  (0 ("1") 0 ("strings") (1)))
          <5 (|Delay| (|nonnullstream| |incLude1| 0 ("1") 0 ("strings") (1)))
        <4 (|incLude| (|nonnullstream| |incLude1| 0 ("1") 0 ("strings") (1)))
\end{verbatim}
That result is passed to \bfref{incRenumber}, which calls \bfref{incIgen}
which returns a \bfref{Delay}. It then calls \bfref{incZip} to ``zips''
together the function \bfref{incRenumberLine} and the two delays into
a single delay. This gets put into a delay with \bfref{incZip1} as the
function.
\begin{verbatim}
        4> (|incRenumber| 
               (|nonnullstream| |incLude1| 0 ("1") 0 ("strings") (1)))
          5> (|incIgen| 0)
            6> (|Delay| |incIgen1| (0))
            <6 (|Delay| (|nonnullstream| |incIgen1| 0))
          <5 (|incIgen| (|nonnullstream| |incIgen1| 0))

          5> (|incZip| |incRenumberLine| 
                 (|nonnullstream| |incLude1| 0 ("1") 0 ("strings") (1))
                 (|nonnullstream| |incIgen1| 0))
            6> (|Delay| |incZip1| |incRenumberLine|)
            <6 (|Delay| 
                 (|nonnullstream| |incZip1| |incRenumberLine| 
                   (|nonnullstream| |incLude1| 0 ("1") 0 ("strings") (1))
                   (|nonnullstream| |incIgen1| 0)))
          <5 (|incZip| 
               (|nonnullstream| |incZip1| |incRenumberLine| 
                 (|nonnullstream| |incLude1| 0 ("1") 0 ("strings") (1))
                 (|nonnullstream| |incIgen1| 0)))

        <4 (|incRenumber| 
              (|nonnullstream| |incZip1| |incRenumberLine| 
                (|nonnullstream| |incLude1| 0 ("1") 0 ("strings") (1))
                (|nonnullstream| |incIgen1| 0)))

      <3 (|incString| 
           (|nonnullstream| |incZip1| |incRenumberLine| 
             (|nonnullstream| |incLude1| 0 ("1") 0 ("strings") (1))
             (|nonnullstream| |incIgen1| 0)))
\end{verbatim}

We are building a stream of functions and arguments stored in a delay
structure which will eventually be evaluated. We continue this process
with the call to \bfref{next} which builds a delay with the function
\bfref{next1} and the current delay.

\subsection{Creating a Delay -- next}
\begin{verbatim}
      3> (|next| |lineoftoks| 
           (|nonnullstream| |incZip1| |incRenumberLine| 
             (|nonnullstream| |incLude1| 0 ("1") 0 ("strings") (1))
             (|nonnullstream| |incIgen1| 0)))
        4> (|Delay| |next1| 
             (|lineoftoks| 
               (|nonnullstream| |incZip1| |incRenumberLine| 
                 (|nonnullstream| |incLude1| 0 ("1") 0 ("strings") (1))
                 (|nonnullstream| |incIgen1| 0))))
        <4 (|Delay| (|nonnullstream| |next1| |lineoftoks| 
             (|nonnullstream| |incZip1| |incRenumberLine| 
               (|nonnullstream| |incLude1| 0 ("1") 0 ("strings") (1))
               (|nonnullstream| |incIgen1| 0))))
      <3 (|next| 
           (|nonnullstream| |next1| |lineoftoks| 
             (|nonnullstream| |incZip1| |incRenumberLine| 
               (|nonnullstream| |incLude1| 0 ("1") 0 ("strings") (1))
               (|nonnullstream| |incIgen1| 0))))
\end{verbatim}

\subsection{Creating a Delay -- ncloopParse}
`We continue building a larger delay, this time with a call to
\bfref{next} with the function argument \bfref{ncloopParse} and the
existing delay.

\begin{verbatim}
      3> (|next| |ncloopParse| 
           (|nonnullstream| |next1| |lineoftoks| 
             (|nonnullstream| |incZip1| |incRenumberLine| 
               (|nonnullstream| |incLude1| 0 ("1") 0 ("strings") (1))
               (|nonnullstream| |incIgen1| 0))))
        4> (|Delay| #0=|next1| 
             (|ncloopParse| 
               (|nonnullstream| #0# |lineoftoks| 
                 (|nonnullstream| |incZip1| |incRenumberLine| 
                   (|nonnullstream| |incLude1| 0 ("1") 0 ("strings") (1))
                   (|nonnullstream| |incIgen1| 0)))))
        <4 (|Delay| 
             (|nonnullstream| #0=|next1| |ncloopParse| 
               (|nonnullstream| #0# |lineoftoks| 
                 (|nonnullstream| |incZip1| |incRenumberLine| 
                   (|nonnullstream| |incLude1| 0 ("1") 0 ("strings") (1))
                   (|nonnullstream| |incIgen1| 0)))))
      <3 (|next| 
           (|nonnullstream| #0=|next1| |ncloopParse| 
             (|nonnullstream| #0# |lineoftoks| 
               (|nonnullstream| |incZip1| |incRenumberLine| 
                 (|nonnullstream| |incLude1| 0 ("1") 0 ("strings") (1))
                 (|nonnullstream| |incIgen1| 0)))))
\end{verbatim}

Finally we call \bfref{intloopProcess} with the step number {\bf stepno},
whether we are talking to the console {\bf interactive} and the delay
we just constructed {\bf delay}

\subsection{Evaluating a Delay -- intloopProcess}

At this point we have created a large delay. Now we begin to evaluate it.

\begin{verbatim}
      3> (|intloopProcess| 1 T 
          (|nonnullstream| #0=|next1| |ncloopParse| 
            (|nonnullstream| #0# |lineoftoks| 
              (|nonnullstream| |incZip1| |incRenumberLine| 
               (|nonnullstream| |incLude1| 0 ("1") 0 ("strings") (1))
               (|nonnullstream| |incIgen1| 0)))))
\end{verbatim}

\bfref{intloopProcess} calls \bfref{StreamNull} which walks the 
delay applying the second value, which is a function, to the rest
of the delay. Thus, all of the functions we packaged into the
delay will be evaluated.

The result of each function call, e.g the result of calling \bfref{next1}
will be a pair, which we call a ParsePair \index{ParsePair}. 
The car of the ParsePair is rplaca'd into the delay and
the cdr of the ParsePair is rplacd'd into the delay. 
So the delay is gradually reduced by each function call.

\begin{verbatim}
        4> (|StreamNull| 
             (|nonnullstream| #0=|next1| |ncloopParse| 
               (|nonnullstream| #0# |lineoftoks| 
                 (|nonnullstream| |incZip1| |incRenumberLine| 
                   (|nonnullstream| |incLude1| 0 ("1") 0 ("strings") (1)) 
                   (|nonnullstream| |incIgen1| 0)))))
\end{verbatim}

Here we see the \bfref{next1} function being called from the delay.
It immediately calls \bfref{StreamNull} to process the rest of the delay.

\begin{verbatim}
          5> (|next1| |ncloopParse| 
               (|nonnullstream| |next1| |lineoftoks| 
                 (|nonnullstream| |incZip1| |incRenumberLine| 
                   (|nonnullstream| |incLude1| 0 ("1") 0 ("strings") (1)) 
                   (|nonnullstream| |incIgen1| 0))))
            6> (|StreamNull| 
                 (|nonnullstream| |next1| |lineoftoks| 
                   (|nonnullstream| |incZip1| |incRenumberLine| 
                     (|nonnullstream| |incLude1| 0 ("1") 0 ("strings") (1)) 
                     (|nonnullstream| |incIgen1| 0))))
\end{verbatim}
 
\bfref{StreamNull}, now working on the inner portion of the delay,
finds the function \bfref{next1} and calls it, which results in an
immediate inner call to \bfref{StreamNull}.

\begin{verbatim}
              7> (|next1| |lineoftoks| 
                   (|nonnullstream| |incZip1| |incRenumberLine| 
                     (|nonnullstream| |incLude1| 0 ("1") 0 ("strings") (1)) 
                     (|nonnullstream| |incIgen1| 0)))
                8> (|StreamNull| 
                     (|nonnullstream| |incZip1| |incRenumberLine| 
                       (|nonnullstream| |incLude1| 0 ("1") 0 ("strings") (1)) 
                       (|nonnullstream| |incIgen1| 0)))
\end{verbatim}

Descending even further, the \bfref{StreamNull} finds \bfref{incZip1}, 
which finds the function \bfref{incRenumberLine} and two delays.
\begin{verbatim}
                  9> (|incZip1| 
                       |incRenumberLine| 
                       (|nonnullstream| |incLude1| 0 ("1") 0 ("strings") (1))
                       (|nonnullstream| |incIgen1| 0))
\end{verbatim}
\bfref{incZip1} invokes \bfref{StreamNull} on the first delay, which
invokes \bfref{incLude1} on the rest of the delay.
\begin{verbatim}
                    10> (|StreamNull| 
                          (|nonnullstream| |incLude1| 0 ("1") 0 
                                                        ("strings") (1)))
\end{verbatim}
\bfref{incLude1} unpacks the argument list and invokes \bfref{StreamNull}
on the second argument \verb|("1")| which is not the expected symbol
{\bf nonnullstream} so \bfref{StreamNull} immediately returns NIL.
\begin{verbatim}
                    11> (|incLude1| 0 ("1") 0 ("strings") (1))
                    12> (|StreamNull| ("1"))
                    <12 (|StreamNull| NIL)
\end{verbatim}
Next, \bfref{incLude1} calls \bfref{incClassify} to which calls
\bfref{incCommand?} which checks for a leading ``)''. Since there
isn't one \bfref{incClassify} immediately returns a list of NIL, 0,
and the empty string.
\begin{verbatim}
                    12> (|incClassify| "1")
                    13> (|incCommand?| "1")
                    <13 (|incCommand?| NIL)
                    <12 (|incClassify| (NIL 0 ""))

                    12> (|Skipping?| 1)
                    13> (|KeepPart?| 1)
                    <13 (|KeepPart?| T)
                    <12 (|Skipping?| NIL)

                    12> (|xlOK| 0 "1" 1 "strings")
                    13> (|xlOK1| 0 "1" "1" 1 "strings")
                    14> (INCLINE1 0 "1" "1" -1 1 "strings")
                    15> (|lnCreate| 0 "1" -1 1 "strings")
                    <15 (|lnCreate| (0 "1" -1 1 "strings"))
                    <14 (INCLINE1 (((0 "1" -1 1 "strings") . 1) . "1"))
                    <13 (|xlOK1| ((((0 "1" -1 1 "strings") . 1) . "1") 
                                  (NIL |none|)))
                    <12 (|xlOK| ((((0 "1" -1 1 "strings") . 1) . "1") 
                                  (NIL |none|)))

                    12> (|incLude| 0 NIL 1 ("strings") (1))
                    13> (|Delay| |incLude1| (0 NIL 1 ("strings") (1)))
                    <13 (|Delay| 
                          (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1)))
                    <12 (|incLude| 
                          (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1)))

                    <11 (|incLude1| 
                          (((((0 "1" -1 1 "strings") . 1) . "1") (NIL |none|))
                          |nonnullstream| |incLude1| 0 NIL 1 ("strings") (1)))
                    <10 (|StreamNull| NIL)
\end{verbatim}

\begin{verbatim}
                    10> (|StreamNull| (|nonnullstream| |incIgen1| 0))
                    11> (|incIgen1| 0)
                    12> (|incIgen| 1)
                    13> (|Delay| |incIgen1| (1))
                    <13 (|Delay| (|nonnullstream| |incIgen1| 1))
                    <12 (|incIgen| (|nonnullstream| |incIgen1| 1))
                    <11 (|incIgen1| (1 |nonnullstream| |incIgen1| 1))
                    <10 (|StreamNull| NIL)
                    10> (|incRenumberLine| 
                         ((((0 "1" -1 1 "strings") . 1) . "1") (NIL |none|)) 1)
                    11> (|incRenumberItem| 
                         (((0 "1" -1 1 "strings") . 1) . "1") 1)
                    12> (|lnSetGlobalNum| (0 "1" -1 1 "strings") 1)
                    <12 (|lnSetGlobalNum| 1)
                    <11 (|incRenumberItem| (((0 "1" 1 1 "strings") . 1) . "1"))
                    11> (|incHandleMessage| 
                          ((((0 "1" 1 1 "strings") . 1) . "1") (NIL |none|)))
                    <11 (|incHandleMessage| 0)
                    <10 (|incRenumberLine| 
                          (((0 "1" 1 1 "strings") . 1) . "1"))
\end{verbatim}

\begin{verbatim}
                    10> (|incZip| |incRenumberLine| 
                          (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1))
                          (|nonnullstream| |incIgen1| 1))
                    11> (|Delay| |incZip1| 
                          (|incRenumberLine| 
                           (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1))
                           (|nonnullstream| |incIgen1| 1)))
                    <11 (|Delay| 
                          (|nonnullstream| |incZip1| |incRenumberLine| 
                           (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1))
                           (|nonnullstream| |incIgen1| 1)))
                    <10 (|incZip| 
                         (|nonnullstream| |incZip1| |incRenumberLine| 
                          (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1))
                          (|nonnullstream| |incIgen1| 1)))
\end{verbatim}

\begin{verbatim}
                  <9 (|incZip1| 
                      ((((0 "1" 1 1 "strings") . 1) . "1") 
                        |nonnullstream| |incZip1| |incRenumberLine| 
                        (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1)) 
                        (|nonnullstream| |incIgen1| 1)))
                <8 (|StreamNull| NIL)
\end{verbatim}

\begin{verbatim}
                8> (|lineoftoks| 
                    ((((0 "1" 1 1 "strings") . 1) . "1") 
                      |nonnullstream| |incZip1| |incRenumberLine| 
                      (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1)) 
                      (|nonnullstream| |incIgen1| 1)))
                  9> (|nextline| 
                      ((((0 "1" 1 1 "strings") . 1) . "1") 
                        |nonnullstream| |incZip1| |incRenumberLine| 
                        (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1)) 
                        (|nonnullstream| |incIgen1| 1)))
                    10> (|npNull| 
                         ((((0 "1" 1 1 "strings") . 1) . "1") 
                          |nonnullstream| |incZip1| |incRenumberLine| 
                          (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1)) 
                          (|nonnullstream| |incIgen1| 1)))
                    11> (|StreamNull| 
                         ((((0 "1" 1 1 "strings") . 1) . "1") 
                          |nonnullstream| |incZip1| |incRenumberLine| 
                          (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1)) 
                          (|nonnullstream| |incIgen1| 1)))
                    <11 (|StreamNull| NIL)
                    <10 (|npNull| NIL)
                    10> (STRPOSL " " "1" 0 T)
                    <10 (STRPOSL 0)
                  <9 (|nextline| T)
                  9> (|scanIgnoreLine| "1" 0)
                  <9 (|scanIgnoreLine| 0)
                  9> (|incPrefix?| "command" 1 "1")
                  <9 (|incPrefix?| NIL)
                  9> (|scanToken|)
                    10> (|startsComment?|)
                    <10 (|startsComment?| NIL)
                    10> (|startsNegComment?|)
                    <10 (|startsNegComment?| NIL)
                    10> (|punctuation?| 49)
                    <10 (|punctuation?| NIL)
                    10> (|digit?| #\1)
                    11> (DIGITP #\1)
                    <11 (DIGITP 1)
                    <10 (|digit?| 1)
                    10> (|scanNumber|)
                    11> (|spleI| |digit?|)
                    12> (|spleI1| |digit?| NIL)
                    13> (|digit?| #\1)
                    14> (DIGITP #\1)
                    <14 (DIGITP 1)
                    <13 (|digit?| 1)
                    <12 (|spleI1| "1")
                    <11 (|spleI| "1")
                    11> (|lfinteger| "1")
                    <11 (|lfinteger| (|integer| "1"))
                    <10 (|scanNumber| (|integer| "1"))
                    10> (|lnExtraBlanks| (0 "1" 1 1 "strings"))
                    <10 (|lnExtraBlanks| 0)
                    10> (|constoken| 
                          "1" (0 "1" 1 1 "strings") (|integer| "1") 0)
                    11> (|ncPutQ| 
                         (|integer| . "1") |posn| ((0 "1" 1 1 "strings") . 0))
                    12> (|ncAlist| (|integer| . "1"))
                    <12 (|ncAlist| NIL)
                    12> (|ncAlist| (|integer| . "1"))
                    <12 (|ncAlist| NIL)
                    12> (|ncTag| (|integer| . "1"))
                    <12 (|ncTag| |integer|)
                    <11 (|ncPutQ| ((0 "1" 1 1 "strings") . 0))
                    <10 (|constoken| 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) .
                             "1"))
                    10> (|dqUnit| 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) .
                             "1"))
                    <10 (|dqUnit|
                         (#0=(((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) .
                             "1")) . #0#))
                  <9 (|scanToken|
                       (#0=(((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) .
                             "1")) . #0#))
                  9> (|dqAppend| NIL
                      (#0=(((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) .
                             "1")) . #0#))
                  <9 (|dqAppend|
                      (#0=(((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) .
                             "1")) . #0#))
                <8 (|lineoftoks|
                    ((((#0=(
                     ((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0)) . "1"))
                         . #0#)
                      (((#1# . 1) . "1") . 
                       #2=(|nonnullstream| |incZip1| |incRenumberLine| 
                           (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1))
                           (|nonnullstream| |incIgen1| 1)))))
                     . #2#))
\end{verbatim}

\begin{verbatim}
                8> (|next| |lineoftoks| 
                    (|nonnullstream| |incZip1| |incRenumberLine| 
                     (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1)) 
                     (|nonnullstream| |incIgen1| 1)))
                  9> (|Delay| |next1| 
                      (|lineoftoks| 
                       (|nonnullstream| |incZip1| |incRenumberLine| 
                        (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1)) 
                        (|nonnullstream| |incIgen1| 1))))
                  <9 (|Delay|
                      (|nonnullstream| |next1| |lineoftoks| 
                       (|nonnullstream| |incZip1| |incRenumberLine| 
                        (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1))
                        (|nonnullstream| |incIgen1| 1))))
                <8 (|next| 
                    (|nonnullstream| |next1| |lineoftoks| 
                     (|nonnullstream| |incZip1| |incRenumberLine| 
                      (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1))
                      (|nonnullstream| |incIgen1| 1))))
\end{verbatim}

\begin{verbatim}
                8> (|incAppend| 
                    (((#0=(((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0)) . "1")) . #0#)
                     (((#1# . 1) . "1") .
                       #2=(|nonnullstream| |incZip1| |incRenumberLine| 
                       (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1))
                       (|nonnullstream| |incIgen1| 1)))))
                    (|nonnullstream| |next1| |lineoftoks| #2#))
                  9> (|Delay| |incAppend1| 
                      ((((#1=((
                        (|integer| (|posn| #2=(0 "1" 1 1 "strings") . 0)) . 
                           "1")) . #1#)
                         (((#2# . 1) . "1") . 
                           #3=(|nonnullstream| |incZip1| |incRenumberLine| 
                           (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1))
                           (|nonnullstream| |incIgen1| 1)))))
                       (|nonnullstream| |next1| |lineoftoks| #3#)))
                  <9 (|Delay| 
                       (|nonnullstream| |incAppend1| 
                        (((#1=
                          (((|integer| (|posn| #2=(0 "1" 1 1 "strings") . 0))
                            . "1"))
                             . #1#)
                         (((#2# . 1) . "1") . 
                          #3=(|nonnullstream| |incZip1| |incRenumberLine| 
                           (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1))
                           (|nonnullstream| |incIgen1| 1)))))
                        (|nonnullstream| |next1| |lineoftoks| #3#)))
                <8 (|incAppend| 
                    (|nonnullstream| |incAppend1| 
                     (((#1=(((|integer| (|posn| #2=(0 "1" 1 1 "strings") . 0)) . "1")) . #1#)
                      (((#2# . 1) . "1") . 
                       #3=(|nonnullstream| |incZip1| |incRenumberLine| 
                           (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1))
                           (|nonnullstream| |incIgen1| 1)))))
                     (|nonnullstream| |next1| |lineoftoks| #3#)))
\end{verbatim}

\begin{verbatim}
              <7 (|next1| 
                  (|nonnullstream| |incAppend1| 
                   (((#1=(((|integer| (|posn| #2=(0 "1" 1 1 "strings") . 0))
                     . "1"))
                      . #1#) (((#2# . 1) . "1") . 
                       #3=(|nonnullstream| |incZip1| |incRenumberLine| 
                          (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1))
                          (|nonnullstream| |incIgen1| 1)))))
                   (|nonnullstream| |next1| |lineoftoks| #3#)))
              7> (|incAppend1| 
                  (((#0=(((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0)) .
                    "1"))
                      . #0#) (((#1# . 1) . "1") . 
                   #2=(|nonnullstream| |incZip1| |incRenumberLine| 
                       (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1))
                       (|nonnullstream| |incIgen1| 1)))))
                   (|nonnullstream| |next1| |lineoftoks| #2#))
\end{verbatim}

\begin{verbatim}
                8> (|StreamNull| 
                    (((#0=(((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                      . "1"))
                       . #0#) (((#1# . 1) . "1") 
                        |nonnullstream| |incZip1| |incRenumberLine| 
                        (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1))
                        (|nonnullstream| |incIgen1| 1)))))
                <8 (|StreamNull| NIL)
\end{verbatim}

\begin{verbatim}
                8> (|incAppend| NIL 
                    (|nonnullstream| |next1| |lineoftoks| 
                     (|nonnullstream| |incZip1| |incRenumberLine| 
                      (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1))
                      (|nonnullstream| |incIgen1| 1))))
                  9> (|Delay| |incAppend1| 
                      (NIL 
                       (|nonnullstream| |next1| |lineoftoks| 
                        (|nonnullstream| |incZip1| |incRenumberLine| 
                         (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1))
                         (|nonnullstream| |incIgen1| 1)))))
                  <9 (|Delay| 
                      (|nonnullstream| |incAppend1| NIL 
                       (|nonnullstream| |next1| |lineoftoks| 
                        (|nonnullstream| |incZip1| |incRenumberLine| 
                         (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1))
                         (|nonnullstream| |incIgen1| 1)))))
                <8 (|incAppend| (|nonnullstream| |incAppend1| NIL 
                    (|nonnullstream| |next1| |lineoftoks| 
                     (|nonnullstream| |incZip1| |incRenumberLine| 
                      (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1))
                      (|nonnullstream| |incIgen1| 1)))))
\end{verbatim}

\begin{verbatim}
              <7 (|incAppend1| 
                  (((#0=(((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                    . "1")) . #0#) (((#1# . 1) . "1")
                     . #2=(|nonnullstream| |incZip1| |incRenumberLine| 
                      (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1))
                      (|nonnullstream| |incIgen1| 1))))
                   |nonnullstream| |incAppend1| NIL 
                   (|nonnullstream| |next1| |lineoftoks| #2#)))
            <6 (|StreamNull| NIL)
\end{verbatim}

\begin{verbatim}
            6> (|ncloopParse| 
                (((#0=(((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                  . "1")) . #0#) (((#1# . 1) . "1")
                   . #2=(|nonnullstream| |incZip1| |incRenumberLine|
                   (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1))
                   (|nonnullstream| |incIgen1| 1))))
                 |nonnullstream| |incAppend1| NIL 
                 (|nonnullstream| |next1| |lineoftoks| #2#)))
              7> (|ncloopDQlines|
                  (#0=(((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                   . "1")) . #0#) (((#1# . 1) . "1")
                   |nonnullstream| |incZip1| |incRenumberLine|
                   (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1))
                   (|nonnullstream| |incIgen1| 1)))
                8> (|StreamNull|
                    ((((0 "1" 1 1 "strings") . 1) . "1")
                     |nonnullstream| |incZip1| |incRenumberLine|
                     (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1))
                     (|nonnullstream| |incIgen1| 1)))
                <8 (|StreamNull| NIL)
                8> (|tokPosn|
                    ((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) . "1"))
                  9> (|ncAlist|
                      ((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) . "1"))
                  <9 (|ncAlist| ((|posn| (0 "1" 1 1 "strings") . 0)))
                <8 (|tokPosn| ((0 "1" 1 1 "strings") . 0))
                8> (|poGlobalLinePosn| ((0 "1" 1 1 "strings") . 0))
                  9> (|poGetLineObject| ((0 "1" 1 1 "strings") . 0))
                  <9 (|poGetLineObject| (0 "1" 1 1 "strings"))
                  9> (|lnGlobalNum| (0 "1" 1 1 "strings"))
                  <9 (|lnGlobalNum| 1)
                <8 (|poGlobalLinePosn| 1)
                8> (|poGlobalLinePosn| ((0 "1" 1 1 "strings") . 1))
                  9> (|poGetLineObject| ((0 "1" 1 1 "strings") . 1))
                  <9 (|poGetLineObject| (0 "1" 1 1 "strings"))
                  9> (|lnGlobalNum| (0 "1" 1 1 "strings"))
                  <9 (|lnGlobalNum| 1)
                <8 (|poGlobalLinePosn| 1)
                8> (|streamChop| 1 
                    ((((0 "1" 1 1 "strings") . 1) . "1")
                     |nonnullstream| |incZip1| |incRenumberLine|
                     (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1))
                     (|nonnullstream| |incIgen1| 1)))
                  9> (|StreamNull|
                      ((((0 "1" 1 1 "strings") . 1) . "1") 
                       |nonnullstream| |incZip1| |incRenumberLine|
                       (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1))
                       (|nonnullstream| |incIgen1| 1)))
                  <9 (|StreamNull| NIL)
                  9> (|streamChop| 0 
                      (|nonnullstream| |incZip1| |incRenumberLine| 
                       (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1))
                       (|nonnullstream| |incIgen1| 1)))
                    10> (|StreamNull|
                         (|nonnullstream| |incZip1| |incRenumberLine|
                          (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1))
                          (|nonnullstream| |incIgen1| 1)))
                    11> (|incZip1| |incRenumberLine|
                         (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1))
                         (|nonnullstream| |incIgen1| 1))
                    12> (|StreamNull|
                         (|nonnullstream| |incLude1| 0 NIL 1 ("strings") (1)))
                    13> (|incLude1| 0 NIL 1 ("strings") (1))
                    14> (|StreamNull| NIL)
                    <14 (|StreamNull| T)
                    14> (|Top?| 1)
                    <14 (|Top?| T)
                    <13 (|incLude1| (|nullstream|))
                    <12 (|StreamNull| T)
                    <11 (|incZip1| (|nullstream|))
                    <10 (|StreamNull| T)
                  <9 (|streamChop| (NIL NIL))
                  9> (|ncloopPrefix?| ")command" "1")
                  <9 (|ncloopPrefix?| NIL)
                <8 (|streamChop| (((((0 "1" 1 1 "strings") . 1) . "1")) NIL))
              <7 (|ncloopDQlines| (((((0 "1" 1 1 "strings") . 1) . "1")) NIL))
              7> (|dqToList|
                   (#0=((
                    (|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                    . "1")) . #0#))
              <7 (|dqToList|
                  (((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) . "1")))
              7> (|npParse|
                  (((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) . "1")))
                8> (|npFirstTok|)
                  9> (|tokPart|
                      ((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) . "1"))
                  <9 (|tokPart| "1")
                <8 (|npFirstTok| "1")
                8> (|npItem|)
                  9> (|npQualDef|)
                    10> (|npComma|)
                    11> (|npTuple| |npQualifiedDefinition|)
                    12> (|npListofFun| 
                         |npQualifiedDefinition| 
                         |npCommaBackSet| 
                         |pfTupleListOf|)
                    13> (|npQualifiedDefinition|)
                    14> (|npQualified| |npDefinitionOrStatement|)
                    15> (|npDefinitionOrStatement|)
                    16> (|npBackTrack| |npGives| DEF |npDef|)
                    17> (|npState|)
                    <17 (|npState| 
                         ((((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                         . "1"))))
                    17> (|npGives|)
                    18> (|npBackTrack| |npExit| GIVES |npLambda|)
                    19> (|npState|)
                    <19 (|npState|
                         ((((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                         . "1"))))
                    19> (|npExit|)
                    20> (|npBackTrack| |npAssign| EXIT |npPileExit|)
                    21> (|npState|)
                    <21 (|npState|
                         ((((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                         . "1"))))
                    21> (|npAssign|)
                    22> (|npBackTrack| |npMDEF| BECOMES |npAssignment|)
                    23> (|npState|)
                    <23 (|npState|
                         ((((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                         . "1"))))
                    23> (|npMDEF|)
                    24> (|npBackTrack| |npStatement| MDEF |npMDEFinition|)
                    25> (|npState|)
                    <25 (|npState|
                         ((((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                         . "1"))))
                    25> (|npStatement|)
                    26> (|npExpress|)
                    27> (|npExpress1|)
                    28> (|npConditionalStatement|)
                    29> (|npConditional| |npQualifiedDefinition|)
                    30> (|npEqKey| IF)
                    <30 (|npEqKey| NIL)
                    <29 (|npConditional| NIL)
                    <28 (|npConditionalStatement| NIL)
                    28> (|npADD|)
                    29> (|npType|)
                    30> (|npMatch|)
                    31> (|npLeftAssoc| (IS ISNT) |npSuch|)
                    32> (|npSuch|)
                    33> (|npLeftAssoc| (BAR) |npLogical|)
                    34> (|npLogical|)
                    35> (|npLeftAssoc| (OR) |npDisjand|)
                    36> (|npDisjand|)
                    37> (|npLeftAssoc| (AND) |npDiscrim|)
                    38> (|npDiscrim|)
                    39> (|npLeftAssoc| (CASE HAS) |npQuiver|)
                    40> (|npQuiver|)
                    41> (|npRightAssoc| (ARROW LARROW) |npRelation|)
                    42> (|npState|)
                    <42 (|npState|
                         ((((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                         . "1"))))
                    42> (|npRelation|)
                    43> (|npLeftAssoc|
                         (EQUAL NOTEQUAL LT LE GT GE OANGLE CANGLE)
                         |npSynthetic|)
                    44> (|npSynthetic|)
                    45> (|npBy|)
                    46> (|npLeftAssoc| (BY) |npInterval|)
                    47> (|npInterval|)
                    48> (|npArith|)
                    49> (|npLeftAssoc| (MOD) |npSum|)
                    50> (|npSum|)
                    51> (|npLeftAssoc| (PLUS MINUS) |npTerm|)
                    52> (|npTerm|)
                    53> (|npInfGeneric| (MINUS PLUS))
                    54> (|npDDInfKey| (MINUS PLUS))
                    55> (|npInfKey| (MINUS PLUS))
                    <55 (|npInfKey| NIL)
                    55> (|npState|)
                    <55 (|npState|
                         ((((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                          . "1"))))
                    55> (|npEqKey| |'|)
                    <55 (|npEqKey| NIL)
                    55> (|npRestore|
                         ((((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                          . "1"))))
                    56> (|npFirstTok|)
                    57> (|tokPart|
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                          . "1"))
                    <57 (|tokPart| "1")
                    <56 (|npFirstTok| "1")
                    <55 (|npRestore| T)
                    55> (|npEqKey| BACKQUOTE)
                    <55 (|npEqKey| NIL)
                    55> (|npRestore|
                         ((((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                          . "1"))))
                    56> (|npFirstTok|)
                    57> (|tokPart|
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                          . "1"))
                    <57 (|tokPart| "1")
                    <56 (|npFirstTok| "1")
                    <55 (|npRestore| T)
                    <54 (|npDDInfKey| NIL)
                    <53 (|npInfGeneric| NIL)
                    53> (|npRemainder|)
                    54> (|npLeftAssoc| (REM QUO) |npProduct|)
                    55> (|npProduct|)
                    56> (|npLeftAssoc|
                          (TIMES SLASH BACKSLASH SLASHSLASH BACKSLASHBACKSLASH
                            SLASHBACKSLASH BACKSLASHSLASH)
                          |npPower|)
                    57> (|npPower|)
                    58> (|npRightAssoc| (POWER CARAT) |npColon|)
                    59> (|npState|)
                    <59 (|npState|
                         ((((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1"))))
                    59> (|npColon|)
                    60> (|npTypified|)
                    61> (|npApplication|)
                    62> (|npDotted| |npPrimary|)
                    63> (|npPrimary|)
                    64> (|npPrimary1|)
                    65> (|npEncAp| |npAtom1|)
                    66> (|npAtom1|)
                    67> (|npPDefinition|)
                    68> (|npParenthesized| |npDefinitionlist|)
                    69> (|npParenthesize| |(| |)| |npDefinitionlist|)
                    70> (|npEqKey| |(|)
                    <70 (|npEqKey| NIL)
                    <69 (|npParenthesize| NIL)
                    69> (|npParenthesize| |(\|| |\|)| |npDefinitionlist|)
                    70> (|npEqKey| |(\||)
                    <70 (|npEqKey| NIL)
                    <69 (|npParenthesize| NIL)
                    <68 (|npParenthesized| NIL)
                    <67 (|npPDefinition| NIL)
                    67> (|npName|)
                    68> (|npId|)
                    <68 (|npId| NIL)
                    68> (|npSymbolVariable|)
                    69> (|npState|)
                    <69 (|npState|
                         ((((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1"))))
                    69> (|npEqKey| BACKQUOTE)
                    <69 (|npEqKey| NIL)
                    69> (|npRestore|
                         ((((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1"))))
                    70> (|npFirstTok|)
                    71> (|tokPart|
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                          . "1"))
                    <71 (|tokPart| "1")
                    <70 (|npFirstTok| "1")
                    <69 (|npRestore| T)
                    <68 (|npSymbolVariable| NIL)
                    <67 (|npName| NIL)
                    67> (|npConstTok|)
                    68> (|tokType|
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                          . "1"))
                    69> (|ncTag|
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                          . "1"))
                    <69 (|ncTag| |integer|)
                    <68 (|tokType| |integer|)
                    68> (|npPush|
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                          . "1"))
                    <68 (|npPush|
                         (((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                          . "1")))
                    68> (|npNext|)
                    69> (|npFirstTok|)
                    70> (|tokPosn|
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                          . "1"))
                    71> (|ncAlist|
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1"))
                    <71 (|ncAlist| ((|posn| (0 "1" 1 1 "strings") . 0)))
                    <70 (|tokPosn| ((0 "1" 1 1 "strings") . 0))
                    70> (|tokConstruct| ERROR NOMORE 
                         ((0 "1" 1 1 "strings") . 0))
                    71> (|pfNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    72> (|poNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    <72 (|poNoPosition?| NIL)
                    <71 (|pfNoPosition?| NIL)
                    71> (|ncPutQ| (ERROR . NOMORE) |posn| 
                         ((0 "1" 1 1 "strings") . 0))
                    72> (|ncAlist| (ERROR . NOMORE))
                    <72 (|ncAlist| NIL)
                    72> (|ncAlist| (ERROR . NOMORE))
                    <72 (|ncAlist| NIL)
                    72> (|ncTag| (ERROR . NOMORE))
                    <72 (|ncTag| ERROR)
                    <71 (|ncPutQ| ((0 "1" 1 1 "strings") . 0))
                    <70 (|tokConstruct| 
                          ((ERROR (|posn| (0 "1" 1 1 "strings") . 0))
                            . NOMORE))
                    70> (|tokPart|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <70 (|tokPart| NOMORE)
                    <69 (|npFirstTok| NOMORE)
                    <68 (|npNext| NOMORE)
                    <67 (|npConstTok| NOMORE)
                    67> (|npFromdom|)
                    68> (|npEqKey| $)
                    <68 (|npEqKey| NIL)
                    <67 (|npFromdom| T)
                    <66 (|npAtom1| T)
                    66> (|npAnyNo| |npEncl|)
                    67> (|npEncl|)
                    68> (|npBDefinition|)
                    69> (|npPDefinition|)
                    70> (|npParenthesized| |npDefinitionlist|)
                    71> (|npParenthesize| |(| |)| |npDefinitionlist|)
                    72> (|npEqKey| |(|)
                    <72 (|npEqKey| NIL)
                    <71 (|npParenthesize| NIL)
                    71> (|npParenthesize| |(\|| |\|)| |npDefinitionlist|)
                    72> (|npEqKey| |(\||)
                    <72 (|npEqKey| NIL)
                    <71 (|npParenthesize| NIL)
                    <70 (|npParenthesized| NIL)
                    <69 (|npPDefinition| NIL)
                    69> (|npBracketed| |npDefinitionlist|)
                    70> (|npParened| |npDefinitionlist|)
                    71> (|npEnclosed| |(| |)| |pfParen| |npDefinitionlist|)
                    72> (|npEqKey| |(|)
                    <72 (|npEqKey| NIL)
                    <71 (|npEnclosed| NIL)
                    71> (|npEnclosed| |(\|| |\|)| |pfParen| |npDefinitionlist|)
                    72> (|npEqKey| |(\||)
                    <72 (|npEqKey| NIL)
                    <71 (|npEnclosed| NIL)
                    <70 (|npParened| NIL)
                    70> (|npBracked| |npDefinitionlist|)
                    71> (|npEnclosed| [ ] |pfBracket| |npDefinitionlist|)
                    72> (|npEqKey| [)
                    <72 (|npEqKey| NIL)
                    <71 (|npEnclosed| NIL)
                    71> (|npEnclosed| |[\|| |\|]| 
                                      |pfBracketBar| |npDefinitionlist|)
                    72> (|npEqKey| |[\||)
                    <72 (|npEqKey| NIL)
                    <71 (|npEnclosed| NIL)
                    <70 (|npBracked| NIL)
                    70> (|npBraced| |npDefinitionlist|)
                    71> (|npEnclosed| { } |pfBrace| |npDefinitionlist|)
                    72> (|npEqKey| {)
                    <72 (|npEqKey| NIL)
                    <71 (|npEnclosed| NIL)
                    71> (|npEnclosed| |{\|| |\|}| 
                                      |pfBraceBar| |npDefinitionlist|)
                    72> (|npEqKey| |{\||)
                    <72 (|npEqKey| NIL)
                    <71 (|npEnclosed| NIL)
                    <70 (|npBraced| NIL)
                    70> (|npAngleBared| |npDefinitionlist|)
                    71> (|npEnclosed| |<\|| |\|>| |pfHide| |npDefinitionlist|)
                    72> (|npEqKey| |<\||)
                    <72 (|npEqKey| NIL)
                    <71 (|npEnclosed| NIL)
                    <70 (|npAngleBared| NIL)
                    <69 (|npBracketed| NIL)
                    <68 (|npBDefinition| NIL)
                    <67 (|npEncl| NIL)
                    <66 (|npAnyNo| T)
                    66> (|npFromdom|)
                    67> (|npEqKey| $)
                    <67 (|npEqKey| NIL)
                    <66 (|npFromdom| T)
                    <65 (|npEncAp| T)
                    <64 (|npPrimary1| T)
                    <63 (|npPrimary| T)
                    63> (|npAnyNo| |npSelector|)
                    64> (|npSelector|)
                    65> (|npEqKey| DOT)
                    <65 (|npEqKey| NIL)
                    <64 (|npSelector| NIL)
                    <63 (|npAnyNo| T)
                    <62 (|npDotted| T)
                    62> (|npApplication2|)
                    63> (|npDotted| |npPrimary1|)
                    64> (|npPrimary1|)
                    65> (|npEncAp| |npAtom1|)
                    66> (|npAtom1|)
                    67> (|npPDefinition|)
                    68> (|npParenthesized| |npDefinitionlist|)
                    69> (|npParenthesize| |(| |)| |npDefinitionlist|)
                    70> (|npEqKey| |(|)
                    <70 (|npEqKey| NIL)
                    <69 (|npParenthesize| NIL)
                    69> (|npParenthesize| |(\|| |\|)| |npDefinitionlist|)
                    70> (|npEqKey| |(\||)
                    <70 (|npEqKey| NIL)
                    <69 (|npParenthesize| NIL)
                    <68 (|npParenthesized| NIL)
                    <67 (|npPDefinition| NIL)
                    67> (|npName|)
                    68> (|npId|)
                    <68 (|npId| NIL)
                    68> (|npSymbolVariable|)
                    69> (|npState|)
                    <69 (|npState| 
                         (NIL ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1")))
                    69> (|npEqKey| BACKQUOTE)
                    <69 (|npEqKey| NIL)
                    69> (|npRestore|
                         (NIL ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1")))
                    70> (|npFirstTok|)
                    71> (|tokPosn|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    72> (|ncAlist|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <72 (|ncAlist| ((|posn| (0 "1" 1 1 "strings") . 0)))
                    <71 (|tokPosn| ((0 "1" 1 1 "strings") . 0))
                    71> (|tokConstruct| ERROR NOMORE
                          ((0 "1" 1 1 "strings") . 0))
                    72> (|pfNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    73> (|poNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    <73 (|poNoPosition?| NIL)
                    <72 (|pfNoPosition?| NIL)
                    72> (|ncPutQ| (ERROR . NOMORE) |posn|
                          ((0 "1" 1 1 "strings") . 0))
                    73> (|ncAlist| (ERROR . NOMORE))
                    <73 (|ncAlist| NIL)
                    73> (|ncAlist| (ERROR . NOMORE))
                    <73 (|ncAlist| NIL)
                    73> (|ncTag| (ERROR . NOMORE))
                    <73 (|ncTag| ERROR)
                    <72 (|ncPutQ| ((0 "1" 1 1 "strings") . 0))
                    <71 (|tokConstruct|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    71> (|tokPart|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <71 (|tokPart| NOMORE)
                    <70 (|npFirstTok| NOMORE)
                    <69 (|npRestore| T)
                    <68 (|npSymbolVariable| NIL)
                    <67 (|npName| NIL)
                    67> (|npConstTok|)
                    68> (|tokType|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    69> (|ncTag|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <69 (|ncTag| ERROR)
                    <68 (|tokType| ERROR)
                    68> (|npEqPeek| |'|)
                    <68 (|npEqPeek| NIL)
                    <67 (|npConstTok| NIL)
                    67> (|npDollar|)
                    68> (|npEqPeek| $)
                    <68 (|npEqPeek| NIL)
                    <67 (|npDollar| NIL)
                    67> (|npBDefinition|)
                    68> (|npPDefinition|)
                    69> (|npParenthesized| |npDefinitionlist|)
                    70> (|npParenthesize| |(| |)| |npDefinitionlist|)
                    71> (|npEqKey| |(|)
                    <71 (|npEqKey| NIL)
                    <70 (|npParenthesize| NIL)
                    70> (|npParenthesize| |(\|| |\|)| |npDefinitionlist|)
                    71> (|npEqKey| |(\||)
                    <71 (|npEqKey| NIL)
                    <70 (|npParenthesize| NIL)
                    <69 (|npParenthesized| NIL)
                    <68 (|npPDefinition| NIL)
                    68> (|npBracketed| |npDefinitionlist|)
                    69> (|npParened| |npDefinitionlist|)
                    70> (|npEnclosed| |(| |)| |pfParen| |npDefinitionlist|)
                    71> (|npEqKey| |(|)
                    <71 (|npEqKey| NIL)
                    <70 (|npEnclosed| NIL)
                    70> (|npEnclosed| |(\|| |\|)| |pfParen| |npDefinitionlist|)
                    71> (|npEqKey| |(\||)
                    <71 (|npEqKey| NIL)
                    <70 (|npEnclosed| NIL)
                    <69 (|npParened| NIL)
                    69> (|npBracked| |npDefinitionlist|)
                    70> (|npEnclosed| [ ] |pfBracket| |npDefinitionlist|)
                    71> (|npEqKey| [)
                    <71 (|npEqKey| NIL)
                    <70 (|npEnclosed| NIL)
                    70> (|npEnclosed| |[\|| |\|]| 
                                      |pfBracketBar| |npDefinitionlist|)
                    71> (|npEqKey| |[\||)
                    <71 (|npEqKey| NIL)
                    <70 (|npEnclosed| NIL)
                    <69 (|npBracked| NIL)
                    69> (|npBraced| |npDefinitionlist|)
                    70> (|npEnclosed| { } |pfBrace| |npDefinitionlist|)
                    71> (|npEqKey| {)
                    <71 (|npEqKey| NIL)
                    <70 (|npEnclosed| NIL)
                    70> (|npEnclosed| |{\|| |\|}| 
                                      |pfBraceBar| |npDefinitionlist|)
                    71> (|npEqKey| |{\||)
                    <71 (|npEqKey| NIL)
                    <70 (|npEnclosed| NIL)
                    <69 (|npBraced| NIL)
                    69> (|npAngleBared| |npDefinitionlist|)
                    70> (|npEnclosed| |<\|| |\|>| |pfHide| |npDefinitionlist|)
                    71> (|npEqKey| |<\||)
                    <71 (|npEqKey| NIL)
                    <70 (|npEnclosed| NIL)
                    <69 (|npAngleBared| NIL)
                    <68 (|npBracketed| NIL)
                    <67 (|npBDefinition| NIL)
                    <66 (|npAtom1| NIL)
                    <65 (|npEncAp| NIL)
                    65> (|npLet|)
                    66> (|npLetQualified| |npDefinitionOrStatement|)
                    67> (|npEqKey| LET)
                    <67 (|npEqKey| NIL)
                    <66 (|npLetQualified| NIL)
                    <65 (|npLet| NIL)
                    65> (|npFix|)
                    66> (|npEqKey| FIX)
                    <66 (|npEqKey| NIL)
                    <65 (|npFix| NIL)
                    65> (|npMacro|)
                    66> (|npEqKey| MACRO)
                    <66 (|npEqKey| NIL)
                    <65 (|npMacro| NIL)
                    65> (|npBPileDefinition|)
                    66> (|npPileBracketed| |npPileDefinitionlist|)
                    67> (|npEqKey| SETTAB)
                    <67 (|npEqKey| NIL)
                    <66 (|npPileBracketed| NIL)
                    <65 (|npBPileDefinition| NIL)
                    65> (|npDefn|)
                    66> (|npEqKey| DEFN)
                    <66 (|npEqKey| NIL)
                    <65 (|npDefn| NIL)
                    65> (|npRule|)
                    66> (|npEqKey| RULE)
                    <66 (|npEqKey| NIL)
                    <65 (|npRule| NIL)
                    <64 (|npPrimary1| NIL)
                    <63 (|npDotted| NIL)
                    <62 (|npApplication2| NIL)
                    <61 (|npApplication| T)
                    61> (|npAnyNo| |npTypeStyle|)
                    62> (|npTypeStyle|)
                    63> (|npCoerceTo|)
                    64> (|npTypedForm| COERCE |pfCoerceto|)
                    65> (|npEqKey| COERCE)
                    <65 (|npEqKey| NIL)
                    <64 (|npTypedForm| NIL)
                    <63 (|npCoerceTo| NIL)
                    63> (|npRestrict|)
                    64> (|npTypedForm| AT |pfRestrict|)
                    65> (|npEqKey| AT)
                    <65 (|npEqKey| NIL)
                    <64 (|npTypedForm| NIL)
                    <63 (|npRestrict| NIL)
                    63> (|npPretend|)
                    64> (|npTypedForm| PRETEND |pfPretend|)
                    65> (|npEqKey| PRETEND)
                    <65 (|npEqKey| NIL)
                    <64 (|npTypedForm| NIL)
                    <63 (|npPretend| NIL)
                    63> (|npColonQuery|)
                    64> (|npTypedForm| ATAT |pfRetractTo|)
                    65> (|npEqKey| ATAT)
                    <65 (|npEqKey| NIL)
                    <64 (|npTypedForm| NIL)
                    <63 (|npColonQuery| NIL)
                    <62 (|npTypeStyle| NIL)
                    <61 (|npAnyNo| T)
                    <60 (|npTypified| T)
                    60> (|npAnyNo| |npTagged|)
                    61> (|npTagged|)
                    62> (|npTypedForm1| COLON |pfTagged|)
                    63> (|npEqKey| COLON)
                    <63 (|npEqKey| NIL)
                    <62 (|npTypedForm1| NIL)
                    <61 (|npTagged| NIL)
                    <60 (|npAnyNo| T)
                    <59 (|npColon| T)
                    59> (|npInfGeneric| (POWER CARAT))
                    60> (|npDDInfKey| (POWER CARAT))
                    61> (|npInfKey| (POWER CARAT))
                    <61 (|npInfKey| NIL)
                    61> (|npState|)
                    <61 (|npState| 
                         (NIL 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1")))
                    61> (|npEqKey| |'|)
                    <61 (|npEqKey| NIL)
                    61> (|npRestore| 
                         (NIL 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1")))
                    62> (|npFirstTok|)
                    63> (|tokPosn| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    64> (|ncAlist| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <64 (|ncAlist| ((|posn| (0 "1" 1 1 "strings") . 0)))
                    <63 (|tokPosn| ((0 "1" 1 1 "strings") . 0))
                    63> (|tokConstruct| ERROR NOMORE 
                         ((0 "1" 1 1 "strings") . 0))
                    64> (|pfNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    65> (|poNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    <65 (|poNoPosition?| NIL)
                    <64 (|pfNoPosition?| NIL)
                    64> (|ncPutQ| (ERROR . NOMORE) |posn| 
                         ((0 "1" 1 1 "strings") . 0))
                    65> (|ncAlist| (ERROR . NOMORE))
                    <65 (|ncAlist| NIL)
                    65> (|ncAlist| (ERROR . NOMORE))
                    <65 (|ncAlist| NIL)
                    65> (|ncTag| (ERROR . NOMORE))
                    <65 (|ncTag| ERROR)
                    <64 (|ncPutQ| ((0 "1" 1 1 "strings") . 0))
                    <63 (|tokConstruct| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    63> (|tokPart| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <63 (|tokPart| NOMORE)
                    <62 (|npFirstTok| NOMORE)
                    <61 (|npRestore| T)
                    61> (|npEqKey| BACKQUOTE)
                    <61 (|npEqKey| NIL)
                    61> (|npRestore| 
                         (NIL 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1")))
                    62> (|npFirstTok|)
                    63> (|tokPosn| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    64> (|ncAlist| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <64 (|ncAlist| ((|posn| (0 "1" 1 1 "strings") . 0)))
                    <63 (|tokPosn| ((0 "1" 1 1 "strings") . 0))
                    63> (|tokConstruct| ERROR NOMORE 
                         ((0 "1" 1 1 "strings") . 0))
                    64> (|pfNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    65> (|poNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    <65 (|poNoPosition?| NIL)
                    <64 (|pfNoPosition?| NIL)
                    64> (|ncPutQ| (ERROR . NOMORE) |posn| 
                         ((0 "1" 1 1 "strings") . 0))
                    65> (|ncAlist| (ERROR . NOMORE))
                    <65 (|ncAlist| NIL)
                    65> (|ncAlist| (ERROR . NOMORE))
                    <65 (|ncAlist| NIL)
                    65> (|ncTag| (ERROR . NOMORE))
                    <65 (|ncTag| ERROR)
                    <64 (|ncPutQ| ((0 "1" 1 1 "strings") . 0))
                    <63 (|tokConstruct| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    63> (|tokPart| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <63 (|tokPart| NOMORE)
                    <62 (|npFirstTok| NOMORE)
                    <61 (|npRestore| T)
                    <60 (|npDDInfKey| NIL)
                    <59 (|npInfGeneric| NIL)
                    <58 (|npRightAssoc| T)
                    <57 (|npPower| T)
                    57> (|npInfGeneric| 
                         (TIMES SLASH BACKSLASH SLASHSLASH BACKSLASHBACKSLASH 
                          SLASHBACKSLASH BACKSLASHSLASH))
                    58> (|npDDInfKey| 
                         (TIMES SLASH BACKSLASH SLASHSLASH BACKSLASHBACKSLASH 
                          SLASHBACKSLASH BACKSLASHSLASH))
                    59> (|npInfKey| 
                         (TIMES SLASH BACKSLASH SLASHSLASH BACKSLASHBACKSLASH 
                          SLASHBACKSLASH BACKSLASHSLASH))
                    <59 (|npInfKey| NIL)
                    59> (|npState|)
                    <59 (|npState| 
                         (NIL 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1")))
                    59> (|npEqKey| |'|)
                    <59 (|npEqKey| NIL)
                    59> (|npRestore| 
                         (NIL 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1")))
                    60> (|npFirstTok|)
                    61> (|tokPosn| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    62> (|ncAlist| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <62 (|ncAlist| ((|posn| (0 "1" 1 1 "strings") . 0)))
                    <61 (|tokPosn| ((0 "1" 1 1 "strings") . 0))
                    61> (|tokConstruct| ERROR NOMORE 
                         ((0 "1" 1 1 "strings") . 0))
                    62> (|pfNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    63> (|poNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    <63 (|poNoPosition?| NIL)
                    <62 (|pfNoPosition?| NIL)
                    62> (|ncPutQ| (ERROR . NOMORE) |posn| 
                         ((0 "1" 1 1 "strings") . 0))
                    63> (|ncAlist| (ERROR . NOMORE))
                    <63 (|ncAlist| NIL)
                    63> (|ncAlist| (ERROR . NOMORE))
                    <63 (|ncAlist| NIL)
                    63> (|ncTag| (ERROR . NOMORE))
                    <63 (|ncTag| ERROR)
                    <62 (|ncPutQ| ((0 "1" 1 1 "strings") . 0))
                    <61 (|tokConstruct| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    61> (|tokPart| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <61 (|tokPart| NOMORE)
                    <60 (|npFirstTok| NOMORE)
                    <59 (|npRestore| T)
                    59> (|npEqKey| BACKQUOTE)
                    <59 (|npEqKey| NIL)
                    59> (|npRestore| 
                         (NIL 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1")))
                    60> (|npFirstTok|)
                    61> (|tokPosn| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    62> (|ncAlist| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <62 (|ncAlist| ((|posn| (0 "1" 1 1 "strings") . 0)))
                    <61 (|tokPosn| ((0 "1" 1 1 "strings") . 0))
                    61> (|tokConstruct| ERROR NOMORE 
                         ((0 "1" 1 1 "strings") . 0))
                    62> (|pfNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    63> (|poNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    <63 (|poNoPosition?| NIL)
                    <62 (|pfNoPosition?| NIL)
                    62> (|ncPutQ| (ERROR . NOMORE) |posn| 
                         ((0 "1" 1 1 "strings") . 0))
                    63> (|ncAlist| (ERROR . NOMORE))
                    <63 (|ncAlist| NIL)
                    63> (|ncAlist| (ERROR . NOMORE))
                    <63 (|ncAlist| NIL)
                    63> (|ncTag| (ERROR . NOMORE))
                    <63 (|ncTag| ERROR)
                    <62 (|ncPutQ| ((0 "1" 1 1 "strings") . 0))
                    <61 (|tokConstruct|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    61> (|tokPart|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <61 (|tokPart| NOMORE)
                    <60 (|npFirstTok| NOMORE)
                    <59 (|npRestore| T)
                    <58 (|npDDInfKey| NIL)
                    <57 (|npInfGeneric| NIL)
                    <56 (|npLeftAssoc| T)
                    <55 (|npProduct| T)
                    55> (|npInfGeneric| (REM QUO))
                    56> (|npDDInfKey| (REM QUO))
                    57> (|npInfKey| (REM QUO))
                    <57 (|npInfKey| NIL)
                    57> (|npState|)
                    <57 (|npState|
                         (NIL
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1")))
                    57> (|npEqKey| |'|)
                    <57 (|npEqKey| NIL)
                    57> (|npRestore|
                         (NIL 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1")))
                    58> (|npFirstTok|)
                    59> (|tokPosn| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    60> (|ncAlist| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <60 (|ncAlist| ((|posn| (0 "1" 1 1 "strings") . 0)))
                    <59 (|tokPosn| ((0 "1" 1 1 "strings") . 0))
                    59> (|tokConstruct| ERROR NOMORE (
                         (0 "1" 1 1 "strings") . 0))
                    60> (|pfNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    61> (|poNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    <61 (|poNoPosition?| NIL)
                    <60 (|pfNoPosition?| NIL)
                    60> (|ncPutQ| (ERROR . NOMORE) |posn| 
                         ((0 "1" 1 1 "strings") . 0))
                    61> (|ncAlist| (ERROR . NOMORE))
                    <61 (|ncAlist| NIL)
                    61> (|ncAlist| (ERROR . NOMORE))
                    <61 (|ncAlist| NIL)
                    61> (|ncTag| (ERROR . NOMORE))
                    <61 (|ncTag| ERROR)
                    <60 (|ncPutQ| ((0 "1" 1 1 "strings") . 0))
                    <59 (|tokConstruct| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    59> (|tokPart| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <59 (|tokPart| NOMORE)
                    <58 (|npFirstTok| NOMORE)
                    <57 (|npRestore| T)
                    57> (|npEqKey| BACKQUOTE)
                    <57 (|npEqKey| NIL)
                    57> (|npRestore| 
                         (NIL 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1")))
                    58> (|npFirstTok|)
                    59> (|tokPosn| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    60> (|ncAlist| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <60 (|ncAlist| ((|posn| (0 "1" 1 1 "strings") . 0)))
                    <59 (|tokPosn| ((0 "1" 1 1 "strings") . 0))
                    59> (|tokConstruct| ERROR NOMORE 
                          ((0 "1" 1 1 "strings") . 0))
                    60> (|pfNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    61> (|poNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    <61 (|poNoPosition?| NIL)
                    <60 (|pfNoPosition?| NIL)
                    60> (|ncPutQ| (ERROR . NOMORE) |posn| 
                         ((0 "1" 1 1 "strings") . 0))
                    61> (|ncAlist| (ERROR . NOMORE))
                    <61 (|ncAlist| NIL)
                    61> (|ncAlist| (ERROR . NOMORE))
                    <61 (|ncAlist| NIL)
                    61> (|ncTag| (ERROR . NOMORE))
                    <61 (|ncTag| ERROR)
                    <60 (|ncPutQ| ((0 "1" 1 1 "strings") . 0))
                    <59 (|tokConstruct| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    59> (|tokPart| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <59 (|tokPart| NOMORE)
                    <58 (|npFirstTok| NOMORE)
                    <57 (|npRestore| T)
                    <56 (|npDDInfKey| NIL)
                    <55 (|npInfGeneric| NIL)
                    <54 (|npLeftAssoc| T)
                    <53 (|npRemainder| T)
                    <52 (|npTerm| T)
                    52> (|npInfGeneric| (PLUS MINUS))
                    53> (|npDDInfKey| (PLUS MINUS))
                    54> (|npInfKey| (PLUS MINUS))
                    <54 (|npInfKey| NIL)
                    54> (|npState|)
                    <54 (|npState| 
                         (NIL 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1")))
                    54> (|npEqKey| |'|)
                    <54 (|npEqKey| NIL)
                    54> (|npRestore| 
                         (NIL 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) 
                           . "1")))
                    55> (|npFirstTok|)
                    56> (|tokPosn|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    57> (|ncAlist|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <57 (|ncAlist| ((|posn| (0 "1" 1 1 "strings") . 0)))
                    <56 (|tokPosn| ((0 "1" 1 1 "strings") . 0))
                    56> (|tokConstruct| ERROR NOMORE 
                          ((0 "1" 1 1 "strings") . 0))
                    57> (|pfNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    58> (|poNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    <58 (|poNoPosition?| NIL)
                    <57 (|pfNoPosition?| NIL)
                    57> (|ncPutQ| (ERROR . NOMORE) |posn| 
                          ((0 "1" 1 1 "strings") . 0))
                    58> (|ncAlist| (ERROR . NOMORE))
                    <58 (|ncAlist| NIL)
                    58> (|ncAlist| (ERROR . NOMORE))
                    <58 (|ncAlist| NIL)
                    58> (|ncTag| (ERROR . NOMORE))
                    <58 (|ncTag| ERROR)
                    <57 (|ncPutQ| ((0 "1" 1 1 "strings") . 0))
                    <56 (|tokConstruct| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    56> (|tokPart| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <56 (|tokPart| NOMORE)
                    <55 (|npFirstTok| NOMORE)
                    <54 (|npRestore| T)
                    54> (|npEqKey| BACKQUOTE)
                    <54 (|npEqKey| NIL)
                    54> (|npRestore| 
                         (NIL 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1")))
                    55> (|npFirstTok|)
                    56> (|tokPosn| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    57> (|ncAlist| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <57 (|ncAlist| ((|posn| (0 "1" 1 1 "strings") . 0)))
                    <56 (|tokPosn| ((0 "1" 1 1 "strings") . 0))
                    56> (|tokConstruct| ERROR NOMORE 
                         ((0 "1" 1 1 "strings") . 0))
                    57> (|pfNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    58> (|poNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    <58 (|poNoPosition?| NIL)
                    <57 (|pfNoPosition?| NIL)
                    57> (|ncPutQ| (ERROR . NOMORE) |posn| 
                         ((0 "1" 1 1 "strings") . 0))
                    58> (|ncAlist| (ERROR . NOMORE))
                    <58 (|ncAlist| NIL)
                    58> (|ncAlist| (ERROR . NOMORE))
                    <58 (|ncAlist| NIL)
                    58> (|ncTag| (ERROR . NOMORE))
                    <58 (|ncTag| ERROR)
                    <57 (|ncPutQ| ((0 "1" 1 1 "strings") . 0))
                    <56 (|tokConstruct| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    56> (|tokPart| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <56 (|tokPart| NOMORE)
                    <55 (|npFirstTok| NOMORE)
                    <54 (|npRestore| T)
                    <53 (|npDDInfKey| NIL)
                    <52 (|npInfGeneric| NIL)
                    <51 (|npLeftAssoc| T)
                    <50 (|npSum| T)
                    50> (|npInfGeneric| (MOD))
                    51> (|npDDInfKey| (MOD))
                    52> (|npInfKey| (MOD))
                    <52 (|npInfKey| NIL)
                    52> (|npState|)
                    <52 (|npState| 
                         (NIL 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1")))
                    52> (|npEqKey| |'|)
                    <52 (|npEqKey| NIL)
                    52> (|npRestore| 
                         (NIL 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1")))
                    53> (|npFirstTok|)
                    54> (|tokPosn| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    55> (|ncAlist| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <55 (|ncAlist| ((|posn| (0 "1" 1 1 "strings") . 0)))
                    <54 (|tokPosn| ((0 "1" 1 1 "strings") . 0))
                    54> (|tokConstruct| ERROR NOMORE 
                         ((0 "1" 1 1 "strings") . 0))
                    55> (|pfNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    56> (|poNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    <56 (|poNoPosition?| NIL)
                    <55 (|pfNoPosition?| NIL)
                    55> (|ncPutQ| (ERROR . NOMORE) |posn| 
                         ((0 "1" 1 1 "strings") . 0))
                    56> (|ncAlist| (ERROR . NOMORE))
                    <56 (|ncAlist| NIL)
                    56> (|ncAlist| (ERROR . NOMORE))
                    <56 (|ncAlist| NIL)
                    56> (|ncTag| (ERROR . NOMORE))
                    <56 (|ncTag| ERROR)
                    <55 (|ncPutQ| ((0 "1" 1 1 "strings") . 0))
                    <54 (|tokConstruct| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    54> (|tokPart| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <54 (|tokPart| NOMORE)
                    <53 (|npFirstTok| NOMORE)
                    <52 (|npRestore| T)
                    52> (|npEqKey| BACKQUOTE)
                    <52 (|npEqKey| NIL)
                    52> (|npRestore| 
                         (NIL 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1")))
                    53> (|npFirstTok|)
                    54> (|tokPosn| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    55> (|ncAlist| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <55 (|ncAlist| ((|posn| (0 "1" 1 1 "strings") . 0)))
                    <54 (|tokPosn| ((0 "1" 1 1 "strings") . 0))
                    54> (|tokConstruct| ERROR NOMORE 
                          ((0 "1" 1 1 "strings") . 0))
                    55> (|pfNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    56> (|poNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    <56 (|poNoPosition?| NIL)
                    <55 (|pfNoPosition?| NIL)
                    55> (|ncPutQ| (ERROR . NOMORE) |posn| 
                          ((0 "1" 1 1 "strings") . 0))
                    56> (|ncAlist| (ERROR . NOMORE))
                    <56 (|ncAlist| NIL)
                    56> (|ncAlist| (ERROR . NOMORE))
                    <56 (|ncAlist| NIL)
                    56> (|ncTag| (ERROR . NOMORE))
                    <56 (|ncTag| ERROR)
                    <55 (|ncPutQ| ((0 "1" 1 1 "strings") . 0))
                    <54 (|tokConstruct| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    54> (|tokPart|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <54 (|tokPart| NOMORE)
                    <53 (|npFirstTok| NOMORE)
                    <52 (|npRestore| T)
                    <51 (|npDDInfKey| NIL)
                    <50 (|npInfGeneric| NIL)
                    <49 (|npLeftAssoc| T)
                    <48 (|npArith| T)
                    48> (|npSegment|)
                    49> (|npEqPeek| SEG)
                    <49 (|npEqPeek| NIL)
                    <48 (|npSegment| NIL)
                    <47 (|npInterval| T)
                    47> (|npInfGeneric| (BY))
                    48> (|npDDInfKey| (BY))
                    49> (|npInfKey| (BY))
                    <49 (|npInfKey| NIL)
                    49> (|npState|)
                    <49 (|npState| 
                         (NIL 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1")))
                    49> (|npEqKey| |'|)
                    <49 (|npEqKey| NIL)
                    49> (|npRestore|
                         (NIL
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1")))
                    50> (|npFirstTok|)
                    51> (|tokPosn|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    52> (|ncAlist|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <52 (|ncAlist| ((|posn| (0 "1" 1 1 "strings") . 0)))
                    <51 (|tokPosn| ((0 "1" 1 1 "strings") . 0))
                    51> (|tokConstruct| ERROR NOMORE
                          ((0 "1" 1 1 "strings") . 0))
                    52> (|pfNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    53> (|poNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    <53 (|poNoPosition?| NIL)
                    <52 (|pfNoPosition?| NIL)
                    52> (|ncPutQ| (ERROR . NOMORE) |posn|
                         ((0 "1" 1 1 "strings") . 0))
                    53> (|ncAlist| (ERROR . NOMORE))
                    <53 (|ncAlist| NIL)
                    53> (|ncAlist| (ERROR . NOMORE))
                    <53 (|ncAlist| NIL)
                    53> (|ncTag| (ERROR . NOMORE))
                    <53 (|ncTag| ERROR)
                    <52 (|ncPutQ| ((0 "1" 1 1 "strings") . 0))
                    <51 (|tokConstruct|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    51> (|tokPart|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <51 (|tokPart| NOMORE)
                    <50 (|npFirstTok| NOMORE)
                    <49 (|npRestore| T)
                    49> (|npEqKey| BACKQUOTE)
                    <49 (|npEqKey| NIL)
                    49> (|npRestore|
                         (NIL
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1")))
                    50> (|npFirstTok|)
                    51> (|tokPosn|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    52> (|ncAlist|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <52 (|ncAlist| ((|posn| (0 "1" 1 1 "strings") . 0)))
                    <51 (|tokPosn| ((0 "1" 1 1 "strings") . 0))
                    51> (|tokConstruct| ERROR NOMORE ((0 "1" 1 1 "strings") .
                           0))
                    52> (|pfNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    53> (|poNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    <53 (|poNoPosition?| NIL)
                    <52 (|pfNoPosition?| NIL)
                    52> (|ncPutQ|
                         (ERROR . NOMORE) |posn| ((0 "1" 1 1 "strings") . 0))
                    53> (|ncAlist| (ERROR . NOMORE))
                    <53 (|ncAlist| NIL)
                    53> (|ncAlist| (ERROR . NOMORE))
                    <53 (|ncAlist| NIL)
                    53> (|ncTag| (ERROR . NOMORE))
                    <53 (|ncTag| ERROR)
                    <52 (|ncPutQ| ((0 "1" 1 1 "strings") . 0))
                    <51 (|tokConstruct|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    51> (|tokPart|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <51 (|tokPart| NOMORE)
                    <50 (|npFirstTok| NOMORE)
                    <49 (|npRestore| T)
                    <48 (|npDDInfKey| NIL)
                    <47 (|npInfGeneric| NIL)
                    <46 (|npLeftAssoc| T)
                    <45 (|npBy| T)
                    45> (|npAmpersandFrom|)
                    46> (|npAmpersand|)
                    47> (|npEqKey| AMPERSAND)
                    <47 (|npEqKey| NIL)
                    <46 (|npAmpersand| NIL)
                    <45 (|npAmpersandFrom| NIL)
                    <44 (|npSynthetic| T)
                    44> (|npInfGeneric|
                         (EQUAL NOTEQUAL LT LE GT GE OANGLE CANGLE))
                    45> (|npDDInfKey|
                         (EQUAL NOTEQUAL LT LE GT GE OANGLE CANGLE))
                    46> (|npInfKey| (EQUAL NOTEQUAL LT LE GT GE OANGLE CANGLE))
                    <46 (|npInfKey| NIL)
                    46> (|npState|)
                    <46 (|npState|
                         (NIL
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1")))
                    46> (|npEqKey| |'|)
                    <46 (|npEqKey| NIL)
                    46> (|npRestore|
                         (NIL
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) 
                           . "1")))
                    47> (|npFirstTok|)
                    48> (|tokPosn|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    49> (|ncAlist|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <49 (|ncAlist| ((|posn| (0 "1" 1 1 "strings") . 0)))
                    <48 (|tokPosn| ((0 "1" 1 1 "strings") . 0))
                    48> (|tokConstruct| ERROR NOMORE 
                         ((0 "1" 1 1 "strings") . 0))
                    49> (|pfNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    50> (|poNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    <50 (|poNoPosition?| NIL)
                    <49 (|pfNoPosition?| NIL)
                    49> (|ncPutQ| (ERROR . NOMORE) |posn| 
                          ((0 "1" 1 1 "strings") . 0))
                    50> (|ncAlist| (ERROR . NOMORE))
                    <50 (|ncAlist| NIL)
                    50> (|ncAlist| (ERROR . NOMORE))
                    <50 (|ncAlist| NIL)
                    50> (|ncTag| (ERROR . NOMORE))
                    <50 (|ncTag| ERROR)
                    <49 (|ncPutQ| ((0 "1" 1 1 "strings") . 0))
                    <48 (|tokConstruct| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    48> (|tokPart| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <48 (|tokPart| NOMORE)
                    <47 (|npFirstTok| NOMORE)
                    <46 (|npRestore| T)
                    46> (|npEqKey| BACKQUOTE)
                    <46 (|npEqKey| NIL)
                    46> (|npRestore| 
                         (NIL 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1")))
                    47> (|npFirstTok|)
                    48> (|tokPosn| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    49> (|ncAlist| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <49 (|ncAlist| ((|posn| (0 "1" 1 1 "strings") . 0)))
                    <48 (|tokPosn| ((0 "1" 1 1 "strings") . 0))
                    48> (|tokConstruct| ERROR NOMORE 
                         ((0 "1" 1 1 "strings") . 0))
                    49> (|pfNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    50> (|poNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    <50 (|poNoPosition?| NIL)
                    <49 (|pfNoPosition?| NIL)
                    49> (|ncPutQ| (ERROR . NOMORE) |posn| 
                         ((0 "1" 1 1 "strings") . 0))
                    50> (|ncAlist| (ERROR . NOMORE))
                    <50 (|ncAlist| NIL)
                    50> (|ncAlist| (ERROR . NOMORE))
                    <50 (|ncAlist| NIL)
                    50> (|ncTag| (ERROR . NOMORE))
                    <50 (|ncTag| ERROR)
                    <49 (|ncPutQ| ((0 "1" 1 1 "strings") . 0))
                    <48 (|tokConstruct| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    48> (|tokPart| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <48 (|tokPart| NOMORE)
                    <47 (|npFirstTok| NOMORE)
                    <46 (|npRestore| T)
                    <45 (|npDDInfKey| NIL)
                    <44 (|npInfGeneric| NIL)
                    <43 (|npLeftAssoc| T)
                    <42 (|npRelation| T)
                    42> (|npInfGeneric| (ARROW LARROW))
                    43> (|npDDInfKey| (ARROW LARROW))
                    44> (|npInfKey| (ARROW LARROW))
                    <44 (|npInfKey| NIL)
                    44> (|npState|)
                    <44 (|npState| 
                         (NIL 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1")))
                    44> (|npEqKey| |'|)
                    <44 (|npEqKey| NIL)
                    44> (|npRestore| 
                         (NIL 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1")))
                    45> (|npFirstTok|)
                    46> (|tokPosn|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    47> (|ncAlist|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <47 (|ncAlist| ((|posn| (0 "1" 1 1 "strings") . 0)))
                    <46 (|tokPosn| ((0 "1" 1 1 "strings") . 0))
                    46> (|tokConstruct| ERROR NOMORE 
                         ((0 "1" 1 1 "strings") . 0))
                    47> (|pfNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    48> (|poNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    <48 (|poNoPosition?| NIL)
                    <47 (|pfNoPosition?| NIL)
                    47> (|ncPutQ| (ERROR . NOMORE) |posn| 
                         ((0 "1" 1 1 "strings") . 0))
                    48> (|ncAlist| (ERROR . NOMORE))
                    <48 (|ncAlist| NIL)
                    48> (|ncAlist| (ERROR . NOMORE))
                    <48 (|ncAlist| NIL)
                    48> (|ncTag| (ERROR . NOMORE))
                    <48 (|ncTag| ERROR)
                    <47 (|ncPutQ| ((0 "1" 1 1 "strings") . 0))
                    <46 (|tokConstruct| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    46> (|tokPart| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <46 (|tokPart| NOMORE)
                    <45 (|npFirstTok| NOMORE)
                    <44 (|npRestore| T)
                    44> (|npEqKey| BACKQUOTE)
                    <44 (|npEqKey| NIL)
                    44> (|npRestore| 
                         (NIL 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1")))
                    45> (|npFirstTok|)
                    46> (|tokPosn|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    47> (|ncAlist|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <47 (|ncAlist| ((|posn| (0 "1" 1 1 "strings") . 0)))
                    <46 (|tokPosn| ((0 "1" 1 1 "strings") . 0))
                    46> (|tokConstruct| ERROR NOMORE 
                         ((0 "1" 1 1 "strings") . 0))
                    47> (|pfNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    48> (|poNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    <48 (|poNoPosition?| NIL)
                    <47 (|pfNoPosition?| NIL)
                    47> (|ncPutQ| (ERROR . NOMORE) |posn| 
                         ((0 "1" 1 1 "strings") . 0))
                    48> (|ncAlist| (ERROR . NOMORE))
                    <48 (|ncAlist| NIL)
                    48> (|ncAlist| (ERROR . NOMORE))
                    <48 (|ncAlist| NIL)
                    48> (|ncTag| (ERROR . NOMORE))
                    <48 (|ncTag| ERROR)
                    <47 (|ncPutQ| ((0 "1" 1 1 "strings") . 0))
                    <46 (|tokConstruct| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    46> (|tokPart| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <46 (|tokPart| NOMORE)
                    <45 (|npFirstTok| NOMORE)
                    <44 (|npRestore| T)
                    <43 (|npDDInfKey| NIL)
                    <42 (|npInfGeneric| NIL)
                    <41 (|npRightAssoc| T)
                    <40 (|npQuiver| T)
                    40> (|npInfGeneric| (CASE HAS))
                    41> (|npDDInfKey| (CASE HAS))
                    42> (|npInfKey| (CASE HAS))
                    <42 (|npInfKey| NIL)
                    42> (|npState|)
                    <42 (|npState|
                         (NIL
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1")))
                    42> (|npEqKey| |'|)
                    <42 (|npEqKey| NIL)
                    42> (|npRestore|
                         (NIL
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1")))
                    43> (|npFirstTok|)
                    44> (|tokPosn|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    45> (|ncAlist|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <45 (|ncAlist| ((|posn| (0 "1" 1 1 "strings") . 0)))
                    <44 (|tokPosn| ((0 "1" 1 1 "strings") . 0))
                    44> (|tokConstruct| ERROR NOMORE 
                         ((0 "1" 1 1 "strings") . 0))
                    45> (|pfNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    46> (|poNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    <46 (|poNoPosition?| NIL)
                    <45 (|pfNoPosition?| NIL)
                    45> (|ncPutQ| (ERROR . NOMORE) |posn| 
                         ((0 "1" 1 1 "strings") . 0))
                    46> (|ncAlist| (ERROR . NOMORE))
                    <46 (|ncAlist| NIL)
                    46> (|ncAlist| (ERROR . NOMORE))
                    <46 (|ncAlist| NIL)
                    46> (|ncTag| (ERROR . NOMORE))
                    <46 (|ncTag| ERROR)
                    <45 (|ncPutQ| ((0 "1" 1 1 "strings") . 0))
                    <44 (|tokConstruct| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    44> (|tokPart| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <44 (|tokPart| NOMORE)
                    <43 (|npFirstTok| NOMORE)
                    <42 (|npRestore| T)
                    42> (|npEqKey| BACKQUOTE)
                    <42 (|npEqKey| NIL)
                    42> (|npRestore| 
                         (NIL 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1")))
                    43> (|npFirstTok|)
                    44> (|tokPosn| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    45> (|ncAlist| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <45 (|ncAlist| ((|posn| (0 "1" 1 1 "strings") . 0)))
                    <44 (|tokPosn| ((0 "1" 1 1 "strings") . 0))
                    44> (|tokConstruct| ERROR NOMORE 
                          ((0 "1" 1 1 "strings") . 0))
                    45> (|pfNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    46> (|poNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    <46 (|poNoPosition?| NIL)
                    <45 (|pfNoPosition?| NIL)
                    45> (|ncPutQ| (ERROR . NOMORE) |posn| 
                          ((0 "1" 1 1 "strings") . 0))
                    46> (|ncAlist| (ERROR . NOMORE))
                    <46 (|ncAlist| NIL)
                    46> (|ncAlist| (ERROR . NOMORE))
                    <46 (|ncAlist| NIL)
                    46> (|ncTag| (ERROR . NOMORE))
                    <46 (|ncTag| ERROR)
                    <45 (|ncPutQ| ((0 "1" 1 1 "strings") . 0))
                    <44 (|tokConstruct| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    44> (|tokPart| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <44 (|tokPart| NOMORE)
                    <43 (|npFirstTok| NOMORE)
                    <42 (|npRestore| T)
                    <41 (|npDDInfKey| NIL)
                    <40 (|npInfGeneric| NIL)
                    <39 (|npLeftAssoc| T)
                    <38 (|npDiscrim| T)
                    38> (|npInfGeneric| (AND))
                    39> (|npDDInfKey| (AND))
                    40> (|npInfKey| (AND))
                    <40 (|npInfKey| NIL)
                    40> (|npState|)
                    <40 (|npState| 
                         (NIL 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1")))
                    40> (|npEqKey| |'|)
                    <40 (|npEqKey| NIL)
                    40> (|npRestore|
                          (NIL 
                           ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1")))
                    41> (|npFirstTok|)
                    42> (|tokPosn|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    43> (|ncAlist|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <43 (|ncAlist| ((|posn| (0 "1" 1 1 "strings") . 0)))
                    <42 (|tokPosn| ((0 "1" 1 1 "strings") . 0))
                    42> (|tokConstruct| ERROR NOMORE ((0 "1" 1 1 "strings") . 0))
                    43> (|pfNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    44> (|poNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    <44 (|poNoPosition?| NIL)
                    <43 (|pfNoPosition?| NIL)
                    43> (|ncPutQ| (ERROR . NOMORE) |posn| 
                         ((0 "1" 1 1 "strings") . 0))
                    44> (|ncAlist| (ERROR . NOMORE))
                    <44 (|ncAlist| NIL)
                    44> (|ncAlist| (ERROR . NOMORE))
                    <44 (|ncAlist| NIL)
                    44> (|ncTag| (ERROR . NOMORE))
                    <44 (|ncTag| ERROR)
                    <43 (|ncPutQ| ((0 "1" 1 1 "strings") . 0))
                    <42 (|tokConstruct| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    42> (|tokPart| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <42 (|tokPart| NOMORE)
                    <41 (|npFirstTok| NOMORE)
                    <40 (|npRestore| T)
                    40> (|npEqKey| BACKQUOTE)
                    <40 (|npEqKey| NIL)
                    40> (|npRestore| 
                         (NIL 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1")))
                    41> (|npFirstTok|)
                    42> (|tokPosn|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    43> (|ncAlist|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <43 (|ncAlist| ((|posn| (0 "1" 1 1 "strings") . 0)))
                    <42 (|tokPosn| ((0 "1" 1 1 "strings") . 0))
                    42> (|tokConstruct| ERROR NOMORE 
                          ((0 "1" 1 1 "strings") . 0))
                    43> (|pfNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    44> (|poNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    <44 (|poNoPosition?| NIL)
                    <43 (|pfNoPosition?| NIL)
                    43> (|ncPutQ| (ERROR . NOMORE) |posn|
                          ((0 "1" 1 1 "strings") . 0))
                    44> (|ncAlist| (ERROR . NOMORE))
                    <44 (|ncAlist| NIL)
                    44> (|ncAlist| (ERROR . NOMORE))
                    <44 (|ncAlist| NIL)
                    44> (|ncTag| (ERROR . NOMORE))
                    <44 (|ncTag| ERROR)
                    <43 (|ncPutQ| ((0 "1" 1 1 "strings") . 0))
                    <42 (|tokConstruct|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    42> (|tokPart|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <42 (|tokPart| NOMORE)
                    <41 (|npFirstTok| NOMORE)
                    <40 (|npRestore| T)
                    <39 (|npDDInfKey| NIL)
                    <38 (|npInfGeneric| NIL)
                    <37 (|npLeftAssoc| T)
                    <36 (|npDisjand| T)
                    36> (|npInfGeneric| (OR))
                    37> (|npDDInfKey| (OR))
                    38> (|npInfKey| (OR))
                    <38 (|npInfKey| NIL)
                    38> (|npState|)
                    <38 (|npState| 
                         (NIL 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1")))
                    38> (|npEqKey| |'|)
                    <38 (|npEqKey| NIL)
                    38> (|npRestore| 
                         (NIL 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1")))
                    39> (|npFirstTok|)
                    40> (|tokPosn| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    41> (|ncAlist| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <41 (|ncAlist| ((|posn| (0 "1" 1 1 "strings") . 0)))
                    <40 (|tokPosn| ((0 "1" 1 1 "strings") . 0))
                    40> (|tokConstruct| ERROR NOMORE 
                          ((0 "1" 1 1 "strings") . 0))
                    41> (|pfNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    42> (|poNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    <42 (|poNoPosition?| NIL)
                    <41 (|pfNoPosition?| NIL)
                    41> (|ncPutQ| (ERROR . NOMORE) |posn| 
                          ((0 "1" 1 1 "strings") . 0))
                    42> (|ncAlist| (ERROR . NOMORE))
                    <42 (|ncAlist| NIL)
                    42> (|ncAlist| (ERROR . NOMORE))
                    <42 (|ncAlist| NIL)
                    42> (|ncTag| (ERROR . NOMORE))
                    <42 (|ncTag| ERROR)
                    <41 (|ncPutQ| ((0 "1" 1 1 "strings") . 0))
                    <40 (|tokConstruct| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    40> (|tokPart| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <40 (|tokPart| NOMORE)
                    <39 (|npFirstTok| NOMORE)
                    <38 (|npRestore| T)
                    38> (|npEqKey| BACKQUOTE)
                    <38 (|npEqKey| NIL)
                    38> (|npRestore| 
                         (NIL 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1")))
                    39> (|npFirstTok|)
                    40> (|tokPosn| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    41> (|ncAlist| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <41 (|ncAlist| ((|posn| (0 "1" 1 1 "strings") . 0)))
                    <40 (|tokPosn| ((0 "1" 1 1 "strings") . 0))
                    40> (|tokConstruct| ERROR NOMORE 
                          ((0 "1" 1 1 "strings") . 0))
                    41> (|pfNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    42> (|poNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    <42 (|poNoPosition?| NIL)
                    <41 (|pfNoPosition?| NIL)
                    41> (|ncPutQ| (ERROR . NOMORE) |posn| 
                          ((0 "1" 1 1 "strings") . 0))
                    42> (|ncAlist| (ERROR . NOMORE))
                    <42 (|ncAlist| NIL)
                    42> (|ncAlist| (ERROR . NOMORE))
                    <42 (|ncAlist| NIL)
                    42> (|ncTag| (ERROR . NOMORE))
                    <42 (|ncTag| ERROR)
                    <41 (|ncPutQ| ((0 "1" 1 1 "strings") . 0))
                    <40 (|tokConstruct| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    40> (|tokPart| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <40 (|tokPart| NOMORE)
                    <39 (|npFirstTok| NOMORE)
                    <38 (|npRestore| T)
                    <37 (|npDDInfKey| NIL)
                    <36 (|npInfGeneric| NIL)
                    <35 (|npLeftAssoc| T)
                    <34 (|npLogical| T)
                    34> (|npInfGeneric| (BAR))
                    35> (|npDDInfKey| (BAR))
                    36> (|npInfKey| (BAR))
                    <36 (|npInfKey| NIL)
                    36> (|npState|)
                    <36 (|npState| 
                         (NIL 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1")))
                    36> (|npEqKey| |'|)
                    <36 (|npEqKey| NIL)
                    36> (|npRestore| 
                         (NIL 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1")))
                    37> (|npFirstTok|)
                    38> (|tokPosn|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    39> (|ncAlist|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <39 (|ncAlist| ((|posn| (0 "1" 1 1 "strings") . 0)))
                    <38 (|tokPosn| ((0 "1" 1 1 "strings") . 0))
                    38> (|tokConstruct| ERROR NOMORE 
                          ((0 "1" 1 1 "strings") . 0))
                    39> (|pfNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    40> (|poNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    <40 (|poNoPosition?| NIL)
                    <39 (|pfNoPosition?| NIL)
                    39> (|ncPutQ| (ERROR . NOMORE) |posn| 
                          ((0 "1" 1 1 "strings") . 0))
                    40> (|ncAlist| (ERROR . NOMORE))
                    <40 (|ncAlist| NIL)
                    40> (|ncAlist| (ERROR . NOMORE))
                    <40 (|ncAlist| NIL)
                    40> (|ncTag| (ERROR . NOMORE))
                    <40 (|ncTag| ERROR)
                    <39 (|ncPutQ| ((0 "1" 1 1 "strings") . 0))
                    <38 (|tokConstruct| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    38> (|tokPart| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <38 (|tokPart| NOMORE)
                    <37 (|npFirstTok| NOMORE)
                    <36 (|npRestore| T)
                    36> (|npEqKey| BACKQUOTE)
                    <36 (|npEqKey| NIL)
                    36> (|npRestore| 
                         (NIL 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1")))
                    37> (|npFirstTok|)
                    38> (|tokPosn|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    39> (|ncAlist|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <39 (|ncAlist| ((|posn| (0 "1" 1 1 "strings") . 0)))
                    <38 (|tokPosn| ((0 "1" 1 1 "strings") . 0))
                    38> (|tokConstruct| ERROR NOMORE
                          ((0 "1" 1 1 "strings") . 0))
                    39> (|pfNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    40> (|poNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    <40 (|poNoPosition?| NIL)
                    <39 (|pfNoPosition?| NIL)
                    39> (|ncPutQ| (ERROR . NOMORE) |posn|
                         ((0 "1" 1 1 "strings") . 0))
                    40> (|ncAlist| (ERROR . NOMORE))
                    <40 (|ncAlist| NIL)
                    40> (|ncAlist| (ERROR . NOMORE))
                    <40 (|ncAlist| NIL)
                    40> (|ncTag| (ERROR . NOMORE))
                    <40 (|ncTag| ERROR)
                    <39 (|ncPutQ| ((0 "1" 1 1 "strings") . 0))
                    <38 (|tokConstruct| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    38> (|tokPart| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <38 (|tokPart| NOMORE)
                    <37 (|npFirstTok| NOMORE)
                    <36 (|npRestore| T)
                    <35 (|npDDInfKey| NIL)
                    <34 (|npInfGeneric| NIL)
                    <33 (|npLeftAssoc| T)
                    <32 (|npSuch| T)
                    32> (|npInfGeneric| (IS ISNT))
                    33> (|npDDInfKey| (IS ISNT))
                    34> (|npInfKey| (IS ISNT))
                    <34 (|npInfKey| NIL)
                    34> (|npState|)
                    <34 (|npState| 
                         (NIL 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1")))
                    34> (|npEqKey| |'|)
                    <34 (|npEqKey| NIL)
                    34> (|npRestore| 
                         (NIL 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1")))
                    35> (|npFirstTok|)
                    36> (|tokPosn|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    37> (|ncAlist|
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <37 (|ncAlist| ((|posn| (0 "1" 1 1 "strings") . 0)))
                    <36 (|tokPosn| ((0 "1" 1 1 "strings") . 0))
                    36> (|tokConstruct| ERROR NOMORE 
                          ((0 "1" 1 1 "strings") . 0))
                    37> (|pfNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    38> (|poNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    <38 (|poNoPosition?| NIL)
                    <37 (|pfNoPosition?| NIL)
                    37> (|ncPutQ| (ERROR . NOMORE) |posn| 
                          ((0 "1" 1 1 "strings") . 0))
                    38> (|ncAlist| (ERROR . NOMORE))
                    <38 (|ncAlist| NIL)
                    38> (|ncAlist| (ERROR . NOMORE))
                    <38 (|ncAlist| NIL)
                    38> (|ncTag| (ERROR . NOMORE))
                    <38 (|ncTag| ERROR)
                    <37 (|ncPutQ| ((0 "1" 1 1 "strings") . 0))
                    <36 (|tokConstruct| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    36> (|tokPart| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <36 (|tokPart| NOMORE)
                    <35 (|npFirstTok| NOMORE)
                    <34 (|npRestore| T)
                    34> (|npEqKey| BACKQUOTE)
                    <34 (|npEqKey| NIL)
                    34> (|npRestore| 
                         (NIL 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1")))
                    35> (|npFirstTok|)
                    36> (|tokPosn| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    37> (|ncAlist| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <37 (|ncAlist| ((|posn| (0 "1" 1 1 "strings") . 0)))
                    <36 (|tokPosn| ((0 "1" 1 1 "strings") . 0))
                    36> (|tokConstruct| ERROR NOMORE 
                          ((0 "1" 1 1 "strings") . 0))
                    37> (|pfNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    38> (|poNoPosition?| ((0 "1" 1 1 "strings") . 0))
                    <38 (|poNoPosition?| NIL)
                    <37 (|pfNoPosition?| NIL)
                    37> (|ncPutQ| (ERROR . NOMORE) |posn| 
                          ((0 "1" 1 1 "strings") . 0))
                    38> (|ncAlist| (ERROR . NOMORE))
                    <38 (|ncAlist| NIL)
                    38> (|ncAlist| (ERROR . NOMORE))
                    <38 (|ncAlist| NIL)
                    38> (|ncTag| (ERROR . NOMORE))
                    <38 (|ncTag| ERROR)
                    <37 (|ncPutQ| ((0 "1" 1 1 "strings") . 0))
                    <36 (|tokConstruct| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    36> (|tokPart| 
                         ((ERROR (|posn| (0 "1" 1 1 "strings") . 0)) . NOMORE))
                    <36 (|tokPart| NOMORE)
                    <35 (|npFirstTok| NOMORE)
                    <34 (|npRestore| T)
                    <33 (|npDDInfKey| NIL)
                    <32 (|npInfGeneric| NIL)
                    <31 (|npLeftAssoc| T)
                    <30 (|npMatch| T)
                    30> (|npPop1|)
                    <30 (|npPop1| 
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1"))
                    30> (|npWith| 
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1"))
                    31> (|npEqKey| WITH)
                    <31 (|npEqKey| NIL)
                    <30 (|npWith| NIL)
                    30> (|npPush| 
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1"))
                    <30 (|npPush| 
                         (((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1")))
                    <29 (|npType|
                         (((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1")))
                    29> (|npPop1|)
                    <29 (|npPop1|
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1"))
                    29> (|npAdd|
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1"))
                    30> (|npEqKey| ADD)
                    <30 (|npEqKey| NIL)
                    <29 (|npAdd| NIL)
                    29> (|npPush|
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1"))
                    <29 (|npPush|
                         (((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1")))
                    <28 (|npADD|
                         (((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                          . "1")))
                    <27 (|npExpress1|
                         (((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                          . "1")))
                    27> (|npIterators|)
                    28> (|npForIn|)
                    29> (|npEqKey| FOR)
                    <29 (|npEqKey| NIL)
                    <28 (|npForIn| NIL)
                    28> (|npWhile|)
                    29> (|npAndOr| WHILE |npLogical| |pfWhile|)
                    30> (|npEqKey| WHILE)
                    <30 (|npEqKey| NIL)
                    <29 (|npAndOr| NIL)
                    <28 (|npWhile| NIL)
                    <27 (|npIterators| NIL)
                    <26 (|npExpress| T)
                    <25 (|npStatement| T)
                    25> (|npEqPeek| MDEF)
                    <25 (|npEqPeek| NIL)
                    <24 (|npBackTrack| T)
                    <23 (|npMDEF| T)
                    23> (|npEqPeek| BECOMES)
                    <23 (|npEqPeek| NIL)
                    <22 (|npBackTrack| T)
                    <21 (|npAssign| T)
                    21> (|npEqPeek| EXIT)
                    <21 (|npEqPeek| NIL)
                    <20 (|npBackTrack| T)
                    <19 (|npExit| T)
                    19> (|npEqPeek| GIVES)
                    <19 (|npEqPeek| NIL)
                    <18 (|npBackTrack| T)
                    <17 (|npGives| T)
                    17> (|npEqPeek| DEF)
                    <17 (|npEqPeek| NIL)
                    <16 (|npBackTrack| T)
                    <15 (|npDefinitionOrStatement| T)
                    15> (|npEqKey| WHERE)
                    <15 (|npEqKey| NIL)
                    <14 (|npQualified| T)
                    <13 (|npQualifiedDefinition| T)
                    13> (|npCommaBackSet|)
                    14> (|npEqKey| COMMA)
                    <14 (|npEqKey| NIL)
                    <13 (|npCommaBackSet| NIL)
                    <12 (|npListofFun| T)
                    <11 (|npTuple| T)
                    <10 (|npComma| T)
                    10> (|npPop1|)
                    <10 (|npPop1|
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                          . "1"))
                    10> (|npPush|
                         (((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1")))
                    <10 (|npPush| 
                         ((((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1"))))
                  <9 (|npQualDef|
                      ((((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                        . "1"))))
                  9> (|npEqKey| SEMICOLON)
                  <9 (|npEqKey| NIL)
                  9> (|npPop1|)
                  <9 (|npPop1|
                      (((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) . "1")))
                  9> (|pfEnSequence| 
                      (((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) . "1")))
                  <9 (|pfEnSequence| 
                      ((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) . "1"))
                  9> (|npPush| 
                      ((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) . "1"))
                  <9 (|npPush| 
                      (((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) . "1")))
                <8 (|npItem| 
                    (((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) . "1")))
              <7 (|npParse| 
                  ((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) . "1"))
            <6 (|ncloopParse| 
                ((((((#0=(0 "1" 1 1 "strings") . 1) . "1"))
                   ((|integer| (|posn| #0# . 0)) . "1")))
                 |nonnullstream| |incAppend1| NIL 
                 (|nonnullstream| |next1| |lineoftoks| (|nullstream|))))
\end{verbatim}

\begin{verbatim}
            6> (|next| |ncloopParse| 
                (|nonnullstream| |incAppend1| NIL 
                 (|nonnullstream| |next1| |lineoftoks| (|nullstream|))))
              7> (|Delay| #0=|next1| 
                  (|ncloopParse| 
                   (|nonnullstream| |incAppend1| NIL 
                    (|nonnullstream| #0# |lineoftoks| (|nullstream|)))))
              <7 (|Delay| 
                  (|nonnullstream| #0=|next1| |ncloopParse| 
                   (|nonnullstream| |incAppend1| NIL 
                    (|nonnullstream| #0# |lineoftoks| (|nullstream|)))))
            <6 (|next| 
                (|nonnullstream| #0=|next1| |ncloopParse| 
                 (|nonnullstream| |incAppend1| NIL 
                  (|nonnullstream| #0# |lineoftoks| (|nullstream|)))))
\end{verbatim}

\begin{verbatim}
            6> (|incAppend| 
                (((((#0=(0 "1" 1 1 "strings") . 1) . "1")) 
                   ((|integer| (|posn| #0# . 0)) . "1"))) 
                 (|nonnullstream| #1=|next1| |ncloopParse| 
                  (|nonnullstream| |incAppend1| NIL 
                   (|nonnullstream| #1# |lineoftoks| (|nullstream|)))))
              7> (|Delay| #0=|incAppend1| 
                  ((((((#2=(0 "1" 1 1 "strings") . 1) . "1")) 
                      ((|integer| (|posn| #2# . 0)) . "1")))
                     (|nonnullstream| #3=|next1| |ncloopParse| 
                      (|nonnullstream| #0# NIL 
                       (|nonnullstream| #3# |lineoftoks| (|nullstream|))))))
              <7 (|Delay| 
                  (|nonnullstream| #0=|incAppend1| 
                   (((((#2=(0 "1" 1 1 "strings") . 1) . "1")) 
                      ((|integer| (|posn| #2# . 0)) . "1")))
                     (|nonnullstream| #3=|next1| |ncloopParse|
                      (|nonnullstream| #0# NIL
                       (|nonnullstream| #3# |lineoftoks| (|nullstream|))))))
            <6 (|incAppend|
                (|nonnullstream| #0=|incAppend1|
                 (((((#2=(0 "1" 1 1 "strings") . 1) . "1"))
                    ((|integer| (|posn| #2# . 0)) . "1")))
                   (|nonnullstream| #3=|next1| |ncloopParse|
                    (|nonnullstream| #0# NIL
                     (|nonnullstream| #3# |lineoftoks| (|nullstream|))))))
          <5 (|next1|
              (|nonnullstream| #0=|incAppend1|
               (((((#2=(0 "1" 1 1 "strings") . 1) . "1"))
                  ((|integer| (|posn| #2# . 0)) . "1")))
                 (|nonnullstream| #3=|next1| |ncloopParse|
                  (|nonnullstream| #0# NIL
                   (|nonnullstream| #3# |lineoftoks| (|nullstream|))))))
\end{verbatim}

\begin{verbatim}
          5> (|incAppend1|
              (((((#0=(0 "1" 1 1 "strings") . 1) . "1"))
                 ((|integer| (|posn| #0# . 0)) . "1")))
                (|nonnullstream| #1=|next1| |ncloopParse|
                 (|nonnullstream| |incAppend1| NIL
                  (|nonnullstream| #1# |lineoftoks| (|nullstream|)))))
            6> (|StreamNull|
                (((((#0=(0 "1" 1 1 "strings") . 1) . "1"))
                   ((|integer| (|posn| #0# . 0)) . "1"))))
            <6 (|StreamNull| NIL)
            6> (|incAppend| NIL
                (|nonnullstream| #0=|next1| |ncloopParse|
                 (|nonnullstream| |incAppend1| NIL
                  (|nonnullstream| #0# |lineoftoks| (|nullstream|)))))
              7> (|Delay| #0=|incAppend1|
                  (NIL
                   (|nonnullstream| #2=|next1| |ncloopParse|
                    (|nonnullstream| #0# NIL
                     (|nonnullstream| #2# |lineoftoks| (|nullstream|))))))
              <7 (|Delay|
                  (|nonnullstream| #0=|incAppend1| NIL
                   (|nonnullstream| #2=|next1| |ncloopParse|
                    (|nonnullstream| #0# NIL
                     (|nonnullstream| #2# |lineoftoks| (|nullstream|))))))
            <6 (|incAppend|
                (|nonnullstream| #0=|incAppend1| NIL
                 (|nonnullstream| #2=|next1| |ncloopParse|
                  (|nonnullstream| #0# NIL
                   (|nonnullstream| #2# |lineoftoks| (|nullstream|))))))
          <5 (|incAppend1|
              (((((#0=(0 "1" 1 1 "strings") . 1) . "1"))
                ((|integer| (|posn| #0# . 0)) . "1"))
                |nonnullstream| #1=|incAppend1| NIL 
                (|nonnullstream| #3=|next1| |ncloopParse| 
                 (|nonnullstream| #1# NIL 
                  (|nonnullstream| #3# |lineoftoks| (|nullstream|))))))
        <4 (|StreamNull| NIL)
\end{verbatim}

\begin{verbatim}
        4> (|pfAbSynOp?|
            ((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) . "1") |command|)
        <4 (|pfAbSynOp?| NIL)
\end{verbatim}

\begin{verbatim}
        4> (|intloopSpadProcess| 1 
            (((#0=(0 "1" 1 1 "strings") . 1) . "1")) 
             ((|integer| (|posn| #0# . 0)) . "1") T)
          5> (|ncPutQ| (|carrier|) |stepNumber| 1)
            6> (|ncAlist| (|carrier|))
            <6 (|ncAlist| NIL)
            6> (|ncAlist| (|carrier|))
            <6 (|ncAlist| NIL)
            6> (|ncTag| (|carrier|))
            <6 (|ncTag| |carrier|)
          <5 (|ncPutQ| 1)
          5> (|ncPutQ| ((|carrier| (|stepNumber| . 1))) |messages| NIL)
            6> (|ncAlist| ((|carrier| (|stepNumber| . 1))))
            <6 (|ncAlist| ((|stepNumber| . 1)))
            6> (|ncAlist| ((|carrier| (|stepNumber| . 1))))
            <6 (|ncAlist| ((|stepNumber| . 1)))
            6> (|ncTag| ((|carrier| (|stepNumber| . 1))))
            <6 (|ncTag| |carrier|)
          <5 (|ncPutQ| NIL)
          5> (|ncPutQ|
              ((|carrier| (|messages|) (|stepNumber| . 1))) 
              |lines| ((((0 "1" 1 1 "strings") . 1) . "1")))
            6> (|ncAlist| ((|carrier| (|messages|) (|stepNumber| . 1))))
            <6 (|ncAlist| ((|messages|) (|stepNumber| . 1)))
            6> (|ncAlist| ((|carrier| (|messages|) (|stepNumber| . 1))))
            <6 (|ncAlist| ((|messages|) (|stepNumber| . 1)))
            6> (|ncTag| ((|carrier| (|messages|) (|stepNumber| . 1))))
            <6 (|ncTag| |carrier|)
          <5 (|ncPutQ| ((((0 "1" 1 1 "strings") . 1) . "1")))
          5> (|intloopSpadProcess,interp| 
              ((|carrier| (|lines| ((#0=(0 "1" 1 1 "strings") . 1) . "1"))
                          (|messages|) (|stepNumber| . 1)))
              ((|integer| (|posn| #0# . 0)) . "1") T)
            6> (|ncConversationPhase| |phParse| 
                (((|carrier| (|lines| ((#0=(0 "1" 1 1 "strings") . 1) . "1"))
                           (|messages|) (|stepNumber| . 1)))
                 ((|integer| (|posn| #0# . 0)) . "1")))
              7> (|phParse|
                  ((|carrier| (|lines| ((#0=(0 "1" 1 1 "strings") . 1) . "1"))
                           (|messages|) (|stepNumber| . 1)))
                   ((|integer| (|posn| #0# . 0)) . "1"))
                8> (|ncPutQ| 
                    ((|carrier| (|lines| ((#0=(0 "1" 1 1 "strings") . 1) . "1")
                         ) (|messages|) (|stepNumber| . 1)))
                     |ptree| ((|integer| (|posn| #0# . 0)) . "1"))
                  9> (|ncAlist|
                      ((|carrier| (|lines| (((0 "1" 1 1 "strings") . 1) . "1"))
                             (|messages|) (|stepNumber| . 1))))
                  <9 (|ncAlist|
                      ((|lines| (((0 "1" 1 1 "strings") . 1) . "1")) 
                         (|messages|) (|stepNumber| . 1)))
                  9> (|ncAlist| 
                      ((|carrier| (|lines| (((0 "1" 1 1 "strings") . 1) . "1"))
                        (|messages|) (|stepNumber| . 1))))
                  <9 (|ncAlist| 
                      ((|lines| (((0 "1" 1 1 "strings") . 1) . "1"))
                        (|messages|) (|stepNumber| . 1)))
                  9> (|ncTag|
                      ((|carrier| (|lines| (((0 "1" 1 1 "strings") . 1) . "1"))
                       (|messages|) (|stepNumber| . 1))))
                  <9 (|ncTag| |carrier|)
                <8 (|ncPutQ| 
                     ((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) . "1"))
              <7 (|phParse| OK)
              7> (|ncConversationPhase,wrapup|
                  ((|carrier| 
                    (|ptree| 
                     (|integer| (|posn| #0=(0 "1" 1 1 "strings") . 0))
                      . "1")
                    (|lines| ((#0# . 1) . "1"))
                    (|messages|)
                    (|stepNumber| . 1))))
              <7 (|ncConversationPhase,wrapup| NIL)
            <6 (|ncConversationPhase| OK)
            6> (|ncConversationPhase| |phMacro| 
                (((|carrier| 
                   (|ptree| 
                    (|integer| (|posn| #0=(0 "1" 1 1 "strings") . 0)) . "1") 
                    (|lines| ((#0# . 1) . "1"))
                    (|messages|) 
                    (|stepNumber| . 1)))))
              7> (|phMacro|
                  ((|carrier| 
                    (|ptree| 
                     (|integer| (|posn| #0=(0 "1" 1 1 "strings") . 0)) . "1")
                    (|lines| ((#0# . 1) . "1"))
                    (|messages|)
                    (|stepNumber| . 1))))
                8> (|ncEltQ| 
                    ((|carrier| 
                      (|ptree| 
                       (|integer| (|posn| #0=(0 "1" 1 1 "strings") . 0)) . "1")
                       (|lines| ((#0# . 1) . "1"))
                       (|messages|)
                       (|stepNumber| . 1))) |ptree|)
                  9> (|ncAlist|
                      ((|carrier| 
                       (|ptree| 
                        (|integer| (|posn| #0=(0 "1" 1 1 "strings") . 0))
                            . "1") 
                        (|lines| ((#0# . 1) . "1")) 
                        (|messages|) 
                        (|stepNumber| . 1))))
                  <9 (|ncAlist|
                      ((|ptree| 
                        (|integer| (|posn| #0=(0 "1" 1 1 "strings") . 0))
                           . "1") 
                        (|lines| ((#0# . 1) . "1")) 
                        (|messages|) 
                        (|stepNumber| . 1)))
                <8 (|ncEltQ|
                     ((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) . "1"))
                8> (|ncPutQ|
                    ((|carrier| 
                      (|ptree| .
                         #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                            . "1")) 
                      (|lines| ((#1# . 1) . "1")) 
                      (|messages|) 
                      (|stepNumber| . 1)))
                     |ptreePremacro| #0#)
                  9> (|ncAlist|
                      ((|carrier|
                       (|ptree|
                        (|integer| (|posn| #0=(0 "1" 1 1 "strings") . 0))
                           . "1") 
                        (|lines| ((#0# . 1) . "1")) 
                        (|messages|) 
                        (|stepNumber| . 1))))
                  <9 (|ncAlist| 
                      ((|ptree| 
                        (|integer| (|posn| #0=(0 "1" 1 1 "strings") . 0))
                          . "1") 
                        (|lines| ((#0# . 1) . "1")) 
                        (|messages|) 
                        (|stepNumber| . 1)))
                  9> (|ncAlist|
                      ((|carrier| 
                       (|ptree| 
                        (|integer| (|posn| #0=(0 "1" 1 1 "strings") . 0))
                          . "1") 
                        (|lines| ((#0# . 1) . "1")) 
                        (|messages|) 
                        (|stepNumber| . 1))))
                  <9 (|ncAlist|
                      ((|ptree| 
                       (|integer| (|posn| #0=(0 "1" 1 1 "strings") . 0)) . "1")
                       (|lines| ((#0# . 1) . "1")) 
                       (|messages|) 
                       (|stepNumber| . 1)))
                  9> (|ncTag|
                      ((|carrier|
                       (|ptree|
                        (|integer| (|posn| #0=(0 "1" 1 1 "strings") . 0))
                          . "1") 
                        (|lines| ((#0# . 1) . "1")) 
                        (|messages|) 
                        (|stepNumber| . 1))))
                  <9 (|ncTag| |carrier|)
                <8 (|ncPutQ|
                     ((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) . "1"))
                8> (|macroExpanded| 
                    ((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) . "1"))
                  9> (|macExpand| 
                      ((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) . "1"))
                    10> (|pfWhere?| 
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1"))
                    11> (|pfAbSynOp?|
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1") |Where|)
                    <11 (|pfAbSynOp?| NIL)
                    <10 (|pfWhere?| NIL)
                    10> (|pfLambda?| 
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1"))
                    11> (|pfAbSynOp?| 
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1") |Lambda|)
                    <11 (|pfAbSynOp?| NIL)
                    <10 (|pfLambda?| NIL)
                    10> (|pfMacro?| 
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1"))
                    11> (|pfAbSynOp?| 
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1") |Macro|)
                    <11 (|pfAbSynOp?| NIL)
                    <10 (|pfMacro?| NIL)
                    10> (|pfId?| 
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) 
                           . "1"))
                    11> (|pfAbSynOp?|
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1") |id|)
                    <11 (|pfAbSynOp?| NIL)
                    11> (|pfAbSynOp?|
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1") |idsy|)
                    <11 (|pfAbSynOp?| NIL)
                    <10 (|pfId?| NIL)
                    10> (|pfApplication?|
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1"))
                    11> (|pfAbSynOp?|
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1") |Application|)
                    <11 (|pfAbSynOp?| NIL)
                    <10 (|pfApplication?| NIL)
                    10> (|pfMapParts| |macExpand|
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) 
                           . "1"))
                    11> (|pfLeaf?|
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1"))
                    12> (|pfAbSynOp|
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1"))
                    <12 (|pfAbSynOp| |integer|)
                    <11 (|pfLeaf?| (|integer| |Document| |error|))
                    <10 (|pfMapParts|
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1"))
                  <9 (|macExpand| 
                      ((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) . "1"))
                <8 (|macroExpanded| 
                    ((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) . "1"))
                8> (|ncPutQ| 
                    ((|carrier| 
                      (|ptreePremacro| . 
                       #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                            . "1")) 
                      (|ptree| . #0#) 
                      (|lines| ((#1# . 1) . "1")) 
                      (|messages|) 
                      (|stepNumber| . 1))) |ptree| #0#)
                  9> (|ncAlist| 
                      ((|carrier| 
                       (|ptreePremacro| . 
                         #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                          . "1")) 
                       (|ptree| . #0#) 
                       (|lines| ((#1# . 1) . "1")) 
                       (|messages|) 
                       (|stepNumber| . 1))))
                  <9 (|ncAlist|
                      ((|ptreePremacro| . 
                       #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                            . "1")) 
                      (|ptree| . #0#) 
                      (|lines| ((#1# . 1) . "1")) 
                      (|messages|) 
                      (|stepNumber| . 1)))
                <8 (|ncPutQ|
                    ((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) . "1"))
              <7 (|phMacro| OK)
              7> (|ncConversationPhase,wrapup| 
                  ((|carrier| 
                   (|ptreePremacro| . 
                     #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                       . "1")) 
                   (|ptree| . #0#) 
                   (|lines| ((#1# . 1) . "1")) 
                   (|messages|) 
                   (|stepNumber| . 1))))
              <7 (|ncConversationPhase,wrapup| NIL)
            <6 (|ncConversationPhase| OK)
            6> (|ncConversationPhase| |phIntReportMsgs| 
                (((|carrier| 
                   (|ptreePremacro| . 
                    #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0)) 
                         . "1")) 
                   (|ptree| . #0#) 
                   (|lines| ((#1# . 1) . "1")) 
                   (|messages|) 
                   (|stepNumber| . 1))) T))
              7> (|phIntReportMsgs| 
                  ((|carrier| 
                    (|ptreePremacro| . 
                     #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                          . "1")) 
                    (|ptree| . #0#) 
                    (|lines| ((#1# . 1) . "1")) 
                    (|messages|) 
                    (|stepNumber| . 1))) T)
                8> (|ncEltQ|
                    ((|carrier| 
                      (|ptreePremacro| . 
                        #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                             . "1")) 
                      (|ptree| . #0#) 
                      (|lines| ((#1# . 1) . "1")) 
                      (|messages|) 
                      (|stepNumber| . 1))) |lines|)
                  9> (|ncAlist| 
                      ((|carrier| 
                        (|ptreePremacro| . 
                         #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                           . "1")) 
                        (|ptree| . #0#) 
                        (|lines| ((#1# . 1) . "1")) 
                        (|messages|) 
                        (|stepNumber| . 1))))
                  <9 (|ncAlist|
                      ((|ptreePremacro| . 
                        #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                             . "1")) 
                       (|ptree| . #0#) 
                       (|lines| ((#1# . 1) . "1")) 
                       (|messages|) 
                       (|stepNumber| . 1)))
                <8 (|ncEltQ| ((((0 "1" 1 1 "strings") . 1) . "1")))
                8> (|ncEltQ| 
                    ((|carrier| (|ptreePremacro| . 
                     #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0)) .
                           "1")) 
                     (|ptree| . #0#) 
                     (|lines| ((#1# . 1) . "1")) 
                     (|messages|) 
                     (|stepNumber| . 1))) 
                     |messages|)
                  9> (|ncAlist| 
                      ((|carrier| 
                       (|ptreePremacro| . 
                         #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                             . "1")) 
                       (|ptree| . #0#) 
                       (|lines| ((#1# . 1) . "1")) 
                       (|messages|) 
                       (|stepNumber| . 1))))
                  <9 (|ncAlist| 
                      ((|ptreePremacro| . 
                       #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                          . "1")) 
                       (|ptree| . #0#) 
                       (|lines| ((#1# . 1) . "1")) 
                       (|messages|) 
                       (|stepNumber| . 1)))
                <8 (|ncEltQ| NIL)
                8> (|ncPutQ| 
                    ((|carrier| 
                     (|ptreePremacro| . 
                      #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                           . "1")) 
                     (|ptree| . #0#) 
                     (|lines| ((#1# . 1) . "1")) 
                     (|messages|) 
                     (|stepNumber| . 1))) |ok?| T)
                  9> (|ncAlist| 
                      ((|carrier| 
                       (|ptreePremacro| . 
                        #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                           . "1")) 
                       (|ptree| . #0#) 
                       (|lines| ((#1# . 1) . "1")) 
                       (|messages|) 
                       (|stepNumber| . 1))))
                  <9 (|ncAlist| 
                      ((|ptreePremacro| .
                        #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                             . "1")) 
                       (|ptree| . #0#) 
                       (|lines| ((#1# . 1) . "1")) 
                       (|messages|) 
                       (|stepNumber| . 1)))
                  9> (|ncAlist| 
                      ((|carrier| 
                       (|ptreePremacro| .
                         #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                             . "1")) 
                       (|ptree| . #0#) 
                       (|lines| ((#1# . 1) . "1")) 
                       (|messages|) 
                       (|stepNumber| . 1))))
                  <9 (|ncAlist|
                      ((|ptreePremacro| . 
                        #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                            . "1")) 
                       (|ptree| . #0#) 
                       (|lines| ((#1# . 1) . "1")) 
                       (|messages|) 
                       (|stepNumber| . 1)))
                  9> (|ncTag|
                      ((|carrier| 
                       (|ptreePremacro| .
                         #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                              . "1")) 
                       (|ptree| . #0#) 
                       (|lines| ((#1# . 1) . "1")) 
                       (|messages|) 
                       (|stepNumber| . 1))))
                  <9 (|ncTag| |carrier|)
                <8 (|ncPutQ| T)
              <7 (|phIntReportMsgs| OK)
              7> (|ncConversationPhase,wrapup| 
                  ((|carrier| 
                    (|ok?| . T) 
                    (|ptreePremacro| . 
                      #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                           . "1"))
                    (|ptree| . #0#)
                    (|lines| ((#1# . 1) . "1"))
                    (|messages|)
                    (|stepNumber| . 1))))
              <7 (|ncConversationPhase,wrapup| NIL)
            <6 (|ncConversationPhase| OK)
            6> (|ncConversationPhase| |phInterpret| 
                (((|carrier|
                  (|ok?| . T)
                  (|ptreePremacro| . 
                   #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                         . "1"))
                  (|ptree| . #0#)
                  (|lines| ((#1# . 1) . "1"))
                  (|messages|)
                  (|stepNumber| . 1)))))
              7> (|phInterpret|
                  ((|carrier|
                   (|ok?| . T)
                   (|ptreePremacro| . 
                    #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                          . "1"))
                   (|ptree| . #0#)
                   (|lines| ((#1# . 1) . "1"))
                   (|messages|)
                   (|stepNumber| . 1))))
                8> (|ncEltQ| 
                    ((|carrier| 
                     (|ok?| . T)
                     (|ptreePremacro| . 
                      #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                           . "1"))
                     (|ptree| . #0#)
                     (|lines| ((#1# . 1) . "1"))
                     (|messages|)
                     (|stepNumber| . 1)))
                    |ptree|)
                  9> (|ncAlist| 
                      ((|carrier|
                       (|ok?| . T)
                       (|ptreePremacro| . 
                        #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                              . "1"))
                       (|ptree| . #0#)
                       (|lines| ((#1# . 1) . "1"))
                       (|messages|)
                       (|stepNumber| . 1))))
                  <9 (|ncAlist|
                      ((|ok?| . T)
                       (|ptreePremacro| . 
                        #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                             . "1"))
                       (|ptree| . #0#)
                       (|lines| ((#1# . 1) . "1"))
                       (|messages|)
                       (|stepNumber| . 1)))
                <8 (|ncEltQ|
                    ((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) . "1"))
                8> (|intInterpretPform|
                    ((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) . "1"))
                  9> (|pf2Sex|
                      ((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) . "1"))
                    10> (|pf2Sex1|
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                             . "1"))
                    11> (|pfNothing?|
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1"))
                    12> (|pfAbSynOp?|
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1") |nothing|)
                    <12 (|pfAbSynOp?| NIL)
                    <11 (|pfNothing?| NIL)
                    11> (|pfSymbol?|
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1"))
                    12> (|pfAbSynOp?|
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1") |symbol|)
                    <12 (|pfAbSynOp?| NIL)
                    <11 (|pfSymbol?| NIL)
                    11> (|pfLiteral?|
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1"))
                    12> (|pfAbSynOp|
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1"))
                    <12 (|pfAbSynOp| |integer|)
                    <11 (|pfLiteral?|
                         (|integer| |symbol| |expression| |one| |zero| 
                          |char| |string| |float|))
                    11> (|pfLiteral2Sex|
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1"))
                    12> (|pfLiteralClass|
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1"))
                    13> (|pfAbSynOp|
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1"))
                    <13 (|pfAbSynOp| |integer|)
                    <12 (|pfLiteralClass| |integer|)
                    12> (|pfLiteralString|
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                           . "1"))
                    13> (|tokPart| 
                         ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                            . "1"))
                    <13 (|tokPart| "1")
                    <12 (|pfLiteralString| "1")
                    <11 (|pfLiteral2Sex| 1)
                    <10 (|pf2Sex1| 1)
                  <9 (|pf2Sex| 1)
                  9> (|zeroOneTran| 1)
                  <9 (|zeroOneTran| 1)
                  9> (|processInteractive| 1 
                      ((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) . "1"))
                    10> (PUT |algebra| |TimeTotal| 0.0)
                    <10 (PUT 0.0)
                    10> (PUT |algebra| |SpaceTotal| 0)
                    <10 (PUT 0)
                    10> (PUT |analysis| |TimeTotal| 0.0)
                    <10 (PUT 0.0)
                    10> (PUT |analysis| |SpaceTotal| 0)
                    <10 (PUT 0)
                    10> (PUT |coercion| |TimeTotal| 0.0)
                    <10 (PUT 0.0)
                    10> (PUT |coercion| |SpaceTotal| 0)
                    <10 (PUT 0)
                    10> (PUT |compilation| |TimeTotal| 0.0)
                    <10 (PUT 0.0)
                    10> (PUT |compilation| |SpaceTotal| 0)
                    <10 (PUT 0)
                    10> (PUT |debug| |TimeTotal| 0.0)
                    <10 (PUT 0.0)
                    10> (PUT |debug| |SpaceTotal| 0)
                    <10 (PUT 0)
                    10> (PUT |evaluation| |TimeTotal| 0.0)
                    <10 (PUT 0.0)
                    10> (PUT |evaluation| |SpaceTotal| 0)
                    <10 (PUT 0)
                    10> (PUT |gc| |TimeTotal| 0.0)
                    <10 (PUT 0.0)
                    10> (PUT |gc| |SpaceTotal| 0)
                    <10 (PUT 0)
                    10> (PUT |history| |TimeTotal| 0.0)
                    <10 (PUT 0.0)
                    10> (PUT |history| |SpaceTotal| 0)
                    <10 (PUT 0)
                    10> (PUT |instantiation| |TimeTotal| 0.0)
                    <10 (PUT 0.0)
                    10> (PUT |instantiation| |SpaceTotal| 0)
                    <10 (PUT 0)
                    10> (PUT |load| |TimeTotal| 0.0)
                    <10 (PUT 0.0)
                    10> (PUT |load| |SpaceTotal| 0)
                    <10 (PUT 0)
                    10> (PUT |modemaps| |TimeTotal| 0.0)
                    <10 (PUT 0.0)
                    10> (PUT |modemaps| |SpaceTotal| 0)
                    <10 (PUT 0)
                    10> (PUT |optimization| |TimeTotal| 0.0)
                    <10 (PUT 0.0)
                    10> (PUT |optimization| |SpaceTotal| 0)
                    <10 (PUT 0)
                    10> (PUT |querycoerce| |TimeTotal| 0.0)
                    <10 (PUT 0.0)
                    10> (PUT |querycoerce| |SpaceTotal| 0)
                    <10 (PUT 0)
                    10> (PUT |other| |TimeTotal| 0.0)
                    <10 (PUT 0.0)
                    10> (PUT |other| |SpaceTotal| 0)
                    <10 (PUT 0)
                    10> (PUT |diskread| |TimeTotal| 0.0)
                    <10 (PUT 0.0)
                    10> (PUT |diskread| |SpaceTotal| 0)
                    <10 (PUT 0)
                    10> (PUT |print| |TimeTotal| 0.0)
                    <10 (PUT 0.0)
                    10> (PUT |print| |SpaceTotal| 0)
                    <10 (PUT 0)
                    10> (PUT |resolve| |TimeTotal| 0.0)
                    <10 (PUT 0.0)
                    10> (PUT |resolve| |SpaceTotal| 0)
                    <10 (PUT 0)
                    10> (PUT |interpreter| |ClassTimeTotal| 0.0)
                    <10 (PUT 0.0)
                    10> (PUT |interpreter| |ClassSpaceTotal| 0)
                    <10 (PUT 0)
                    10> (PUT |evaluation| |ClassTimeTotal| 0.0)
                    <10 (PUT 0.0)
                    10> (PUT |evaluation| |ClassSpaceTotal| 0)
                    <10 (PUT 0)
                    10> (PUT |other| |ClassTimeTotal| 0.0)
                    <10 (PUT 0.0)
                    10> (PUT |other| |ClassSpaceTotal| 0)
                    <10 (PUT 0)
                    10> (PUT |reclaim| |ClassTimeTotal| 0.0)
                    <10 (PUT 0.0)
                    10> (PUT |reclaim| |ClassSpaceTotal| 0)
                    <10 (PUT 0)
                    10> (GETL |gc| |TimeTotal|)
                    <10 (GETL 0.0)
                    10> (PUT |gc| |TimeTotal| 0.050000000000000003)
                    <10 (PUT 0.050000000000000003)
                    10> (PUT |gc| |TimeTotal| 0.0)
                    <10 (PUT 0.0)
                    10> (PUT |gc| |SpaceTotal| 0)
                    <10 (PUT 0)
                    10> (|processInteractive1| 1 
                        ((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) . "1"))
                    11> (recordFrame |system|)
                    12> (|diffAlist| NIL NIL)
                    <12 (|diffAlist| NIL)
                    <11 (recordFrame NIL)
                    11> (GETL |other| |TimeTotal|)
                    <11 (GETL 0.0)
                    11> (GETL |gc| |TimeTotal|)
                    <11 (GETL 0.0)
                    11> (PUT |gc| |TimeTotal| 0.0)
                    <11 (PUT 0.0)
                    11> (PUT |other| |TimeTotal| 0.0)
                    <11 (PUT 0.0)
                    11> (|interpretTopLevel| 1 
                        ((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) . "1"))
                    12> (|interpret| 1 
                        ((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) . "1"))
                    13> (|interpret1| 1 NIL 
                        ((|integer| (|posn| (0 "1" 1 1 "strings") . 0)) . "1"))
                    14> (|member| 1 (|noBranch| |noMapVal|))
                    <14 (|member| NIL)
                    14> (|member| 1 (|nil| |true| |false|))
                    <14 (|member| NIL)
                    14> (|member| |--immediateData--| NIL)
                    <14 (|member| NIL)
                    14> (|isDomainValuedVariable| |--immediateData--|)
                    <14 (|isDomainValuedVariable| NIL)
                    14> (GETDATABASE |--immediateData--| CONSTRUCTOR)
                    <14 (GETDATABASE NIL)
                    14> (GETDATABASE |--immediateData--| ABBREVIATION)
                    <14 (GETDATABASE NIL)
                    14> (|member| |--immediateData--| 
                         (|Record| |Union| |Enumeration|))
                    <14 (|member| NIL)
                    14> (|getProplist| |--immediateData--| ((NIL)))
                    15> (|search| |--immediateData--| ((NIL)))
                    16> (|searchCurrentEnv| |--immediateData--| (NIL))
                    <16 (|searchCurrentEnv| NIL)
                    16> (|searchTailEnv| |--immediateData--| NIL)
                    <16 (|searchTailEnv| NIL)
                    <15 (|search| NIL)
                    15> (|search| |--immediateData--| 
                         ((((|Category| 
                             (|modemap| (((|Category|) (|Category|)) (T *))))
                            (|Join| 
                             (|modemap| 
                              (((|Category|)
                                (|Category|)
                                (|Category|)
                                (|Category|))
                               (T *))
                              (((|Category|)
                                (|Category|)
                                (|List| (|Category|))
                                (|Category|))
                               (T *))))))))
                    16> (|searchCurrentEnv| |--immediateData--|
                          (((|Category|
                             (|modemap| (((|Category|) (|Category|)) (T *))))
                            (|Join|
                             (|modemap|
                              (((|Category|)
                                (|Category|)
                                (|Category|)
                                (|Category|))
                               (T *))
                              (((|Category|)
                                (|Category|)
                                (|List| (|Category|))
                                (|Category|))
                               (T *)))))))
                    <16 (|searchCurrentEnv| NIL)
                    16> (|searchTailEnv| |--immediateData--| NIL)
                    <16 (|searchTailEnv| NIL)
                    <15 (|search| NIL)
                    <14 (|getProplist| NIL)
                    14> (|member| |--immediateData--| NIL)
                    <14 (|member| NIL)
                    14> (|member| |--immediateData--| NIL)
                    <14 (|member| NIL)
                    14> (|member| |--immediateData--| NIL)
                    <14 (|member| NIL)
                    14> (|member| |--immediateData--| NIL)
                    <14 (|member| NIL)
                    14> (|member| |--immediateData--| NIL)
                    <14 (|member| NIL)
                    14> (|interpret2|
                         (#0=(|PositiveInteger|) . 1) #0# 
                          ((|integer| (|posn| (0 "1" 1 1 "strings") . 0))
                             . "1"))
                    <14 (|interpret2| ((|PositiveInteger|) . 1))
                    <13 (|interpret1| ((|PositiveInteger|) . 1))
                    <12 (|interpret| ((|PositiveInteger|) . 1))
                    <11 (|interpretTopLevel| ((|PositiveInteger|) . 1))
                    11> (GETL |analysis| |TimeTotal|)
                    <11 (GETL 0.0)
                    11> (GETL |gc| |TimeTotal|)
                    <11 (GETL 0.0)
                    11> (PUT |gc| |TimeTotal| 0.0)
                    <11 (PUT 0.0)
                    11> (PUT |analysis| |TimeTotal| 0.0)
                    <11 (PUT 0.0)
                    11> (GETL |other| |TimeTotal|)
                    <11 (GETL 0.0)
                    11> (GETL |gc| |TimeTotal|)
                    <11 (GETL 0.0)
                    11> (PUT |gc| |TimeTotal| 0.0)
                    <11 (PUT 0.0)
                    11> (PUT |other| |TimeTotal| 0.0)
                    <11 (PUT 0.0)
                    11> (|recordAndPrint| 1 (|PositiveInteger|))

                    12> (GETDATABASE |PositiveInteger| CONSTRUCTORKIND)
                    <12 (GETDATABASE |domain|)
                    12> (|member| (|PositiveInteger|) 
                          ((|Mode|) (|Domain|) (|SubDomain| (|Domain|))))
                    <12 (|member| NIL)
                    12> (|member| (|PositiveInteger|)
                          ((|Category|) (|Mode|) (|Domain|) 
                           (|SubDomain| (|Domain|))))
                    <12 (|member| NIL)
                    12> (GETL |print| |TimeTotal|)
                    <12 (GETL 0.0)
                    12> (GETL |gc| |TimeTotal|)
                    <12 (GETL 0.0)
                    12> (PUT |gc| |TimeTotal| 0.0)
                    <12 (PUT 0.0)
                    12> (PUT |print| |TimeTotal| 0.0)
                    <12 (PUT 0.0)
                    12> (|isEqualOrSubDomain| (|PositiveInteger|) 
                                              (|OutputForm|))
                    <12 (|isEqualOrSubDomain| NIL)
                    12> (GETDATABASE |OutputForm| ABBREVIATION)
                    <12 (GETDATABASE OUTFORM)
                    12> (HPUT #<hash-table 0000000001ab1e40> 
                         (|OutputForm|) (1))
                    <12 (HPUT (1))
                    12> (HPUT #<hash-table 0000000001ab1ea0> 
                         (NIL NIL NIL) (1 . T))
                    <12 (HPUT (1 . T))
                    12> (HPUT #<hash-table 0000000001ab1ea0> 
                         (#0=(|OutputForm|) NIL NIL) (1 . #0#))
                    <12 (HPUT (1 |OutputForm|))
                    12> (HPUT #<hash-table 0000000001ab1e40> 
                         (|PositiveInteger|) (1))
                    <12 (HPUT (1))
                    12> (|member| (|OutputForm|) ((|Integer|) (|OutputForm|)))
                    <12 (|member| ((|OutputForm|)))
                    12> (|member| (|OutputForm|) 
                          ((|Mode|) (|Domain|) (|SubDomain| (|Domain|))))
                    <12 (|member| NIL)
                    12> (GETDATABASE |OutputForm| ABBREVIATION)
                    <12 (GETDATABASE OUTFORM)
                    12> (GETDATABASE |OutputForm| COSIG)
                    <12 (GETDATABASE (NIL))
                    12> (HPUT #<hash-table 0000000001ab1840> 
                         (|OutputForm|) (1 . T))
                    <12 (HPUT (1 . T))
                    12> (|isPartialMode| (|OutputForm|))
                    <12 (|isPartialMode| NIL)
                    12> (|member| |coerce| (= + * -))
                    <12 (|member| NIL)
                    12> (|isPartialMode| (|OutputForm|))
                    <12 (|isPartialMode| NIL)
                    12> (|member| |PositiveInteger| 
                         (|List| |Vector| |Stream| |FiniteSet| |Array|))
                    <12 (|member| NIL)
                    12> (|member| |PositiveInteger| 
                         (|Union| |Record| |Mapping| |Enumeration|))
                    <12 (|member| NIL)
                    12> (GETDATABASE |PositiveInteger| OPERATIONALIST)
                    <12 (GETDATABASE 
                         ((~= (((|Boolean|) $ $) NIL))
                          (|sample| (($) NIL T CONST))
                          (|recip| (((|Union| $ "failed") $) NIL))
                          (|one?| (((|Boolean|) $) NIL))
                          (|min| (($ $ $) NIL))
                          (|max| (($ $ $) NIL))
                          (|latex| (((|String|) $) NIL))
                          (|hash| (((|SingleInteger|) $) NIL))
                          (|gcd| (($ $ $) NIL))
                          (|coerce| (((|OutputForm|) $) NIL))
                          (^ (($ $ (|NonNegativeInteger|)) NIL) 
                             (($ $ (|PositiveInteger|)) NIL))
                          (|One| (($) NIL T CONST))
                          (>= (((|Boolean|) $ $) NIL))
                          (> (((|Boolean|) $ $) NIL))
                          (= (((|Boolean|) $ $) NIL))
                          (<= (((|Boolean|) $ $) NIL))
                          (< (((|Boolean|) $ $) NIL))
                          (+ (($ $ $) NIL))
                          (** (($ $ (|NonNegativeInteger|)) NIL) 
                              (($ $ (|PositiveInteger|)) NIL))
                          (* (($ (|PositiveInteger|) $) NIL) (($ $ $) NIL))))
                    12> (|constructSubst| (|PositiveInteger|))
                    <12 (|constructSubst| (($ |PositiveInteger|)))
                    12> (|isEqualOrSubDomain| #0=(|PositiveInteger|) #0#)
                    <12 (|isEqualOrSubDomain| T)
                    12> (|isEqualOrSubDomain| (|OutputForm|) (|OutputForm|))
                    <12 (|isEqualOrSubDomain| T)
                    12> (|member| |OutputForm| (|Union| |Record| |Mapping| |Enumeration|))
                    <12 (|member| NIL)
                    12> (GETDATABASE |OutputForm| OPERATIONALIST)
                    <12 (GETDATABASE 
                         ((~= (((|Boolean|) $ $) NIL))
                          (|zag| (($ $ $) 120))
                          (|width| (((|Integer|) $) 30) (((|Integer|)) 35))
                          (|vspace| (($ (|Integer|)) 47))
                          (|vconcat| (($ $ $) 48) (($ (|List| $)) 80))
                          (|supersub| (($ $ (|List| $)) 78))
                          (|superHeight| (((|Integer|) $) 33))
                          (|super| (($ $ $) 66))
                          (|sum| (($ $) 135) (($ $ $) 136) (($ $ $ $) 137))
                          (|subHeight| (((|Integer|) $) 32))
                          (|sub| (($ $ $) 65))
                          (|string| (($ $) 109))
                          (|slash| (($ $ $) 124))
                          (|semicolonSeparate| (($ (|List| $)) 55))
                          (|scripts| (($ $ (|List| $)) 72))
                          (|rspace| (($ (|Integer|) (|Integer|)) 49))
                          (|root| (($ $) 121) (($ $ $) 122))
                          (|right| (($ $ (|Integer|)) 42) (($ $) 45))
                          (|rem| (($ $ $) 93))
                          (|rarrow| (($ $ $) 127))
                          (|quote| (($ $) 110))
                          (|quo| (($ $ $) 94))
                          (|prod| (($ $) 138) (($ $ $) 139) (($ $ $ $) 140))
                          (|print| (((|Void|) $) 8))
                          (|prime| (($ $) 113) (($ $ (|NonNegativeInteger|)) 117))
                          (|presuper| (($ $ $) 68))
                          (|presub| (($ $ $) 67))
                          (|prefix| (($ $ (|List| $)) 104))
                          (|postfix| (($ $ $) 108))
                          (|pile| (($ (|List| $)) 53))
                          (|paren| (($ $) 63) (($ (|List| $)) 64))
                          (|overlabel| (($ $ $) 118))
                          (|overbar| (($ $) 111))
                          (|over| (($ $ $) 123))
                          (|outputForm| (($ (|Integer|)) 20) 
                                        (($ (|Symbol|)) 22) 
                                        (($ (|String|)) 29) 
                                        (($ (|DoubleFloat|)) 24))
                          (|or| (($ $ $) 97))
                          (|not| (($ $) 98))
                          (|messagePrint| (((|Void|) (|String|)) 14))
                          (|message| (($ (|String|)) 13))
                          (|matrix| (($ (|List| (|List| $))) 51))
                          (|left| (($ $ (|Integer|)) 41) (($ $) 44))
                          (|latex| (((|String|) $) NIL))
                          (|label| (($ $ $) 126))
                          (|int| (($ $) 141) (($ $ $) 142) (($ $ $ $) 143))
                          (|infix?| (((|Boolean|) $) 102))
                          (|infix| (($ $ (|List| $)) 106) (($ $ $ $) 107))
                          (|hspace| (($ (|Integer|)) 38))
                          (|height| (((|Integer|) $) 31) (((|Integer|)) 34))
                          (|hconcat| (($ $ $) 39) (($ (|List| $)) 79))
                          (|hash| (((|SingleInteger|) $) NIL))
                          (|exquo| (($ $ $) 95))
                          (|empty| (($) 12))
                          (|elt| (($ $ (|List| $)) 103))
                          (|dot| (($ $) 112) 
                                 (($ $ (|NonNegativeInteger|)) 116))
                          (|div| (($ $ $) 92))
                          (|differentiate| (($ $ (|NonNegativeInteger|)) 134))
                          (|commaSeparate| (($ (|List| $)) 54))
                          (|coerce| (((|OutputForm|) $) 18))
                          (|center| (($ $ (|Integer|)) 40) (($ $) 43))
                          (|bracket| (($ $) 61) (($ (|List| $)) 62))
                          (|brace| (($ $) 59) (($ (|List| $)) 60))
                          (|box| (($ $) 119))
                          (|blankSeparate| (($ (|List| $)) 58))
                          (|binomial| (($ $ $) 101))
                          (|assign| (($ $ $) 125))
                          (|and| (($ $ $) 96))
                          (^= (($ $ $) 81))
                          (SEGMENT (($ $ $) 99) (($ $) 100))
                          (>= (($ $ $) 85))
                          (> (($ $ $) 83))
                          (= (((|Boolean|) $ $) 15) (($ $ $) 16))
                          (<= (($ $ $) 84))
                          (< (($ $ $) 82))
                          (/ (($ $ $) 90))
                          (- (($ $ $) 87) (($ $) 88))
                          (+ (($ $ $) 86))
                          (** (($ $ $) 91))
                          (* (($ $ $) 89))))
                    12> (|constructSubst| (|OutputForm|))
                    <12 (|constructSubst| (($ |OutputForm|)))
                    12> (|isEqualOrSubDomain| 
                          (|PositiveInteger|) (|OutputForm|))
                    <12 (|isEqualOrSubDomain| NIL)
                    12> (HPUT #<hash-table 0000000001ab1e70> 
                         (|coerce| (|OutputForm|) (#0=(|PositiveInteger|)) 
                          (#0#) NIL) (1 ((#0# #1=(|OutputForm|) #0#) 
                          (#1# $) (NIL))))
                    <12 (HPUT (1 ((#0=(|PositiveInteger|) 
                          #1=(|OutputForm|) #0#) (#1# $) (NIL))))
                    12> (HPUT #<hash-table 0000000001ab1f00> 
                         (|coerce| #0=(|PositiveInteger|) (|OutputForm|)) 
                         (1 (#0# #1=(|OutputForm|) #0#) (#1# $) (NIL)))
                    <12 (HPUT (1 (#0=(|PositiveInteger|) 
                         #1=(|OutputForm|) #0#) (#1# $) (NIL)))
                    12> (|evalDomain| (|PositiveInteger|))
                    13> (GETL |print| |TimeTotal|)
                    <13 (GETL 0.0)
                    13> (GETL |gc| |TimeTotal|)
                    <13 (GETL 0.0)
                    13> (PUT |gc| |TimeTotal| 0.0)
                    <13 (PUT 0.0)
                    13> (PUT |print| |TimeTotal| 0.0)
                    <13 (PUT 0.0)
                    13> (|mkEvalable| (|PositiveInteger|))
                    14> (CANFUNCALL? |PositiveInteger|)
                    <14 (CANFUNCALL? T)
                    14> (GETDATABASE |PositiveInteger| CONSTRUCTORKIND)
                    <14 (GETDATABASE |domain|)
                    14> (GETDATABASE |PositiveInteger| COSIG)
                    <14 (GETDATABASE (NIL))
                    <13 (|mkEvalable| (|PositiveInteger|))
                    13> (GETL |PositiveInteger| LOADED)
                    <13 (GETL NIL)
                    13> (|loadLib| |PositiveInteger|)
                    14> (GETL |instantiation| |TimeTotal|)
                    <14 (GETL 0.0)
                    14> (GETL |gc| |TimeTotal|)
                    <14 (GETL 0.0)
                    14> (PUT |gc| |TimeTotal| 0.0)
                    <14 (PUT 0.0)
                    14> (PUT |instantiation| |TimeTotal| 0.0)
                    <14 (PUT 0.0)
                    14> (GETDATABASE |PositiveInteger| OBJECT)
                    <14 (GETDATABASE 
                         "/home/daly/noise/mnt/ubuntu/algebra/PI.o")
                    14> (|pathnameDirectory| 
                         "/home/daly/noise/mnt/ubuntu/algebra/PI.o")
                    15> (|pathname| 
                         "/home/daly/noise/mnt/ubuntu/algebra/PI.o")
                    <15 (|pathname| 
                          #p"/home/daly/noise/mnt/ubuntu/algebra/PI.o")
                    <14 (|pathnameDirectory| 
                         "/home/daly/noise/mnt/ubuntu/algebra/")
                    14> (|isSystemDirectory| 
                         "/home/daly/noise/mnt/ubuntu/algebra/")
                    <14 (|isSystemDirectory| T)
                    14> (|loadLibNoUpdate| |PositiveInteger| |PositiveInteger|
                         "/home/daly/noise/mnt/ubuntu/algebra/PI.o")
                    15> (GETDATABASE |PositiveInteger| CONSTRUCTORKIND)
                    <15 (GETDATABASE |domain|)
                    15> (|getProplist| |NonNegativeInteger| 
                         ((((|Category| (|modemap|
                              (((|Category|) (|Category|)) (T *))))
                            (|Join| (|modemap| 
                             (((|Category|) (|Category|) (|Category|)
                               (|Category|))
                              (T *))
                            (((|Category|) (|Category|) (|List| (|Category|))
                              (|Category|)) (T *))))))))
                    16> (|search| |NonNegativeInteger|
                         ((((|Category| (|modemap|
                             (((|Category|) (|Category|)) (T *))))
                           (|Join| (|modemap|
                            (((|Category|) (|Category|) (|Category|)
                              (|Category|))
                             (T *))
                           (((|Category|) (|Category|) (|List| (|Category|))
                             (|Category|)) (T *))))))))
                    17> (|searchCurrentEnv| |NonNegativeInteger|
                         (((|Category| (|modemap|
                            (((|Category|) (|Category|)) (T *))))
                          (|Join| (|modemap|
                           (((|Category|) (|Category|) (|Category|)
                             (|Category|))
                            (T *))
                           (((|Category|) (|Category|) (|List| (|Category|))
                             (|Category|)) (T *)))))))
                    <17 (|searchCurrentEnv| NIL)
                    17> (|searchTailEnv| |NonNegativeInteger| NIL)
                    <17 (|searchTailEnv| NIL)
                    <16 (|search| NIL)
                    16> (|search| |NonNegativeInteger|
                         ((((|Category| (|modemap|
                           (((|Category|) (|Category|)) (T *))))
                         (|Join| (|modemap|
                          (((|Category|) (|Category|) (|Category|)
                            (|Category|))
                           (T *))
                          (((|Category|) (|Category|) (|List| (|Category|))
                            (|Category|)) (T *))))))))
                    17> (|searchCurrentEnv| |NonNegativeInteger|
                         (((|Category| (|modemap|
                            (((|Category|) (|Category|)) (T *))))
                           (|Join| (|modemap|
                             (((|Category|) (|Category|) (|Category|)
                               (|Category|)) (T *))
                             (((|Category|) (|Category|) (|List| (|Category|))
                               (|Category|)) (T *)))))))
                    <17 (|searchCurrentEnv| NIL)
                    17> (|searchTailEnv| |NonNegativeInteger| NIL)
                    <17 (|searchTailEnv| NIL)
                    <16 (|search| NIL)
                    <15 (|getProplist| NIL)
                    15> (|addBinding| |NonNegativeInteger|
                         ((|SubDomain|
                           (|PositiveInteger| SPADCALL 0 |#1| (QREFELT $ 7))))
                         ((((|Category| (|modemap|
                           (((|Category|) (|Category|)) (T *))))
                          (|Join| (|modemap|
                           (((|Category|) (|Category|) (|Category|)
                             (|Category|)) (T *))
                           (((|Category|) (|Category|) (|List| (|Category|))
                             (|Category|)) (T *))))))))
                    16> (|getProplist| |NonNegativeInteger|
                         ((((|Category| (|modemap|
                          (((|Category|) (|Category|)) (T *))))
                         (|Join| (|modemap|
                          (((|Category|) (|Category|) (|Category|)
                            (|Category|)) (T *))
                          (((|Category|) (|Category|) (|List| (|Category|))
                            (|Category|)) (T *))))))))
                    17> (|search| |NonNegativeInteger|
                         ((((|Category| (|modemap|
                          (((|Category|) (|Category|)) (T *))))
                         (|Join| (|modemap|
                          (((|Category|) (|Category|) (|Category|)
                            (|Category|)) (T *))
                          (((|Category|) (|Category|) (|List| (|Category|))
                            (|Category|)) (T *))))))))
                    18> (|searchCurrentEnv| |NonNegativeInteger|
                         (((|Category| (|modemap|
                            (((|Category|) (|Category|)) (T *))))
                          (|Join| (|modemap|
                            (((|Category|) (|Category|) (|Category|)
                              (|Category|)) (T *))
                            (((|Category|) (|Category|) (|List| (|Category|))
                              (|Category|)) (T *)))))))
                    <18 (|searchCurrentEnv| NIL)
                    18> (|searchTailEnv| |NonNegativeInteger| NIL)
                    <18 (|searchTailEnv| NIL)
                    <17 (|search| NIL)
                    17> (|search| |NonNegativeInteger|
                         ((((|Category| (|modemap|
                          (((|Category|) (|Category|)) (T *))))
                         (|Join| (|modemap|
                          (((|Category|) (|Category|) (|Category|)
                            (|Category|)) (T *))
                          (((|Category|) (|Category|) (|List| (|Category|))
                            (|Category|)) (T *))))))))
                    18> (|searchCurrentEnv| |NonNegativeInteger|
                         (((|Category| (|modemap|
                           (((|Category|) (|Category|)) (T *))))
                          (|Join| (|modemap|
                           (((|Category|) (|Category|) (|Category|) 
                             (|Category|)) (T *)) 
                          (((|Category|) (|Category|) (|List| (|Category|)) 
                            (|Category|)) (T *)))))))
                    <18 (|searchCurrentEnv| NIL)
                    18> (|searchTailEnv| |NonNegativeInteger| NIL)
                    <18 (|searchTailEnv| NIL)
                    <17 (|search| NIL)
                    <16 (|getProplist| NIL)
                    16> (|addBindingInteractive| |NonNegativeInteger|
                         ((|SubDomain|
                           (|PositiveInteger| SPADCALL 0 |#1| (QREFELT $ 7))))
                         ((((|Category| (|modemap|
                           (((|Category|) (|Category|)) (T *))))
                          (|Join| (|modemap|
                           (((|Category|) (|Category|) (|Category|)
                             (|Category|)) (T *))
                           (((|Category|) (|Category|) (|List| (|Category|))
                             (|Category|)) (T *))))))))
                    <16 (|addBindingInteractive|
                         ((((|NonNegativeInteger|
                          (|SubDomain|
                            (|PositiveInteger| SPADCALL 0 |#1| (QREFELT $ 7))))
                          (|Category| (|modemap|
                            (((|Category|) (|Category|)) (T *))))
                           (|Join| (|modemap|
                             (((|Category|) (|Category|) (|Category|)
                               (|Category|)) (T *))
                             (((|Category|) (|Category|) (|List| (|Category|))
                               (|Category|)) (T *))))))))
                    <15 (|addBinding|
                         ((((|NonNegativeInteger|
                          (|SubDomain|
                            (|PositiveInteger| SPADCALL 0 |#1| (QREFELT $ 7))))
                          (|Category| (|modemap|
                            (((|Category|) (|Category|)) (T *))))
                          (|Join| (|modemap|
                           (((|Category|) (|Category|) (|Category|)
                            (|Category|)) (T *))
                           (((|Category|) (|Category|) (|List| (|Category|))
                            (|Category|)) (T *))))))))
                    15> (|getProplist| |PositiveInteger|
                         ((((|NonNegativeInteger|
                           (|SubDomain|
                            (|PositiveInteger| SPADCALL 0 |#1| (QREFELT $ 7))))
                           (|Category| (|modemap|
                              (((|Category|) (|Category|)) (T *))))
                           (|Join| (|modemap|
                              (((|Category|) (|Category|) (|Category|)
                                (|Category|)) (T *))
                              (((|Category|) (|Category|) (|List| (|Category|))
                                (|Category|)) (T *))))))))
                    16> (|search| |PositiveInteger|
                         ((((|NonNegativeInteger|
                          (|SubDomain|
                           (|PositiveInteger| SPADCALL 0 |#1| (QREFELT $ 7))))
                         (|Category| (|modemap|
                          (((|Category|) (|Category|)) (T *))))
                         (|Join| (|modemap|
                          (((|Category|) (|Category|) (|Category|)
                            (|Category|)) (T *))
                          (((|Category|) (|Category|) (|List| (|Category|))
                            (|Category|)) (T *))))))))
                    17> (|searchCurrentEnv| |PositiveInteger|
                         (((|NonNegativeInteger|
                          (|SubDomain|
                           (|PositiveInteger| SPADCALL 0 |#1| (QREFELT $ 7))))
                          (|Category| (|modemap|
                           (((|Category|) (|Category|)) (T *))))
                          (|Join| (|modemap|
                           (((|Category|) (|Category|) (|Category|)
                             (|Category|)) (T *))
                           (((|Category|) (|Category|) (|List| (|Category|))
                             (|Category|)) (T *)))))))
                    <17 (|searchCurrentEnv| NIL)
                    17> (|searchTailEnv| |PositiveInteger| NIL)
                    <17 (|searchTailEnv| NIL)
                    <16 (|search| NIL)
                    16> (|search| |PositiveInteger|
                         ((((|NonNegativeInteger|
                          (|SubDomain|
                           (|PositiveInteger| SPADCALL 0 |#1| (QREFELT $ 7))))
                          (|Category| (|modemap|
                           (((|Category|) (|Category|)) (T *))))
                          (|Join| (|modemap|
                           (((|Category|) (|Category|) (|Category|)
                             (|Category|)) (T *))
                           (((|Category|) (|Category|) (|List| (|Category|))
                             (|Category|)) (T *))))))))
                    17> (|searchCurrentEnv| |PositiveInteger|
                         (((|NonNegativeInteger|
                          (|SubDomain|
                           (|PositiveInteger| SPADCALL 0 |#1| (QREFELT $ 7))))
                          (|Category| (|modemap|
                           (((|Category|) (|Category|)) (T *))))
                          (|Join| (|modemap|
                           (((|Category|) (|Category|) (|Category|)
                             (|Category|)) (T *))
                           (((|Category|) (|Category|) (|List| (|Category|))
                             (|Category|)) (T *)))))))
                    <17 (|searchCurrentEnv| NIL)
                    17> (|searchTailEnv| |PositiveInteger| NIL)
                    <17 (|searchTailEnv| NIL)
                    <16 (|search| NIL)
                    <15 (|getProplist| NIL)
                    15> (|addBinding| |PositiveInteger|
                         ((|SuperDomain| |NonNegativeInteger|))
                         ((((|NonNegativeInteger|
                          (|SubDomain|
                           (|PositiveInteger| SPADCALL 0 |#1| (QREFELT $ 7))))
                         (|Category| (|modemap|
                          (((|Category|) (|Category|)) (T *))))
                         (|Join| (|modemap|
                          (((|Category|) (|Category|) (|Category|)
                            (|Category|)) (T *))
                          (((|Category|) (|Category|) (|List| (|Category|))
                            (|Category|)) (T *))))))))
                    16> (|getProplist| |PositiveInteger|
                         ((((|NonNegativeInteger|
                          (|SubDomain|
                           (|PositiveInteger| SPADCALL 0 |#1| (QREFELT $ 7))))
                          (|Category| (|modemap|
                           (((|Category|) (|Category|)) (T *))))
                          (|Join| (|modemap|
                           (((|Category|) (|Category|) (|Category|)
                             (|Category|)) (T *))
                           (((|Category|) (|Category|) (|List| (|Category|))
                             (|Category|)) (T *))))))))
                    17> (|search| |PositiveInteger|
                         ((((|NonNegativeInteger|
                          (|SubDomain|
                           (|PositiveInteger| SPADCALL 0 |#1| (QREFELT $ 7))))
                          (|Category| (|modemap|
                           (((|Category|) (|Category|)) (T *))))
                          (|Join| (|modemap|
                           (((|Category|) (|Category|) (|Category|)
                             (|Category|)) (T *))
                           (((|Category|) (|Category|) (|List| (|Category|))
                             (|Category|)) (T *))))))))
                    18> (|searchCurrentEnv| |PositiveInteger|
                         (((|NonNegativeInteger|
                          (|SubDomain|
                           (|PositiveInteger| SPADCALL 0 |#1| (QREFELT $ 7))))
                          (|Category| (|modemap|
                           (((|Category|) (|Category|)) (T *))))
                          (|Join| (|modemap|
                           (((|Category|) (|Category|) (|Category|)
                             (|Category|)) (T *))
                           (((|Category|) (|Category|) (|List| (|Category|))
                             (|Category|)) (T *)))))))
                    <18 (|searchCurrentEnv| NIL)
                    18> (|searchTailEnv| |PositiveInteger| NIL)
                    <18 (|searchTailEnv| NIL)
                    <17 (|search| NIL)
                    17> (|search| |PositiveInteger|
                         ((((|NonNegativeInteger|
                          (|SubDomain|
                           (|PositiveInteger| SPADCALL 0 |#1| (QREFELT $ 7))))
                          (|Category| (|modemap|
                           (((|Category|) (|Category|)) (T *))))
                          (|Join| (|modemap|
                           (((|Category|) (|Category|) (|Category|)
                             (|Category|)) (T *))
                           (((|Category|) (|Category|) (|List| (|Category|))
                             (|Category|)) (T *))))))))
                    18> (|searchCurrentEnv| |PositiveInteger|
                         (((|NonNegativeInteger|
                          (|SubDomain|
                           (|PositiveInteger| SPADCALL 0 |#1| (QREFELT $ 7))))
                          (|Category| (|modemap|
                           (((|Category|) (|Category|)) (T *))))
                          (|Join| (|modemap|
                           (((|Category|) (|Category|) (|Category|)
                             (|Category|)) (T *))
                           (((|Category|) (|Category|) (|List| (|Category|))
                             (|Category|)) (T *)))))))
                    <18 (|searchCurrentEnv| NIL)
                    18> (|searchTailEnv| |PositiveInteger| NIL)
                    <18 (|searchTailEnv| NIL)
                    <17 (|search| NIL)
                    <16 (|getProplist| NIL)
                    16> (|addBindingInteractive| |PositiveInteger|
                         ((|SuperDomain| |NonNegativeInteger|))
                         ((((|NonNegativeInteger|
                          (|SubDomain|
                           (|PositiveInteger| SPADCALL 0 |#1| (QREFELT $ 7))))
                          (|Category| (|modemap|
                           (((|Category|) (|Category|)) (T *))))
                          (|Join| (|modemap|
                           (((|Category|) (|Category|) (|Category|)
                             (|Category|)) (T *))
                           (((|Category|) (|Category|) (|List| (|Category|))
                             (|Category|)) (T *))))))))
                    <16 (|addBindingInteractive|
                         ((((|PositiveInteger|
                          (|SuperDomain| |NonNegativeInteger|))
                          (|NonNegativeInteger|
                           (|SubDomain|
                            (|PositiveInteger| SPADCALL 0 |#1| (QREFELT $ 7))))
                           (|Category| (|modemap|
                            (((|Category|) (|Category|)) (T *))))
                           (|Join| (|modemap|
                            (((|Category|) (|Category|) (|Category|)
                              (|Category|)) (T *))
                            (((|Category|) (|Category|) (|List| (|Category|))
                              (|Category|)) (T *))))))))
                    <15 (|addBinding|
                         ((((|PositiveInteger|
                          (|SuperDomain| |NonNegativeInteger|))
                          (|NonNegativeInteger|
                           (|SubDomain|
                            (|PositiveInteger| SPADCALL 0 |#1| (QREFELT $ 7))))
                           (|Category| (|modemap|
                            (((|Category|) (|Category|)) (T *))))
                           (|Join| (|modemap|
                            (((|Category|) (|Category|) (|Category|)
                              (|Category|)) (T *))
                            (((|Category|) (|Category|) (|List| (|Category|))
                              (|Category|)) (T *))))))))
                    15> (|makeByteWordVec2| 1 (0 0 0 0 0 0 0))
                    <15 (|makeByteWordVec2| #<bit-vector 0000000001ab1db0>)
                    15> (|makeByteWordVec2| 12 (2 5 6 0 0 7 2 0 6 0 0 1 0 0 0
                          1 1 0 9 0 1 1 0 6 0 1 2 0 0 0 0 1 2 0 0 0 0 1 1 0 11
                          0 1 1 0 10 0 1 2 0 0 0 0 1 1 0 12 0 1 2 0 0 0 8 1 2
                          0 0 0 5 1 0 0 0 1 2 0 6 0 0 1 2 0 6 0 0 1 2 0 6 0 0
                          1 2 0 6 0 0 1 2 0 6 0 0 1 2 0 0 0 0 1 2 0 0 0 8 1 2
                          0 0 0 5 1 2 0 0 0 0 1 2 0 0 8 0 1))
                    <15 (|makeByteWordVec2| #<vector 0000000001ab1d80>)
                    15> (GETDATABASE |PositiveInteger| CONSTRUCTORKIND)
                    <15 (GETDATABASE |domain|)
                    15> (GETL |load| |TimeTotal|)
                    <15 (GETL 0.0)
                    15> (GETL |gc| |TimeTotal|)
                    <15 (GETL 0.0)
                    15> (PUT |gc| |TimeTotal| 0.0)
                    <15 (PUT 0.0)
                    15> (PUT |load| |TimeTotal| 0.0)
                    <15 (PUT 0.0)
                    <14 (|loadLibNoUpdate| T)
                    <13 (|loadLib| T)
                    13> (HPUT #<hash-table 000000000105e810> |PositiveInteger|
                          ((NIL 1 . #<vector 0000000001ab1d50>)))
                    <13 (HPUT ((NIL 1 . #<vector 0000000001ab1d50>)))
                    13> (GETDATABASE |PositiveInteger| CONSTRUCTORKIND)
                    <13 (GETDATABASE |domain|)
                    13> (GETL |PositiveInteger| |infovec|)
                    <13 (GETL (#<vector 0000000000fa5db0> 
                               #<vector 0000000000fa5cf0>
                         (((|commutative| "*") . 0))
                         (#<bit-vector 0000000001ab1db0> 
                          #<vector 0000000000fa5c90> 
                          #<vector 0000000001ab1de0>
                          . #<vector 0000000001ab1d80>) |lookupComplete|))
                    13> (HPUT #<hash-table 000000000105e810> |PositiveInteger|
                          ((NIL 1 . #<vector 0000000001ab1d50>)))
                    <13 (HPUT ((NIL 1 . #<vector 0000000001ab1d50>)))
                    13> (GETL |instantiation| |TimeTotal|)
                    <13 (GETL 0.0)
                    13> (GETL |gc| |TimeTotal|)
                    <13 (GETL 0.0)
                    13> (PUT |gc| |TimeTotal| 0.0)
                    <13 (PUT 0.0)
                    13> (PUT |instantiation| |TimeTotal| 0.0)
                    <13 (PUT 0.0)
                    <12 (|evalDomain| #<vector 0000000001ab1d50>)
                    12> (|compiledLookup| |coerce| ((|OutputForm|) $)
                          #<vector 0000000001ab1d50>)
                    13> (|NRTevalDomain| #<vector 0000000001ab1d50>)
                    14> (|evalDomain| #<vector 0000000001ab1d50>)
                    15> (GETL |print| |TimeTotal|)
                    <15 (GETL 0.0)
                    15> (GETL |gc| |TimeTotal|)
                    <15 (GETL 0.0)
                    15> (PUT |gc| |TimeTotal| 0.0)
                    <15 (PUT 0.0)
                    15> (PUT |print| |TimeTotal| 0.0)
                    <15 (PUT 0.0)
                    15> (|mkEvalable| #<vector 0000000001ab1d50>)
                    <15 (|mkEvalable| #<vector 0000000001ab1d50>)
                    15> (GETL |instantiation| |TimeTotal|)
                    <15 (GETL 0.0)
                    15> (GETL |gc| |TimeTotal|)
                    <15 (GETL 0.0)
                    15> (PUT |gc| |TimeTotal| 0.0)
                    <15 (PUT 0.0)
                    15> (PUT |instantiation| |TimeTotal| 0.0)
                    <15 (PUT 0.0)
                    <14 (|evalDomain| #<vector 0000000001ab1d50>)
                    <13 (|NRTevalDomain| #<vector 0000000001ab1d50>)
                    13> (|basicLookup| |coerce| ((|OutputForm|) $) 
                         #<vector 0000000001ab1d50> #<vector 0000000001ab1d50>)
                    14> (|oldCompLookup| |coerce| ((|OutputForm|) $) 
                         #<vector 0000000001ab1d50> #<vector 0000000001ab1d50>)
                    15> (|lookupInDomainVector| |coerce| ((|OutputForm|) $) 
                         #<vector 0000000001ab1d50> #<vector 0000000001ab1d50>)
                    16> (GETDATABASE |OutputForm| COSIG)
                    <16 (GETDATABASE (NIL))
                    16> (GETDATABASE |PositiveInteger| CONSTRUCTORKIND)
                    <16 (GETDATABASE |domain|)
                    16> (GETL |NonNegativeInteger| LOADED)
                    <16 (GETL NIL)
                    16> (|loadLib| |NonNegativeInteger|)
                    17> (GETL |print| |TimeTotal|)
                    <17 (GETL 0.0)
                    17> (GETL |gc| |TimeTotal|)
                    <17 (GETL 0.0)
                    17> (PUT |gc| |TimeTotal| 0.0)
                    <17 (PUT 0.0)
                    17> (PUT |print| |TimeTotal| 0.0)
                    <17 (PUT 0.0)
                    17> (GETDATABASE |NonNegativeInteger| OBJECT)
                    <17 (GETDATABASE 
                         "/home/daly/noise/mnt/ubuntu/algebra/NNI.o")
                    17> (|pathnameDirectory| 
                         "/home/daly/noise/mnt/ubuntu/algebra/NNI.o")
                    18> (|pathname| 
                         "/home/daly/noise/mnt/ubuntu/algebra/NNI.o")
                    <18 (|pathname| 
                         #p"/home/daly/noise/mnt/ubuntu/algebra/NNI.o")
                    <17 (|pathnameDirectory| 
                         "/home/daly/noise/mnt/ubuntu/algebra/")
                    17> (|isSystemDirectory| 
                         "/home/daly/noise/mnt/ubuntu/algebra/")
                    <17 (|isSystemDirectory| T)
                    17> (|loadLibNoUpdate| |NonNegativeInteger| 
                         |NonNegativeInteger| 
                         "/home/daly/noise/mnt/ubuntu/algebra/NNI.o")
                    18> (GETDATABASE |NonNegativeInteger| CONSTRUCTORKIND)
                    <18 (GETDATABASE |domain|)
                    18> (|getProplist| |Integer| ((NIL)))
                    19> (|search| |Integer| ((NIL)))
                    20> (|searchCurrentEnv| |Integer| (NIL))
                    <20 (|searchCurrentEnv| NIL)
                    20> (|searchTailEnv| |Integer| NIL)
                    <20 (|searchTailEnv| NIL)
                    <19 (|search| NIL)
                    19> (|search| |Integer| ((NIL)))
                    20> (|searchCurrentEnv| |Integer| (NIL))
                    <20 (|searchCurrentEnv| NIL)
                    20> (|searchTailEnv| |Integer| NIL)
                    <20 (|searchTailEnv| NIL)
                    <19 (|search| NIL)
                    <18 (|getProplist| NIL)
                    18> (|addBinding| |Integer| 
                         ((|SubDomain| 
                           (|NonNegativeInteger| 
                            COND 
                             ((SPADCALL |#1| 0 (QREFELT $ 7)) (QUOTE NIL)) 
                             ((QUOTE T) (QUOTE T))))) ((NIL)))
                    19> (|getProplist| |Integer| ((NIL)))
                    20> (|search| |Integer| ((NIL)))
                    21> (|searchCurrentEnv| |Integer| (NIL))
                    <21 (|searchCurrentEnv| NIL)
                    21> (|searchTailEnv| |Integer| NIL)
                    <21 (|searchTailEnv| NIL)
                    <20 (|search| NIL)
                    20> (|search| |Integer| ((NIL)))
                    21> (|searchCurrentEnv| |Integer| (NIL))
                    <21 (|searchCurrentEnv| NIL)
                    21> (|searchTailEnv| |Integer| NIL)
                    <21 (|searchTailEnv| NIL)
                    <20 (|search| NIL)
                    <19 (|getProplist| NIL)
                    19> (|addBindingInteractive| |Integer| 
                         ((|SubDomain| 
                          (|NonNegativeInteger| 
                           COND 
                            ((SPADCALL |#1| 0 (QREFELT $ 7)) (QUOTE NIL)) 
                            ((QUOTE T) (QUOTE T))))) ((NIL)))
                    <19 (|addBindingInteractive| 
                         ((((|Integer| 
                          (|SubDomain| 
                           (|NonNegativeInteger| 
                            COND 
                             ((SPADCALL |#1| 0 (QREFELT $ 7)) (QUOTE NIL))
                             ((QUOTE T) (QUOTE T)))))))))
                    <18 (|addBinding| 
                         ((((|Integer| 
                          (|SubDomain| 
                           (|NonNegativeInteger| 
                            COND 
                             ((SPADCALL |#1| 0 (QREFELT $ 7)) (QUOTE NIL))
                             ((QUOTE T) (QUOTE T)))))))))
                    18> (|getProplist| |NonNegativeInteger|
                         ((((|Integer|
                          (|SubDomain|
                           (|NonNegativeInteger|
                             COND
                              ((SPADCALL |#1| 0 (QREFELT $ 7)) (QUOTE NIL)) 
                              ((QUOTE T) (QUOTE T)))))))))
                    19> (|search| |NonNegativeInteger|
                         ((((|Integer|
                          (|SubDomain|
                           (|NonNegativeInteger|
                            COND
                             ((SPADCALL |#1| 0 (QREFELT $ 7)) (QUOTE NIL))
                             ((QUOTE T) (QUOTE T)))))))))
                    20> (|searchCurrentEnv| |NonNegativeInteger|
                         (((|Integer|
                          (|SubDomain|
                           (|NonNegativeInteger|
                            COND
                             ((SPADCALL |#1| 0 (QREFELT $ 7)) (QUOTE NIL))
                             ((QUOTE T) (QUOTE T))))))))
                    <20 (|searchCurrentEnv| NIL)
                    20> (|searchTailEnv| |NonNegativeInteger| NIL)
                    <20 (|searchTailEnv| NIL)
                    <19 (|search| NIL)
                    19> (|search| |NonNegativeInteger|
                         ((((|Integer|
                          (|SubDomain|
                           (|NonNegativeInteger|
                            COND
                             ((SPADCALL |#1| 0 (QREFELT $ 7)) (QUOTE NIL))
                             ((QUOTE T) (QUOTE T)))))))))
                    20> (|searchCurrentEnv| |NonNegativeInteger|
                         (((|Integer|
                          (|SubDomain|
                           (|NonNegativeInteger|
                            COND
                             ((SPADCALL |#1| 0 (QREFELT $ 7)) (QUOTE NIL))
                             ((QUOTE T) (QUOTE T))))))))
                    <20 (|searchCurrentEnv| NIL)
                    20> (|searchTailEnv| |NonNegativeInteger| NIL)
                    <20 (|searchTailEnv| NIL)
                    <19 (|search| NIL)
                    <18 (|getProplist| NIL)
                    18> (|addBinding| |NonNegativeInteger|
                         ((|SuperDomain| |Integer|))
                          ((((|Integer|
                           (|SubDomain|
                            (|NonNegativeInteger|
                             COND
                              ((SPADCALL |#1| 0 (QREFELT $ 7)) (QUOTE NIL))
                              ((QUOTE T) (QUOTE T)))))))))
                    19> (|getProplist| |NonNegativeInteger|
                         ((((|Integer|
                          (|SubDomain|
                           (|NonNegativeInteger|
                            COND
                             ((SPADCALL |#1| 0 (QREFELT $ 7)) (QUOTE NIL))
                             ((QUOTE T) (QUOTE T)))))))))
                    20> (|search| |NonNegativeInteger|
                         ((((|Integer|
                          (|SubDomain|
                           (|NonNegativeInteger|
                            COND
                             ((SPADCALL |#1| 0 (QREFELT $ 7)) (QUOTE NIL)) 
                             ((QUOTE T) (QUOTE T)))))))))
                    21> (|searchCurrentEnv| |NonNegativeInteger|
                         (((|Integer|
                          (|SubDomain|
                           (|NonNegativeInteger|
                            COND
                             ((SPADCALL |#1| 0 (QREFELT $ 7)) (QUOTE NIL))
                             ((QUOTE T) (QUOTE T))))))))
                    <21 (|searchCurrentEnv| NIL)
                    21> (|searchTailEnv| |NonNegativeInteger| NIL)
                    <21 (|searchTailEnv| NIL)
                    <20 (|search| NIL)
                    20> (|search| |NonNegativeInteger|
                         ((((|Integer|
                          (|SubDomain|
                           (|NonNegativeInteger|
                            COND
                             ((SPADCALL |#1| 0 (QREFELT $ 7)) (QUOTE NIL))
                             ((QUOTE T) (QUOTE T)))))))))
                    21> (|searchCurrentEnv| |NonNegativeInteger|
                         (((|Integer|
                          (|SubDomain|
                           (|NonNegativeInteger|
                            COND
                             ((SPADCALL |#1| 0 (QREFELT $ 7)) (QUOTE NIL))
                             ((QUOTE T) (QUOTE T))))))))
                    <21 (|searchCurrentEnv| NIL)
                    21> (|searchTailEnv| |NonNegativeInteger| NIL)
                    <21 (|searchTailEnv| NIL)
                    <20 (|search| NIL)
                    <19 (|getProplist| NIL)
                    19> (|addBindingInteractive| |NonNegativeInteger|
                         ((|SuperDomain| |Integer|))
                         ((((|Integer|
                          (|SubDomain|
                           (|NonNegativeInteger| 
                            COND
                             ((SPADCALL |#1| 0 (QREFELT $ 7)) (QUOTE NIL)) 
                             ((QUOTE T) (QUOTE T)))))))))
                    <19 (|addBindingInteractive|
                         ((((|NonNegativeInteger| (|SuperDomain| |Integer|))
                         (|Integer|
                          (|SubDomain|
                           (|NonNegativeInteger|
                             COND
                              ((SPADCALL |#1| 0 (QREFELT $ 7)) (QUOTE NIL))
                              ((QUOTE T) (QUOTE T)))))))))
                    <18 (|addBinding|
                         ((((|NonNegativeInteger| (|SuperDomain| |Integer|))
                          (|Integer|
                           (|SubDomain|
                            (|NonNegativeInteger|
                             COND
                              ((SPADCALL |#1| 0 (QREFELT $ 7)) (QUOTE NIL))
                              ((QUOTE T) (QUOTE T)))))))))
                    18> (|makeByteWordVec2| 1 (0 0 0 0 0 0 0 0 0 0 0 0 0))
                    <18 (|makeByteWordVec2| #<bit-vector 0000000001ab1990>)
                    18> (|makeByteWordVec2| 18 (2 5 6 0 0 7 2 5 0 0 0 10 2 0 6
                           0 0 1 1 0 6 0 1 2 0 0 0 0 8 2 0 11 0 0 12 2 0 0 0 5
                           9 0 0 0 1 2 0 0 0 0 1 1 0 11 0 1 1 0 0 0 1 2 0 0 0
                           0 1 1 0 6 0 1 2 0 0 0 0 1 2 0 0 0 0 1 1 0 17 0 1 1
                           0 16 0 1 2 0 0 0 0 1 2 0 11 0 0 1 2 0 13 0 0 1 1 0
                           18 0 1 2 0 0 0 14 1 2 0 0 0 15 1 0 0 0 1 0 0 0 1 2
                           0 6 0 0 1 2 0 6 0 0 1 2 0 6 0 0 1 2 0 6 0 0 1 2 0
                           6 0 0 1 2 0 0 0 0 1 2 0 0 0 14 1 2 0 0 0 15 1 2 0
                           0 0 0 1 2 0 0 14 0 1 2 0 0 15 0 1))
                    <18 (|makeByteWordVec2| #<vector 0000000001ab1960>)
                    18> (GETDATABASE |NonNegativeInteger| CONSTRUCTORKIND)
                    <18 (GETDATABASE |domain|)
                    18> (GETL |load| |TimeTotal|)
                    <18 (GETL 0.0)
                    18> (GETL |gc| |TimeTotal|)
                    <18 (GETL 0.0)
                    18> (PUT |gc| |TimeTotal| 0.0)
                    <18 (PUT 0.0)
                    18> (PUT |load| |TimeTotal| 0.0)
                    <18 (PUT 0.0)
                    <17 (|loadLibNoUpdate| T)
                    <16 (|loadLib| T)
                    16> (HPUT #<hash-table 000000000105e810> 
                         |NonNegativeInteger| 
                         ((NIL 1 . #<vector 0000000001ab1930>)))
                    <16 (HPUT ((NIL 1 . #<vector 0000000001ab1930>)))
                    16> (GETDATABASE |NonNegativeInteger| CONSTRUCTORKIND)
                    <16 (GETDATABASE |domain|)
                    16> (GETL |NonNegativeInteger| |infovec|)
                    <16 (GETL (#<vector 0000000001ab1b10> 
                               #<vector 0000000001ab1ae0> 
                               (((|commutative| "*") . 0)) 
                               (#<bit-vector 0000000001ab1990> 
                                #<vector 0000000001ab1ab0> 
                                #<vector 0000000001ab1a80>
                                . #<vector 0000000001ab1960>)
                          |lookupComplete|))
                    16> (HPUT #<hash-table 000000000105e810> 
                              |NonNegativeInteger|
                              ((NIL 1 . #<vector 0000000001ab1930>)))
                    <16 (HPUT ((NIL 1 . #<vector 0000000001ab1930>)))
                    16> (|lookupInDomainVector| |coerce| ((|OutputForm|) $) 
                         #<vector 0000000001ab1930> #<vector 0000000001ab1d50>)
                    17> (GETDATABASE |NonNegativeInteger| CONSTRUCTORKIND)
                    <17 (GETDATABASE |domain|)
                    17> (PNAME |NonNegativeInteger|)
                    <17 (PNAME "NonNegativeInteger")
                    17> (PNAME |NonNegativeInteger|)
                    <17 (PNAME "NonNegativeInteger")
                    17> (GETDATABASE |OutputForm| COSIG)
                    <17 (GETDATABASE (NIL))
                    17> (GETDATABASE |PositiveInteger| CONSTRUCTORKIND)
                    <17 (GETDATABASE |domain|)
                    17> (GETL |Integer| LOADED)
                    <17 (GETL NIL)
                    17> (|loadLib| |Integer|)
                    18> (GETL |print| |TimeTotal|)
                    <18 (GETL 0.0)
                    18> (GETL |gc| |TimeTotal|)
                    <18 (GETL 0.0)
                    18> (PUT |gc| |TimeTotal| 0.0)
                    <18 (PUT 0.0)
                    18> (PUT |print| |TimeTotal| 0.0)
                    <18 (PUT 0.0)
                    18> (GETDATABASE |Integer| OBJECT)
                    <18 (GETDATABASE 
                         "/home/daly/noise/mnt/ubuntu/algebra/INT.o")
                    18> (|pathnameDirectory| 
                         "/home/daly/noise/mnt/ubuntu/algebra/INT.o")
                    19> (|pathname| 
                         "/home/daly/noise/mnt/ubuntu/algebra/INT.o")
                    <19 (|pathname| 
                         #p"/home/daly/noise/mnt/ubuntu/algebra/INT.o")
                    <18 (|pathnameDirectory| 
                         "/home/daly/noise/mnt/ubuntu/algebra/")
                    18> (|isSystemDirectory| 
                         "/home/daly/noise/mnt/ubuntu/algebra/")
                    <18 (|isSystemDirectory| T)
                    18> (|loadLibNoUpdate| |Integer| |Integer| 
                         "/home/daly/noise/mnt/ubuntu/algebra/INT.o")
                    19> (GETDATABASE |Integer| CONSTRUCTORKIND)
                    <19 (GETDATABASE |domain|)
                    19> (|makeByteWordVec2| 1 
                         (0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
                          0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0))
                    <19 (|makeByteWordVec2| #<bit-vector 0000000001723f60>)
                    19> (|makeByteWordVec2| 133 
                         (1 7 6 0 8 3 7 6 0 9 9 10 2 7 6 0 11 12 1 7 6 0 13 0
                          14 0 15 2 7 0 9 14 16 1 7 6 0 17 1 7 6 0 18 1 7 6 0
                          19 1 35 0 11 36 1 44 0 11 45 1 47 0 11 48 1 50 0 11
                          51 1 9 0 11 53 2 93 90 91 92 94 1 97 95 96 98 1 96
                          0 0 99 1 96 2 0 100 1 101 95 96 102 1 96 0 2 103 1
                          0 104 0 105 2 108 95 106 107 109 2 110 95 95 95 111
                          1 101 95 96 112 1 96 21 0 113 1 96 0 0 114 1 116 96
                          115 117 2 0 21 0 0 1 1 0 21 0 25 1 0 87 0 88 1 0 0
                          0 89 1 0 21 0 1 2 0 0 0 0 1 2 0 83 0 0 1 3 0 0 0 0 
                          0 42 1 0 0 0 1 1 0 104 0 1 2 0 21 0 0 1 1 0 11 0 1
                          2 0 0 0 0 82 0 0 0 1 1 0 124 0 1 1 0 11 0 1 2 0 0 0
                          0 81 2 0 60 58 61 62 1 0 57 58 59 1 0 83 0 85 1 0
                          120 0 1 1 0 21 0 1 1 0 121 0 1 1 0 0 0 65 0 0 0 64
                          2 0 0 0 0 80 1 0 127 126 1 1 0 21 0 1 3 0 0 0 0 0 1
                          2 0 0 0 0 56 1 0 21 0 1 2 0 0 0 0 1 3 0 122 0 123
                          122 1 1 0 21 0 26 1 0 21 0 75 1 0 83 0 1 1 0 21 0
                          34 2 0 125 126 0 1 3 0 0 0 0 0 43 2 0 0 0 0 77 2 0
                          0 0 0 76 1 0 0 0 1 1 0 0 0 40 2 0 131 0 0 1 1 0 0
                          126 1 2 0 0 0 0 1 1 0 9 0 55 2 0 0 0 0 1 0 0 0 1 1
                          0 0 0 31 1 0 0 0 33 1 0 133 0 1 2 0 118 118 118 119
                          2 0 0 0 0 86 1 0 0 126 1 1 0 0 0 1 1 0 104 0 105 3
                          0 129 0 0 0 1 2 0 130 0 0 1 2 0 83 0 0 84 2 0 125
                          126 0 1 1 0 21 0 1 1 0 73 0 1 2 0 78 0 0 79 1 0 0 0
                          1 2 0 0 0 73 1 1 0 0 0 32 1 0 0 0 30 1 0 9 0 54 1 0
                          47 0 49 1 0 44 0 46 1 0 50 0 52 1 0 123 0 1 1 0 11
                          0 39 1 0 0 11 38 1 0 0 0 1 1 0 0 11 38 1 0 35 0 37
                          0 0 73 1 2 0 21 0 0 1 2 0 0 0 0 1 0 0 0 29 2 0 21 0
                          0 1 3 0 0 0 0 0 41 1 0 0 0 63 2 0 0 0 73 1 2 0 0 0
                          132 1 0 0 0 27 0 0 0 28 3 0 6 7 0 21 24 2 0 9 0 21
                          22 2 0 6 7 0 23 1 0 9 0 20 1 0 0 0 1 2 0 0 0 73 1 2
                          0 21 0 0 1 2 0 21 0 0 1 2 0 21 0 0 66 2 0 21 0 0 1
                          2 0 21 0 0 67 2 0 0 0 0 70 1 0 0 0 68 2 0 0 0 0 69
                          2 0 0 0 73 74 2 0 0 0 132 1 2 0 0 0 0 71 2 0 0 11 0
                          72 2 0 0 73 0 1 2 0 0 132 0 1))
                    <19 (|makeByteWordVec2| #<vector 0000000001723f00>)
                    19> (GETDATABASE |Integer| CONSTRUCTORKIND)
                    <19 (GETDATABASE |domain|)
                    19> (GETL |load| |TimeTotal|)
                    <19 (GETL 0.0)
                    19> (GETL |gc| |TimeTotal|)
                    <19 (GETL 0.0)
                    19> (PUT |gc| |TimeTotal| 0.0)
                    <19 (PUT 0.0)
                    19> (PUT |load| |TimeTotal| 0.0)
                    <19 (PUT 0.0)
                    <18 (|loadLibNoUpdate| T)
                    <17 (|loadLib| T)
                    17> (HPUT #<hash-table 000000000105e810> |Integer| 
                         ((NIL 1 . #<vector 0000000001723ed0>)))
                    <17 (HPUT ((NIL 1 . #<vector 0000000001723ed0>)))
                    17> (GETDATABASE |Integer| CONSTRUCTORKIND)
                    <17 (GETDATABASE |domain|)
                    17> (GETL |Integer| |infovec|)
                    <17 (GETL (#<vector 0000000001ab1780> 
                               #<vector 0000000001ab1750> ((|infinite| . 0)
                               (|noetherian| . 0) (|canonicalsClosed| . 0) 
                               (|canonical| . 0) (|canonicalUnitNormal| . 0) 
                               (|multiplicativeValuation| . 0) 
                               (|noZeroDivisors| . 0) 
                               ((|commutative| "*") . 0) (|rightUnitary| . 0) 
                               (|leftUnitary| . 0) (|unitsKnown| . 0)) 
                               (#<bit-vector 0000000001723f60> 
                                #<vector 0000000001723fc0> 
                                #<vector 0000000001723f90>
                                . #<vector 0000000001723f00>)
                           |lookupComplete|))
                    17> (HPUT #<hash-table 000000000105e810> |Integer| 
                         ((NIL 1 . #<vector 0000000001723ed0>)))
                    <17 (HPUT ((NIL 1 . #<vector 0000000001723ed0>)))
                    17> (|lookupInDomainVector| |coerce| ((|OutputForm|) $) 
                         #<vector 0000000001723ed0> #<vector 0000000001ab1d50>)
                    18> (GETDATABASE |Integer| CONSTRUCTORKIND)
                    <18 (GETDATABASE |domain|)
                    18> (PNAME |Integer|)
                    <18 (PNAME "Integer")
                    18> (PNAME |Integer|)
                    <18 (PNAME "Integer")
                    18> (GETDATABASE |OutputForm| COSIG)
                    <18 (GETDATABASE (NIL))
                    18> (GETDATABASE |PositiveInteger| CONSTRUCTORKIND)
                    <18 (GETDATABASE |domain|)
                    <17 (|lookupInDomainVector| 
                         (#<compiled-function |INT;coerce;$Of;16|> 
                          . #<vector 0000000001723ed0>))
                    <16 (|lookupInDomainVector|
                         (#<compiled-function |INT;coerce;$Of;16|> 
                          . #<vector 0000000001723ed0>))
                    <15 (|lookupInDomainVector| 
                         (#<compiled-function |INT;coerce;$Of;16|> 
                          . #<vector 0000000001723ed0>))
                    <14 (|oldCompLookup| 
                         (#<compiled-function |INT;coerce;$Of;16|> 
                          . #<vector 0000000001723ed0>))
                    <13 (|basicLookup| 
                         (#<compiled-function |INT;coerce;$Of;16|> 
                          . #<vector 0000000001723ed0>))
                    <12 (|compiledLookup| 
                         (#<compiled-function |INT;coerce;$Of;16|> 
                          . #<vector 0000000001723ed0>))

"TPD:INT:coerce(x):OutputForm" 
\end{verbatim}

\begin{verbatim}
                    12> (GETDATABASE |Integer| CONSTRUCTORKIND)
                    <12 (GETDATABASE |domain|)
                    12> (GETL |OutputForm| LOADED)
                    <12 (GETL NIL)
                    12> (|loadLib| |OutputForm|)
                    13> (GETL |print| |TimeTotal|)
                    <13 (GETL 0.0)
                    13> (GETL |gc| |TimeTotal|)
                    <13 (GETL 0.0)
                    13> (PUT |gc| |TimeTotal| 0.0)
                    <13 (PUT 0.0)
                    13> (PUT |print| |TimeTotal| 0.0)
                    <13 (PUT 0.0)
                    13> (GETDATABASE |OutputForm| OBJECT)
                    <13 (GETDATABASE 
                         "/home/daly/noise/mnt/ubuntu/algebra/OUTFORM.o")
                    13> (|pathnameDirectory| 
                         "/home/daly/noise/mnt/ubuntu/algebra/OUTFORM.o")
                    14> (|pathname| 
                         "/home/daly/noise/mnt/ubuntu/algebra/OUTFORM.o")
                    <14 (|pathname| 
                         #p"/home/daly/noise/mnt/ubuntu/algebra/OUTFORM.o")
                    <13 (|pathnameDirectory| 
                         "/home/daly/noise/mnt/ubuntu/algebra/")
                    13> (|isSystemDirectory| 
                         "/home/daly/noise/mnt/ubuntu/algebra/")
                    <13 (|isSystemDirectory| T)
                    13> (|loadLibNoUpdate| |OutputForm| |OutputForm| 
                         "/home/daly/noise/mnt/ubuntu/algebra/OUTFORM.o")
                    14> (GETDATABASE |OutputForm| CONSTRUCTORKIND)
                    <14 (GETDATABASE |domain|)
                    14> (|makeByteWordVec2| 1 (0 0 0))
                    <14 (|makeByteWordVec2| #<bit-vector 0000000001723c90>)
                    14> (|makeByteWordVec2| 144 
                         (1 10 9 0 11 0 25 0 26 2 10 0 0 25 27 2 10 0 25 0 28
                          2 19 0 0 0 36 2 19 0 0 0 37 2 19 9 0 0 46 1 6 0 0 56
                          2 6 0 0 0 57 1 6 9 0 69 1 6 0 0 70 1 6 2 0 71 1 6 73
                          0 74 1 19 9 0 75 2 76 0 0 0 77 1 76 0 0 105 1 25 0
                          10 114 2 10 0 73 25 115 1 73 9 0 128 2 73 9 0 0 129
                          1 131 10 130 132 1 10 0 0 133 2 0 9 0 0 1 2 0 0 0 0
                          120 0 0 19 35 1 0 19 0 30 1 0 0 19 47 1 0 0 52 80 2
                          0 0 0 0 48 2 0 0 0 52 78 1 0 19 0 33 2 0 0 0 0 66 2
                          0 0 0 0 136 3 0 0 0 0 0 137 1 0 0 0 135 1 0 19 0 32
                          2 0 0 0 0 65 1 0 0 0 109 2 0 0 0 0 124 1 0 0 52 55
                          2 0 0 0 52 72 2 0 0 19 19 49 1 0 0 0 121 2 0 0 0 0
                          122 1 0 0 0 45 2 0 0 0 19 42 2 0 0 0 0 93 2 0 0 0 0
                          127 1 0 0 0 110 2 0 0 0 0 94 3 0 0 0 0 0 140 1 0 0
                          0 138 2 0 0 0 0 139 1 0 7 0 8 2 0 0 0 73 117 1 0 0
                          0 113 2 0 0 0 0 68 2 0 0 0 0 67 2 0 0 0 52 104 2 0
                          0 0 0 108 1 0 0 52 53 1 0 0 52 64 1 0 0 0 63 2 0 0
                          0 0 118 1 0 0 0 111 2 0 0 0 0 123 1 0 0 10 29 1 0 0
                          23 24 1 0 0 21 22 1 0 0 19 20 2 0 0 0 0 97 1 0 0 0
                          98 1 0 7 10 14 1 0 0 10 13 1 0 0 50 51 1 0 0 0 44 2
                          0 0 0 19 41 1 0 10 0 1 2 0 0 0 0 126 3 0 0 0 0 0
                          143 2 0 0 0 0 142 1 0 0 0 141 1 0 9 0 102 2 0 0 0
                          52 106 3 0 0 0 0 0 107 1 0 0 19 38 0 0 19 34 1 0 19
                          0 31 1 0 0 52 79 2 0 0 0 0 39 1 0 144 0 1 2 0 0 0 0
                          95 0 0 0 12 2 0 0 0 52 103 2 0 0 0 73 116 1 0 0 0
                          112 2 0 0 0 0 92 2 0 0 0 73 134 1 0 0 52 54 1 0 17
                          0 18 1 0 0 0 43 2 0 0 0 19 40 1 0 0 0 61 1 0 0 52
                          62 1 0 0 52 60 1 0 0 0 59 1 0 0 0 119 1 0 0 52 58 2
                          0 0 0 0 101 2 0 0 0 0 125 2 0 0 0 0 96 2 0 0 0 0 81
                          1 0 0 0 100 2 0 0 0 0 99 2 0 0 0 0 85 2 0 0 0 0 83
                          2 0 0 0 0 16 2 0 9 0 0 15 2 0 0 0 0 84 2 0 0 0 0 82
                          2 0 0 0 0 90 1 0 0 0 88 2 0 0 0 0 87 2 0 0 0 0 86 2
                          0 0 0 0 91 2 0 0 0 0 89))
                    <14 (|makeByteWordVec2| #<vector 0000000001723c60>)
                    14> (GETDATABASE |OutputForm| CONSTRUCTORKIND)
                    <14 (GETDATABASE |domain|)
                    14> (GETL |load| |TimeTotal|)
                    <14 (GETL 0.0)
                    14> (GETL |gc| |TimeTotal|)
                    <14 (GETL 0.0)
                    14> (PUT |gc| |TimeTotal| 0.0)
                    <14 (PUT 0.0)
                    14> (PUT |load| |TimeTotal| 0.0)
                    <14 (PUT 0.0)
                    <13 (|loadLibNoUpdate| T)
                    <12 (|loadLib| T)
                    12> (HPUT #<hash-table 000000000105e810> |OutputForm| 
                         ((NIL 1 . #<vector 0000000001723c30>)))
                    <12 (HPUT ((NIL 1 . #<vector 0000000001723c30>)))
                    12> (GETDATABASE |OutputForm| CONSTRUCTORKIND)
                    <12 (GETDATABASE |domain|)
                    12> (GETL |OutputForm| |infovec|)
                    <12 (GETL (#<vector 0000000001723d80> 
                               #<vector 0000000001723d50> NIL 
                               (#<bit-vector 0000000001723c90> 
                                #<vector 0000000001723cf0> 
                                #<vector 0000000001723cc0> 
                                . #<vector 0000000001723c60>)
                           |lookupComplete|))
                    12> (GETL |List| LOADED)
                    <12 (GETL NIL)
                    12> (|loadLib| |List|)
                    13> (GETL |print| |TimeTotal|)
                    <13 (GETL 0.0)
                    13> (GETL |gc| |TimeTotal|)
                    <13 (GETL 0.0)
                    13> (PUT |gc| |TimeTotal| 0.0)
                    <13 (PUT 0.0)
                    13> (PUT |print| |TimeTotal| 0.0)
                    <13 (PUT 0.0)
                    13> (GETDATABASE |List| OBJECT)
                    <13 (GETDATABASE 
                         "/home/daly/noise/mnt/ubuntu/algebra/LIST.o")
                    13> (|pathnameDirectory| 
                         "/home/daly/noise/mnt/ubuntu/algebra/LIST.o")
                    14> (|pathname| 
                         "/home/daly/noise/mnt/ubuntu/algebra/LIST.o")
                    <14 (|pathname| 
                         #p"/home/daly/noise/mnt/ubuntu/algebra/LIST.o")
                    <13 (|pathnameDirectory| 
                         "/home/daly/noise/mnt/ubuntu/algebra/")
                    13> (|isSystemDirectory| 
                         "/home/daly/noise/mnt/ubuntu/algebra/")
                    <13 (|isSystemDirectory| T)
                    13> (|loadLibNoUpdate| |List| |List| 
                         "/home/daly/noise/mnt/ubuntu/algebra/LIST.o")
                    14> (GETDATABASE |List| CONSTRUCTORKIND)
                    <14 (GETDATABASE |domain|)
                    14> (|makeByteWordVec2| 8 
                         (0 0 0 0 0 0 0 0 0 0 3 0 0 8 4 0 0 8 1 2 4 5))
                    <14 (|makeByteWordVec2| #<vector 0000000001723a50>)
                    14> (|makeByteWordVec2| 51 
                         (1 13 12 0 14 3 13 12 0 15 15 16 1 0 6 0 17 3 6 12
                          13 0 8 18 1 0 0 0 19 1 13 12 0 20 0 21 0 22 2 13 0
                          15 21 23 1 13 12 0 24 1 13 12 0 25 1 13 12 0 26 1
                          0 15 0 27 2 0 15 0 8 28 2 0 12 13 0 29 3 0 12 13 0
                          8 30 2 0 0 0 0 31 1 0 0 0 32 2 0 0 0 0 33 0 0 0 34
                          1 0 8 0 35 2 0 8 6 0 36 2 0 0 0 0 37 2 0 6 0 38 39
                          2 0 0 6 0 40 2 0 0 0 0 41 1 42 0 15 43 1 44 0 42 45
                          1 6 44 0 46 2 47 0 44 0 48 1 44 0 49 50 1 0 44 0 51
                          2 1 0 0 0 33 2 1 0 0 0 37 2 1 0 0 0 41 1 0 0 0 19 1
                          1 0 0 32 1 0 8 0 9 0 0 0 7 2 1 8 6 0 36 1 0 6 0 17
                          1 0 8 0 35 0 0 0 34 2 0 6 0 38 39 1 2 44 0 51 2 0 0
                          6 0 10 2 0 0 6 0 40 2 0 0 0 0 31 2 0 0 0 0 11 3 5 12
                          13 0 8 30 2 5 12 13 0 29 1 5 15 0 27 2 5 15 0 8 28))
                    <14 (|makeByteWordVec2| #<vector 0000000001723a20>)
                    14> (GETDATABASE |List| CONSTRUCTORKIND)
                    <14 (GETDATABASE |domain|)
                    14> (GETL |load| |TimeTotal|)
                    <14 (GETL 0.0)
                    14> (GETL |gc| |TimeTotal|)
                    <14 (GETL 0.0)
                    14> (PUT |gc| |TimeTotal| 0.0)
                    <14 (PUT 0.0)
                    14> (PUT |load| |TimeTotal| 0.0)
                    <14 (PUT 0.0)
                    <13 (|loadLibNoUpdate| T)
                    <12 (|loadLib| T)
                    12> (GETDATABASE |OutputForm| CONSTRUCTORKIND)
                    <12 (GETDATABASE |domain|)
                    12> (GETDATABASE |OutputForm| CONSTRUCTORKIND)
                    <12 (GETDATABASE |domain|)
                    12> (GETDATABASE |OutputForm| CONSTRUCTORKIND)
                    <12 (GETDATABASE |domain|)
                    12> (PNAME |OutputForm|)
                    <12 (PNAME "OutputForm")
                    12> (PNAME |OutputForm|)
                    <12 (PNAME "OutputForm")
                    12> (GETDATABASE |SetCategory| COSIG)
                    <12 (GETDATABASE (NIL))
                    12> (GETDATABASE |OutputForm| CONSTRUCTORKIND)
                    <12 (GETDATABASE |domain|)
                    12> (PNAME |OutputForm|)
                    <12 (PNAME "OutputForm")
                    12> (PNAME |OutputForm|)
                    <12 (PNAME "OutputForm")
                    12> (GETDATABASE |OutputForm| CONSTRUCTORKIND)
                    <12 (GETDATABASE |domain|)
                    12> (PNAME |OutputForm|)
                    <12 (PNAME "OutputForm")
                    12> (PNAME |OutputForm|)
                    <12 (PNAME "OutputForm")
                    12> (GETDATABASE |OutputForm| CONSTRUCTORKIND)
                    <12 (GETDATABASE |domain|)
                    12> (PNAME |OutputForm|)
                    <12 (PNAME "OutputForm")
                    12> (PNAME |OutputForm|)
                    <12 (PNAME "OutputForm")
                    12> (GETDATABASE |SetCategory| COSIG)
                    <12 (GETDATABASE (NIL))
                    12> (GETDATABASE |OutputForm| CONSTRUCTORKIND)
                    <12 (GETDATABASE |domain|)
                    12> (PNAME |OutputForm|)
                    <12 (PNAME "OutputForm")
                    12> (PNAME |OutputForm|)
                    <12 (PNAME "OutputForm")
                    12> (GETDATABASE |Integer| CONSTRUCTORKIND)
                    <12 (GETDATABASE |domain|)
                    12> (PNAME |Integer|)
                    <12 (PNAME "Integer")
                    12> (PNAME |Integer|)
                    <12 (PNAME "Integer")
                    12> (GETDATABASE |OrderedSet| COSIG)
                    <12 (GETDATABASE (NIL))
                    12> (GETDATABASE |OutputForm| CONSTRUCTORKIND)
                    <12 (GETDATABASE |domain|)
                    12> (GETDATABASE |OutputForm| CONSTRUCTORKIND)
                    <12 (GETDATABASE |domain|)
                    12> (PNAME |OutputForm|)
                    <12 (PNAME "OutputForm")
                    12> (PNAME |OutputForm|)
                    <12 (PNAME "OutputForm")
                    12> (GETDATABASE |OutputForm| CONSTRUCTORKIND)
                    <12 (GETDATABASE |domain|)
                    12> (GETDATABASE |OutputForm| CONSTRUCTORKIND)
                    <12 (GETDATABASE |domain|)
                    12> (PNAME |OutputForm|)
                    <12 (PNAME "OutputForm")
                    12> (PNAME |OutputForm|)
                    <12 (PNAME "OutputForm")
                    12> (GETDATABASE |OutputForm| CONSTRUCTORKIND)
                    <12 (GETDATABASE |domain|)
                    12> (GETDATABASE |OutputForm| CONSTRUCTORKIND)
                    <12 (GETDATABASE |domain|)
                    12> (PNAME |OutputForm|)
                    <12 (PNAME "OutputForm")
                    12> (PNAME |OutputForm|)
                    <12 (PNAME "OutputForm")
                    12> (HPUT #<hash-table 000000000105e810> |List| 
                         ((((|OutputForm|)) 1 . #<vector 00000000017239f0>)))
                    <12 (HPUT ((((|OutputForm|)) 1 
                               . #<vector 00000000017239f0>)))
                    12> (GETDATABASE |List| CONSTRUCTORKIND)
                    <12 (GETDATABASE |domain|)
                    12> (GETL |List| |infovec|)
                    <12 (GETL (#<vector 0000000001723b10> 
                               #<vector 0000000001723ae0> 
                               ((|shallowlyMutable| . 0) 
                                (|finiteAggregate| . 0)) 
                                (#<vector 0000000001723a50> 
                                 #<vector 0000000001723ab0> 
                                 #<vector 0000000001723a80> 
                                 . #<vector 0000000001723a20>)
                         |lookupIncomplete|))
                    12> (HPUT #<hash-table 000000000105e810> |OutputForm| 
                          ((NIL 1 . #<vector 0000000001723c30>)))
                    <12 (HPUT ((NIL 1 . #<vector 0000000001723c30>)))
                    12> (GETDATABASE |Integer| COSIG)
                    <12 (GETDATABASE (NIL))
                    12> (|basicLookup| |outputForm| ($ (|Integer|)) 
                         #<vector 0000000001723c30> #<vector 0000000001723c30>)
                    13> (|oldCompLookup| |outputForm| ($ (|Integer|)) 
                         #<vector 0000000001723c30> #<vector 0000000001723c30>)
                    14> (|lookupInDomainVector| |outputForm| ($ (|Integer|)) 
                         #<vector 0000000001723c30> #<vector 0000000001723c30>)
                    15> (GETDATABASE |OutputForm| CONSTRUCTORKIND)
                    <15 (GETDATABASE |domain|)
                    15> (GETDATABASE |OutputForm| CONSTRUCTORKIND)
                    <15 (GETDATABASE |domain|)
                    15> (GETDATABASE |OutputForm| CONSTRUCTORKIND)
                    <15 (GETDATABASE |domain|)
                    15> (GETDATABASE |OutputForm| CONSTRUCTORKIND)
                    <15 (GETDATABASE |domain|)
                    15> (GETDATABASE |Integer| COSIG)
                    <15 (GETDATABASE (NIL))
                    <14 (|lookupInDomainVector| 
                         (#<compiled-function |OUTFORM;outputForm;I$;7|> 
                          . #<vector 0000000001723c30>))
                    <13 (|oldCompLookup| 
                         (#<compiled-function |OUTFORM;outputForm;I$;7|> 
                          . #<vector 0000000001723c30>))
                    <12 (|basicLookup| 
                         (#<compiled-function |OUTFORM;outputForm;I$;7|> 
                          . #<vector 0000000001723c30>))

"TPD:OUTFORM:outputForm n"
\end{verbatim}

\begin{verbatim} 
                    12> (GETL |print| |TimeTotal|)
                    <12 (GETL 0.0)
                    12> (GETL |gc| |TimeTotal|)
                    <12 (GETL 0.0)
                    12> (PUT |gc| |TimeTotal| 0.0)
                    <12 (PUT 0.0)
                    12> (PUT |print| |TimeTotal| 0.0)
                    <12 (PUT 0.0)
                    12> (|member| 1 ("failed" "nil" "prime" "sqfr" "irred"))
                    <12 (|member| NIL)
                    12> (|member| EQUATNUM (SLASH OVER))
                    <12 (|member| NIL)
                    12> (GETL EQUATNUM |Led|)
                    <12 (GETL (|dummy| |dummy| 10000 0))
                    12> (|member| EQUATNUM (SLASH OVER))
                    <12 (|member| NIL)
                    12> (GETL EQUATNUM |Led|)
                    <12 (GETL (|dummy| |dummy| 10000 0))
                    12> (GETL EQUATNUM INFIXOP)
                    <12 (GETL "  ")
                    12> (GETL EQUATNUM WIDTH)
                    <12 (GETL NIL)
                    12> (GETL EQUATNUM APP)
                    <12 (GETL NIL)
                    12> (|member| EQUATNUM (SLASH OVER))
                    <12 (|member| NIL)
                    12> (GETL EQUATNUM |Led|)
                    <12 (GETL (|dummy| |dummy| 10000 0))
                    12> (|member| EQUATNUM (SLASH OVER))
                    <12 (|member| NIL)
                    12> (GETL EQUATNUM |Led|)
                    <12 (GETL (|dummy| |dummy| 10000 0))
                    12> (GETL EQUATNUM INFIXOP)
                    <12 (GETL "  ")
                    12> (GETL EQUATNUM SUPERSPAN)
                    <12 (GETL NIL)
                    12> (GETL EQUATNUM SUBSPAN)
                    <12 (GETL NIL)
   (1)  1
\end{verbatim}

\begin{verbatim}
                    12> (|putHist| % |value| ((|PositiveInteger|) . 1) ((NIL)))
                    13> (|recordNewValue| % |value| ((|PositiveInteger|) . 1))
                    14> (GETL |print| |TimeTotal|)
                    <14 (GETL 0.0)
                    14> (GETL |gc| |TimeTotal|)
                    <14 (GETL 0.0)
                    14> (PUT |gc| |TimeTotal| 0.0)
                    <14 (PUT 0.0)
                    14> (PUT |print| |TimeTotal| 0.0)
                    <14 (PUT 0.0)
                    14> (|recordNewValue0| % |value| ((|PositiveInteger|) . 1))
                    <14 (|recordNewValue0| 
                         ((% (|value| (|PositiveInteger|) . 1))))
                    14> (GETL |history| |TimeTotal|)
                    <14 (GETL 0.0)
                    14> (GETL |gc| |TimeTotal|)
                    <14 (GETL 0.0)
                    14> (PUT |gc| |TimeTotal| 0.0)
                    <14 (PUT 0.0)
                    14> (PUT |history| |TimeTotal| 0.0)
                    <14 (PUT 0.0)
                    <13 (|recordNewValue| |history|)
                    13> (|search| % ((NIL)))
                    14> (|searchCurrentEnv| % (NIL))
                    <14 (|searchCurrentEnv| NIL)
                    14> (|searchTailEnv| % NIL)
                    <14 (|searchTailEnv| NIL)
                    <13 (|search| NIL)
                    <12 (|putHist| ((((% (|value| (|PositiveInteger|) . 1))))))
                    12> (|printTypeAndTime| 1 (|PositiveInteger|))
                    14> (|sayKeyedMsg| "%rjon Type: %1p %rjoff" ((|PositiveInteger|)))
                    15> (|sayKeyedMsgLocal| "%rjon Type: %1p %rjoff" ((|PositiveInteger|)))
                    16> (|segmentKeyedMsg| " %rjon Type: %1p %rjoff")
                    <16 (|segmentKeyedMsg| ("%rjon" "Type:" "%1p" "%rjoff"))
                    16> (|member| "%rjon" (|%ceon| "%ceon"))
                    <16 (|member| NIL)
                    16> (|member| "%rjon" (|%rjon| "%rjon"))
                    <16 (|member| ("%rjon"))
                    16> (|member| "Type:" 
                         (|%ceoff| "%ceoff" |%rjoff| "%rjoff"))
                    <16 (|member| NIL)
                    16> (|member| "%1p" (|%ceoff| "%ceoff" |%rjoff| "%rjoff"))
                    <16 (|member| NIL)
                    16> (|member| "%rjoff" 
                         (|%ceoff| "%ceoff" |%rjoff| "%rjoff"))
                    <16 (|member| ("%rjoff"))
                    16> (|member| "%rj" (|%ceon| "%ceon"))
                    <16 (|member| NIL)
                    16> (|member| "%rj" (|%rjon| "%rjon"))
                    <16 (|member| NIL)
                    16> (|member| "Type:" (|%ceon| "%ceon"))
                    <16 (|member| NIL)
                    16> (|member| "Type:" (|%rjon| "%rjon"))
                    <16 (|member| NIL)
                    16> (|member| "%1p" (|%ceon| "%ceon"))
                    <16 (|member| NIL)
                    16> (|member| "%1p" (|%rjon| "%rjon"))
                    <16 (|member| NIL)
                    16> (DIGITP #\r)
                    <16 (DIGITP NIL)
                    16> (DIGITP #\1)
                    <16 (DIGITP 1)
                    16> (GETDATABASE |PositiveInteger| ABBREVIATION)
                    <16 (GETDATABASE PI)
                    16> (|member| "Type:" ("%n" |%n|))
                    <16 (|member| NIL)
                    16> (|member| "Type:" ("%y" |%y|))
                    <16 (|member| NIL)
                    16> (|member| "%rj" 
                         (" " | | "%" % |%b| |%d| |%l| |%i| |%u| %U |%n| |%x| 
                          |%ce| |%rj| "%U" "%b" "%d" "%l" "%i" "%u" "%U" "%n" 
                          "%x" "%ce" "%rj" [ |(| "[" "("))
                    <16 (|member| ("%rj" [ |(| "[" "("))
                    16> (|member| |PositiveInteger| ("%n" |%n|))
                    <16 (|member| NIL)
                    16> (|member| |PositiveInteger| ("%y" |%y|))
                    <16 (|member| NIL)
                    16> (|member| "Type:" 
                         (" " | | "%" % |%b| |%d| |%l| |%i| |%u| %U |%n| |%x|
                          |%ce| |%rj| "%U" "%b" "%d" "%l" "%i" "%u" "%U" "%n"
                           "%x" "%ce" "%rj" [ |(| "[" "("))
                    <16 (|member| NIL)
                    16> (SIZE "Type:")
                    <16 (SIZE 5)
                    16> (|member| |PositiveInteger|
                         (" " | | "%" % |%b| |%d| |%l| |%i| |%u| %U |%n| |%x|
                          |%ce| |%rj| "%U" "%b" "%d" "%l" "%i" "%u" "%U" "%n"
                          "%x" "%ce" "%rj" |.| |,| ! |:| |;| ? ] |)| "." ","
                          "!" ":" ";" "?" "]" ")"))
                    <16 (|member| NIL)
                    16> (|member| "%rj" (|%ce| "%ce" |%rj| "%rj"))
                    <16 (|member| ("%rj"))
                    16> (|sayMSG| (("%rj" "Type:" " " |PositiveInteger|)))
                    17> (SAYBRIGHTLY1 (("%rj" "Type:" " " |PositiveInteger|))
                          #<synonym stream to *TERMINAL-IO*>)
                    18> (BRIGHTPRINT (("%rj" "Type:" " " |PositiveInteger|)))
                    19> (|member| "%rj" ("%p" "%s"))
                    <19 (|member| NIL)
                    19> (|member| "Type:" (|%l| "%l"))
                    <19 (|member| NIL)
                    19> (|member| " " (|%l| "%l"))
                    <19 (|member| NIL)
                    19> (|member| |PositiveInteger| (|%l| "%l"))
                    <19 (|member| NIL)
                    19> (|member| "Type:" ("%b" "%d" |%b| |%d|))
                    <19 (|member| NIL)
                    19> (|member| "Type:" ("%l" |%l|))
                    <19 (|member| NIL)
                    19> (|member| " " ("%b" "%d" |%b| |%d|))
                    <19 (|member| NIL)
                    19> (|member| " " ("%l" |%l|))
                    <19 (|member| NIL)
                    19> (|member| |PositiveInteger| ("%b" "%d" |%b| |%d|))
                    <19 (|member| NIL)
                    19> (|member| |PositiveInteger| ("%l" |%l|))
                    <19 (|member| NIL)
                    19> (PNAME |PositiveInteger|)
                    <19 (PNAME "PositiveInteger")
                    19> (|fillerSpaces| 56 " ")
                    <19 (|fillerSpaces| 
                    "                                                        ")
                                                        Type: 
                    19> (PNAME |PositiveInteger|)
                    <19 (PNAME "PositiveInteger")
PositiveInteger     
\end{verbatim}

\begin{verbatim}
                    <18 (BRIGHTPRINT NIL)
                    <17 (SAYBRIGHTLY1 NIL)
                    <16 (|sayMSG| NIL)
                    <15 (|sayKeyedMsgLocal| NIL)
                    <14 (|sayKeyedMsg| NIL)
                    <12 (|printTypeAndTime| NIL)
                    <11 (|recordAndPrint| |done|)
                    11> (recordFrame |normal|)
                    12> (|diffAlist| 
                         ((% (|value| (|PositiveInteger|) . 1))) NIL)
                    <12 (|diffAlist| ((% (|value|))))
                    <11 (recordFrame ((% (|value|))))
                    11> (GETL |print| |TimeTotal|)
                    <11 (GETL 0.0)
                    11> (GETL |gc| |TimeTotal|)
                    <11 (GETL 0.0)
                    11> (PUT |gc| |TimeTotal| 0.0)
                    <11 (PUT 0.0)
                    11> (PUT |print| |TimeTotal| 0.0)
                    <11 (PUT 0.0)
                    <10 (|processInteractive1| ((|PositiveInteger|) . 1))
                    10> (|writeHistModesAndValues|)
                    11> (|putHist| % |value| 
                        #0=((|PositiveInteger|) . 1) ((((% (|value| . #0#))))))
                    12> (|recordNewValue| % |value| ((|PositiveInteger|) . 1))
                    13> (GETL |other| |TimeTotal|)
                    <13 (GETL 0.0)
                    13> (GETL |gc| |TimeTotal|)
                    <13 (GETL 0.0)
                    13> (PUT |gc| |TimeTotal| 0.0)
                    <13 (PUT 0.0)
                    13> (PUT |other| |TimeTotal| 0.0)
                    <13 (PUT 0.0)
                    13> (|recordNewValue0| % |value| ((|PositiveInteger|) . 1))
                    <13 (|recordNewValue0| (|value| (|PositiveInteger|) . 1))
                    13> (GETL |history| |TimeTotal|)
                    <13 (GETL 0.0)
                    13> (GETL |gc| |TimeTotal|)
                    <13 (GETL 0.0)
                    13> (PUT |gc| |TimeTotal| 0.0)
                    <13 (PUT 0.0)
                    13> (PUT |history| |TimeTotal| 0.0)
                    <13 (PUT 0.0)
                    <12 (|recordNewValue| |history|)
                    12> (|search| % 
                         ((((% (|value| (|PositiveInteger|) . 1))))))
                    13> (|searchCurrentEnv| % 
                         (((% (|value| (|PositiveInteger|) . 1)))))
                    <13 (|searchCurrentEnv| 
                         ((|value| (|PositiveInteger|) . 1)))
                    <12 (|search| ((|value| (|PositiveInteger|) . 1)))
                    <11 (|putHist| ((((% (|value| (|PositiveInteger|) . 1))))))
                    <10 (|writeHistModesAndValues| NIL)
                    10> (|updateHist|)
                    11> (GETL |other| |TimeTotal|)
                    <11 (GETL 0.0)
                    11> (GETL |gc| |TimeTotal|)
                    <11 (GETL 0.0)
                    11> (PUT |gc| |TimeTotal| 0.0)
                    <11 (PUT 0.0)
                    11> (PUT |other| |TimeTotal| 0.0)
                    <11 (PUT 0.0)
                    11> (|updateInCoreHist|)
                    <11 (|updateInCoreHist| 1)
                    11> (|writeHiFi|)
                    <11 (|writeHiFi| 
                         ((1 (% (|value| (|PositiveInteger|) . 1)))))
                    11> (|disableHist|)
                    <11 (|disableHist| NIL)
                    11> (|updateCurrentInterpreterFrame|)
                    12> (|createCurrentInterpreterFrame|)
                    <12 (|createCurrentInterpreterFrame| 
                         (|frame0| 
                          ((((% (|value| . #0=((|PositiveInteger|) . 1)))))) 
                          2 T 
                          #1=(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL 
                              NIL NIL NIL NIL NIL NIL NIL NIL NIL . #1#)
                          20 1 NIL ((1 (% (|value| . #0#)))) 
                          #<vector 0000000000fa5cc0>))
                    12> (|updateFromCurrentInterpreterFrame|)
                    <12 (|updateFromCurrentInterpreterFrame| NIL)
                    <11 (|updateCurrentInterpreterFrame| NIL)
                    11> (GETL |history| |TimeTotal|)
                    <11 (GETL 0.0)
                    11> (GETL |gc| |TimeTotal|)
                    <11 (GETL 0.0)
                    11> (PUT |gc| |TimeTotal| 0.0)
                    <11 (PUT 0.0)
                    11> (PUT |history| |TimeTotal| 0.0)
                    <11 (PUT 0.0)
                    <10 (|updateHist| |history|)
                  <9 (|processInteractive| ((|PositiveInteger|) . 1))
                <8 (|intInterpretPform| ((|PositiveInteger|) . 1))
                8> (|ncPutQ| 
                    ((|carrier| (|ok?| . T) 
                      (|ptreePremacro| 
                        . #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                               . "1"))
                      (|ptree| . #0#) 
                     (|lines| ((#1# . 1) . "1")) 
                     (|messages|) 
                     (|stepNumber| . 1))) |value| 
                     ((|PositiveInteger|) . 1))
                  9> (|ncAlist| 
                      ((|carrier| (|ok?| . T) 
                       (|ptreePremacro| 
                        . #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                               . "1")) 
                       (|ptree| . #0#) 
                       (|lines| ((#1# . 1) . "1")) 
                       (|messages|) 
                       (|stepNumber| . 1))))
                  <9 (|ncAlist| ((|ok?| . T) 
                      (|ptreePremacro| 
                       . #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                             . "1")) 
                      (|ptree| . #0#) 
                      (|lines| ((#1# . 1) . "1")) 
                      (|messages|) 
                      (|stepNumber| . 1)))
                  9> (|ncAlist| 
                      ((|carrier| (|ok?| . T) 
                       (|ptreePremacro| 
                        . #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                              . "1")) 
                       (|ptree| . #0#) 
                       (|lines| ((#1# . 1) . "1")) 
                       (|messages|) 
                       (|stepNumber| . 1))))
                  <9 (|ncAlist| 
                      ((|ok?| . T) 
                       (|ptreePremacro| 
                        . #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                               . "1")) 
                       (|ptree| . #0#) 
                       (|lines| ((#1# . 1) . "1")) 
                       (|messages|) 
                       (|stepNumber| . 1)))
                  9> (|ncTag| 
                      ((|carrier| (|ok?| . T) 
                       (|ptreePremacro| 
                        . #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0))
                              . "1")) 
                       (|ptree| . #0#) 
                       (|lines| ((#1# . 1) . "1")) 
                       (|messages|) 
                       (|stepNumber| . 1))))
                  <9 (|ncTag| |carrier|)
                <8 (|ncPutQ| ((|PositiveInteger|) . 1))
              <7 (|phInterpret| ((|PositiveInteger|) . 1))
              7> (|ncConversationPhase,wrapup| 
                  ((|carrier| (|value| (|PositiveInteger|) . 1) (|ok?| . T) 
                   (|ptreePremacro| 
                    . #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0)) 
                          . "1")) 
                   (|ptree| . #0#) 
                   (|lines| ((#1# . 1) . "1")) 
                   (|messages|) 
                   (|stepNumber| . 1))))
              <7 (|ncConversationPhase,wrapup| NIL)
            <6 (|ncConversationPhase| ((|PositiveInteger|) . 1))
            6> (|ncEltQ| 
                ((|carrier| (|value| (|PositiveInteger|) . 1) (|ok?| . T) 
                 (|ptreePremacro| 
                  . #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0)) 
                         . "1")) 
                 (|ptree| . #0#) 
                 (|lines| ((#1# . 1) . "1")) 
                 (|messages|) 
                 (|stepNumber| . 1))) 
                 |messages|)
              7> (|ncAlist| 
                  ((|carrier| (|value| (|PositiveInteger|) . 1) (|ok?| . T) 
                   (|ptreePremacro| 
                    . #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0)) 
                          . "1")) 
                   (|ptree| . #0#) 
                   (|lines| ((#1# . 1) . "1")) 
                   (|messages|) 
                   (|stepNumber| . 1))))
              <7 (|ncAlist| 
                  ((|value| (|PositiveInteger|) . 1) (|ok?| . T) 
                   (|ptreePremacro| 
                    . #0=((|integer| (|posn| #1=(0 "1" 1 1 "strings") . 0)) 
                          . "1")) 
                   (|ptree| . #0#) 
                   (|lines| ((#1# . 1) . "1")) 
                   (|messages|) 
                   (|stepNumber| . 1)))
            <6 (|ncEltQ| NIL)
          <5 (|intloopSpadProcess,interp| NIL)
        <4 (|intloopSpadProcess| 2)
\end{verbatim}
\begin{verbatim}
        4> (|StreamNull| 
            (|nonnullstream| #0=|incAppend1| NIL 
             (|nonnullstream| #2=|next1| |ncloopParse| 
              (|nonnullstream| #0# NIL 
               (|nonnullstream| #2# |lineoftoks| (|nullstream|))))))
          5> (|incAppend1| NIL 
              (|nonnullstream| #0=|next1| |ncloopParse| 
               (|nonnullstream| |incAppend1| NIL 
                (|nonnullstream| #0# |lineoftoks| (|nullstream|)))))
            6> (|StreamNull| NIL)
            <6 (|StreamNull| T)
            6> (|StreamNull| 
                (|nonnullstream| #0=|next1| |ncloopParse| 
                 (|nonnullstream| |incAppend1| NIL 
                  (|nonnullstream| #0# |lineoftoks| (|nullstream|)))))
              7> (|next1| |ncloopParse| 
                  (|nonnullstream| |incAppend1| NIL 
                   (|nonnullstream| |next1| |lineoftoks| (|nullstream|))))
                8> (|StreamNull| 
                    (|nonnullstream| |incAppend1| NIL 
                     (|nonnullstream| |next1| |lineoftoks| (|nullstream|))))
                  9> (|incAppend1| NIL 
                      (|nonnullstream| |next1| |lineoftoks| (|nullstream|)))
                    10> (|StreamNull| NIL)
                    <10 (|StreamNull| T)
                    10> (|StreamNull| 
                         (|nonnullstream| |next1| |lineoftoks| (|nullstream|)))
                    11> (|next1| |lineoftoks| (|nullstream|))
                    12> (|StreamNull| (|nullstream|))
                    <12 (|StreamNull| T)
                    <11 (|next1| (|nullstream|))
                    <10 (|StreamNull| T)
                  <9 (|incAppend1| (|nullstream|))
                <8 (|StreamNull| T)
              <7 (|next1| (|nullstream|))
            <6 (|StreamNull| T)
          <5 (|incAppend1| (|nullstream|))
        <4 (|StreamNull| T)
      <3 (|intloopProcess| 2)
\end{verbatim}

\chapter{Axiom Details}
\section{Variables Used}
\section{Data Structures}
\section{Functions}
\defunsec{set-restart-hook}{Set the restart hook}
When a lisp image containing code is reloaded there is a hook to
allow a function to be called. In our case it is the restart
function which is the entry to the Axiom interpreter.
\sig{set-restart-hook}{Void}{'restart}
\begin{chunk}{defun set-restart-hook 0}
(defun set-restart-hook ()
  "Set the restart hook"
  #+KCL (setq system::*top-level-hook* 'restart)
  #+Lucid (setq boot::restart-hook 'restart)
  'restart
 )

\end{chunk}

\pagehead{restart function}{The restart function}
\pagepic{ps/v5restart.ps}{Restart}{1.00}
The restart function is the real root of the world. It sets up memory
if we are working in a GCL/akcl version of the system. 

The \verb|compiler::*compile-verbose*| flag has been set to nil globally.
We do not want to know about the microsteps of GCL's compile facility.

The \verb|compiler::*suppress-compiler-warnings*| flag has been set to t.
We do not care that certain generated variables are not used.

The \verb|compiler::*suppress-compiler-notes*| flag has been set to t.
We do not care that tail recursion occurs.

It sets the
current package to be the ``BOOT'' package which is the standard
package in which the interpreter runs. 

The \fnref{initroot} function sets global variables that depend on the
AXIOM shell variable. These are needed to find basic files like s2-us.msgs,
which contains the error message text.

The \fnref{openserver} function tried to set up the socket connection
used for things like hyperdoc. The \verb|$openServerIfTrue| variable
starts true, which implies trying to start a server.

Axiom has multiple frames that contain independent information about a
computation. There can be several frames at any one time and you can 
shift back and forth between the frames. By default, the system starts
in ``frame0'' (try the \verb|)frame names| command). See the Frame
Mechanism chapter (\ref{TheFrameMechanism} page~\pageref{TheFrameMechanism}).

The \varref{printLoadMsgs} variable controls whether load messages will
be output as library routines are loaded. We disnable this by default.
It can be changed by using \verb|)set message autoload|.

The \varref{current-directory} variable is set to the current directory.
This is used by the \verb|)cd| function and some of the compile routines.

The \fnref{statisticsInitialization} function initializes variables
used to collect statistics. Currently, only the garbage collector
information is initialized.

We test {\bfref{*ThisIsARunningSystem*}}. If this variable is true
then we are restarting from a previously running system and we
do not want to reset all of the user variables.

\calls{restart}{init-memory-config}
\calls{restart}{initroot}
\calls{restart}{openserver}
\calls{restart}{makeInitialModemapFrame}
\calls{restart}{get-current-directory}
\calls{restart}{statisticsInitialization}
\calls{restart}{initHist}
\calls{restart}{initializeInterpreterFrameRing}
\calls{restart}{spadStartUpMsgs}
\calls{restart}{restart0}
\calls{restart}{readSpadProfileIfThere}
\calls{restart}{spad}
\usesdollar{restart}{openServerIfTrue}
\usesdollar{restart}{SpadServerName}
\usesdollar{restart}{SpadServer}
\usesdollar{restart}{IOindex}
\usesdollar{restart}{InteractiveFrame}
\usesdollar{restart}{printLoadMsgs}
\usesdollar{restart}{current-directory}
\usesdollar{restart}{displayStartMsgs}
\usesdollar{restart}{currentLine}
\begin{chunk}{defun restart}
(defun restart ()
  (declare (special $openServerIfTrue $SpadServerName |$SpadServer|
    |$IOindex| |$InteractiveFrame| |$printLoadMsgs| $current-directory
    |$displayStartMsgs| |$currentLine|))
#+:akcl
  (init-memory-config :cons 1024 :fixnum 200 :symbol 500 :package 8
    :array 800 :string 1024 :cfun 200 :cpages 6000 :rpages 2000 :hole 4000)
#+:akcl (setq compiler::*compile-verbose* nil)
#+:akcl (setq compiler::*suppress-compiler-warnings* t)
#+:akcl (setq compiler::*suppress-compiler-notes* t)
#+:akcl (setq si::*system-directory* "")
  (in-package "BOOT")
  (initroot)
#+:akcl
  (when (and $openServerIfTrue (zerop (openserver $SpadServerName)))
    (setq $openServerIfTrue nil) 
    (setq |$SpadServer| t))
  (setq |$IOindex| 1)
  (setq |$printLoadMsgs| nil)
  (setq $current-directory (get-current-directory))
  (setq *default-pathname-defaults* (pathname $current-directory))
  (|statisticsInitialization|)
  (unless *ThisIsARunningSystem* 
   (setq |$InteractiveFrame| (|makeInitialModemapFrame|))
   (|initHist|)
   (|initializeInterpreterFrameRing|))
  (setq *ThisIsARunningSystem* t)
  (when |$displayStartMsgs| (|spadStartUpMsgs|))
  (setq |$currentLine| nil)
  (restart0)
  (|readSpadProfileIfThere|)
  (|spad|))

\end{chunk}

\defvar{localVars}
\begin{chunk}{initvars}
(defvar |$localVars| ())        ;checked by isType

\end{chunk}

\defun{restart0}{Non-interactive restarts}
\calls{restart0}{interpopen}
\calls{restart0}{operationopen}
\calls{restart0}{categoryopen}
\calls{restart0}{browseopen}
\begin{chunk}{defun restart0}
(defun restart0 ()
  (interpopen)      ;; open up the interpreter database
  (operationopen)   ;; all of the operations known to the system
  (categoryopen)    ;; answer hasCategory question
  (browseopen))

\end{chunk}

\defun{spadStartUpMsgs}{The startup banner messages}
\calls{spadStartUpMsgs}{fillerSpaces}
\calls{spadStartUpMsgs}{specialChar}
\calls{spadStartUpMsgs}{sayKeyedMsg}
\calls{spadStartUpMsgs}{sayMSG}
\usesdollar{spadStartUpMsgs}{msgAlist}
\usesdollar{spadStartUpMsgs}{opSysName}
\usesdollar{spadStartUpMsgs}{linelength}
\uses{spadStartUpMsgs}{*yearweek*}
\uses{spadStartUpMsgs}{*build-version*}
\begin{chunk}{defun spadStartUpMsgs}
(defun |spadStartUpMsgs| ()
 (let (bar)
 (declare (special |$msgAlist| |$opSysName| $linelength *yearweek*
                    *build-version*))
  (when (> $linelength 60)
   (setq bar (|fillerSpaces| $linelength (|specialChar| '|hbar|)))
   (|sayKeyedMsg| 
    (format nil "%ceon AXIOM Computer Algebra System %l Version: %1 %l ~
                 Timestamp: %2 %ceoff")
    (list *build-version* *yearweek*))
   (|sayMSG| bar)
   (say "   Issue )copyright to view copyright notices.")
   (say "   Issue )summary for a summary of useful system commands.")
   (say "   Issue )quit to leave AXIOM and return to shell.")
   (say "   Visit http://axiom-developer.org for more information")
   (|sayMSG| bar)
   (setq |$msgAlist| nil)
   (|sayMSG| '| |))))

\end{chunk}

\defun{fillerSpaces}{Make a vector of filler characters}
\calls{fillerSpaces}{ifcar}
\begin{chunk}{defun fillerSpaces}
(defun |fillerSpaces| (&rest arglist &aux charPart n)
  (setq n (car arglist))
  (setq charPart (cdr arglist))
  (if (<= n 0) 
   ""
   (make-string n :initial-element (character (or (ifcar charPart) " ")))))

\end{chunk}

\defdollar{PrintCompilerMessageIfTrue}
The \verb|$PrintCompilerMessageIfTrue| variable is set to NIL in spad.
\begin{chunk}{initvars}
(defvar |$PrintCompilerMessageIfTrue| nil)

\end{chunk}

\defunsec{spad}{Starts the interpreter but do not read in profiles}
\calls{spad}{setOutputAlgebra}
\calls{spad}{runspad}
\usesdollar{spad}{PrintCompilerMessageIfTrue}
\begin{chunk}{defun spad}
(defun |spad| () 
 "Starts the interpreter but do not read in profiles"
 (let (|$PrintCompilerMessageIfTrue|) 
  (declare (special |$PrintCompilerMessageIfTrue|)) 
  (setq |$PrintCompilerMessageIfTrue| nil) 
  (|setOutputAlgebra| '|%initialize%|) 
  (|runspad|) 
  '|EndOfSpad|))

\end{chunk}

\defdollar{quitTag}
\begin{chunk}{initvars}
(defvar |$quitTag| system::*quit-tag*)

\end{chunk}

\defun{runspad}{runspad}
\catches{runspad}{quitTag}
\catches{runspad}{coerceFailure}
\catches{runspad}{top-level}
\calls{runspad}{seq}
\calls{runspad}{exit}
\calls{runspad}{resetStackLimits}
\calls{runspad}{ncTopLevel}
\usesdollar{runspad}{quitTag}
\begin{chunk}{defun runspad}
(defun |runspad| () 
 (prog (mode) 
 (declare (special |$quitTag|))
  (return 
   (seq 
    (progn 
     (setq mode '|restart|) 
     (do () 
         ((null (eq mode '|restart|)) nil)
      (seq 
       (exit 
        (progn 
         (|resetStackLimits|) 
         (catch |$quitTag| 
          (catch '|coerceFailure| 
           (setq mode (catch '|top_level| (|ncTopLevel|))))))))))))))

\end{chunk}

\defun{resetStackLimits}{Reset the stack limits}
\calls{resetStackLimits}{reset-stack-limits}
\begin{chunk}{defun resetStackLimits 0}
(defun |resetStackLimits| () 
 "Reset the stack limits"
 (system:reset-stack-limits))

\end{chunk}

\chapter{Handling Terminal Input}
\section{Streams}
\defvar{curinstream}
The curinstream variable is set to the value of the 
\verb|*standard-input*| common lisp
variable in ncIntLoop. While not using the
``dollar'' convention this variable is still ``global''.
\begin{chunk}{initvars}
(defvar curinstream (make-synonym-stream '*standard-input*))

\end{chunk}

\defvar{curoutstream}
The curoutstream variable is set to the value of the 
\verb|*standard-output*| common lisp variable in ncIntLoop.
While not using the ``dollar'' convention this variable is still ``global''.
\begin{chunk}{initvars}
(defvar curoutstream (make-synonym-stream '*standard-output*))

\end{chunk}

\defvar{errorinstream}
\begin{chunk}{initvars}
(defvar errorinstream (make-synonym-stream '*terminal-io*))

\end{chunk}

\defvar{erroroutstream}
\begin{chunk}{initvars}
(defvar erroroutstream (make-synonym-stream '*terminal-io*))

\end{chunk}

\defvar{*eof*}
\begin{chunk}{initvars}
(defvar *eof* nil)

\end{chunk}

\defvar{*whitespace*}
\begin{chunk}{initvars}
(defvar *whitespace*
 '(#\Space #\Newline #\Tab #\Page #\Linefeed #\Return #\Backspace)
 "A list of characters used by string-trim considered as whitespace")

\end{chunk}

There are several different environments used in the interpreter:

{\bf \verb|$InteractiveFrame|} is the environment where the user
values are stored.  Any side effects of evaluation of a top-level
expression are stored in this environment.  It is always used as
the starting environment for interpretation.

{\bf \$e} is the name used for \verb|$InteractiveFrame| while interpreting.

{\bf \verb|$env|} is local environment used by the interpreter.
Only temporary information (such as types of local variables is
stored in \verb|$env|. It is thrown away after evaluation of each expression.

\defdollar{InteractiveMode}
\begin{chunk}{initvars}
(defvar |$InteractiveMode| (list (list nil)) "top level environment")

\end{chunk}

\defdollar{env}
\begin{chunk}{initvars}
(defvar |$env| nil "checked in isDomainValuedVariable")

\end{chunk}

\defdollar{e}
The \verb|$e| variable is set to the value of \verb|$InteractiveFrame|
which is set in restart to the value of the call to the
makeInitialModemapFrame function. This function simply returns a copy
of the variable \verb|$InitialModemapFrame|.

Prints out the value x which is of type m, and records the changes
in environment \verb|$e| into \verb|$InteractiveFrame|
Thus \verb|$e| is a copy of the variable \verb|$InitialModemapFrame|.

This variable is used in the undo mechanism.
\begin{chunk}{initvars}
(defvar |$e| nil "the environment?")

\end{chunk}

\defdollar{boot}
\begin{chunk}{initvars}
(defvar $boot nil)

\end{chunk}

\subsection{\$newspad}
The \verb|$newspad| is set to T in ncTopLevel.
\defdollar{newspad}
\begin{chunk}{initvars}
(defvar $newspad nil)

\end{chunk}

\defunsec{ncTopLevel}{Top-level read-parse-eval-print loop}
Top-level read-parse-eval-print loop for the interpreter.  Uses
the Bill Burge's parser.
\calls{ncTopLevel}{ncIntLoop}
\usesdollar{ncTopLevel}{e}
\usesdollar{ncTopLevel}{spad}
\usesdollar{ncTopLevel}{newspad}
\usesdollar{ncTopLevel}{boot}
\usesdollar{ncTopLevel}{InteractiveMode}
\usesdollar{ncTopLevel}{InteractiveFrame}
\uses{ncTopLevel}{*eof*}
\uses{ncTopLevel}{in-stream}
\begin{chunk}{defun ncTopLevel}
(defun |ncTopLevel| ()
 "Top-level read-parse-eval-print loop"
 (let (|$e| $spad $newspad $boot |$InteractiveMode| *eof* in-stream) 
  (declare (special |$e| $spad $newspad $boot |$InteractiveMode| *eof*
             in-stream |$InteractiveFrame|)) 
   (setq in-stream curinstream) 
   (setq *eof* nil) 
   (setq |$InteractiveMode| t) 
   (setq $boot nil) 
   (setq $newspad t) 
   (setq $spad t) 
   (setq |$e| |$InteractiveFrame|) 
   (|ncIntLoop|)))

\end{chunk}
\defun{ncIntLoop}{ncIntLoop}
\calls{ncIntLoop}{intloop}
\uses{ncIntLoop}{curinstream}
\uses{ncIntLoop}{curoutstream}
\begin{chunk}{defun ncIntLoop}
(defun |ncIntLoop| ()
  (let ((curinstream *standard-output*)
        (curoutstream *standard-input*))
    (declare (special curinstream curoutstream))
    (|intloop|)))

\end{chunk}

\defdollar{intTopLevel}
\begin{chunk}{initvars}
(defvar |$intTopLevel| '|top_level|)

\end{chunk}

\defdollar{intRestart}
\begin{chunk}{initvars}
(defvar |$intRestart| '|restart|)

\end{chunk}

\defun{intloop}{intloop}
Note that the SpadInterpretStream function uses a list of 
three strings as an argument. The values in the list seem to have
no use and can eventually be removed. 
\catches{intloop}{intTopLevel}
\calls{intloop}{SpadInterpretStream}
\calls{intloop}{resetStackLimits}
\usesdollar{intloop}{intTopLevel}
\usesdollar{intloop}{intRestart}
\begin{chunk}{defun intloop}
(defun |intloop| () 
 (prog (mode) 
  (declare (special |$intTopLevel| |$intRestart|)) 
   (return 
    (progn 
     (setq mode |$intRestart|) 
     ((lambda () 
       (loop 
        (cond 
         ((not (equal mode |$intRestart|))
           (return nil))
         (t
           (progn 
             (|resetStackLimits|) 
             (setq mode 
               (catch |$intTopLevel| 
                 (|SpadInterpretStream| 1 
                   (list 'tim  'daly '?) t)))))))))))))

\end{chunk}
\defdollar{ncMsgList}
\begin{chunk}{initvars}
(defvar |$ncMsgList| nil)

\end{chunk}

\defun{SpadInterpretStream}{SpadInterpretStream}
The SpadInterpretStream function takes three arguments
\begin{list}{}
\item str This is passed as an argument to intloopReadConsole
\item source This is the name of a source file but appears not
to be used. It is set to the list \verb|(tim daly ?)|.
\item \verb|interactive?| If this is false then various messages are 
suppressed and input does not use piles. If this is true then the
library loading routines might output messages and piles are expected
on input (as from a file).
\end{list}
System commands are handled by the function in the ``hook''
variable \verb|$systemCommandFunction| which
has the default function \verb|InterpExecuteSpadSystemCommand|.
Thus, when a system command is entered this function is called.

\defun{cmpnote}{GCL cmpnote function}
GCL keeps noting the fact that the compiler is performing tail-recursion.
Bill Schelter added this as a debugging tool for Axiom and it was never
removed. Patching the lisp code in the GCL build fails as the system
is actually built from the pre-compiled C code. Thus, we can only step
on this message after the fact. The cmpnote function is used nowhere
else in GCL so stepping on the function call seems best. We're unhappy
with this hack and will try to convince the GCL crowd to fix this.
\begin{chunk}{defun cmpnote}
#+:gcl (defun compiler::cmpnote (&rest x) (declare (ignore x)))

\end{chunk}

\defdollar{newcompErrorCount}
\begin{chunk}{initvars}
(defvar |$newcompErrorCount| 0)

\end{chunk}

\defdollar{nopos}
\begin{chunk}{initvars}
(defvar |$nopos| (list '|noposition|))

\end{chunk}
\calls{SpadInterpretStream}{mkprompt}
\calls{SpadInterpretStream}{intloopReadConsole}
\calls{SpadInterpretStream}{intloopInclude}
\usesdollar{SpadInterpretStream}{systemCommandFunction}
\usesdollar{SpadInterpretStream}{ncMsgList}
\usesdollar{SpadInterpretStream}{erMsgToss}
\usesdollar{SpadInterpretStream}{lastPos}
\usesdollar{SpadInterpretStream}{inclAssertions}
\usesdollar{SpadInterpretStream}{okToExecuteMachineCode}
\usesdollar{SpadInterpretStream}{newcompErrorCount}
\usesdollar{SpadInterpretStream}{libQuiet}
\usesdollar{SpadInterpretStream}{fn}
\usesdollar{SpadInterpretStream}{nopos}
\label{SpadInterpretStream}
\begin{chunk}{defun SpadInterpretStream}
(defun |SpadInterpretStream| (str source interactive?) 
 (let (|$systemCommandFunction| 
       |$ncMsgList| |$erMsgToss| |$lastPos| |$inclAssertions| 
       |$okToExecuteMachineCode| |$newcompErrorCount|
       |$libQuiet|)
  (declare (special 
            |$systemCommandFunction| |$ncMsgList| |$erMsgToss| |$lastPos| 
            |$inclAssertions| |$okToExecuteMachineCode| |$newcompErrorCount| 
            |$libQuiet| |$nopos|))
  (setq |$libQuiet| (null interactive?)) 
  (setq |$newcompErrorCount| 0) 
  (setq |$okToExecuteMachineCode| t) 
  (setq |$inclAssertions| (list 'aix '|CommonLisp|)) 
  (setq |$lastPos| |$nopos|) 
  (setq |$erMsgToss| nil) 
  (setq |$ncMsgList| nil) 
  (setq |$systemCommandFunction| #'|InterpExecuteSpadSystemCommand|) 
  (if interactive? 
   (progn 
     (princ (mkprompt)) 
     (|intloopReadConsole| "" str))
   (|intloopInclude| source 0))))

\end{chunk}

\section{The Read-Eval-Print Loop}
\defun{intloopReadConsole}{intloopReadConsole}
Note that this function relies on the fact that lisp can do tail-recursion.
The function recursively invokes itself.

The serverReadLine function is a special readline function that handles
communication with the session manager code, which is a separate process
running in parallel. 

We read a line from standard input.
\begin{itemize}
\item If it is a null line then we exit Axiom.
\item If it is a zero length line we prompt and recurse
\item If \$dalymode and open-paren we execute lisp code, prompt and recurse
The \$dalymode will interpret any input that begins with an open-paren
as a lisp expression rather than Axiom input. This is useful for debugging
purposes when most of the input lines will be lisp. Setting \$dalymode
non-nil will certainly break user expectations and is to be used with 
caution.
\item If it is ``)fi'' or ``)fin'' we drop into lisp. Use the (restart)
      function to return to the interpreter loop.
\item If it starts with ``)'' we process the command, prompt, and recurse
\item If it is a command then we remember the current line, process the
      command, prompt, and recurse.
\item If the input has a trailing underscore (Axiom line-continuation)
      then we cut off the continuation character and pass the truncated
      string to ourselves, prompt, and recurse
\item otherwise we process the input, prompt, and recurse.
\end{itemize}
Notice that all but two paths (a null input or a ``)fi'' or a ``)fin'')
will end up as a recursive call to ourselves.

\throws{intloopReadConsole}{top-level}
\calls{intloopReadConsole}{serverReadLine}
\calls{intloopReadConsole}{leaveScratchpad}
\calls{intloopReadConsole}{mkprompt}
\calls{intloopReadConsole}{intloopReadConsole}
\calls{intloopReadConsole}{intloopPrefix?}
\calls{intloopReadConsole}{intnplisp}
\calls{intloopReadConsole}{setCurrentLine}
\calls{intloopReadConsole}{ncloopCommand}
\calls{intloopReadConsole}{concat}
\calls{intloopReadConsole}{ncloopEscaped}
\calls{intloopReadConsole}{intloopProcessString}
\usesdollar{intloopReadConsole}{dalymode}
\label{intloopReadConsole}
\sig{intloopReadConsole}{(String Integer)}{Throw}
\begin{chunk}{defun intloopReadConsole}
(defun |intloopReadConsole| (prefix stepNumber) 
 (declare (special $dalymode)) 
 (let (newStepNo cmd pfx input) 
   ; read the next line
   (setq input (|serverReadLine| *standard-input*)) 
   ; if we have lost *standard-input* then exit Axiom
   (when (null (stringp input)) (|leaveScratchpad|)) 
   ; if the input is a zero-length input, recurse
   (when (eql (length input) 0) 
     (princ (mkprompt)) 
     (|intloopReadConsole| "" stepNumber))
   ; if $dalymode is nonnil anything starting with '(' is a lisp expression
   ; evaluate the expression in lisp and recurse
   (when (and $dalymode (|intloopPrefix?| "(" input))
     (|intnplisp| input) 
     (princ (mkprompt)) 
     (|intloopReadConsole| "" stepNumber))
   ; if the input starts with ")fi" or ")fin" throw into lisp
   (setq pfx (|intloopPrefix?| ")fi" input))
   (when (and pfx (or (string= pfx ")fi") (string= pfx ")fin")))
     (throw '|top_level| nil))
   ; if the input starts with ')' it is a command; execute and recurse
   (when (and (equal prefix "") (setq cmd (|intloopPrefix?| ")" input)))
     (|setCurrentLine| cmd) 
     (setq newStepNo (|ncloopCommand| cmd stepNumber)) 
     (princ (mkprompt)) 
     (|intloopReadConsole| "" newStepNo))
   ; if the last non-blank character on the line is an underscore
   ; we use the current accumulated input as a prefix and recurse.
   ; this has the effect of concatenating the next line (minus the underscore)
   (setq input (concat prefix input)) 
   (when (|ncloopEscaped| input) 
     (|intloopReadConsole| (subseq input 0 (- (length input) 1)) stepNumber))
   ; if there are no special cases, process the current line and recurse
   (setq newStepNo (|intloopProcessString| input stepNumber)) 
   (princ (mkprompt)) 
   (|intloopReadConsole| "" newStepNo)))

\end{chunk}

\section{Helper Functions}
\defunsec{getenviron}{Get the value of an evironment variable}
\calls{getenviron}{getenv}
\begin{chunk}{defun getenviron 0}
(defun getenviron (var)
 "Get the value of an evironment variable"
 #+allegro (sys::getenv (string var))
 #+clisp (ext:getenv (string var))
 #+(or cmu scl)
  (cdr 
   (assoc (string var) ext:*environment-list* :test #'equalp :key #'string))
 #+(or kcl akcl gcl) (si::getenv (string var))
 #+lispworks (lw:environment-variable (string var))
 #+lucid (lcl:environment-variable (string var))
 #+mcl (ccl::getenv var)
 #+sbcl (sb-ext:posix-getenv var)
 )

\end{chunk}

\defdollar{intCoerceFailure}
\begin{chunk}{initvars}
(defvar |$intCoerceFailure| '|coerceFailure|)

\end{chunk}

\defdollar{intSpadReader}
\begin{chunk}{initvars}
(defvar |$intSpadReader| 'SPAD_READER)

\end{chunk}

\defun{InterpExecuteSpadSystemCommand}{InterpExecuteSpadSystemCommand}
\catches{InterpExecuteSpadSystemCommand}{intCoerceFailure}
\catches{InterpExecuteSpadSystemCommand}{intSpadReader}
\calls{InterpExecuteSpadSystemCommand}{ExecuteInterpSystemCommand}
\usesdollar{InterpExecuteSpadSystemCommand}{intSpadReader}
\usesdollar{InterpExecuteSpadSystemCommand}{intCoerceFailure}
\begin{chunk}{defun InterpExecuteSpadSystemCommand}
(defun |InterpExecuteSpadSystemCommand| (string)
 (declare (special |$intSpadReader| |$intCoerceFailure|))
  (catch |$intCoerceFailure|
   (catch |$intSpadReader|
    (|ExecuteInterpSystemCommand| string))))

\end{chunk}

\defun{ExecuteInterpSystemCommand}{ExecuteInterpSystemCommand}
\calls{ExecuteInterpSystemCommand}{intProcessSynonyms}
\calls{ExecuteInterpSystemCommand}{substring}
\calls{ExecuteInterpSystemCommand}{doSystemCommand}
\usesdollar{ExecuteInterpSystemCommand}{currentLine}
\begin{chunk}{defun ExecuteInterpSystemCommand}
(defun |ExecuteInterpSystemCommand| (string)
 (let (|$currentLine|)
 (declare (special |$currentLine|))
  (setq string (|intProcessSynonyms| string))
  (setq |$currentLine| string)
  (setq string (substring string 1 nil))
  (unless (equal string "") (|doSystemCommand| string))))

\end{chunk}

\defun{substring}{substring}
\begin{chunk}{defun substring 0}
(defun substring (cvec start length)
  (if length 
   (subseq (string cvec) start (+ start length))
   (subseq (string cvec) start)))

\end{chunk}

\defun{intProcessSynonyms}{Handle Synonyms}
\calls{intProcessSynonyms}{processSynonyms}
\uses{intProcessSynonyms}{line}
\begin{chunk}{defun intProcessSynonyms}
(defun |intProcessSynonyms| (str)
 (let ((line str))
 (declare (special line))
  (|processSynonyms|)
  line))

\end{chunk}

\defun{processSynonyms}{Synonym File Reader}
\calls{processSynonyms}{strpos}
\calls{processSynonyms}{substring}
\calls{processSynonyms}{string2id-n}
\calls{processSynonyms}{lassoc}
\calls{processSynonyms}{concat}
\calls{processSynonyms}{size}
\calls{processSynonyms}{concat}
\calls{processSynonyms}{rplacstr}
\calls{processSynonyms}{processSynonyms}
\usesdollar{processSynonyms}{CommandSynonymAlist}
\uses{processSynonyms}{line}
\begin{chunk}{defun processSynonyms}
(defun |processSynonyms| ()
 (let (fill p aline synstr syn to opt fun cl chr)
 (declare (special |$CommandSynonymAlist| line))
  (setq p (strpos ")" line 0 nil))
  (setq fill "")
  (cond
   (p
    (setq aline (substring line p nil))
    (when (> p 0) (setq fill (substring line 0 p))))
   (t
    (setq p 0)
    (setq aline line)))
  (setq to (strpos " " aline 1 nil))
  (cond (to (setq to (1- to))))
  (setq synstr (substring aline 1 to))
  (setq syn (string2id-n synstr 1))
  (when  (setq fun (lassoc syn |$CommandSynonymAlist|))
   (setq to (strpos ")" fun 1 nil))
   (cond
    ((and to (not (eql to (1- (size fun)))))
     (setq opt (concat " " (substring fun to nil)))
     (setq fun (substring fun 0 (1- to ))))
    (t (setq opt " ")))
   (when (> (size synstr) (size fun))
    (do ((G167173 (size synstr)) (i (size fun) (1+ i)))
        ((> i G167173) nil)
     (setq fun (concat fun " "))))
   (setq cl (concat fill (rplacstr aline 1 (size synstr) fun) opt))
   (setq line cl)
   (setq chr (elt line (1+ p)))
   (|processSynonyms|))))

\end{chunk}

\defun{init-memory-config}{init-memory-config}
Austin-Kyoto Common Lisp (AKCL), now known as Gnu Common Lisp (GCL)
requires some changes to the default memory setup to run Axiom efficently.
This function performs those setup commands. 

\calls{init-memory-config}{allocate}
\calls{init-memory-config}{allocate-contiguous-pages}
\calls{init-memory-config}{allocate-relocatable-pages}
\calls{init-memory-config}{set-hole-size}

\begin{remark}
Starting from GCL 2.6.10, the call of \texttt{system:set-hole-size} has become
a \emph{noop}. Instead, we should either call nothing or call another function
\texttt{SET-STARTING-HOLE-DIVISOR} instead. Below are notes taken from GCL's
mailing list:
\begin{verbatim}
[Gcl-devel] SET-STARTING-HOLE-DIVISOR

From:	 Camm Maguire
Subject: [Gcl-devel] SET-STARTING-HOLE-DIVISOR
Date:	 Thu, 10 Jul 2014 14:41:06 -0400

Greetings!

2.6.10 has a significantly improved memory layout and fixnum handling.
Much work was also done on graceful oom handling encountered by some
acl2 jobs on 'lesser' machines.  The statically compiled maxpage
variable was replaced with a runtime probe of the maximum number of
pages that can be brk'ed at each image startup.  The upshot is that GCL
needed to scale the hole dynamically, so #'si::set-hole-size had to
become a noop.

You can 

1) safely ignore the error
2) remove the set-hole-size call and let gcl handle the memory, or
3) replace the call with si::set-starting-hole-divisor, which will set
the initial hole size as a fraction of the probed maxpages.

This is simply a performance tweak.  A generous hole lowers the starting
gc overhead.  GCL will try to optimize this by itself, but you can
change the initial placement if you want to.

Take care,
-- 
Camm Maguire                                        address@hidden
==========================================================================
"The earth is but one country, and mankind its citizens."  --  Baha'u'llah
\end{verbatim}
\end{remark}

\begin{chunk}{defun init-memory-config 0}
(defun init-memory-config (&key
                           (cons 500)
                           (fixnum 200)
                           (symbol 500)
                           (package 8)
                           (array 400)
                           (string 500)
                           (cfun 100)
                           (cpages 3000)
                           (rpages 1000)
                           (hole 2000) )
  ;; initialize AKCL memory allocation parameters
  #+:nil ; disabled by Camm Maguire <camm@debian.org>)
  (progn
    (system:allocate 'cons cons)
    (system:allocate 'fixnum fixnum)
    (system:allocate 'symbol symbol)
    (system:allocate 'package package)
    (system:allocate 'array array)
    (system:allocate 'string string)
    (system:allocate 'cfun cfun)
    (system:allocate-contiguous-pages cpages)
    (system:allocate-relocatable-pages rpages)
    (system:set-hole-size hole))
  #-:nil
  nil)

\end{chunk}

\defunsec{initroot}{Set spadroot to be the AXIOM shell variable}
Sets up the system to use the {\bf AXIOM} shell variable if we can
and default to the {\bf \$spadroot} variable (which was the value
of the {\bf AXIOM} shell variable at build time) if we can't.

\calls{initroot}{reroot}
\calls{initroot}{getenviron}
\usesdollar{initroot}{spadroot}
\begin{chunk}{defun initroot}
(defun initroot (&optional (newroot (getenviron "AXIOM")))
 "Set spadroot to be the AXIOM shell variable"
  (declare (special $spadroot))
  (reroot (or newroot $spadroot (error "setenv AXIOM or (setq $spadroot)"))))

\end{chunk}

\defunsec{intloopPrefix?}{Does the string start with this prefix?}
If the prefix string is the same as the whole string initial characters
--R(ignoring spaces in the whole string) then we return the whole string
minus any leading spaces.
\label{intloopPrefix?}
\sig{intloopPrefix?}{String}{Union(String,NIL)}
\begin{chunk}{defun intloopPrefix? 0}
(defun |intloopPrefix?| (prefix whole)
 "Does the string start with this prefix?"
 (let ((newprefix (string-left-trim '(#\space) prefix))
       (newwhole  (string-left-trim '(#\space) whole)))
  (when (<= (length newprefix) (length newwhole))
   (when (string= newprefix newwhole :end2 (length prefix))
    newwhole))))

\end{chunk}

\defun{intnplisp}{Interpret a line of lisp code}
This is used to hande {\tt )lisp} top level commands
\calls{intnplisp}{nplisp}
\usesdollar{intnplisp}{currentLine}
\label{intnplisp}
\begin{chunk}{defun intnplisp}
(defun |intnplisp| (s)
 (declare (special |$currentLine|))
 (setq |$currentLine| s)
 (|nplisp| |$currentLine|))

\end{chunk}

\defunsec{get-current-directory}{Get the current directory}
\begin{chunk}{defun get-current-directory 0}
(defun get-current-directory ()
 "Get the current directory"
  (namestring (truename "")))

\end{chunk} 

\defunsec{make-absolute-filename}{Prepend the absolute path to a filename}
Prefix a filename with the {\bf AXIOM} shell variable.

\usesdollar{make-absolute-filename}{spadroot}
\begin{chunk}{defun make-absolute-filename 0}
(defun make-absolute-filename (name)
 "Prepend the absolute path to a filename"
 (declare (special $spadroot))
 (concatenate 'string $spadroot name))

\end{chunk}

\defunsec{makeInitialModemapFrame}{Make the initial modemap frame}
\calls{makeInitialModemapFrame}{copy}
\usesdollar{makeInitialModemapFrame}{InitialModemapFrame}
\begin{chunk}{defun makeInitialModemapFrame 0}
(defun |makeInitialModemapFrame| ()
  "Make the initial modemap frame"
  (declare (special |$InitialModemapFrame|)) 
  (copy |$InitialModemapFrame|)) 

\end{chunk}

\defun{ncloopEscaped}{ncloopEscaped}
The ncloopEscaped function will return true if the last non-blank
character of a line is an underscore, the Axiom line-continuation
character. Otherwise, it returns nil.
\begin{chunk}{defun ncloopEscaped 0}
(defun |ncloopEscaped| (x)
 (let ((l (length x)))
  (dotimes (i l)
   (when (char= (char x (- l i 1)) #\_) (return t))
   (unless (char= (char x (- l i 1)) #\space) (return nil)))))

\end{chunk}

\defun{intloopProcessString}{intloopProcessString}
\calls{intloopProcessString}{setCurrentLine}
\calls{intloopProcessString}{intloopProcess}
\calls{intloopProcessString}{next}
\calls{intloopProcessString}{incString}
\label{intloopProcessString}
\sig{intloopProcessString}{(String,StepNo)}{StepNo}
\begin{chunk}{defun intloopProcessString}
(defun |intloopProcessString| (currentline stepno)
 (|setCurrentLine| currentline)
 (|intloopProcess| stepno t
  (|next| #'|ncloopParse|
   (|next| #'|lineoftoks| (|incString| currentline)))))

\end{chunk}

\defun{ncloopParse}{ncloopParse}
\calls{ncloopParse}{ncloopDQlines}
\calls{ncloopParse}{npParse}
\calls{ncloopParse}{dqToList}
\begin{chunk}{defun ncloopParse}
(defun |ncloopParse| (s)
 (let (cudr lines stream dq t1)
  (setq t1 (car s))
  (setq dq (car t1))
  (setq stream (cadr t1))
  (setq t1 (|ncloopDQlines| dq stream))
  (setq lines (car t1))
  (setq cudr (cadr t1))
  (cons (list (list lines (|npParse| (|dqToList| dq)))) (cdr s))))

\end{chunk}

\defun{next}{next}
\calls{next}{Delay}
\calls{next}{next1}
\label{next}
\sig{next}{(Function,Delay)}{Delay}
\begin{chunk}{defun next}
(defun |next| (function delay)
 (|Delay| #'|next1| (list function delay)))

\end{chunk}

\defun{next1}{next1}
\calls{next1}{StreamNull}
\calls{next1}{incAppend}
\calls{next1}{next}
\label{next1}
\sig{next1}{Delay}{ParsePair}
\begin{chunk}{defun next1}
(defun |next1| (&rest delayArg)
 (let (h delay function)
  (setq function (car delayArg))
  (setq delay (cadr delayArg))
  (cond
   ((|StreamNull| delay) |StreamNil|)
   (t
    (setq h (apply function (list delay)))
    (|incAppend| (car h) (|next| function (cdr h)))))))

\end{chunk}

\defun{incString}{incString}
The {\bf incString} function gets a string, usually from Axiom's input,
and constructs a set of nested function calls to process the input line.
\calls{incString}{incRenumber}
\calls{incString}{incLude}
\uses{incString}{Top}
\label{incString}
\sig{incString}{String}{Function}
\begin{chunk}{defun incString}
(defun |incString| (s)
 (declare (special |Top|))
 (|incRenumber| (|incLude| 0 (list s) 0 (list "strings") (list |Top|))))

\end{chunk}

\defunsec{reclaim}{Call the garbage collector}
Call the garbage collector on various platforms.
\begin{chunk}{defun reclaim 0}
#+abcl 
(defun reclaim () "Call the garbage collector" (ext::gc))
#+:allegro
(defun reclaim () "Call the garbage collector" (excl::gc t))
#+:CCL
(defun reclaim () "Call the garbage collector" (gc))
#+clisp
(defun reclaim () 
 "Call the garbage collector" 
 (#+lisp=cl ext::gc #-lisp=cl lisp::gc))
#+(or :cmulisp :cmu)
(defun reclaim () "Call the garbage collector" (ext:gc))
#+cormanlisp
(defun reclaim () "Call the garbage collector" (cl::gc))
#+(OR IBCL KCL GCL)
(defun reclaim () "Call the garbage collector" (si::gbc t))
#+lispworks 
(defun reclaim () "Call the garbage collector" (hcl::normal-gc))
#+Lucid
(defun reclaim () "Call the garbage collector" (lcl::gc))
#+sbcl
(defun reclaim () "Call the garbage collector" (sb-ext::gc))

\end{chunk}

\defun{reroot}{reroot}
The reroot function is used to reset the important variables used by
the system. In particular, these variables are sensitive to the
{\bf AXIOM} shell variable. That variable is renamed internally to
be {\bf \$spadroot}. The {\bf reroot} function will change the
system to use a new root directory and will have the same effect
as changing the {\bf AXIOM} shell variable and rerunning the system
from scratch. Note that we have changed from the
NAG distribution back to the original form. If you need the NAG
version you can push {\bf :tpd} on the {\bf *features*} variable
before compiling this file. A correct call looks like:
\begin{verbatim}
  (in-package "BOOT")
  (reroot "/spad/mnt/${SYS}")
\end{verbatim}
where the \verb|${SYS}| variable is the same one set at build time.

For the example call:
\begin{verbatim}
  (REROOT "/research/test/mnt/ubuntu")
\end{verbatim}
the variables are set as:
\begin{verbatim}
$spadroot = "/research/test/mnt/ubuntu"

$relative-directory-list =
  ("/../../src/input/" 
   "/doc/msgs/" 
   "/../../src/algebra/" 
   "/../../src/interp/" 
   "/doc/spadhelp/")

$directory-list =
  ("/research/test/mnt/ubuntu/../../src/input/" 
   "/research/test/mnt/ubuntu/doc/msgs/" 
   "/research/test/mnt/ubuntu/../../src/algebra/" 
   "/research/test/mnt/ubuntu/../../src/interp/" 
   "/research/test/mnt/ubuntu/doc/spadhelp/")

$relative-library-directory-list = ("/algebra/")

$library-directory-list =  ("/research/test/mnt/ubuntu/algebra/")

|$msgDatabaseName| = nil

$current-directory = "/research/test/"
\end{verbatim}

\calls{reroot}{make-absolute-filename}
\usesdollar{reroot}{spadroot}
\usesdollar{reroot}{directory-list}
\usesdollar{reroot}{relative-directory-list}
\usesdollar{reroot}{library-directory-list}
\usesdollar{reroot}{relative-library-directory-list}
\usesdollar{reroot}{current-directory}
\begin{chunk}{defun reroot}
(defun reroot (dir)
  (declare (special $spadroot $directory-list $relative-directory-list
     $library-directory-list $relative-library-directory-list
     $current-directory))
  (setq $spadroot dir)
  (setq $directory-list
   (mapcar #'make-absolute-filename $relative-directory-list))
  (setq $library-directory-list
   (mapcar #'make-absolute-filename $relative-library-directory-list))
  (setq $current-directory $spadroot))

\end{chunk}

\defdollar{current-directory}
\begin{chunk}{initvars}
(defvar |$currentLine| "" "A list of the input line history")

\end{chunk}

\defun{setCurrentLine}{setCurrentLine}
Remember the current line. The cases are:
\begin{itemize}
\item If there is no \$currentLine set it to the input
\item Is the current line a string and the input a string?
      Make them into a list
\item Is \$currentLine not a cons cell? Make it one.
\item Is the input a string? Cons it on the end of the list.
\item Otherwise stick it on the end of the list
\end{itemize}
\usesdollar{setCurrentLine}{currentLine}
\label{setCurrentLine}
\sig{setCurrentLine}{String}{List(String)}
\begin{chunk}{defun setCurrentLine 0}
(defun |setCurrentLine| (s)
 (declare (special |$currentLine|))
 (cond 
  ((null |$currentLine|) (setq |$currentLine| s))
  ((and (stringp |$currentLine|) (stringp s))
    (setq |$currentLine| (list |$currentLine| s)))
  ((not (consp |$currentLine|)) (setq |$currentLine| (cons |$currentLine| s)))
  ((stringp s) (rplacd (last |$currentLine|) (cons s nil)))
  (t (rplacd (last |$currentLine|) s)))
 |$currentLine|)

\end{chunk}

\defunsec{mkprompt}{Show the Axiom prompt}
\calls{mkprompt}{concat}
\calls{mkprompt}{substring}
\calls{mkprompt}{currenttime}
\usesdollar{mkprompt}{inputPromptType}
\usesdollar{mkprompt}{IOindex}
\usesdollar{mkprompt}{interpreterFrameName}
\label{mkprompt}
\sig{mkprompt}{Void}{String}
\begin{chunk}{defun mkprompt}
(defun mkprompt ()  
 "Show the Axiom prompt"
 (declare (special |$inputPromptType| |$IOindex| |$interpreterFrameName|))
 (case |$inputPromptType|
  (|none| "")
  (|plain| "-> ")
  (|step|  (concat "(" (princ-to-string |$IOindex|) ") -> "))
  (|frame|
   (concat (princ-to-string |$interpreterFrameName|) " ("
           (princ-to-string |$IOindex|) ") -> "))
  (t (concat (princ-to-string |$interpreterFrameName|) " ["
             (substring (currenttime) 8 nil) "] [" 
             (princ-to-string |$IOindex|) "] -> "))))

\end{chunk}

\defdollar{frameAlist}
\begin{chunk}{initvars}
(defvar |$frameAlist| nil) 

\end{chunk}
\defdollar{frameNumber}
\begin{chunk}{initvars}
(defvar |$frameNumber| 0) 

\end{chunk}
\defdollar{currentFrameNum}
\begin{chunk}{initvars}
(defvar |$currentFrameNum| 0) 

\end{chunk}

\defdollar{EndServerSession}
\begin{chunk}{initvars}
(defvar |$EndServerSession| nil) 

\end{chunk}

\defdollar{NeedToSignalSessionManager}
\begin{chunk}{initvars}
(defvar |$NeedToSignalSessionManager| nil) 

\end{chunk}

\defdollar{sockBufferLength}
\begin{chunk}{initvars}
(defvar |$sockBufferLength| 9217) 

\end{chunk}

\defunsec{serverReadLine}{READ-LINE in an Axiom server system}
\catches{serverReadLine}{coerceFailure}
\catches{serverReadLine}{top-level}
\catches{serverReadLine}{spad-reader}
\calls{serverReadLine}{read-line}
\calls{serverReadLine}{addNewInterpreterFrame}
\calls{serverReadLine}{sockSendInt}
\calls{serverReadLine}{sockSendString}
\calls{serverReadLine}{mkprompt}
\calls{serverReadLine}{sockGetInt}
\calls{serverReadLine}{lassoc}
\calls{serverReadLine}{changeToNamedInterpreterFrame}
\calls{serverReadLine}{sockGetString}
\calls{serverReadLine}{unescapeStringsInForm}
\calls{serverReadLine}{protectedEVAL}
\calls{serverReadLine}{executeQuietCommand}
\calls{serverReadLine}{parseAndInterpret}
\seebook{serverReadLine}{is-console}{9}
\calls{serverReadLine}{serverSwitch}
\usesdollar{serverReadLine}{KillLispSystem}
\usesdollar{serverReadLine}{NonSmanSession}
\usesdollar{serverReadLine}{SpadCommand}
\usesdollar{serverReadLine}{QuietSpadCommand}
\usesdollar{serverReadLine}{MenuServer}
\usesdollar{serverReadLine}{sockBufferLength}
\usesdollar{serverReadLine}{LispCommand}
\usesdollar{serverReadLine}{EndServerSession}
\usesdollar{serverReadLine}{EndSession}
\usesdollar{serverReadLine}{SwitchFrames}
\usesdollar{serverReadLine}{CreateFrameAnswer}
\usesdollar{serverReadLine}{currentFrameNum}
\usesdollar{serverReadLine}{frameNumber}
\usesdollar{serverReadLine}{frameAlist}
\usesdollar{serverReadLine}{CreateFrame}
\usesdollar{serverReadLine}{CallInterp}
\usesdollar{serverReadLine}{EndOfOutput}
\usesdollar{serverReadLine}{SessionManager}
\usesdollar{serverReadLine}{NeedToSignalSessionManager}
\usesdollar{serverReadLine}{EndServerSession}
\usesdollar{serverReadLine}{SpadServer}
\uses{serverReadLine}{*eof*}
\uses{serverReadLine}{in-stream}
\label{serverReadLine}
\sig{serverReadLine}{Stream}{String}
\begin{chunk}{defun serverReadLine}
(defun |serverReadLine| (stream)
 "used in place of READ-LINE in a Axiom server system."
 (let (in-stream *eof* l framename currentframe form stringbuf line action)
 (declare (special in-stream *eof* |$SpadServer| |$EndServerSession|
     |$NeedToSignalSessionManager| |$SessionManager| |$EndOfOutput|
     |$CallInterp| |$CreateFrame| |$frameAlist| |$frameNumber|
     |$currentFrameNum| |$CreateFrameAnswer| |$SwitchFrames| |$EndSession|
     |$EndServerSession| |$LispCommand| |$sockBufferLength| |$MenuServer|
     |$QuietSpadCommand| |$SpadCommand| |$NonSmanSession| |$KillLispSystem|))
  (force-output)
  (if (or (null |$SpadServer|) (null (is-console stream)))
   (|read-line| stream)
   (progn
    (setq in-stream stream)
    (setq *eof* nil)
    (setq line
     (do ()
         ((null (and (null |$EndServerSession|) (null *eof*))) nil)
         (when |$NeedToSignalSessionManager|
          (|sockSendInt| |$SessionManager| |$EndOfOutput|))
      (setq |$NeedToSignalSessionManager| nil)
      ; see bookvol8 for the constants that serverSwitch returns
      (setq action (|serverSwitch|))
      (cond 
       ((= action |$CallInterp|)
        (setq l (|read-line| stream))
        (setq |$NeedToSignalSessionManager| t)
        (return l))
       ((= action |$CreateFrame|)
        (setq framename (gentemp "frame"))
        (|addNewInterpreterFrame| framename)
        (setq |$frameAlist|
         (cons (cons |$frameNumber| framename) |$frameAlist|))
        (setq |$currentFrameNum| |$frameNumber|)
        (|sockSendInt| |$SessionManager| |$CreateFrameAnswer|)
        (|sockSendInt| |$SessionManager| |$frameNumber|)
        (setq |$frameNumber| (1+ |$frameNumber|))
        (|sockSendString| |$SessionManager| (mkprompt)))
       ((= action |$SwitchFrames|)
        (setq |$currentFrameNum| (|sockGetInt| |$SessionManager|))
        (setq currentframe (lassoc |$currentFrameNum| |$frameAlist|))
        (|changeToNamedInterpreterFrame| currentframe))
       ((= action |$EndSession|)
        (setq |$EndServerSession| t))
       ((= action |$LispCommand|)
        (setq |$NeedToSignalSessionManager| t)
        (setq stringbuf (make-string |$sockBufferLength|))
        (|sockGetString| |$MenuServer| stringbuf |$sockBufferLength|)
        (setq form (|unescapeStringsInForm| (read-from-string stringbuf)))
        (|protectedEVAL| form))
       ((= action |$QuietSpadCommand|)
        (setq |$NeedToSignalSessionManager| t)
        (|executeQuietCommand|))
       ((= action |$SpadCommand|)
        (setq |$NeedToSignalSessionManager| t)
        (setq stringbuf (make-string 512))
        (|sockGetString| |$MenuServer| stringbuf 512)
        (catch '|coerceFailure|
         (catch '|top_level|
          (catch 'spad_reader
           (|parseAndInterpret| stringbuf))))
        (princ (mkprompt))
        (finish-output))
       ((= action |$NonSmanSession|) (setq |$SpadServer| nil))
       ((= action |$KillLispSystem|) (bye))
       (t nil))))
    (cond
     (line line)
     (t '||))))))

\end{chunk}

\defun{protectedEVAL}{protectedEVAL}
\calls{protectedEVAL}{resetStackLimits}
\calls{protectedEVAL}{sendHTErrorSignal}
\begin{chunk}{defun protectedEVAL}
(defun |protectedEVAL| (x)
 (let (val (error t))
  (unwind-protect
   (progn
    (setq val (eval x))
    (setq error nil))
   (when error
    (|resetStackLimits|)
    (|sendHTErrorSignal|)))
  (unless error val)))

\end{chunk}

\defdollar{QuietCommand}
\begin{chunk}{initvars}
(defvar |$QuietCommand| nil "If true, produce no top level output") 

\end{chunk}

\defun{executeQuietCommand}{executeQuietCommand}
When \verb|$QuiteCommand| is true Spad will not produce any output from
a top level command

\catches{executeQuietCommand}{spad-reader}
\catches{executeQuietCommand}{coerceFailure}
\catches{executeQuietCommand}{toplevel}
\catches{executeQuietCommand}{spadreader}
\calls{executeQuietCommand}{make-string}
\calls{executeQuietCommand}{sockGetString}
\calls{executeQuietCommand}{parseAndInterpret}
\usesdollar{executeQuietCommand}{MenuServer}
\usesdollar{executeQuietCommand}{QuietCommand}
\begin{chunk}{defun executeQuietCommand}
(defun |executeQuietCommand| ()
 (let (|$QuietCommand| stringBuf)
 (declare (special |$QuietCommand| |$MenuServer|))
  (setq |$QuietCommand| t)
  (setq stringBuf (make-string 512))
  (|sockGetString| |$MenuServer| stringBuf 512)
  (catch '|coerceFailure|
   (catch '|top_level|
    (catch 'spad_reader (|parseAndInterpret| stringBuf))))))

\end{chunk}

\defun{parseAndInterpret}{parseAndInterpret}
\usesdollar{parseAndInterpret}{InteractiveMode}
\usesdollar{parseAndInterpret}{boot}
\usesdollar{parseAndInterpret}{spad}
\usesdollar{parseAndInterpret}{e}
\usesdollar{parseAndInterpret}{InteractiveFrame}
\begin{chunk}{defun parseAndInterpret}
(defun |parseAndInterpret| (str)
 (let (|$InteractiveMode| $boot $spad |$e|)
 (declare (special |$InteractiveMode| $boot $spad |$e| 
                   |$InteractiveFrame|))
  (setq |$InteractiveMode| t)
  (setq $boot nil)
  (setq $spad t)
  (setq |$e| |$InteractiveFrame|)
  (|processInteractive| (|parseFromString| str) nil)))

\end{chunk}

\defun{parseFromString}{parseFromString}
\calls{parseFromString}{next}
\calls{parseFromString}{ncloopParse}
\calls{parseFromString}{lineoftoks}
\calls{parseFromString}{incString}
\calls{parseFromString}{StreamNull}
\calls{parseFromString}{pf2Sex}
\calls{parseFromString}{macroExpanded}
\begin{chunk}{defun parseFromString}
(defun |parseFromString| (s)
  (setq s (|next| #'|ncloopParse| (|next| #'|lineoftoks| (|incString| s))))
  (unless (|StreamNull| s) (|pf2Sex| (|macroExpanded| (cadar s)))))

\end{chunk}

\defdollar{interpOnly}
\begin{chunk}{initvars}
(defvar |$interpOnly| nil)

\end{chunk}

\defdollar{minivectorNames}
\begin{chunk}{initvars}
(defvar |$minivectorNames| nil)

\end{chunk}

\defdollar{domPvar}
\begin{chunk}{initvars}
(defvar |$domPvar| nil)

\end{chunk}

\defdollar{compilingMap}
{\bf \verb|$compilingMap|}: true when compiling a map, used to
detect where to THROW when interpret-only is invoked
\begin{chunk}{initvars}
(defvar |$compilingMap| ())

\end{chunk}

\defdollar{instantRecord}
\begin{chunk}{initvars}
(setq |$instantRecord| (make-hash-table :test #'eq))

\end{chunk}

\defun{processInteractive}{processInteractive}
Parser Output {\tt -->} Interpreter

Top-level dispatcher for the interpreter.  It sets local variables
and then calls processInteractive1 to do most of the work.
This function receives the output from the parser.

\calls{processInteractive}{initializeTimedNames}
\calls{processInteractive}{qcar}
\calls{processInteractive}{processInteractive1}
\calls{processInteractive}{reportInstantiations}
\calls{processInteractive}{clrhash}
\calls{processInteractive}{writeHistModesAndValues}
\calls{processInteractive}{updateHist}
\usesdollar{processInteractive}{op}
\usesdollar{processInteractive}{Coerce}
\usesdollar{processInteractive}{compErrorMessageStack}
\usesdollar{processInteractive}{freeVars}
\usesdollar{processInteractive}{mapList}
\usesdollar{processInteractive}{compilingMap}
\usesdollar{processInteractive}{compilingLoop}
\usesdollar{processInteractive}{interpOnly}
\usesdollar{processInteractive}{whereCacheList}
\usesdollar{processInteractive}{timeGlobalName}
\usesdollar{processInteractive}{StreamFrame}
\usesdollar{processInteractive}{declaredMode}
\usesdollar{processInteractive}{localVars}
\usesdollar{processInteractive}{analyzingMapList}
\usesdollar{processInteractive}{lastLineInSEQ}
\usesdollar{processInteractive}{instantCoerceCount}
\usesdollar{processInteractive}{instantCanCoerceCount}
\usesdollar{processInteractive}{instantMmCondCount}
\usesdollar{processInteractive}{fortVar}
\usesdollar{processInteractive}{minivector}
\usesdollar{processInteractive}{minivectorCode}
\usesdollar{processInteractive}{minivectorNames}
\usesdollar{processInteractive}{domPvar}
\usesdollar{processInteractive}{inRetract}
\usesdollar{processInteractive}{instantRecord}
\usesdollar{processInteractive}{reportInstantiations}
\usesdollar{processInteractive}{ProcessInteractiveValue}
\usesdollar{processInteractive}{defaultFortVar}
\usesdollar{processInteractive}{interpreterTimedNames}
\usesdollar{processInteractive}{interpreterTimedClasses}
\begin{chunk}{defun processInteractive}
(defun |processInteractive| (form posnForm)
 (let (|$op| |$Coerce| |$compErrorMessageStack| |$freeVars|
             |$mapList| |$compilingMap| |$compilingLoop|
             |$interpOnly| |$whereCacheList| |$timeGlobalName|
             |$StreamFrame| |$declaredMode| |$localVars|
             |$analyzingMapList| |$lastLineInSEQ|
             |$instantCoerceCount| |$instantCanCoerceCount|
             |$instantMmCondCount| |$fortVar| |$minivector|
             |$minivectorCode| |$minivectorNames| |$domPvar|
             |$inRetract| object)
 (declare (special |$op| |$Coerce| |$compErrorMessageStack|
                   |$freeVars| |$mapList| |$compilingMap|
                   |$compilingLoop| |$interpOnly| |$whereCacheList|
                   |$timeGlobalName| |$StreamFrame| |$declaredMode|
                   |$localVars| |$analyzingMapList| |$lastLineInSEQ|
                   |$instantCoerceCount| |$instantCanCoerceCount|
                   |$instantMmCondCount| |$fortVar| |$minivector|
                   |$minivectorCode| |$minivectorNames| |$domPvar|
                   |$inRetract| |$instantRecord| |$reportInstantiations|
                   |$ProcessInteractiveValue| |$defaultFortVar|
                   |$interpreterTimedNames| |$interpreterTimedClasses|))
  (|initializeTimedNames| |$interpreterTimedNames| |$interpreterTimedClasses|)
  (if (consp form)                        ; compute name of operator
   (setq |$op| (qcar form))
   (setq |$op| form))
  (setq |$Coerce| nil)
  (setq |$compErrorMessageStack| nil)
  (setq |$freeVars| nil)
  (setq |$mapList| nil)                   ; list of maps being type analyzed
  (setq |$compilingMap| nil)              ; true when compiling a map
  (setq |$compilingLoop| nil)             ; true when compiling a loop body
  (setq |$interpOnly| nil)                ; true when in interp only mode
  (setq |$whereCacheList| nil)            ; maps compiled because of where
  (setq |$timeGlobalName| '|$compTimeSum|); see incrementTimeSum
  (setq |$StreamFrame| nil)               ; used in printing streams
  (setq |$declaredMode| nil)              ; weak type propagation for symbols
  (setq |$localVars| nil)                 ; list of local variables in function
  (setq |$analyzingMapList| nil)       ; names of maps currently being analyzed
  (setq |$lastLineInSEQ| t)               ; see evalIF and friends
  (setq |$instantCoerceCount| 0)
  (setq |$instantCanCoerceCount| 0)
  (setq |$instantMmCondCount| 0)
  (setq |$defaultFortVar| 'x)             ; default FORTRAN variable name
  (setq |$fortVar| |$defaultFortVar|)     ; variable name for FORTRAN output
  (setq |$minivector| nil)
  (setq |$minivectorCode| nil)
  (setq |$minivectorNames| nil)
  (setq |$domPvar| nil)
  (setq |$inRetract| nil)
  (setq object (|processInteractive1| form posnForm))
  (unless |$ProcessInteractiveValue|
   (when |$reportInstantiations|
    (|reportInstantiations|) 
    (clrhash |$instantRecord|))
   (|writeHistModesAndValues|) 
   (|updateHist|))
  object))

\end{chunk}

\defdollar{ProcessInteractiveValue}
\begin{chunk}{initvars}
(defvar |$ProcessInteractiveValue| nil "If true, no output or record") 

\end{chunk}

\defdollar{HTCompanionWindowID}
\begin{chunk}{initvars}
(defvar |$HTCompanionWindowID| nil)

\end{chunk}

\defun{processInteractive1}{processInteractive1}
This calls the analysis and output printing routines
\calls{processInteractive1}{recordFrame}
\calls{processInteractive1}{startTimingProcess}
\calls{processInteractive1}{interpretTopLevel}
\calls{processInteractive1}{stopTimingProcess}
\calls{processInteractive1}{recordAndPrint}
\calls{processInteractive1}{objValUnwrap}
\calls{processInteractive1}{objMode}
\usesdollar{processInteractive1}{e}
\usesdollar{processInteractive1}{ProcessInteractiveValue}
\usesdollar{processInteractive1}{InteractiveFrame}
\begin{chunk}{defun processInteractive1}
(defun |processInteractive1| (form posnForm)
 (let (|$e| object)
 (declare (special |$e| |$ProcessInteractiveValue| |$InteractiveFrame|))
  (setq |$e| |$InteractiveFrame|)
  (recordFrame 'system)
  (|startTimingProcess| '|analysis|)
  (setq object (|interpretTopLevel| form posnForm))
  (|stopTimingProcess| '|analysis|)
  (|startTimingProcess| '|print|)
  (unless |$ProcessInteractiveValue|
    (|recordAndPrint| (|objValUnwrap| object) (|objMode| object)))
  (recordFrame 'normal)
  (|stopTimingProcess| '|print|)
  object))

\end{chunk}

\defun{interpretTopLevel}{interpretTopLevel}
\catches{interpretTopLevel}{interpreter}
\calls{interpretTopLevel}{interpret}
\calls{interpretTopLevel}{stopTimingProcess}
\calls{interpretTopLevel}{peekTimedName}
\calls{interpretTopLevel}{interpretTopLevel}
\usesdollar{interpretTopLevel}{timedNameStack}
\begin{chunk}{defun interpretTopLevel}
(defun |interpretTopLevel| (x posnForm)
 (let (savedTimerStack c)
 (declare (special |$timedNameStack|))
  (setq savedTimerStack (copy |$timedNameStack|))
  (setq c (catch '|interpreter| (|interpret| x posnForm)))
  (do ()
      ((equal savedTimerStack |$timedNameStack|) nil)
    (|stopTimingProcess| (|peekTimedName|)))
  (if (eq c '|tryAgain|) 
   (|interpretTopLevel| x posnForm)
   c)))

\end{chunk}

\defdollar{genValue}
If the \verb|$genValue| variable is true then evaluate generated code,
otherwise leave code unevaluated. If \verb|$genValue| is false then we
are compiling. This variable is only defined and used locally.
\begin{chunk}{initvars}
(defvar |$genValue| nil "evaluate generated code if true")

\end{chunk}

\defun{interpret}{Type analyzes and evaluates expression x, returns object}
\calls{interpret}{interpret1}
\usesdollar{interpret}{env}
\usesdollar{interpret}{eval}
\usesdollar{interpret}{genValue}
\begin{chunk}{defun interpret}
(defun |interpret| (&rest arg &aux restargs x)
 (let (|$env| |$eval| |$genValue| posnForm)
 (declare (special |$env| |$eval| |$genValue|))
  (setq x (car arg))
  (setq restargs (cdr arg))
  (if (consp restargs)
    (setq posnForm (car restargs))
    (setq posnForm restargs))
  (setq |$env| (list (list nil)))
  (setq |$eval| t)      ; generate code -- don't just type analyze
  (setq |$genValue| t)  ; evaluate all generated code
  (|interpret1| x nil posnForm)))

\end{chunk}

\defun{interpret1}{Dispatcher for the type analysis routines}
This is the dispatcher for the type analysis routines. It type analyzes and
evaluates the expression x in the rootMode (if non-nil)
which may be \verb|$EmptyMode|. It returns an object if evaluating, and a
modeset otherwise. It creates the attributed tree.

\calls{interpret1}{mkAtreeWithSrcPos}
\calls{interpret1}{putTarget}
\calls{interpret1}{bottomUp}
\calls{interpret1}{getArgValue}
\calls{interpret1}{mkObj}
\calls{interpret1}{getValue}
\calls{interpret1}{interpret2}
\calls{interpret1}{keyedSystemError}
\usesdollar{interpret1}{genValue}
\usesdollar{interpret1}{eval}
\begin{chunk}{defun interpret1}
(defun |interpret1| (x rootMode posnForm)
 (let (node modeSet newRootMode argVal val)
 (declare (special |$genValue| |$eval|))
  (setq node (|mkAtreeWithSrcPos| x posnForm))
  (when rootMode (|putTarget| node rootMode))
  (setq modeSet (|bottomUp| node))
  (if (null |$eval|)
   modeSet
   (progn
    (if (null rootMode)
     (setq newRootMode (car modeSet))
     (setq newRootMode rootMode))
    (setq argVal (|getArgValue| node newRootMode))
    (cond
     ((and argVal (null |$genValue|))
       (mkObj argVal newRootMode))
     ((and argVal (setq val (|getValue| node)))
       (|interpret2| val newRootMode posnForm))
     (t
       (|keyedSystemError|
         "Interpreter code generation failed for expression %1s"
         (list x))))))))

\end{chunk}

\defdollar{ThrowAwayMode}
\begin{chunk}{initvars}
(defvar |$ThrowAwayMode| '|$ThrowAwayMode| "interp constant")

\end{chunk}

\defun{interpret2}{interpret2}
This is the late interpretCoerce. I removed the call to
coerceInteractive, so it only does the JENKS cases.

\calls{interpret2}{objVal}
\calls{interpret2}{objMode}
\calls{interpret2}{member}
\calls{interpret2}{mkObj}
\calls{interpret2}{systemErrorHere}
\calls{interpret2}{coerceInteractive}
\calls{interpret2}{throwKeyedMsgCannotCoerceWithValue}
\usesdollar{interpret2}{EmptyMode}
\usesdollar{interpret2}{ThrowAwayMode}
\begin{chunk}{defun interpret2}
(defun |interpret2| (object m1 posnForm)
 (declare (ignore  posnForm))
 (let (x m op ans)
 (declare (special |$EmptyMode| |$ThrowAwayMode|))
  (cond
   ((equal m1 |$ThrowAwayMode|) object)
   (t
    (setq x (|objVal| object))
    (setq m (|objMode| object))
    (cond
     ((equal m |$EmptyMode|)
      (cond
        ((and (consp x) 
              (progn (setq op (qcar x)) t)
              (|member| op '(map stream)))
          (mkObj x m1))
        ((equal m1 |$EmptyMode|)
          (mkObj x m))
        (t
          (|systemErrorHere| "interpret2"))))
     (m1
      (if (setq ans (|coerceInteractive| object m1)) 
       ans
       (|throwKeyedMsgCannotCoerceWithValue| x m m1)))
     (t object))))))

\end{chunk}

\defdollar{runTestFlag}
This is referenced by maPrin to stash output by recordAndPrint to not
print type/time
\begin{chunk}{initvars}
(defvar |$runTestFlag| nil)

\end{chunk}

\defdollar{mkTestFlag}
This referenced by READLN to stash input by maPrin to stash output
by recordAndPrint to write i/o onto \verb|$testStream|
\begin{chunk}{initvars}
(defvar |$mkTestFlag| nil)  

\end{chunk}

\defun{recordAndPrint}{Result Output Printing}
Prints out the value x which is of type m, and records the changes
in environment \verb|$e| into \verb|$InteractiveFrame|
\verb|$printAnyIfTrue| is documented in setvart.boot. 
It is controlled with the {\tt )se me any} command.

\calls{recordAndPrint}{output}
\calls{recordAndPrint}{putHist}
\calls{recordAndPrint}{mkObjWrap}
\calls{recordAndPrint}{printTypeAndTime}
\calls{recordAndPrint}{printStorage}
\calls{recordAndPrint}{printStatisticsSummary}
\calls{recordAndPrint}{mkCompanionPage}
\calls{recordAndPrint}{recordAndPrintTest}
\usesdollar{recordAndPrint}{outputMode}
\usesdollar{recordAndPrint}{mkTestOutputType}
\usesdollar{recordAndPrint}{runTestFlag}
\usesdollar{recordAndPrint}{e}
\usesdollar{recordAndPrint}{mkTestFlag}
\usesdollar{recordAndPrint}{HTCompanionWindowID}
\usesdollar{recordAndPrint}{QuietCommand}
\usesdollar{recordAndPrint}{printStatisticsSummaryIfTrue}
\usesdollar{recordAndPrint}{printTypeIfTrue}
\usesdollar{recordAndPrint}{printStorageIfTrue}
\usesdollar{recordAndPrint}{printTimeIfTrue}
\usesdollar{recordAndPrint}{Void}
\usesdollar{recordAndPrint}{algebraOutputStream}
\usesdollar{recordAndPrint}{collectOutput}
\usesdollar{recordAndPrint}{EmptyMode}
\usesdollar{recordAndPrint}{printVoidIfTrue}
\usesdollar{recordAndPrint}{outputMode}
\usesdollar{recordAndPrint}{printAnyIfTrue}
\begin{chunk}{defun recordAndPrint}
(defun |recordAndPrint| (x md)
 (let (|$outputMode| xp mdp mode)
 (declare (special |$outputMode| |$mkTestOutputType| |$runTestFlag| |$e|
                   |$mkTestFlag| |$HTCompanionWindowID| |$QuietCommand|
                   |$printStatisticsSummaryIfTrue| |$printTypeIfTrue|
                   |$printStorageIfTrue| |$printTimeIfTrue| |$Void|
                   |$algebraOutputStream| |$collectOutput| |$EmptyMode|
                   |$printVoidIfTrue| |$outputMode| |$printAnyIfTrue|))
  (cond
   ((and (equal md '(|Any|)) |$printAnyIfTrue|)
    (setq mdp (car x))
    (setq xp (cdr x)))
   (t
    (setq mdp md)
    (setq xp x)))
  (setq |$outputMode| md)
  (if (equal md |$EmptyMode|)
   (setq mode (|quadSch|))
   (setq mode md))
  (when (or (not (equal md |$Void|)) |$printVoidIfTrue|)
    (unless |$collectOutput| (terpri |$algebraOutputStream|))
    (unless |$QuietCommand| (|output| xp mdp)))
  (|putHist| '% '|value| (mkObjWrap x md) |$e|)
  (when (or |$printTimeIfTrue| |$printTypeIfTrue|)
    (|printTypeAndTime| xp mdp))
  (when |$printStorageIfTrue| (|printStorage|))
  (when |$printStatisticsSummaryIfTrue| (|printStatisticsSummary|))
  (when (integerp |$HTCompanionWindowID|) (|mkCompanionPage| md))
  (cond
   (|$mkTestFlag| (|recordAndPrintTest| md))
   (|$runTestFlag|
    (setq |$mkTestOutputType| md) 
    '|done|)
   (t '|done|))))

\end{chunk}

\defun{printStatisticsSummary}{printStatisticsSummary}
\calls{printStatisticsSummary}{sayKeyedMsg}
\calls{printStatisticsSummary}{statisticsSummary}
\usesdollar{printStatisticsSummary}{collectOutput}
\begin{chunk}{defun printStatisticsSummary}
(defun |printStatisticsSummary| ()
 (declare (special |$collectOutput|))
 (unless |$collectOutput| 
  (|sayKeyedMsg| "%rjon Summary: %1 %rjoff" (list (|statisticsSummary|)))))

\end{chunk}

\defun{printStorage}{printStorage}
\calls{printStorage}{makeLongSpaceString}
\usesdollar{printStorage}{interpreterTimedClasses}
\usesdollar{printStorage}{collectOutput}
\usesdollar{printStorage}{interpreterTimedNames}
\begin{chunk}{defun printStorage}
(defun |printStorage| ()
 (declare (special |$interpreterTimedClasses| |$collectOutput|
                   |$interpreterTimedNames|))
  (unless |$collectOutput|
   (|sayKeyedMsg| "%rjon Storage: %1 %rjoff"
    (list 
     (|makeLongSpaceString|
       |$interpreterTimedNames|
       |$interpreterTimedClasses|)))))

\end{chunk}

\defun{printTypeAndTime}{printTypeAndTime}
\calls{printTypeAndTime}{retract}
\calls{printTypeAndTime}{qcar}
\calls{printTypeAndTime}{retract}
\calls{printTypeAndTime}{mkObjWrap}
\calls{printTypeAndTime}{objMode}
\calls{printTypeAndTime}{sameUnionBranch}
\calls{printTypeAndTime}{makeLongTimeString}
\calls{printTypeAndTime}{msgText}
\calls{printTypeAndTime}{sayKeyedMsg}
\calls{printTypeAndTime}{justifyMyType}
\usesdollar{printTypeAndTime}{collectOutput}
\usesdollar{printTypeAndTime}{printTypeIfTrue}
\usesdollar{printTypeAndTime}{printTimeIfTrue}
\usesdollar{printTypeAndTime}{outputLines}
\usesdollar{printTypeAndTime}{interpreterTimedNames}
\usesdollar{printTypeAndTime}{interpreterTimedClasses}
\begin{chunk}{defun printTypeAndTime}
(defun |printTypeAndTime| (x m)
 (let (xp mp timeString result)
 (declare (special |$outputLines| |$collectOutput| |$printTypeIfTrue|
                   |$printTimeIfTrue| |$outputLines|
                   |$interpreterTimedNames| |$interpreterTimedClasses|))
  (cond
   ((and (consp m) (eq (qcar m) '|Union|))
    (setq xp (|retract| (mkObjWrap x m)))
    (setq mp (|objMode| xp))
    (setq m
     (cons '|Union|
      (append
       (dolist (arg (qcdr m) (nreverse result))
         (when (|sameUnionBranch| arg mp) (push arg result)))
       (list "..."))))))
  (when |$printTimeIfTrue|
   (setq timeString
    (|makeLongTimeString|
     |$interpreterTimedNames|
     |$interpreterTimedClasses|)))
  (cond
   ((and |$printTimeIfTrue| |$printTypeIfTrue|)
    (if |$collectOutput|
     (push (|msgText| "%rjon Type: %1p %rjoff" (list m)) |$outputLines|)
     (|sayKeyedMsg| "%rjon Type: %1p %l Time: %2 %rjoff"
       (list m timeString ))))
   (|$printTimeIfTrue|
    (unless |$collectOutput|
      (|sayKeyedMsg| "%rjon Time: %1 %rjoff" (list timeString))))
   (|$printTypeIfTrue|
    (if |$collectOutput|
     (push (|justifyMyType|
            (|msgText| "%rjon Type: %1p %rjoff" (list m))) |$outputLines|)
     (|sayKeyedMsg| "%rjon Type: %1p %rjoff" (list m)))))))

\end{chunk}

\defun{printAsTeX}{printAsTeX}
\usesdollar{printAsTeX}{texOutputStream}
\begin{chunk}{defun printAsTeX 0}
(defun |printAsTeX| (x)
 (declare (special |$texOutputStream|)) 
 (princ x |$texOutputStream|)) 

\end{chunk}

\defun{sameUnionBranch}{sameUnionBranch}
\begin{verbatim}
sameUnionBranch(uArg, m) ==
  uArg is [":", ., t] => t = m
  uArg = m
\end{verbatim}
\begin{chunk}{defun sameUnionBranch 0}
(defun |sameUnionBranch| (uArg m)
 (let (t1 t2 t3)
 (cond
  ((and (consp uArg) 
        (eq (qcar uArg) '|:|)
        (progn
         (setq t1 (qcdr uArg))
         (and (consp t1)
              (progn
               (setq t2 (qcdr t1))
               (and (consp t2)
                    (eq (qcdr t2) nil)
                    (progn (setq t3 (qcar t2)) t))))))
   (equal t3 m))
  (t (equal uArg m)))))

\end{chunk}

\defun{msgText}{msgText}
\calls{msgText}{segmentKeyedMsg}
\calls{msgText}{substituteSegmentedMsg}
\calls{msgText}{flowSegmentedMsg}
\usesdollar{msgText}{linelength}
\usesdollar{msgText}{margin}
\begin{chunk}{defun msgText}
(defun |msgText| (key args)
 (let (msg)
 (declare (special $linelength $margin))
  (setq msg (|segmentKeyedMsg| key))
  (setq msg (|substituteSegmentedMsg| msg args))
  (setq msg (|flowSegmentedMsg| msg $linelength $margin))
  (apply #'concat (mapcar #'princ-to-string (cdar msg)))))

\end{chunk}

\defun{justifyMyType}{Right-justify the Type output}
\calls{justifyMyType}{fillerSpaces}
\usesdollar{justifyMyType}{linelength}
\begin{chunk}{defun justifyMyType}
(defun |justifyMyType| (arg)
 (let (len)
 (declare (special $linelength))
  (setq len (|#| arg))
  (if (> len $linelength)
   arg
   (concat (|fillerSpaces| (- $linelength len)) arg))))

\end{chunk}

\defun{unescapeStringsInForm}{Destructively fix quotes in strings}
\calls{unescapeStringsInForm}{unescapeStringsInForm}
\usesdollar{unescapeStringsInForm}{funnyBacks}
\usesdollar{unescapeStringsInForm}{funnyQuote}
\begin{chunk}{defun unescapeStringsInForm}
(defun |unescapeStringsInForm| (form)
 (let (str)
 (declare (special |$funnyBacks| |$funnyQuote|))
  (cond
   ((stringp form)
    (setq str (nsubstitute #\" |$funnyQuote| form))
    (nsubstitute #\\ |$funnyBacks| str))
   ((consp form) 
    (|unescapeStringsInForm| (car form))
    (|unescapeStringsInForm| (cdr form))
    form)
   (t form))))

\end{chunk}

\defunsec{intloopInclude}{Include a file into the stream}
\calls{intloopInclude}{intloopInclude0}
\begin{chunk}{defun intloopInclude}
(defun |intloopInclude| (name n)
  "Include a file into the stream"
  (with-open-file (st name) (|intloopInclude0| st name n)))

\end{chunk}

\defun{intloopInclude0}{intloopInclude0}
\calls{intloopInclude0}{incStream}
\calls{intloopInclude0}{intloopProcess}
\calls{intloopInclude0}{next}
\calls{intloopInclude0}{intloopEchoParse}
\calls{intloopInclude0}{insertpile}
\calls{intloopInclude0}{lineoftoks}
\usesdollar{intloopInclude0}{lines}
\begin{chunk}{defun intloopInclude0}
(defun |intloopInclude0| (|st| |name| |n|)
 (let (|$lines|)
 (declare (special |$lines|))
  (setq |$lines| (|incStream| |st| |name|))
  (|intloopProcess| |n| NIL 
   (|next| #'|intloopEchoParse|
    (|next| #'|insertpile|
     (|next| #'|lineoftoks|
      |$lines|))))))

\end{chunk}

\defun{intloopProcess}{intloopProcess}
An example call looks like:
\begin{verbatim}
      3> (|intloopProcess| 1 T 
          (|nonnullstream| #0=|next1| |ncloopParse| 
            (|nonnullstream| #0# |lineoftoks| 
              (|nonnullstream| |incZip1| |incRenumberLine| 
               (|nonnullstream| |incLude1| 0 ("1") 0 ("strings") (1))
               (|nonnullstream| |incIgen1| 0)))))
\end{verbatim}
which was constructed \bfref{intloopProcessString}. This call
says we are processing the first input, in this case ``1''. 
It is interactive. The third argument, the delay, contains the
information to drive the rest of the process.
\calls{intloopProcess}{StreamNull}
\calls{intloopProcess}{pfAbSynOp?}
\calls{intloopProcess}{setCurrentLine}
\calls{intloopProcess}{tokPart}
\calls{intloopProcess}{intloopProcess}
\calls{intloopProcess}{intloopSpadProcess}
\callsdollar{intloopProcess}{systemCommandFunction}
\usesdollar{intloopProcess}{systemCommandFunction}
\label{intloopProcess}
\sig{intloopProcess}{(StepNo,Boolean,Delay)}{StepNo}
\begin{chunk}{defun intloopProcess}
(defun |intloopProcess| (stepno interactive delay)
 (let (ptree lines t1)
 (declare (special |$systemCommandFunction|))
  (cond
   ((|StreamNull| delay) stepno)
   (t
    (setq t1 (car delay))
    (setq lines (car t1))
    (setq ptree (cadr t1))
    (cond
     ((|pfAbSynOp?| ptree '|command|)
       (when interactive (|setCurrentLine| (|tokPart| ptree)))
       (funcall |$systemCommandFunction| (|tokPart| ptree))
       (|intloopProcess| stepno interactive (cdr delay)))
     (t
       (|intloopProcess|
         (|intloopSpadProcess| stepno lines ptree interactive)
         interactive (cdr delay))))))))

\end{chunk}

\defun{intloopSpadProcess}{intloopSpadProcess}
\catches{intloopSpadProcess}{flung}
\catches{intloopSpadProcess}{SpadCompileItem}
\catches{intloopSpadProcess}{intCoerceFailure}
\catches{intloopSpadProcess}{intSpadReader}
\calls{intloopSpadProcess}{ncPutQ}
\calls{intloopSpadProcess}{CatchAsCan}
\calls{intloopSpadProcess}{Catch}
\calls{intloopSpadProcess}{intloopSpadProcess,interp}
\usesdollar{intloopSpadProcess}{currentCarrier}
\usesdollar{intloopSpadProcess}{ncMsgList}
\usesdollar{intloopSpadProcess}{intCoerceFailure}
\usesdollar{intloopSpadProcess}{intSpadReader}
\usesdollar{intloopSpadProcess}{prevCarrier}
\usesdollar{intloopSpadProcess}{stepNo}
\usesdollar{intloopSpadProcess}{NeedToSignalSessionManager}
\uses{intloopSpadProcess}{flung}
\begin{chunk}{defun intloopSpadProcess}
(defun |intloopSpadProcess| (stepNo lines ptree interactive?)
 (let (|$stepNo| result cc)
 (declare (special |$stepNo| |$prevCarrier| |$intSpadReader| |flung|
                   |$intCoerceFailure| |$ncMsgList| |$currentCarrier|
                   |$NeedToSignalSessionManager|))
  (setq |$stepNo| stepNo)
  (setq |$currentCarrier| (setq cc (list '|carrier|)))
  (|ncPutQ| cc '|stepNumber| stepNo)
  (|ncPutQ| cc '|messages| |$ncMsgList|)
  (|ncPutQ| cc '|lines| lines)
  (setq |$ncMsgList| nil)
  (setq result
    (catch '|SpadCompileItem|
     (catch |$intCoerceFailure|
      (catch |$intSpadReader|
       (|intloopSpadProcess,interp| cc ptree interactive?)))))
  (setq |$NeedToSignalSessionManager| t)
  (setq |$prevCarrier| |$currentCarrier|)
  (cond
    ((eq result '|ncEnd|) stepNo)
    ((eq result '|ncError|) stepNo)
    ((eq result '|ncEndItem|) stepNo)
    (t (1+ stepNo)))))

\end{chunk}

\defun{intloopSpadProcess,interp}{intloopSpadProcess,interp}
\calls{intloopSpadProcess,interp}{ncConversationPhase}
\calls{intloopSpadProcess,interp}{ncEltQ}
\calls{intloopSpadProcess,interp}{ncError}
\begin{chunk}{defun intloopSpadProcess,interp}
(defun |intloopSpadProcess,interp| (cc ptree interactive?)
 (|ncConversationPhase| #'|phParse| (list cc ptree))
 (|ncConversationPhase| #'|phMacro| (list cc))
 (|ncConversationPhase| #'|phIntReportMsgs| (list cc interactive?))
 (|ncConversationPhase| #'|phInterpret| (list cc))
 (unless (eql (length (|ncEltQ| cc '|messages|)) 0) (|ncError|)))

\end{chunk}

\defun{phParse}{phParse}
\tpdhere{The pform function has a leading percent sign}
\begin{verbatim}
phParse: carrier[tokens,...] -> carrier[ptree, tokens,...]
\end{verbatim}
\calls{phParse}{ncPutQ}
\begin{chunk}{defun phParse}
(defun |phParse| (carrier ptree)
  (|ncPutQ| carrier '|ptree| ptree)
  'ok)

\end{chunk}

\defun{phIntReportMsgs}{phIntReportMsgs}
\begin{verbatim}
carrier[lines,messages,..]-> carrier[lines,messages,..]
\end{verbatim}
\calls{phIntReportMsgs}{ncEltQ}
\calls{phIntReportMsgs}{ncPutQ}
\calls{phIntReportMsgs}{processMsgList}
\usesdollar{phIntReportMsgs}{erMsgToss}
\begin{chunk}{defun phIntReportMsgs}
(defun |phIntReportMsgs| (carrier interactive?)
 (declare (ignore interactive?))
 (let (nerr msgs lines)
 (declare (special |$erMsgToss|))
  (cond
   (|$erMsgToss| 'ok)
   (t
     (setq lines (|ncEltQ| carrier '|lines|))
     (setq msgs (|ncEltQ| carrier '|messages|))
     (setq nerr (length msgs))
     (|ncPutQ| carrier '|ok?| (eql nerr 0))
     (cond
      ((eql nerr 0) 'ok)
      (t
       (|processMsgList| msgs lines)
       (|sayKeyedMsg| "%1 error(s) parsing " (list nerr))
       'ok))))))

\end{chunk}

\defun{phInterpret}{phInterpret}
\calls{phInterpret}{ncEltQ}
\calls{phInterpret}{intInterpretPform}
\calls{phInterpret}{ncPutQ}
\begin{chunk}{defun phInterpret}
(defun |phInterpret| (carrier)
 (let (val ptree)
  (setq ptree (|ncEltQ| carrier '|ptree|))
  (setq val (|intInterpretPform| ptree))
  (|ncPutQ| carrier '|value| val)))

\end{chunk}

\defun{intInterpretPform}{intInterpretPform}
\calls{intInterpretPform}{processInteractive}
\calls{intInterpretPform}{zeroOneTran}
\calls{intInterpretPform}{pf2Sex}
\begin{chunk}{defun intInterpretPform}
(defun |intInterpretPform| (pf)
  (|processInteractive| (|zeroOneTran| (|pf2Sex| pf)) pf))

\end{chunk}

\defun{zeroOneTran}{zeroOneTran}
\calls{zeroOneTran}{nsubst}
\begin{chunk}{defun zeroOneTran 0}
(defun |zeroOneTran| (sex)
 (nsubst '|$EmptyMode| '? sex))

\end{chunk}

\defun{ncConversationPhase}{ncConversationPhase}
\calls{ncConversationPhase}{ncConversationPhase,wrapup}
\usesdollar{ncConversationPhase}{ncMsgList}
\begin{chunk}{defun ncConversationPhase}
(defun |ncConversationPhase| (fn args)
 (let (|$ncMsgList| carrier)
 (declare (special |$ncMsgList|))
  (setq carrier (car args))
  (setq |$ncMsgList| nil)
  (unwind-protect
   (apply fn args)
   (|ncConversationPhase,wrapup| carrier))))

\end{chunk}

\defun{ncConversationPhase,wrapup}{ncConversationPhase,wrapup}
\usesdollar{ncConversationPhase,wrapup}{ncMsgList}
\begin{chunk}{defun ncConversationPhase,wrapup}
(defun |ncConversationPhase,wrapup| (carrier)
 (declare (special |$ncMsgList|))
  ((lambda (Var5 m)
   (loop
    (cond
     ((or (atom Var5) (progn (setq m (car Var5)) nil))
       (return nil))
     (t
      (|ncPutQ| carrier '|messages| (cons m (|ncEltQ| carrier '|messages|)))))
    (setq Var5 (cdr Var5))))
   |$ncMsgList| nil))

\end{chunk}

\defun{ncError}{ncError}
\throws{ncError}{SpadCompileItem}
\begin{chunk}{defun ncError 0}
(defun |ncError| ()
 (throw '|SpadCompileItem| '|ncError|))

\end{chunk}

\defun{intloopEchoParse}{intloopEchoParse}
\calls{intloopEchoParse}{ncloopDQlines}
\calls{intloopEchoParse}{setCurrentLine}
\calls{intloopEchoParse}{mkLineList}
\calls{intloopEchoParse}{ncloopPrintLines}
\calls{intloopEchoParse}{npParse}
\calls{intloopEchoParse}{dqToList}
\usesdollar{intloopEchoParse}{EchoLines}
\usesdollar{intloopEchoParse}{lines}
\begin{chunk}{defun intloopEchoParse}
(defun |intloopEchoParse| (s)
 (let (cudr lines stream dq t1)
 (declare (special |$EchoLines| |$lines|))
  (setq t1 (car s))
  (setq dq (car t1))
  (setq stream (cadr t1))
  (setq t1 (|ncloopDQlines| dq |$lines|))
  (setq lines (car t1))
  (setq cudr (cadr t1))
  (|setCurrentLine| (|mkLineList| lines))
  (when |$EchoLines| (|ncloopPrintLines| lines))
  (setq |$lines| cudr)
  (cons (list (list lines (|npParse| (|dqToList| dq)))) (cdr s))))

\end{chunk}

\defun{ncloopPrintLines}{ncloopPrintLines}
\begin{verbatim}
;ncloopPrintLines lines ==
;        for line in lines repeat WRITE_-LINE CDR line
;        WRITE_-LINE '" "
\end{verbatim}
\begin{chunk}{defun ncloopPrintLines 0}
(defun |ncloopPrintLines| (lines)
 ((lambda (Var4 line)
  (loop
   (cond
    ((or (atom Var4) (progn (setq line (car Var4)) nil))
      (return nil))
    (t (write-line (cdr line))))
   (setq Var4 (cdr Var4))))
  lines nil)
 (write-line " "))

\end{chunk}

\defun{mkLineList}{mkLineList}
\begin{verbatim}
;mkLineList lines ==
;  l := [CDR line for line in lines | nonBlank CDR line]
;  #l = 1 => CAR l
;  l
\end{verbatim}
\begin{chunk}{defun mkLineList}
(defun |mkLineList| (lines)
 (let (l)
  (setq l
   ((lambda (Var2 Var1 line)
     (loop
      (cond
       ((or (atom Var1) (progn (setq line (car Var1)) nil))
         (return (nreverse Var2)))
       (t
        (and (|nonBlank| (cdr line))
             (setq Var2 (cons (cdr line) Var2)))))
      (setq Var1 (cdr Var1))))
    nil lines nil))
  (cond 
   ((eql (length l) 1) (car l))
   (t l))))

\end{chunk}

\defun{nonBlank}{nonBlank}
\begin{verbatim}
;nonBlank str ==
;  value := false
;  for i in 0..MAXINDEX str repeat
;    str.i ^= char " " =>
;      value := true
;      return value
;  value
\end{verbatim}
\begin{chunk}{defun nonBlank 0}
(defun |nonBlank| (str)
 (let (value)
  ((lambda (Var3 i)
   (loop
    (cond
     ((> i Var3) (return nil))
     (t
      (cond
       ((not (equal (elt str i) #\Space))
         (identity (progn (setq value t) (return value)))))))
    (setq i (+ i 1))))
   (maxindex str) 0)
  value))

\end{chunk}

\defun{ncloopDQlines}{ncloopDQlines}
\calls{ncloopDQlines}{StreamNull}
\calls{ncloopDQlines}{poGlobalLinePosn}
\calls{ncloopDQlines}{tokPosn}
\calls{ncloopDQlines}{streamChop}
\begin{chunk}{defun ncloopDQlines}
(defun |ncloopDQlines| (dq stream)
 (let (b a)
  (|StreamNull| stream)
  (setq a (|poGlobalLinePosn| (|tokPosn| (cadr dq))))
  (setq b (|poGlobalLinePosn| (caar stream)))
  (|streamChop| (+ (- a b) 1) stream)))

\end{chunk}

\defun{poGlobalLinePosn}{poGlobalLinePosn}
\calls{poGlobalLinePosn}{lnGlobalNum}
\calls{poGlobalLinePosn}{poGetLineObject}
\calls{poGlobalLinePosn}{ncBug}
\begin{chunk}{defun poGlobalLinePosn}
(defun |poGlobalLinePosn| (posn)
 (if posn 
  (|lnGlobalNum| (|poGetLineObject| posn))
  (|ncBug| "old style pos objects have no global positions" nil)))

\end{chunk}

\defun{streamChop}{streamChop}
Note that changing the name ``lyne'' to ``line'' will break the system.
I do not know why. The symptom shows up when there is a file with a large
contiguous comment spanning enough lines to overflow the stack.

\calls{streamChop}{StreamNull}
\calls{streamChop}{streamChop}
\calls{streamChop}{ncloopPrefix?}
\begin{chunk}{defun streamChop}
(defun |streamChop| (n s)
 (let (d c lyne b a tmp1)
  (cond
   ((|StreamNull| s) (list nil nil))
   ((eql n 0) (list nil s))
   (t
     (setq tmp1 (|streamChop| (- n 1) (cdr s)))
     (setq a (car tmp1)) 
     (setq b (cadr tmp1))
     (setq lyne (car s))
     (setq c (|ncloopPrefix?| ")command" (cdr lyne)))
     (setq d (cons (car lyne) (cond (c c) (t (cdr lyne)))))
     (list (cons d a) b)))))

\end{chunk}

\defun{ncloopInclude0}{ncloopInclude0}
\calls{ncloopInclude0}{incStream}
\calls{ncloopInclude0}{ncloopProcess}
\calls{ncloopInclude0}{next}
\calls{ncloopInclude0}{ncloopEchoParse}
\calls{ncloopInclude0}{insertpile}
\calls{ncloopInclude0}{lineoftoks}
\usesdollar{ncloopInclude0}{lines}
\begin{chunk}{defun ncloopInclude0}
(defun |ncloopInclude0| (st name n)
 (let (|$lines|)
 (declare (special |$lines|))
   (setq |$lines| (|incStream| st name))
   (|ncloopProcess| n nil
    (|next| #'|ncloopEchoParse|
     (|next| #'|insertpile|
      (|next| #'|lineoftoks|
       |$lines|))))))

\end{chunk}

\defun{incStream}{incStream}
\calls{incStream}{incRenumber}
\calls{incStream}{incLude}
\calls{incStream}{incRgen}
\uses{incStream}{Top}
\begin{chunk}{defun incStream}
(defun |incStream| (st fn)
 (declare (special |Top|))
 (|incRenumber| (|incLude| 0 (|incRgen| st) 0 (list fn) (list |Top|))))

\end{chunk}

\defun{incRenumber}{incRenumber}
\calls{incRenumber}{incZip}
\calls{incRenumber}{incIgen}
\label{incRenumber}
\sig{incRenumber}{Delay}{Delay}
\begin{chunk}{defun incRenumber}
(defun |incRenumber| (ssx)
 (|incZip| #'|incRenumberLine| ssx (|incIgen| 0)))

\end{chunk}

\defun{incZip}{incZip}
Axiom ``zips'' a function together with two delays into a delay.

\calls{incZip}{Delay}
\calls{incZip}{incZip1}
\label{incZip}
\sig{incZip}{(Function,Delay,Delay)}{Delay}
\begin{chunk}{defun incZip}
(defun |incZip| (function delay1 delay2)
  (|Delay| #'|incZip1| (list function delay1 delay2)))

\end{chunk}

\defun{incZip1}{incZip1}
\calls{incZip1}{StreamNull}
\calls{incZip1}{incZip}
\label{incZip1}
\sig{incZip1}{Delay}{ParsePair}
\begin{chunk}{defun incZip1}
(defun |incZip1| (&rest delayArg)
 (let (function delay1 delay2)
  (setq function (car delayArg))
  (setq delay1 (cadr delayArg))
  (setq delay2 (caddr delayArg))
  (cond
   ((|StreamNull| delay1) |StreamNil|)
   ((|StreamNull| delay2) |StreamNil|)
   (t 
     (cons
      (funcall function (car delay1) (car delay2))
      (|incZip| function (cdr delay1) (cdr delay2)))))))

\end{chunk}

\defun{incIgen}{incIgen}
\calls{incIgen}{Delay}
\calls{incIgen}{incIgen1}
\label{incIgen}
\sig{incIgen}{Integer}{Delay}
\begin{chunk}{defun incIgen}
(defun |incIgen| (int)
 (|Delay| #'|incIgen1| (list int)))

\end{chunk}

\defun{incIgen1}{incIgen1}
\calls{incIgen1}{incIgen}
\begin{chunk}{defun incIgen1}
(defun |incIgen1| (&rest z)
 (let (n)
  (setq n (car z))
  (setq n (+ n 1))
  (cons n (|incIgen| n))))

\end{chunk}

\defun{incRenumberLine}{incRenumberLine}
\calls{incRenumberLine}{incRenumberItem}
\calls{incRenumberLine}{incHandleMessage}
\label{incRenumberLine}
\begin{chunk}{defun incRenumberLine}
(defun |incRenumberLine| (xl gno)
 (let (l)
  (setq l (|incRenumberItem| (elt xl 0) gno))
  (|incHandleMessage| xl)
  l))

\end{chunk}
\defun{incRenumberItem}{incRenumberItem}
\calls{incRenumberItem}{lnSetGlobalNum}
\begin{chunk}{defun incRenumberItem}
(defun |incRenumberItem| (f i)
 (let (l)
  (setq l (caar f))
  (|lnSetGlobalNum| l i) f))

\end{chunk}

\defun{incHandleMessage}{incHandleMessage}
\calls{incHandleMessage}{ncSoftError}
\calls{incHandleMessage}{ncBug}
\begin{chunk}{defun incHandleMessage 0}
(defun |incHandleMessage| (x)
 "Message handling for the source includer"
 (let ((msgtype (elt (elt x 1) 1))
       (pos (car (elt x 0)))
       (key (car (elt (elt x 1) 0)))
       (args (cadr (elt (elt x 1) 0))))
       
 (cond
  ((eq msgtype '|none|)    0)
  ((eq msgtype '|error|)   (|ncSoftError| pos key args))
  ((eq msgtype '|warning|) (|ncSoftError| pos key args))
  ((eq msgtype '|say|)     (|ncSoftError| pos key args))
  (t                       (|ncBug| key args)))))

\end{chunk}

\defun{incLude}{incLude}
This function takes
\begin{enumerate}
\item {\bf eb} -- in Integer
\item {\bf ss} -- a list of strings
\item {\bf ln} -- an Integer
\item {\bf ufos} -- a list of strings
\item {\bf states} -- a list of integers
\end{enumerate}
and constructs a call to \bfref{Delay}.

\calls{incLude}{Delay}
\calls{include}{incLude1}
\label{incLude}
\sig{incLude}{(Int,List(String),Int,List(String),List(Int))}{Delay}
\begin{chunk}{defun incLude}
(defun |incLude| (eb ss ln ufos states) 
 (|Delay| #'|incLude1| (list eb ss ln ufos states)))

\end{chunk}

\defmacro{Rest}
\begin{chunk}{defmacro Rest}
(defmacro |Rest| ()
 "used in incLude1 for parsing; s is not used."
 '(|incLude| eb (cdr ss) lno ufos states))

\end{chunk}

\defvar{Top}
\begin{chunk}{initvars}
(defvar |Top| 1 "used in incLude1 for parsing")

\end{chunk}

\defvar{IfSkipToEnd}
\begin{chunk}{initvars}
(defvar |IfSkipToEnd| 10 "used in incLude1 for parsing")

\end{chunk}

\defvar{IfKeepPart}
\begin{chunk}{initvars}
(defvar |IfKeepPart| 11 "used in incLude1 for parsing")

\end{chunk}

\defvar{IfSkipPart}
\begin{chunk}{initvars}
(defvar |IfSkipPart| 12 "used in incLude1 for parsing")

\end{chunk}

\defvar{ElseifSkipToEnd}
\begin{chunk}{initvars}
(defvar |ElseifSkipToEnd| 20 "used in incLude1 for parsing")

\end{chunk}

\defvar{ElseifKeepPart}
\begin{chunk}{initvars}
(defvar |ElseifKeepPart| 21 "used in incLude1 for parsing")

\end{chunk}

\defvar{ElseifSkipPart}
\begin{chunk}{initvars}
(defvar |ElseifSkipPart| 22 "used in incLude1 for parsing")

\end{chunk}

\defvar{ElseSkipToEnd}
\begin{chunk}{initvars}
(defvar |ElseSkipToEnd| 30 "used in incLude1 for parsing")

\end{chunk}

\defvar{ElseKeepPart}
\begin{chunk}{initvars}
(defvar |ElseKeepPart| 31 "used in incLude1 for parsing")

\end{chunk}

\defun{Top?}{Top?}
\calls{Top?}{quotient}
\begin{chunk}{defun Top? 0}
(defun |Top?| (|st|)
 "used in incLude1 for parsing"
 (eql (quotient |st| 10) 0))

\end{chunk}

\defun{If?}{If?}
\calls{If?}{quotient}
\begin{chunk}{defun If?}
(defun |If?| (|st|)
 "used in incLude1 for parsing"
 (eql (quotient |st| 10) 1))

\end{chunk}

\defun{Elseif?}{Elseif?}
\calls{Elseif?}{quotient}
\begin{chunk}{defun Elseif?}
(defun |Elseif?| (|st|)
 "used in incLude1 for parsing"
 (eql (quotient |st| 10) 2))

\end{chunk}

\defun{Else?}{Else?}
\calls{Else?}{quotient}
\begin{chunk}{defun Else?}
(defun |Else?| (|st|)
 "used in incLude1 for parsing"
 (eql (quotient |st| 10) 3))

\end{chunk}

\defun{SkipEnd?}{SkipEnd?}
\calls{SkipEnd?}{remainder}
\begin{chunk}{defun SkipEnd?}
(defun |SkipEnd?| (|st|)
 "used in incLude1 for parsing"
 (eql (remainder |st| 10) 0))

\end{chunk}

\defun{KeepPart?}{KeepPart?}
\calls{KeepPart?}{remainder}
\begin{chunk}{defun KeepPart?}
(defun |KeepPart?| (|st|)
 "used in incLude1 for parsing"
 (eql (remainder |st| 10) 1))

\end{chunk}

\defun{SkipPart?}{SkipPart?}
\calls{SkipPart?}{remainder}
\begin{chunk}{defun SkipPart?}
(defun |SkipPart?| (|st|)
 "used in incLude1 for parsing"
 (eql (remainder |st| 10) 2))

\end{chunk}

\defun{Skipping?}{Skipping?}
\calls{Skipping?}{KeepPart?}
\begin{chunk}{defun Skipping?}
(defun |Skipping?| (|st|)
 "used in incLude1 for parsing"
 (null (|KeepPart?| |st|)))

\end{chunk}

\defun{incLude1}{incLude1}
\calls{incLude1}{StreamNull}
\calls{incLude1}{Top?}
\calls{incLude1}{xlPrematureEOF}
\calls{incLude1}{Skipping?}
\calls{incLude1}{xlSkip}
\calls{incLude1}{Rest}
\calls{incLude1}{xlOK}
\calls{incLude1}{xlOK1}
\calls{incLude1}{concat}
\calls{incLude1}{incCommandTail}
\calls{incLude1}{xlSay}
\calls{incLude1}{xlNoSuchFile}
\calls{incLude1}{xlCannotRead}
\calls{incLude1}{incActive?}
\calls{incLude1}{xlFileCycle}
\calls{incLude1}{incLude}
\calls{incLude1}{incFileInput}
\calls{incLude1}{incAppend}
\calls{incLude1}{inclFname}
\calls{incLude1}{xlConActive}
\calls{incLude1}{xlConStill}
\calls{incLude1}{incConsoleInput}
\calls{incLude1}{incNConsoles}
\calls{incLude1}{xlConsole}
\calls{incLude1}{xlSkippingFin}
\calls{incLude1}{xlPrematureFin}
\calls{incLude1}{assertCond}
\calls{incLude1}{ifCond}
\calls{incLude1}{If?}
\calls{incLude1}{Elseif?}
\calls{incLude1}{xlIfSyntax}
\calls{incLude1}{SkipEnd?}
\calls{incLude1}{KeepPart?}
\calls{incLude1}{SkipPart?}
\calls{incLude1}{xlIfBug}
\calls{incLude1}{xlCmdBug}
\calls{incLude1}{expand-tabs}
\calls{incLude1}{incClassify}
\begin{chunk}{defun incLude1}
(defun |incLude1| (&rest z)
 (let (pred s1 n tail head includee fn1 info str state lno states 
       ufos ln ss eb)
  (setq eb (car z))
  (setq ss (cadr . (z)))
  (setq ln (caddr . (z)))
  (setq ufos (cadddr . (z)))
  (setq states (car (cddddr . (z))))
  (setq lno (+ ln 1))
  (setq state (elt states 0))
  (cond
   ((|StreamNull| ss)
     (cond
      ((null (|Top?| state))
       (cons (|xlPrematureEOF| eb ")--premature end" lno ufos)
             |StreamNil|))
      (t |StreamNil|)))
   (t
    (progn
     (setq str (expand-tabs (car ss)))
     (setq info (|incClassify| str))
     (cond
      ((null (elt info 0))
       (cond
        ((|Skipping?| state)
         (cons (|xlSkip| eb str lno (elt ufos 0)) (|Rest|)))
        (t
         (cons (|xlOK| eb str lno (elt ufos 0)) (|Rest|)))))
      ((equal (elt info 2) "other")
       (cond
        ((|Skipping?| state)
         (cons (|xlSkip| eb str lno (elt ufos 0)) (|Rest|)))
        (t
         (cons
          (|xlOK1| eb str (concat ")command" str) lno (elt ufos 0))
          (|Rest|)))))
      ((equal (elt info 2) "say")
       (cond
        ((|Skipping?| state)
         (cons (|xlSkip| eb str lno (elt ufos 0)) (|Rest|)))
        (t
         (progn
          (setq str (|incCommandTail| str info))
          (cons (|xlSay| eb str lno ufos str)
           (cons (|xlOK| eb str lno (ELT ufos 0)) (|Rest|)))))))
      ((equal (elt info 2) "include")
       (cond
        ((|Skipping?| state)
         (cons (|xlSkip| eb str lno (elt ufos 0)) (|Rest|)))
        (t
         (progn
          (setq fn1 (|inclFname| str info))
          (cond
           ((null fn1)
            (cons (|xlNoSuchFile| eb str lno ufos fn1) (|Rest|)))
           ((null (probe-file fn1))
            (cons (|xlCannotRead| eb str lno ufos fn1) (|Rest|)))
           ((|incActive?| fn1 ufos)
            (cons (|xlFileCycle| eb str lno ufos fn1) (|Rest|)))
           (t
            (progn
             (setq includee
              (|incLude| (+ eb (elt info 1))
                         (|incFileInput| fn1)
                         0
                         (cons fn1 ufos)
                         (cons |Top| states)))
             (cons (|xlOK| eb str lno (elt ufos 0))
                   (|incAppend| includee (|Rest|))))))))))
      ((equal (elt info 2) "console")
       (cond
        ((|Skipping?| state)
         (cons (|xlSkip| eb str lno (elt ufos 0)) (|Rest|)))
        (t
         (progn
          (setq head
           (|incLude| (+ eb (elt info 1))
                      (|incConsoleInput|)
                      0
                      (cons "console" ufos)
                      (cons |Top| states)))
          (setq tail (|Rest|))
          (setq n (|incNConsoles| ufos))
          (cond
           ((< 0 n)
            (setq head
             (cons (|xlConActive| eb str lno ufos n) head))
            (setq tail
             (cons (|xlConStill| eb str lno ufos n) tail))))
          (setq head (cons (|xlConsole| eb str lno ufos) head))
          (cons (|xlOK| eb str lno (elt ufos 0))
                (|incAppend| head tail))))))
      ((equal (elt info 2) "fin")
       (cond
        ((|Skipping?| state)
         (cons (|xlSkippingFin| eb str lno ufos) (|Rest|)))
        ((null (|Top?| state))
         (cons (|xlPrematureFin| eb str lno ufos) |StreamNil|))
        (t
         (cons (|xlOK| eb str lno (elt ufos 0)) |StreamNil|))))
      ((equal (elt info 2) "assert")
       (cond
        ((|Skipping?| state)
         (cons (|xlSkippingFin| eb str lno ufos) (|Rest|)))
        (t
         (progn
          (|assertCond| str info)
          (cons (|xlOK| eb str lno (elt ufos 0))
                (|incAppend| includee (|Rest|)))))))
      ((equal (elt info 2) "if")
       (progn
        (setq s1
         (cond
          ((|Skipping?| state) |IfSkipToEnd|)
          (t
           (cond
            ((|ifCond| str info) |IfKeepPart|)
            (t |IfSkipPart|)))))
        (cons (|xlOK| eb str lno (elt ufos 0))
              (|incLude| eb (cdr ss) lno ufos (cons s1 states)))))
      ((equal (elt info 2) "elseif")
       (cond
        ((and (null (|If?| state)) (null (|Elseif?| state)))
         (cons (|xlIfSyntax| eb str lno ufos info states)
               |StreamNil|))
        (t
         (cond
          ((or (|SkipEnd?| state) 
               (|KeepPart?| state)
               (|SkipPart?| state))
           (setq s1
            (cond
             ((|SkipPart?| state)
              (setq pred (|ifCond| str info))
              (cond
               (pred |ElseifKeepPart|)
               (t |ElseifSkipPart|)))
             (t |ElseifSkipToEnd|)))
           (cons (|xlOK| eb str lno (elt ufos 0))
                 (|incLude| eb (cdr ss) lno ufos (cons s1 (cdr states)))))
          (t
           (cons (|xlIfBug| eb str lno ufos) |StreamNil|))))))
      ((equal (elt info 2) "else")
       (cond
        ((and (null (|If?| state)) (null (|Elseif?| state)))
         (cons (|xlIfSyntax| eb str lno ufos info states)
               |StreamNil|))
        (t
         (cond
          ((or (|SkipEnd?| state) 
               (|KeepPart?| state) 
               (|SkipPart?| state))
            (setq s1
             (cond ((|SkipPart?| state) |ElseKeepPart|) (t |ElseSkipToEnd|)))
            (cons (|xlOK| eb str lno (elt ufos 0))
                  (|incLude| eb (cdr ss) lno ufos (cons s1 (cdr states)))))
          (t
           (cons (|xlIfBug| eb str lno ufos) |StreamNil|))))))
      ((equal (elt info 2) "endif")
       (cond
        ((|Top?| state)
         (cons (|xlIfSyntax| eb str lno ufos info states)
               |StreamNil|))
        (t
         (cons (|xlOK| eb str lno (elt ufos 0))
               (|incLude| eb (cdr ss) lno ufos (cdr states))))))
      (t (cons (|xlCmdBug| eb str lno ufos) |StreamNil|))))))))

\end{chunk}

\defun{xlPrematureEOF}{xlPrematureEOF}
\calls{xlPrematureEOF}{xlMsg}
\calls{xlPrematureEOF}{inclmsgPrematureEOF}
\begin{chunk}{defun xlPrematureEOF}
(defun |xlPrematureEOF| (eb str lno ufos)
 (|xlMsg| eb str lno (elt ufos 0)
          (list (|inclmsgPrematureEOF| (elt ufos 0)) '|error|)))

\end{chunk}

\defun{xlMsg}{xlMsg}
\calls{xlMsg}{incLine}
\begin{chunk}{defun xlMsg}
(defun |xlMsg| (extrablanks string localnum fileobj mess)
 (let ((globalnum -1))
  (list (incLine extrablanks string globalnum localnum fileobj) mess)))

\end{chunk}

\defun{xlOK}{xlOK}
\calls{xlOK}{xlOK1}
\begin{chunk}{defun xlOK}
(defun |xlOK| (extrablanks string localnum fileobj)
 (|xlOK1| extrablanks string string localnum fileobj))

\end{chunk}

\defun{xlOK1}{xlOK1}
\calls{xlOK1}{incLine1}
\begin{chunk}{defun xlOK1}
(defun |xlOK1| (extrablanks string string1 localnum fileobj)
 (let ((globalnum -1))
  (list (incLine1 extrablanks string string1 globalnum localnum fileobj)
    (list nil '|none|))))

\end{chunk}

\defun{incAppend}{incAppend}
\calls{incAppend}{Delay}
\calls{incAppend}{incAppend1}
\begin{chunk}{defun incAppend}
(defun |incAppend| (x y)
 (|Delay| #'|incAppend1| (list x y)))

\end{chunk}

\defun{incAppend1}{incAppend1}
\calls{incAppend1}{StreamNull}
\calls{incAppend1}{incAppend}
\begin{chunk}{defun incAppend1}
(defun |incAppend1| (&rest z)
 (let (y x)
  (setq x (car z))
  (setq y (cadr z))
  (cond
   ((|StreamNull| x) 
    (cond ((|StreamNull| y) |StreamNil|) (t y)))
   (t 
    (cons (car x) (|incAppend| (cdr x) y))))))

\end{chunk}

\defun{incLine}{incLine}
\calls{incLine}{incLine1}
\begin{chunk}{defun incLine}
(defun incLine (extrablanks string globalnum localnum fileobj)
 (incLine1 extrablanks string string globalnum localnum fileobj))

\end{chunk}

\defun{incLine1}{incLine1}
\calls{incLine1}{lnCreate}
\begin{chunk}{defun incLine1}
(defun incLine1 (extrablanks string string1 globalnum localnum fileobj)
 (cons
  (cons (|lnCreate| extrablanks string globalnum localnum fileobj) 1) string1))

\end{chunk}

\defun{inclmsgPrematureEOF}{inclmsgPrematureEOF}
\calls{inclmsgPrematureEOF}{theorigin}
\begin{chunk}{defun inclmsgPrematureEOF 0}
(defun |inclmsgPrematureEOF| (ufo)
 (list 
  (format nil
   "File %1f ended where at least one )endif was still needed.
    An appropriate number of )endif lines has been assumed.")
  (list (|theorigin| ufo))))

\end{chunk}

\defun{theorigin}{theorigin}
\begin{chunk}{defun theorigin 0}
(defun |theorigin| (x) (list #'|porigin| x))

\end{chunk}

\defun{porigin}{porigin}
\calls{porigin}{pfname}
\begin{chunk}{defun porigin}
(defun |porigin| (x)
 (if (stringp x)
  x
  (|pfname| x)))

\end{chunk}

\defun{ifCond}{ifCond}
\calls{ifCond}{MakeSymbol}
\calls{ifCond}{incCommandTail}
\usesdollar{ifCond}{inclAssertions}
\begin{chunk}{defun ifCond}
(defun |ifCond| (s info)
 (let (word)
 (declare (special |$inclAssertions|))
  (setq word 
   (|MakeSymbol| (string-trim *whitespace* (|incCommandTail| s info))))
  (member word |$inclAssertions|)))

\end{chunk}

\defun{xlSkip}{xlSkip}
\calls{xlSkip}{incLine}
\calls{xlSkip}{concat}
\begin{chunk}{defun xlSkip}
(defun |xlSkip| (extrablanks str localnum fileobj)
 (let ((string (concat "-- Omitting:" str)) (globalnum -1))
 (list 
  (incLine extrablanks string globalnum localnum fileobj)
  (list nil '|none|))))

\end{chunk}

\defun{xlSay}{xlSay}
\calls{xlSay}{xlMsg}
\calls{xlSay}{inclmsgSay}
\begin{chunk}{defun xlSay}
(defun |xlSay| (eb str lno ufos x)
 (|xlMsg| eb str lno (elt ufos 0) (list (|inclmsgSay| x) '|say|)))

\end{chunk}

\defun{inclmsgSay}{inclmsgSay}
\calls{inclmsgSay}{theid}
\begin{chunk}{defun inclmsgSay}
(defun |inclmsgSay| (str)
 (list "%1f" (list (|theid| str))))

\end{chunk}

\defun{theid}{theid}
\begin{chunk}{defun theid 0}
(defun |theid| (a) (list #'identity a))

\end{chunk}

\defun{xlNoSuchFile}{xlNoSuchFile}
\calls{xlNoSuchFile}{xlMsg}
\calls{xlNoSuchFile}{inclmsgNoSuchFile}
\begin{chunk}{defun xlNoSuchFile}
(defun |xlNoSuchFile| (eb str lno ufos fn)
 (|xlMsg| eb str lno (elt ufos 0) (list (|inclmsgNoSuchFile| fn) '|error|)))

\end{chunk}

\defun{inclmsgNoSuchFile}{inclmsgNoSuchFile}
\calls{inclmsgNoSuchFile}{thefname}
\begin{chunk}{defun inclmsgNoSuchFile}
(defun |inclmsgNoSuchFile| (fn)
 (list "The )include file %1f does not exist." (list (|thefname| fn))))

\end{chunk}

\defun{thefname}{thefname}
\calls{thefname}{pfname}
\begin{chunk}{defun thefname 0}
(defun |thefname| (x) (list #'|pfname| x))

\end{chunk}

\defun{pfname}{pfname}
\calls{pfname}{PathnameString}
\begin{chunk}{defun pfname}
(defun |pfname| (x) (|PathnameString| x))

\end{chunk}

\defun{xlCannotRead}{xlCannotRead}
\calls{xlCannotRead}{xlMsg}
\calls{xlCannotRead}{inclmsgCannotRead}
\begin{chunk}{defun xlCannotRead}
(defun |xlCannotRead| (eb str lno ufos fn)
 (|xlMsg| eb str lno (elt ufos 0) (list (|inclmsgCannotRead| fn) '|error|)))

\end{chunk}

\defun{inclmsgCannotRead}{inclmsgCannotRead}
\calls{inclmsgCannotRead}{thefname}
\begin{chunk}{defun inclmsgCannotRead}
(defun |inclmsgCannotRead| (fn)
 (list "The )include file %1f exists, but cannot be read."
   (list (|thefname| fn))))

\end{chunk}

\defun{xlFileCycle}{xlFileCycle}
\calls{xlFileCycle}{xlMsg}
\calls{xlFileCycle}{inclmsgFileCycle}
\begin{chunk}{defun xlFileCycle}
(defun |xlFileCycle| (eb str lno ufos fn)
 (|xlMsg| eb str lno (elt ufos 0) 
  (list (|inclmsgFileCycle| ufos fn) '|error|)))

\end{chunk}

\defun{inclmsgFileCycle}{inclmsgFileCycle}
\begin{verbatim}
;inclmsgFileCycle(ufos,fn) ==
;    flist := [porigin n for n in reverse ufos]
;    f1    := porigin fn
;    cycle := [:[:[n,'"==>"] for n in flist], f1]
;    ['SCI0004, [%id cycle, %id f1] ]

\end{verbatim}
\calls{inclmsgFileCycle}{porigin}
\calls{inclmsgFileCycle}{theid}
\begin{chunk}{defun inclmsgFileCycle}
(defun |inclmsgFileCycle| (ufos fn)
 (let (cycle f1 flist)
  (setq flist
   ((lambda (Var8 Var7 n)
     (loop
      (cond
       ((or (atom Var7) (progn (setq n (car Var7)) nil))
        (return (nreverse Var8)))
       (t
        (setq Var8 (cons (|porigin| n) Var8))))
      (setq Var7 (cdr Var7))))
    nil (reverse ufos) nil))
  (setq f1 (|porigin| fn))
  (setq cycle
   (append
    ((lambda (Var10 Var9 n)
      (loop
       (cond
        ((or (atom Var9) (progn (setq n (car Var9)) nil))
          (return (nreverse Var10)))
        (t
         (setq Var10 (append (reverse (list n "==>")) Var10))))
       (setq Var9 (cdr Var9))))
     nil flist nil)
    (cons f1 nil)))
  (list 
   (format nil
    "There is a cycle in the )include files: %i %l %1f %u %l. ~
     The inner occurrence of %2f has not been included.")
   (list (|theid| cycle) (|theid| f1)))))

\end{chunk}

\defun{xlConActive}{xlConActive}
\calls{xlConActive}{xlMsg}
\calls{xlConActive}{inclmsgConActive}
\begin{chunk}{defun xlConActive}
(defun |xlConActive| (eb str lno ufos n)
 (|xlMsg| eb str lno (elt ufos 0) (list (|inclmsgConActive| n) '|warning|)))

\end{chunk}

\defun{inclmsgConActive}{inclmsgConActive}
\calls{inclmsgConActive}{theid}
\begin{chunk}{defun inclmsgConActive}
(defun |inclmsgConActive| (n)
 (list 
  (format nil 
   "%1f other )console commands are currently active. ~
    While this new )console command is reading input the others ~
    will have to wait. !
    Remember, each )console command will need a separate )fin.")
  (list (|theid| n))))

\end{chunk}

\defun{xlConStill}{xlConStill}
\calls{xlConStill}{xlMsg}
\calls{xlConStill}{inclmsgConStill}
\begin{chunk}{defun xlConStill}
(defun |xlConStill| (eb str lno ufos n)
 (|xlMsg| eb str lno (elt ufos 0) (list (|inclmsgConStill| n) '|say|)))

\end{chunk}

\defun{inclmsgConStill}{inclmsgConStill}
\calls{inclmsgConStill}{theid}
\begin{chunk}{defun inclmsgConStill}
(defun |inclmsgConStill| (n)
 (list 
  (format nil 
   "The current )console command has finished reading. ~
    %1f are still active.  Remember, each will need a separate )fin.")
   (list (|theid| n))))

\end{chunk}

\defun{xlConsole}{xlConsole}
\calls{xlConsole}{xlMsg}
\calls{xlConsole}{inclmsgConsole}
\begin{chunk}{defun xlConsole}
(defun |xlConsole| (eb str lno ufos)
 (|xlMsg| eb str lno (elt ufos 0) (list (|inclmsgConsole|) '|say|)))

\end{chunk}

\defun{inclmsgConsole}{inclmsgConsole}
\begin{chunk}{defun inclmsgConsole 0}
(defun |inclmsgConsole| ()
 (list "Including source lines from console.  Type )fin when done." nil))

\end{chunk}

\defun{xlSkippingFin}{xlSkippingFin}
\calls{xlSkippingFin}{xlMsg}
\calls{xlSkippingFin}{inclmsgFinSkipped}
\begin{chunk}{defun xlSkippingFin}
(defun |xlSkippingFin| (eb str lno ufos)
 (|xlMsg| eb str lno (elt ufos 0)
   (list (|inclmsgFinSkipped|) '|warning|)))

\end{chunk}

\defun{inclmsgFinSkipped}{inclmsgFinSkipped}
\begin{chunk}{defun inclmsgFinSkipped 0}
(defun |inclmsgFinSkipped| ()
 (list 
  (format nil 
   "A )fin command was skipped ~
   (along with everything else) in a false branch of an )if...)endif.")
  nil))

\end{chunk}

\defun{xlPrematureFin}{xlPrematureFin}
\calls{xlPrematureFin}{xlMsg}
\calls{xlPrematureFin}{inclmsgPrematureFin}
\begin{chunk}{defun xlPrematureFin}
(defun |xlPrematureFin| (eb str lno ufos)
 (|xlMsg| eb str lno (elt ufos 0)
   (list (|inclmsgPrematureFin| (elt ufos 0)) '|error|)))

\end{chunk}

\defun{inclmsgPrematureFin}{inclmsgPrematureFin}
\calls{inclmsgPrematureFin}{theorigin}
\begin{chunk}{defun inclmsgPrematureFin}
(defun |inclmsgPrematureFin| (ufo)
 (list 
  (format nil
   "A )fin command has been given in %1f where at least one )endif ~
    was still needed. ~
    An appropriate number of )endif lines have been assumed.")
   (list (|theorigin| ufo))))

\end{chunk}

\defun{assertCond}{assertCond}
\calls{assertCond}{MakeSymbol}
\calls{assertCond}{incCommandTail}
\usesdollar{assertCond}{inclAssertions}
\uses{assertCond}{*whitespace*}
\begin{chunk}{defun assertCond}
(defun |assertCond| (s info)
 (let (word)
 (declare (special |$inclAssertions| *whitespace*))
  (setq word 
   (|MakeSymbol| (string-trim *whitespace* (|incCommandTail| s info))))
  (unless (member word |$inclAssertions|)
    (setq |$inclAssertions| (cons word |$inclAssertions|)))))

\end{chunk}

\defun{xlIfSyntax}{xlIfSyntax}
\calls{xlIfSyntax}{Top?}
\calls{xlIfSyntax}{Else?}
\calls{xlIfSyntax}{xlMsg}
\calls{xlIfSyntax}{inclmsgIfSyntax}
\begin{chunk}{defun xlIfSyntax}
(defun |xlIfSyntax| (eb str lno ufos info sts)
 (let (context found st)
  (setq st (elt sts 0))
  (setq found (elt info 2))
  (setq context
   (cond
    ((|Top?| st) '|not in an )if...)endif|)
    ((|Else?| st) '|after an )else|)
    (t '|but can't figure out where|)))
  (|xlMsg| eb str lno (elt ufos 0)
    (list (|inclmsgIfSyntax| (elt ufos 0) found context) '|error|))))

\end{chunk}

\defun{inclmsgIfSyntax}{inclmsgIfSyntax}
\calls{inclmsgIfSyntax}{concat}
\calls{inclmsgIfSyntax}{theid}
\calls{inclmsgIfSyntax}{theorigin}
\begin{chunk}{defun inclmsgIfSyntax}
(defun |inclmsgIfSyntax| (ufo found context)
 (setq found (concat ")" found))
 (list 
  (format nil
   "Incorrect )if...)endif syntax.  A %1f was found %2f. ~
    The processing of the source from %3f has been abandoned.")
  (list (|theid| found) (|theid| context) (|theorigin| ufo))))

\end{chunk}

\defun{xlIfBug}{xlIfBug}
\calls{xlIfBug}{xlMsg}
\calls{xlIfBug}{inclmsgIfBug}
\begin{chunk}{defun xlIfBug}
(defun |xlIfBug| (eb str lno ufos)
 (|xlMsg| eb str lno (elt ufos 0) (list (|inclmsgIfBug|) '|bug|)))

\end{chunk}

\defun{inclmsgIfBug}{inclmsgIfBug}
\begin{chunk}{defun inclmsgIfBug 0}
(defun |inclmsgIfBug| ()
  (list "Unexpected state in )if...)endif." nil))

\end{chunk}

\defun{xlCmdBug}{xlCmdBug}
\calls{xlCmdBug}{xlMsg}
\calls{xlCmdBug}{inclmsgCmdBug}
\begin{chunk}{defun xlCmdBug}
(defun |xlCmdBug| (eb str lno ufos)
 (|xlMsg| eb str lno (elt ufos 0) (list (|inclmsgCmdBug|) '|bug|)))

\end{chunk}

\defun{inclmsgCmdBug}{inclmsgCmdBug}
\begin{chunk}{defun inclmsgCmdBug 0}
(defun |inclmsgCmdBug| ()
 (list "Unexpected command in source inclusion." nil))

\end{chunk}

\defvar{incCommands}
This is a list of commands that can be in an include file
\begin{chunk}{postvars}
(eval-when (eval load)
(setq |incCommands|
 (list "say" "include" "console" "fin" "assert" "if" "elseif" "else" "endif")))

\end{chunk}

\defdollar{pfMacros}
The \$pfMacros variable is an alist [ [id, state, body-pform], ...]
where state is one of: mbody, mparam, mlambda

User-defined macros are maintained in a stack of definitions. This is the
stack sequence resulting from the command lines:
\begin{verbatim}
a ==> 3
a ==> 4
b ==> 7
(
 (|b| |mbody| ((|integer| (|posn| (0 "b ==> 7" 1 1 "strings") . 6)) . "7"))
 (|a| |mbody| ((|integer| (|posn| (0 "a ==> 4" 1 1 "strings") . 6)) . "4"))
 (|a| |mbody| ((|integer| (|posn| (0 "a ==> 3" 1 1 "strings") . 6)) . "3"))
)
\end{verbatim}
\begin{chunk}{initvars}
(defvar |$pfMacros| nil)

\end{chunk}


\defun{incClassify}{incClassify}
\begin{verbatim}
;incClassify(s) ==
;            not incCommand? s => [false,0, '""]
;            i := 1; n := #s
;            while i < n and s.i = char " " repeat i := i + 1
;            i >= n => [true,0,'"other"]
;            eb := (i = 1 => 0; i)
;            bad:=true
;            for p in incCommands while bad repeat
;                incPrefix?(p, i, s) =>
;                    bad:=false
;                    p1 :=p
;            if bad then [true,0,'"other"] else [true,eb,p1]
\end{verbatim}
\calls{incClassify}{incCommand?}
\uses{incClassify}{incCommands}
\label{incClassify}
\begin{chunk}{defun incClassify}
(defun |incClassify| (s)
 (let (p1 bad eb n i)
  (declare (special |incCommands|))
  (if (null (|incCommand?| s)) 
   (list nil 0 "")
   (progn
    (setq i 1)
    (setq n (length s))
    ((lambda ()
      (loop
       (cond
        ((not (and (< i n) (char= (elt s i) #\space)))
         (return nil))
        (t (setq i (1+ i)))))))
    (cond
     ((not (< i n)) (list t 0 "other"))
     (t
      (if (= i 1) 
       (setq eb 0)
       (setq eb i))
      (setq bad t)
      ((lambda (tmp1 p)
        (loop
         (cond
          ((or (atom tmp1)
               (progn (setq p (car tmp1)) nil)
               (not bad))
            (return nil))
          (t
           (cond
            ((|incPrefix?| p i s)
             (identity
              (progn
               (setq bad nil)
               (setq p1 p)))))))
         (setq tmp1 (cdr tmp1))))
        |incCommands| nil)
      (if bad 
       (list t 0 "other")
       (list t eb p1))))))))

\end{chunk}

\defun{incCommand?}{incCommand?}
\sig{incCommand?}{String}{Boolean}
\begin{chunk}{defun incCommand? 0}
(defun |incCommand?| (s)
  "does this start with a close paren?"
  (and (< 0 (length s)) (equal (elt s 0) #\) )))

\end{chunk}

\defun{incPrefix?}{incPrefix?}
\begin{verbatim}
;incPrefix?(prefix, start, whole) ==
;            #prefix > #whole-start => false
;            good:=true
;            for i in 0..#prefix-1 for j in start.. while good repeat
;                good:= prefix.i = whole.j
;            good
\end{verbatim}
\begin{chunk}{defun incPrefix? 0}
(defun |incPrefix?| (prefix start whole)
 (let (good)
  (cond
   ((< (- (length whole) start) (length prefix)) nil)
   (t
    (setq good t)
    ((lambda (Var i j)
      (loop
       (cond
        ((or (> i Var) (not good)) (return nil))
        (t (setq good (equal (elt prefix i) (elt whole j)))))
       (setq i (+ i 1))
       (setq j (+ j 1))))
      (- (length prefix) 1) 0 start)
    good))))

\end{chunk}

\defun{incCommandTail}{incCommandTail}
\calls{incCommandTail}{incDrop}
\begin{chunk}{defun incCommandTail}
(defun |incCommandTail| (s info)
 (let ((start (elt info 1)))
  (when (= start 0) (setq start 1))
  (|incDrop| (+ start (length (elt info 2)) 1) s)))

\end{chunk}

\defun{incDrop}{incDrop}
\calls{incDrop}{substring}
\begin{chunk}{defun incDrop 0}
(defun |incDrop| (n b)
 (if (>= n (length b)) 
  '||
  (substring b n nil)))

\end{chunk}

\defun{inclFname}{inclFname}
\calls{inclFname}{incFileName}
\calls{inclFname}{incCommandTail}
\begin{chunk}{defun inclFname}
(defun |inclFname| (s info)
 (|incFileName| (|incCommandTail| s info)))

\end{chunk}

\defun{incFileInput}{incFileInput}
\calls{incFileInput}{incRgen}
\calls{incFileInput}{make-instream}
\begin{chunk}{defun incFileInput}
(defun |incFileInput| (fn)
  (|incRgen| (make-instream fn)))

\end{chunk}

\defun{incConsoleInput}{incConsoleInput}
\calls{incConsoleInput}{incRgen}
\calls{incConsoleInput}{make-instream}
\begin{chunk}{defun incConsoleInput}
(defun |incConsoleInput| ()
  (|incRgen| (make-instream 0)))

\end{chunk}

\defun{incNConsoles}{incNConsoles}
\calls{incNConsoles}{incNConsoles}
\begin{chunk}{defun incNConsoles}
(defun |incNConsoles| (ufos)
 (let ((a (member "console" ufos)))
  (if a
   (+ 1 (|incNConsoles| (cdr a)))
   0)))

\end{chunk}

\defun{incActive?}{incActive?}
\begin{chunk}{defun incActive? 0}
(defun |incActive?| (fn ufos)
 (member fn ufos))

\end{chunk}

\defun{incRgen}{incRgen}
Note that incRgen1 recursively calls this function.

\calls{incRgen}{Delay}
\calls{incRgen}{incRgen1}
\begin{chunk}{defun incRgen}
(defun |incRgen| (s)
 (|Delay| #'|incRgen1| (list s)))

\end{chunk}

\defun{Delay}{Delay}
{\bf Delay} prepends a label {\bf nonnullstream}, returning a list
of the label, the given function name in {\bf function}
and {\bf arguments}. That is, given
\begin{verbatim}
 (|Delay| |incLude1|  (0 ("1") 0 ("strings") (1)))
\end{verbatim}
construct
\begin{verbatim}
 (|nonnullstream| |incLude1| 0 ("1") 0 ("strings") (1))
\end{verbatim}
Note that {\bf nonnullstream} is NOT a function so the inputs
have been changed from a function call to a simple list.
\label{Delay}
\sig{Delay}{(Function,List(Any))}{Delay}
\begin{chunk}{defun Delay 0}
(defun |Delay| (function arguments)
 (cons '|nonnullstream| (cons function arguments)))

\end{chunk}

\defvar{StreamNil}
\begin{chunk}{initvars}
(defvar |StreamNil| (list '|nullstream|))

\end{chunk}

\begin{chunk}{postvars}
(eval-when (eval load)
  (setq |StreamNil| (list '|nullstream|)))

\end{chunk}

\defun{incRgen1}{incRgen1}
This function reads a line from the stream and then conses it up
with a recursive call to incRgen.
Note that incRgen recursively wraps this function in a delay list.

\calls{incRgen1}{incRgen}
\uses{incRgen1}{StreamNil}
\begin{chunk}{defun incRgen1}
(defun |incRgen1| (&rest z)
 (let (a s)
 (declare (special |StreamNil|))
  (setq s (car z))
  (setq a (read-line s nil nil))
  (if (null a)
   (progn
    (close s) 
    |StreamNil|)
   (cons a (|incRgen| s)))))

\end{chunk}

\chapter{The Token Scanner}

\defvar{scanKeyWords}
\begin{chunk}{postvars}
(eval-when (eval load)
(defvar |scanKeyWords|
 (list
  (list "add" 'add)
  (list "and" 'and)
  (list "break" 'break)
  (list "by" 'by)
  (list "case" 'case)
  (list "default" 'default)
  (list "define" 'defn)
  (list "do" 'do)
  (list "else" 'else)
  (list "exit" 'exit)
  (list "export" 'export)
  (list "for" 'for)
  (list "free" 'free)
  (list "from" 'from)
  (list "has" 'has)
  (list "if" 'if)
  (list "import" 'import)
  (list "in" 'in)
  (list "inline" 'inline)
  (list "is" 'is)
  (list "isnt" 'isnt)
  (list "iterate" 'iterate)
  (list "local" '|local|)
  (list "macro" 'macro)
  (list "mod" 'mod)
  (list "or" 'or)
  (list "pretend" 'pretend)
  (list "quo" 'quo)
  (list "rem" 'rem)
  (list "repeat" 'repeat)
  (list "return" 'return)
  (list "rule" 'rule)
  (list "then" 'then)
  (list "where" 'where)
  (list "while" 'while)
  (list "with" 'with)
  (list "|" 'bar)
  (list "." 'dot)
  (list "::" 'coerce)
  (list ":" 'colon)
  (list ":-" 'colondash)
  (list "@" 'at)
  (list "@@" 'atat)
  (list "," 'comma)
  (list ";" 'semicolon)
  (list "**" 'power)
  (list "*" 'times)
  (list "+" 'plus)
  (list "-" 'minus)
  (list "<" 'lt)
  (list ">" 'gt)
  (list "<=" 'le)
  (list ">=" 'ge)
  (list "=" 'equal)
  (list "~=" 'notequal)
  (list "~" '~)
  (list "^" 'carat)
  (list ".." 'seg)
  (list "#" '|#|)
  (list "&" 'ampersand)
  (list "$" '$)
  (list "/" 'slash)
  (list "\\" 'backslash)
  (list "//" 'slashslash)
  (list "\\\\" 'backslashbackslash)
  (list "/\\" 'slashbackslash)
  (list "\\/" 'backslashslash)
  (list "=>" 'exit)
  (list ":=" 'becomes)
  (list "==" 'def)
  (list "==>" 'mdef)
  (list "->" 'arrow)
  (list "<-" 'larrow)
  (list "+->" 'gives)
  (list "(" '|(|)
  (list ")" '|)|)
  (list "(|" '|(\||)
  (list "|)" '|\|)|)
  (list "[" '[)
  (list "]" '])
  (list "[_]" '[])
  (list "{" '{)
  (list "}" '})
  (list "{_}" '{})
  (list "[|" '|[\||)
  (list "|]" '|\|]|)
  (list "[|_|]" '|[\|\|]|)
  (list "{|" '|{\||)
  (list "|}" '|\|}|)
  (list "{|_|}" '|{\|\|}|)
  (list "<<" 'oangle)
  (list ">>" 'cangle)
  (list "'" '|'|)
  (list "`" 'backquote))))

\end{chunk}

\defvar{infgeneric}
\begin{chunk}{postvars}
(eval-when (eval load)
(prog ()
  (return
    ((lambda (var value)
       (loop
         (cond
           ((or (atom var) (progn (setq value (car var)) nil))
            (return nil))
           (t
            (setf (get (car value) 'infgeneric) (cadr value))))
         (setq var (cdr var))))
     (list
      (list 'equal '=)
      (list 'times '*)
      (list 'has '|has|)
      (list 'case '|case|)
      (list 'rem '|rem|)
      (list 'mod '|mod|)
      (list 'quo '|quo|)
      (list 'slash '/)
      (list 'backslash '|\\|)
      (list 'slashslash '//)
      (list 'backslashbackslash '|\\\\|)
      (list 'slashbackslash '|/\\|)
      (list 'backslashslash '|\\/|)
      (list 'power '**)
      (list 'carat '^)
      (list 'plus '+)
      (list 'minus '-)
      (list 'lt '<)
      (list 'gt '>)
      (list 'oangle '<<)
      (list 'cangle '>>)
      (list 'le '<=)
      (list 'ge '>=)
      (list 'notequal '~=)
      (list 'by '|by|)
      (list 'arrow '->)
      (list 'larrow '<-)
      (list 'bar '|\||)
      (list 'seg '|..|))
     nil))))

\end{chunk}

\defun{lineoftoks}{lineoftoks}
lineoftoks  bites off a token-dq from a line-stream
returning the token-dq and the rest of the line-stream
\begin{verbatim}
;lineoftoks(s)==
;   $f: local:=nil
;   $r:local :=nil
;   $ln:local :=nil
;   $linepos:local:=nil
;   $n:local:=nil
;   $sz:local := nil
;   $floatok:local:=true
;   if not nextline s
;   then CONS(nil,nil)
;   else
;     if null scanIgnoreLine($ln,$n) -- line of spaces or starts ) or >
;     then cons(nil,$r)
;     else
;      toks:=[]
;      a:= incPrefix?('"command",1,$ln)
;      a =>
;                 $ln:=SUBSTRING($ln,8,nil)
;                 b:= dqUnit constoken($ln,$linepos,["command",$ln],0)
;                 cons([ [b,s] ],$r)
;
;      while $n<$sz repeat toks:=dqAppend(toks,scanToken())
;      if null toks
;      then cons([],$r)
;      else cons([ [toks,s] ],$r)
\end{verbatim}
\calls{lineoftoks}{nextline}
\calls{lineoftoks}{scanIgnoreLine}
\calls{lineoftoks}{incPrefix?}
\calls{lineoftoks}{substring}
\calls{lineoftoks}{dqUnit}
\calls{lineoftoks}{constoken}
\usesdollar{lineoftoks}{floatok}
\usesdollar{lineoftoks}{f}
\usesdollar{lineoftoks}{sz}
\usesdollar{lineoftoks}{linepos}
\usesdollar{lineoftoks}{r}
\usesdollar{lineoftoks}{n}
\usesdollar{lineoftoks}{ln}
\label{lineoftoks}
\begin{chunk}{defun lineoftoks}
(defun |lineoftoks| (s)
 (let (|$floatok| |$sz| |$n| |$linepos| |$ln| |$r| |$f| |b| |a| |toks|)
 (declare (special |$floatok| |$f| |$sz| |$linepos| |$r| |$n| |$ln|))
  (setq |$f| nil)
  (setq |$r| nil)
  (setq |$ln| nil)
  (setq |$linepos| nil)
  (setq |$n| nil)
  (setq |$sz| nil)
  (setq |$floatok| t)
  (cond
   ((null (|nextline| s)) (cons nil nil))
   ((null (|scanIgnoreLine| |$ln| |$n|)) (cons nil |$r|))
   (t
    (setq |toks| nil)
    (setq |a| (|incPrefix?| "command" 1 |$ln|))
    (cond
     (|a|
      (setq |$ln| (substring |$ln| 8 nil))
      (setq |b|
       (|dqUnit| (|constoken| |$ln| |$linepos| (list '|command| |$ln|) 0)))
      (cons (list (list |b| s)) |$r|))
     (t
      ((lambda ()
        (loop
         (cond
          ((not (< |$n| |$sz|)) (return nil))
          (t (setq |toks| (|dqAppend| |toks| (|scanToken|))))))))
      (cond
       ((null |toks|) (cons nil |$r|))
       (t (cons (list (list |toks| s)) |$r|)))))))))

\end{chunk}

\defun{nextline}{nextline}
\calls{nextline}{npNull}
\calls{nextline}{strposl}
\usesdollar{nextline}{sz}
\usesdollar{nextline}{n}
\usesdollar{nextline}{linepos}
\usesdollar{nextline}{ln}
\usesdollar{nextline}{r}
\usesdollar{nextline}{f}
\begin{chunk}{defun nextline}
(defun |nextline| (s)
 (declare (special |$sz| |$n| |$linepos| |$ln| |$r| |$f|))
 (cond
  ((|npNull| s) nil)
  (t
   (setq |$f| (car s))
   (setq |$r| (cdr s))
   (setq |$ln| (cdr |$f|))
   (setq |$linepos| (caar |$f|))
   (setq |$n| (strposl " " |$ln| 0 t)) ; spaces at beginning
   (setq |$sz| (length |$ln|))
   t)))

\end{chunk}

\defun{scanIgnoreLine}{scanIgnoreLine}
\calls{scanIgnoreLine}{incPrefix?}
\begin{chunk}{defun scanIgnoreLine}
(defun |scanIgnoreLine| (ln n)
  (cond
   ((null n) n)
   (t
    (cond
     ((= (char-code (char ln 0)) (char-code #\)))
      (cond
        ((|incPrefix?| "command" 1 ln) t)
        (t nil)))
     (t n)))))

\end{chunk}

\defun{constoken}{constoken}
\calls{constoken}{ncPutQ}
\begin{chunk}{defun constoken}
(defun |constoken| (ln lp b n)
 (declare (ignore ln))
 (let (a)
  (setq a (cons (elt b 0) (elt b 1)))
  (|ncPutQ| a '|posn| (cons lp n))
  a))

\end{chunk}

\defun{scanToken}{scanToken}
\calls{scanToken}{startsComment?}
\calls{scanToken}{scanComment}
\calls{scanToken}{startsNegComment?}
\calls{scanToken}{scanNegComment}
\calls{scanToken}{lfid}
\calls{scanToken}{punctuation?}
\calls{scanToken}{scanPunct}
\calls{scanToken}{startsId?}
\calls{scanToken}{scanWord}
\calls{scanToken}{scanSpace}
\calls{scanToken}{scanString}
\calls{scanToken}{scanNumber}
\calls{scanToken}{scanEscape}
\calls{scanToken}{scanError}
\calls{scanToken}{dqUnit}
\calls{scanToken}{constoken}
\calls{scanToken}{lnExtraBlanks}
\usesdollar{scanToken}{linepos}
\usesdollar{scanToken}{n}
\usesdollar{scanToken}{ln}
\begin{chunk}{defun scanToken}
(defun |scanToken| ()
 (let (b ch n linepos c ln)
 (declare (special |$linepos| |$n| |$ln|))
  (setq ln |$ln|)
  (setq c (char-code (char |$ln| |$n|))) 
  (setq linepos |$linepos|)
  (setq n |$n|)
  (setq ch (elt |$ln| |$n|))
  (setq b
   (cond
    ((|startsComment?|) (|scanComment|) nil)
    ((|startsNegComment?|) (|scanNegComment|) nil)
    ((= c (char-code #\?))
      (setq |$n| (+ |$n| 1))
      (|lfid| "?"))
    ((|punctuation?| c) (|scanPunct|))
    ((|startsId?| ch) (|scanWord| nil))
    ((= c (char-code #\space)) (|scanSpace|) nil)
    ((= c (char-code #\")) (|scanString|))
    ((digitp ch) (|scanNumber|))
    ((= c (char-code #\_)) (|scanEscape|))
    (t (|scanError|))))
  (cond
    ((null b) nil)
    (t
     (|dqUnit|
      (|constoken| ln linepos b (+ n (|lnExtraBlanks| linepos))))))))

\end{chunk}

\defun{lfid}{lfid}
To pair badge and badgee
\begin{chunk}{defun lfid 0}
(defun |lfid| (x)
 (list '|id| (intern x "BOOT")))

\end{chunk}

\defun{startsComment?}{Is it a ++ comment?}
\usesdollar{startsComment?}{ln}
\usesdollar{startsComment?}{sz}
\usesdollar{startsComment?}{n}
\begin{chunk}{defun startsComment? 0}
(defun |startsComment?| ()
 (let (www)
 (declare (special |$ln| |$sz| |$n|))
  (cond
   ((< |$n| |$sz|)
    (cond
     ((= (char-code (char |$ln| |$n|)) (char-code #\+))
       (setq www (+ |$n| 1))
       (cond
        ((not (< www |$sz|)) nil)
        (t (= (char-code (char |$ln| www)) (char-code #\+)))))
     (t nil)))
   (t nil))))

\end{chunk}

\defun{scanComment}{scanComment}
\calls{scanComment}{lfcomment}
\calls{scanComment}{substring}
\usesdollar{scanComment}{ln}
\usesdollar{scanComment}{sz}
\usesdollar{scanComment}{n}
\begin{chunk}{defun scanComment}
(defun |scanComment| ()
 (let (n)
 (declare (special |$ln| |$sz| |$n|))
  (setq n |$n|)
  (setq |$n| |$sz|)
  (|lfcomment| (substring |$ln| n nil))))

\end{chunk}

\defun{lfcomment}{lfcomment}
\begin{chunk}{defun lfcomment 0}
(defun |lfcomment| (x)
 (list '|comment| x))

\end{chunk}

\defun{startsNegComment?}{Is it a -- comment?}
\usesdollar{startsNegComment?}{ln}
\usesdollar{startsNegComment?}{sz}
\usesdollar{startsNegComment?}{n}
\begin{chunk}{defun startsNegComment?}
(defun |startsNegComment?| ()
 (let (www)
 (declare (special |$ln| |$sz| |$n|))
  (cond
   ((< |$n| |$sz|)
    (cond
     ((= (char-code (char |$ln| |$n|)) (char-code #\-))
       (setq www (+ |$n| 1))
       (cond
        ((not (< www |$sz|)) nil)
        (t (= (char-code (char |$ln| www)) (char-code #\-)))))
     (t nil)))
   (t nil))))

\end{chunk}

\defun{scanNegComment}{scanNegComment}
\calls{scanNegComment}{lfnegcomment}
\calls{scanNegComment}{substring}
\usesdollar{scanNegComment}{ln}
\usesdollar{scanNegComment}{sz}
\usesdollar{scanNegComment}{n}
\begin{chunk}{defun scanNegComment}
(defun |scanNegComment| ()
 (let (n)
 (declare (special |$ln| |$sz| |$n|))
  (setq n |$n|)
  (setq |$n| |$sz|)
  (|lfnegcomment| (substring |$ln| n nil))))

\end{chunk}

\defun{lfnegcomment}{lfnegcomment}
\begin{chunk}{defun lfnegcomment 0}
(defun |lfnegcomment| (x)
 (list '|negcomment| x))

\end{chunk}

\defun{punctuation?}{punctuation?}
\begin{chunk}{defun punctuation?}
(defun |punctuation?| (c)
 (eql (elt |scanPun| c) 1))

\end{chunk}

\defun{scanPunct}{scanPunct}
\calls{scanPunct}{subMatch}
\calls{scanPunct}{scanError}
\calls{scanPunct}{scanKeyTr}
\usesdollar{scanPunct}{n}
\usesdollar{scanPunct}{ln}
\begin{chunk}{defun scanPunct}
(defun |scanPunct| ()
 (let (a sss)
 (declare (special |$n| |$ln|))
  (setq sss (|subMatch| |$ln| |$n|))
  (setq a (length sss))
  (cond
   ((eql a 0) (|scanError|))
   (t (setq |$n| (+ |$n| a)) (|scanKeyTr| sss)))))

\end{chunk}

\defun{subMatch}{subMatch}
\calls{subMatch}{substringMatch}
\begin{chunk}{defun subMatch}
(defun |subMatch| (a b)
 (|substringMatch| a |scanDict| b))

\end{chunk}

\defun{substringMatch}{substringMatch}
\begin{verbatim}
;substringMatch (l,d,i)==
;       h:= QENUM(l, i)
;       u:=ELT(d,h)
;       ll:=SIZE l
;       done:=false
;       s1:='""
;       for j in 0.. SIZE u - 1 while not done repeat
;          s:=ELT(u,j)
;          ls:=SIZE s
;          done:=if ls+i > ll
;                then false
;                else
;                 eql:= true
;                 for k in 1..ls-1 while eql repeat
;                    eql:= EQL(QENUM(s,k),QENUM(l,k+i))
;                 if eql
;                 then
;                   s1:=s
;                   true
;                 else false
;       s1
\end{verbatim}
\calls{substringMatch}{size}
\begin{chunk}{defun substringMatch}
(defun |substringMatch| (l dict i)
 (let (equl ls s s1 done ll u h)
  (setq h (char-code (char l i)))
  (setq u (elt dict h))
  (setq ll (size l))
  (setq s1 "")
  ((lambda (Var4 j)
    (loop
     (cond
      ((or (> j Var4) done) (return nil))
      (t
       (setq s (elt u j))
       (setq ls (size s))
       (setq done
        (cond
         ((< ll (+ ls i)) nil)
         (t
          (setq equl t)
          ((lambda (Var5 k)
           (loop
            (cond
             ((or (> k Var5) (not equl)) (return nil))
             (t
              (setq equl (= (char-code (char s k)) 
                            (char-code (char l (+ k i)))))))
              (setq k (+ k 1))))
           (- ls 1) 1)
          (cond (equl (setq s1 s) t) (t nil)))))))
     (setq j (+ j 1))))
   (- (size u) 1) 0)
  s1))

\end{chunk}

\defun{scanKeyTr}{scanKeyTr}
\calls{scanKeyTr}{keyword}
\calls{scanKeyTr}{scanPossFloat}
\calls{scanKeyTr}{lfkey}
\calls{scanKeyTr}{scanCloser?}
\usesdollar{scanKeyTr}{floatok}
\begin{chunk}{defun scanKeyTr}
(defun |scanKeyTr| (w)
 (declare (special |$floatok|))
 (cond
  ((eq (|keyword| w) 'dot)
    (cond
     (|$floatok| (|scanPossFloat| w))
     (t (|lfkey| w))))
  (t (setq |$floatok| (null (|scanCloser?| w))) (|lfkey| w))))

\end{chunk}

\defun{keyword}{keyword}
\calls{keyword}{hget}
\begin{chunk}{defun keyword 0}
(defun |keyword| (st)
 (hget |scanKeyTable| st))

\end{chunk}

\defun{keyword?}{keyword?}
\calls{keyword?}{hget}
\begin{chunk}{defun keyword? 0}
(defun |keyword?| (st)
 (null (null (hget |scanKeyTable| st))))

\end{chunk}

\defun{scanPossFloat}{scanPossFloat}
\calls{scanPossFloat}{lfkey}
\calls{scanPossFloat}{spleI}
\calls{scanPossFloat}{scanExponent}
\usesdollar{scanPossFloat}{ln}
\usesdollar{scanPossFloat}{sz}
\usesdollar{scanPossFloat}{n}
\begin{chunk}{defun scanPossFloat}
(defun |scanPossFloat| (w)
 (declare (special |$ln| |$sz| |$n|))
 (cond
  ((or (not (< |$n| |$sz|)) (null (digitp (elt |$ln| |$n|))))
    (|lfkey| w))
  (t
    (setq w (|spleI| #'digitp)) (|scanExponent| "0" w))))

\end{chunk}

\defun{digit?}{digit?}
\calls{digit?}{digitp}
\begin{chunk}{defun digit?}
(defun |digit?| (x)
 (digitp x))

\end{chunk}

\defun{lfkey}{lfkey}
\calls{lfkey}{keyword}
\begin{chunk}{defun lfkey}
(defun |lfkey| (x)
 (list '|key| (|keyword| x)))

\end{chunk}

\defun{spleI}{spleI}
\calls{spleI}{spleI1}
\begin{chunk}{defun spleI}
(defun |spleI| (dig)
 (|spleI1| dig nil))

\end{chunk}

\defun{spleI1}{spleI1}
\calls{spleI1}{substring}
\calls{spleI1}{scanEsc}
\calls{spleI1}{spleI1}
\calls{spleI1}{concat}
\usesdollar{spleI1}{ln}
\usesdollar{spleI1}{sz}
\usesdollar{spleI1}{n}
\begin{chunk}{defun spleI1}
(defun |spleI1| (dig zro)
 (let (bb a str l n)
 (declare (special |$ln| |$sz| |$n|))
  (setq n |$n|)
  (setq l |$sz|)
  ; while $n<l and FUNCALL(dig,($ln.$n)) repeat $n:=$n+1
  ((lambda ()
    (loop
     (cond
      ((not (and (< |$n| l) (funcall dig (elt |$ln| |$n|))))
       (return nil))
      (t
       (setq |$n| (+ |$n| 1)))))))
  (cond
   ((or (equal |$n| l) (not (= (char-code (char |$ln| |$n|)) (char-code #\_))))
    (cond
      ((and (equal n |$n|) zro) "0")
      (t (substring |$ln| n (- |$n| n)))))
   (t                            ; escaped
    (setq str (substring |$ln| n (- |$n| n)))
    (setq |$n| (+ |$n| 1))
    (setq a (|scanEsc|))
    (setq bb (|spleI1| dig zro)) ; escape, any number of spaces are ignored
    (concat str bb)))))

\end{chunk}

\defun{scanEsc}{scanEsc}
\begin{verbatim}
;scanEsc()==
;     if $n>=$sz
;     then if nextline($r)
;          then
;             while null $n repeat nextline($r)
;             scanEsc()
;             false
;          else false
;     else
;           n1:=STRPOSL('" ",$ln,$n,true)
;           if null n1
;           then if nextline($r)
;                then
;                  while null $n repeat nextline($r)
;                  scanEsc()
;                  false
;                else false
;           else
;                if $n=n1
;                then true
;                else if QENUM($ln,n1)=ESCAPE
;                     then
;                       $n:=n1+1
;                       scanEsc()
;                       false
;                     else
;                       $n:=n1
;                       startsNegComment?() or startsComment?() =>
;                                 nextline($r)
;                                 scanEsc()
;                                 false
;                       false
\end{verbatim}
\calls{scanEsc}{nextline}
\calls{scanEsc}{scanEsc}
\calls{scanEsc}{strposl}
\calls{scanEsc}{startsNegComment?}
\calls{scanEsc}{startsComment?}
\usesdollar{scanEsc}{ln}
\usesdollar{scanEsc}{r}
\usesdollar{scanEsc}{sz}
\usesdollar{scanEsc}{n}
\begin{chunk}{defun scanEsc}
(defun |scanEsc| ()
 (let (n1)
 (declare (special |$ln| |$r| |$sz| |$n|))
  (cond
   ((not (< |$n| |$sz|))
    (cond
     ((|nextline| |$r|)
      ((lambda ()
       (loop
        (cond 
         (|$n| (return nil))
         (t (|nextline| |$r|))))))
      (|scanEsc|)
      nil)
     (t nil)))
   (t 
    (setq n1 (strposl " " |$ln| |$n| t))
    (cond
     ((null n1)
      (cond
       ((|nextline| |$r|)
        ((lambda ()
          (loop
           (cond 
            (|$n| (return nil))
            (t (|nextline| |$r|))))))
         (|scanEsc|)
         nil)
        (t nil)))
     ((equal |$n| n1) t)
     ((= (char-code (char |$ln| n1)) (char-code #\_))
       (setq |$n| (+ n1 1))
       (|scanEsc|)
       nil)
     (t (setq |$n| n1)
      (cond
       ((or (|startsNegComment?|) (|startsComment?|))
        (progn
         (|nextline| |$r|)
         (|scanEsc|)
         nil))
       (t nil))))))))

\end{chunk}

\defvar{scanCloser}
\begin{chunk}{postvars}
(eval-when (eval load)
  (defvar |scanCloser| (list '|)| '} '] '|\|)| '|\|}| '|\|]|)))

\end{chunk}

\defun{scanCloser?}{scanCloser?}
\calls{scanCloser?}{keyword}
\uses{scanCloser?}{scanCloser}
\begin{chunk}{defun scanCloser? 0}
(defun |scanCloser?| (w)
 (declare (special |scanCloser|))
 (member (|keyword| w) |scanCloser|))

\end{chunk}

\defun{scanWord}{scanWord}
\calls{scanWord}{scanW}
\calls{scanWord}{lfid}
\calls{scanWord}{keyword?}
\calls{scanWord}{lfkey}
\usesdollar{scanWord}{floatok}
\begin{chunk}{defun scanWord}
(defun |scanWord| (esp)
 (let (w aaa)
 (declare (special |$floatok|))
  (setq aaa (|scanW| nil))
  (setq w (elt aaa 1))
  (setq |$floatok| nil)
  (cond
   ((or esp (elt aaa 0))
    (|lfid| w))
   ((|keyword?| w)
    (setq |$floatok| t)
    (|lfkey| w))
   (t
    (|lfid| w)))))

\end{chunk}

\defun{scanExponent}{scanExponent}
\calls{scanExponent}{lffloat}
\calls{scanExponent}{digit?}
\calls{scanExponent}{spleI}
\calls{scanExponent}{concat}
\usesdollar{scanExponent}{ln}
\usesdollar{scanExponent}{sz}
\usesdollar{scanExponent}{n}
\begin{chunk}{defun scanExponent}
(defun |scanExponent| (a w)
 (let (c1 e c n)
 (declare (special |$ln| |$sz| |$n|))
  (cond
   ((not (< |$n| |$sz|)) (|lffloat| a w "0"))
   (t
    (setq n |$n|)
    (setq c (char-code (char |$ln| |$n|)))
    (cond
     ((or (= c (char-code #\E)) (= c (char-code #\e)))
      (setq |$n| (+ |$n| 1))
      (cond
       ((not (< |$n| |$sz|))
        (setq |$n| n)
        (|lffloat| a w "0"))
       ((digitp (elt |$ln| |$n|))
        (setq e (|spleI| #'digitp))
        (|lffloat| a w e))
       (t
        (setq c1 (char-code (char |$ln| |$n|)))
        (cond
         ((or (= c1 (char-code #\+)) (= c1 (char-code #\-)))
           (setq |$n| (+ |$n| 1))
           (cond
            ((not (< |$n| |$sz|))
             (setq |$n| n)
             (|lffloat| a w "0"))
            ((digitp (elt |$ln| |$n|))
             (setq e (|spleI| #'digitp))
             (|lffloat| a w
              (cond
               ((= c1 (char-code #\-))
                (concat "-" e))
               (t e))))
            (t
             (setq |$n| n)
             (|lffloat| a w "0"))))))))
     (t (|lffloat| a w "0")))))))

\end{chunk}

\defun{lffloat}{lffloat}
\calls{lffloat}{concat}
\begin{chunk}{defun lffloat 0}
(defun |lffloat| (a w e)
 (list '|float| (concat a "." w "e" e)))

\end{chunk}

\defmacro{idChar?}
\begin{chunk}{defmacro idChar? 0}
(defmacro |idChar?| (x)
 `(or (alphanumericp ,x) (member ,x '(#\? #\% #\' #\!) :test #'char=)))

\end{chunk}

\defun{scanW}{scanW}
\calls{scanW}{posend}
\calls{scanW}{substring}
\calls{scanW}{scanEsc}
\calls{scanW}{scanW}
\calls{scanW}{idChar?}
\calls{scanW}{concat}
\usesdollar{scanW}{ln}
\usesdollar{scanW}{sz}
\usesdollar{scanW}{n}
\begin{chunk}{defun scanW}
(defun |scanW| (b)
 (let (bb a str endid l n1)
 (declare (special |$ln| |$sz| |$n|))
  (setq n1 |$n|)
  (setq |$n| (+ |$n| 1))
  (setq l |$sz|)
  (setq endid (|posend| |$ln| |$n|))
  (cond
   ((or (equal endid l)
        (not (= (char-code (char |$ln| endid)) (char-code #\_))))
    (setq |$n| endid)
    (list b (substring |$ln| n1 (- endid n1))))
   (t
    (setq str (substring |$ln| n1 (- endid n1)))
    (setq |$n| (+ endid 1))
    (setq a (|scanEsc|))
    (setq bb
     (cond
      (a (|scanW| t))
      ((not (< |$n| |$sz|)) (list b ""))
      ((|idChar?| (elt |$ln| |$n|)) (|scanW| b))
      (t (list b ""))))
    (list (or (elt bb 0) b) (concat str (elt bb 1)))))))

\end{chunk}

\defun{posend}{posend}
\begin{verbatim}
;posend(line,n)==
;     while n<#line and idChar? line.n repeat n:=n+1
;     n
\end{verbatim}
NOTE: do not replace ``lyne'' with ``line''
\begin{chunk}{defun posend}
(defun |posend| (lyne n)
 ((lambda ()
  (loop
   (cond
    ((not (and (< n (length lyne)) (|idChar?| (elt lyne n))))
     (return nil))
    (t (setq n (+ n 1)))))))
 n)

\end{chunk}

\defun{scanSpace}{scanSpace}
\calls{scanSpace}{strposl}
\calls{scanSpace}{lfspaces}
\usesdollar{scanSpace}{floatok}
\usesdollar{scanSpace}{ln}
\usesdollar{scanSpace}{n}
\begin{chunk}{defun scanSpace}
(defun |scanSpace| ()
 (let (n)
 (declare (special |$floatok| |$ln| |$n|))
  (setq n |$n|)
  (setq |$n| (strposl " " |$ln| |$n| t))
  (when (null |$n|) (setq |$n| (length |$ln|)))
  (setq |$floatok| t)
  (|lfspaces| (- |$n| n))))

\end{chunk}

\defun{lfspaces}{lfspaces}
\begin{chunk}{defun lfspaces 0}
(defun |lfspaces| (x)
 (list '|spaces| x))

\end{chunk}

\defun{scanString}{scanString}
\calls{scanString}{lfstring}
\calls{scanString}{scanS}
\usesdollar{scanString}{floatok}
\usesdollar{scanString}{n}
\begin{chunk}{defun scanString}
(defun |scanString| ()
 (declare (special |$floatok| |$n|))
  (setq |$n| (+ |$n| 1))
  (setq |$floatok| nil)
  (|lfstring| (|scanS|)))

\end{chunk}

\defun{lfstring}{lfstring}
\begin{chunk}{defun lfstring 0}
(defun |lfstring| (x)
 (if (eql (length x) 1)
  (list '|char| x)
  (list '|string| x)))

\end{chunk}

\defun{scanS}{scanS}
\calls{scanS}{ncSoftError}
\calls{scanS}{lnExtraBlanks}
\calls{scanS}{strpos}
\calls{scanS}{substring}
\calls{scanS}{scanEsc}
\calls{scanS}{concat}
\calls{scanS}{scanTransform}
\calls{scanS}{scanS}
\usesdollar{scanS}{ln}
\usesdollar{scanS}{linepos}
\usesdollar{scanS}{sz}
\usesdollar{scanS}{n}
\begin{chunk}{defun scanS}
(defun |scanS| ()
 (let (b a str mn escsym strsym n)
 (declare (special |$ln| |$linepos| |$sz| |$n|))
 (cond
  ((not (< |$n| |$sz|))
   (|ncSoftError|
    (cons |$linepos| (+ (|lnExtraBlanks| |$linepos|) |$n|))
     "Quote added at end of line." nil) "")
  (t
   (setq n |$n|)
   (setq strsym (or (strpos "\"" |$ln| |$n| nil) |$sz|))
   (setq escsym (or (strpos "_" |$ln| |$n| nil) |$sz|))
   (setq mn (min strsym escsym))
   (cond
    ((equal mn |$sz|)
     (setq |$n| |$sz|)
     (|ncSoftError|
      (cons |$linepos| (+ (|lnExtraBlanks| |$linepos|) |$n|))
       "Quote added at end of line." nil)
       (substring |$ln| n nil))
    ((equal mn strsym)
     (setq |$n| (+ mn 1))
     (substring |$ln| n (- mn n)))
    (t 
     (setq str (substring |$ln| n (- mn n)))
     (setq |$n| (+ mn 1))
     (setq a (|scanEsc|))
     (setq b
      (cond
       (a 
        (setq str (concat str (|scanTransform| (elt |$ln| |$n|))))
        (setq |$n| (+ |$n| 1)) (|scanS|))
       (t (|scanS|))))
     (concat str b)))))))

\end{chunk}

\defun{scanTransform}{scanTransform}
\begin{chunk}{defun scanTransform}
(defun |scanTransform| (x) x)

\end{chunk}

\defun{scanNumber}{scanNumber}
\calls{scanNumber}{spleI}
\calls{scanNumber}{lfinteger}
\calls{scanNumber}{spleI1}
\calls{scanNumber}{scanExponent}
\calls{scanNumber}{scanCheckRadix}
\calls{scanNumber}{lfrinteger}
\calls{scanNumber}{concat}
\usesdollar{scanNumber}{floatok}
\usesdollar{scanNumber}{ln}
\usesdollar{scanNumber}{sz}
\usesdollar{scanNumber}{n}
\begin{chunk}{defun scanNumber}
(defun |scanNumber| ()
 (let (v w n a)
 (declare (special |$floatok| |$ln| |$sz| |$n|))
  (setq a (|spleI| #'digitp))
  (cond
   ((not (< |$n| |$sz|))
    (|lfinteger| a))
   ((not (= (char-code (char |$ln| |$n|)) (char-code #\r)))
    (cond
     ((and |$floatok| (= (char-code (char |$ln| |$n|)) (char-code #\.)))
      (setq n |$n|)
      (setq |$n| (+ |$n| 1))
      (cond
       ((and (< |$n| |$sz|) (= (char-code (char |$ln| |$n|)) (char-code #\.)))
        (setq |$n| n)
        (|lfinteger| a))
       (t
        (setq w (|spleI1| #'digitp t))
        (|scanExponent| a w))))
     (t (|lfinteger| a))))
   (t
    (setq |$n| (+ |$n| 1))
    (setq w (|spleI1| #'|rdigit?| t))
    (|scanCheckRadix| (parse-integer a) w)
    (cond
     ((not (< |$n| |$sz|))
      (|lfrinteger| a w))
      ((= (char-code (char |$ln| |$n|)) (char-code #\.))
       (setq n |$n|)
       (setq |$n| (+ |$n| 1))
       (cond
        ((and (< |$n| |$sz|) (= (char-code (char |$ln| |$n|)) (char-code #\.)))
         (setq |$n| n)
         (|lfrinteger| a w))
        (t 
         (setq v (|spleI1| #'|rdigit?| t))
         (|scanCheckRadix| (parse-integer a) v)
         (|scanExponent| (concat a "r" w) v))))
      (t (|lfrinteger| a w)))))))

\end{chunk}

\defun{rdigit?}{rdigit?}
\calls{rdigit?}{strpos}
\begin{chunk}{defun rdigit? 0}
(defun |rdigit?| (x)
 (strpos x "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" 0 nil))

\end{chunk}

\defun{lfinteger}{lfinteger}
\begin{chunk}{defun lfinteger 0}
(defun |lfinteger| (x)
 (list '|integer| x))

\end{chunk}

\defun{lfrinteger}{lfrinteger}
\calls{lfrinteger}{concat}
\begin{chunk}{defun lfrinteger 0}
(defun |lfrinteger| (r x)
 (list '|integer| (concat r (concat "r" x))))

\end{chunk}

\defun{scanCheckRadix}{scanCheckRadix}
\begin{verbatim}
;scanCheckRadix(r,w)==
;       ns:=#w
;       done:=false
;       for i in 0..ns-1  repeat
;         a:=rdigit? w.i
;         if null a or a>=r
;         then  ncSoftError(cons($linepos,lnExtraBlanks $linepos+$n-ns+i),
;                    "S2CN0002", [w.i])
\end{verbatim}
\usesdollar{scanCheckRadix}{n}
\usesdollar{scanCheckRadix}{linepos}
\begin{chunk}{defun scanCheckRadix}
(defun |scanCheckRadix| (r w)
 (let (a ns)
 (declare (special |$n| |$linepos|))
  (setq ns (length w))
  ((lambda (Var1 i)
   (loop
    (cond
     ((> i Var1) (return nil))
     (t
      (setq a (|rdigit?| (elt w i)))
      (cond
       ((or (null a) (not (< a r)))
        (|ncSoftError|
         (cons |$linepos| (+ (- (+ (|lnExtraBlanks| |$linepos|) |$n|) ns) i))
          "The character %1 is greater than the radix."
          (list (elt w i)))))))
    (setq i (+ i 1))))
   (- ns 1) 0)))

\end{chunk}

\defun{scanEscape}{scanEscape}
\calls{scanEscape}{scanEsc}
\calls{scanEscape}{scanWord}
\usesdollar{scanEscape}{n}
\begin{chunk}{defun scanEscape}
(defun |scanEscape| ()
 (declare (special |$n|))
  (setq |$n| (+ |$n| 1))
  (when (|scanEsc|) (|scanWord| t)))

\end{chunk}

\defun{scanError}{scanError}
\calls{scanError}{ncSoftError}
\calls{scanError}{lnExtraBlanks}
\calls{scanError}{lferror}
\usesdollar{scanError}{ln}
\usesdollar{scanError}{linepos}
\usesdollar{scanError}{n}
\begin{chunk}{defun scanError}
(defun |scanError| ()
 (let (n)
 (declare (special |$ln| |$linepos| |$n|))
  (setq n |$n|)
  (setq |$n| (+ |$n| 1))
  (|ncSoftError|
   (cons |$linepos| (+ (|lnExtraBlanks| |$linepos|) |$n|))
    "The character %1 is not an AXIOM character."
    (list (elt |$ln| n)))
  (|lferror| (elt |$ln| n))))

\end{chunk}

\defun{lferror}{lferror}
\begin{chunk}{defun lferror 0}
(defun |lferror| (x)
 (list '|error| x))

\end{chunk}

\defvar{scanKeyTable}
\begin{chunk}{postvars}
(eval-when (eval load)
 (defvar |scanKeyTable| (|scanKeyTableCons|)))

\end{chunk}

\defun{scanKeyTableCons}{scanKeyTableCons}
This function is used to build the scanKeyTable
\begin{verbatim}
;scanKeyTableCons()==
;   KeyTable:=MAKE_-HASHTABLE("CVEC",true)
;   for st in scanKeyWords repeat
;      HPUT(KeyTable,CAR st,CADR st)
;   KeyTable
\end{verbatim}
\begin{chunk}{defun scanKeyTableCons}
(defun |scanKeyTableCons| ()
 (let (KeyTable)
  (setq KeyTable (make-hash-table :test #'equal))
  ((lambda (Var6 st)
   (loop
    (cond
     ((or (atom Var6) (progn (setq st (car Var6)) nil))
      (return nil))
     (t
      (hput KeyTable (car st) (cadr st))))
    (setq Var6 (cdr Var6))))
   |scanKeyWords| nil)
  KeyTable))

\end{chunk}

\defvar{scanDict}
\begin{chunk}{postvars}
(eval-when (eval load)
 (defvar |scanDict| (|scanDictCons|)))

\end{chunk}

\defun{scanDictCons}{scanDictCons}
\begin{verbatim}
;scanDictCons()==
;      l:= HKEYS scanKeyTable
;      d :=
;          a:=MAKE_-VEC(256)
;          b:=MAKE_-VEC(1)
;          VEC_-SETELT(b,0,MAKE_-CVEC 0)
;          for i in 0..255 repeat VEC_-SETELT(a,i,b)
;          a
;      for s in l repeat scanInsert(s,d)
;      d
\end{verbatim}
\calls{scanDictCons}{hkeys}
\begin{chunk}{defun scanDictCons}
(defun |scanDictCons| ()
 (let (d b a l)
  (setq l (hkeys |scanKeyTable|))
  (setq d
   (progn
    (setq a (make-array 256))
    (setq b (make-array 1))
    (setf (svref b 0)
      (make-array 0 :fill-pointer 0 :element-type 'string-char))
    ((lambda (i)
     (loop
      (cond
       ((> i 255) (return nil))
       (t (setf (svref a i) b)))
      (setq i (+ i 1))))
     0)
    a))
  ((lambda (Var7 s)
   (loop
    (cond
     ((or (atom Var7) (progn (setq s (car Var7)) nil))
      (return nil))
     (t (|scanInsert| s d)))
    (setq Var7 (cdr Var7))))
   l nil)
  d))

\end{chunk}

\defun{scanInsert}{scanInsert}
\begin{verbatim}
;scanInsert(s,d) ==
;      l := #s
;      h := QENUM(s,0)
;      u := ELT(d,h)
;      n := #u
;      k:=0
;      while l <= #(ELT(u,k)) repeat
;          k:=k+1
;      v := MAKE_-VEC(n+1)
;      for i in 0..k-1 repeat VEC_-SETELT(v,i,ELT(u,i))
;      VEC_-SETELT(v,k,s)
;      for i in k..n-1 repeat VEC_-SETELT(v,i+1,ELT(u,i))
;      VEC_-SETELT(d,h,v)
;      s
\end{verbatim}
\begin{chunk}{defun scanInsert}
(defun |scanInsert| (s d)
 (let (v k n u h l)
  (setq l (length s))
  (setq h (char-code (char s 0)))
  (setq u (elt d h))
  (setq n (length u))
  (setq k 0)
  ((lambda ()
   (loop
    (cond
     ((< (length (elt u k)) l) (return nil))
     (t (setq k (+ k 1)))))))
  (setq v (make-array (+ n 1)))
  ((lambda (Var2 i)
   (loop
    (cond
     ((> i Var2) (return nil))
     (t (setf (svref v i) (elt u i))))
    (setq i (+ i 1))))
   (- k 1) 0)
  (setf (svref v k) s)
  ((lambda (Var3 i)
   (loop
    (cond
     ((> i Var3) (return nil))
     (t (setf (svref v (+ i 1)) (elt u i))))
    (setq i (+ i 1))))
   (- n 1) k)
  (setf (svref d h) v)
  s))

\end{chunk}

\defvar{scanPun}
\begin{chunk}{postvars}
(eval-when (eval load)
 (defvar |scanPun| (|scanPunCons|)))

\end{chunk}

\defun{scanPunCons}{scanPunCons}
\begin{verbatim}
;scanPunCons()==
;    listing := HKEYS scanKeyTable
;    a:=MAKE_-BVEC 256
;    for i in 0..255 repeat BVEC_-SETELT(a,i,0)
;    for k in listing repeat
;       if not startsId? k.0
;       then BVEC_-SETELT(a,QENUM(k,0),1)
;    a
\end{verbatim}
\calls{scanPunCons}{hkeys}
\begin{chunk}{defun scanPunCons}
(defun |scanPunCons| ()
 (let (a listing)
  (setq listing (hkeys |scanKeyTable|))
  (setq a (make-array (list 256) :element-type 'bit :initial-element 0))
  ((lambda (i)
   (loop
    (cond
     ((> i 255) (return nil))
     (t (setf (sbit a i) 0)))
    (setq i (+ i 1))))
   0)
  ((lambda (Var8 k)
   (loop
    (cond
     ((or (atom Var8) (progn (setq k (car Var8)) nil))
      (return nil))
     (t
      (cond
       ((null (|startsId?| (elt k 0)))
        (setf (sbit a (char-code (char k 0))) 1)))))
    (setq Var8 (cdr Var8))))
   listing nil)
  a))

\end{chunk}

\chapter{Input Stream Parser}

\defun{npParse}{Input Stream Parser}
\catches{npParse}{trappoint}
\calls{npParse}{npFirstTok}
\calls{npParse}{npItem}
\calls{npParse}{ncSoftError}
\calls{npParse}{tokPosn}
\calls{npParse}{pfWrong}
\calls{npParse}{pfDocument}
\calls{npParse}{pfListOf}
\usesdollar{npParse}{ttok}
\usesdollar{npParse}{stok}
\usesdollar{npParse}{stack}
\usesdollar{npParse}{inputStream}
\begin{chunk}{defun npParse}
(defun |npParse| (stream)
 (let (|$ttok| |$stok| |$stack| |$inputStream| found)
 (declare (special |$ttok| |$stack| |$inputStream| |$stok|))
  (setq |$inputStream| stream)
  (setq |$stack| nil)
  (setq |$stok| nil)
  (setq |$ttok| nil)
  (|npFirstTok|)
  (setq found (catch 'trappoint (|npItem|)))
  (cond
   ((eq found 'trapped)
    (|ncSoftError| (|tokPosn| |$stok|) "syntax error at top level" nil)
    (|pfWrong| (|pfDocument| "top level syntax error") (|pfListOf| nil)))
   ((null (null |$inputStream|))
    (|ncSoftError| (|tokPosn| |$stok|) " Improper syntax." nil)
    (|pfWrong|
     (|pfDocument| (list "input stream not exhausted"))
     (|pfListOf| nil)))
   ((null |$stack|)
    (|ncSoftError| (|tokPosn| |$stok|) 
      "System error while parsing, stack is empty." nil)
    (|pfWrong| (|pfDocument| (list "stack empty")) (|pfListOf| nil)))
   (t (car |$stack|)))))

\end{chunk}

\defun{npItem}{npItem}
\calls{npItem}{npQualDef}
\calls{npItem}{npEqKey}
\calls{npItem}{npItem1}
\calls{npItem}{npPop1}
\calls{npItem}{pfEnSequence}
\calls{npItem}{npPush}
\calls{npItem}{pfNovalue}
\begin{chunk}{defun npItem}
(defun |npItem| ()
 (let (c b a tmp1)
  (when (|npQualDef|)
    (if (|npEqKey| 'semicolon)
     (progn
      (setq tmp1 (|npItem1| (|npPop1|)))
      (setq a (car tmp1))
      (setq b (cadr tmp1))
      (setq c (|pfEnSequence| b))
      (if a
       (|npPush| c)
       (|npPush| (|pfNovalue| c))))
     (|npPush| (|pfEnSequence| (|npPop1|)))))))

\end{chunk}

\defun{npItem1}{npItem1}
\calls{npItem1}{npQualDef}
\calls{npItem1}{npEqKey}
\calls{npItem1}{npItem1}
\calls{npItem1}{npPop1}
\begin{chunk}{defun npItem1}
(defun |npItem1| (c)
 (let (b a tmp1)
  (if (|npQualDef|)
   (if (|npEqKey| 'semicolon)
     (progn
      (setq tmp1 (|npItem1| (|npPop1|)))
      (setq a (car tmp1))
      (setq b (cadr tmp1))
      (list a (append c b)))
    (list t (append c (|npPop1|))))
   (list nil c))))

\end{chunk}

\defun{npFirstTok}{npFirstTok}
Sets the current leaf (\$stok) to the next leaf in the input stream.
Sets the current token (\$ttok) cdr of the leaf.
A leaf token looks like [head, token, position]
where head is either an id or (id . alist)

\calls{npFirstTok}{tokConstruct}
\calls{npFirstTok}{tokPosn}
\calls{npFirstTok}{tokPart}
\usesdollar{npFirstTok}{ttok}
\usesdollar{npFirstTok}{stok}
\usesdollar{npFirstTok}{inputStream}
\begin{chunk}{defun npFirstTok}
(defun |npFirstTok| ()
 (declare (special |$ttok| |$stok| |$inputStream|))
 (if (null |$inputStream|)
  (setq |$stok| (|tokConstruct| 'error 'nomore (|tokPosn| |$stok|)))
  (setq |$stok| (car |$inputStream|)))
 (setq |$ttok| (|tokPart| |$stok|)))

\end{chunk}

\defun{npPush}{Push one item onto \$stack}
\usesdollar{npPush}{stack}
\begin{chunk}{defun npPush 0}
(defun |npPush| (x)
 (declare (special |$stack|))
  (push x |$stack|))

\end{chunk}

\defun{npPop1}{Pop one item off \$stack}
\usesdollar{npPop1}{stack}
\begin{chunk}{defun npPop1 0}
(defun |npPop1| ()
 (declare (special |$stack|))
 (pop |$stack|))

\end{chunk}

\defun{npPop2}{Pop the second item off \$stack}
\usesdollar{npPop2}{stack}
\begin{chunk}{defun npPop2 0}
(defun |npPop2| ()
 (let (a) 
 (declare (special |$stack|))
  (setq a (cadr |$stack|))
  (rplacd |$stack| (cddr |$stack|))
  a))

\end{chunk}

\defun{npPop3}{Pop the third item off \$stack}
\usesdollar{npPop3}{stack}
\begin{chunk}{defun npPop3 0}
(defun |npPop3| () 
 (let (a)
 (declare (special |$stack|))
  (setq a (caddr |$stack|))
  (rplacd (cdr |$stack|) (cdddr |$stack|)) a))

\end{chunk}

\defun{npQualDef}{npQualDef}
\calls{npQualDef}{npComma}
\calls{npQualDef}{npPush}
\calls{npQualDef}{npPop1}
\begin{chunk}{defun npQualDef}
(defun |npQualDef| ()
 (and (|npComma|) (|npPush| (list (|npPop1|)))))

\end{chunk}

\defun{npEqKey}{Advance over a keyword}
Test for the keyword, if found advance the token stream

\calls{npEqKey}{npNext}
\usesdollar{npEqKey}{ttok}
\usesdollar{npEqKey}{stok}
\begin{chunk}{defun npEqKey}
(defun |npEqKey| (keyword)
 (declare (special |$ttok| |$stok|))
 (and
  (eq (caar |$stok|) '|key|)
  (eq keyword |$ttok|)
  (|npNext|)))

\end{chunk}

\defun{npNext}{Advance the input stream}
This advances the input stream. The call to npFirstTok picks off the
next token in the input stream and updates the current leaf (\$stok)
and the current token (\$ttok)

\calls{npNext}{npFirstTok}
\usesdollar{npNext}{inputStream}
\begin{chunk}{defun npNext}
(defun |npNext| ()
 (declare (special |$inputStream|))
  (setq |$inputStream| (cdr |$inputStream|))
  (|npFirstTok|))

\end{chunk}

\defun{npComma}{npComma}
\calls{npComma}{npTuple}
\calls{npComma}{npQualifiedDefinition}
\begin{chunk}{defun npComma}
(defun |npComma| ()
 (|npTuple| #'|npQualifiedDefinition|))

\end{chunk}

\defun{npTuple}{npTuple}
\calls{npTuple}{npListofFun}
\calls{npTuple}{npCommaBackSet}
\calls{npTuple}{pfTupleListOf}
\begin{chunk}{defun npTuple}
(defun |npTuple| (|p|)
 (|npListofFun| |p| #'|npCommaBackSet| #'|pfTupleListOf|))

\end{chunk}

\defun{npCommaBackSet}{npCommaBackSet}
\calls{npCommaBackSet}{npEqKey}
\begin{chunk}{defun npCommaBackSet}
(defun |npCommaBackSet| ()
 (and
  (|npEqKey| 'comma)
  (or (|npEqKey| 'backset) t)))

\end{chunk}

\defun{npQualifiedDefinition}{npQualifiedDefinition}
\calls{npQualifiedDefinition}{npQualified}
\calls{npQualifiedDefinition}{npDefinitionOrStatement}
\begin{chunk}{defun npQualifiedDefinition}
(defun |npQualifiedDefinition| ()
 (|npQualified| #'|npDefinitionOrStatement|))

\end{chunk}

\defun{npQualified}{npQualified}
\calls{npQualified}{npEqKey}
\calls{npQualified}{npDefinition}
\calls{npQualified}{npTrap}
\calls{npQualified}{npPush}
\calls{npQualified}{pfWhere}
\calls{npQualified}{npPop1}
\calls{npQualified}{npLetQualified}
\begin{chunk}{defun npQualified}
(defun |npQualified| (f)
 (if (funcall f)
  (progn
   (do () ; while ... do
      ((not (and (|npEqKey| 'where) (or (|npDefinition|) (|npTrap|)))))
   (|npPush| (|pfWhere| (|npPop1|) (|npPop1|))))
   t)
  (|npLetQualified| f)))

\end{chunk}

\defun{npDefinitionOrStatement}{npDefinitionOrStatement}
\calls{npDefinitionOrStatement}{npBackTrack}
\calls{npDefinitionOrStatement}{npGives}
\calls{npDefinitionOrStatement}{npDef}
\begin{chunk}{defun npDefinitionOrStatement}
(defun |npDefinitionOrStatement| ()
 (|npBackTrack| #'|npGives| 'def #'|npDef|))

\end{chunk}

\defun{npBackTrack}{npBackTrack}
\calls{npBackTrack}{npState}
\calls{npBackTrack}{npEqPeek}
\calls{npBackTrack}{npRestore}
\calls{npBackTrack}{npTrap}
\begin{chunk}{defun npBackTrack}
(defun |npBackTrack| (p1 p2 p3)
 (let (a)
  (setq a (|npState|))
  (when (apply p1 nil)
    (cond
     ((|npEqPeek| p2)
       (|npRestore| a)
       (or (apply p3 nil) (|npTrap|)))
     (t t)))))

\end{chunk}

\defun{npGives}{npGives}
\calls{npGives}{npBackTrack}
\calls{npGives}{npExit}
\calls{npGives}{npLambda}
\begin{chunk}{defun npGives}
(defun |npGives| ()
 (|npBackTrack| #'|npExit| 'gives #'|npLambda|))

\end{chunk}

\defun{npLambda}{npLambda}
\calls{npLambda}{npVariable}
\calls{npLambda}{npLambda}
\calls{npLambda}{npTrap}
\calls{npLambda}{npPush}
\calls{npLambda}{pfLam}
\calls{npLambda}{npPop2}
\calls{npLambda}{npPop1}
\calls{npLambda}{npEqKey}
\calls{npLambda}{npDefinitionOrStatement}
\calls{npLambda}{npType}
\calls{npLambda}{pfReturnTyped}
\begin{chunk}{defun npLambda}
(defun |npLambda| ()
 (or
  (and
   (|npVariable|)
   (or (|npLambda|) (|npTrap|))
   (|npPush| (|pfLam| (|npPop2|) (|npPop1|))))
  (and
   (|npEqKey| 'gives)
   (or (|npDefinitionOrStatement|) (|npTrap|)))
  (and
   (|npEqKey| 'colon)
   (or (|npType|) (|npTrap|))
   (|npEqKey| 'gives)
   (or (|npDefinitionOrStatement|) (|npTrap|))
   (|npPush| (|pfReturnTyped| (|npPop2|) (|npPop1|))))))

\end{chunk}

\defun{npType}{npType}
\calls{npType}{npMatch}
\calls{npType}{npPop1}
\calls{npType}{npWith}
\calls{npType}{npPush}
\begin{chunk}{defun npType}
(defun |npType| ()
 (and
  (|npMatch|)
  (let ((a (|npPop1|)))
   (or
    (|npWith| a)
    (|npPush| a)))))

\end{chunk}

\defun{npMatch}{npMatch}
\calls{npMatch}{npLeftAssoc}
\calls{npMatch}{npSuch}
\begin{chunk}{defun npMatch}
(defun |npMatch| () 
 (|npLeftAssoc| '(is isnt) #'|npSuch|))

\end{chunk}

\defun{npSuch}{npSuch}
\calls{npSuch}{npLeftAssoc}
\calls{npSuch}{npLogical}
\begin{chunk}{defun npSuch}
(defun |npSuch| () 
 (|npLeftAssoc| '(bar) #'|npLogical|))

\end{chunk}

\defun{npWith}{npWith}
\calls{npWith}{npEqKey}
\calls{npWith}{npState}
\calls{npWith}{npCategoryL}
\calls{npWith}{npTrap}
\calls{npWith}{npEqPeek}
\calls{npWith}{npRestore}
\calls{npWith}{npVariable}
\calls{npWith}{npCompMissing}
\calls{npWith}{npPush}
\calls{npWith}{pfWith}
\calls{npWith}{npPop2}
\calls{npWith}{npPop1}
\calls{npWith}{pfNothing}
\begin{chunk}{defun npWith}
(defun |npWith| (extra)
 (let (a)
  (and
   (|npEqKey| 'with)
   (progn
    (setq a (|npState|))
    (or (|npCategoryL|) (|npTrap|))
    (if (|npEqPeek| 'in)
     (progn
       (|npRestore| a)
       (and
        (or (|npVariable|) (|npTrap|))
        (|npCompMissing| 'in)
        (or (|npCategoryL|) (|npTrap|))
        (|npPush| (|pfWith| (|npPop2|) (|npPop1|) extra))))
     (|npPush| (|pfWith| (|pfNothing|) (|npPop1|) extra)))))))

\end{chunk}

\defun{npCompMissing}{npCompMissing}
\calls{npCompMissing}{npEqKey}
\calls{npCompMissing}{npMissing}
\begin{chunk}{defun npCompMissing}
(defun |npCompMissing| (s)
 (or (|npEqKey| s) (|npMissing| s)))

\end{chunk}

\defun{npMissing}{npMissing}
\throws{npMissing}{trappoint}
\calls{npMissing}{ncSoftError}
\calls{npMissing}{tokPosn}
\calls{npMissing}{pname}
\usesdollar{npMissing}{stok}
\begin{chunk}{defun npMissing}
(defun |npMissing| (s)
 (declare (special |$stok|))
  (|ncSoftError| (|tokPosn| |$stok|) "Possibly missing a %1" (list (pname s)))
  (throw 'trappoint 'trapped))

\end{chunk}

\defun{npRestore}{npRestore}
\calls{npRestore}{npFirstTok}
\usesdollar{npRestore}{stack}
\usesdollar{npRestore}{inputStream}
\begin{chunk}{defun npRestore}
(defun |npRestore| (x)
 (declare (special |$stack| |$inputStream|))
  (setq |$inputStream| (car x))
  (|npFirstTok|)
  (setq |$stack| (cdr x))
  t)

\end{chunk}

\defun{npEqPeek}{Peek for keyword s, no advance of token stream}
\usesdollar{npEqPeek}{ttok}
\usesdollar{npEqPeek}{stok}
\begin{chunk}{defun npEqPeek 0}
(defun |npEqPeek| (s)
 (declare (special |$ttok| |$stok|))
  (and (eq (caar |$stok|) '|key|) (eq s |$ttok|)))

\end{chunk}

\defun{npCategoryL}{npCategoryL}
\calls{npCategoryL}{npCategory}
\calls{npCategoryL}{npPush}
\calls{npCategoryL}{pfUnSequence}
\calls{npCategoryL}{npPop1}
\begin{chunk}{defun npCategoryL}
(defun |npCategoryL| ()
 (and 
  (|npCategory|)
  (|npPush| (|pfUnSequence| (|npPop1|)))))

\end{chunk}

\defun{npCategory}{npCategory}
\calls{npCategory}{npPP}
\calls{npCategory}{npSCategory}
\begin{chunk}{defun npCategory}
(defun |npCategory| ()
 (|npPP| #'|npSCategory|))

\end{chunk}

\defun{npSCategory}{npSCategory}
\calls{npSCategory}{npWConditional}
\calls{npSCategory}{npCategoryL}
\calls{npSCategory}{npPush}
\calls{npSCategory}{npPop1}
\calls{npSCategory}{npDefaultValue}
\calls{npSCategory}{npState}
\calls{npSCategory}{npPrimary}
\calls{npSCategory}{npEqPeek}
\calls{npSCategory}{npRestore}
\calls{npSCategory}{npSignature}
\calls{npSCategory}{npApplication}
\calls{npSCategory}{pfAttribute}
\calls{npSCategory}{npTrap}
\begin{chunk}{defun npSCategory}
(defun |npSCategory| ()
 (let (a)
  (cond
   ((|npWConditional| #'|npCategoryL|) (|npPush| (list (|npPop1|))))
   ((|npDefaultValue|) t)
   (t
    (setq a (|npState|))
    (cond
     ((|npPrimary|)
       (cond
        ((|npEqPeek| 'colon) (|npRestore| a) (|npSignature|))
        (t
         (|npRestore| a)
         (or
          (and (|npApplication|) (|npPush| (list (|pfAttribute| (|npPop1|)))))
          (|npTrap|)))))
      (t nil))))))

\end{chunk}

\defun{npSignature}{npSignature}
\calls{npSignature}{npSigItemlist}
\calls{npSignature}{npPush}
\calls{npSignature}{pfWDec}
\calls{npSignature}{pfNothing}
\calls{npSignature}{npPop1}
\begin{chunk}{defun npSignature}
(defun |npSignature| ()
 (and (|npSigItemlist|) (|npPush| (|pfWDec| (|pfNothing|) (|npPop1|)))))

\end{chunk}

\defun{npSigItemlist}{npSigItemlist}
\calls{npSigItemlist}{npListing}
\calls{npSigItemlist}{npSigItem}
\calls{npSigItemlist}{npPush}
\calls{npSigItemlist}{pfListOf}
\calls{npSigItemlist}{pfAppend}
\calls{npSigItemlist}{pfParts}
\calls{npSigItemlist}{npPop1}
\begin{chunk}{defun npSigItemlist}
(defun |npSigItemlist| ()
 (and
  (|npListing| #'|npSigItem|)
  (|npPush| (|pfListOf| (|pfAppend| (|pfParts| (|npPop1|)))))))

\end{chunk}

\defun{npListing}{npListing}
\calls{npListing}{npList}
\calls{npListing}{pfListOf}
\begin{chunk}{defun npListing}
(defun |npListing| (p)
 (|npList| p 'comma #'|pfListOf|))

\end{chunk}

\defun{npList}{Always produces a list, fn is applied to it}
\calls{npList}{npEqKey}
\calls{npList}{npTrap}
\calls{npList}{npPush}
\calls{npList}{npPop3}
\calls{npList}{npPop2}
\calls{npList}{npPop1}
\usesdollar{npList}{stack}
\begin{chunk}{defun npList}
(defun |npList| (f str1 fn)
 (let (a)
 (declare (special |$stack|))
  (cond
   ((apply f nil)
    (cond
     ((and (|npEqKey| str1) 
           (or (|npEqKey| 'backset) t)
           (or (apply f nil) (|npTrap|)))
       (setq a |$stack|)
       (setq |$stack| nil)
       (do ()                                ; while .. do nothing
           ((not 
             (and (|npEqKey| str1)
                  (or (|npEqKey| 'backset) t)
                  (or (apply f nil) (|npTrap|))))
            nil))
       (setq |$stack| (cons (nreverse |$stack|) a))
       (|npPush| (funcall fn (cons (|npPop3|) (cons (|npPop2|) (|npPop1|))))))
     (t (|npPush| (funcall fn (list (|npPop1|)))))))
   (t (|npPush| (funcall fn nil))))))

\end{chunk}

\defun{npSigItem}{npSigItem}
\calls{npSigItem}{npTypeVariable}
\calls{npSigItem}{npSigDecl}
\calls{npSigItem}{npTrap}
\begin{chunk}{defun npSigItem}
(defun |npSigItem| ()
 (and (|npTypeVariable|) (or (|npSigDecl|) (|npTrap|))))

\end{chunk}

\defun{npTypeVariable}{npTypeVariable}
\calls{npTypeVariable}{npParenthesized}
\calls{npTypeVariable}{npTypeVariablelist}
\calls{npTypeVariable}{npSignatureDefinee}
\calls{npTypeVariable}{npPush}
\calls{npTypeVariable}{pfListOf}
\calls{npTypeVariable}{npPop1}
\begin{chunk}{defun npTypeVariable}
(defun |npTypeVariable| ()
 (or
  (|npParenthesized| #'|npTypeVariablelist|)
  (and (|npSignatureDefinee|) (|npPush| (|pfListOf| (list (|npPop1|)))))))

\end{chunk}

\defun{npSignatureDefinee}{npSignatureDefinee}
\calls{npSignatureDefinee}{npName}
\calls{npSignatureDefinee}{npInfixOperator}
\calls{npSignatureDefinee}{npPrefixColon}
\begin{chunk}{defun npSignatureDefinee}
(defun |npSignatureDefinee| ()
 (or (|npName|) (|npInfixOperator|) (|npPrefixColon|)))

\end{chunk}

\defun{npTypeVariablelist}{npTypeVariablelist}
\calls{npTypeVariablelist}{npListing}
\calls{npTypeVariablelist}{npSignatureDefinee}
\begin{chunk}{defun npTypeVariablelist}
(defun |npTypeVariablelist| ()
 (|npListing| #'|npSignatureDefinee|))

\end{chunk}

\defun{npSigDecl}{npSigDecl}
\calls{npSigDecl}{npEqKey}
\calls{npSigDecl}{npType}
\calls{npSigDecl}{npTrap}
\calls{npSigDecl}{npPush}
\calls{npSigDecl}{pfSpread}
\calls{npSigDecl}{pfParts}
\calls{npSigDecl}{npPop2}
\calls{npSigDecl}{npPop1}
\begin{chunk}{defun npSigDecl}
(defun |npSigDecl| () 
 (and
  (|npEqKey| 'colon)
  (or (|npType|) (|npTrap|))
  (|npPush| (|pfSpread| (|pfParts| (|npPop2|)) (|npPop1|)))))

\end{chunk}

\defun{npPrimary}{npPrimary}
\calls{npPrimary}{npPrimary1}
\calls{npPrimary}{npPrimary2}
\begin{chunk}{defun npPrimary}
(defun |npPrimary| ()
 (or (|npPrimary1|) (|npPrimary2|)))

\end{chunk}

\defun{npPrimary2}{npPrimary2}
\calls{npPrimary2}{npEncAp}
\calls{npPrimary2}{npAtom2}
\calls{npPrimary2}{npAdd}
\calls{npPrimary2}{pfNothing}
\calls{npPrimary2}{npWith}
\begin{chunk}{defun npPrimary2}
(defun |npPrimary2| ()
 (or
  (|npEncAp| #'|npAtom2|)
  (|npAdd| (|pfNothing|))
  (|npWith| (|pfNothing|))))

\end{chunk}

\defun{npADD}{npADD}
\tpdhere{Note that there is also an npAdd function}

\calls{npADD}{npType}
\calls{npADD}{npPop1}
\calls{npADD}{npAdd}
\calls{npADD}{npPush}
\begin{chunk}{defun npADD}
(defun |npADD| ()
 (let (a)
  (and
   (|npType|)
   (progn
    (setq a (|npPop1|))
    (or
      (|npAdd| a)
      (|npPush| a))))))

\end{chunk}

\defun{npAdd}{npAdd}
\tpdhere{Note that there is also an npADD function}

\calls{npAdd}{npEqKey}
\calls{npAdd}{npState}
\calls{npAdd}{npDefinitionOrStatement}
\calls{npAdd}{npTrap}
\calls{npAdd}{npEqPeek}
\calls{npAdd}{npRestore}
\calls{npAdd}{npVariable}
\calls{npAdd}{npCompMissing}
\calls{npAdd}{npDefinitionOrStatement}
\calls{npAdd}{npPush}
\calls{npAdd}{pfAdd}
\calls{npAdd}{npPop2}
\calls{npAdd}{npPop1}
\calls{npAdd}{pfNothing}
\begin{chunk}{defun npAdd}
(defun |npAdd| (extra)
 (let (a)
  (and
   (|npEqKey| 'add)
   (progn
    (setq a (|npState|))
    (or (|npDefinitionOrStatement|) (|npTrap|))
    (cond
     ((|npEqPeek| 'in)
      (progn
        (|npRestore| a)
        (and
         (or (|npVariable|) (|npTrap|))
         (|npCompMissing| 'in)
         (or (|npDefinitionOrStatement|) (|npTrap|))
         (|npPush| (|pfAdd| (|npPop2|) (|npPop1|) extra)))))
     (t
       (|npPush| (|pfAdd| (|pfNothing|) (|npPop1|) extra))))))))

\end{chunk}

\defun{npAtom2}{npAtom2}
\calls{npAtom2}{npInfixOperator}
\calls{npAtom2}{npAmpersand}
\calls{npAtom2}{npPrefixColon}
\calls{npAtom2}{npFromdom}
\begin{chunk}{defun npAtom2}
(defun |npAtom2| ()
 (and
  (or (|npInfixOperator|) (|npAmpersand|) (|npPrefixColon|))
  (|npFromdom|)))

\end{chunk}

\defun{npInfixOperator}{npInfixOperator}
\calls{npInfixOperator}{npInfixOp}
\calls{npInfixOperator}{npState}
\calls{npInfixOperator}{npEqKey}
\calls{npInfixOperator}{npInfixOp}
\calls{npInfixOperator}{npPush}
\calls{npInfixOperator}{pfSymb}
\calls{npInfixOperator}{npPop1}
\calls{npInfixOperator}{tokPosn}
\calls{npInfixOperator}{npRestore}
\calls{npInfixOperator}{tokConstruct}
\calls{npInfixOperator}{tokPart}
\usesdollar{npInfixOperator}{stok}
\begin{chunk}{defun npInfixOperator}
(defun |npInfixOperator| ()
 (let (b a)
  (declare (special |$stok|))
   (or (|npInfixOp|)
       (progn
        (setq a (|npState|))
        (setq b |$stok|)
        (cond
         ((and (|npEqKey| '|'|) (|npInfixOp|))
           (|npPush| (|pfSymb| (|npPop1|) (|tokPosn| b))))
          (t
           (|npRestore| a)
           (cond
            ((and (|npEqKey| 'backquote) (|npInfixOp|))
              (setq a (|npPop1|))
               (|npPush| (|tokConstruct| '|idsy| (|tokPart| a) (|tokPosn| a))))
            (t 
             (|npRestore| a)
             nil))))))))

\end{chunk}

\defun{npInfixOp}{npInfixOp}
\calls{npInfixOp}{npPushId}
\usesdollar{npInfixOp}{ttok}
\usesdollar{npInfixOp}{stok}
\begin{chunk}{defun npInfixOp}
(defun |npInfixOp| ()
 (declare (special |$ttok| |$stok|))
  (and
   (eq (caar |$stok|) '|key|)
   (get |$ttok| 'infgeneric)
   (|npPushId|)))

\end{chunk}

\defun{npPrefixColon}{npPrefixColon}
\calls{npPrefixColon}{npEqPeek}
\calls{npPrefixColon}{npPush}
\calls{npPrefixColon}{tokConstruct}
\calls{npPrefixColon}{tokPosn}
\calls{npPrefixColon}{npNext}
\usesdollar{npPrefixColon}{stok}
\begin{chunk}{defun npPrefixColon}
(defun |npPrefixColon| ()
 (declare (special |$stok|))
 (and
  (|npEqPeek| 'colon)
  (progn
   (|npPush| (|tokConstruct| '|id| '|:| (|tokPosn| |$stok|)))
   (|npNext|))))

\end{chunk}

\defun{npApplication}{npApplication}
\calls{npApplication}{npDotted}
\calls{npApplication}{npPrimary}
\calls{npApplication}{npApplication2}
\calls{npApplication}{npPush}
\calls{npApplication}{pfApplication}
\calls{npApplication}{npPop2}
\calls{npApplication}{npPop1}
\begin{chunk}{defun npApplication}
(defun |npApplication| ()
 (and
  (|npDotted| #'|npPrimary|)
  (or
   (and
    (|npApplication2|)
    (|npPush| (|pfApplication| (|npPop2|) (|npPop1|))))
    t)))

\end{chunk}

\defun{npDotted}{npDotted}
\begin{chunk}{defun npDotted}
(defun |npDotted| (f)
 (and (apply f nil) (|npAnyNo| #'|npSelector|)))

\end{chunk}

\defun{npAnyNo}{npAnyNo}
fn must transform the head of the stack
\begin{chunk}{defun npAnyNo 0}
(defun |npAnyNo| (fn)
 (do () ((not (apply fn nil)))) ; while apply do...
 t) 

\end{chunk}

\defun{npSelector}{npSelector}
\calls{npSelector}{npEqKey}
\calls{npSelector}{npPrimary}
\calls{npSelector}{npTrap}
\calls{npSelector}{npPush}
\calls{npSelector}{pfApplication}
\calls{npSelector}{npPop2}
\calls{npSelector}{npPop1}
\begin{chunk}{defun npSelector}
(defun |npSelector| ()
 (and
  (|npEqKey| 'dot)
  (or (|npPrimary|) (|npTrap|))
  (|npPush| (|pfApplication| (|npPop2|) (|npPop1|)))))

\end{chunk}

\defun{npApplication2}{npApplication2}
\calls{npApplication2}{npDotted}
\calls{npApplication2}{npPrimary1}
\calls{npApplication2}{npApplication2}
\calls{npApplication2}{npPush}
\calls{npApplication2}{pfApplication}
\calls{npApplication2}{npPop2}
\calls{npApplication2}{npPop1}
\begin{chunk}{defun npApplication2}
(defun |npApplication2| ()
 (and
  (|npDotted| #'|npPrimary1|)
  (or
   (and
    (|npApplication2|)
    (|npPush| (|pfApplication| (|npPop2|) (|npPop1|))))
    t)))

\end{chunk}

\defun{npPrimary1}{npPrimary1}
\calls{npPrimary1}{npEncAp}
\calls{npPrimary1}{npAtom1}
\calls{npPrimary1}{npLet}
\calls{npPrimary1}{npFix}
\calls{npPrimary1}{npMacro}
\calls{npPrimary1}{npBPileDefinition}
\calls{npPrimary1}{npDefn}
\calls{npPrimary1}{npRule}
\begin{chunk}{defun npPrimary1}
(defun |npPrimary1| ()
 (or
  (|npEncAp| #'|npAtom1|)
  (|npLet|)
  (|npFix|)
  (|npMacro|)
  (|npBPileDefinition|)
  (|npDefn|)
  (|npRule|)))

\end{chunk}

\defun{npMacro}{npMacro}
\calls{npMacro}{npPP}
\calls{npMacro}{npMdef}
\begin{chunk}{defun npMacro}
(defun |npMacro| ()
 (and
  (|npEqKey| 'macro)
  (|npPP| #'|npMdef|)))

\end{chunk}

\defun{npMdef}{npMdef}
\tpdhere{Beware that this function occurs with uppercase also}

\calls{npMdef}{npQuiver}
\calls{npMdef}{pfCheckMacroOut}
\calls{npMdef}{npPop1}
\calls{npMdef}{npDefTail}
\calls{npMdef}{npTrap}
\calls{npMdef}{npPop1}
\calls{npMdef}{npPush}
\calls{npMdef}{pfMacro}
\calls{npMdef}{pfPushMacroBody}
\begin{chunk}{defun npMdef}
(defun |npMdef| () 
 (let (body arg op tmp)
  (when (|npQuiver|)                    ;[op,arg]:= pfCheckMacroOut(npPop1())
   (setq tmp (|pfCheckMacroOut| (|npPop1|))) 
   (setq op (car tmp))
   (setq arg (cadr tmp))
   (or (|npDefTail|) (|npTrap|))
   (setq body (|npPop1|))
   (if (null arg) 
    (|npPush| (|pfMacro| op body))
    (|npPush| (|pfMacro| op (|pfPushMacroBody| arg body)))))))

\end{chunk}

\defun{npMDEF}{npMDEF}
\tpdhere{Beware that this function occurs with lowercase also}

\calls{npMDEF}{npBackTrack}
\calls{npMDEF}{npStatement}
\calls{npMDEF}{npMDEFinition}
\begin{chunk}{defun npMDEF}
(defun |npMDEF| () 
 (|npBackTrack| #'|npStatement| 'mdef #'|npMDEFinition|))

\end{chunk}

\defun{npMDEFinition}{npMDEFinition}
\calls{npMDEFinition}{npPP}
\calls{npMDEFinition}{npMdef}
\begin{chunk}{defun npMDEFinition}
(defun |npMDEFinition| ()
 (|npPP| #'|npMdef|))

\end{chunk}

\defun{npFix}{npFix}
\calls{npFix}{npEqKey}
\calls{npFix}{npDef}
\calls{npFix}{npPush}
\calls{npFix}{pfFix}
\calls{npFix}{npPop1}
\begin{chunk}{defun npFix}
(defun |npFix| ()
 (and
  (|npEqKey| 'fix)
  (|npPP| #'|npDef|)
  (|npPush| (|pfFix| (|npPop1|)))))

\end{chunk}

\defun{npLet}{npLet}
\calls{npLet}{npLetQualified}
\calls{npLet}{npDefinitionOrStatement}
\begin{chunk}{defun npLet}
(defun |npLet| ()
 (|npLetQualified| #'|npDefinitionOrStatement|))

\end{chunk}

\defun{npLetQualified}{npLetQualified}
\calls{npLetQualified}{npEqKey}
\calls{npLetQualified}{npDefinition}
\calls{npLetQualified}{npTrap}
\calls{npLetQualified}{npCompMissing}
\calls{npLetQualified}{npPush}
\calls{npLetQualified}{pfWhere}
\calls{npLetQualified}{npPop2}
\calls{npLetQualified}{npPop1}
\begin{chunk}{defun npLetQualified}
(defun |npLetQualified| (f)
 (and
  (|npEqKey| 'let)
  (or (|npDefinition|) (|npTrap|))
  (|npCompMissing| 'in)
  (or (funcall f) (|npTrap|))
  (|npPush| (|pfWhere| (|npPop2|) (|npPop1|)))))

\end{chunk}

\defun{npDefinition}{npDefinition}
\calls{npDefinition}{npPP}
\calls{npDefinition}{npDefinitionItem}
\calls{npDefinition}{npPush}
\calls{npDefinition}{pfSequenceToList}
\calls{npDefinition}{npPop1}
\begin{chunk}{defun npDefinition}
(defun |npDefinition| ()
 (and
  (|npPP| #'|npDefinitionItem|)
  (|npPush| (|pfSequenceToList| (|npPop1|)))))

\end{chunk}

\defun{npDefinitionItem}{npDefinitionItem}
\calls{npDefinitionItem}{npTyping}
\calls{npDefinitionItem}{npImport}
\calls{npDefinitionItem}{npState}
\calls{npDefinitionItem}{npStatement}
\calls{npDefinitionItem}{npEqPeek}
\calls{npDefinitionItem}{npRestore}
\calls{npDefinitionItem}{npDef}
\calls{npDefinitionItem}{npMacro}
\calls{npDefinitionItem}{npDefn}
\calls{npDefinitionItem}{npTrap}
\begin{chunk}{defun npDefinitionItem}
(defun |npDefinitionItem| ()
 (let (a)
  (or (|npTyping|) 
      (|npImport|)
      (progn
       (setq a (|npState|))
       (cond
        ((|npStatement|)
         (cond
           ((|npEqPeek| 'def)
            (|npRestore| a) 
            (|npDef|))
           (t
            (|npRestore| a)
            (or (|npMacro|) (|npDefn|)))))
        (t (|npTrap|)))))))

\end{chunk}

\defun{npTyping}{npTyping}
\calls{npTyping}{npEqKey}
\calls{npTyping}{npDefaultItemlist}
\calls{npTyping}{npTrap}
\calls{npTyping}{npPush}
\calls{npTyping}{pfTyping}
\calls{npTyping}{npPop1}
\begin{chunk}{defun npTyping}
(defun |npTyping| ()
 (and
  (|npEqKey| 'default)
  (or (|npDefaultItemlist|) (|npTrap|))
  (|npPush| (|pfTyping| (|npPop1|)))))

\end{chunk}

\defun{npDefaultItemlist}{npDefaultItemlist}
\calls{npDefaultItemlist}{npPC}
\calls{npDefaultItemlist}{npSDefaultItem}
\calls{npDefaultItemlist}{npPush}
\calls{npDefaultItemlist}{pfUnSequence}
\calls{npDefaultItemlist}{npPop1}
\begin{chunk}{defun npDefaultItemlist}
(defun |npDefaultItemlist| ()
 (and
  (|npPC| #'|npSDefaultItem|)
  (|npPush| (|pfUnSequence| (|npPop1|)))))

\end{chunk}

\defun{npSDefaultItem}{npSDefaultItem}
\calls{npSDefaultItem}{npListing}
\calls{npSDefaultItem}{npDefaultItem}
\calls{npSDefaultItem}{npPush}
\calls{npSDefaultItem}{pfAppend}
\calls{npSDefaultItem}{pfParts}
\calls{npSDefaultItem}{npPop1}
\begin{chunk}{defun npSDefaultItem}
(defun |npSDefaultItem| ()
 (and
  (|npListing| #'|npDefaultItem|)
  (|npPush| (|pfAppend| (|pfParts| (|npPop1|))))))

\end{chunk}

\defun{npDefaultItem}{npDefaultItem}
\calls{npDefaultItem}{npTypeVariable}
\calls{npDefaultItem}{npDefaultDecl}
\calls{npDefaultItem}{npTrap}
\begin{chunk}{defun npDefaultItem}
(defun |npDefaultItem| ()
 (and
  (|npTypeVariable|)
  (or (|npDefaultDecl|) (|npTrap|))))

\end{chunk}

\defun{npDefaultDecl}{npDefaultDecl}
\calls{npDefaultDecl}{npEqKey}
\calls{npDefaultDecl}{npType}
\calls{npDefaultDecl}{npTrap}
\calls{npDefaultDecl}{npPush}
\calls{npDefaultDecl}{pfSpread}
\calls{npDefaultDecl}{pfParts}
\calls{npDefaultDecl}{npPop2}
\calls{npDefaultDecl}{npPop1}
\begin{chunk}{defun npDefaultDecl}
(defun |npDefaultDecl| ()
 (and
  (|npEqKey| 'colon)
  (or (|npType|) (|npTrap|))
  (|npPush| (|pfSpread| (|pfParts| (|npPop2|)) (|npPop1|)))))

\end{chunk}

\defun{npStatement}{npStatement}
\calls{npStatement}{npExpress}
\calls{npStatement}{npLoop}
\calls{npStatement}{npIterate}
\calls{npStatement}{npReturn}
\calls{npStatement}{npBreak}
\calls{npStatement}{npFree}
\calls{npStatement}{npImport}
\calls{npStatement}{npInline}
\calls{npStatement}{npLocal}
\calls{npStatement}{npExport}
\calls{npStatement}{npTyping}
\calls{npStatement}{npVoid}
\begin{chunk}{defun npStatement}
(defun |npStatement| () 
 (or
  (|npExpress|)
  (|npLoop|)
  (|npIterate|)
  (|npReturn|)
  (|npBreak|)
  (|npFree|)
  (|npImport|)
  (|npInline|)
  (|npLocal|)
  (|npExport|)
  (|npTyping|)
  (|npVoid|)))

\end{chunk}

\defun{npExport}{npExport}
\calls{npExport}{npEqKey}
\calls{npExport}{npLocalItemlist}
\calls{npExport}{npTrap}
\calls{npExport}{npPush}
\calls{npExport}{pfExport}
\calls{npExport}{npPop1}
\begin{chunk}{defun npExport}
(defun |npExport| ()
 (and
  (|npEqKey| 'export)
  (or (|npLocalItemlist|) (|npTrap|))
  (|npPush| (|pfExport| (|npPop1|)))))

\end{chunk}

\defun{npLocalItemlist}{npLocalItemlist}
\calls{npLocalItemlist}{npPC}
\calls{npLocalItemlist}{npSLocalItem}
\calls{npLocalItemlist}{npPush}
\calls{npLocalItemlist}{pfUnSequence}
\calls{npLocalItemlist}{npPop1}
\begin{chunk}{defun npLocalItemlist}
(defun |npLocalItemlist| ()
 (and
  (|npPC| #'|npSLocalItem|)
  (|npPush| (|pfUnSequence| (|npPop1|)))))

\end{chunk}

\defun{npSLocalItem}{npSLocalItem}
\calls{npSLocalItem}{npListing}
\calls{npSLocalItem}{npLocalItem}
\calls{npSLocalItem}{npPush}
\calls{npSLocalItem}{pfAppend}
\calls{npSLocalItem}{pfParts}
\calls{npSLocalItem}{npPop1}
\begin{chunk}{defun npSLocalItem}
(defun |npSLocalItem| ()
 (and
  (|npListing| #'|npLocalItem|)
  (|npPush| (|pfAppend| (|pfParts| (|npPop1|))))))

\end{chunk}

\defun{npLocalItem}{npLocalItem}
\calls{npLocalItem}{npTypeVariable}
\calls{npLocalItem}{npLocalDecl}
\begin{chunk}{defun npLocalItem}
(defun |npLocalItem| ()
 (and
  (|npTypeVariable|)
  (|npLocalDecl|)))

\end{chunk}

\defun{npLocalDecl}{npLocalDecl}
\calls{npLocalDecl}{npEqKey}
\calls{npLocalDecl}{npType}
\calls{npLocalDecl}{npTrap}
\calls{npLocalDecl}{npPush}
\calls{npLocalDecl}{pfSpread}
\calls{npLocalDecl}{pfParts}
\calls{npLocalDecl}{npPop2}
\calls{npLocalDecl}{npPop1}
\calls{npLocalDecl}{pfNothing}
\begin{chunk}{defun npLocalDecl}
(defun |npLocalDecl| ()
 (or
  (and
   (|npEqKey| 'colon)
   (or (|npType|) (|npTrap|))
   (|npPush| (|pfSpread| (|pfParts| (|npPop2|)) (|npPop1|))))
  (|npPush| (|pfSpread| (|pfParts| (|npPop1|)) (|pfNothing|)))))

\end{chunk}

\defun{npLocal}{npLocal}
\calls{npLocal}{npEqKey}
\calls{npLocal}{npLocalItemlist}
\calls{npLocal}{npTrap}
\calls{npLocal}{npPush}
\calls{npLocal}{pfLocal}
\calls{npLocal}{npPop1}
\begin{chunk}{defun npLocal}
(defun |npLocal| ()
 (and
  (|npEqKey| '|local|)
  (or (|npLocalItemlist|) (|npTrap|))
  (|npPush| (|pfLocal| (|npPop1|)))))

\end{chunk}

\defun{npFree}{npFree}
\calls{npFree}{npEqKey}
\calls{npFree}{npLocalItemlist}
\calls{npFree}{npTrap}
\calls{npFree}{npPush}
\calls{npFree}{pfFree}
\calls{npFree}{npPop1}
\begin{chunk}{defun npFree}
(defun |npFree| ()
 (and
  (|npEqKey| 'free)
  (or (|npLocalItemlist|) (|npTrap|))
  (|npPush| (|pfFree| (|npPop1|)))))

\end{chunk}

\defun{npInline}{npInline}
\calls{npInline}{npAndOr}
\calls{npInline}{npQualTypelist}
\calls{npInline}{pfInline}
\begin{chunk}{defun npInline}
(defun |npInline| () 
 (|npAndOr| 'inline #'|npQualTypelist| #'|pfInline|))

\end{chunk}

\defun{npIterate}{npIterate}
\calls{npIterate}{npEqKey}
\calls{npIterate}{npPush}
\calls{npIterate}{pfIterate}
\calls{npIterate}{pfNothing}
\begin{chunk}{defun npIterate}
(defun |npIterate| ()
 (and (|npEqKey| 'iterate) (|npPush| (|pfIterate| (|pfNothing|)))))

\end{chunk}

\defun{npBreak}{npBreak}
\calls{npBreak}{npEqKey}
\calls{npBreak}{npPush}
\calls{npBreak}{pfBreak}
\calls{npBreak}{pfNothing}
\begin{chunk}{defun npBreak}
(defun |npBreak| ()
 (and (|npEqKey| 'break) (|npPush| (|pfBreak| (|pfNothing|)))))

\end{chunk}

\defun{npLoop}{npLoop}
\calls{npLoop}{npIterators}
\calls{npLoop}{npCompMissing}
\calls{npLoop}{npAssign}
\calls{npLoop}{npTrap}
\calls{npLoop}{npPush}
\calls{npLoop}{pfLp}
\calls{npLoop}{npPop2}
\calls{npLoop}{npPop1}
\calls{npLoop}{npEqKey}
\calls{npLoop}{pfLoop1}
\begin{chunk}{defun npLoop}
(defun |npLoop| ()
 (or
  (and 
   (|npIterators|)
   (|npCompMissing| 'repeat)
   (or (|npAssign|) (|npTrap|))
   (|npPush| (|pfLp| (|npPop2|) (|npPop1|))))
  (and
   (|npEqKey| 'repeat)
   (or (|npAssign|) (|npTrap|))
   (|npPush| (|pfLoop1| (|npPop1|))))))

\end{chunk}

\defun{npIterators}{npIterators}
\calls{npIterators}{npForIn}
\calls{npIterators}{npZeroOrMore}
\calls{npIterators}{npIterator}
\calls{npIterators}{npPush}
\calls{npIterators}{npPop2}
\calls{npIterators}{npPop1}
\calls{npIterators}{npWhile}
\calls{npIterators}{npIterators}
\begin{chunk}{defun npIterators}
(defun |npIterators| ()
 (or
  (and
   (|npForIn|)
   (|npZeroOrMore| #'|npIterator|)
   (|npPush| (cons (|npPop2|) (|npPop1|))))
  (and
   (|npWhile|)
   (or
    (and (|npIterators|) (|npPush| (cons (|npPop2|) (|npPop1|))))
    (|npPush| (list (|npPop1|)))))))

\end{chunk}

\defun{npIterator}{npIterator}
\calls{npIterator}{npForIn}
\calls{npIterator}{npSuchThat}
\calls{npIterator}{npWhile}
\begin{chunk}{defun npIterator}
(defun |npIterator| ()
 (or
  (|npForIn|)
  (|npSuchThat|)
  (|npWhile|)))

\end{chunk}

\defun{npSuchThat}{npSuchThat}
\calls{npSuchThat}{npAndOr}
\calls{npSuchThat}{npLogical}
\calls{npSuchThat}{pfSuchthat}
\begin{chunk}{defun npSuchThat}
(defun |npSuchThat| ()
 (|npAndOr| 'bar #'|npLogical| #'|pfSuchthat|))

\end{chunk}

\defun{npZeroOrMore}{Apply argument 0 or more times}
\calls{npZeroOrMore}{npPush}
\calls{npZeroOrMore}{npPop2}
\calls{npZeroOrMore}{npPop1}
\usesdollar{npZeroOrMore}{stack}
\begin{chunk}{defun npZeroOrMore}
(defun |npZeroOrMore| (f)
 (let (a)
 (declare (special |$stack|))
  (cond
   ((apply f nil)
    (setq a |$stack|)
    (setq |$stack| nil)
    (do () ((not (apply f nil)))) ; while .. do
    (setq |$stack| (cons (nreverse |$stack|) a))
    (|npPush| (cons (|npPop2|) (|npPop1|))))
   (t (progn (|npPush| nil) t)))))

\end{chunk}

\defun{npWhile}{npWhile}
\calls{npWhile}{npAndOr}
\calls{npWhile}{npLogical}
\calls{npWhile}{pfWhile}
\begin{chunk}{defun npWhile}
(defun |npWhile| ()
 (|npAndOr| 'while  #'|npLogical| #'|pfWhile|))

\end{chunk}

\defun{npForIn}{npForIn}
\calls{npForIn}{npEqKey}
\calls{npForIn}{npVariable}
\calls{npForIn}{npTrap}
\calls{npForIn}{npCompMissing}
\calls{npForIn}{npBy}
\calls{npForIn}{npPush}
\calls{npForIn}{pfForin}
\calls{npForIn}{npPop2}
\calls{npForIn}{npPop1}
\begin{chunk}{defun npForIn}
(defun |npForIn| ()
 (and
  (|npEqKey| 'for)
  (or (|npVariable|) (|npTrap|))
  (|npCompMissing| 'in)
  (or (|npBy|) (|npTrap|))
  (|npPush| (|pfForin| (|npPop2|) (|npPop1|)))))

\end{chunk}

\defun{npReturn}{npReturn}
\calls{npReturn}{npEqKey}
\calls{npReturn}{npExpress}
\calls{npReturn}{npPush}
\calls{npReturn}{pfNothing}
\calls{npReturn}{npEqKey}
\calls{npReturn}{npName}
\calls{npReturn}{npTrap}
\calls{npReturn}{pfReturn}
\calls{npReturn}{npPop2}
\calls{npReturn}{npPop1}
\calls{npReturn}{pfReturnNoName}
\begin{chunk}{defun npReturn}
(defun |npReturn| ()
 (and
  (|npEqKey| 'return)
  (or 
   (|npExpress|)
   (|npPush| (|pfNothing|)))
  (or
   (and
    (|npEqKey| 'from)
    (or (|npName|) (|npTrap|))
    (|npPush| (|pfReturn| (|npPop2|) (|npPop1|))))
   (|npPush| (|pfReturnNoName| (|npPop1|))))))

\end{chunk}

\defun{npVoid}{npVoid}
\calls{npVoid}{npAndOr}
\calls{npVoid}{npStatement}
\calls{npVoid}{pfNovalue}
\begin{chunk}{defun npVoid}
(defun |npVoid| ()
 (|npAndOr| 'do #'|npStatement| #'|pfNovalue|))

\end{chunk}

\defun{npExpress}{npExpress}
\calls{npExpress}{npExpress1}
\calls{npExpress}{npIterators}
\calls{npExpress}{npPush}
\calls{npExpress}{pfCollect}
\calls{npExpress}{npPop2}
\calls{npExpress}{pfListOf}
\calls{npExpress}{npPop1}
\begin{chunk}{defun npExpress}
(defun |npExpress| ()
 (and
  (|npExpress1|)
  (or
   (and
    (|npIterators|)
    (|npPush| (|pfCollect| (|npPop2|) (|pfListOf| (|npPop1|)))))
   t)))

\end{chunk}

\defun{npExpress1}{npExpress1}
\calls{npExpress1}{npConditionalStatement}
\calls{npExpress1}{npADD}
\begin{chunk}{defun npExpress1}
(defun |npExpress1| ()
 (or (|npConditionalStatement|) (|npADD|)))

\end{chunk}

\defun{npConditionalStatement}{npConditionalStatement}
\calls{npConditionalStatement}{npConditional}
\calls{npConditionalStatement}{npQualifiedDefinition}
\begin{chunk}{defun npConditionalStatement}
(defun |npConditionalStatement| ()
 (|npConditional| #'|npQualifiedDefinition|))

\end{chunk}

\defun{npImport}{npImport}
\calls{npImport}{npAndOr}
\calls{npImport}{npQualTypelist}
\calls{npImport}{pfImport}
\begin{chunk}{defun npImport}
(defun |npImport| ()
 (|npAndOr| 'import #'|npQualTypelist| #'|pfImport|))

\end{chunk}

\defun{npQualTypelist}{npQualTypelist}
\calls{npQualTypelist}{npPC}
\calls{npQualTypelist}{npSQualTypelist}
\calls{npQualTypelist}{npPush}
\calls{npQualTypelist}{pfUnSequence}
\calls{npQualTypelist}{npPop1}
\begin{chunk}{defun npQualTypelist}
(defun |npQualTypelist| ()
 (and
  (|npPC| #'|npSQualTypelist|)
  (|npPush| (|pfUnSequence| (|npPop1|)))))

\end{chunk}

\defun{npSQualTypelist}{npSQualTypelist}
\calls{npSQualTypelist}{npListing}
\calls{npSQualTypelist}{npQualType}
\calls{npSQualTypelist}{npPush}
\calls{npSQualTypelist}{pfParts}
\calls{npSQualTypelist}{npPop1}
\begin{chunk}{defun npSQualTypelist}
(defun |npSQualTypelist| ()
 (and
  (|npListing| #'|npQualType|)
  (|npPush| (|pfParts| (|npPop1|)))))

\end{chunk}

\defun{npQualType}{npQualType}
\calls{npQualType}{npType}
\calls{npQualType}{npPush}
\calls{npQualType}{pfQualType}
\calls{npQualType}{npPop1}
\calls{npQualType}{pfNothing}
\begin{chunk}{defun npQualType}
(defun |npQualType| () 
 (and
  (|npType|)
  (|npPush| (|pfQualType| (|npPop1|) (|pfNothing|)))))

\end{chunk}

\defun{npAndOr}{npAndOr}
\calls{npAndOr}{npEqKey}
\calls{npAndOr}{npTrap}
\calls{npAndOr}{npPush}
\calls{npAndOr}{npPop1}
\begin{chunk}{defun npAndOr}
(defun |npAndOr| (keyword p f)
 (and
  (|npEqKey| keyword)
  (or (apply p nil) (|npTrap|))
  (|npPush| (funcall f (|npPop1|)))))

\end{chunk}

\defun{npEncAp}{npEncAp}
\calls{npEncAp}{npAnyNo}
\calls{npEncAp}{npEncl}
\calls{npEncAp}{npFromdom}
\begin{chunk}{defun npEncAp}
(defun |npEncAp| (f)
 (and (apply f nil) (|npAnyNo| #'|npEncl|) (|npFromdom|)))

\end{chunk}

\defun{npEncl}{npEncl}
\calls{npEncl}{npBDefinition}
\calls{npEncl}{npPush}
\calls{npEncl}{pfApplication}
\calls{npEncl}{npPop2}
\calls{npEncl}{npPop1}
\begin{chunk}{defun npEncl}
(defun |npEncl| ()
 (and
  (|npBDefinition|)
  (|npPush| (|pfApplication| (|npPop2|) (|npPop1|)))))

\end{chunk}

\defun{npAtom1}{npAtom1}
\calls{npAtom1}{npPDefinition}
\calls{npAtom1}{npName}
\calls{npAtom1}{npConstTok}
\calls{npAtom1}{npDollar}
\calls{npAtom1}{npBDefinition}
\calls{npAtom1}{npFromdom}
\begin{chunk}{defun npAtom1}
(defun |npAtom1| ()
 (or
  (|npPDefinition|)
  (and
   (or (|npName|) (|npConstTok|) (|npDollar|) (|npBDefinition|))
   (|npFromdom|))))

\end{chunk}

\defun{npPDefinition}{npPDefinition}
\calls{npPDefinition}{npParenthesized}
\calls{npPDefinition}{npDefinitionlist}
\calls{npPDefinition}{npPush}
\calls{npPDefinition}{pfEnSequence}
\calls{npPDefinition}{npPop1}
\begin{chunk}{defun npPDefinition}
(defun |npPDefinition| ()
 (and
  (|npParenthesized| #'|npDefinitionlist|)
  (|npPush| (|pfEnSequence| (|npPop1|)))))

\end{chunk}

\defun{npDollar}{npDollar}
\calls{npDollar}{npEqPeek}
\calls{npDollar}{npPush}
\calls{npDollar}{tokConstruct}
\calls{npDollar}{tokPosn}
\calls{npDollar}{npNext}
\usesdollar{npDollar}{stok}
\begin{chunk}{defun npDollar}
(defun |npDollar| ()
 (declare (special |$stok|))
  (and (|npEqPeek| '$)
       (progn
        (|npPush| (|tokConstruct| '|id| '$ (|tokPosn| |$stok|)))
        (|npNext|))))

\end{chunk}

\defun{npConstTok}{npConstTok}
\calls{npConstTok}{tokType}
\calls{npConstTok}{npPush}
\calls{npConstTok}{npNext}
\calls{npConstTok}{npEqPeek}
\calls{npConstTok}{npState}
\calls{npConstTok}{npPrimary1}
\calls{npConstTok}{pfSymb}
\calls{npConstTok}{npPop1}
\calls{npConstTok}{tokPosn}
\calls{npConstTok}{npRestore}
\usesdollar{npConstTok}{stok}
\begin{chunk}{defun npConstTok}
(defun |npConstTok| ()
 (let (b a)
 (declare (special |$stok|))
  (cond
   ((member (|tokType| |$stok|) '(|integer| |string| |char| |float| |command|))
    (|npPush| |$stok|) 
    (|npNext|))
   ((|npEqPeek| '|'|)
    (setq a |$stok|)
    (setq b (|npState|))
    (|npNext|)
    (cond
      ((and (|npPrimary1|)
            (|npPush| (|pfSymb| (|npPop1|) (|tokPosn| a))))
       t)
      (t (|npRestore| b) nil)))
   (t nil))))

\end{chunk}

\defun{npBDefinition}{npBDefinition}
\calls{npBDefinition}{npPDefinition}
\calls{npBDefinition}{npBracketed}
\calls{npBDefinition}{npDefinitionlist}
\begin{chunk}{defun npBDefinition}
(defun |npBDefinition| ()
 (or
  (|npPDefinition|)
  (|npBracketed| #'|npDefinitionlist|)))

\end{chunk}

\defun{npBracketed}{npBracketed}
\calls{npBracketed}{npParened}
\calls{npBracketed}{npBracked}
\calls{npBracketed}{npBraced}
\calls{npBracketed}{npAngleBared}
\begin{chunk}{defun npBracketed}
(defun |npBracketed| (f)
 (or
  (|npParened| f)
  (|npBracked| f)
  (|npBraced| f)
  (|npAngleBared| f)))

\end{chunk}

\defun{npParened}{npParened}
\calls{npParened}{npEnclosed}
\calls{npParened}{pfParen}
\begin{chunk}{defun npParened}
(defun |npParened| (f)
 (or (|npEnclosed| '|(| '|)| #'|pfParen| f)
     (|npEnclosed| '|(\|| '|\|)| #'|pfParen| f)))

\end{chunk}

\defun{npBracked}{npBracked}
\calls{npBracked}{npEnclosed}
\calls{npBracked}{pfBracket}
\calls{npBracked}{pfBracketBar}
\begin{chunk}{defun npBracked}
(defun |npBracked| (f)
 (or (|npEnclosed| '[ '] #'|pfBracket| f)
     (|npEnclosed| '|[\|| '|\|]| #'|pfBracketBar| f)))

\end{chunk}

\defun{npBraced}{npBraced}
\calls{npBraced}{npEnclosed}
\calls{npBraced}{pfBrace}
\calls{npBraced}{pfBraceBar}
\begin{chunk}{defun npBraced}
(defun |npBraced| (f)
 (or (|npEnclosed| '{ '} #'|pfBrace| f)
     (|npEnclosed| '|{\|| '|\|}| #'|pfBraceBar| f)))

\end{chunk}

\defun{npAngleBared}{npAngleBared}
\calls{npAngleBared}{npEnclosed}
\calls{npAngleBared}{pfHide}
\begin{chunk}{defun npAngleBared}
(defun |npAngleBared| (f)
  (|npEnclosed| '|<\|| '|\|>| #'|pfHide| f))

\end{chunk}

\defun{npDefn}{npDefn}
\calls{npDefn}{npEqKey}
\calls{npDefn}{npPP}
\calls{npDefn}{npDef}
\begin{chunk}{defun npDefn}
(defun |npDefn| ()
 (and
  (|npEqKey| 'defn)
  (|npPP| #'|npDef|)))

\end{chunk}

\defun{npDef}{npDef}
\calls{npDef}{npMatch}
\calls{npDef}{pfCheckItOut}
\calls{npDef}{npPop1}
\calls{npDef}{npDefTail}
\calls{npDef}{npTrap}
\calls{npDef}{npPop1}
\calls{npDef}{npPush}
\calls{npDef}{pfDefinition}
\calls{npDef}{pfPushBody}
\begin{chunk}{defun npDef}
(defun |npDef| ()
 (let (body rt arg op tmp1)
  (when (|npMatch|)
   ; [op,arg,rt]:=  pfCheckItOut(npPop1())
   (setq tmp1 (|pfCheckItOut| (|npPop1|))) 
   (setq op (car tmp1))
   (setq arg (cadr tmp1))
   (setq rt (caddr tmp1))
   (or (|npDefTail|) (|npTrap|))
   (setq body (|npPop1|))
   (if (null arg)
    (|npPush| (|pfDefinition| op body))
    (|npPush| (|pfDefinition| op (|pfPushBody| rt arg body)))))))

\end{chunk}

\defun{npBPileDefinition}{npBPileDefinition}
\calls{npBPileDefinition}{npPileBracketed}
\calls{npBPileDefinition}{npPileDefinitionlist}
\calls{npBPileDefinition}{npPush}
\calls{npBPileDefinition}{pfSequence}
\calls{npBPileDefinition}{pfListOf}
\calls{npBPileDefinition}{npPop1}
\begin{chunk}{defun npBPileDefinition}
(defun |npBPileDefinition| ()
 (and
  (|npPileBracketed| #'|npPileDefinitionlist|)
  (|npPush| (|pfSequence| (|pfListOf| (|npPop1|))))))

\end{chunk}

\defun{npPileBracketed}{npPileBracketed}
\calls{npPileBracketed}{npEqKey}
\calls{npPileBracketed}{npPush}
\calls{npPileBracketed}{pfNothing}
\calls{npPileBracketed}{npMissing}
\calls{npPileBracketed}{pfPile}
\calls{npPileBracketed}{npPop1}
\begin{chunk}{defun npPileBracketed}
(defun |npPileBracketed| (f)
 (cond
  ((|npEqKey| 'settab)
   (cond
    ((|npEqKey| 'backtab) (|npPush| (|pfNothing|))) ; never happens
    ((and (apply f nil)
          (or (|npEqKey| 'backtab) (|npMissing| '|backtab|)))
     (|npPush| (|pfPile| (|npPop1|))))
    (t nil)))
  (t nil)))

\end{chunk}

\defun{npPileDefinitionlist}{npPileDefinitionlist}
\calls{npPileDefinitionlist}{npListAndRecover}
\calls{npPileDefinitionlist}{npDefinitionlist}
\calls{npPileDefinitionlist}{npPush}
\calls{npPileDefinitionlist}{pfAppend}
\calls{npPileDefinitionlist}{npPop1}
\begin{chunk}{defun npPileDefinitionlist}
(defun |npPileDefinitionlist| ()
 (and
  (|npListAndRecover| #'|npDefinitionlist|)
  (|npPush| (|pfAppend| (|npPop1|)))))

\end{chunk}

\defun{npListAndRecover}{npListAndRecover}
\catches{npListAndRecover}{trappoint}
\calls{npListAndRecover}{npRecoverTrap}
\calls{npListAndRecover}{syGeneralErrorHere}
\calls{npListAndRecover}{npEqKey}
\calls{npListAndRecover}{npEqPeek}
\calls{npListAndRecover}{npNext}
\calls{npListAndRecover}{npPop1}
\calls{npListAndRecover}{npPush}
\usesdollar{npListAndRecover}{inputStream}
\usesdollar{npListAndRecover}{stack}
\begin{chunk}{defun npListAndRecover}
(defun |npListAndRecover| (f)
 (let (found c done b savestack)
 (declare (special |$inputStream| |$stack|))
  (setq savestack |$stack|)
  (setq |$stack| nil)
  (setq c |$inputStream|)
  (do ()
      (done)
   (setq found (catch 'trappoint (apply f nil)))
   (cond
    ((eq found 'trapped)
     (setq |$inputStream| c)
     (|npRecoverTrap|))
    ((null found)
     (setq |$inputStream| c)
     (|syGeneralErrorHere|) (|npRecoverTrap|)))
   (cond
    ((|npEqKey| 'backset) (setq c |$inputStream|))
    ((|npEqPeek| 'backtab) (setq done t))
    (t 
     (setq |$inputStream| c)
     (|syGeneralErrorHere|) 
     (|npRecoverTrap|)
     (cond
      ((|npEqPeek| 'backtab) (setq done t))
      (t 
       (|npNext|) 
       (setq c |$inputStream|)))))
   (setq b (cons (|npPop1|) b)))
  (setq |$stack| savestack)
  (|npPush| (nreverse b))))

\end{chunk}

\defun{npRecoverTrap}{npRecoverTrap}
\calls{npRecoverTrap}{npFirstTok}
\calls{npRecoverTrap}{tokPosn}
\calls{npRecoverTrap}{npMoveTo}
\calls{npRecoverTrap}{syIgnoredFromTo}
\calls{npRecoverTrap}{npPush}
\calls{npRecoverTrap}{pfWrong}
\calls{npRecoverTrap}{pfDocument}
\calls{npRecoverTrap}{pfListOf}
\usesdollar{npRecoverTrap}{stok}
\begin{chunk}{defun npRecoverTrap}
(defun |npRecoverTrap| ()
 (let (pos2 pos1)
 (declare (special |$stok|))
  (|npFirstTok|)
  (setq pos1 (|tokPosn| |$stok|))
  (|npMoveTo| 0)
  (setq pos2 (|tokPosn| |$stok|))
  (|syIgnoredFromTo| pos1 pos2)
  (|npPush|
   (list (|pfWrong| (|pfDocument| (list "pile syntax error"))
                    (|pfListOf| nil))))))

\end{chunk}

\defun{npMoveTo}{npMoveTo}
\calls{npMoveTo}{npEqPeek}
\calls{npMoveTo}{npNext}
\calls{npMoveTo}{npMoveTo}
\calls{npMoveTo}{npEqKey}
\usesdollar{npMoveTo}{inputStream}
\begin{chunk}{defun npMoveTo}
(defun |npMoveTo| (|n|)
 (declare (special |$inputStream|))
  (cond
   ((null |$inputStream|) t)
   ((|npEqPeek| 'backtab)
    (cond
     ((eql |n| 0) t)
     (t (|npNext|) (|npMoveTo| (1- |n|)))))
   ((|npEqPeek| 'backset)
    (cond
     ((eql |n| 0) t)
     (t (|npNext|) (|npMoveTo| |n|))))
   ((|npEqKey| 'settab) (|npMoveTo| (+ |n| 1)))
   (t (|npNext|) (|npMoveTo| |n|))))

\end{chunk}

\defun{syIgnoredFromTo}{syIgnoredFromTo}
\calls{syIgnoredFromTo}{pfGlobalLinePosn}
\calls{syIgnoredFromTo}{ncSoftError}
\calls{syIgnoredFromTo}{FromTo}
\calls{syIgnoredFromTo}{From}
\calls{syIgnoredFromTo}{To}
\begin{chunk}{defun syIgnoredFromTo}
(defun |syIgnoredFromTo| (pos1 pos2)
 (cond
  ((equal (|pfGlobalLinePosn| pos1) (|pfGlobalLinePosn| pos2))
   (|ncSoftError| (|FromTo| pos1 pos2) "Ignored." nil))
  (t
   (|ncSoftError| (|From| pos1) "Ignored from here" nil)
   (|ncSoftError| (|To| pos2) "to here." nil))))

\end{chunk}

\defun{syGeneralErrorHere}{syGeneralErrorHere}
\calls{syGeneralErrorHere}{sySpecificErrorHere}
\begin{chunk}{defun syGeneralErrorHere}
(defun |syGeneralErrorHere| ()
 (|sySpecificErrorHere| " Improper syntax." nil))

\end{chunk}

\defun{sySpecificErrorHere}{sySpecificErrorHere}
\calls{sySpecificErrorHere}{sySpecificErrorAtToken}
\usesdollar{sySpecificErrorHere}{stok}
\begin{chunk}{defun sySpecificErrorHere}
(defun |sySpecificErrorHere| (key args)
 (declare (special |$stok|))
 (|sySpecificErrorAtToken| |$stok| key args))

\end{chunk}

\defun{sySpecificErrorAtToken}{sySpecificErrorAtToken}
\calls{sySpecificErrorAtToken}{ncSoftError}
\calls{sySpecificErrorAtToken}{tokPosn}
\begin{chunk}{defun sySpecificErrorAtToken}
(defun |sySpecificErrorAtToken| (tok key args)
 (|ncSoftError| (|tokPosn| tok) key args))

\end{chunk}

\defun{npDefinitionlist}{npDefinitionlist}
\calls{npDefinitionlist}{npSemiListing}
\calls{npDefinitionlist}{npQualDef}
\begin{chunk}{defun npDefinitionlist}
(defun |npDefinitionlist| ()
 (|npSemiListing| #'|npQualDef|))

\end{chunk}

\defun{npSemiListing}{npSemiListing}
\calls{npSemiListing}{npListofFun}
\calls{npSemiListing}{npSemiBackSet}
\calls{npSemiListing}{pfAppend}
\begin{chunk}{defun npSemiListing}
(defun |npSemiListing| (p)
 (|npListofFun| p #'|npSemiBackSet| #'|pfAppend|))

\end{chunk}

\defun{npSemiBackSet}{npSemiBackSet}
\calls{npSemiBackSet}{npEqKey}
\begin{chunk}{defun npSemiBackSet}
(defun |npSemiBackSet| ()
 (and (|npEqKey| 'semicolon) (or (|npEqKey| 'backset) t)))

\end{chunk}

\defun{npRule}{npRule}
\calls{npRule}{npEqKey}
\calls{npRule}{npPP}
\calls{npRule}{npSingleRule}
\begin{chunk}{defun npRule}
(defun |npRule| ()
 (and
  (|npEqKey| 'rule)
  (|npPP| #'|npSingleRule|)))

\end{chunk}

\defun{npSingleRule}{npSingleRule}
\calls{npSingleRule}{npQuiver}
\calls{npSingleRule}{npDefTail}
\calls{npSingleRule}{npTrap}
\calls{npSingleRule}{npPush}
\calls{npSingleRule}{pfRule}
\calls{npSingleRule}{npPop2}
\calls{npSingleRule}{npPop1}
\begin{chunk}{defun npSingleRule}
(defun |npSingleRule| ()
 (when (|npQuiver|)
  (or (|npDefTail|) (|npTrap|))
  (|npPush| (|pfRule| (|npPop2|) (|npPop1|)))))

\end{chunk}

\defun{npDefTail}{npDefTail}
\calls{npDefTail}{npEqKey}
\calls{npDefTail}{npDefinitionOrStatement}
\begin{chunk}{defun npDefTail}
(defun |npDefTail| ()
 (and
  (or (|npEqKey| 'def) (|npEqKey| 'mdef))
  (|npDefinitionOrStatement|)))

\end{chunk}

\defun{npDefaultValue}{npDefaultValue}
\calls{npDefaultValue}{npEqKey}
\calls{npDefaultValue}{npDefinitionOrStatement}
\calls{npDefaultValue}{npTrap}
\calls{npDefaultValue}{npPush}
\calls{npDefaultValue}{pfAdd}
\calls{npDefaultValue}{pfNothing}
\calls{npDefaultValue}{npPop1}
\begin{chunk}{defun npDefaultValue}
(defun |npDefaultValue| ()
 (and
  (|npEqKey| 'default)
  (or (|npDefinitionOrStatement|) (|npTrap|))
  (|npPush| (list (|pfAdd| (|pfNothing|) (|npPop1|) (|pfNothing|))))))

\end{chunk}

\defun{npWConditional}{npWConditional}
\calls{npWConditional}{npConditional}
\calls{npWConditional}{npPush}
\calls{npWConditional}{pfTweakIf}
\calls{npWConditional}{npPop1}
\begin{chunk}{defun npWConditional}
(defun |npWConditional| (f)
 (when (|npConditional| f) (|npPush| (|pfTweakIf| (|npPop1|)))))

\end{chunk}

\defun{npConditional}{npConditional}
\calls{npConditional}{npEqKey}
\calls{npConditional}{npLogical}
\calls{npConditional}{npTrap}
\calls{npConditional}{npMissing}
\calls{npConditional}{npElse}
\begin{chunk}{defun npConditional}
(defun |npConditional| (f)
 (cond
  ((and (|npEqKey| 'IF) 
        (or (|npLogical|) (|npTrap|))
        (or (|npEqKey| 'backset) t))
   (cond
    ((|npEqKey| 'settab)
     (cond
      ((|npEqKey| 'then)
       (and (or (apply f nil) (|npTrap|))
            (|npElse| f)
            (|npEqKey| 'backtab)))
      (t (|npMissing| '|then|))))
    ((|npEqKey| 'then)
     (and (or (apply f nil) (|npTrap|)) (|npElse| f)))
    (t (|npMissing| '|then|))))
  (t nil)))

\end{chunk}

\defun{npElse}{npElse}
\calls{npElse}{npState}
\calls{npElse}{npBacksetElse}
\calls{npElse}{npTrap}
\calls{npElse}{npPush}
\calls{npElse}{pfIf}
\calls{npElse}{npPop3}
\calls{npElse}{npPop2}
\calls{npElse}{npPop1}
\calls{npElse}{npRestore}
\calls{npElse}{pfIfThenOnly}
\begin{chunk}{defun npElse}
(defun |npElse| (f) 
 (let (a)
  (setq a (|npState|))
  (cond
   ((|npBacksetElse|)
    (and
     (or (apply f nil) (|npTrap|))
     (|npPush| (|pfIf| (|npPop3|) (|npPop2|) (|npPop1|)))))
   (t
     (|npRestore| a)
     (|npPush| (|pfIfThenOnly| (|npPop2|) (|npPop1|)))))))

\end{chunk}

\defun{npBacksetElse}{npBacksetElse}
\tpdhere{Well this makes no sense.}

\calls{npBacksetElse}{npEqKey}
\begin{chunk}{defun npBacksetElse}
(defun |npBacksetElse| ()
 (if (|npEqKey| 'backset) 
  (|npEqKey| 'else)
  (|npEqKey| 'else)))

\end{chunk}

\defun{npLogical}{npLogical}
\calls{npLogical}{npLeftAssoc}
\calls{npLogical}{npDisjand}
\begin{chunk}{defun npLogical}
(defun |npLogical| () 
 (|npLeftAssoc| '(or) #'|npDisjand|))

\end{chunk}

\defun{npDisjand}{npDisjand}
\calls{npDisjand}{npLeftAssoc}
\calls{npDisjand}{npDiscrim}
\begin{chunk}{defun npDisjand}
(defun |npDisjand| ()
 (|npLeftAssoc| '(and) #'|npDiscrim|))

\end{chunk}

\defun{npDiscrim}{npDiscrim}
\calls{npDiscrim}{npLeftAssoc}
\calls{npDiscrim}{npQuiver}
\begin{chunk}{defun npDiscrim}
(defun |npDiscrim| ()
 (|npLeftAssoc| '(case has) #'|npQuiver|))

\end{chunk}

\defun{npQuiver}{npQuiver}
\calls{npQuiver}{npRightAssoc}
\calls{npQuiver}{npRelation}
\begin{chunk}{defun npQuiver}
(defun |npQuiver| ()
 (|npRightAssoc| '(arrow larrow) #'|npRelation|))

\end{chunk}

\defun{npRelation}{npRelation}
\calls{npRelation}{npLeftAssoc}
\calls{npRelation}{npSynthetic}
\begin{chunk}{defun npRelation}
(defun |npRelation| ()
 (|npLeftAssoc| '(equal notequal lt le gt ge oangle cangle) #'|npSynthetic|))

\end{chunk}

\defun{npSynthetic}{npSynthetic}
\calls{npSynthetic}{npBy}
\calls{npSynthetic}{npAmpersandFrom}
\calls{npSynthetic}{npPush}
\calls{npSynthetic}{pfApplication}
\calls{npSynthetic}{npPop2}
\calls{npSynthetic}{npPop1}
\calls{npSynthetic}{pfInfApplication}
\begin{chunk}{defun npSynthetic}
(defun |npSynthetic| ()
 (cond
  ((|npBy|)
   ((lambda ()
    (loop
     (cond
      ((not (and (|npAmpersandFrom|)
                 (or (|npBy|)
                     (progn
                      (|npPush| (|pfApplication| (|npPop2|) (|npPop1|)))
                      nil))))
         (return nil))
      (t
       (|npPush| (|pfInfApplication| (|npPop2|) (|npPop2|) (|npPop1|))))))))
       t)
  (t nil)))

\end{chunk}

\defun{npBy}{npBy}
\calls{npBy}{npLeftAssoc}
\calls{npBy}{npInterval}
\begin{chunk}{defun npBy}
(defun |npBy| ()
 (|npLeftAssoc| '(by) #'|npInterval|))

\end{chunk}

\defun{npInterval}{}
\calls{npInterval}{npArith}
\calls{npInterval}{npSegment}
\calls{npInterval}{npEqPeek}
\calls{npInterval}{npPush}
\calls{npInterval}{pfApplication}
\calls{npInterval}{npPop1}
\calls{npInterval}{pfInfApplication}
\calls{npInterval}{npPop2}
\begin{chunk}{defun npInterval}
(defun |npInterval| ()
 (and
  (|npArith|)
  (or
   (and
    (|npSegment|)
    (or
     (and
      (|npEqPeek| 'bar)
      (|npPush| (|pfApplication| (|npPop1|) (|npPop1|))))
     (and
      (|npArith|)
      (|npPush| (|pfInfApplication| (|npPop2|) (|npPop2|) (|npPop1|))))
     (|npPush| (|pfApplication| (|npPop1|) (|npPop1|)))))
   t)))

\end{chunk}

\defun{npSegment}{npSegment}
\calls{npSegment}{npEqPeek}
\calls{npSegment}{npPushId}
\calls{npSegment}{npFromdom}
\begin{chunk}{defun npSegment}
(defun |npSegment| ()
 (and (|npEqPeek| 'seg) (|npPushId|) (|npFromdom|)))

\end{chunk}

\defun{npArith}{npArith}
\calls{npArith}{npLeftAssoc}
\calls{npArith}{npSum}
\begin{chunk}{defun npArith}
(defun |npArith| ()
 (|npLeftAssoc| '(mod) #'|npSum|))

\end{chunk}

\defun{npSum}{npSum}
\calls{npSum}{npLeftAssoc}
\calls{npSum}{npTerm}
\begin{chunk}{defun npSum}
(defun |npSum| ()
 (|npLeftAssoc| '(plus minus) #'|npTerm|))

\end{chunk}

\defun{npTerm}{npTerm}
\calls{npTerm}{npInfGeneric}
\calls{npTerm}{npRemainder}
\calls{npTerm}{npPush}
\calls{npTerm}{pfApplication}
\calls{npTerm}{npPop2}
\calls{npTerm}{npPop1}
\begin{chunk}{defun npTerm}
(defun |npTerm| ()
 (or
  (and
   (|npInfGeneric| '(minus plus))
   (or
    (and (|npRemainder|) (|npPush| (|pfApplication| (|npPop2|) (|npPop1|))))
    t))
  (|npRemainder|)))

\end{chunk}

\defun{npRemainder}{npRemainder}
\calls{npRemainder}{npLeftAssoc}
\calls{npRemainder}{npProduct}
\begin{chunk}{defun npRemainder}
(defun |npRemainder| ()
 (|npLeftAssoc| '(rem quo) #'|npProduct|))

\end{chunk}

\defun{npProduct}{npProduct}
\calls{npProduct}{npLeftAssoc}
\calls{npProduct}{npPower}
\begin{chunk}{defun npProduct}
(defun |npProduct| ()
 (|npLeftAssoc|
  '(times slash backslash slashslash backslashbackslash
            slashbackslash backslashslash)
    #'|npPower|))

\end{chunk}

\defun{npPower}{npPower}
\calls{npPower}{npRightAssoc}
\calls{npPower}{npColon}
\begin{chunk}{defun npPower}
(defun |npPower| ()
 (|npRightAssoc| '(power carat) #'|npColon|))

\end{chunk}

\defun{npAmpersandFrom}{npAmpersandFrom}
\calls{npAmpersandFrom}{npAmpersand}
\calls{npAmpersandFrom}{npFromdom}
\begin{chunk}{defun npAmpersandFrom}
(defun |npAmpersandFrom| ()
 (and (|npAmpersand|) (|npFromdom|)))

\end{chunk}

\defun{npFromdom}{npFromdom}
\calls{npFromdom}{npEqKey}
\calls{npFromdom}{npApplication}
\calls{npFromdom}{npTrap}
\calls{npFromdom}{npFromdom1}
\calls{npFromdom}{npPop1}
\calls{npFromdom}{npPush}
\calls{npFromdom}{pfFromDom}
\begin{chunk}{defun npFromdom}
(defun |npFromdom| ()
 (or
  (and
   (|npEqKey| '$)
   (or (|npApplication|) (|npTrap|))
   (|npFromdom1| (|npPop1|))
   (|npPush| (|pfFromDom| (|npPop1|) (|npPop1|))))
  t))

\end{chunk}

\defun{npFromdom1}{npFromdom1}
\calls{npFromdom1}{npEqKey}
\calls{npFromdom1}{npApplication}
\calls{npFromdom1}{npTrap}
\calls{npFromdom1}{npFromdom1}
\calls{npFromdom1}{npPop1}
\calls{npFromdom1}{npPush}
\calls{npFromdom1}{pfFromDom}
\begin{chunk}{defun npFromdom1}
(defun |npFromdom1| (c)
 (or
  (and
   (|npEqKey| '$)
   (or (|npApplication|) (|npTrap|))
   (|npFromdom1| (|npPop1|))
   (|npPush| (|pfFromDom| (|npPop1|) c)))
  (|npPush| c)))

\end{chunk}

\defun{npAmpersand}{npAmpersand}
\calls{npAmpersand}{npEqKey}
\calls{npAmpersand}{npName}
\calls{npAmpersand}{npTrap}
\begin{chunk}{defun npAmpersand}
(defun |npAmpersand| ()
 (and
  (|npEqKey| 'ampersand)
  (or (|npName|) (|npTrap|))))

\end{chunk}

\defun{npName}{npName}
\calls{npName}{npId}
\calls{npName}{npSymbolVariable}
\begin{chunk}{defun npName}
(defun |npName| ()
 (or (|npId|) (|npSymbolVariable|)))

\end{chunk}

\defdollar{npTokToNames}
\begin{chunk}{initvars}
(defvar |$npTokToNames| (list '~ '|#| '[] '{} '|[\|\|]| '|{\|\|}|))

\end{chunk}

\defun{npId}{npId}
\calls{npId}{npPush}
\calls{npId}{npNext}
\calls{npId}{tokConstruct}
\calls{npId}{tokPosn}
\usesdollar{npId}{npTokToNames}
\usesdollar{npId}{ttok}
\usesdollar{npId}{stok}
\begin{chunk}{defun npId}
(defun |npId| ()
 (declare (special |$npTokToNames| |$ttok| |$stok|))
  (cond
   ((eq (caar |$stok|) '|id|)
     (|npPush| |$stok|) 
     (|npNext|))
   ((and (eq (caar |$stok|) '|key|) (member |$ttok| |$npTokToNames|))
     (|npPush| (|tokConstruct| '|id| |$ttok| (|tokPosn| |$stok|)))
     (|npNext|))
   (t nil)))

\end{chunk}

\defun{npSymbolVariable}{npSymbolVariable}
\calls{npSymbolVariable}{npState}
\calls{npSymbolVariable}{npEqKey}
\calls{npSymbolVariable}{npId}
\calls{npSymbolVariable}{npPop1}
\calls{npSymbolVariable}{npPush}
\calls{npSymbolVariable}{tokConstruct}
\calls{npSymbolVariable}{tokPart}
\calls{npSymbolVariable}{tokPosn}
\calls{npSymbolVariable}{npRestore}
\begin{chunk}{defun npSymbolVariable}
(defun |npSymbolVariable| ()
 (let (a)
  (setq a (|npState|))
  (cond
   ((and (|npEqKey| 'backquote) (|npId|))
    (setq a (|npPop1|))
    (|npPush| (|tokConstruct| '|idsy| (|tokPart| a) (|tokPosn| a))))
   (t (|npRestore| a) nil))))

\end{chunk}

\defun{npRightAssoc}{npRightAssoc}
\calls{npRightAssoc}{npState}
\calls{npRightAssoc}{npInfGeneric}
\calls{npRightAssoc}{npRightAssoc}
\calls{npRightAssoc}{npPush}
\calls{npRightAssoc}{pfApplication}
\calls{npRightAssoc}{npPop2}
\calls{npRightAssoc}{npPop1}
\calls{npRightAssoc}{pfInfApplication}
\calls{npRightAssoc}{npRestore}
\begin{chunk}{defun npRightAssoc}
(defun |npRightAssoc| (o p)
 (let (a)
  (setq a (|npState|))
  (cond
   ((apply p nil)
      ((lambda ()
       (loop
        (cond
         ((not
           (and
            (|npInfGeneric| o)
            (or
             (|npRightAssoc| o p)
             (progn (|npPush| (|pfApplication| (|npPop2|) (|npPop1|))) nil))))
          (return nil))
         (t
          (|npPush| (|pfInfApplication| (|npPop2|) (|npPop2|) (|npPop1|))))))))
       t)
   (t 
    (|npRestore| a) 
    nil))))

\end{chunk}

\defun{npLeftAssoc}{p o p o p o p = (((p o p) o p) o p)}
\begin{verbatim}
p o p o p o p = (((p o p) o p) o p)
p o p o = (p o p) o
;npLeftAssoc(operations,parser)==
;    if APPLY(parser,nil)
;    then
;       while npInfGeneric(operations)
;         and (APPLY(parser,nil) or
;              (npPush pfApplication(npPop2(),npPop1());false))
;           repeat
;             npPush pfInfApplication(npPop2(),npPop2(),npPop1())
;       true
;    else false
\end{verbatim}
\calls{npLeftAssoc}{npInfGeneric}
\calls{npLeftAssoc}{npPush}
\calls{npLeftAssoc}{pfApplication}
\calls{npLeftAssoc}{npPop2}
\calls{npLeftAssoc}{npPop1}
\calls{npLeftAssoc}{pfInfApplication}
\begin{chunk}{defun npLeftAssoc}
(defun |npLeftAssoc| (operations parser)
 (when (apply parser nil)
   ((lambda nil
      (loop
       (cond
        ((not
          (and
           (|npInfGeneric| operations)
           (or
            (apply parser nil)
            (progn (|npPush| (|pfApplication| (|npPop2|) (|npPop1|))) nil))))
         (return nil))
        (t
         (|npPush| (|pfInfApplication| (|npPop2|) (|npPop2|) (|npPop1|))))))))
     t))

\end{chunk}

\defun{npInfGeneric}{npInfGeneric}
\calls{npInfGeneric}{npDDInfKey}
\calls{npInfGeneric}{npEqKey}
\begin{chunk}{defun npInfGeneric}
(defun |npInfGeneric| (s)
 (and
  (|npDDInfKey| s)
  (or (|npEqKey| 'backset) t)))

\end{chunk}

\defun{npDDInfKey}{npDDInfKey}
\calls{npDDInfKey}{npInfKey}
\calls{npDDInfKey}{npState}
\calls{npDDInfKey}{npEqKey}
\calls{npDDInfKey}{npPush}
\calls{npDDInfKey}{pfSymb}
\calls{npDDInfKey}{npPop1}
\calls{npDDInfKey}{tokPosn}
\calls{npDDInfKey}{npRestore}
\calls{npDDInfKey}{tokConstruct}
\calls{npDDInfKey}{tokPart}
\usesdollar{npDDInfKey}{stok}
\begin{chunk}{defun npDDInfKey}
(defun |npDDInfKey| (s)
 (let (b a)
 (declare (special |$stok|))
  (or
   (|npInfKey| s)
   (progn
    (setq a (|npState|))
    (setq b |$stok|)
    (cond
     ((and (|npEqKey| '|'|) (|npInfKey| s))
       (|npPush| (|pfSymb| (|npPop1|) (|tokPosn| b))))
     (t
      (|npRestore| a)
      (cond
       ((and (|npEqKey| 'backquote) (|npInfKey| s))
         (setq a (|npPop1|))
          (|npPush| (|tokConstruct| '|idsy| (|tokPart| a) (|tokPosn| a))))
       (t 
        (|npRestore| a) 
        nil))))))))

\end{chunk}

\defun{npInfKey}{npInfKey}
\calls{npInfKey}{npPushId}
\usesdollar{npInfKey}{stok}
\usesdollar{npInfKey}{ttok}
\begin{chunk}{defun npInfKey}
(defun |npInfKey| (s)
 (declare (special |$ttok| |$stok|))
  (and (eq (caar |$stok|) '|key|) (member |$ttok| s) (|npPushId|)))

\end{chunk}

\defun{npPushId}{npPushId}
\calls{npPushId}{tokConstruct}
\calls{npPushId}{tokPosn}
\calls{npPushId}{npNext}
\usesdollar{npPushId}{stack}
\usesdollar{npPushId}{stok}
\usesdollar{npPushId}{ttok}
\begin{chunk}{defun npPushId}
(defun |npPushId| ()
 (let (a)
 (declare (special |$stack| |$stok| |$ttok|))
  (setq a (get |$ttok| 'infgeneric))
  (when a (setq |$ttok| a))
  (setq |$stack|
   (cons (|tokConstruct| '|id| |$ttok| (|tokPosn| |$stok|)) |$stack|))
  (|npNext|)))

\end{chunk}

\defvar{npPParg}
\begin{chunk}{initvars}
(defvar *npPParg* nil "rewrite npPP without flets, using global scoping")

\end{chunk}

\defun{npPP}{npPP}
This was rewritten by NAG to remove flet.

\calls{npPP}{npParened}
\calls{npPP}{npPPf}
\calls{npPP}{npPileBracketed}
\calls{npPP}{npPPg}
\calls{npPP}{npPush}
\calls{npPP}{pfEnSequence}
\calls{npPP}{npPop1}
\uses{npPP}{npPParg}
\begin{chunk}{defun npPP}
(defun |npPP| (f)
 (declare (special *npPParg*))
  (setq *npPParg* f)
  (or 
   (|npParened| #'npPPf)
   (and  (|npPileBracketed| #'npPPg) (|npPush| (|pfEnSequence| (|npPop1|))))
   (funcall f)))

\end{chunk}

\defun{npPPff}{npPPff}
\calls{npPPff}{npPop1}
\calls{npPPff}{npPush}
\usesdollar{npPPff}{npPParg}
\begin{chunk}{defun npPPff}
(defun npPPff ()
 (and (funcall *npPParg*) (|npPush| (list (|npPop1|)))))

\end{chunk}

\defun{npPPg}{npPPg}
\calls{npPPg}{npListAndRecover}
\calls{npPPg}{npPPf}
\calls{npPPg}{npPush}
\calls{npPPg}{pfAppend}
\calls{npPPg}{npPop1}
\begin{chunk}{defun npPPg}
(defun npPPg () 
 (and (|npListAndRecover| #'npPPf))
 (|npPush| (|pfAppend| (|npPop1|))))

\end{chunk}

\defun{npPPf}{npPPf}
\calls{npPPf}{npSemiListing}
\calls{npPPf}{npPPff}
\begin{chunk}{defun npPPf}
(defun npPPf ()
 (|npSemiListing| #'npPPff))

\end{chunk}

\defun{npEnclosed}{npEnclosed}
\calls{npEnclosed}{npEqKey}
\calls{npEnclosed}{npPush}
\calls{npEnclosed}{pfTuple}
\calls{npEnclosed}{pfListOf}
\calls{npEnclosed}{npMissingMate}
\calls{npEnclosed}{pfEnSequence}
\calls{npEnclosed}{npPop1}
\usesdollar{npEnclosed}{stok}
\begin{chunk}{defun npEnclosed}
(defun |npEnclosed| (open close fn f)
 (let (a)
 (declare (special |$stok|))
  (setq a |$stok|)
  (when (|npEqKey| open)
   (cond
    ((|npEqKey| close)
     (|npPush| (funcall fn a (|pfTuple| (|pfListOf| NIL)))))
    ((and (apply f nil)
          (or (|npEqKey| close)
              (|npMissingMate| close a)))
     (|npPush| (funcall fn a (|pfEnSequence| (|npPop1|)))))
    ('t nil)))))

\end{chunk}

\defun{npState}{npState}
\usesdollar{npState}{stack}
\usesdollar{npState}{inputStream}
\begin{chunk}{defun npState}
(defun |npState| ()
 (declare (special |$stack| |$inputStream|))
  (cons |$inputStream| |$stack|))

\end{chunk}

\defun{npTrap}{npTrap}
\throws{npTrap}{trappoint}
\calls{npTrap}{tokPosn}
\calls{npTrap}{ncSoftError}
\usesdollar{npTrap}{stok}
\begin{chunk}{defun npTrap}
(defun |npTrap| ()
 (declare (special |$stok|))
  (|ncSoftError| (|tokPosn| |$stok|) " Improper syntax." nil)
  (throw 'trappoint 'trapped))

\end{chunk}

\defun{npTrapForm}{npTrapForm}
\throws{npTrapForm}{trappoint}
\calls{npTrapForm}{pfSourceStok}
\calls{npTrapForm}{syGeneralErrorHere}
\calls{npTrapForm}{ncSoftError}
\calls{npTrapForm}{tokPosn}
\begin{chunk}{defun npTrapForm}
(defun |npTrapForm| (x)
 (let (a)
  (setq a (|pfSourceStok| x))
  (cond
   ((eq a '|NoToken|)
     (|syGeneralErrorHere|) 
     (throw 'trappoint 'trapped))
   (t
    (|ncSoftError| (|tokPosn| a) " Improper syntax." nil)
    (throw 'trappoint 'trapped)))))

\end{chunk}

\defun{npVariable}{npVariable}
\calls{npVariable}{npParenthesized}
\calls{npVariable}{npVariablelist}
\calls{npVariable}{npVariableName}
\calls{npVariable}{npPush}
\calls{npVariable}{pfListOf}
\calls{npVariable}{npPop1}
\begin{chunk}{defun npVariable}
(defun |npVariable| ()
 (or
  (|npParenthesized| #'|npVariablelist|)
  (and (|npVariableName|) (|npPush| (|pfListOf| (list (|npPop1|)))))))

\end{chunk}

\defun{npVariablelist}{npVariablelist}
\calls{npVariablelist}{npListing}
\calls{npVariablelist}{npVariableName}
\begin{chunk}{defun npVariablelist}
(defun |npVariablelist| ()
 (|npListing| #'|npVariableName|))

\end{chunk}

\defun{npVariableName}{npVariableName}
\calls{npVariableName}{npName}
\calls{npVariableName}{npDecl}
\calls{npVariableName}{npPush}
\calls{npVariableName}{pfTyped}
\calls{npVariableName}{npPop1}
\calls{npVariableName}{pfNothing}
\begin{chunk}{defun npVariableName}
(defun |npVariableName| ()
 (and
  (|npName|)
  (or (|npDecl|) (|npPush| (|pfTyped| (|npPop1|) (|pfNothing|))))))

\end{chunk}

\defun{npDecl}{npDecl}
\calls{npDecl}{npEqKey}
\calls{npDecl}{npType}
\calls{npDecl}{npTrap}
\calls{npDecl}{npPush}
\calls{npDecl}{pfTyped}
\calls{npDecl}{npPop2}
\calls{npDecl}{npPop1}
\begin{chunk}{defun npDecl}
(defun |npDecl| ()
 (and
  (|npEqKey| 'colon)
  (or (|npType|) (|npTrap|))
  (|npPush| (|pfTyped| (|npPop2|) (|npPop1|)))))

\end{chunk}

\defun{npParenthesized}{npParenthesized}
\calls{npParenthesized}{npParenthesize}
\begin{chunk}{defun npParenthesized}
(defun |npParenthesized| (f)
 (or (|npParenthesize| '|(| '|)| f) (|npParenthesize| '|(\|| '|\|)| f)))

\end{chunk}

\defun{npParenthesize}{npParenthesize}
\calls{npParenthesize}{npEqKey}
\calls{npParenthesize}{npMissingMate}
\calls{npParenthesize}{npPush}
\usesdollar{npParenthesize}{stok}
\begin{chunk}{defun npParenthesize}
(defun |npParenthesize| (open close f)
 (let (a)
 (declare (special |$stok|))
  (setq a |$stok|)
  (cond
   ((|npEqKey| open)
    (cond
     ((and (apply f nil)
           (or (|npEqKey| close)
               (|npMissingMate| close a)))
      t)
     ((|npEqKey| close) (|npPush| nil))
     (t (|npMissingMate| close a))))
   (t nil))))

\end{chunk}

\defun{npMissingMate}{npMissingMate}
\calls{npMissingMate}{ncSoftError}
\calls{npMissingMate}{tokPosn}
\calls{npMissingMate}{npMissing}
\begin{chunk}{defun npMissingMate}
(defun |npMissingMate| (close open)
 (|ncSoftError| (|tokPosn| open) "Missing mate." nil)
 (|npMissing| close))

\end{chunk}

\defun{npExit}{npExit}
\calls{npExit}{npBackTrack}
\calls{npExit}{npAssign}
\calls{npExit}{npPileExit}
\begin{chunk}{defun npExit}
(defun |npExit| ()
 (|npBackTrack| #'|npAssign| 'exit #'|npPileExit|))

\end{chunk}

\defun{npPileExit}{npPileExit}
\calls{npPileExit}{npAssign}
\calls{npPileExit}{npEqKey}
\calls{npPileExit}{npStatement}
\calls{npPileExit}{npPush}
\calls{npPileExit}{pfExit}
\calls{npPileExit}{npPop2}
\calls{npPileExit}{npPop1}
\begin{chunk}{defun npPileExit}
(defun |npPileExit| ()
 (and
  (|npAssign|)
  (or (|npEqKey| 'exit) (|npTrap|))
  (or (|npStatement|) (|npTrap|))
  (|npPush| (|pfExit| (|npPop2|) (|npPop1|)))))

\end{chunk}

\defun{npAssign}{npAssign}
\calls{npAssign}{npBackTrack}
\calls{npAssign}{npMDEF}
\calls{npAssign}{npAssignment}
\begin{chunk}{defun npAssign}
(defun |npAssign| ()
 (|npBackTrack| #'|npMDEF| 'becomes #'|npAssignment|))

\end{chunk}

\defun{npAssignment}{npAssignment}
\calls{npAssignment}{npAssignVariable}
\calls{npAssignment}{npEqKey}
\calls{npAssignment}{npTrap}
\calls{npAssignment}{npGives}
\calls{npAssignment}{npPush}
\calls{npAssignment}{pfAssign}
\calls{npAssignment}{npPop2}
\calls{npAssignment}{npPop1}
\begin{chunk}{defun npAssignment}
(defun |npAssignment| ()
 (and
  (|npAssignVariable|)
  (or (|npEqKey| 'becomes) (|npTrap|))
  (or (|npGives|) (|npTrap|))
  (|npPush| (|pfAssign| (|npPop2|) (|npPop1|)))))

\end{chunk}

\defun{npAssignVariable}{npAssignVariable}
\calls{npAssignVariable}{npColon}
\calls{npAssignVariable}{npPush}
\calls{npAssignVariable}{pfListOf}
\calls{npAssignVariable}{npPop1}
\begin{chunk}{defun npAssignVariable}
(defun |npAssignVariable| () 
 (and (|npColon|) (|npPush| (|pfListOf| (list (|npPop1|))))))

\end{chunk}

\defun{npColon}{npColon}
\calls{npColon}{npTypified}
\calls{npColon}{npAnyNo}
\calls{npColon}{npTagged}
\begin{chunk}{defun npColon}
(defun |npColon| ()
 (and (|npTypified|) (|npAnyNo| #'|npTagged|)))

\end{chunk}

\defun{npTagged}{npTagged}
\calls{npTagged}{npTypedForm1}
\calls{npTagged}{pfTagged}
\begin{chunk}{defun npTagged}
(defun |npTagged| ()
 (|npTypedForm1| 'colon #'|pfTagged|))

\end{chunk}

\defun{npTypedForm1}{npTypedForm1}
\calls{npTypedForm1}{npEqKey}
\calls{npTypedForm1}{npType}
\calls{npTypedForm1}{npTrap}
\calls{npTypedForm1}{npPush}
\calls{npTypedForm1}{npPop2}
\calls{npTypedForm1}{npPop1}
\begin{chunk}{defun npTypedForm1}
(defun |npTypedForm1| (sy fn)
 (and
  (|npEqKey| sy)
  (or (|npType|) (|npTrap|))
  (|npPush| (funcall fn (|npPop2|) (|npPop1|)))))

\end{chunk}

\defun{npTypified}{npTypified}
\calls{npTypified}{npApplication}
\calls{npTypified}{npAnyNo}
\calls{npTypified}{npTypeStyle}
\begin{chunk}{defun npTypified}
(defun |npTypified| ()
 (and (|npApplication|) (|npAnyNo| #'|npTypeStyle|)))

\end{chunk}

\defun{npTypeStyle}{npTypeStyle}
\calls{npTypeStyle}{npCoerceTo}
\calls{npTypeStyle}{npRestrict}
\calls{npTypeStyle}{npPretend}
\calls{npTypeStyle}{npColonQuery}
\begin{chunk}{defun npTypeStyle}
(defun |npTypeStyle| ()
 (or (|npCoerceTo|) (|npRestrict|) (|npPretend|) (|npColonQuery|)))

\end{chunk}

\defun{npPretend}{npPretend}
\calls{npPretend}{npTypedForm}
\calls{npPretend}{pfPretend}
\begin{chunk}{defun npPretend}
(defun |npPretend| ()
 (|npTypedForm| 'pretend #'|pfPretend|))

\end{chunk}

\defun{npColonQuery}{npColonQuery}
\calls{npColonQuery}{npTypedForm}
\calls{npColonQuery}{pfRetractTo}
\begin{chunk}{defun npColonQuery}
(defun |npColonQuery| ()
 (|npTypedForm| 'atat #'|pfRetractTo|))

\end{chunk}

\defun{npCoerceTo}{npCoerceTo}
\calls{npCoerceTo}{npTypedForm}
\calls{npCoerceTo}{pfCoerceto}
\begin{chunk}{defun npCoerceTo}
(defun |npCoerceTo| ()
 (|npTypedForm| 'coerce #'|pfCoerceto|))

\end{chunk}

\defun{npTypedForm}{npTypedForm}
\calls{npTypedForm}{npEqKey}
\calls{npTypedForm}{npApplication}
\calls{npTypedForm}{npTrap}
\calls{npTypedForm}{npPush}
\calls{npTypedForm}{npPop2}
\calls{npTypedForm}{npPop1}
\begin{chunk}{defun npTypedForm}
(defun |npTypedForm| (sy fn)
 (and
  (|npEqKey| sy)
  (or (|npApplication|) (|npTrap|))
  (|npPush| (funcall fn (|npPop2|) (|npPop1|)))))

\end{chunk}

\defun{npRestrict}{npRestrict}
\calls{npRestrict}{npTypedForm}
\calls{npRestrict}{pfRestrict}
\begin{chunk}{defun npRestrict}
(defun |npRestrict| ()
 (|npTypedForm| 'at #'|pfRestrict|))

\end{chunk}

\defun{npListofFun}{npListofFun}
\calls{npListofFun}{npTrap}
\calls{npListofFun}{npPush}
\calls{npListofFun}{npPop3}
\calls{npListofFun}{npPop2}
\calls{npListofFun}{npPop1}
\usesdollar{npListofFun}{stack}
\begin{chunk}{defun npListofFun}
(defun |npListofFun| (f h g)
 (let (a)
 (declare (special |$stack|))
  (cond
   ((apply f nil)
    (cond
     ((and (apply h nil) (or (apply f nil) (|npTrap|)))
       (setq a |$stack|) 
       (setq |$stack| nil)
       (do ()
           ((not (and (apply h nil)
                 (or (apply f nil) (|npTrap|))))))
       (setq |$stack| (cons (nreverse |$stack|) a))
       (|npPush| (funcall g (cons (|npPop3|) (cons (|npPop2|) (|npPop1|))))))
     (t t)))
   (t nil))))

\end{chunk}

\section{Functions on interpreter objects}
Interpreter objects used to be called triples because they had the
structure [value, type, environment].  For many years, the environment
was not used, so finally in January, 1990, the structure of objects
was changed to be (type . value).  This was chosen because it was the
structure of objects of type Any.  Sometimes the values are wrapped
(see the function isWrapped to see what this means physically).
Wrapped values are not actual values belonging to their types.  An
unwrapped value must be evaluated to get an actual value.  A wrapped
value must be unwrapped before being passed to a library function.
Typically, an unwrapped value in the interpreter consists of LISP
code, e.g., parts of a function that is being constructed.
--  RSS 1/14/90

These are the new structure functions.

\begin{center}
\includegraphics{ps/v5mkObj.eps}\\
{\bf {\Large Object representation}}
\end{center}

\defmacro{mkObj}
\begin{chunk}{defmacro mkObj}
(defmacro mkObj (val mode)
 `(cons ,mode ,val)) 

\end{chunk}

\begin{center}
\includegraphics{ps/v5mkObjWrap.eps}\\
{\bf {\Large Object representation}}
\end{center}

\defmacro{mkObjWrap}
\calls{mkObjWrap}{wrap}
\begin{chunk}{defmacro mkObjWrap}
(defmacro mkObjWrap (val mode)
 `(cons ,mode (|wrap| ,val))) 

\end{chunk}

\defmacro{mkObjCode}
\begin{chunk}{defmacro mkObjCode}
(defmacro mkObjCode (val mode)
 `(cons 'cons (cons (mkq ,mode) (cons ,val nil)))) 

\end{chunk}

\defmacro{objSetVal}
\begin{chunk}{defmacro objSetVal}
(defmacro |objSetVal| (obj val)
 `(rplacd ,obj ,val)) 

\end{chunk}

\defmacro{objSetMode}
\begin{chunk}{defmacro objSetMode}
(defmacro |objSetMode| (obj mode)
 `(rplaca ,obj ,mode)) 

\end{chunk}

\defmacro{objVal}
\begin{chunk}{defmacro objVal}
(defmacro |objVal| (obj)
 `(cdr ,obj)) 

\end{chunk}

\defmacro{objValUnwrap}
\begin{chunk}{defmacro objValUnwrap}
(defmacro |objValUnwrap| (obj)
 `(|unwrap| (cdr ,obj))) 

\end{chunk}

\defmacro{objMode}
\begin{chunk}{defmacro objMode}
(defmacro |objMode| (obj)
 `(car ,obj)) 

\end{chunk}

\defun{objEnv}{objEnv}
\begin{chunk}{defun objEnv 0}
(defun |objEnv| (obj)
 (declare (special $NE) (ignore obj))
 $NE) 

\end{chunk}

\defmacro{objCodeVal}
\begin{chunk}{defmacro objCodeVal}
(defmacro |objCodeVal| (obj)
 `(caddr ,obj)) 

\end{chunk}

\defmacro{objCodeMode}
\begin{chunk}{defmacro objCodeMode}
(defmacro |objCodeMode| (obj)
 `(cadr ,obj)) 

\end{chunk}

\section{Macro handling}
\defun{phMacro}{phMacro}
\tpdhere{The pform function has a leading percent sign}
\begin{verbatim}
carrier[ptree,...] -> carrier[ptree, ptreePremacro,...]
\end{verbatim}
\calls{phMacro}{ncEltQ}
\calls{phMacro}{ncPutQ}
\calls{phMacro}{macroExpanded}
\calls{phMacro}{pform}
\begin{chunk}{defun phMacro}
(defun |phMacro| (carrier)
 (let (ptree)
  (setq ptree (|ncEltQ| carrier '|ptree|))
  (|ncPutQ| carrier '|ptreePremacro| ptree)
  (setq ptree (|macroExpanded| ptree))
  (|ncPutQ| carrier '|ptree| ptree)
  'ok))

\end{chunk}

\defun{macroExpanded}{macroExpanded}
\$macActive is a list of the bodies being expanded.
\$posActive is a list of the parse forms where the bodies came from.
\calls{macroExpanded}{macExpand}
\usesdollar{macroExpanded}{posActive}
\usesdollar{macroExpanded}{macActive}
\begin{chunk}{defun macroExpanded}
(defun |macroExpanded| (pf)
 (let (|$posActive| |$macActive|)
 (declare (special |$posActive| |$macActive|))
  (setq |$macActive| nil)
  (setq |$posActive| nil)
  (|macExpand| pf)))

\end{chunk}

\defun{macExpand}{macExpand}
\calls{macExpand}{pfWhere?}
\calls{macExpand}{macWhere}
\calls{macExpand}{pfLambda?}
\calls{macExpand}{macLambda}
\calls{macExpand}{pfMacro?}
\calls{macExpand}{macMacro}
\calls{macExpand}{pfId?}
\calls{macExpand}{macId}
\calls{macExpand}{pfApplication?}
\calls{macExpand}{macApplication}
\calls{macExpand}{pfMapParts}
\calls{macExpand}{macExpand}
\begin{chunk}{defun macExpand}
(defun |macExpand| (pf)
 (cond
  ((|pfWhere?| pf)       (|macWhere| pf))
  ((|pfLambda?| pf)      (|macLambda| pf))
  ((|pfMacro?| pf)       (|macMacro| pf))
  ((|pfId?| pf)          (|macId| pf))
  ((|pfApplication?| pf) (|macApplication| pf))
  (t                     (|pfMapParts| #'|macExpand| pf))))

\end{chunk}

\defun{macApplication}{macApplication}
\calls{macApplication}{pfMapParts}
\calls{macApplication}{macExpand}
\calls{macApplication}{pfApplicationOp}
\calls{macApplication}{pfMLambda?}
\calls{macApplication}{pf0ApplicationArgs}
\calls{macApplication}{mac0MLambdaApply}
\usesdollar{macApplication}{pfMacros}
\begin{chunk}{defun macApplication}
(defun |macApplication| (pf)
 (let (args op)
 (declare (special |$pfMacros|))
  (setq pf (|pfMapParts| #'|macExpand| pf))
  (setq op (|pfApplicationOp| pf))
  (cond
   ((null (|pfMLambda?| op)) pf)
   (t
    (setq args (|pf0ApplicationArgs| pf))
    (|mac0MLambdaApply| op args pf |$pfMacros|)))))

\end{chunk}

\defun{mac0MLambdaApply}{mac0MLambdaApply}
\tpdhere{The pform function has a leading percent sign. fix this}

\calls{mac0MLambdaApply}{pf0MLambdaArgs}
\calls{mac0MLambdaApply}{pfMLambdaBody}
\calls{mac0MLambdaApply}{pfSourcePosition}
\calls{mac0MLambdaApply}{ncHardError}
\calls{mac0MLambdaApply}{pfId?}
\calls{mac0MLambdaApply}{pform}
\calls{mac0MLambdaApply}{mac0Define}
\calls{mac0MLambdaApply}{mac0ExpandBody}
\usesdollar{mac0MLambdaApply}{pfMacros}
\usesdollar{mac0MLambdaApply}{posActive}
\usesdollar{mac0MLambdaApply}{macActive}
\begin{chunk}{defun mac0MLambdaApply}
(defun |mac0MLambdaApply| (mlambda args opf |$pfMacros|)
 (declare (special |$pfMacros|))
 (let (pos body params)
 (declare (special |$posActive| |$macActive|))
  (setq params (|pf0MLambdaArgs| mlambda))
  (setq body (|pfMLambdaBody| mlambda))
  (cond
   ((not (eql (length args) (length params)))
    (setq pos (|pfSourcePosition| opf))
    (|ncHardError| pos "Expected %1 arguments, but received %2."
      (list (length params) (length args))))
   (t
    ((lambda (parms p arrgs a) ; for p in params for a in args repeat
     (loop
      (cond
       ((or (atom parms)
            (progn (setq p (car parms)) nil)
            (atom arrgs)
            (progn (setq a (CAR arrgs)) nil))
         (return nil))
       (t
        (cond
         ((null (|pfId?| p))
          (setq pos (|pfSourcePosition| opf))
          (|ncHardError| pos "Macro parameter %1f is not an id." 
            (list (|%pform| p))))
         (t
          (|mac0Define| (|pfIdSymbol| p) '|mparam| a)))))
      (setq parms (cdr parms))
      (setq arrgs (cdr arrgs))))
     params nil args nil)
    (|mac0ExpandBody| body opf |$macActive| |$posActive|)))))

\end{chunk}

\defun{mac0ExpandBody}{mac0ExpandBody}
\calls{mac0ExpandBody}{pfSourcePosition}
\calls{mac0ExpandBody}{mac0InfiniteExpansion}
\calls{mac0ExpandBody}{macExpand}
\usesdollar{mac0ExpandBody}{posActive}
\usesdollar{mac0ExpandBody}{macActive}
\begin{chunk}{defun mac0ExpandBody}
(defun |mac0ExpandBody| (body opf |$macActive| |$posActive|)
 (declare (special |$macActive| |$posActive|))
 (let (posn pf)
  (cond
   ((member body |$macActive|)
    (setq pf (cadr |$posActive|))
    (setq posn (|pfSourcePosition| pf))
    (|mac0InfiniteExpansion| posn body |$macActive|))
   (t
    (setq |$macActive| (cons body |$macActive|))
    (setq |$posActive| (cons opf |$posActive|))
    (|macExpand| body)))))

\end{chunk}

\defun{mac0InfiniteExpansion}{mac0InfiniteExpansion}
\tpdhere{The pform function has a leading percent sign. fix this}

\calls{mac0InfiniteExpansion}{mac0InfiniteExpansion,name}
\calls{mac0InfiniteExpansion}{ncSoftError}
\calls{mac0InfiniteExpansion}{pform}
\begin{chunk}{defun mac0InfiniteExpansion}
(defun |mac0InfiniteExpansion| (posn body active)
 (let (rnames fname tmp1 blist result)
  (setq blist (cons body active))
  (setq tmp1 (mapcar #'|mac0InfiniteExpansion,name| blist))
  (setq fname (car tmp1)) ;[fname, :rnames] := [name b for b in blist] 
  (setq rnames (cdr tmp1))
  (|ncSoftError| posn
   "noRep Cycle in macro expansion: %l %1y %2 %l.  Left as: %3f"
   (list
    (dolist (n (reverse rnames) (nreverse result))
      (setq result (append (reverse (list n "==>")) result)))
    fname (|%pform| body)))
  body))

\end{chunk}

\defun{mac0InfiniteExpansion,name}{mac0InfiniteExpansion,name}
\calls{mac0InfiniteExpansion,name}{mac0GetName}
\calls{mac0InfiniteExpansion,name}{pname}
\begin{chunk}{defun mac0InfiniteExpansion,name 0}
(defun |mac0InfiniteExpansion,name| (b)
 (let (st sy got)
  (setq got (|mac0GetName| b))
  (cond
   ((null got) "???")
   (t
    (setq sy (car got))
    (setq st (cadr got))
    (if (eq st '|mlambda|) 
     (concat (pname sy) "(...)")
     (pname sy))))))

\end{chunk}

\defun{mac0GetName}{mac0GetName}
Returns [state, body] or NIL.
Returns [sy, state] or NIL.

\calls{mac0GetName}{pfMLambdaBody}
\usesdollar{mac0GetName}{pfMacros}
\begin{chunk}{defun mac0GetName}
(defun |mac0GetName| (body)
 (let (bd tmp1 st tmp2 sy name)
 (declare (special |$pfMacros|))
 ; for [sy,st,bd] in $pfMacros while not name repeat
  ((lambda (macros tmplist)
   (loop
    (cond
     ((or (atom macros)
          (progn (setq tmplist (car macros)) nil)
          name)
       (return nil))
     (t
      (and (consp tmplist)
           (progn
            (setq sy (car tmplist))
            (setq tmp2 (cdr tmplist))
            (and (consp tmp2)
                 (progn
                  (setq st (car tmp2))
                  (setq tmp1 (cdr tmp2))
                  (and (consp tmp1)
                       (eq (cdr tmp1) nil)
                       (progn
                        (setq bd (car tmp1))
                        t)))))
           (progn
            (when (eq st '|mlambda|) (setq bd (|pfMLambdaBody| bd)))
            (when (eq bd body) (setq name (list sy st)))))))
           (setq macros (cdr macros))))
         |$pfMacros| nil)
        name))

\end{chunk}

\defun{macId}{macId}
\calls{macId}{pfIdSymbol}
\calls{macId}{mac0Get}
\calls{macId}{pfCopyWithPos}
\calls{macId}{pfSourcePosition}
\calls{macId}{mac0ExpandBody}
\usesdollar{macId}{posActive}
\usesdollar{macId}{macActive}
\begin{chunk}{defun macId}
(defun |macId| (pf)
 (let (body state got sy)
 (declare (special |$posActive| |$macActive|))
  (setq sy (|pfIdSymbol| pf))
  (cond
   ((null (setq got (|mac0Get| sy))) pf)
   (t
    (setq state (car got))
    (setq body (cadr got))
    (cond
     ((eq state '|mparam|) body)
     ((eq state '|mlambda|) (|pfCopyWithPos| body (|pfSourcePosition| pf)))
     (t
      (|pfCopyWithPos|
       (|mac0ExpandBody| body pf |$macActive| |$posActive|)
       (|pfSourcePosition| pf))))))))

\end{chunk}

\defun{mac0Get}{mac0Get}
\calls{mac0Get}{ifcdr}
\usesdollar{mac0Get}{pfMacros}
\begin{chunk}{defun mac0Get}
(defun |mac0Get| (sy)
 (declare (special |$pfMacros|))
 (ifcdr (assoc sy |$pfMacros|)))

\end{chunk}

\defun{macWhere}{macWhere}
\calls{macWhere}{macWhere,mac}
\usesdollar{macWhere}{pfMacros}
\begin{chunk}{defun macWhere}
(defun |macWhere| (pf)
 (declare (special |$pfMacros|))
 (|macWhere,mac| pf |$pfMacros|))

\end{chunk}

\defun{macWhere,mac}{macWhere,mac}
\calls{macWhere,mac}{pfMapParts}
\calls{macWhere,mac}{macExpand}
\usesdollar{macWhere,mac}{pfMacros}
\begin{chunk}{defun macWhere,mac}
(defun |macWhere,mac| (pf |$pfMacros|)
 (declare (special |$pfMacros|))
 (|pfMapParts| #'|macExpand| pf))

\end{chunk}

\defun{macLambda}{macLambda}
\calls{macLambda}{macLambda,mac}
\usesdollar{macLambda}{pfMacros}
\begin{chunk}{defun macLambda}
(defun |macLambda| (pf)
 (declare (special |$pfMacros|))
 (|macLambda,mac| pf |$pfMacros|))

\end{chunk}

\defun{macLambda,mac}{macLambda,mac}
\calls{macLambda,mac}{pfMapParts}
\calls{macLambda,mac}{macExpand}
\usesdollar{macLambda,mac}{pfMacros}
\begin{chunk}{defun macLambda,mac}
(defun |macLambda,mac| (pf |$pfMacros|)
 (declare (special |$pfMacros|))
 (|pfMapParts| #'|macExpand| pf))

\end{chunk}

\defun{macMacro}{Add appropriate definition the a Macro pform}
This function adds the definition and returns
the original Macro pform.
\tpdhere{The pform function has a leading percent sign. fix this}
\calls{macMacro}{pfMacroLhs}
\calls{macMacro}{pfMacroRhs}
\calls{macMacro}{pfId?}
\calls{macMacro}{ncSoftError}
\calls{macMacro}{pfSourcePosition}
\calls{macMacro}{pfIdSymbol}
\calls{macMacro}{mac0Define}
\calls{macMacro}{pform}
\calls{macMacro}{pfMLambda?}
\calls{macMacro}{macSubstituteOuter}
\calls{macMacro}{pfNothing?}
\calls{macMacro}{pfMacro}
\calls{macMacro}{pfNothing}
\begin{chunk}{defun macMacro}
(defun |macMacro| (pf)
 (let (sy rhs lhs)
  (setq lhs (|pfMacroLhs| pf))
  (setq rhs (|pfMacroRhs| pf))
  (cond
   ((null (|pfId?| lhs))
    (|ncSoftError| (|pfSourcePosition| lhs) 
     "%1 is improper for macro definition.  Ignored."
     (list (|%pform| lhs)))
    pf)
   (t
    (setq sy (|pfIdSymbol| lhs))
    (|mac0Define| sy
     (cond
      ((|pfMLambda?| rhs) '|mlambda|)
      (t '|mbody|))
     (|macSubstituteOuter| rhs))
     (cond
      ((|pfNothing?| rhs) pf)
      (t (|pfMacro| lhs (|pfNothing|))))))))

\end{chunk}

\defun{mac0Define}{Add a macro to the global pfMacros list}
\usesdollar{mac0Define}{pfMacros}
\begin{chunk}{defun mac0Define 0}
(defun |mac0Define| (sy state body)
 (declare (special |$pfMacros|))
  (setq |$pfMacros| (cons (list sy state body) |$pfMacros|)))

\end{chunk}

\defun{macSubstituteOuter}{macSubstituteOuter}
\calls{macSubstituteOuter}{mac0SubstituteOuter}
\calls{macSubstituteOuter}{macLambdaParameterHandling}
\begin{chunk}{defun macSubstituteOuter}
(defun |macSubstituteOuter| (pform)
 (|mac0SubstituteOuter| (|macLambdaParameterHandling| nil pform) pform))

\end{chunk}

\defun{mac0SubstituteOuter}{mac0SubstituteOuter}
\calls{mac0SubstituteOuter}{pfId?}
\calls{mac0SubstituteOuter}{macSubstituteId}
\calls{mac0SubstituteOuter}{pfLeaf?}
\calls{mac0SubstituteOuter}{pfLambda?}
\calls{mac0SubstituteOuter}{macLambdaParameterHandling}
\calls{mac0SubstituteOuter}{mac0SubstituteOuter}
\calls{mac0SubstituteOuter}{pfParts}
\begin{chunk}{defun mac0SubstituteOuter}
(defun |mac0SubstituteOuter| (replist pform)
 (let (tmplist)
  (cond
   ((|pfId?| pform) (|macSubstituteId| replist pform))
   ((|pfLeaf?| pform) pform)
   ((|pfLambda?| pform)
    (setq tmplist (|macLambdaParameterHandling| replist pform))
    (dolist (p (|pfParts| pform)) (|mac0SubstituteOuter| tmplist p))
    pform)
   (t
    (dolist (p (|pfParts| pform)) (|mac0SubstituteOuter| replist p))
    pform))))
   
\end{chunk}

\defun{macLambdaParameterHandling}{macLambdaParameterHandling}
\calls{macLambdaParameterHandling}{pfLeaf?}
\calls{macLambdaParameterHandling}{pfLambda?}
\calls{macLambdaParameterHandling}{pfTypedId}
\calls{macLambdaParameterHandling}{pf0LambdaArgs}
\calls{macLambdaParameterHandling}{pfIdSymbol}
\calls{macLambdaParameterHandling}{pfMLambda?}
\calls{macLambdaParameterHandling}{pf0MLambdaArgs}
\calls{macLambdaParameterHandling}{pfLeaf}
\calls{macLambdaParameterHandling}{pfAbSynOp}
\calls{macLambdaParameterHandling}{pfLeafPosition}
\calls{macLambdaParameterHandling}{pfParts}
\calls{macLambdaParameterHandling}{macLambdaParameterHandling}
\begin{chunk}{defun macLambdaParameterHandling}
(defun |macLambdaParameterHandling| (replist pform)
 (let (parlist symlist result)
  (cond
   ((|pfLeaf?| pform) nil)
   ((|pfLambda?| pform) ; remove ( identifier . replacement ) from assoclist
    (setq parlist (mapcar #'|pfTypedId| (|pf0LambdaArgs| pform)))
    (setq symlist (mapcar #'|pfIdSymbol| parlist))
    (dolist (par symlist)
     (setq replist
      (let ((pr (assoc par replist :test #'equal)))
       (when pr (remove par replist :test #'equal)))))
    replist)
   ((|pfMLambda?| pform) ;construct assoclist ( identifier . replacement )
    (setq parlist (|pf0MLambdaArgs| pform)) ; extract parameter list
    (dolist (par parlist (nreverse result))
     (push
      (cons (|pfIdSymbol| par)
            (|pfLeaf| (|pfAbSynOp| par) (gensym) (|pfLeafPosition| par)))
       result)))
   (t
    (dolist (p (|pfParts| pform)) 
     (|macLambdaParameterHandling| replist p))))))

\end{chunk}

\defun{macSubstituteId}{macSubstituteId}
\calls{macSubstituteId}{pfIdSymbol}
\begin{chunk}{defun macSubstituteId}
(defun |macSubstituteId| (replist pform)
 (let (ex)
  (setq ex (assoc (|pfIdSymbol| pform) replist :test #'eq))
  (cond
    (ex 
     (rplaca pform (cadr ex))
     (rplacd pform (cddr ex))
     pform)
    (t pform))))

\end{chunk}

\chapter{Pftrees}
\section{Abstract Syntax Trees Overview}

Th functions create and examine abstract syntax trees.  
These are called pforms, for short.

The pform data structure

\begin{itemize}
\item Leaves: [hd, tok, pos] where pos is optional
\item Trees:  [hd, tree, tree, ...]
\item hd is either an id or (id . alist)
\end{itemize}

The leaves are:

\begin{tabular}{lcl}
  char          &:=& ('char expr position) \\
  Document      &:=& ('Document expr position) \\
  error         &:=& ('error expr position) \\
  expression    &:=& ('expression expr position) \\
  float         &:=& ('float expr position) \\
  id            &:=& ('id expr position)\\
  idsy          &:=& ('idsy expr position)\\
  integer       &:=& ('integer expr position)\\
  string        &:=& ('string expr position)\\
  symbol        &:=& ('symbol expr position)
\end{tabular}

The special nodes:

\begin{tabular}{lcl}
  ListOf        &:=& ('listOf items)\\
  Nothing       &:=& ('nothing)\\
  SemiColon     &:=& ('SemiColon (Body: Expr))
\end{tabular}
          
The expression nodes:

\begin{tabular}{lcl}
 Add &:=& ('Add (Base: [Typed], Addin: Expr))\\ 
 And &:=& ('And left right)\\
 Application &:=& ('Application (Op: Expr, Arg: Expr))\\
 Assign &:=& ('Assign (LhsItems: [AssLhs], Rhs: Expr))\\
 Attribute &:=& ('Attribute (Expr: Primary))\\
 Break &:=& ('Break (From: ? Id))\\
 Coerceto &:=& ('Coerceto (Expr: Expr, Type: Type))\\
 Collect &:=& ('Collect (Body: Expr, Iterators: [Iterator]))\\
 ComDefinition &:=& ('ComDefinition (Doc: Document, Def: Definition))\\
 DeclPart &&\\
 Definition &:=& ('Definition (LhsItems: [Typed], Rhs: Expr))\\
 DefinitionSequence &:=& (Args: [DeclPart])\\
 Do &:=& ('Do (Body: Expr))\\
 Document &:=& ('Document strings)\\
 DWhere &:=& ('DWhere (Context: [DeclPart], Expr: [DeclPart]))\\
 EnSequence &:=&\\
 Exit &:=& ('Exit (Cond: ? Expr, Expr: ? Expr))\\
 Export &:=& ('Export (Items: [Typed]))\\
 Forin &:=& ('Forin (Lhs: [AssLhs], Whole: Expr))\\
 Free &:=& ('Free (Items: [Typed]))\\
 Fromdom &:=& ('Fromdom (What: Id, Domain: Type))\\
 Hide &:=& ('hide, arg)\\
 If &:=& ('If (Cond: Expr, Then: Expr, Else: ? Expr))\\
 Import &:=& ('Import (Items: [QualType]))\\
 Inline &:=& ('Inline (Items: [QualType]))\\
 Iterate &:=& ('Iterate (From: ? Id))\\
 Lambda &:=& ('Lambda (Args: [Typed], Rets: ReturnedTyped, Body: Expr))\\
 Literal \\
 Local &:=& ('Local (Items: [Typed]))\\
 Loop &:=& ('Loop (Iterators: [Iterator]))\\
 Macro &:=& ('Macro (Lhs: Id, Rhs: ExprorNot))\\
 MLambda &:=& ('MLambda (Args: [Id], Body: Expr))\\
 Not &:=& ('Not arg)\\
 Novalue &:=& ('Novalue (Expr: Expr))\\
 Or &:=& ('Or left right)\\
 Pretend &:=& ('Pretend (Expr: Expr, Type: Type))\\
 QualType &:=& ('QualType (Type: Type, Qual: ? Type))\\
 Restrict &:=& ('Restrict (Expr: Expr, Type: Type))\\
 Retract &:=& ('RetractTo (Expr: Expr, Type: Type))\\
 Return &:=& ('Return (Expr: ? Expr, From: ? Id))\\
 ReturnTyped &:=& ('returntyuped (type body))\\
 Rule &:=& ('Rule (lhsitems, rhsitems))\\
 Sequence &:=& ('Sequence (Args: [Expr]))\\
 Suchthat &:=& ('Suchthat (Cond: Expr))\\
 Symb &:=& if leaf then symbol else expression\\
 Tagged &:=& ('Tagged (Tag: Expr, Expr: Expr))\\
 TLambda &:=&('TLambda (Args: [Typed], \\
 &&\quad{}Rets: ReturnedTyped Type, Body: Expr))\\
 Tuple &:=& ('Tuple (Parts: [Expr]))\\
 Typed &:=& ('Typed (Id: Id, Type: ? Type))\\
 Typing &:=& ('Typing (Items: [Typed]))\\
 Until &:=& ('Until (Cond: Expr)) NOT USED\\
 WDeclare &:=& ('WDeclare (Signature: Typed, Doc: ? Document))\\
 Where &:=& ('Where (Context: [DeclPart], Expr: Expr))\\
 While &:=& ('While (Cond: Expr))\\
 With &:=& ('With (Base: [Typed], Within: [WithPart]))\\
 WIf &:=& ('WIf (Cond: Primary, Then: [WithPart], Else: [WithPart]))\\
 Wrong &:=& ('Wrong (Why: Document, Rubble: [Expr]))
\end{tabular}

Special cases of expression nodes are:

\begin{itemize}
\item Application. The Op parameter is one of
 \verb/and, or, Y, |, {}, [], {||}, [||]/
\item DeclPart. The comment is attached to all signatutres in 
 Typing, Import, Definition, Sequence, DWhere, Macro nodes
\item EnSequence. This is either a Tuple or Sequence depending on the
argument
\item Literal. One of integer symbol expression one zero char string float
of the form ('expression expr position)
\end{itemize}

\section{Structure handlers}

\defun{pfGlobalLinePosn}{pfGlobalLinePosn}
\calls{pfGlobalLinePosn}{poGlobalLinePosn}
\begin{chunk}{defun pfGlobalLinePosn}
(defun |pfGlobalLinePosn| (posn)
 (|poGlobalLinePosn| posn))

\end{chunk}

\defun{pfCharPosn}{pfCharPosn}
\calls{pfCharPosn}{poCharPosn}
\begin{chunk}{defun pfCharPosn}
(defun |pfCharPosn| (posn)
 (|poCharPosn| posn))

\end{chunk}

\defun{pfLinePosn}{pfLinePosn}
\calls{pfLinePosn}{poLinePosn}
\begin{chunk}{defun pfLinePosn}
(defun |pfLinePosn| (posn)
 (|poLinePosn| posn))

\end{chunk}

\defun{pfFileName}{pfFileName}
\calls{pfFileName}{poFileName}
\begin{chunk}{defun pfFileName}
(defun |pfFileName| (posn)
 (|poFileName| posn))

\end{chunk}

\defun{pfCopyWithPos}{pfCopyWithPos}
\calls{pfCopyWithPos}{pfLeaf?}
\calls{pfCopyWithPos}{pfLeaf}
\calls{pfCopyWithPos}{pfAbSynOp}
\calls{pfCopyWithPos}{tokPart}
\calls{pfCopyWithPos}{pfTree}
\calls{pfCopyWithPos}{pfParts}
\calls{pfCopyWithPos}{pfCopyWithPos}
\begin{chunk}{defun pfCopyWithPos}
(defun |pfCopyWithPos| (pform pos)
 (if (|pfLeaf?| pform)
  (|pfLeaf| (|pfAbSynOp| pform) (|tokPart| pform) pos)
  (|pfTree| (|pfAbSynOp| pform)
            (loop for p in (|pfParts| pform)
                  collect (|pfCopyWithPos| p pos)))))

\end{chunk}

\defun{pfMapParts}{pfMapParts}
\calls{pfMapParts}{pfLeaf?}
\calls{pfMapParts}{pfParts}
\calls{pfMapParts}{pfTree}
\calls{pfMapParts}{pfAbSynOp}
\begin{chunk}{defun pfMapParts}
(defun |pfMapParts| (f pform)
 (let (parts1 parts0)
  (if (|pfLeaf?| pform) 
   pform
   (progn
    (setq parts0 (|pfParts| pform))
    (setq parts1 (loop for p in parts0 collect (funcall f p)))
    (if (reduce #'(lambda (u v) (and u v)) (mapcar #'eq parts0 parts1))
     pform
     (|pfTree| (|pfAbSynOp| pform) parts1))))))

\end{chunk}

\defun{pf0ApplicationArgs}{pf0ApplicationArgs}
\calls{pf0ApplicationArgs}{pf0FlattenSyntacticTuple}
\calls{pf0ApplicationArgs}{pfApplicationArg}
\begin{chunk}{defun pf0ApplicationArgs}
(defun |pf0ApplicationArgs| (pform)
  (|pf0FlattenSyntacticTuple| (|pfApplicationArg| pform)))

\end{chunk}

\defun{pf0FlattenSyntacticTuple}{pf0FlattenSyntacticTuple}
\calls{pf0FlattenSyntacticTuple}{pfTuple?}
\calls{pf0FlattenSyntacticTuple}{pf0FlattenSyntacticTuple}
\calls{pf0FlattenSyntacticTuple}{pf0TupleParts}
\begin{chunk}{defun pf0FlattenSyntacticTuple}
(defun |pf0FlattenSyntacticTuple| (pform)
 (if (null (|pfTuple?| pform)) 
  (list pform)
   ; [:pf0FlattenSyntacticTuple p for p in pf0TupleParts pform]
  ((lambda (arg0 arg1 p)
   (loop
    (cond
     ((or (atom arg1) (progn (setq p (car arg1)) nil))
      (return (nreverse arg0)))
     (t
      (setq arg0 (append (reverse (|pf0FlattenSyntacticTuple| p)) arg0))))
    (setq arg1 (cdr arg1))))
   nil (|pf0TupleParts| pform) nil)))

\end{chunk}

\defun{pfSourcePosition}{pfSourcePosition}
\calls{pfSourcePosition}{pfLeaf?}
\calls{pfSourcePosition}{pfLeafPosition}
\calls{pfSourcePosition}{poNoPosition?}
\calls{pfSourcePosition}{pfSourcePosition}
\calls{pfSourcePosition}{pfParts}
\usesdollar{pfSourcePosition}{nopos}
\begin{chunk}{defun pfSourcePosition}
(defun |pfSourcePosition| (form)
 (let (pos)
 (declare (special |$nopos|))
  (cond
   ((|pfLeaf?| form) (|pfLeafPosition| form))
   (t
    (setq pos |$nopos|)
    ((lambda (theparts p) ; for p in parts while poNoPosition? pos repeat
     (loop
      (cond
       ((or (atom theparts)
            (progn (setq p (car theparts)) nil)
            (not (|poNoPosition?| pos)))
          (return nil))
       (t (setq pos (|pfSourcePosition| p))))
      (setq theparts (cdr theparts))))
     (|pfParts| form) nil)
    pos))))

\end{chunk}

\defun{pfSequenceToList}{Convert a Sequence node to a list}
\calls{pfSequenceToList}{pfSequence?}
\calls{pfSequenceToList}{pfSequenceArgs}
\calls{pfSequenceToList}{pfListOf}
\begin{chunk}{defun pfSequenceToList}
(defun |pfSequenceToList| (x)
 (if (|pfSequence?| x) 
  (|pfSequenceArgs| x)
  (|pfListOf| (list x))))

\end{chunk}

\defun{pfSpread}{pfSpread}
\calls{pfSpread}{pfTyped}
\begin{chunk}{defun pfSpread}
(defun |pfSpread| (arg1 arg2)
 (mapcar #'(lambda (i) (|pfTyped| i arg2)) arg1))

\end{chunk}

\defun{pfCheckItOut}{Deconstruct nodes to lists}
\calls{pfCheckItOut}{pfTagged?}
\calls{pfCheckItOut}{pfTaggedExpr}
\calls{pfCheckItOut}{pfNothing}
\calls{pfCheckItOut}{pfTaggedTag}
\calls{pfCheckItOut}{pfId?}
\calls{pfCheckItOut}{pfListOf}
\calls{pfCheckItOut}{pfTyped}
\calls{pfCheckItOut}{pfCollect1?}
\calls{pfCheckItOut}{pfCollectVariable1}
\calls{pfCheckItOut}{pfTuple?}
\calls{pfCheckItOut}{pf0TupleParts}
\calls{pfCheckItOut}{pfTaggedToTyped}
\calls{pfCheckItOut}{pfDefinition?}
\calls{pfCheckItOut}{pfApplication?}
\calls{pfCheckItOut}{pfFlattenApp}
\calls{pfCheckItOut}{pfTaggedToTyped1}
\calls{pfCheckItOut}{pfTransformArg}
\calls{pfCheckItOut}{npTrapForm}
\begin{chunk}{defun pfCheckItOut}
(defun |pfCheckItOut| (x)
 (let (args op ls form rt result)
  (if (|pfTagged?| x)
   (setq rt (|pfTaggedExpr| x))
   (setq rt (|pfNothing|)))
  (if (|pfTagged?| x)
   (setq form (|pfTaggedTag| x))
   (setq form x))
  (cond
   ((|pfId?| form)
    (list (|pfListOf| (list (|pfTyped| form rt))) nil rt))
   ((|pfCollect1?| form)
    (list (|pfListOf| (list (|pfCollectVariable1| form))) nil rt))
   ((|pfTuple?| form)
    (list (|pfListOf|
     (dolist (part (|pf0TupleParts| form) (nreverse result))
      (push (|pfTaggedToTyped| part) result)))
     nil rt))
   ((|pfDefinition?| form)
    (list (|pfListOf| (list (|pfTyped| form (|pfNothing|)))) nil rt))
   ((|pfApplication?| form)
    (setq ls (|pfFlattenApp| form))
    (setq op (|pfTaggedToTyped1| (car ls)))
    (setq args
     (dolist (part (cdr ls) (nreverse result))
      (push (|pfTransformArg| part) result)))
    (list (|pfListOf| (list op)) args rt))
   (t (|npTrapForm| form)))))

\end{chunk}

\defun{pfCheckMacroOut}{pfCheckMacroOut}
\calls{pfCheckMacroOut}{pfId?}
\calls{pfCheckMacroOut}{pfApplication?}
\calls{pfCheckMacroOut}{pfFlattenApp}
\calls{pfCheckMacroOut}{pfCheckId}
\calls{pfCheckMacroOut}{pfCheckArg}
\calls{pfCheckMacroOut}{npTrapForm}
\begin{chunk}{defun pfCheckMacroOut}
(defun |pfCheckMacroOut| (form)
 (let (args op ls)
  (cond
   ((|pfId?| form) (list form nil))
   ((|pfApplication?| form)
    (setq ls (|pfFlattenApp| form))
    (setq op (|pfCheckId| (car ls)))
    (setq args (mapcar #'|pfCheckArg| (cdr ls)))
    (list op args))
   (t (|npTrapForm| form)))))

\end{chunk}

\defun{pfCheckArg}{pfCheckArg}
\calls{pfCheckArg}{pfTuple?}
\calls{pfCheckArg}{pf0TupleParts}
\calls{pfCheckArg}{pfListOf}
\calls{pfCheckArg}{pfCheckId}
\begin{chunk}{defun pfCheckArg}
(defun |pfCheckArg| (args)
 (let (argl)
  (if (|pfTuple?| args)
   (setq argl (|pf0TupleParts| args))
   (setq argl (list args)))
  (|pfListOf| (mapcar #'|pfCheckId| argl))))

\end{chunk}

\defun{pfCheckId}{pfCheckId}
\calls{pfCheckId}{pfId?}
\calls{pfCheckId}{npTrapForm}
\begin{chunk}{defun pfCheckId}
(defun |pfCheckId| (form)
 (if (null (|pfId?| form))
  (|npTrapForm| form)
  form))

\end{chunk}

\defun{pfFlattenApp}{pfFlattenApp}
\calls{pfFlattenApp}{pfApplication?}
\calls{pfFlattenApp}{pfCollect1?}
\calls{pfFlattenApp}{pfFlattenApp}
\calls{pfFlattenApp}{pfApplicationOp}
\calls{pfFlattenApp}{pfApplicationArg}
\begin{chunk}{defun pfFlattenApp}
(defun |pfFlattenApp| (x)
 (cond
  ((|pfApplication?| x)
   (cond
    ((|pfCollect1?| x) (LIST x))
    (t
     (append (|pfFlattenApp| (|pfApplicationOp| x))
             (|pfFlattenApp| (|pfApplicationArg| x))))))
  (t (list x))))

\end{chunk}

\defun{pfCollect1?}{pfCollect1?}
\calls{pfCollect1?}{pfApplication?}
\calls{pfCollect1?}{pfApplicationOp}
\calls{pfCollect1?}{pfId?}
\calls{pfCollect1?}{pfIdSymbol}
\begin{chunk}{defun pfCollect1?}
(defun |pfCollect1?| (x)
 (let (a)
  (when (|pfApplication?| x)
   (setq a (|pfApplicationOp| x))
   (when (|pfId?| a) (eq (|pfIdSymbol| a) '|\||)))))

\end{chunk}

\defun{pfCollectVariable1}{pfCollectVariable1}
\calls{pfCollectVariable1}{pfApplicationArg}
\calls{pfCollectVariable1}{pf0TupleParts}
\calls{pfCollectVariable1}{pfTaggedToTyped}
\calls{pfCollectVariable1}{pfTyped}
\calls{pfCollectVariable1}{pfSuch}
\calls{pfCollectVariable1}{pfTypedId}
\calls{pfCollectVariable1}{pfTypedType}
\begin{chunk}{defun pfCollectVariable1}
(defun |pfCollectVariable1| (x)
 (let (id var a)
  (setq a (|pfApplicationArg| x))
  (setq var (car (|pf0TupleParts| a)))
  (setq id (|pfTaggedToTyped| var))
  (|pfTyped|
   (|pfSuch| (|pfTypedId| id) (cadr (|pf0TupleParts| a)))
   (|pfTypedType| id))))

\end{chunk}

\defun{pfPushMacroBody}{pfPushMacroBody}
\calls{pfPushMacroBody}{pfMLambda}
\calls{pfPushMacroBody}{pfPushMacroBody}
\begin{chunk}{defun pfPushMacroBody}
(defun |pfPushMacroBody| (args body)
 (if (null args)
   body
   (|pfMLambda| (car args) (|pfPushMacroBody| (cdr args) body))))

\end{chunk}

\defun{pfSourceStok}{pfSourceStok}
\calls{pfSourceStok}{pfLeaf?}
\calls{pfSourceStok}{pfParts}
\calls{pfSourceStok}{pfSourceStok}
\calls{pfSourceStok}{pfFirst}
\begin{chunk}{defun pfSourceStok}
(defun |pfSourceStok| (x)
 (cond
  ((|pfLeaf?| x) x)
  ((null (|pfParts| x)) '|NoToken|)
  (t (|pfSourceStok| (|pfFirst| x)))))

\end{chunk}

\defun{pfTransformArg}{pfTransformArg}
\calls{pfTransformArg}{pfTuple?}
\calls{pfTransformArg}{pf0TupleParts}
\calls{pfTransformArg}{pfListOf}
\calls{pfTransformArg}{pfTaggedToTyped1}
\begin{chunk}{defun pfTransformArg}
(defun |pfTransformArg| (args)
 (let (arglist result)
  (if (|pfTuple?| args)
   (setq arglist (|pf0TupleParts| args))
   (setq arglist (list args)))
  (|pfListOf|
   (dolist (|i| arglist (nreverse result))
    (push (|pfTaggedToTyped1| |i|) result)))))

\end{chunk}

\defun{pfTaggedToTyped1}{pfTaggedToTyped1}
\calls{pfTaggedToTyped1}{pfCollect1?}
\calls{pfTaggedToTyped1}{pfCollectVariable1}
\calls{pfTaggedToTyped1}{pfDefinition?}
\calls{pfTaggedToTyped1}{pfTyped}
\calls{pfTaggedToTyped1}{pfNothing}
\calls{pfTaggedToTyped1}{pfTaggedToTyped}
\begin{chunk}{defun pfTaggedToTyped1}
(defun |pfTaggedToTyped1| (arg)
 (cond
  ((|pfCollect1?| arg) (|pfCollectVariable1| arg))
  ((|pfDefinition?| arg) (|pfTyped| arg (|pfNothing|)))
  (t (|pfTaggedToTyped| arg))))

\end{chunk}

\defun{pfSuch}{pfSuch}
\calls{pfSuch}{pfInfApplication}
\calls{pfSuch}{pfId}
\begin{chunk}{defun pfSuch}
(defun |pfSuch| (x y)
 (|pfInfApplication| (|pfId| '|\||) x y))

\end{chunk}

\section{Special Nodes}

\defun{pfListOf}{Create a Listof node}
\calls{pfListOf}{pfTree}
\begin{chunk}{defun pfListOf}
(defun |pfListOf| (x)
 (|pfTree| '|listOf| x))

\end{chunk}

\defun{pfNothing}{pfNothing}
\calls{pfNothing}{pfTree}
\begin{chunk}{defun pfNothing}
(defun |pfNothing| ()
 (|pfTree| '|nothing| nil))

\end{chunk}

\defun{pfNothing?}{Is this a Nothing node?}
\calls{pfNothing?}{pfAbSynOp?}
\begin{chunk}{defun pfNothing?}
(defun |pfNothing?| (form)
 (|pfAbSynOp?| form '|nothing|))

\end{chunk}

\section{Leaves}

\defun{pfDocument}{Create a Document node}
\calls{pfDocument}{pfLeaf}
\begin{chunk}{defun pfDocument}
(defun |pfDocument| (strings)
 (|pfLeaf| '|Document| strings))

\end{chunk}

\defun{pfId}{Construct an Id node}
\calls{pfId}{pfLeaf}
\begin{chunk}{defun pfId}
(defun |pfId| (expr)
 (|pfLeaf| '|id| expr))

\end{chunk}

\defun{pfId?}{Is this an Id node?}
\calls{pfId?}{pfAbSynOp?}
\begin{chunk}{defun pfId?}
(defun |pfId?| (form)
 (or (|pfAbSynOp?| form '|id|) (|pfAbSynOp?| form '|idsy|)))

\end{chunk}

\defun{pfIdPos}{Construct an Id leaf node}
\calls{pfIdPos}{pfLeaf}
\begin{chunk}{defun pfIdPos}
(defun |pfIdPos| (expr pos)
 (|pfLeaf| '|id| expr pos))

\end{chunk}

\defun{pfIdSymbol}{Return the Id part}
\calls{pfIdSymbol}{tokPart}
\begin{chunk}{defun pfIdSymbol}
(defun |pfIdSymbol| (form)
 (|tokPart| form))

\end{chunk}

\defun{pfLeaf}{Construct a Leaf node}
\calls{pfLeaf}{tokConstruct}
\calls{pfLeaf}{ifcar}
\calls{pfLeaf}{pfNoPosition}
\begin{chunk}{defun pfLeaf}
(defun |pfLeaf| (x y &rest z)
 (|tokConstruct| x y (or (ifcar z) (|pfNoPosition|))))

\end{chunk}

\defun{pfLeaf?}{Is this a leaf node?}
\calls{pfLeaf?}{pfAbSynOp}
\begin{chunk}{defun pfLeaf?}
(defun |pfLeaf?| (form)
 (member (|pfAbSynOp| form)
   '(|id| |idsy| |symbol| |string| |char| |float| |expression|
     |integer| |Document| |error|)))

\end{chunk}

\defun{pfLeafPosition}{Return the token position of a leaf node}
\calls{pfLeafPosition}{tokPosn}
\begin{chunk}{defun pfLeafPosition}
(defun |pfLeafPosition| (form)
 (|tokPosn| form))

\end{chunk}

\defun{pfLeafToken}{Return the Leaf Token}
\calls{pfLeafToken}{tokPart}
\begin{chunk}{defun pfLeafToken}
(defun |pfLeafToken| (form)
 (|tokPart| form))

\end{chunk}

\defun{pfLiteral?}{Is this a Literal node?}
\calls{pfLiteral?}{pfAbSynOp}
\begin{chunk}{defun pfLiteral? 0}
(defun |pfLiteral?| (form)
 (member (|pfAbSynOp| form)
  '(|integer| |symbol| |expression| |one| |zero| |char| |string| |float|)))

\end{chunk}

\defun{pfLiteralClass}{Create a LiteralClass node}
\calls{pfLiteralClass}{pfAbSynOp}
\begin{chunk}{defun pfLiteralClass}
(defun |pfLiteralClass| (form)
 (|pfAbSynOp| form))

\end{chunk}

\defun{pfLiteralString}{Return the LiteralString}
\calls{pfLiteralString}{tokPart}
\begin{chunk}{defun pfLiteralString}
(defun |pfLiteralString| (form)
 (|tokPart| form))

\end{chunk}

\defun{pfParts}{Return the parts of a tree node}
\begin{chunk}{defun pfParts 0}
(defun |pfParts| (form)
 (cdr form))

\end{chunk}

\defun{pfPile}{Return the argument unchanged}
\begin{chunk}{defun pfPile 0}
(defun |pfPile| (part)
 part)

\end{chunk}

\defun{pfPushBody}{pfPushBody}
\calls{pfPushBody}{pfLambda}
\calls{pfPushBody}{pfNothing}
\calls{pfPushBody}{pfPushBody}
\begin{chunk}{defun pfPushBody}
(defun |pfPushBody| (rt args body)
 (cond
  ((null args) body)
  ((null (cdr args)) (|pfLambda| (car args) rt body))
  (t
   (|pfLambda| (car args) (|pfNothing|)
               (|pfPushBody| rt (cdr args) body)))))

\end{chunk}

\defun{pfSexpr}{An S-expression which people can read.}
\calls{pfSexpr}{pfSexpr,strip}
\begin{chunk}{defun pfSexpr}
(defun |pfSexpr| (pform)
 (|pfSexpr,strip| pform))

\end{chunk}

\defun{pfSexpr,strip}{Create a human readable S-expression}
\calls{pfSexpr,strip}{pfId?}
\calls{pfSexpr,strip}{pfIdSymbol}
\calls{pfSexpr,strip}{pfLiteral?}
\calls{pfSexpr,strip}{pfLiteralString}
\calls{pfSexpr,strip}{pfLeaf?}
\calls{pfSexpr,strip}{tokPart}
\calls{pfSexpr,strip}{pfApplication?}
\calls{pfSexpr,strip}{pfApplicationArg}
\calls{pfSexpr,strip}{pfTuple?}
\calls{pfSexpr,strip}{pf0TupleParts}
\calls{pfSexpr,strip}{pfApplicationOp}
\calls{pfSexpr,strip}{pfSexpr,strip}
\calls{pfSexpr,strip}{pfAbSynOp}
\calls{pfSexpr,strip}{pfParts}
\begin{chunk}{defun pfSexpr,strip}
(defun |pfSexpr,strip| (pform)
 (let (args a result)
  (cond
   ((|pfId?| pform)      (|pfIdSymbol| pform))
   ((|pfLiteral?| pform) (|pfLiteralString| pform))
   ((|pfLeaf?| pform)    (|tokPart| pform))
   ((|pfApplication?| pform)
    (setq a (|pfApplicationArg| pform))
    (if (|pfTuple?| a)
     (setq args (|pf0TupleParts| a))
     (setq args (list a)))
    (dolist (p (cons (|pfApplicationOp| pform) args) (nreverse result))
     (push (|pfSexpr,strip| p) result)))
   (t
    (cons (|pfAbSynOp| pform)
     (dolist (p (|pfParts| pform) (nreverse result))
      (push (|pfSexpr,strip| p) result)))))))

\end{chunk}

\defun{pfSymb}{Construct a Symbol or Expression node}
\calls{pfSymb}{pfLeaf?}
\calls{pfSymb}{pfSymbol}
\calls{pfSymb}{tokPart}
\calls{pfSymb}{ifcar}
\calls{pfSymb}{pfExpression}
\calls{pfSymb}{pfSexpr}
\begin{chunk}{defun pfSymb}
(defun |pfSymb| (expr &REST optpos)
 (if (|pfLeaf?| expr)
  (|pfSymbol| (|tokPart| expr) (ifcar optpos))
  (|pfExpression| (|pfSexpr| expr) (ifcar optpos))))

\end{chunk}

\defun{pfSymbol}{Construct a Symbol leaf node}
\calls{pfSymbol}{pfLeaf}
\calls{pfSymbol}{ifcar}
\begin{chunk}{defun pfSymbol}
(defun |pfSymbol| (expr &rest optpos)
 (|pfLeaf| '|symbol| expr (ifcar optpos)))

\end{chunk}

\defun{pfSymbol?}{Is this a Symbol node?}
\calls{pfSymbol?}{pfAbSynOp?}
\begin{chunk}{defun pfSymbol?}
(defun |pfSymbol?| (form)
 (|pfAbSynOp?| form '|symbol|))

\end{chunk}

\defun{pfSymbolSymbol}{Return the Symbol part}
\calls{pfSymbolSymbol}{tokPart}
\begin{chunk}{defun pfSymbolSymbol}
(defun |pfSymbolSymbol| (form)
 (|tokPart| form))

\end{chunk}

\section{Trees}

\defun{pfTree}{Construct a tree node}
\begin{chunk}{defun pfTree 0}
(defun |pfTree| (x y)
 (cons x y))

\end{chunk}

\defun{pfAdd}{Construct an Add node}
\calls{pfAdd}{pfNothing}
\calls{pfAdd}{pfTree}
\begin{chunk}{defun pfAdd}
(defun |pfAdd| (pfbase pfaddin &rest addon)
 (let (lhs)
  (if addon
   (setq lhs addon)
   (setq lhs (|pfNothing|)))
  (|pfTree| '|Add| (list pfbase pfaddin lhs))))

\end{chunk}

\defun{pfAnd}{Construct an And node}
\calls{pfAnd}{pfTree}
\begin{chunk}{defun pfAnd}
(defun |pfAnd| (pfleft pfright)
 (|pfTree| '|And| (list pfleft pfright)))

\end{chunk}

\defun{pfAttribute}{pfAttribute}
\calls{pfAttribute}{pfTree}
\begin{chunk}{defun pfAttribute}
(defun |pfAttribute| (pfexpr)
 (|pfTree| '|Attribute| (list pfexpr)))

\end{chunk}

\defun{pfApplication}{Return an Application node}
\calls{pfApplication}{pfTree}
\begin{chunk}{defun pfApplication}
(defun |pfApplication| (pfop pfarg)
 (|pfTree| '|Application| (list pfop pfarg)))

\end{chunk}

\defun{pfApplicationArg}{Return the Arg part of an Application node}
\begin{chunk}{defun pfApplicationArg 0}
(defun |pfApplicationArg| (pf)
 (caddr pf))

\end{chunk}

\defun{pfApplicationOp}{Return the Op part of an Application node}
\begin{chunk}{defun pfApplicationOp 0}
(defun |pfApplicationOp| (pf)
 (cadr pf))

\end{chunk}

\defun{pfAnd?}{Is this an And node?}
\calls{pfAnd?}{pfAbSynOp?}
\begin{chunk}{defun pfAnd?}
(defun |pfAnd?| (pf)
 (|pfAbSynOp?| pf '|And|))

\end{chunk}

\defun{pfAndLeft}{Return the Left part of an And node}
\begin{chunk}{defun pfAndLeft 0}
(defun |pfAndLeft| (pf)
 (cadr pf))

\end{chunk}

\defun{pfAndRight}{Return the Right part of an And node}
\begin{chunk}{defun pfAndRight 0}
(defun |pfAndRight| (pf)
 (caddr pf))

\end{chunk}

\defun{pfAppend}{Flatten a list of lists}
\begin{chunk}{defun pfAppend 0}
(defun |pfAppend| (list)
 (apply #'append list))

\end{chunk}

\defun{pfApplication?}{Is this an Application node?}
\calls{pfApplication?}{pfAbSynOp?}
\begin{chunk}{defun pfApplication?}
(defun |pfApplication?| (pf)
  (|pfAbSynOp?| pf '|Application|))

\end{chunk}

\defun{pfAssign}{Create an Assign node}
\calls{pfAssign}{pfTree}
\begin{chunk}{defun pfAssign}
(defun |pfAssign| (pflhsitems pfrhs)
 (|pfTree| '|Assign| (list pflhsitems pfrhs)))

\end{chunk}

\defun{pfAssign?}{Is this an Assign node?}
\calls{pfAssign?}{pfAbSynOp?}
\begin{chunk}{defun pfAssign?}
(defun |pfAssign?| (pf)
 (|pfAbSynOp?| pf '|Assign|))

\end{chunk}

\defun{pf0AssignLhsItems}{Return the parts of an LhsItem of an Assign node}
\calls{pf0AssignLhsItems}{pfParts}
\calls{pf0AssignLhsItems}{pfAssignLhsItems}
\begin{chunk}{defun pf0AssignLhsItems 0}
(defun |pf0AssignLhsItems| (pf)
 (|pfParts| (|pfAssignLhsItems| pf)))

\end{chunk}

\defun{pfAssignLhsItems}{Return the LhsItem of an Assign node}
\begin{chunk}{defun pfAssignLhsItems 0}
(defun |pfAssignLhsItems| (pf)
 (cadr pf))

\end{chunk}

\defun{pfAssignRhs}{Return the RHS of an Assign node}
\begin{chunk}{defun pfAssignRhs 0}
(defun |pfAssignRhs| (pf)
 (caddr pf))

\end{chunk}

\defun{pfBrace}{Construct an application node for a brace}
\calls{pfBrace}{pfApplication}
\calls{pfBrace}{pfIdPos}
\calls{pfBrace}{tokPosn}
\begin{chunk}{defun pfBrace}
(defun |pfBrace| (a part)
 (|pfApplication| (|pfIdPos| '{} (|tokPosn| a)) part))

\end{chunk}

\defun{pfBraceBar}{Construct an Application node for brace-bars}
\calls{pfBraceBar}{pfApplication}
\calls{pfBraceBar}{pfIdPos}
\calls{pfBraceBar}{tokPosn}
\begin{chunk}{defun pfBraceBar}
(defun |pfBraceBar| (a part)
 (|pfApplication| (|pfIdPos| '|{\|\|}| (|tokPosn| a)) part))

\end{chunk}

\defun{pfBracket}{Construct an Application node for a bracket}
\calls{pfBracket}{pfApplication}
\calls{pfBracket}{pfIdPos}
\calls{pfBracket}{tokPosn}
\begin{chunk}{defun pfBracket}
(defun |pfBracket| (a part)
 (|pfApplication| (|pfIdPos| '[] (|tokPosn| a)) part))

\end{chunk}

\defun{pfBracketBar}{Construct an Application node for bracket-bars}
\calls{pfBracketBar}{pfApplication}
\calls{pfBracketBar}{pfIdPos}
\calls{pfBracketBar}{tokPosn}
\begin{chunk}{defun pfBracketBar}
(defun |pfBracketBar| (a part)
 (|pfApplication| (|pfIdPos| '|[\|\|]| (|tokPosn| a)) part))

\end{chunk}

\defun{pfBreak}{Create a Break node}
\calls{pfBreak}{pfTree}
\begin{chunk}{defun pfBreak}
(defun |pfBreak| (pffrom)
 (|pfTree| '|Break| (list pffrom)))

\end{chunk}

\defun{pfBreak?}{Is this a Break node?}
\calls{pfBreak?}{pfAbSynOp?}
\begin{chunk}{defun pfBreak?}
(defun |pfBreak?| (pf)
 (|pfAbSynOp?| pf '|Break|))

\end{chunk}

\defun{pfBreakFrom}{Return the From part of a Break node}
\begin{chunk}{defun pfBreakFrom 0}
(defun |pfBreakFrom| (pf)
 (cadr pf))

\end{chunk}

\defun{pfCoerceto}{Construct a Coerceto node}
\calls{pfCoerceto}{pfTree}
\begin{chunk}{defun pfCoerceto}
(defun |pfCoerceto| (pfexpr pftype)
 (|pfTree| '|Coerceto| (list pfexpr pftype)))

\end{chunk}

\defun{pfCoerceto?}{Is this a CoerceTo node?}
\calls{pfCoerceto?}{pfAbSynOp?}
\begin{chunk}{defun pfCoerceto?}
(defun |pfCoerceto?| (pf)
 (|pfAbSynOp?| pf '|Coerceto|))

\end{chunk}

\defun{pfCoercetoExpr}{Return the Expression part of a CoerceTo node}
\begin{chunk}{defun pfCoercetoExpr 0}
(defun |pfCoercetoExpr| (pf)
 (cadr pf))

\end{chunk}

\defun{pfCoercetoType}{Return the Type part of a CoerceTo node}
\begin{chunk}{defun pfCoercetoType 0}
(defun |pfCoercetoType| (pf)
 (caddr pf))

\end{chunk}

\defun{pfCollectBody}{Return the Body of a Collect node}
\begin{chunk}{defun pfCollectBody 0}
(defun |pfCollectBody| (pf)
 (cadr pf))

\end{chunk}

\defun{pfCollectIterators}{Return the Iterators of a Collect node}
\begin{chunk}{defun pfCollectIterators 0}
(defun |pfCollectIterators| (pf)
 (caddr pf))

\end{chunk}

\defun{pfCollect}{Create a Collect node}
\calls{pfCollect}{pfTree}
\begin{chunk}{defun pfCollect}
(defun |pfCollect| (pfbody pfiterators)
 (|pfTree| '|Collect| (list pfbody pfiterators)))

\end{chunk}

\defun{pfCollect?}{Is this a Collect node?}
\calls{pfCollect?}{pfAbSynOp?}
\begin{chunk}{defun pfCollect?}
(defun |pfCollect?| (pf)
 (|pfAbSynOp?| pf '|Collect|))

\end{chunk}

\defun{pfDefinition}{pfDefinition}
\calls{pfDefinition}{pfTree}
\begin{chunk}{defun pfDefinition}
(defun |pfDefinition| (pflhsitems pfrhs)
 (|pfTree| '|Definition| (list pflhsitems pfrhs)))

\end{chunk}

\defun{pfDefinitionLhsItems}{Return the Lhs of a Definition node}
\begin{chunk}{defun pfDefinitionLhsItems 0}
(defun |pfDefinitionLhsItems| (pf)
 (cadr pf))

\end{chunk}

\defun{pfDefinitionRhs}{Return the Rhs of a Definition node}
\begin{chunk}{defun pfDefinitionRhs 0}
(defun |pfDefinitionRhs| (pf)
 (caddr pf))

\end{chunk}

\defun{pfDefinition?}{Is this a Definition node?}
\calls{pfDefinition?}{pfAbSynOp?}
\begin{chunk}{defun pfDefinition?}
(defun |pfDefinition?| (pf)
 (|pfAbSynOp?| pf '|Definition|))

\end{chunk}

\defun{pf0DefinitionLhsItems}{Return the parts of a Definition node}
\calls{pf0DefinitionLhsItems}{pfParts}
\calls{pf0DefinitionLhsItems}{pfDefinitionLhsItems}
\begin{chunk}{defun pf0DefinitionLhsItems}
(defun |pf0DefinitionLhsItems| (pf)
 (|pfParts| (|pfDefinitionLhsItems| pf)))

\end{chunk}

\defun{pfDo}{Create a Do node}
\calls{pfDo}{pfTree}
\begin{chunk}{defun pfDo}
(defun |pfDo| (pfbody)
 (|pfTree| '|Do| (list pfbody)))

\end{chunk}

\defun{pfDo?}{Is this a Do node?}
\calls{pfDo?}{pfAbSynOp?}
\begin{chunk}{defun pfDo?}
(defun |pfDo?| (pf)
 (|pfAbSynOp?| pf '|Do|))

\end{chunk}

\defun{pfDoBody}{Return the Body of a Do node}
\begin{chunk}{defun pfDoBody 0}
(defun |pfDoBody| (pf)
 (cadr pf))

\end{chunk}

\defun{pfEnSequence}{Construct a Sequence node}
\calls{pfEnSequence}{pfTuple}
\calls{pfEnSequence}{pfListOf}
\calls{pfEnSequence}{pfSequence}
\begin{chunk}{defun pfEnSequence}
(defun |pfEnSequence| (a)
 (cond
  ((null a) (|pfTuple| (|pfListOf| a)))
  ((null (cdr a)) (car a))
  (t (|pfSequence| (|pfListOf| a)))))

\end{chunk}

\defun{pfExit}{Construct an Exit node}
\calls{pfExit}{pfTree}
\begin{chunk}{defun pfExit}
(defun |pfExit| (pfcond pfexpr)
 (|pfTree| '|Exit| (list pfcond pfexpr)))

\end{chunk}

\defun{pfExit?}{Is this an Exit node?}
\calls{pfExit?}{pfAbSynOp?}
\begin{chunk}{defun pfExit?}
(defun |pfExit?| (pf)
 (|pfAbSynOp?| pf '|Exit|))

\end{chunk}

\defun{pfExitCond}{Return the Cond part of an Exit}
\begin{chunk}{defun pfExitCond 0}
(defun |pfExitCond| (pf)
 (cadr pf))

\end{chunk}

\defun{pfExitExpr}{Return the Expression part of an Exit}
\begin{chunk}{defun pfExitExpr 0}
(defun |pfExitExpr| (pf)
 (caddr pf))

\end{chunk}

\defun{pfExport}{Create an Export node}
\calls{pfExport}{pfTree}
\begin{chunk}{defun pfExport}
(defun |pfExport| (pfitems)
 (|pfTree| '|Export| (list pfitems)))

\end{chunk}

\defun{pfExpression}{Construct an Expression leaf node}
\calls{pfExpression}{pfLeaf}
\calls{pfExpression}{ifcar}
\begin{chunk}{defun pfExpression}
(defun |pfExpression| (expr &rest optpos)
 (|pfLeaf| '|expression| expr (ifcar optpos)))

\end{chunk}

\defun{pfFirst}{pfFirst}
\begin{chunk}{defun pfFirst 0}
(defun |pfFirst| (form)
 (cadr form))

\end{chunk}

\defun{pfFix}{Create an Application Fix node}
\calls{pfFix}{pfApplication}
\calls{pfFix}{pfId}
\begin{chunk}{defun pfFix}
(defun |pfFix| (pf)
 (|pfApplication| (|pfId| 'Y) pf))

\end{chunk}

\defun{pfFree}{Create a Free node}
\calls{pfFree}{pfTree}
\begin{chunk}{defun pfFree}
(defun |pfFree| (pfitems)
 (|pfTree| '|Free| (list pfitems)))

\end{chunk}

\defun{pfFree?}{Is this a Free node?}
\calls{pfFree?}{pfAbSynOp?}
\begin{chunk}{defun pfFree?}
(defun |pfFree?| (pf)
 (|pfAbSynOp?| pf '|Free|))

\end{chunk}

\defun{pf0FreeItems}{Return the parts of the Items of a Free node}
\calls{pf0FreeItems}{pfParts}
\calls{pf0FreeItems}{pfFreeItems}
\begin{chunk}{defun pf0FreeItems}
(defun |pf0FreeItems| (pf)
 (|pfParts| (|pfFreeItems| pf)))

\end{chunk}

\defun{pfFreeItems}{Return the Items of a Free node}
\begin{chunk}{defun pfFreeItems 0}
(defun |pfFreeItems| (pf)
 (cadr pf))

\end{chunk}

\defun{pfForin}{Construct a Forin node}
\calls{pfForin}{pfTree}
\begin{chunk}{defun pfForin}
(defun |pfForin| (pflhs pfwhole)
 (|pfTree| '|Forin| (list pflhs pfwhole)))

\end{chunk}

\defun{pfForin?}{Is this a ForIn node?}
\calls{pfForin?}{pfAbSynOp?}
\begin{chunk}{defun pfForin?}
(defun |pfForin?| (pf)
 (|pfAbSynOp?| pf '|Forin|))

\end{chunk}

\defun{pf0ForinLhs}{Return all the parts of the LHS of a ForIn node}
\calls{pf0ForinLhs}{pfParts}
\calls{pf0ForinLhs}{pfForinLhs}
\begin{chunk}{defun pf0ForinLhs}
(defun |pf0ForinLhs| (pf)
 (|pfParts| (|pfForinLhs| pf)))

\end{chunk}

\defun{pfForinLhs}{Return the LHS part of a ForIn node}
\begin{chunk}{defun pfForinLhs 0}
(defun |pfForinLhs| (pf)
 (cadr pf))

\end{chunk}

\defun{pfForinWhole}{Return the Whole part of a ForIn node}
\begin{chunk}{defun pfForinWhole 0}
(defun |pfForinWhole| (pf)
 (caddr pf))

\end{chunk}

\defun{pfFromDom}{pfFromDom}
\calls{pfFromDom}{pfApplication?}
\calls{pfFromDom}{pfApplication}
\calls{pfFromDom}{pfApplicationOp}
\calls{pfFromDom}{pfApplicationArg}
\calls{pfFromDom}{pfFromdom}
\begin{chunk}{defun pfFromDom}
(defun |pfFromDom| (dom expr)
 (cond
  ((|pfApplication?| expr)
   (|pfApplication|
    (|pfFromdom| (|pfApplicationOp| expr) dom)
    (|pfApplicationArg| expr)))
  (t (|pfFromdom| expr dom))))

\end{chunk}

\defun{pfFromdom}{Construct a Fromdom node}
\calls{pfFromdom}{pfTree}
\begin{chunk}{defun pfFromdom}
(defun |pfFromdom| (pfwhat pfdomain)
 (|pfTree| '|Fromdom| (list pfwhat pfdomain)))

\end{chunk}

\defun{pfFromdom?}{Is this a Fromdom mode?}
\calls{pfFromdom?}{pfAbSynOp?}
\begin{chunk}{defun pfFromdom?}
(defun |pfFromdom?| (pf)
 (|pfAbSynOp?| pf '|Fromdom|))

\end{chunk}

\defun{pfFromdomWhat}{Return the What part of a Fromdom node}
\begin{chunk}{defun pfFromdomWhat 0}
(defun |pfFromdomWhat| (pf)
 (cadr pf))

\end{chunk}

\defun{pfFromdomDomain}{Return the Domain part of a Fromdom node}
\begin{chunk}{defun pfFromdomDomain 0}
(defun |pfFromdomDomain| (pf)
 (caddr pf))

\end{chunk}

\defun{pfHide}{Construct a Hide node}
\calls{pfHide}{pfTree}
\begin{chunk}{defun pfHide}
(defun |pfHide| (a part)
 (declare (ignore a))
 (|pfTree| '|Hide| (list part)))

\end{chunk}

\defun{pfIf}{pfIf}
\calls{pfIf}{pfTree}
\begin{chunk}{defun pfIf}
(defun |pfIf| (pfcond pfthen pfelse)
 (|pfTree| '|If| (list pfcond pfthen pfelse)))

\end{chunk}

\defun{pfIf?}{Is this an If node?}
\calls{pfIf?}{pfAbSynOp?}
\begin{chunk}{defun pfIf?}
(defun |pfIf?| (pf)
  (|pfAbSynOp?| pf '|If|))

\end{chunk}

\defun{pfIfCond}{Return the Cond part of an If}
\begin{chunk}{defun pfIfCond 0}
(defun |pfIfCond| (pf)
 (cadr pf))

\end{chunk}

\defun{pfIfThen}{Return the Then part of an If}
\begin{chunk}{defun pfIfThen 0}
(defun |pfIfThen| (pf)
 (caddr pf))

\end{chunk}

\defun{pfIfThenOnly}{pfIfThenOnly}
\calls{pfIfThenOnly}{pfIf}
\calls{pfIfThenOnly}{pfNothing}
\begin{chunk}{defun pfIfThenOnly}
(defun |pfIfThenOnly| (pred cararg)
 (|pfIf| pred cararg (|pfNothing|)))

\end{chunk}

\defun{pfIfElse}{Return the Else part of an If}
\begin{chunk}{defun pfIfElse 0}
(defun |pfIfElse| (pf)
 (cadddr pf))

\end{chunk}

\defun{pfImport}{Construct an Import node}
\calls{pfImport}{pfTree}
\begin{chunk}{defun pfImport}
(defun |pfImport| (pfitems)
 (|pfTree| '|Import| (list pfitems)))

\end{chunk}

\defun{pfIterate}{Construct an Iterate node}
\calls{pfIterate}{pfTree}
\begin{chunk}{defun pfIterate}
(defun |pfIterate| (pffrom)
 (|pfTree| '|Iterate| (list pffrom)))

\end{chunk}

\defun{pfIterate?}{Is this an Iterate node?}
\calls{pfIterate?}{pfAbSynOp?}
\begin{chunk}{defun pfIterate?}
(defun |pfIterate?| (pf)
 (|pfAbSynOp?| pf '|Iterate|))

\end{chunk}

\defun{pfInfApplication}{Handle an infix application}
\calls{pfInfApplication}{pfListOf}
\calls{pfInfApplication}{pfIdSymbol}
\calls{pfInfApplication}{pfAnd}
\calls{pfInfApplication}{pfOr}
\calls{pfInfApplication}{pfApplication}
\calls{pfInfApplication}{pfTuple}
\begin{chunk}{defun pfInfApplication}
(defun |pfInfApplication| (op left right)
 (cond
  ((eq (|pfIdSymbol| op) '|and|) (|pfAnd| left right))
  ((eq (|pfIdSymbol| op) '|or|) (|pfOr| left right))
  (t (|pfApplication| op (|pfTuple| (|pfListOf| (list left right)))))))

\end{chunk}

\defun{pfInline}{Create an Inline node}
\calls{pfInline}{pfTree}
\begin{chunk}{defun pfInline}
(defun |pfInline| (pfitems)
 (|pfTree| '|Inline| (list pfitems)))

\end{chunk}

\defun{pfLam}{pfLam}
\calls{pfLam}{pfAbSynOp?}
\calls{pfLam}{pfFirst}
\calls{pfLam}{pfNothing}
\calls{pfLam}{pfSecond}
\calls{pfLam}{pfLambda}
\begin{chunk}{defun pfLam}
(defun |pfLam| (variable body)
 (let (bdy rets)
  (if (|pfAbSynOp?| body '|returntyped|)
   (setq rets (|pfFirst| body))
   (setq rets (|pfNothing|)))
  (if (|pfAbSynOp?| body '|returntyped|)
   (setq bdy (|pfSecond| body))
   (setq bdy body))
  (|pfLambda| variable rets bdy)))

\end{chunk}

\defun{pfLambda}{pfLambda}
\calls{pfLambda}{pfTree}
\begin{chunk}{defun pfLambda}
(defun |pfLambda| (pfargs pfrets pfbody)
 (|pfTree| '|Lambda| (list pfargs pfrets pfbody)))

\end{chunk}

\defun{pfLambdaBody}{Return the Body part of a Lambda node}
\begin{chunk}{defun pfLambdaBody 0}
(defun |pfLambdaBody| (pf)
 (cadddr pf))

\end{chunk}

\defun{pfLambdaRets}{Return the Rets part of a Lambda node}
\begin{chunk}{defun pfLambdaRets 0}
(defun |pfLambdaRets| (pf)
 (caddr pf))

\end{chunk}

\defun{pfLambda?}{Is this a Lambda node?}
\calls{pfLambda?}{pfAbSynOp?}
\begin{chunk}{defun pfLambda?}
(defun |pfLambda?| (pf)
 (|pfAbSynOp?| pf '|Lambda|))

\end{chunk}

\defun{pfLambdaArgs}{Return the Args part of a Lambda node}
\begin{chunk}{defun pfLambdaArgs 0}
(defun |pfLambdaArgs| (pf)
 (cadr pf))

\end{chunk}

\defun{pf0LambdaArgs}{Return the Args of a Lambda Node}
\calls{pf0LambdaArgs}{pfParts}
\calls{pf0LambdaArgs}{pfLambdaArgs}
\begin{chunk}{defun pf0LambdaArgs}
(defun |pf0LambdaArgs| (pf)
 (|pfParts| (|pfLambdaArgs| pf)))

\end{chunk}

\defun{pfLocal}{Construct a Local node}
\calls{pfLocal}{pfTree}
\begin{chunk}{defun pfLocal}
(defun |pfLocal| (pfitems)
 (|pfTree| '|Local| (list pfitems)))

\end{chunk}

\defun{pfLocal?}{Is this a Local node?}
\calls{pfLocal?}{pfAbSynOp?}
\begin{chunk}{defun pfLocal?}
(defun |pfLocal?| (pf)
 (|pfAbSynOp?| pf '|Local|))

\end{chunk}

\defun{pf0LocalItems}{Return the parts of Items of a Local node}
\calls{pf0LocalItems}{pfParts}
\calls{pf0LocalItems}{pfLocalItems}
\begin{chunk}{defun pf0LocalItems}
(defun |pf0LocalItems| (pf)
 (|pfParts| (|pfLocalItems| pf)))

\end{chunk}

\defun{pfLocalItems}{Return the Items of a Local node}
\begin{chunk}{defun pfLocalItems 0}
(defun |pfLocalItems| (pf)
 (cadr pf))

\end{chunk}

\defun{pfLoop}{Construct a Loop node}
\calls{pfLoop}{pfTree}
\begin{chunk}{defun pfLoop}
(defun |pfLoop| (pfiterators)
 (|pfTree| '|Loop| (list pfiterators)))

\end{chunk}

\defun{pfLoop1}{pfLoop1}
\calls{pfLoop1}{pfLoop}
\calls{pfLoop1}{pfListOf}
\calls{pfLoop1}{pfDo}
\begin{chunk}{defun pfLoop1}
(defun |pfLoop1| (body)
 (|pfLoop| (|pfListOf| (list (|pfDo| body)))))

\end{chunk}

\defun{pfLoop?}{Is this a Loop node?}
\calls{pfLoop?}{pfAbSynOp?}
\begin{chunk}{defun pfLoop?}
(defun |pfLoop?| (pf)
 (|pfAbSynOp?| pf '|Loop|))

\end{chunk}

\defun{pfLoopIterators}{Return the Iterators of a Loop node}
\begin{chunk}{defun pfLoopIterators 0}
(defun |pfLoopIterators| (pf)
 (cadr pf))

\end{chunk}

\defun{pf0LoopIterators}{pf0LoopIterators}
\calls{pf0LoopIterators}{pfParts}
\calls{pf0LoopIterators}{pf0LoopIterators}
\begin{chunk}{defun pf0LoopIterators}
(defun |pf0LoopIterators| (pf)
 (|pfParts| (|pfLoopIterators| pf)))

\end{chunk}

\defun{pfLp}{pfLp}
\calls{pfLp}{pfLoop}
\calls{pfLp}{pfListOf}
\calls{pfLp}{pfDo}
\begin{chunk}{defun pfLp}
(defun |pfLp| (iterators body)
 (|pfLoop| (|pfListOf| (append iterators (list (|pfDo| body))))))

\end{chunk}

\defun{pfMacro}{Create a Macro node}
\calls{pfMacro}{pfTree}
\begin{chunk}{defun pfMacro}
(defun |pfMacro| (pflhs pfrhs)
 (|pfTree| '|Macro| (list pflhs pfrhs)))

\end{chunk}

\defun{pfMacro?}{Is this a Macro node?}
\calls{pfMacro?}{pfAbSynOp?}
\begin{chunk}{defun pfMacro?}
(defun |pfMacro?| (pf)
 (|pfAbSynOp?| pf '|Macro|))

\end{chunk}

\defun{pfMacroLhs}{Return the Lhs of a Macro node}
\begin{chunk}{defun pfMacroLhs 0}
(defun |pfMacroLhs| (pf)
 (cadr pf))

\end{chunk}

\defun{pfMacroRhs}{Return the Rhs of a Macro node}
\begin{chunk}{defun pfMacroRhs 0}
(defun |pfMacroRhs| (pf)
 (caddr pf))

\end{chunk}

\defun{pfMLambda}{Construct an MLambda node}
\calls{pfMLambda}{pfTree}
\begin{chunk}{defun pfMLambda}
(defun |pfMLambda| (pfargs pfbody)
 (|pfTree| '|MLambda| (list pfargs pfbody)))

\end{chunk}

\defun{pfMLambda?}{Is this an MLambda node?}
\calls{pfMLambda?}{pfAbSynOp?}
\begin{chunk}{defun pfMLambda?}
(defun |pfMLambda?| (pf)
 (|pfAbSynOp?| pf '|MLambda|))

\end{chunk}

\defun{pfMLambdaArgs}{Return the Args of an MLambda}
\begin{chunk}{defun pfMLambdaArgs 0}
(defun |pfMLambdaArgs| (pf)
 (cadr pf))

\end{chunk}

\defun{pf0MLambdaArgs}{Return the parts of an MLambda argument}
\calls{pf0MLambdaArgs}{pfParts}
\begin{chunk}{defun pf0MLambdaArgs}
(defun |pf0MLambdaArgs| (pf)
 (|pfParts| (|pfMLambdaArgs| pf)))

\end{chunk}

\defun{pfMLambdaBody}{pfMLambdaBody}
\begin{chunk}{defun pfMLambdaBody 0}
(defun |pfMLambdaBody| (pf)
 (caddr pf))

\end{chunk}

\defun{pfNot?}{Is this a Not node?}
\calls{pfNot?}{pfAbSynOp?}
\begin{chunk}{defun pfNot?}
(defun |pfNot?| (pf)
 (|pfAbSynOp?| pf '|Not|))

\end{chunk}

\defun{pfNotArg}{Return the Arg part of a Not node}
\begin{chunk}{defun pfNotArg 0}
(defun |pfNotArg| (pf)
 (cadr pf))

\end{chunk}

\defun{pfNovalue}{Construct a NoValue node}
\calls{pfNovalue}{pfTree}
\begin{chunk}{defun pfNovalue}
(defun |pfNovalue| (pfexpr)
 (|pfTree| '|Novalue| (list pfexpr)))

\end{chunk}

\defun{pfNovalue?}{Is this a Novalue node?}
\calls{pfNovalue?}{pfAbSynOp?}
\begin{chunk}{defun pfNovalue?}
(defun |pfNovalue?| (pf)
 (|pfAbSynOp?| pf '|Novalue|))

\end{chunk}

\defun{pfNovalueExpr}{Return the Expr part of a Novalue node}
\begin{chunk}{defun pfNovalueExpr 0}
(defun |pfNovalueExpr| (pf)
 (cadr pf))

\end{chunk}

\defun{pfOr}{Construct an Or node}
\calls{pfOr}{pfTree}
\begin{chunk}{defun pfOr}
(defun |pfOr| (pfleft pfright)
 (|pfTree| '|Or| (list pfleft pfright)))

\end{chunk}

\defun{pfOr?}{Is this an Or node?}
\calls{pfOr?}{pfAbSynOp?}
\begin{chunk}{defun pfOr?}
(defun |pfOr?| (pf)
 (|pfAbSynOp?| pf '|Or|))

\end{chunk}

\defun{pfOrLeft}{Return the Left part of an Or node}
\begin{chunk}{defun pfOrLeft 0}
(defun |pfOrLeft| (pf)
 (cadr pf))

\end{chunk}

\defun{pfOrRight}{Return the Right part of an Or node}
\begin{chunk}{defun pfOrRight 0}
(defun |pfOrRight| (pf)
 (caddr pf))

\end{chunk}

\defun{pfParen}{Return the part of a parenthesised expression}
\begin{chunk}{defun pfParen}
(defun |pfParen| (a part)
 (declare (ignore a))
 part)

\end{chunk}

\defun{pfPretend}{pfPretend}
\calls{pfPretend}{pfTree}
\begin{chunk}{defun pfPretend}
(defun |pfPretend| (pfexpr pftype)
 (|pfTree| '|Pretend| (list pfexpr pftype)))

\end{chunk}

\defun{pfPretend?}{Is this a Pretend node?}
\calls{pfPretend?}{pfAbSynOp?}
\begin{chunk}{defun pfPretend?}
(defun |pfPretend?| (pf)
 (|pfAbSynOp?| pf '|Pretend|))

\end{chunk}

\defun{pfPretendExpr}{Return the Expression part of a Pretend node}
\begin{chunk}{defun pfPretendExpr 0}
(defun |pfPretendExpr| (pf)
 (cadr pf))

\end{chunk}

\defun{pfPretendType}{Return the Type part of a Pretend node}
\begin{chunk}{defun pfPretendType 0}
(defun |pfPretendType| (pf)
 (caddr pf))

\end{chunk}

\defun{pfQualType}{Construct a QualType node}
\calls{pfQualType}{pfTree}
\begin{chunk}{defun pfQualType}
(defun |pfQualType| (pftype pfqual)
 (|pfTree| '|QualType| (list pftype pfqual)))

\end{chunk}

\defun{pfRestrict}{Construct a Restrict node}
\calls{pfRestrict}{pfTree}
\begin{chunk}{defun pfRestrict}
(defun |pfRestrict| (pfexpr pftype)
 (|pfTree| '|Restrict| (list pfexpr pftype)))

\end{chunk}

\defun{pfRestrict?}{Is this a Restrict node?}
\calls{pfRestrict?}{pfAbSynOp?}
\begin{chunk}{defun pfRestrict?}
(defun |pfRestrict?| (pf)
 (|pfAbSynOp?| pf '|Restrict|))

\end{chunk}

\defun{pfRestrictExpr}{Return the Expr part of a Restrict node}
\begin{chunk}{defun pfRestrictExpr 0}
(defun |pfRestrictExpr| (pf)
 (cadr pf))

\end{chunk}

\defun{pfRestrictType}{Return the Type part of a Restrict node}
\begin{chunk}{defun pfRestrictType 0}
(defun |pfRestrictType| (pf)
 (caddr pf))

\end{chunk}

\defun{pfRetractTo}{Construct a RetractTo node}
\calls{pfRetractTo}{pfTree}
\begin{chunk}{defun pfRetractTo}
(defun |pfRetractTo| (pfexpr pftype)
 (|pfTree| '|RetractTo| (list pfexpr pftype)))

\end{chunk}

\defun{pfReturn}{Construct a Return node}
\calls{pfReturn}{pfTree}
\begin{chunk}{defun pfReturn}
(defun |pfReturn| (pfexpr pffrom)
 (|pfTree| '|Return| (list pfexpr pffrom)))

\end{chunk}

\defun{pfReturn?}{Is this a Return node?}
\calls{pfReturn?}{pfAbSynOp?}
\begin{chunk}{defun pfReturn?}
(defun |pfReturn?| (pf)
 (|pfAbSynOp?| pf '|Return|))

\end{chunk}

\defun{pfReturnExpr}{Return the Expr part of a Return node}
\begin{chunk}{defun pfReturnExpr 0}
(defun |pfReturnExpr| (pf)
 (cadr pf))

\end{chunk}

\defun{pfReturnNoName}{pfReturnNoName}
\calls{pfReturnNoName}{pfReturn}
\calls{pfReturnNoName}{pfNothing}
\begin{chunk}{defun pfReturnNoName}
(defun |pfReturnNoName| (|value|)
 (|pfReturn| |value| (|pfNothing|)))

\end{chunk}

\defun{pfReturnTyped}{Construct a ReturnTyped node}
\calls{pfReturnTyped}{pfTree}
\begin{chunk}{defun pfReturnTyped}
(defun |pfReturnTyped| (type body)
 (|pfTree| '|returntyped| (list type body)))

\end{chunk}

\defun{pfRule}{Construct a Rule node}
\calls{pfRule}{pfTree}
\begin{chunk}{defun pfRule}
(defun |pfRule| (pflhsitems pfrhs)
 (|pfTree| '|Rule| (list pflhsitems pfrhs)))

\end{chunk}

\defun{pfRuleLhsItems}{Return the Lhs of a Rule node}
\begin{chunk}{defun pfRuleLhsItems 0}
(defun |pfRuleLhsItems| (pf)
 (cadr pf))

\end{chunk}

\defun{pfRuleRhs}{Return the Rhs of a Rule node}
\begin{chunk}{defun pfRuleRhs 0}
(defun |pfRuleRhs| (pf)
 (caddr pf))

\end{chunk}

\defun{pfRule?}{Is this a Rule node?}
\calls{pfRule?}{pfAbSynOp?}
\begin{chunk}{defun pfRule?}
(defun |pfRule?| (pf)
 (|pfAbSynOp?| pf '|Rule|))

\end{chunk}

\defun{pfSecond}{pfSecond}
\begin{chunk}{defun pfSecond 0}
(defun |pfSecond| (form)
 (caddr form))

\end{chunk}

\defun{pfSequence}{Construct a Sequence node}
\calls{pfSequence}{pfTree}
\begin{chunk}{defun pfSequence}
(defun |pfSequence| (pfargs)
 (|pfTree| '|Sequence| (list pfargs)))

\end{chunk}

\defun{pfSequenceArgs}{Return the Args of a Sequence node}
\begin{chunk}{defun pfSequenceArgs 0}
(defun |pfSequenceArgs| (pf)
 (cadr pf))

\end{chunk}

\defun{pfSequence?}{ Is this a Sequence node?}
\calls{pfSequence?}{pfAbSynOp?}
\begin{chunk}{defun pfSequence?}
(defun |pfSequence?| (pf)
 (|pfAbSynOp?| pf '|Sequence|))

\end{chunk}

\defun{pf0SequenceArgs}{Return the parts of the Args of a Sequence node}
\calls{pf0SequenceArgs}{pfParts}
\calls{pf0SequenceArgs}{pfSequenceArgs}
\begin{chunk}{defun pf0SequenceArgs}
(defun |pf0SequenceArgs| (pf)
 (|pfParts| (|pfSequenceArgs| pf)))

\end{chunk}

\defun{pfSuchthat}{Create a Suchthat node}
\calls{pfSuchthat}{pfTree}
\begin{chunk}{defun pfSuchthat}
(defun |pfSuchthat| (pfcond)
 (|pfTree| '|Suchthat| (list pfcond)))

\end{chunk}

\defun{pfSuchthat?}{Is this a SuchThat node?}
\calls{pfSuchthat?}{pfAbSynOp?}
\begin{chunk}{defun pfSuchthat?}
(defun |pfSuchthat?| (pf)
 (|pfAbSynOp?| pf '|Suchthat|))

\end{chunk}

\defun{pfSuchthatCond}{Return the Cond part of a SuchThat node}
\begin{chunk}{defun pfSuchthatCond 0}
(defun |pfSuchthatCond| (pf)
 (cadr pf))

\end{chunk}

\defun{pfTagged}{Create a Tagged node}
\calls{pfTagged}{pfTree}
\begin{chunk}{defun pfTagged}
(defun |pfTagged| (pftag pfexpr)
 (|pfTree| '|Tagged| (list pftag pfexpr)))

\end{chunk}

\defun{pfTagged?}{Is this a Tagged node?}
\calls{pfTagged?}{pfAbSynOp?}
\begin{chunk}{defun pfTagged?}
(defun |pfTagged?| (pf)
 (|pfAbSynOp?| pf '|Tagged|))

\end{chunk}

\defun{pfTaggedExpr}{Return the Expression portion of a Tagged node}
\begin{chunk}{defun pfTaggedExpr 0}
(defun |pfTaggedExpr| (pf)
 (caddr pf))

\end{chunk}

\defun{pfTaggedTag}{Return the Tag of a Tagged node}
\begin{chunk}{defun pfTaggedTag 0}
(defun |pfTaggedTag| (pf)
 (cadr pf))

\end{chunk}

\defun{pfTaggedToTyped}{pfTaggedToTyped}
\calls{pfTaggedToTyped}{pfTagged?}
\calls{pfTaggedToTyped}{pfTaggedExpr}
\calls{pfTaggedToTyped}{pfNothing}
\calls{pfTaggedToTyped}{pfTaggedTag}
\calls{pfTaggedToTyped}{pfId?}
\calls{pfTaggedToTyped}{pfId}
\calls{pfTaggedToTyped}{pfTyped}
\calls{pfTaggedToTyped}{pfSuch}
\calls{pfTaggedToTyped}{pfInfApplication}
\begin{chunk}{defun pfTaggedToTyped}
(defun |pfTaggedToTyped| (arg)
 (let (a form rt)
  (if (|pfTagged?| arg)
   (setq rt (|pfTaggedExpr| arg))
   (setq rt (|pfNothing|)))
  (if (|pfTagged?| arg)
   (setq form (|pfTaggedTag| arg))
   (setq form arg))
  (cond
   ((null (|pfId?| form))
    (setq a (|pfId| (gensym)))
    (|pfTyped| (|pfSuch| a (|pfInfApplication| (|pfId| '=) a form)) rt))
   (t (|pfTyped| form rt)))))

\end{chunk}

\defun{pfTweakIf}{pfTweakIf}
\calls{pfTweakIf}{pfIfElse}
\calls{pfTweakIf}{pfNothing?}
\calls{pfTweakIf}{pfListOf}
\calls{pfTweakIf}{pfTree}
\calls{pfTweakIf}{pfIfCond}
\calls{pfTweakIf}{pfIfThen}
\begin{chunk}{defun pfTweakIf}
(defun |pfTweakIf| (form)
 (let (b a)
  (setq a (|pfIfElse| form))
  (setq b (if (|pfNothing?| a) (|pfListOf| NIL) a))
  (|pfTree| '|WIf| (list (|pfIfCond| form) (|pfIfThen| form) b))))

\end{chunk}

\defun{pfTyped}{Construct a Typed node}
\calls{pfTyped}{pfTree}
\begin{chunk}{defun pfTyped}
(defun |pfTyped| (pfid pftype)
 (|pfTree| '|Typed| (list pfid pftype)))

\end{chunk}

\defun{pfTyped?}{Is this a Typed node?}
\calls{pfTyped?}{pfAbSynOp?}
\begin{chunk}{defun pfTyped?}
(defun |pfTyped?| (pf)
 (|pfAbSynOp?| pf '|Typed|))

\end{chunk}

\defun{pfTypedType}{Return the Type of a Typed node}
\begin{chunk}{defun pfTypedType 0}
(defun |pfTypedType| (pf)
 (caddr pf))

\end{chunk}

\defun{pfTypedId}{Return the Id of a Typed node}
\begin{chunk}{defun pfTypedId 0}
(defun |pfTypedId| (pf)
 (cadr pf))

\end{chunk}

\defun{pfTyping}{Construct a Typing node}
\calls{pfTyping}{pfTree}
\begin{chunk}{defun pfTyping}
(defun |pfTyping| (pfitems)
 (|pfTree| '|Typing| (list pfitems)))

\end{chunk}

\defun{pfTuple}{Return a Tuple node}
\calls{pfTuple}{pfTree}
\begin{chunk}{defun pfTuple}
(defun |pfTuple| (pfparts)
 (|pfTree| '|Tuple| (list pfparts)))

\end{chunk}

\defun{pfTupleListOf}{Return a Tuple from a List}
\calls{pfTupleListOf}{pfTuple}
\calls{pfTupleListOf}{pfListOf}
\begin{chunk}{defun pfTupleListOf}
(defun |pfTupleListOf| (pfparts)
 (|pfTuple| (|pfListOf| pfparts)))

\end{chunk}

\defun{pfTuple?}{Is this a Tuple node?}
\calls{pfTuple?}{pfAbSynOp?}
\begin{chunk}{defun pfTuple?}
(defun |pfTuple?| (pf)
 (|pfAbSynOp?| pf '|Tuple|))

\end{chunk}

\defun{pfTupleParts}{Return the Parts of a Tuple node}
\begin{chunk}{defun pfTupleParts 0}
(defun |pfTupleParts| (pf)
 (cadr pf))

\end{chunk}

\defun{pf0TupleParts}{Return the parts of a Tuple}
\calls{pf0TupleParts}{pfParts}
\calls{pf0TupleParts}{pfTupleParts}
\begin{chunk}{defun pf0TupleParts}
(defun |pf0TupleParts| (pf)
 (|pfParts| (|pfTupleParts| pf)))

\end{chunk}

\defun{pfUnSequence}{Return a list from a Sequence node}
\calls{pfUnSequence}{pfSequence?}
\calls{pfUnSequence}{pfAppend}
\calls{pfUnSequence}{pf0SequenceArgs}
\calls{pfUnSequence}{pfListOf}
\begin{chunk}{defun pfUnSequence}
(defun |pfUnSequence| (x)
 (if (|pfSequence?| x) 
  (|pfListOf| (|pfAppend| (|pf0SequenceArgs| x)))
  (|pfListOf| x)))

\end{chunk}

\defun{pfWDec}{The comment is attached to all signatutres}
\calls{pfWDec}{pfWDeclare}
\calls{pfWDec}{pfParts}
\begin{chunk}{defun pfWDec}
(defun |pfWDec| (doc name)
 (mapcar #'(lambda (i) (|pfWDeclare| i doc)) (|pfParts| name)))

\end{chunk}

\defun{pfWDeclare}{Construct a WDeclare node}
\calls{pfWDeclare}{pfTree}
\begin{chunk}{defun pfWDeclare}
(defun |pfWDeclare| (pfsignature pfdoc)
 (|pfTree| '|WDeclare| (list pfsignature pfdoc)))

\end{chunk}

\defun{pfWhere}{Construct a Where node}
\calls{pfWhere}{pfTree}
\begin{chunk}{defun pfWhere}
(defun |pfWhere| (pfcontext pfexpr)
 (|pfTree| '|Where| (list pfcontext pfexpr)))

\end{chunk}

\defun{pfWhere?}{Is this a Where node?}
\calls{pfWhere?}{pfAbSynOp?}
\begin{chunk}{defun pfWhere?}
(defun |pfWhere?| (pf)
 (|pfAbSynOp?| pf '|Where|))

\end{chunk}

\defun{pf0WhereContext}{Return the parts of the Context of a Where node}
\calls{pf0WhereContext}{pfParts}
\calls{pf0WhereContext}{pfWhereContext}
\begin{chunk}{defun pf0WhereContext}
(defun |pf0WhereContext| (pf)
 (|pfParts| (|pfWhereContext| pf)))

\end{chunk}

\defun{pfWhereContext}{Return the Context of a Where node}
\begin{chunk}{defun pfWhereContext 0}
(defun |pfWhereContext| (pf)
 (cadr pf))

\end{chunk}

\defun{pfWhereExpr}{Return the Expr part of a Where node}
\begin{chunk}{defun pfWhereExpr 0}
(defun |pfWhereExpr| (pf)
 (caddr pf))

\end{chunk}

\defun{pfWhile}{Construct a While node}
\calls{pfWhile}{pfTree}
\begin{chunk}{defun pfWhile}
(defun |pfWhile| (pfcond)
 (|pfTree| '|While| (list pfcond)))

\end{chunk}

\defun{pfWhile?}{Is this a While node?}
\calls{pfWhile?}{pfAbSynOp?}
\begin{chunk}{defun pfWhile?}
(defun |pfWhile?| (pf)
 (|pfAbSynOp?| pf '|While|))

\end{chunk}

\defun{pfWhileCond}{Return the Cond part of a While node}
\begin{chunk}{defun pfWhileCond 0}
(defun |pfWhileCond| (pf)
 (cadr pf))

\end{chunk}

\defun{pfWith}{Construct a With node}
\calls{pfWith}{pfTree}
\begin{chunk}{defun pfWith}
(defun |pfWith| (pfbase pfwithin pfwithon)
 (|pfTree| '|With| (list pfbase pfwithin pfwithon)))

\end{chunk}

\defun{pfWrong}{Create a Wrong node}
\calls{pfWrong}{pfTree}
\begin{chunk}{defun pfWrong}
(defun |pfWrong| (pfwhy pfrubble)
 (|pfTree| '|Wrong| (list pfwhy pfrubble)))

\end{chunk}

\defun{pfWrong?}{Is this a Wrong node?}
\calls{pfWrong?}{pfAbSynOp?}
\begin{chunk}{defun pfWrong?}
(defun |pfWrong?| (pf)
 (|pfAbSynOp?| pf '|Wrong|))

\end{chunk}

\chapter{Pftree to s-expression translation}
Pftree to s-expression translation.  Used to interface the new parser
technology to the interpreter.  The input is a parseTree and the
output is an old-parser-style s-expression.

\defun{pf2Sex}{Pftree to s-expression translation}
\calls{pf2Sex}{pf2Sex1}
\usesdollar{pf2Sex}{insideSEQ}
\usesdollar{pf2Sex}{insideApplication}
\usesdollar{pf2Sex}{insideRule}
\usesdollar{pf2Sex}{QuietCommand}
\begin{chunk}{defun pf2Sex}
(defun |pf2Sex| (pf)
 (let (|$insideSEQ| |$insideApplication| |$insideRule|)
 (declare (special |$insideSEQ| |$insideApplication| |$insideRule|
                   |$QuietCommand|))
  (setq |$QuietCommand| nil)
  (setq |$insideRule| nil)
  (setq |$insideApplication| nil)
  (setq |$insideSEQ| nil)
  (|pf2Sex1| pf)))

\end{chunk}

\defun{pf2Sex1}{Pftree to s-expression translation inner function}
\calls{pf2Sex1}{pfNothing?}
\calls{pf2Sex1}{pfSymbol?} 
\calls{pf2Sex1}{pfSymbolSymbol}
\calls{pf2Sex1}{pfLiteral?}
\calls{pf2Sex1}{pfLiteral2Sex}
\calls{pf2Sex1}{pfIdSymbol}
\calls{pf2Sex1}{pfApplication?}
\calls{pf2Sex1}{pfApplication2Sex}
\calls{pf2Sex1}{pfTuple?}
\calls{pf2Sex1}{pf2Sex1}
\calls{pf2Sex1}{pf0TupleParts}
\calls{pf2Sex1}{pfIf?}
\calls{pf2Sex1}{pfIfCond}
\calls{pf2Sex1}{pfIfThen}
\calls{pf2Sex1}{pfIfElse}
\calls{pf2Sex1}{pfTagged?}
\calls{pf2Sex1}{pfTaggedTag}
\calls{pf2Sex1}{pfTaggedExpr}
\calls{pf2Sex1}{pfCoerceto?}
\calls{pf2Sex1}{pfCoercetoExpr}
\calls{pf2Sex1}{pfCoercetoType}
\calls{pf2Sex1}{pfPretend?}
\calls{pf2Sex1}{pfPretendExpr}
\calls{pf2Sex1}{pfPretendType}
\calls{pf2Sex1}{pfFromdom?}
\calls{pf2Sex1}{opTran}
\calls{pf2Sex1}{pfFromdomWhat}
\calls{pf2Sex1}{pfFromdomDomain}
\calls{pf2Sex1}{pfSequence?}
\calls{pf2Sex1}{pfSequence2Sex}
\calls{pf2Sex1}{pfExit?}
\calls{pf2Sex1}{pfExitCond}
\calls{pf2Sex1}{pfExitExpr}
\calls{pf2Sex1}{pfLoop?}
\calls{pf2Sex1}{loopIters2Sex}
\calls{pf2Sex1}{pf0LoopIterators}
\calls{pf2Sex1}{pfCollect?}
\calls{pf2Sex1}{pfCollect2Sex}
\calls{pf2Sex1}{pfForin?}
\calls{pf2Sex1}{pf0ForinLhs}
\calls{pf2Sex1}{pfForinWhole}
\calls{pf2Sex1}{pfWhile?}
\calls{pf2Sex1}{pfWhileCond}
\calls{pf2Sex1}{pfSuchthat?}
\calls{pf2Sex1}{keyedSystemError}
\calls{pf2Sex1}{pfSuchthatCond}
\calls{pf2Sex1}{pfDo?}
\calls{pf2Sex1}{pfDoBody}
\calls{pf2Sex1}{pfTyped?}
\calls{pf2Sex1}{pfTypedType}
\calls{pf2Sex1}{pfTypedId}
\calls{pf2Sex1}{pfAssign?}
\calls{pf2Sex1}{pf0AssignLhsItems}
\calls{pf2Sex1}{pfAssignRhs}
\calls{pf2Sex1}{pfDefinition?}
\calls{pf2Sex1}{pfDefinition2Sex}
\calls{pf2Sex1}{pfLambda?}
\calls{pf2Sex1}{pfLambda2Sex}
\calls{pf2Sex1}{pfMLambda?}
\calls{pf2Sex1}{pfRestrict?}
\calls{pf2Sex1}{pfRestrictExpr}
\calls{pf2Sex1}{pfRestrictType}
\calls{pf2Sex1}{pfFree?}
\calls{pf2Sex1}{pf0FreeItems}
\calls{pf2Sex1}{pfLocal?}
\calls{pf2Sex1}{pf0LocalItems}
\calls{pf2Sex1}{pfWrong?}
\calls{pf2Sex1}{spadThrow}
\calls{pf2Sex1}{pfAnd?}
\calls{pf2Sex1}{pfAndLeft}
\calls{pf2Sex1}{pfAndRight}
\calls{pf2Sex1}{pfOr?}
\calls{pf2Sex1}{pfOrLeft}
\calls{pf2Sex1}{pfOrRight}
\calls{pf2Sex1}{pfNot?}
\calls{pf2Sex1}{pfNotArg}
\calls{pf2Sex1}{pfNovalue?}
\calls{pf2Sex1}{pfNovalueExpr}
\calls{pf2Sex1}{pfRule?}
\calls{pf2Sex1}{pfRule2Sex}
\calls{pf2Sex1}{pfBreak?}
\calls{pf2Sex1}{pfBreakFrom}
\calls{pf2Sex1}{pfMacro?}
\calls{pf2Sex1}{pfReturn?}
\calls{pf2Sex1}{pfReturnExpr}
\calls{pf2Sex1}{pfIterate?}
\calls{pf2Sex1}{pfWhere?}
\calls{pf2Sex1}{pf0WhereContext}
\calls{pf2Sex1}{pfWhereExpr}
\calls{pf2Sex1}{pfAbSynOp}
\calls{pf2Sex1}{tokPart}
\usesdollar{pf2Sex1}{insideSEQ}
\usesdollar{pf2Sex1}{insideRule}
\usesdollar{pf2Sex1}{QuietCommand}
\begin{chunk}{defun pf2Sex1}
(defun |pf2Sex1| (pf)
 (let (args idList type op tagPart tag s)
 (declare (special |$insideSEQ| |$insideRule| |$QuietCommand|))
  (cond
   ((|pfNothing?| pf) '|noBranch|)
   ((|pfSymbol?| pf)
    (if (eq |$insideRule| '|left|)
     (progn
      (setq s (|pfSymbolSymbol| pf))
      (list '|constant| (list 'quote s)))
     (list 'quote (|pfSymbolSymbol| pf))))
   ((|pfLiteral?| pf) (|pfLiteral2Sex| pf))
   ((|pfId?| pf)
     (if |$insideRule|
      (progn
        (setq s (|pfIdSymbol| pf))
        (if (member s '(|%pi| |%e| |%i|)) 
          s
          (list 'quote s)))
      (|pfIdSymbol| pf)))
   ((|pfApplication?| pf) (|pfApplication2Sex| pf))
   ((|pfTuple?| pf) (cons '|Tuple| (mapcar #'|pf2Sex1| (|pf0TupleParts| pf))))
   ((|pfIf?| pf)
     (list 'if (|pf2Sex1| (|pfIfCond| pf))
               (|pf2Sex1| (|pfIfThen| pf))
               (|pf2Sex1| (|pfIfElse| pf))))
   ((|pfTagged?| pf)
    (setq tag (|pfTaggedTag| pf))
    (setq tagPart
     (if (|pfTuple?| tag)
      (cons '|Tuple| (mapcar #'|pf2Sex1| (|pf0TupleParts| tag)))
      (|pf2Sex1| tag)))
    (list '|:| tagPart (|pf2Sex1| (|pfTaggedExpr| pf))))
   ((|pfCoerceto?| pf)
    (list '|::| (|pf2Sex1| (|pfCoercetoExpr| pf))
                (|pf2Sex1| (|pfCoercetoType| pf))))
   ((|pfPretend?| pf)
    (list '|pretend| (|pf2Sex1| (|pfPretendExpr| pf))
                     (|pf2Sex1| (|pfPretendType| pf))))
   ((|pfFromdom?| pf)
    (setq op (|opTran| (|pf2Sex1| (|pfFromdomWhat| pf))))
    (when (eq op '|braceFromCurly|) (setq op 'seq))
    (list '|$elt| (|pf2Sex1| (|pfFromdomDomain| pf)) op))
   ((|pfSequence?| pf) (|pfSequence2Sex| pf))
   ((|pfExit?| pf)
    (if |$insideSEQ|
     (list '|exit| (|pf2Sex1| (|pfExitCond| pf))
                   (|pf2Sex1| (|pfExitExpr| pf)))
     (list 'if (|pf2Sex1| (|pfExitCond| pf))
               (|pf2Sex1| (|pfExitExpr| pf)) '|noBranch|)))
   ((|pfLoop?| pf) (cons 'repeat (|loopIters2Sex| (|pf0LoopIterators| pf))))
   ((|pfCollect?| pf) (|pfCollect2Sex| pf))
   ((|pfForin?| pf)
    (cons 'in
     (append (mapcar #'|pf2Sex1| (|pf0ForinLhs| pf))
             (list (|pf2Sex1| (|pfForinWhole| pf))))))
   ((|pfWhile?| pf) (list 'while (|pf2Sex1| (|pfWhileCond| pf))))
   ((|pfSuchthat?| pf)
    (if (eq |$insideRule| '|left|)
     (|keyedSystemError| "Unexpected error in call to system function %1"
       (list "pf2Sex1: pfSuchThat"))
     (list '|\|| (|pf2Sex1| (|pfSuchthatCond| pf)))))
   ((|pfDo?| pf) (|pf2Sex1| (|pfDoBody| pf)))
   ((|pfTyped?| pf)
    (setq type (|pfTypedType| pf))
    (if (|pfNothing?| type) 
     (|pf2Sex1| (|pfTypedId| pf))
     (list '|:| (|pf2Sex1| (|pfTypedId| pf)) (|pf2Sex1| (|pfTypedType| pf)))))
   ((|pfAssign?| pf)
    (setq idList (mapcar #'|pf2Sex1| (|pf0AssignLhsItems| pf)))
    (if (not (eql (length idList) 1))
     (setq idList (cons '|Tuple| idList))
     (setq idList (car idList)))
    (list 'let idList (|pf2Sex1| (|pfAssignRhs| pf))))
   ((|pfDefinition?| pf) (|pfDefinition2Sex| pf))
   ((|pfLambda?| pf) (|pfLambda2Sex| pf))
   ((|pfMLambda?| pf) '|/throwAway|)
   ((|pfRestrict?| pf)
    (list '@ (|pf2Sex1| (|pfRestrictExpr| pf))
             (|pf2Sex1| (|pfRestrictType| pf))))
   ((|pfFree?| pf) (cons '|free| (mapcar #'|pf2Sex1| (|pf0FreeItems| pf))))
   ((|pfLocal?| pf) (cons '|local| (mapcar #'|pf2Sex1| (|pf0LocalItems| pf))))
   ((|pfWrong?| pf) (|spadThrow|))
   ((|pfAnd?| pf)
    (list '|and| (|pf2Sex1| (|pfAndLeft| pf))
                 (|pf2Sex1| (|pfAndRight| pf))))
   ((|pfOr?| pf)
    (list '|or| (|pf2Sex1| (|pfOrLeft| pf))
                (|pf2Sex1| (|pfOrRight| pf))))
   ((|pfNot?| pf) (list '|not| (|pf2Sex1| (|pfNotArg| pf))))
   ((|pfNovalue?| pf)
    (setq |$QuietCommand| t)
    (list 'seq (|pf2Sex1| (|pfNovalueExpr| pf))))
   ((|pfRule?| pf) (|pfRule2Sex| pf))
   ((|pfBreak?| pf) (list '|break| (|pfBreakFrom| pf)))
   ((|pfMacro?| pf) '|/throwAway|)
   ((|pfReturn?| pf) (list '|return| (|pf2Sex1| (|pfReturnExpr| pf))))
   ((|pfIterate?| pf) (list '|iterate|))
   ((|pfWhere?| pf)
    (setq args (mapcar #'|pf2Sex1| (|pf0WhereContext| pf)))
    (if (eql (length args) 1)
     (cons '|where| (cons (|pf2Sex1| (|pfWhereExpr| pf)) args))
     (list '|where| (|pf2Sex1| (|pfWhereExpr| pf)) (cons 'seq args))))
;  -- under strange circumstances/piling, system commands can wind
;  -- up in expressions. This just passes it through as a string for
;  -- the user to figure out what happened.
   ((eq (|pfAbSynOp| pf) '|command|) (|tokPart| pf))
   (t (|keyedSystemError| "Unexpected error in call to system function %1"
       (list "pf2Sex1"))))))

\end{chunk}

\defun{pfLiteral2Sex}{Convert a Literal to an S-expression}
\calls{pfLiteral2Sex}{pfLiteralClass}
\calls{pfLiteral2Sex}{pfLiteralString}
\calls{pfLiteral2Sex}{float2Sex}
\calls{pfLiteral2Sex}{pfSymbolSymbol}
\calls{pfLiteral2Sex}{pfLeafToken}
\calls{pfLiteral2Sex}{keyedSystemError}
\usesdollar{pfLiteral2Sex}{insideRule}
\begin{chunk}{defun pfLiteral2Sex}
(defun |pfLiteral2Sex| (pf)
 (let (s type)
 (declare (special |$insideRule|))
  (setq type (|pfLiteralClass| pf))
  (cond
   ((eq type '|integer|) (read-from-string (|pfLiteralString| pf)))
   ((or (eq type '|string|) (eq type '|char|))
    (|pfLiteralString| pf))
   ((eq type '|float|) (|float2Sex| (|pfLiteralString| pf)))
   ((eq type '|symbol|)
    (if |$insideRule|
     (progn
      (setq s (|pfSymbolSymbol| pf))
      (list 'quote s))
     (|pfSymbolSymbol| pf)))
   ((eq type '|expression|) (list 'quote (|pfLeafToken| pf)))
   (t 
    (|keyedSystemError| "Unexpected error in call to system function %1"
     (list "pfLiteral2Sex: unexpected form"))))))

\end{chunk}

\defun{float2Sex}{Convert a float to an S-expression}
\usesdollar{float2Sex}{useBFasDefault}
\begin{chunk}{defun float2Sex}
(defun |float2Sex| (num)
 (let (exp frac bfForm fracPartString intPart dotIndex expPart mantPart eIndex)
 (declare (special |$useBFasDefault|))
  (setq eIndex (search "e" num))
  (if eIndex
   (setq mantPart (subseq num 0 eIndex))
   (setq mantPart num))
  (if eIndex
   (setq expPart (read-from-string (subseq num (+ eIndex 1))))
   (setq expPart 0))
  (setq dotIndex (search "." mantPart))
  (if dotIndex
   (setq intPart (read-from-string (subseq mantPart 0 dotIndex)))
   (setq intPart (read-from-string mantPart)))
  (if dotIndex
   (setq fracPartString (subseq mantPart (+ dotIndex 1)))
   (setq fracPartString 0))
  (setq bfForm
   (make-float intPart (read-from-string fracPartString)
                         (length fracPartString) expPart))
  (if |$useBFasDefault|
   (progn
    (setq frac (cadr bfForm))
    (setq exp (cddr bfForm))
    (list (list '|$elt| (list '|Float|) '|float|) frac exp 10))
   bfForm)))

\end{chunk}

\defun{pfApplication2Sex}{Change an Application node to an S-expression}
\calls{pfApplication2Sex}{pfOp2Sex}
\calls{pfApplication2Sex}{pfApplicationOp}
\calls{pfApplication2Sex}{opTran}
\calls{pfApplication2Sex}{pf0TupleParts}
\calls{pfApplication2Sex}{pfApplicationArg}
\calls{pfApplication2Sex}{pfTuple?}
\calls{pfApplication2Sex}{pf2Sex1}
\calls{pfApplication2Sex}{pf2Sex}
\calls{pfApplication2Sex}{pfSuchThat2Sex}
\calls{pfApplication2Sex}{hasOptArgs?}
\usesdollar{pfApplication2Sex}{insideApplication}
\usesdollar{pfApplication2Sex}{insideRule}
\begin{chunk}{defun pfApplication2Sex}
(defun |pfApplication2Sex| (pf)
 (let (|$insideApplication| x val realOp tmp1 qt argSex typeList args op)
 (declare (special |$insideApplication| |$insideRule|))
  (setq |$insideApplication| t)
  (setq op (|pfOp2Sex| (|pfApplicationOp| pf)))
  (setq op (|opTran| op))
  (cond
   ((eq op '->)
     (setq args (|pf0TupleParts| (|pfApplicationArg| pf)))
     (if (|pfTuple?| (car args))
      (setq typeList (mapcar #'|pf2Sex1| (|pf0TupleParts| (car args))))
      (setq typeList (list (|pf2Sex1| (car args)))))
     (setq args (cons (|pf2Sex1| (cadr args)) typeList))
     (cons '|Mapping| args))
   ((and (eq op '|:|) (eq |$insideRule| '|left|))
    (list '|multiple| (|pf2Sex| (|pfApplicationArg| pf))))
   ((and (eq op '?) (eq |$insideRule| '|left|))
    (list '|optional| (|pf2Sex| (|pfApplicationArg| pf))))
   (t
    (setq args (|pfApplicationArg| pf))
    (cond
     ((|pfTuple?| args)
      (if (and (eq op '|\||) (eq |$insideRule| '|left|))
       (|pfSuchThat2Sex| args)
       (progn
        (setq argSex (cdr (|pf2Sex1| args)))
        (cond
         ((eq op '>) (list '< (cadr argSex) (car argSex)))
         ((eq op '>=) (list '|not| (list '< (car argSex) (cadr argSex))))
         ((eq op '<=) (list '|not| (list '< (cadr argSex) (car argSex))))
         ((eq op 'and) (list '|and| (car argSex) (cadr argSex)))
         ((eq op 'or) (list '|or| (car argSex) (cadr argSex)))
         ((eq op '|Iterate|) (list '|iterate|))
         ((eq op '|by|) (cons 'by argSex))
         ((eq op '|braceFromCurly|)
          (if (and (consp argSex) (eq (car argSex) 'seq))
           argSex
           (cons 'seq argSex)))
         ((and (consp op)
               (progn
                (setq qt (car op))
                (setq tmp1 (cdr op))
                (and (consp tmp1) 
                     (eq (cdr tmp1) nil)
                     (progn
                      (setq realOp (car tmp1))
                      t)))
               (eq qt 'quote))
          (cons '|applyQuote| (cons op argSex)))
         ((setq val (|hasOptArgs?| argSex)) (cons op val))
         (t (cons op argSex))))))
     ((and (consp op)
           (progn
            (setq qt (car op))
            (setq tmp1 (cdr op))
            (and (consp tmp1) 
                 (eq (cdr tmp1) NIL)
                 (progn
                  (setq realOp (car tmp1))
                  t)))
           (eq qt 'quote))
      (list '|applyQuote| op (|pf2Sex1| args)))
     ((eq op '|braceFromCurly|)
      (setq x (|pf2Sex1| args))
      (if (and (consp x) (eq (car x) 'seq))
       x
       (list 'seq x)))
     ((eq op '|by|) (list 'by (|pf2Sex1| args)))
     (t (list op (|pf2Sex1| args))))))))

\end{chunk}

\defun{pfSuchThat2Sex}{Convert a SuchThat node to an S-expression}
\calls{pfSuchThat2Sex}{pf0TupleParts}
\calls{pfSuchThat2Sex}{pf2Sex1}
\calls{pfSuchThat2Sex}{pf2Sex}
\usesdollar{pfSuchThat2Sex}{predicateList}
\begin{chunk}{defun pfSuchThat2Sex}
(defun |pfSuchThat2Sex| (args)
 (let (rhsSex lhsSex argList name)
 (declare (special |$predicateList|))
  (setq name (gentemp))
  (setq argList (|pf0TupleParts| args))
  (setq lhsSex (|pf2Sex1| (car argList)))
  (setq rhsSex (|pf2Sex| (cadr argList)))
  (setq |$predicateList|
   (cons (cons name (cons lhsSex rhsSex)) |$predicateList|))
  name))

\end{chunk}

\defun{pfOp2Sex}{pfOp2Sex}
\calls{pfOp2Sex}{pf2Sex1}
\calls{pfOp2Sex}{pmDontQuote?}
\calls{pfOp2Sex}{pfSymbol?}
\usesdollar{pfOp2Sex}{quotedOpList}
\usesdollar{pfOp2Sex}{insideRule}
\begin{chunk}{defun pfOp2Sex}
(defun |pfOp2Sex| (pf)
 (let (realOp tmp1 op alreadyQuoted)
 (declare (special |$quotedOpList| |$insideRule|))
  (setq alreadyQuoted (|pfSymbol?| pf))
  (setq op (|pf2Sex1| pf))
  (cond
   ((and (consp op)
         (eq (car op) 'quote)
         (progn
          (setq tmp1 (cdr op))
          (and (consp tmp1)
               (eq (cdr tmp1) nil)
               (progn
                (setq realOp (car tmp1)) t))))
    (cond
     ((eq |$insideRule| '|left|) realOp)
     ((eq |$insideRule| '|right|)
      (cond
       ((|pmDontQuote?| realOp) realOp)
       (t
        (setq |$quotedOpList| (cons op |$quotedOpList|))
        op)))
     ((eq realOp '|\||) realOp)
     ((eq realOp '|:|) realOp)
     ((eq realOp '?) realOp)
     (t op)))
   (t op))))

\end{chunk}

\defun{pmDontQuote?}{pmDontQuote?}
\begin{chunk}{defun pmDontQuote? 0}
(defun |pmDontQuote?| (sy)
 (member sy
  '(+ - * ** ^ / |log| |exp| |pi| |sqrt| |ei| |li| |erf| |ci|
      |si| |dilog| |sin| |cos| |tan| |cot| |sec| |csc| |asin|
      |acos| |atan| |acot| |asec| |acsc| |sinh| |cosh| |tanh|
      |coth| |sech| |csch| |asinh| |acosh| |atanh| |acoth|
      |asech| |acsc|)))

\end{chunk}

\defun{hasOptArgs?}{hasOptArgs?}
\begin{chunk}{defun hasOptArgs? 0}
(defun |hasOptArgs?| (argSex)
 (let (rhs  lhs opt nonOpt tmp1 tmp2)
 (dolist (arg argSex)
  (cond
   ((and (consp arg)
         (eq (car arg) 'optarg)
         (progn
          (setq tmp1 (cdr arg))
          (and (consp tmp1)
               (progn
                (setq lhs (car tmp1))
                (setq tmp2 (cdr tmp1))
                (and (consp tmp2)
                     (eq (cdr tmp2) nil)
                     (progn
                      (setq rhs (car tmp2))
                      t))))))
     (setq opt (cons (list lhs rhs) opt)))
    (t (setq nonOpt (cons arg nonOpt)))))
 (when opt
  (nconc (nreverse nonOpt) (list (cons '|construct| (nreverse opt)))))))

\end{chunk}

\defun{pfSequence2Sex}{Convert a Sequence node to an S-expression}
\calls{pfSequence2Sex}{pf2Sex1}
\calls{pfSequence2Sex}{pf0SequenceArgs}
\usesdollar{pfSequence2Sex}{insideSEQ}
\begin{chunk}{defun pfSequence2Sex}
(defun |pfSequence2Sex| (pf)
 (let (|$insideSEQ| tmp1 ruleList seq)
 (declare (special |$insideSEQ|))
  (setq |$insideSEQ| t)
  (setq seq (|pfSequence2Sex0| (mapcar #'|pf2Sex1| (|pf0SequenceArgs| pf))))
  (cond
   ((and (consp seq) 
         (eq (car seq) 'seq)
         (progn (setq ruleList (cdr seq)) 't)
         (consp ruleList)
         (progn
          (setq tmp1 (car ruleList))
          (and (consp tmp1) (eq (car tmp1) '|rule|))))
    (list '|ruleset| (cons '|construct| ruleList)))
   (t seq))))

\end{chunk}

\defun{pfSequence2Sex0}{pfSequence2Sex0}
\tpdhere{rewrite this using (dolist (item seqList)...)}
\begin{verbatim}
;pfSequence2Sex0 seqList ==
;  null seqList => "noBranch"
;  seqTranList := []
;  while seqList ^= nil repeat
;    item := first seqList
;    item is ["exit", cond, value] =>
;      item := ["IF", cond, value, pfSequence2Sex0 rest seqList]
;      seqTranList := [item, :seqTranList]
;      seqList := nil
;    seqTranList := [item ,:seqTranList]
;    seqList := rest seqList
;  #seqTranList = 1 => first seqTranList
;  ["SEQ", :nreverse seqTranList]
\end{verbatim}
\calls{pfSequence2Sex0}{pfSequence2Sex0}
\begin{chunk}{defun pfSequence2Sex0}
(defun |pfSequence2Sex0| (seqList)
 (let (value tmp2 cond tmp1 item seqTranList)
  (if (null seqList) 
   '|noBranch|
    (progn
     ((lambda ()
       (loop
        (if (not seqList) 
         (return nil)
         (progn
           (setq item (car seqList))
           (cond
            ((and (consp item) 
                  (eq (car item) '|exit|)
                  (progn
                   (setq tmp1 (cdr item))
                   (and (consp tmp1)
                        (progn
                         (setq cond (car tmp1))
                         (setq tmp2 (cdr tmp1))
                         (and (consp tmp2)
                              (eq (cdr tmp2) nil)
                              (progn
                               (setq value (car tmp2))
                               t))))))
               (setq item
                (list 'if cond value (|pfSequence2Sex0| (cdr seqList))))
               (setq seqTranList (cons item seqTranList))
               (setq seqList nil))
            (t
             (progn
              (setq seqTranList (cons item seqTranList))
              (setq seqList (cdr seqList))))))))))
     (if (eql (length seqTranList) 1) 
      (car seqTranList)
      (cons 'seq (nreverse seqTranList)))))))

\end{chunk}

\defun{loopIters2Sex}{Convert a loop node to an S-expression}
\tpdhere{rewrite using dsetq}
\begin{verbatim}
;loopIters2Sex iterList ==
;  result := nil
;  for iter in iterList repeat
;    sex := pf2Sex1 iter
;    sex is ['IN, var, ['SEGMENT, i, ["BY", incr]]] =>
;      result := [ ['STEP, var, i, incr], :result]
;    sex is ['IN, var, ["BY", ['SEGMENT, i, j], incr]] =>
;      result := [ ['STEP, var, i, incr, j], :result]
;    sex is ['IN, var, ['SEGMENT, i, j]] =>
;      result := [ ['STEP, var, i, 1, j], :result]
;    result := [sex, :result]
;  nreverse result
\end{verbatim}
\calls{loopIters2Sex}{pf2Sex1}
\begin{chunk}{defun loopIters2Sex}
(defun |loopIters2Sex| (iterList)
 (let (j incr i var sex result tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8)
  (dolist (iter iterList (nreverse result))
   (setq sex (|pf2Sex1| iter))
   (cond
    ((and (consp sex) 
          (eq (car sex) 'in)
          (progn
           (setq tmp1 (cdr sex))
           (and (consp tmp1)
                (progn
                 (setq var (car tmp1))
                 (setq tmp2 (cdr tmp1))
                 (and (consp tmp2)
                      (eq (cdr tmp2) nil)
                      (progn
                       (setq tmp3 (car tmp2))
                       (and (consp tmp3)
                            (eq (car tmp3) 'segment)
                            (progn
                             (setq tmp4 (cdr tmp3))
                             (and (consp tmp4)
                                  (progn
                                   (setq i (car tmp4))
                                   (setq tmp5 (cdr tmp4))
                                   (and (consp tmp5)
                                        (eq (cdr tmp5) nil)
                                        (progn
                                         (setq tmp6 (car tmp5))
                                         (and (consp tmp6)
                                              (eq (car tmp6) 'by)
                                              (progn
                                               (setq tmp7 (cdr tmp6))
                                               (and (consp tmp7)
                                                    (eq (cdr tmp7) nil)
                                                    (progn
                                                     (setq incr (car tmp7))
                                                     t))))))))))))))))
      (setq result (cons (list 'step var i incr) result)))
     ((and (consp sex) 
           (eq (car sex) 'in)
           (progn
            (setq tmp1 (cdr sex))
            (and (consp tmp1)
                 (progn
                  (setq var (car tmp1))
                  (setq tmp2 (cdr tmp1))
                  (and (consp tmp2)
                       (eq (cdr tmp2) nil)
                       (progn
                        (setq tmp3 (car tmp2))
                        (and (consp tmp3)
                             (eq (car tmp3) 'by)
                             (progn
                              (setq tmp4 (cdr tmp3))
                              (and (consp tmp4)
                               (progn
                                (setq tmp5 (car tmp4))
                                (and (consp tmp5)
                                     (eq (car tmp5) 'segment)
                                     (progn
                                      (setq tmp6 (cdr tmp5))
                                      (and (consp tmp6)
                                           (progn
                                            (setq i (car tmp6))
                                            (setq tmp7 (cdr tmp6))
                                            (and (consp tmp7)
                                                 (eq (cdr tmp7) nil)
                                                 (progn
                                                  (setq j (car tmp7))
                                                  t)))))))
                               (progn
                                (setq tmp8 (cdr tmp4))
                                (and (consp tmp8)
                                     (eq (cdr tmp8) nil)
                                     (progn
                                      (setq incr (car tmp8))
                                      t))))))))))))
      (setq result (cons (list 'step var i incr j) result)))
     ((and (consp sex) 
           (eq (car sex) 'in)
           (progn
            (setq tmp1 (cdr sex))
            (and (consp tmp1)
                 (progn
                  (setq var (car tmp1))
                  (setq tmp2 (cdr tmp1))
                  (and (consp tmp2)
                       (eq (cdr tmp2) nil)
                       (progn
                        (setq tmp3 (car tmp2))
                        (and (consp tmp3)
                             (eq (car tmp3) 'segment)
                             (progn
                              (setq tmp4 (cdr tmp3))
                              (and (consp tmp4)
                                   (progn
                                    (setq i (car tmp4))
                                    (setq tmp5 (cdr tmp4))
                                    (and (consp tmp5)
                                         (eq (cdr tmp5) nil)
                                         (progn
                                          (setq j (car tmp5))
                                          t))))))))))))
      (setq result (cons (list 'step var i 1 j) result)))
     (t (setq result (cons sex result)))))))

\end{chunk}

\defun{pfCollect2Sex}{Change a Collect node to an S-expression}
\calls{pfCollect2Sex}{loopIters2Sex}
\calls{pfCollect2Sex}{pfParts}
\calls{pfCollect2Sex}{pfCollectIterators}
\calls{pfCollect2Sex}{pf2Sex1}
\calls{pfCollect2Sex}{pfCollectBody}
\begin{chunk}{defun pfCollect2Sex}
(defun |pfCollect2Sex| (pf)
 (let (var cond sex tmp1 tmp2 tmp3 tmp4)
  (setq sex
   (cons 'collect
    (append (|loopIters2Sex| (|pfParts| (|pfCollectIterators| pf)))
            (list (|pf2Sex1| (|pfCollectBody| pf))))))
  (cond
   ((and (consp sex)
         (eq (car sex) 'collect)
         (progn
          (setq tmp1 (cdr sex))
          (and (consp tmp1)
               (progn
                (setq tmp2 (car tmp1))
                (and (consp tmp2)
                     (eq (car tmp2) '|\||)
                         (progn
                          (setq tmp3 (cdr tmp2))
                          (and (consp tmp3)
                               (eq (cdr tmp3) nil)
                               (progn
                                (setq cond (car tmp3))
                                t)))))
               (progn
                (setq tmp4 (cdr tmp1))
                (and (consp tmp4)
                     (eq (cdr tmp4) nil)
                         (progn (setq var (car tmp4)) t)))))
         (symbolp var))
    (list '|\|| var cond))
   (t sex))))

\end{chunk}

\defun{pfDefinition2Sex}{Convert a Definition node to an S-expression}
\calls{pfDefinition2Sex}{pf2Sex1}
\calls{pfDefinition2Sex}{pf0DefinitionLhsItems}
\calls{pfDefinition2Sex}{pfDefinitionRhs}
\calls{pfDefinition2Sex}{systemError}
\calls{pfDefinition2Sex}{pfLambdaTran}
\usesdollar{pfDefinition2Sex}{insideApplication}
\begin{chunk}{defun pfDefinition2Sex}
(defun |pfDefinition2Sex| (pf)
 (let (body argList tmp1 rhs id idList)
 (declare (special |$insideApplication|))
  (if |$insideApplication|
   (list 'optarg
    (|pf2Sex1| (car (|pf0DefinitionLhsItems| pf)))
    (|pf2Sex1| (|pfDefinitionRhs| pf)))
   (progn
    (setq idList (mapcar #'|pf2Sex1| (|pf0DefinitionLhsItems| pf)))
    (if (not (eql (length idList) 1))
     (|systemError| 
       "lhs of definition must be a single item in the interpreter")
     (progn
      (setq id (car idList))
      (setq rhs (|pfDefinitionRhs| pf))
      (setq tmp1 (|pfLambdaTran| rhs))
      (setq argList (car tmp1))
      (setq body (cdr tmp1))
      (cons 'def
       (cons
        (if (eq argList '|id|) 
         id
         (cons id argList))
        body))))))))

\end{chunk}

\defun{pfLambdaTran}{Convert a Lambda node to an S-expression}
\calls{pfLambdaTran}{pfLambda?}
\calls{pfLambdaTran}{pf0LambdaArgs}
\calls{pfLambdaTran}{pfTyped?}
\calls{pfLambdaTran}{pfCollectArgTran}
\calls{pfLambdaTran}{pfTypedId}
\calls{pfLambdaTran}{pfNothing?}
\calls{pfLambdaTran}{pfTypedType}
\calls{pfLambdaTran}{pf2Sex1}
\calls{pfLambdaTran}{systemError}
\calls{pfLambdaTran}{pfLambdaRets}
\calls{pfLambdaTran}{pfLambdaBody}
\begin{chunk}{defun pfLambdaTran}
(defun |pfLambdaTran| (pf)
 (let (retType argList argTypeList)
  (cond
   ((|pfLambda?| pf)
    (dolist (arg (|pf0LambdaArgs| pf))
     (if (|pfTyped?| arg)
      (progn
       (setq argList
        (cons (|pfCollectArgTran| (|pfTypedId| arg)) argList))
       (if (|pfNothing?| (|pfTypedType| arg))
        (setq argTypeList (cons nil argTypeList))
        (setq argTypeList 
         (cons (|pf2Sex1| (|pfTypedType| arg)) argTypeList))))
      (|systemError| "definition args should be typed")))
    (setq argList (nreverse argList))
    (unless (|pfNothing?| (|pfLambdaRets| pf))
     (setq retType (|pf2Sex1| (|pfLambdaRets| pf))))
    (setq argTypeList (cons retType (nreverse argTypeList)))
    (cons argList
     (list argTypeList 
           (mapcar #'(lambda (x) (declare (ignore x)) nil) argTypeList)
           (|pf2Sex1| (|pfLambdaBody| pf)))))
   (t (cons '|id| (list '(nil) '(nil) (|pf2Sex1| pf)))))))

\end{chunk}

\defun{pfCollectArgTran}{pfCollectArgTran}
\calls{pfCollectArgTran}{pfCollect?}
\calls{pfCollectArgTran}{pf2sex1}
\calls{pfCollectArgTran}{pfParts}
\calls{pfCollectArgTran}{pfCollectIterators}
\calls{pfCollectArgTran}{pfCollectBody}
\begin{chunk}{defun pfCollectArgTran}
(defun |pfCollectArgTran| (pf)
 (let (cond tmp2 tmp1 id conds)
  (cond
   ((|pfCollect?| pf)
    (setq conds (mapcar #'|pf2sex1| (|pfParts| (|pfCollectIterators| pf))))
    (setq id (|pf2Sex1| (|pfCollectBody| pf)))
    (cond
     ((and (consp conds)                   ; conds is [ ["|", cond] ] 
           (eq (cdr conds) nil)
           (progn
            (setq tmp1 (car conds))
            (and (consp tmp1) 
                 (eq (car tmp1) '|\||)
                 (progn
                  (setq tmp2 (cdr tmp1))
                  (and (consp tmp2)
                       (eq (cdr tmp2) nil)
                       (progn
                        (setq cond (car tmp2))
                        t))))))
              (list '|\|| id cond))
     (t (cons id conds))))
   (t (|pf2Sex1| pf)))))

\end{chunk}

\defun{pfLambda2Sex}{Convert a Lambda node to an S-expression}
\calls{pfLambda2Sex}{pfLambdaTran}
\begin{chunk}{defun pfLambda2Sex}
(defun |pfLambda2Sex| (pf)
 (let (body argList tmp1)
  (setq tmp1 (|pfLambdaTran| pf))
  (setq argList (car tmp1))
  (setq body (cdr tmp1))
  (cons 'adef (cons argList body))))

\end{chunk}

\defun{pfRule2Sex}{Convert a Rule node to an S-expression}
\calls{pfRule2Sex}{pfLhsRule2Sex}
\calls{pfRule2Sex}{pfRuleLhsItems}
\calls{pfRule2Sex}{pfRhsRule2Sex}
\calls{pfRule2Sex}{pfRuleRhs}
\calls{pfRule2Sex}{ruleLhsTran}
\calls{pfRule2Sex}{rulePredicateTran}
\usesdollar{pfRule2Sex}{multiVarPredicateList}
\usesdollar{pfRule2Sex}{predicateList}
\usesdollar{pfRule2Sex}{quotedOpList}
\begin{chunk}{defun pfRule2Sex}
(defun |pfRule2Sex| (pf)
 (let (|$multiVarPredicateList| |$predicateList| |$quotedOpList| rhs lhs)
 (declare (special |$multiVarPredicateList| |$predicateList| |$quotedOpList|))
  (setq |$quotedOpList| nil)
  (setq |$predicateList| nil)
  (setq |$multiVarPredicateList| nil)
  (setq lhs (|pfLhsRule2Sex| (|pfRuleLhsItems| pf)))
  (setq rhs (|pfRhsRule2Sex| (|pfRuleRhs| pf)))
  (setq lhs (|ruleLhsTran| lhs))
  (|rulePredicateTran|
   (if |$quotedOpList|
    (list '|rule| lhs rhs (cons '|construct| |$quotedOpList|))
    (list '|rule| lhs rhs)))))

\end{chunk}

\defun{pfLhsRule2Sex}{Convert the Lhs of a Rule to an S-expression}
\calls{pfLhsRule2Sex}{pf2Sex1}
\usesdollar{pfLhsRule2Sex}{insideRule}
\begin{chunk}{defun pfLhsRule2Sex}
(defun |pfLhsRule2Sex| (lhs)
 (let (|$insideRule|)
 (declare (special |$insideRule|))
  (setq |$insideRule| '|left|)
  (|pf2Sex1| lhs)))

\end{chunk}

\defun{pfRhsRule2Sex}{Convert the Rhs of a Rule to an S-expression}
\calls{pfRhsRule2Sex}{pf2Sex1}
\usesdollar{pfRhsRule2Sex}{insideRule}
\begin{chunk}{defun pfRhsRule2Sex}
(defun |pfRhsRule2Sex| (rhs)
 (let (|$insideRule|)
 (declare (special |$insideRule|))
  (setq |$insideRule| '|right|)
  (|pf2Sex1| rhs)))

\end{chunk}

\defun{rulePredicateTran}{Convert a Rule predicate to an S-expression}
\begin{verbatim}
;rulePredicateTran rule ==
;  null $multiVarPredicateList => rule
;  varList := patternVarsOf [rhs for [.,.,:rhs] in $multiVarPredicateList]
;  predBody :=
;    CDR $multiVarPredicateList =>
;      ['AND, :[:pvarPredTran(rhs, varList) for [.,.,:rhs] in
;        $multiVarPredicateList]]
;    [ [.,.,:rhs],:.] := $multiVarPredicateList
;    pvarPredTran(rhs, varList)
;  ['suchThat, rule,
;   ['construct, :[ ["QUOTE", var] for var in varList]],
;    ['ADEF, '(predicateVariable),
;     '((Boolean) (List (Expression (Integer)))), '(() ()),
;      predBody]]
\end{verbatim}
\calls{rulePredicateTran}{patternVarsOf}
\calls{rulePredicateTran}{pvarPredTran}
\usesdollar{rulePredicateTran}{multiVarPredicateList}
\begin{chunk}{defun rulePredicateTran}
(defun |rulePredicateTran| (rule)
 (let (predBody varList rhs tmp1 result)
 (declare (special |$multiVarPredicateList|))
  (if (null |$multiVarPredicateList|) 
   rule
   (progn
   (setq varList
    (|patternVarsOf|
     ((lambda (t1 t2 t3)
      (loop
       (cond
        ((or (atom t2)
             (progn
              (setq t3 (car t2))
              nil))
           (return (nreverse t1)))
        (t
         (and (consp t3)
              (progn
               (setq tmp1 (cdr t3))
               (and (consp tmp1)
                    (progn
                     (setq rhs (cdr tmp1))
                     t)))
              (setq t1 (cons rhs t1)))))
       (setq t2 (cdr t2))))
      nil |$multiVarPredicateList| nil)))
   (setq predBody
    (cond
     ((cdr |$multiVarPredicateList|)
      (cons 'and
       ((lambda (t4 t5 t6)
        (loop
         (cond
          ((or (atom t5)
               (progn
                (setq t6 (car t5))
                nil))
            (return (nreverse t4)))
          (t
           (and (consp t6)
                (progn
                 (setq tmp1 (cdr t6))
                 (and (consp tmp1)
                      (progn
                       (setq rhs (cdr tmp1))
                       t)))
                      (setq t4
                       (append (reverse (|pvarPredTran| rhs varList))
                               t4)))))
         (setq t5 (cdr t5))))
        nil |$multiVarPredicateList| nil)))
     (t
      (progn
       (setq rhs (cddar |$multiVarPredicateList|))
       (|pvarPredTran| rhs varList)))))
   (dolist (var varList) (push (list 'quote var) result))
   (list '|suchThat| rule
    (cons '|construct| (nreverse result))
    (list 'adef '(|predicateVariable|)
                       '((|Boolean|)
                         (|List| (|Expression| (|Integer|))))
                       '(nil nil) predBody))))))

\end{chunk}

\defun{patternVarsOf}{patternVarsOf}
\calls{patternVarsOf}{patternVarsOf1}
\begin{chunk}{defun patternVarsOf}
(defun |patternVarsOf| (expr)
 (|patternVarsOf1| expr nil))

\end{chunk}

\defun{patternVarsOf1}{patternVarsOf1}
\calls{patternVarsOf1}{patternVarsOf1}
\begin{chunk}{defun patternVarsOf1}
(defun |patternVarsOf1| (expr varList)
 (let (argl op)
  (cond
   ((null expr) varList)
   ((atom expr)
    (cond
     ((null (symbolp expr)) varList)
     ((member expr varList) varList)
     (t (cons expr varList))))
   ((and (consp expr)
         (progn
          (setq op (car expr))
          (setq argl (cdr expr))
          t))
         (progn
           (dolist (arg argl) 
            (setq varList (|patternVarsOf1| arg varList)))
            varList))
   (t varList))))

\end{chunk}

\defun{pvarPredTran}{pvarPredTran}
\begin{chunk}{defun pvarPredTran}
(defun |pvarPredTran| (rhs varList)
 (let ((i 0))
  (dolist (var varList rhs)
   (setq rhs (nsubst (list '|elt| '|predicateVariable| (incf i)) var rhs)))))

\end{chunk}

\defun{ruleLhsTran}{Convert the Lhs of a Rule node to an S-expression}
\calls{ruleLhsTran}{patternVarsOf}
\calls{ruleLhsTran}{nsubst}
\usesdollar{ruleLhsTran}{predicateList}
\usesdollar{ruleLhsTran}{multiVarPredicateList}
\begin{chunk}{defun ruleLhsTran}
(defun |ruleLhsTran| (ruleLhs)
 (let (predicate var vars predRhs predLhs name)
 (declare (special |$predicateList| |$multiVarPredicateList|))
 (dolist (pred |$predicateList|)
  (setq name (car pred))
  (setq predLhs (cadr pred))
  (setq predRhs (cddr pred))
  (setq vars (|patternVarsOf| predRhs))
  (cond
   ((cdr vars)
    (setq ruleLhs (nsubst predLhs name ruleLhs))
    (setq |$multiVarPredicateList| (cons pred |$multiVarPredicateList|)))
   (t
    (setq var (cadr predLhs))
    (setq predicate
      (list '|suchThat| predLhs (list 'adef (list var)
            '((|Boolean|) (|Expression| (|Integer|))) '(nil nil) predRhs)))
    (setq ruleLhs (nsubst predicate name ruleLhs)))))
  ruleLhs))

\end{chunk}

\defun{opTran}{Translate ops into internal symbols}
\begin{chunk}{defun opTran 0}
(defun |opTran| (op)
 (cond
  ((equal op '|..|) 'segment)
  ((eq op '[]) '|construct|)
  ((eq op '{}) '|braceFromCurly|)
  ((eq op 'is) '|is|)
  (t op)))

\end{chunk}

\chapter{Stream Utilities}
The input stream is parsed into a large s-expression by repeated calls
to Delay. Delay takes a function f and an argument x and returns a list
consisting of \verb|("nonnullstream" f x)|. Eventually multiple calls are made
and a large list structure is created that consists of 
\verb|("nonnullstream" f x ("nonnullstream" f1 x1 ("nonnullstream" f2 x2...|

This delay structure is given to StreamNull which walks along the
list looking at the head. If the head is ``nonnullstream'' then the
function is applied to the argument.

So, in effect, the input is ``zipped up'' into a Delay data structure
which is then evaluated by calling StreamNull. This "zippered stream"
parser was a research project at IBM and Axiom was the testbed (which
explains the strange parsing technique).

\defun{npNull}{npNull}
\calls{npNull}{StreamNull}
\begin{chunk}{defun npNull}
(defun |npNull| (x) (|StreamNull| x))

\end{chunk}

\defun{StreamNull}{StreamNull}
\calls{StreamNull}{eqcar}
\label{StreamNull}
\sig{StreamNull}{Delay}{Union(T,NIL)}
\begin{chunk}{defun StreamNull 0}
(defun |StreamNull| (delay)
 (let (parsepair)
  (cond
   ((or (null delay) (eqcar delay '|nullstream|)) t)
   (t
    ((lambda nil
     (loop
      (cond
       ((not (eqcar delay '|nonnullstream|)) (return nil))
       (t
        (setq parsepair (apply (cadr delay) (cddr delay)))
        (rplaca delay (car parsepair))
        (rplacd delay (cdr parsepair)))))))
      (eqcar delay '|nullstream|)))))

\end{chunk}

\chapter{Code Piles}
The insertpiles function converts a line-list to a line-forest where
a line is a token-dequeue and has a column which is an integer.
An A-forest is an A-tree-list
An A-tree has a root which is an A, and subtrees which is an A-forest.
 
A forest with more than one tree corresponds to a Scratchpad pile
structure (t1;t2;t3;...;tn), and a tree corresponds to a pile item.
The ( ; and ) tokens are inserted into a >1-forest, otherwise
the root of the first tree is concatenated with its forest.
column t is the number of spaces before the first non-space in line t

\defun{insertpile}{insertpile}
\calls{insertpile}{npNull}
\calls{insertpile}{pilePlusComment}
\calls{insertpile}{pilePlusComments}
\calls{insertpile}{pileTree}
\calls{insertpile}{pileCforest}
\begin{chunk}{defun insertpile}
(defun |insertpile| (s)
 (let (stream a t1 h1 t2 h tmp1)
  (cond
   ((|npNull| s) (list nil 0 nil s))
   (t
    (setq tmp1 (list (car s) (cdr s)))
    (setq h (car tmp1)) 
    (setq t2 (cadr tmp1))
    (cond
     ((|pilePlusComment| h)
       (setq tmp1 (|pilePlusComments| s))
       (setq h1 (car tmp1))
       (setq t1 (cadr tmp1))
       (setq a (|pileTree| (- 1) t1))
       (cons (list (|pileCforest|
                       (append h1 (cons (elt a 2) nil))))
             (elt a 3)))
     (t
      (setq stream (cadar s))
      (setq a (|pileTree| -1 s))
      (cons (list (list (elt a 2) stream)) (elt a 3))))))))

\end{chunk}

\defun{pilePlusComment}{pilePlusComment}
\calls{pilePlusComment}{tokType}
\calls{pilePlusComments}{npNull}
\calls{pilePlusComments}{pilePlusComment}
\calls{pilePlusComments}{pilePlusComments}
\begin{chunk}{defun pilePlusComment}
(defun |pilePlusComment| (arg)
 (eq (|tokType| (caar arg)) '|comment|))

\end{chunk}
\defun{pilePlusComments}{pilePlusComments}
\begin{chunk}{defun pilePlusComments}
(defun |pilePlusComments| (s)
 (let (t1 h1 t2 h tmp1)
  (cond
   ((|npNull| s) (list nil s))
   (t
    (setq tmp1 (list (car s) (cdr s)))
    (setq h (car tmp1))
    (setq t2 (cadr tmp1))
    (cond
     ((|pilePlusComment| h)
      (setq tmp1 (|pilePlusComments| t2))
      (setq h1 (car tmp1))
      (setq t1 (cadr tmp1))
      (list (cons h h1) t1))
     (t 
      (list nil s)))))))

\end{chunk}

\defun{pileTree}{pileTree}
\calls{pileTree}{npNull}
\calls{pileTree}{pileColumn}
\calls{pileTree}{pileForests}
\begin{chunk}{defun pileTree}
(defun |pileTree| (n s)
 (let (hh t1 h tmp1)
  (cond
   ((|npNull| s) (list nil n nil s))
   (t
    (setq tmp1 (list (car s) (cdr s)))
    (setq h (car tmp1))
    (setq t1 (cadr tmp1))
    (setq hh (|pileColumn| (car h)))
    (cond
     ((< n hh) (|pileForests| (car h) hh t1))
     (t (list nil n nil s)))))))

\end{chunk}

\defun{pileColumn}{pileColumn}
\calls{pileColumn}{tokPosn}
\begin{chunk}{defun pileColumn}
(defun |pileColumn| (arg)
 (cdr (|tokPosn| (caar arg))))

\end{chunk}

\defun{pileForests}{pileForests}
\calls{pileForests}{pileForest}
\calls{pileForests}{npNull}
\calls{pileForests}{pileForests}
\calls{pileForests}{pileCtree}
\begin{chunk}{defun pileForests}
(defun |pileForests| (h n s)
 (let (t1 h1 tmp1)
  (setq tmp1 (|pileForest| n s))
  (setq h1 (car tmp1))
  (setq t1 (cadr tmp1))
  (cond
   ((|npNull| h1) (list t n h s))
   (t (|pileForests| (|pileCtree| h h1) n t1)))))

\end{chunk}

\defun{pileForest}{pileForest}
\calls{pileForest}{pileTree}
\calls{pileForest}{pileForest1}
\begin{chunk}{defun pileForest}
(defun |pileForest| (n s)
 (let (t1 h1 t2 h hh b tmp)
  (setq tmp (|pileTree| n s))
  (setq b (car tmp))
  (setq hh (cadr tmp))
  (setq h (caddr tmp))
  (setq t2 (cadddr tmp))
  (cond
   (b
    (setq tmp (|pileForest1| hh t2))
    (setq h1 (car tmp))
    (setq t1 (cadr tmp))
    (list (cons h h1) t1))
   (t 
    (list nil s)))))

\end{chunk}

\defun{pileForest1}{pileForest1}
\calls{pileForest1}{eqpileTree}
\calls{pileForest1}{pileForest1}
\begin{chunk}{defun pileForest1}
(defun |pileForest1| (n s)
 (let (t1 h1 t2 h n1 b tmp)
  (setq tmp (|eqpileTree| n s))
  (setq b (car tmp))
  (setq n1 (cadr tmp))
  (setq h (caddr tmp))
  (setq t2 (cadddr tmp))
  (cond
   (b
    (setq tmp (|pileForest1| n t2))
    (setq h1 (car tmp))
    (setq t1 (cadr tmp))
    (list (cons h h1) t1))
   (t (list nil s)))))

\end{chunk}

\defun{eqpileTree}{eqpileTree}
\calls{eqpileTree}{npNull}
\calls{eqpileTree}{pileColumn}
\calls{eqpileTree}{pileForests}
\begin{chunk}{defun eqpileTree}
(defun |eqpileTree| (n s)
 (let (hh t1 h tmp)
  (cond
   ((|npNull| s) (list nil n nil s))
   (t
    (setq tmp (list (car s) (cdr s)))
    (setq h (car tmp))
    (setq t1 (cadr tmp))
    (setq hh (|pileColumn| (car h)))
    (cond
     ((equal hh n) (|pileForests| (car h) hh t1))
     (t (list nil n nil s)))))))

\end{chunk}

\defun{pileCtree}{pileCtree}
\calls{pileCtree}{dqAppend}
\calls{pileCtree}{pileCforest}
\begin{chunk}{defun pileCtree}
(defun |pileCtree| (x y)
 (|dqAppend| x (|pileCforest| y)))

\end{chunk}

\defun{pileCforest}{pileCforest}
Only enpiles forests with $>=2$ trees

\calls{pileCforest}{tokPart}
\calls{pileCforest}{enPile}
\calls{pileCforest}{separatePiles}
\begin{chunk}{defun pileCforest}
(defun |pileCforest| (x)
 (let (f)
  (cond
   ((null x) nil)
   ((null (cdr x)) (setq f (car x))
    (cond
     ((eq (|tokPart| (caar f)) 'if) (|enPile| f))
     (t f)))
   (t (|enPile| (|separatePiles| x))))))

\end{chunk}

\defun{enPile}{enPile}
\calls{enPile}{dqConcat}
\calls{enPile}{dqUnit}
\calls{enPile}{tokConstruct}
\calls{enPile}{firstTokPosn}
\calls{enPile}{lastTokPosn}
\begin{chunk}{defun enPile}
(defun |enPile| (x)
 (|dqConcat|
  (list
   (|dqUnit| (|tokConstruct| '|key| 'settab (|firstTokPosn| x)))
   x
   (|dqUnit| (|tokConstruct| '|key| 'backtab (|lastTokPosn| x))))))

\end{chunk}

\defun{firstTokPosn}{firstTokPosn}
\calls{firstTokPosn}{tokPosn}
\begin{chunk}{defun firstTokPosn}
(defun |firstTokPosn| (arg) (|tokPosn| (caar arg)))

\end{chunk}

\defun{lastTokPosn}{lastTokPosn}
\calls{lastTokPosn}{tokPosn}
\begin{chunk}{defun lastTokPosn}
(defun |lastTokPosn| (arg) (|tokPosn| (cadr arg)))

\end{chunk}

\defun{separatePiles}{separatePiles}
\calls{separatePiles}{dqUnit}
\calls{separatePiles}{tokConstruct}
\calls{separatePiles}{lastTokPosn}
\calls{separatePiles}{dqConcat}
\calls{separatePiles}{separatePiles}
\begin{chunk}{defun separatePiles}
(defun |separatePiles| (x)
 (let (semicolon a)
  (cond
   ((null x) nil)
   ((null (cdr x)) (car x))
   (t 
    (setq a (car x))
    (setq semicolon
      (|dqUnit| (|tokConstruct| '|key| 'backset (|lastTokPosn| a))))
    (|dqConcat| (list a semicolon (|separatePiles| (cdr x))))))))

\end{chunk}

\chapter{Dequeue Functions}
The dqUnit makes a unit dq i.e. a dq with one item, from the item
\defun{dqUnit}{dqUnit}
\begin{chunk}{defun dqUnit 0}
(defun |dqUnit| (s)
 (let (a)
  (setq a (list s))
  (cons a a)))

\end{chunk}

\defun{dqConcat}{dqConcat}
The dqConcat function concatenates a list of dq's, destroying all but the last

\calls{dqConcat}{dqAppend}
\calls{dqConcat}{dqConcat}
\begin{chunk}{defun dqConcat}
(defun |dqConcat| (ld)
 (cond
  ((null ld) nil)
  ((null (cdr ld)) (car ld))
  (t (|dqAppend| (car ld) (|dqConcat| (cdr ld))))))

\end{chunk}

\defun{dqAppend}{dqAppend}
The dqAppend function appends 2 dq's, destroying the first
\begin{chunk}{defun dqAppend 0}
(defun |dqAppend| (x y)
 (cond
  ((null x) y)
  ((null y) x)
  (t 
   (rplacd (cdr x) (car y))
   (rplacd x (cdr y)) x)))

\end{chunk}

\defun{dqToList}{dqToList}
\begin{chunk}{defun dqToList 0}
(defun |dqToList| (s)
 (when s (car s)))

\end{chunk}

\chapter{Message Handling}

\section{The Line Object}

\defun{lnCreate}{Line object creation}
This is called in only one place, the incLine1 function.
\begin{chunk}{defun lnCreate 0}
(defun |lnCreate| (extraBlanks string globalNum &rest optFileStuff)
 (let ((localNum (first optFileStuff))
       (filename (second optFileStuff)))
  (unless localNum (setq localNum 0))
  (list extraBlanks string globalNum localNum filename)))

\end{chunk}

\defun{lnExtraBlanks}{Line element 0; Extra blanks}
\begin{chunk}{defun lnExtraBlanks 0}
(defun |lnExtraBlanks| (lineObject) (elt lineObject 0))

\end{chunk}

\defun{lnString}{Line element 1; String}
\begin{chunk}{defun lnString 0}
(defun |lnString| (lineObject) (elt lineObject 1))

\end{chunk}

\defun{lnGlobalNum}{Line element 2; Globlal number}
\begin{chunk}{defun lnGlobalNum 0}
(defun |lnGlobalNum| (lineObject) (elt lineObject 2))

\end{chunk}

\defun{lnSetGlobalNum}{Line element 2; Set Global number}
\begin{chunk}{defun lnSetGlobalNum 0}
(defun |lnSetGlobalNum| (lineObject num)
 (setf (elt lineObject 2) num))

\end{chunk}

\defun{lnLocalNum}{Line elemnt 3; Local number}
\begin{chunk}{defun lnLocalNum 0}
(defun |lnLocalNum| (lineObject) (elt lineObject 3))

\end{chunk}

\defun{lnPlaceOfOrigin}{Line element 4; Place of origin}
\begin{chunk}{defun lnPlaceOfOrigin 0}
(defun |lnPlaceOfOrigin| (lineObject) (elt lineObject 4))

\end{chunk}

\defun{lnImmediate?}{Line element 4: Is it a filename?}
\calls{lnImmediate?}{lnFileName?}
\begin{chunk}{defun lnImmediate? 0}
(defun |lnImmediate?| (lineObject) (null (|lnFileName?| lineObject)))

\end{chunk}

\defun{lnFileName?}{Line element 4: Is it a filename?}
\begin{chunk}{defun lnFileName? 0}
(defun |lnFileName?| (lineObject)
 (let (filename)
  (when (consp (setq filename (elt lineObject 4))) filename)))

\end{chunk}

\defun{lnFileName}{Line element 4; Get filename}
\calls{lnFileName}{lnFileName?}
\calls{lnFileName}{ncBug}
\begin{chunk}{defun lnFileName}
(defun |lnFileName| (lineObject)
 (let (fN)
  (if (setq fN (|lnFileName?| lineObject))
   fN
   (|ncBug| "there is no file name in %1" (list lineObject)))))

\end{chunk}


\section{Messages}

\defun{msgCreate}{msgCreate}
\begin{verbatim}
msgObject
  tag -- catagory of msg
          -- attributes as a-list
               'imPr  => dont save for list processing
                toWhere, screen or file
                'norep => only display once in list
  pos -- position with possible FROM/TO tag
  key -- key for message database
  argL -- arguments to be placed in the msg test
  prefix -- things like "Error: "
  text -- the actual text
\end{verbatim}
\calls{msgCreate}{setMsgForcedAttrList}
\calls{msgCreate}{putDatabaseStuff}
\calls{msgCreate}{initImPr}
\calls{msgCreate}{initToWhere}
\begin{chunk}{defun msgCreate}
(defun |msgCreate| (tag posWTag key argL optPre &rest optAttr)
 (let (msg)
  (when (consp key) (setq tag '|old|))
  (setq msg (list tag posWTag key argL optPre nil))
  (when (car optAttr) (|setMsgForcedAttrList| msg (car optAttr)))
  (|putDatabaseStuff| msg)
  (|initImPr| msg)
  (|initToWhere| msg)
  msg))

\end{chunk}

\defmacro{getMsgPosTagOb}
\begin{chunk}{defmacro getMsgPosTagOb 0}
(defmacro |getMsgPosTagOb| (msg)
 `(elt ,msg 1))

\end{chunk}

\defmacro{getMsgKey}
\begin{chunk}{defmacro getMsgKey 0}
(defmacro |getMsgKey| (msg)
 `(elt ,msg 2))

\end{chunk}

\defmacro{getMsgArgL}
\begin{chunk}{defmacro getMsgArgL 0}
(defmacro |getMsgArgL| (msg)
 `(elt ,msg 3))

\end{chunk}

\defmacro{getMsgPrefix}
\begin{chunk}{defmacro getMsgPrefix 0}
(defmacro |getMsgPrefix| (msg)
 `(elt ,msg 4))

\end{chunk}

\defmacro{setMsgPrefix}
\begin{chunk}{defmacro setMsgPrefix 0}
(defmacro |setMsgPrefix| (msg val) 
 `(setf (elt ,msg 4) ,val))

\end{chunk}

\defmacro{getMsgText}
\begin{chunk}{defmacro getMsgText 0}
(defmacro |getMsgText| (msg) 
 `(elt ,msg 5))

\end{chunk}

\defmacro{setMsgText}
\begin{chunk}{defmacro setMsgText 0}
(defmacro |setMsgText| (msg val)
  `(setf (elt ,msg 5) ,val))

\end{chunk}

\defmacro{getMsgPrefix?}
\begin{chunk}{defmacro getMsgPrefix? 0}
(defmacro |getMsgPrefix?| (msg)
 `(let ((pre (|getMsgPrefix| ,msg)))
   (unless (eq pre '|noPre|) pre)))

\end{chunk}

\defmacro{getMsgTag}
The valid message tags are:
line, old, error, warn, bug, unimple, remark, stat, say, debug

\calls{getMsgTag}{ncTag}
\begin{chunk}{defmacro getMsgTag 0}
(defmacro |getMsgTag| (msg)
 `(|ncTag| ,msg))

\end{chunk}

\defmacro{getMsgTag?}
\calls{getMsgTag?}{ifcar}
\calls{getMsgTag?}{getMsgTag}
\begin{chunk}{defmacro getMsgTag? 0}
(defmacro |getMsgTag?| (msg)
 `(ifcar (member (|getMsgTag| ,msg)
         (list '|line| '|old| '|error| '|warn| '|bug|
               '|unimple| '|remark| '|stat| '|say| '|debug|))))

\end{chunk}

\defmacro{line?}
\calls{line?}{getMsgTag}
\begin{chunk}{defmacro line?}
(defmacro |line?| (msg) 
 `(eq (|getMsgTag| ,msg) '|line|))

\end{chunk}

\defmacro{leader?}
\calls{leader?}{getMsgTag}
\begin{chunk}{defmacro leader?}
(defmacro |leader?| (msg) 
 `(eq (|getMsgTag| ,msg) '|leader|))

\end{chunk}

\defmacro{toScreen?}
\calls{toScreen?}{getMsgToWhere}
\begin{chunk}{defmacro toScreen?}
(defmacro |toScreen?| (msg) 
 `(not (eq (|getMsgToWhere| ,msg) '|fileOnly|)))

\end{chunk}

\defun{ncSoftError}{ncSoftError}
Messages for the USERS of the compiler.
The program being compiled has a minor error.
Give a message and continue processing.

\calls{ncSoftError}{desiredMsg}
\calls{ncSoftError}{processKeyedError}
\calls{ncSoftError}{msgCreate}
\usesdollar{ncSoftError}{newcompErrorCount}
\begin{chunk}{defun ncSoftError}
(defun |ncSoftError| (pos erMsgKey erArgL &rest optAttr)
 (declare (special |$newcompErrorCount|))
  (setq |$newcompErrorCount| (+ |$newcompErrorCount| 1))
  (when (|desiredMsg| erMsgKey)
   (|processKeyedError|
    (|msgCreate| '|error| pos erMsgKey erArgL
                  "Error" optAttr))))

\end{chunk}

\defun{ncHardError}{ncHardError}
The program being compiled is seriously incorrect.
Give message and throw to a recovery point.

\calls{ncHardError}{desiredMsg}
\calls{ncHardError}{processKeyedError}
\calls{ncHardError}{msgCreate}
\calls{ncHardError}{ncError}
\usesdollar{ncHardError}{newcompErrorCount}
\begin{chunk}{defun ncHardError}
(defun |ncHardError| (pos erMsgKey erArgL &rest optAttr)
 (let (erMsg)
 (declare (special |$newcompErrorCount|))
  (setq |$newcompErrorCount| (+ |$newcompErrorCount| 1))
  (if (|desiredMsg| erMsgKey)
   (setq erMsg
    (|processKeyedError|
     (|msgCreate| '|error| pos erMsgKey erArgL "Error" optAttr)))
   (|ncError|))))

\end{chunk}

\defun{desiredMsg}{desiredMsg}
\begin{chunk}{defun desiredMsg 0}
(defun |desiredMsg| (erMsgKey &rest optCatFlag)
 (declare (ignore erMsgKey))
 (cond
  ((null (null optCatFlag)) (car optCatFlag))
  (t t)))

\end{chunk}

\defun{processKeyedError}{processKeyedError}
\calls{processKeyedError}{getMsgTag?}
\calls{processKeyedError}{getMsgKey}
\calls{processKeyedError}{getMsgPrefix?}
\calls{processKeyedError}{sayBrightly}
\calls{processKeyedError}{CallerName}
\calls{processKeyedError}{msgImPr?}
\calls{processKeyedError}{msgOutputter}
\usesdollar{processKeyedError}{ncMsgList}
\begin{chunk}{defun processKeyedError}
(defun |processKeyedError| (msg)
 (prog (pre erMsg)
 (declare (special |$ncMsgList|))
  (cond
   ((eq (|getMsgTag?| msg) '|old|)
     (setq erMsg (|getMsgKey| msg))
     (cond
      ((setq pre (|getMsgPrefix?| msg))
        (setq erMsg (cons pre erMsg))))
     (|sayBrightly| (cons "old msg from " (cons (|CallerName| 4) erMsg))))
   ((|msgImPr?| msg) (|msgOutputter| msg))
   (t (setq |$ncMsgList| (cons msg |$ncMsgList|))))))

\end{chunk}

\defun{msgOutputter}{msgOutputter}
\calls{msgOutputter}{getStFromMsg}
\calls{msgOutputter}{leader?}
\calls{msgOutputter}{line?}
\calls{msgOutputter}{toScreen?}
\calls{msgOutputter}{flowSegmentedMsg}
\calls{msgOutputter}{sayBrightly}
\calls{msgOutputter}{toFile?}
\calls{msgOutputter}{alreadyOpened?}
\usesdollar{msgOutputter}{linelength}
\begin{chunk}{defun msgOutputter}
(defun |msgOutputter| (msg)
 (let (alreadyOpened shouldFlow st)
 (declare (special $linelength))
  (setq st (|getStFromMsg| msg))
  (setq shouldFlow (null (or (|leader?| msg) (|line?| msg))))
  (when (|toScreen?| msg)
    (when shouldFlow (setq st (|flowSegmentedMsg| st $linelength 0)))
    (|sayBrightly| st))
  (when (|toFile?| msg)
    (when shouldFlow (setq st (|flowSegmentedMsg| st (- $linelength 6) 0)))
    (setq alreadyOpened (|alreadyOpened?| msg)))))

\end{chunk}

\defun{listOutputter}{listOutputter}
\calls{listOutputter}{msgOutputter}
\begin{chunk}{defun listOutputter}
(defun |listOutputter| (outputList)
 (dolist (msg outputList)
  (|msgOutputter| msg)))

\end{chunk}

\defun{getStFromMsg}{getStFromMsg}
\calls{getStFromMsg}{getPreStL}
\calls{getStFromMsg}{getMsgPrefix?}
\calls{getStFromMsg}{getMsgTag}
\calls{getStFromMsg}{getMsgText}
\calls{getStFromMsg}{getPosStL}
\calls{getStFromMsg}{getMsgKey?}
\calls{getStFromMsg}{pname}
\calls{getStFromMsg}{tabbing}
\begin{chunk}{defun getStFromMsg}
(defun |getStFromMsg| (msg)
 (let (st posStL preStL)
  (setq preStL (|getPreStL| (|getMsgPrefix?| msg)))
  (cond
   ((eq (|getMsgTag| msg) '|line|)
     (cons ""
       (cons "%x1" (append preStL (cons (|getMsgText| msg) nil)))))
   (t
    (setq posStL (|getPosStL| msg))
    (setq st
     (cons posStL
       (cons " "
        (append preStL
         (cons (|tabbing| msg)
          (|getMsgText| msg))))))))))

\end{chunk}

\defdollar{preLength}
\begin{chunk}{initvars}
(defvar |$preLength| 11)

\end{chunk}

\defun{getPreStL}{getPreStL}
\calls{getPreStL}{size}
\usesdollar{getPreStL}{preLength}
\begin{chunk}{defun getPreStL 0}
(defun |getPreStL| (optPre)
 (let (spses extraPlaces)
 (declare (special |$preLength|))
  (cond
   ((null optPre) (list "  "))
   (t
    (setq spses
     (cond
      ((< 0 (setq extraPlaces (- (- |$preLength| (size optPre)) 3)))
       (make-string extraPlaces))
      (t "")))
    (list optPre spses ":")))))

\end{chunk}

\defun{getPosStL}{getPosStL}
\calls{getPosStL}{showMsgPos?}
\calls{getPosStL}{getMsgPos}
\calls{getPosStL}{msgImPr?}
\calls{getPosStL}{decideHowMuch}
\calls{getPosStL}{listDecideHowMuch}
\calls{getPosStL}{ppos}
\calls{getPosStL}{remLine}
\calls{getPosStL}{remFile}
\usesdollar{getPosStL}{lastPos}
\begin{chunk}{defun getPosStL}
(defun |getPosStL| (msg)
 (let (printedOrigin printedLineNum printedFileName fullPrintedPos howMuch 
       msgPos)
 (declare (special |$lastPos|))
 (cond
  ((null (|showMsgPos?| msg)) "")
  (t
   (setq msgPos (|getMsgPos| msg))
   (setq howMuch
    (if (|msgImPr?| msg) 
     (|decideHowMuch| msgPos |$lastPos|)
     (|listDecideHowMuch| msgPos |$lastPos|)))
   (setq |$lastPos| msgPos)
   (setq fullPrintedPos (|ppos| msgPos))
   (setq printedFileName
    (cons "%x2" (cons "[" (append (|remLine| fullPrintedPos) (cons "]" nil)))))
   (setq printedLineNum
    (cons "%x2" (cons "[" (append (|remFile| fullPrintedPos) (cons "]" nil)))))
   (setq printedOrigin
    (cons "%x2" (cons "[" (append fullPrintedPos (cons "]" nil)))))
   (cond
    ((eq howMuch 'org)
     (cons "" (append printedOrigin (cons '|%l| nil))))
    ((eq howMuch 'line)
     (cons "" (append printedLineNum (cons '|%l| nil))))
    ((eq howMuch 'file)
     (cons "" (append printedFileName (cons '|%l| nil))))
    ((eq howMuch 'all)
     (cons ""
      (append printedFileName
       (cons '|%l|
        (cons ""
         (append printedLineNum
          (cons '|%l| nil)))))))
    (t ""))))))

\end{chunk}

\defun{ppos}{ppos}
\calls{ppos}{pfNoPosition?}
\calls{ppos}{pfImmediate?}
\calls{ppos}{pfCharPosn}
\calls{ppos}{pfLinePosn}
\calls{ppos}{porigin}
\calls{ppos}{pfFileName}
\begin{chunk}{defun ppos}
(defun |ppos| (p)
 (let (org lpos cpos)
  (cond
   ((|pfNoPosition?| p) (list "no position"))
   ((|pfImmediate?| p) (list "console"))
   (t
    (setq cpos (|pfCharPosn| p))
    (setq lpos (|pfLinePosn| p))
    (setq org (|porigin| (|pfFileName| p)))
    (list org " " "line" " " lpos)))))

\end{chunk}

\defun{remFile}{remFile}
\calls{remFile}{ifcdr}
\calls{remLine}{ifcar}
\begin{chunk}{defun remFile}
(defun |remFile| (positionList) (ifcdr (ifcdr positionList)))

\end{chunk}

\defun{showMsgPos?}{showMsgPos?}
\calls{showMsgPos?}{msgImPr?}
\calls{showMsgPos?}{leader?}
\usesdollar{showMsgPos?}{erMsgToss}
\begin{chunk}{defun showMsgPos? 0}
(defun |showMsgPos?| (msg)
 (declare (special |$erMsgToss|))
 (or |$erMsgToss| (and (null (|msgImPr?| msg)) (null (|leader?| msg)))))

\end{chunk}

\defdollar{imPrGuys}
\begin{chunk}{initvars}
(defvar |$imPrGuys| (list '|imPr|))

\end{chunk}

\defun{msgImPr?}{msgImPr?}
\calls{msgImPr?}{getMsgCatAttr}
\begin{chunk}{defun msgImPr?}
(defun |msgImPr?| (msg)
 (eq (|getMsgCatAttr| msg '|$imPrGuys|) '|imPr|))

\end{chunk}

\defun{getMsgCatAttr}{getMsgCatAttr}
\calls{getMsgCatAttr}{ifcdr}
\calls{getMsgCatAttr}{qassq}
\calls{getMsgCatAttr}{ncAlist}
\begin{chunk}{defun getMsgCatAttr}
(defun |getMsgCatAttr| (msg cat)
 (ifcdr (qassq cat (|ncAlist| msg))))

\end{chunk}

\defun{getMsgPos}{getMsgPos}
\calls{getMsgPos}{getMsgFTTag?}
\calls{getMsgPos}{getMsgPosTagOb}
\begin{chunk}{defun getMsgPos}
(defun |getMsgPos| (msg)
 (if (|getMsgFTTag?| msg)
  (cadr (|getMsgPosTagOb| msg))
  (|getMsgPosTagOb| msg)))

\end{chunk}

\defun{getMsgFTTag?}{getMsgFTTag?}
\calls{getMsgFTTag?}{ifcar}
\calls{getMsgFTTag?}{getMsgPosTagOb}
\begin{chunk}{defun getMsgFTTag?}
(defun |getMsgFTTag?| (msg)
 (ifcar (member (ifcar (|getMsgPosTagOb| msg)) (list 'from 'to 'fromto))))

\end{chunk}

\defun{decideHowMuch}{decideHowMuch}
When printing a msg, we wish not to show pos information that was
shown for a previous msg with identical pos info.
org prints out the word noposition or console
\calls{decideHowMuch}{poNopos?}
\calls{decideHowMuch}{poPosImmediate?}
\calls{decideHowMuch}{poFileName}
\calls{decideHowMuch}{poLinePosn}
\begin{chunk}{defun decideHowMuch}
(defun |decideHowMuch| (pos oldPos)
 (cond
  ((or (and (|poNopos?| pos) (|poNopos?| oldPos))
       (and (|poPosImmediate?| pos) (|poPosImmediate?| oldPos)))
    'none)
  ((or (|poNopos?| pos) (|poPosImmediate?| pos)) 'org)
  ((or (|poNopos?| oldPos) (|poPosImmediate?| oldPos)) 'all)
  ((not (equal (|poFileName| oldPos) (|poFileName| pos))) 'all)
  ((not (equal (|poLinePosn| oldPos) (|poLinePosn| pos))) 'line)
  (t 'none)))

\end{chunk}

\defun{poNopos?}{poNopos?}
\begin{chunk}{defun poNopos? 0}
(defun |poNopos?| (posn)
 (equal posn (list '|noposition|)))

\end{chunk}

\defun{poPosImmediate?}{poPosImmediate?}
\calls{poPosImmediate?}{poNopos?}
\calls{poPosImmediate?}{lnImmediate?}
\calls{poPosImmediate?}{poGetLineObject}
\begin{chunk}{defun poPosImmediate?}
(defun |poPosImmediate?| (txp)
 (unless (|poNopos?| txp) (|lnImmediate?| (|poGetLineObject| txp))))

\end{chunk}

\defun{poFileName}{poFileName}
\calls{poFileName}{lnFileName}
\calls{poFileName}{poGetLineObject}
\begin{chunk}{defun poFileName}
(defun |poFileName| (posn)
 (if posn
  (|lnFileName| (|poGetLineObject| posn))
  (caar posn)))

\end{chunk}

\defun{poGetLineObject}{poGetLineObject}
\begin{chunk}{defun poGetLineObject 0}
(defun |poGetLineObject| (posn)
 (car posn))

\end{chunk}

\defun{poLinePosn}{poLinePosn}
\calls{poLinePosn}{lnLocalNum}
\calls{poLinePosn}{poGetLineObject}
\begin{chunk}{defun poLinePosn}
(defun |poLinePosn| (posn)
 (if posn
  (|lnLocalNum| (|poGetLineObject| posn))
  (cdar posn)))

\end{chunk}

\defun{listDecideHowMuch}{listDecideHowMuch}
\calls{listDecideHowMuch}{poNopos?}
\calls{listDecideHowMuch}{poPosImmediate?}
\calls{listDecideHowMuch}{poGlobalLinePosn}
\begin{chunk}{defun listDecideHowMuch}
(defun |listDecideHowMuch| (pos oldPos)
 (cond
  ((or (and (|poNopos?| pos) (|poNopos?| oldPos))
       (and (|poPosImmediate?| pos) (|poPosImmediate?| oldPos)))
    'none)
  ((|poNopos?| pos) 'org)
  ((|poNopos?| oldPos) 'none)
  ((< (|poGlobalLinePosn| pos) (|poGlobalLinePosn| oldPos))
   (if (|poPosImmediate?| pos) 'org 'line))
  (t 'none)))

\end{chunk}

\defun{remLine}{remLine}
\begin{chunk}{defun remLine 0}
(defun |remLine| (positionList) (list (ifcar positionList)))

\end{chunk}

\defun{getMsgKey?}{getMsgKey?}
\calls{getMsgKey?}{identp}
\begin{chunk}{defun getMsgKey? 0}
(defun |getMsgKey?| (msg)
 (let ((val (|getMsgKey| msg)))
  (when (identp val) val)))

\end{chunk}

\defun{tabbing}{tabbing}
\calls{tabbing}{getMsgPrefix?}
\usesdollar{tabbing}{preLength}
\begin{chunk}{defun tabbing}
(defun |tabbing| (msg)
 (let (chPos)
 (declare (special |$preLength|))
  (setq chPos 2)
  (when (|getMsgPrefix?| msg) (setq chPos (- (+ chPos |$preLength|) 1)))
  (cons '|%t| chPos)))

\end{chunk}

\defdollar{toWhereGuys}
\begin{chunk}{initvars}
(defvar |$toWhereGuys| (list '|fileOnly| '|screenOnly|))

\end{chunk}

\defun{getMsgToWhere}{getMsgToWhere}
\calls{getMsgToWhere}{getMsgCatAttr}
\begin{chunk}{defun getMsgToWhere}
(defun |getMsgToWhere| (msg) (|getMsgCatAttr| msg '|$toWhereGuys|))

\end{chunk}

\defun{toFile?}{toFile?}
\calls{toFile?}{getMsgToWhere}
\usesdollar{toFile?}{fn}
\begin{chunk}{defun toFile?}
(defun |toFile?| (msg)
 (and (not (eq (|getMsgToWhere| msg) '|screenOnly|))))

\end{chunk}

\defun{alreadyOpened?}{alreadyOpened?}
\calls{alreadyOpened?}{msgImPr?}
\begin{chunk}{defun alreadyOpened?}
(defun |alreadyOpened?| (msg) (null (|msgImPr?| msg)))

\end{chunk}

\defun{setMsgForcedAttrList}{setMsgForcedAttrList}
\calls{setMsgForcedAttrList}{setMsgForcedAttr}
\calls{setMsgForcedAttrList}{whichCat}
\begin{chunk}{defun setMsgForcedAttrList}
(defun |setMsgForcedAttrList| (msg attrlist)
 (dolist (attr attrlist)
  (|setMsgForcedAttr| msg (|whichCat| attr) attr)))

\end{chunk}

\defun{setMsgForcedAttr}{setMsgForcedAttr}
\calls{setMsgForcedAttr}{setMsgCatlessAttr}
\calls{setMsgForcedAttr}{ncPutQ}
\begin{chunk}{defun setMsgForcedAttr}
(defun |setMsgForcedAttr| (msg cat attr)
 (if (eq cat '|catless|)
  (|setMsgCatlessAttr| msg attr)
  (|ncPutQ| msg cat attr)))

\end{chunk}

\defdollar{attrCats}
\begin{chunk}{initvars}
(defvar |$attrCats| (list '|$imPrGuys| '|$toWhereGuys| '|$repGuys|))

\end{chunk}

\defun{whichCat}{whichCat}
\calls{whichCat}{ListMember?}
\usesdollar{whichCat}{attrCats}
\begin{chunk}{defun whichCat}
(defun |whichCat| (attr)
 (let ((found '|catless|) done)
 (declare (special |$attrCats|))
  (loop for cat in |$attrCats| do
    (when (|ListMember?| attr (eval cat))
     (setq found cat)
     (setq done t))
   until done)
  found))

\end{chunk}

\defun{setMsgCatlessAttr}{setMsgCatlessAttr}
\tpdhere{Changed from |catless| to '|catless|}

\calls{setMsgCatlessAttr}{ncPutQ}
\calls{setMsgCatlessAttr}{ifcdr}
\calls{setMsgCatlessAttr}{qassq}
\calls{setMsgCatlessAttr}{ncAlist}
\begin{chunk}{defun setMsgCatlessAttr}
(defun |setMsgCatlessAttr| (msg attr)
 (|ncPutQ| msg 'catless (cons attr (ifcdr (qassq 'catless (|ncAlist| msg))))))

\end{chunk}

\defun{putDatabaseStuff}{putDatabaseStuff}
\tpdhere{The variable al is undefined}
\calls{putDatabaseStuff}{getMsgInfoFromKey}
\calls{putDatabaseStuff}{setMsgUnforcedAttrList}
\calls{putDatabaseStuff}{setMsgText}
\begin{chunk}{defun putDatabaseStuff}
(defun |putDatabaseStuff| (msg)
 (let (attributes text tmp)
  (setq tmp (|getMsgInfoFromKey| msg))
  (setq text (car tmp))
  (setq attributes (cadr tmp))
  (when attributes (|setMsgUnforcedAttrList| msg attributes))
  (|setMsgText| msg text)))

\end{chunk}

\defun{getMsgInfoFromKey}{getMsgInfoFromKey}
\calls{getMsgInfoFromKey}{getMsgKey?}
\calls{getMsgInfoFromKey}{getErFromDbL}
\calls{getMsgInfoFromKey}{getMsgKey}
\calls{getMsgInfoFromKey}{segmentKeyedMsg}
\calls{getMsgInfoFromKey}{removeAttributes}
\calls{getMsgInfoFromKey}{substituteSegmentedMsg}
\calls{getMsgInfoFromKey}{getMsgArgL}
\usesdollar{getMsgInfoFromKey}{msgDatabaseName}
\begin{chunk}{defun getMsgInfoFromKey}
(defun |getMsgInfoFromKey| (msg)
 (let (|$msgDatabaseName| attributes tmp msgText msgKey)
 (declare (special |$msgDatabaseName|))
  (setq |$msgDatabaseName| nil)
  (setq msgText
   (cond
    ((setq msgKey (|getMsgKey?| msg))
     msgKey)
    (t (|getMsgKey| msg))))
  (setq msgText (|segmentKeyedMsg| msgText))
  (setq tmp (|removeAttributes| msgText))
  (setq msgText (car tmp))
  (setq attributes (cadr tmp))
  (setq msgText (|substituteSegmentedMsg| msgText (|getMsgArgL| msg)))
  (list msgText attributes)))

\end{chunk}

\defun{setMsgUnforcedAttrList}{setMsgUnforcedAttrList}
\calls{setMsgUnforcedAttrList}{setMsgUnforcedAttr}
\calls{setMsgUnforcedAttrList}{whichCat}
\begin{chunk}{defun setMsgUnforcedAttrList}
(defun |setMsgUnforcedAttrList| (msg attrlist)
 (dolist (attr attrlist)
  (|setMsgUnforcedAttr| msg (|whichCat| attr) attr)))

\end{chunk}

\defun{setMsgUnforcedAttr}{setMsgUnforcedAttr}
\calls{setMsgUnforcedAttr}{setMsgCatlessAttr}
\calls{setMsgUnforcedAttr}{qassq}
\calls{setMsgUnforcedAttr}{ncAlist}
\calls{setMsgUnforcedAttr}{ncPutQ}
\begin{chunk}{defun setMsgUnforcedAttr}
(defun |setMsgUnforcedAttr| (msg cat attr)
 (cond
  ((eq cat '|catless|) (|setMsgCatlessAttr| msg attr))
  ((null (qassq cat (|ncAlist| msg))) (|ncPutQ| msg cat attr))))

\end{chunk}

\defdollar{imPrTagGuys}
\begin{chunk}{initvars}
(defvar |$imPrTagGuys| (list '|unimple| '|bug| '|debug| '|say| '|warn|))

\end{chunk}

\defun{initImPr}{initImPr}
\calls{initImPr}{getMsgTag}
\calls{initImPr}{setMsgUnforcedAttr}
\usesdollar{initImPr}{imPrTagGuys}
\usesdollar{initImPr}{erMsgToss}
\begin{chunk}{defun initImPr}
(defun |initImPr| (msg)
 (declare (special |$imPrTagGuys| |$erMsgToss|))
 (when (or |$erMsgToss| (member (|getMsgTag| msg) |$imPrTagGuys|))
   (|setMsgUnforcedAttr| msg '|$imPrGuys| '|imPr|)))

\end{chunk}

\defun{initToWhere}{initToWhere}
\calls{initToWhere}{getMsgCatAttr}
\calls{initToWhere}{setMsgUnforcedAttr}
\begin{chunk}{defun initToWhere}
(defun |initToWhere| (msg)
 (if (member '|trace| (|getMsgCatAttr| msg '|catless|))
   (|setMsgUnforcedAttr| msg '|$toWhereGuys| '|screenOnly|)))

\end{chunk}

\defun{ncBug}{Report a bug in the compiler}
Bug in the compiler: something which shouldn't have happened did.

\calls{ncBug}{processKeyedError}
\calls{ncBug}{msgCreate}
\calls{ncBug}{enable-backtrace}
\calls{ncBug}{ncAbort}
\usesdollar{ncBug}{nopos}
\usesdollar{ncBug}{newcompErrorCount}
\begin{chunk}{defun ncBug}
(defun |ncBug| (erMsgKey erArgL &rest optAttr)
 (let (erMsg)
 (declare (special |$nopos| |$newcompErrorCount|))
  (setq |$newcompErrorCount| (+ |$newcompErrorCount| 1))
  (setq erMsg
   (|processKeyedError|
    (|msgCreate| '|bug| |$nopos| erMsgKey erArgL "Bug!" optAttr)))
  (break)
  (|ncAbort|)))

\end{chunk}

\defun{processMsgList}{processMsgList}
\calls{processMsgList}{erMsgSort}
\calls{processMsgList}{makeMsgFromLine}
\calls{processMsgList}{poGlobalLinePosn}
\calls{processMsgList}{getMsgPos}
\calls{processMsgList}{queueUpErrors}
\calls{processMsgList}{listOutputter}
\usesdollar{processMsgList}{noRepList}
\usesdollar{processMsgList}{outputList}
\begin{chunk}{defun processMsgList}
(defun |processMsgList| (erMsgList lineList)
 (let (|$noRepList| |$outputList| st globalNumOfLine msgLine)
 (declare (special |$noRepList| |$outputList|))
  (setq |$outputList| nil)
  (setq |$noRepList| nil)
  (setq erMsgList (|erMsgSort| erMsgList))
  (dolist (line lineList)
   (setq msgLine (|makeMsgFromLine| line))
   (setq |$outputList| (cons msgLine |$outputList|))
   (setq globalNumOfLine (|poGlobalLinePosn| (|getMsgPos| msgLine)))
   (setq erMsgList (|queueUpErrors| globalNumOfLine erMsgList)))
  (setq |$outputList| (append erMsgList |$outputList|))
  (setq st "---------SOURCE-TEXT-&-ERRORS------------------------")
  (|listOutputter| (reverse |$outputList|))))

\end{chunk}

\defun{erMsgSort}{erMsgSort}
\calls{erMsgSort}{erMsgSep}
\calls{erMsgSort}{listSort}
\begin{chunk}{defun erMsgSort}
(defun |erMsgSort| (erMsgList)
 (let (msgWOPos msgWPos tmp)
  (setq tmp (|erMsgSep| erMsgList))
  (setq msgWPos (car tmp))
  (setq msgWOPos (cadr tmp))
  (setq msgWPos (|listSort| #'|erMsgCompare| msgWPos))
  (setq msgWOPos (reverse msgWOPos))
  (append msgWPos msgWOPos)))

\end{chunk}

\defun{erMsgCompare}{erMsgCompare}
\calls{erMsgCompare}{compareposns}
\calls{erMsgCompare}{getMsgPos}
\begin{chunk}{defun erMsgCompare}
(defun |erMsgCompare| (ob1 ob2)
 (|compareposns| (|getMsgPos| ob2) (|getMsgPos| ob1)))

\end{chunk}

\defun{compareposns}{compareposns}
\calls{compareposns}{poGlobalLinePosn}
\calls{compareposns}{poCharPosn}
\begin{chunk}{defun compareposns}
(defun |compareposns| (a b)
 (let (c d)
  (setq c (|poGlobalLinePosn| a))
  (setq d (|poGlobalLinePosn| b))
  (if (equal c d) 
   (not (< (|poCharPosn| a) (|poCharPosn| b)))
   (not (< c d)))))

\end{chunk}

\defun{erMsgSep}{erMsgSep}
\calls{erMsgSep}{poNopos?}
\calls{erMsgSep}{getMsgPos}
\begin{chunk}{defun erMsgSep}
(defun |erMsgSep| (erMsgList)
 (let (msgWOPos msgWPos)
  (dolist (msg erMsgList)
   (if (|poNopos?| (|getMsgPos| msg))
    (setq msgWOPos (cons msg msgWOPos))
    (setq msgWPos (cons msg msgWPos))))
  (list msgWPos msgWOPos)))

\end{chunk}

\defun{makeMsgFromLine}{makeMsgFromLine}
\calls{makeMsgFromLine}{getLinePos}
\calls{makeMsgFromLine}{getLineText}
\calls{makeMsgFromLine}{poGlobalLinePosn}
\calls{makeMsgFromLine}{poLinePosn}
\calls{makeMsgFromLine}{concat}
\calls{makeMsgFromLine}{rep}
\calls{makeMsgFromLine}{char}
\calls{makeMsgFromLine}{size}
\usesdollar{makeMsgFromLine}{preLength}
\begin{chunk}{defun makeMsgFromLine}
(defun |makeMsgFromLine| (line)
 (let (localNumOfLine stNum globalNumOfLine textOfLine posOfLine)
 (declare (special |$preLength|))
  (setq posOfLine (|getLinePos| line))
  (setq textOfLine (|getLineText| line))
  (setq globalNumOfLine (|poGlobalLinePosn| posOfLine))
  (setq stNum (princ-to-string (|poLinePosn| posOfLine)))
  (setq localNumOfLine
    (concat (|rep| #\space (- |$preLength| 7 (size stNum))) stNum))
  (list '|line| posOfLine nil nil (concat "Line" localNumOfLine) textOfLine)))

\end{chunk}

\defun{rep}{rep}
\tpdhere{This function should be replaced by fillerspaces}
\begin{chunk}{defun rep 0}
(defun |rep| (c n)
 (if (< 0 n)
  (make-string n :initial-element (character c))
  ""))

\end{chunk}

\defun{getLinePos}{getLinePos}
\begin{chunk}{defun getLinePos 0}
(defun |getLinePos| (line) (car line))

\end{chunk}

\defun{getLineText}{getLineText}
\begin{chunk}{defun getLineText 0}
(defun |getLineText| (line) (cdr line))

\end{chunk}

\defun{queueUpErrors}{queueUpErrors}
\begin{verbatim}
;queueUpErrors(globalNumOfLine,msgList)==
;    thisPosMsgs  := []
;    notThisLineMsgs := []
;    for msg in msgList _
;      while thisPosIsLess(getMsgPos msg,globalNumOfLine) repeat
;    --these are msgs that refer to positions from earlier compilations
;        if not redundant (msg,notThisPosMsgs) then
;           notThisPosMsgs := [msg,:notThisPosMsgs]
;        msgList := rest msgList
;    for msg in msgList _
;      while thisPosIsEqual(getMsgPos msg,globalNumOfLine) repeat
;       if not redundant (msg,thisPosMsgs) then
;           thisPosMsgs := [msg,:thisPosMsgs]
;       msgList := rest msgList
;    if thisPosMsgs then
;        thisPosMsgs := processChPosesForOneLine  thisPosMsgs
;        $outputList := NCONC(thisPosMsgs,$outputList)
;    if notThisPosMsgs then
;        $outputList := NCONC(notThisPosMsgs,$outputList)
;    msgList
\end{verbatim}
\calls{queueUpErrors}{processChPosesForOneLine}
\usesdollar{queueUpErrors}{outputList}
\begin{chunk}{defun queueUpErrors}
(DEFUN |queueUpErrors| (|globalNumOfLine| |msgList|)
  (PROG (|notThisPosMsgs| |notThisLineMsgs| |thisPosMsgs|)
    (DECLARE (SPECIAL |$outputList|))
    (RETURN
      (PROGN
        (SETQ |thisPosMsgs| NIL)
        (SETQ |notThisLineMsgs| NIL)
        ((LAMBDA (|bfVar#7| |msg|)
           (LOOP
             (COND
               ((OR (ATOM |bfVar#7|)
                    (PROGN (SETQ |msg| (CAR |bfVar#7|)) NIL)
                    (NOT (|thisPosIsLess| (|getMsgPos| |msg|)
                             |globalNumOfLine|)))
                (RETURN NIL))
               ('T
                (PROGN
                  (COND
                    ((NULL (|redundant| |msg| |notThisPosMsgs|))
                     (SETQ |notThisPosMsgs|
                           (CONS |msg| |notThisPosMsgs|))))
                  (SETQ |msgList| (CDR |msgList|)))))
             (SETQ |bfVar#7| (CDR |bfVar#7|))))
         |msgList| NIL)
        ((LAMBDA (|bfVar#8| |msg|)
           (LOOP
             (COND
               ((OR (ATOM |bfVar#8|)
                    (PROGN (SETQ |msg| (CAR |bfVar#8|)) NIL)
                    (NOT (|thisPosIsEqual| (|getMsgPos| |msg|)
                             |globalNumOfLine|)))
                (RETURN NIL))
               ('T
                (PROGN
                  (COND
                    ((NULL (|redundant| |msg| |thisPosMsgs|))
                     (SETQ |thisPosMsgs| (CONS |msg| |thisPosMsgs|))))
                  (SETQ |msgList| (CDR |msgList|)))))
             (SETQ |bfVar#8| (CDR |bfVar#8|))))
         |msgList| NIL)
        (COND
          (|thisPosMsgs|
              (SETQ |thisPosMsgs|
                    (|processChPosesForOneLine| |thisPosMsgs|))
              (SETQ |$outputList| (NCONC |thisPosMsgs| |$outputList|))))
        (COND
          (|notThisPosMsgs|
              (SETQ |$outputList|
                    (NCONC |notThisPosMsgs| |$outputList|))))
        |msgList|))))

\end{chunk}

\defun{thisPosIsLess}{thisPosIsLess}
\calls{thisPosIsLess}{poNopos?}
\calls{thisPosIsLess}{poGlobalLinePosn}
\begin{chunk}{defun thisPosIsLess}
(defun |thisPosIsLess| (pos num)
 (unless (|poNopos?| pos) (< (|poGlobalLinePosn| pos) num)))

\end{chunk}

\defun{thisPosIsEqual}{thisPosIsEqual}
\calls{thisPosIsEqual}{poNopos?}
\calls{thisPosIsEqual}{poGlobalLinePosn}
\begin{chunk}{defun thisPosIsEqual}
(defun |thisPosIsEqual| (pos num)
 (unless (|poNopos?| pos) (equal (|poGlobalLinePosn| pos) num)))

\end{chunk}

\defun{redundant}{redundant}
\begin{verbatim}
redundant(msg,thisPosMsgs) ==
    found := NIL
    if msgNoRep? msg then
        for item in $noRepList repeat
            sameMsg?(msg,item) => return (found := true)
        $noRepList := [msg,$noRepList]
    found or MEMBER(msg,thisPosMsgs)
\end{verbatim}
\calls{redundant}{msgNoRep?}
\calls{redundant}{sameMsg?}
\usesdollar{redundant}{noRepList}
\begin{chunk}{defun redundant}
(defun |redundant| (msg thisPosMsgs)
 (prog (found)
 (declare (special |$noRepList|))
  (return
   (progn
    (cond
     ((|msgNoRep?| msg)
      ((lambda (Var9 item)
       (loop
        (cond
         ((or (atom Var9) (progn (setq item (car Var9)) nil))
           (return nil))
         (t
          (cond
           ((|sameMsg?| msg item) (return (setq found t))))))
        (setq Var9 (cdr Var9))))
       |$noRepList| nil)
      (setq |$noRepList| (list msg |$noRepList|))))
   (or found (member msg thisPosMsgs))))))

\end{chunk}

\defdollar{repGuys}
\begin{chunk}{initvars}
(defvar |$repGuys| (list '|noRep| '|rep|))

\end{chunk}

\defun{msgNoRep?}{msgNoRep?}
\calls{msgNoRep?}{getMsgCatAttr}
\begin{chunk}{defun msgNoRep?}
(defun |msgNoRep?| (msg) (eq (|getMsgCatAttr| msg '|$repGuys|) '|noRep|))

\end{chunk}

\defun{sameMsg?}{sameMsg?}
\calls{sameMsg?}{getMsgKey}
\calls{sameMsg?}{getMsgArgL}
\begin{chunk}{defun sameMsg?}
(defun |sameMsg?| (msg1 msg2)
 (and (equal (|getMsgKey| msg1) (|getMsgKey| msg2))
      (equal (|getMsgArgL| msg1) (|getMsgArgL| msg2))))

\end{chunk}

\defun{processChPosesForOneLine}{processChPosesForOneLine}
\calls{processChPosesForOneLine}{posPointers}
\calls{processChPosesForOneLine}{getMsgFTTag?}
\calls{processChPosesForOneLine}{putFTText}
\calls{processChPosesForOneLine}{poCharPosn}
\calls{processChPosesForOneLine}{getMsgPos}
\calls{processChPosesForOneLine}{getMsgPrefix}
\calls{processChPosesForOneLine}{setMsgPrefix}
\calls{processChPosesForOneLine}{concat}
\calls{processChPosesForOneLine}{size}
\calls{processChPosesForOneLine}{makeLeaderMsg}
\usesdollar{processChPosesForOneLine}{preLength}
\begin{chunk}{defun processChPosesForOneLine}
(defun |processChPosesForOneLine| (msgList)
 (let (leaderMsg oldPre posLetter chPosList)
 (declare (special |$preLength|))
  (setq chPosList (|posPointers| msgList))
  (dolist (msg msgList)
   (when (|getMsgFTTag?| msg) (|putFTText| msg chPosList))
   (setq posLetter (cdr (assoc (|poCharPosn| (|getMsgPos| msg)) chPosList)))
   (setq oldPre (|getMsgPrefix| msg))
   (|setMsgPrefix| msg
    (concat oldPre
     (make-string (- |$preLength| 4 (size oldPre))) posLetter)))
  (setq leaderMsg (|makeLeaderMsg| chPosList))
  (nconc msgList (list leaderMsg))))

\end{chunk}

\defun{poCharPosn}{poCharPosn}
\begin{chunk}{defun poCharPosn 0}
(defun |poCharPosn| (posn)
 (cdr posn))

\end{chunk}

\defun{makeLeaderMsg}{makeLeaderMsg}
\begin{verbatim}
makeLeaderMsg chPosList ==
    st := MAKE_-FULL_-CVEC ($preLength- 3)
    oldPos := -1
    for [posNum,:posLetter] in reverse chPosList repeat
        st := CONCAT(st, _
            rep(char ".", (posNum - oldPos - 1)),posLetter)
        oldPos := posNum
    ['leader,$nopos,'nokey,NIL,NIL,[st] ]
\end{verbatim}
\usesdollar{makeLeaderMsg}{nopos}
\usesdollar{makeLeaderMsg}{preLength}
\begin{chunk}{defun makeLeaderMsg}
(defun |makeLeaderMsg| (chPosList)
 (let (posLetter posNum oldPos st)
 (declare (special |$nopos| |$preLength|))
  (setq st (make-string (- |$preLength| 3)))
  (setq oldPos -1)
  ((lambda (Var15 Var14)
   (loop
    (cond
     ((or (atom Var15) (progn (setq Var14 (car Var15)) nil))
       (return nil))
     (t
      (and (consp Var14)
           (progn
            (setq posNum (car Var14))
            (setq posLetter (cdr Var14))
            t)
           (progn
            (setq st 
             (concat st (|rep| #\. (- posNum oldPos 1)) posLetter))
            (setq oldPos posNum)))))
    (setq Var15 (cdr Var15))))
   (reverse chPosList) nil)
  (list '|leader| |$nopos| '|nokey| nil nil (list st))))

\end{chunk}

\defun{posPointers}{posPointers}
\tpdhere{getMsgFTTag is nonsense}

\calls{posPointers}{poCharPosn}
\calls{posPointers}{getMsgPos}
\calls{posPointers}{ifcar}
\calls{posPointers}{getMsgPos2}
\calls{posPointers}{insertPos}
\uses{posPointers}{getMsgFTTag}
\begin{chunk}{defun posPointers}
(defun |posPointers| (msgList)
 (let (posLetterList pos ftPosList posList increment pointers)
 (declare (special |getMsgFTTag|))
  (setq pointers "ABCDEFGHIJKLMONPQRS")
  (setq increment 0)
  (dolist (msg msgList)
   (setq pos (|poCharPosn| (|getMsgPos| msg)))
   (unless (equal pos (ifcar posList))
    (setq posList (cons pos posList)))
   ; this should probably read TPDHERE
   ; (when (eq (|getMsgPosTagOb| msg) 'fromto))
   (when (eq |getMsgFTTag| 'fromto)
    (setq ftPosList (cons (|poCharPosn| (|getMsgPos2| msg)) ftPosList))))
  (dolist (toPos ftPosList)
   (setq posList (|insertPos| toPos posList)))
  (dolist (pos posList)
   (setq posLetterList
    (cons (cons pos (elt pointers increment)) posLetterList))
   (setq increment (+ increment 1)))
  posLetterList))

\end{chunk}

\defun{getMsgPos2}{getMsgPos2}
\calls{getMsgPos2}{getMsgFTTag?}
\calls{getMsgPos2}{getMsgPosTagOb}
\calls{getMsgPos2}{ncBug}
\begin{chunk}{defun getMsgPos2}
(defun |getMsgPos2| (msg)
 (if (|getMsgFTTag?| msg)
  (caddr (|getMsgPosTagOb| msg))
  (|ncBug| "not a from to" nil)))

\end{chunk}

\defun{insertPos}{insertPos}
This function inserts a position in the proper place of a position list.
This is used for the 2nd pos of a fromto
\calls{insertPos}{done}
\begin{chunk}{defun insertPos 0}
(defun |insertPos| (newPos posList)
 (let (pos top bot done)
 (setq bot (cons 0 posList))
 (do () (done)
  (setq top (cons (car bot) top))
  (setq bot (cdr bot))
  (setq pos (car bot))
  (setq done
   (cond
    ((< pos newPos) nil)
    ((equal pos newPos) t)
    ((< newPos pos)
     (setq top (cons newPos top))
     t))))
 (cons (cdr (reverse top)) bot)))

\end{chunk}

\defun{putFTText}{putFTText}
\calls{putFTText}{getMsgFTTag?}
\calls{putFTText}{poCharPosn}
\calls{putFTText}{getMsgPos}
\calls{putFTText}{setMsgText}
\calls{putFTText}{getMsgText}
\calls{putFTText}{getMsgPos2}
\begin{chunk}{defun putFTText}
(defun |putFTText| (msg chPosList)
 (let (charMarker2 pos2 markingText charMarker pos tag)
  (setq tag (|getMsgFTTag?| msg))
  (setq pos (|poCharPosn| (|getMsgPos| msg)))
  (setq charMarker (cdr (assoc pos chPosList)))
  (cond
   ((eq tag 'from)
    (setq markingText (list " (from " charMarker " and on) "))
    (|setMsgText| msg (append markingText (|getMsgText| msg))))
   ((eq tag 'to)
    (setq markingText (list " (up to " charMarker ") "))
    (|setMsgText| msg (append markingText (|getMsgText| msg))))
   ((eq tag 'fromto)
    (setq pos2 (|poCharPosn| (|getMsgPos2| msg)))
    (setq charMarker2 (cdr (assoc pos2 chPosList)))
    (setq markingText (list " (from " charMarker " up to " charMarker2 ") "))
    (|setMsgText| msg (append markingText (|getMsgText| msg)))))))

\end{chunk}

\defun{From}{From}
This is called from parameter list of nc message functions
\begin{chunk}{defun From 0}
(defun |From| (pos) (list 'from pos))

\end{chunk}

\defun{To}{To}
This is called from parameter list of nc message functions
\begin{chunk}{defun To 0}
(defun |To| (pos) (list 'to pos))

\end{chunk}

\defun{FromTo}{FromTo}
This is called from parameter list of nc message functions
\begin{chunk}{defun FromTo 0}
(defun |FromTo| (pos1 pos2) (list 'fromto pos1 pos2))

\end{chunk}

\chapter{The Interpreter Syntax}
\section{syntax assignment}
\label{assignment}
\index{assignment}
\index{syntax!assignment}
\index{assignment!syntax}
\begin{chunk}{assignment.help}

Immediate, Delayed, and Multiple Assignment

====================================================================
Immediate Assignment
====================================================================

A variable in Axiom refers to a value. A variable has a name beginning
with an uppercase or lowercase alphabetic character, "%", or "!".
Successive characters (if any) can be any of the above, digits, or "?".
Case is distinguished. The following are all examples of valid, distinct
variable names:

  a       tooBig?     a1B2c3%!?
  A       %j          numberOfPoints
  beta6   %J          numberofpoints

The ":=" operator is the immediate assignment operator. Use it to 
associate a value with a variable. The syntax for immediate assignment
for a single variable is:

   variable := expression

The value returned by an immediate assignment is the value of expression.

  a := 1
    1             
           Type: PositiveInteger

The right-hand side of the expression is evaluated, yielding 1. The value
is then assigned to a.

  b := a
    1             
           Type: PositiveInteger

The right-hand side of the expression is evaluated, yieldig 1. This value
is then assigned to b. Thus a and b both have the value 1 after the sequence
of assignments.

  a := 2
    2
           Type: PositiveInteger

What is the value of b if a is assigned the value 2?

  b
    1
           Type: PositiveInteger

The value of b is left unchanged.

This is what we mean when we say this kind of assignment is immediate.
The variable b has no dependency on a after the initial assignment. This
is the usual notion of assignment in programming languages such as C,
Pascal, and Fortran.

====================================================================
Delayed Assignment
====================================================================

Axiom provides delayed assignment with "==". This implements a delayed
evaluation of the right-hand side and dependency checking. The syntax for
delayed assignment is

   variable == expression

The value returned by a delayed assignment is the unique value of Void.

  a == 1
           Type: Void

  b == a
           Type: Void

Using a and b as above, these are the corresponding delayed assignments.

  a
   Compiling body of rule a to compute value of type PositiveInteger
   1
           Type: PositiveInteger

The right-hand side of each delayed assignment is left unevaluated until
the variables on the left-hand sides are evaluated. 

  b
   Compiling body of rule b to compute value of type PositiveInteger
   1
           Type: PositiveInteger

This gives the same results as before. But if we change a to 2

  a == 2
   Compiled code for a has been cleared.
   Compiled code for b has been cleared.
   1 old definition(s) deleted for function or rule a
           Type: Void

Then a evaluates to 2, as expected

  a
   Compiling body of rule a to compute value of type PositiveInteger
   2
           Type: PositiveInteger

but the value of b reflects the change to a

  b
   Compiling body of rule b to compute value of type PositiveInteger
   2
           Type: PositiveInteger

====================================================================
Multiple Immediate Assignments
====================================================================

It is possible to set several variables at the same time by using a
tuple of variables and a tuple of expressions. A tuple is a collection
of things separated by commas, often surrounded by parentheses. The
syntax for multiple immediate assignment is

 ( var1, var2, ..., varN ) := ( expr1, expr2, ..., exprN )

The value returned by an immediate assignment is the value of exprN.

 ( x, y ) := ( 1, 2 )
   2
           Type: PositiveInteger

This sets x to 1 and y to 2. Multiple immediate assignments are parallel
in the sense that the expressions on the right are all evaluated before
any assignments on the left are made. However, the order of evaluation
of these expressions is undefined.

 ( x, y ) := ( y, x )
   1
           Type: PositiveInteger

  x
   2
           Type: PositiveInteger

The variable x now has the previous value of y.

  y
   1
           Type: PositiveInteger

The variable y now has the previous value of x.

There is no syntactic form for multiple delayed assignments. 

\end{chunk}

\section{syntax blocks}
\label{blocks}
\index{blocks}
\index{syntax!blocks}
\index{blocks!syntax}
\begin{chunk}{blocks.help}
====================================================================
Blocks
====================================================================

A block is a sequence of expressions evaluated in the order that they
appear, except as modified by control expressions such as leave, return,
iterate, and if-then-else constructions. The value of a block is the
value of the expression last evaluated in the block.

To leave a block early, use "=>". For example, 

    i < 0 => x

The expression before the "=>" must evaluate to true or false. The
expression following the "=>" is the return value of the block.

A block can be constructed in two ways:

  1. the expressions can be separated by semicolons and the resulting
     expression surrounded by parentheses, and
  2. the expressions can be written on succeeding lines with each line
     indented the same number of spaces (which must be greater than zero).
     A block entered in this form is called a pile

Only the first form is available if you are entering expressions directly
to Axiom. Both forms are available in .input files. The syntax for a simple
block of expressions entered interactively is

  ( expression1 ; expression2 ; ... ; expressionN )

The value returned by a block is the value of an "=>" expression, or
expressionN if no "=>" is encountered.

In .input files, blocks can also be written in piles. The examples
given here are assumed to come from .input files.

  a := 
    i := gcd(234,672)
    i := 2*i**5 - i + 1
    1 / i

      1
    -----
    23323
              Type: Fraction Integer

In this example, we assign a rational number to a using a block consisting
of three expressions. This block is written as a pile. Each expression in
the pile has the same indentation, in this case two spaces to the right of
the first line.

  a := ( i := gcd(234,672); i := 2*i**5 - i + 1; 1 / i )

      1
    -----
    23323
              Type: Fraction Integer

Here is the same block written on one line. This is how you are required
to enter it at the input prompt.

  ( a := 1; b := 2; c := 3; [a,b,c] )
    [1,2,3]
              Type: List PositiveInteger

AAxiom gives you two ways of writing a block and the preferred way in
an .input file is to use a pile. Roughly speaking, a pile is a block
whose consituent expressions are indented the same amount. You begin a
pile by starting a new line for the first expression, indenting it to
the right of the previous line. You then enter the second expression on
a new line, vertically aligning it with the first line. And so on. If
you need to enter an inner pile, further indent its lines to the right
of the outer pile. Axiom knows where a pile ends. It ends when a subsequent
line is indented to the left of the pile or the end of the file.

Also See: 
o )help if
o )help repeat
o )help while
o )help for
o )help suchthat
o )help parallel
o )help lists

\end{chunk}
\footnote{
\fnref{if}
\fnref{repeat}
\fnref{while}
\fnref{for}
\fnref{suchthat}
\fnref{parallel}
\fnref{lists}}

\section{system clef}
\label{clef}
\index{clef}
\index{syntax!clef}
\index{clef!syntax}
\begin{chunk}{clef.help}

Entering printable keys generally inserts new text into the buffer (unless
in overwrite mode, see below).  Other special keys can be used to modify
the text in the buffer.  In the description of the keys below, ^n means
Control-n, or holding the CONTROL key down while pressing "n".  Errors
will ring the terminal bell.

^A/^E   : Move cursor to beginning/end of the line.
^F/^B   : Move cursor forward/backward one character.
^D      : Delete the character under the cursor.
^H, DEL : Delete the character to the left of the cursor.
^K      : Kill from the cursor to the end of line.
^L      : Redraw current line.
^O      : Toggle overwrite/insert mode. Initially in insert mode. Text
          added in overwrite mode (including yanks) overwrite
          existing text, while insert mode does not overwrite.
^P/^N   : Move to previous/next item on history list.
^R/^S   : Perform incremental reverse/forward search for string on
          the history list.  Typing normal characters adds to the current
          search string and searches for a match. Typing ^R/^S marks
          the start of a new search, and moves on to the next match.
          Typing ^H or DEL deletes the last character from the search 
          string, and searches from the starting location of the last search.  
          Therefore, repeated DEL's appear to unwind to the match nearest 
          the point at which the last ^R or ^S was typed.  If DEL is 
          repeated until the search string is empty the search location 
          begins from the start of the history list.  Typing ESC or 
          any other editing character accepts the current match and 
          loads it into the buffer, terminating the search.
^T      : Toggle the characters under and to the left of the cursor.
^Y      : Yank previously killed text back at current location.  Note that
          this will overwrite or insert, depending on the current mode.
^U      : Show help (this text).
TAB     : Perform command completion based on word to the left of the cursor. 
          Words are deemed to contain only the alphanumeric and the % ! ? _  
          characters.
NL, CR  : returns current buffer to the program.

DOS and ANSI terminal arrow key sequences are recognized, and act like:

  up    : same as ^P
  down  : same as ^N
  left  : same as ^B
  right : same as ^F

\end{chunk} 

\section{syntax collection}
\label{collection}
\index{collection}
\index{syntax!collection}
\index{collection!syntax}
\begin{chunk}{collection.help}
====================================================================
Collection -- Creating Lists and Streams with Iterators
====================================================================

All of the loop expressions which do not use the repeat leave or
iterate words can be used to create lists and streams. For example:

This creates a simple list of the integers from 1 to 10:

  list := [i for i in 1..10]
   [1,2,3,4,5,6,7,8,9,10]
                      Type: List PositiveInteger

Create a stream of the integers greater than or equal to 1:

  stream := [i for i in 1..]
   [1,2,3,4,5,6,7,...]
                      Type: Stream PositiveInteger

This is a list of the prime numbers between 1 and 10, inclusive:

  [i for i in 1..10 | prime? i]
   [2,3,5,7]
                      Type: List PositiveInteger

This is a stream of the prime integers greater than or equal to 1:
  
  [i for i in 1.. | prime? i]
   [2,3,5,7,11,13,17,...]
                      Type: Stream PositiveInteger

This is a list of the integers between 1 and 10, inclusive, whose
squares are less than 700:

  [i for i in 1..10 while i*i < 700]
   [1,2,3,4,5,6,7,8,9,10]
                      Type: List PositiveInteger

This is a stream of the integers greater than or equal to 1 whose
squares are less than 700:

  [i for i in 1.. while i*i < 700]
   [1,2,3,4,5,6,7,...]
                      Type: Stream PositiveInteger

The general syntax of a collection is

  [ collectExpression iterator1 iterator2 ... iteratorN ]

where each iterator is either a for or a while clause. The loop 
terminates immedidately when the end test of any iterator succeeds
or when a return expression is evaluated in collectExpression. The
value returned by the collection is either a list or a stream of
elements, one for each iteration of the collectExpression.

Be careful when you use while to create a stream. By default Axiom
tries to compute and display the first ten elements of a stream. If
the while condition is not satisfied quickly, Axiom can spend a long
(potentially infinite) time trying to compute the elements. Use

  )set streams calculate 

to change the defaults to something else. This also affects the number
of terms computed and displayed for power series. For the purposes of
these examples we have use this system command to display fewer than
ten terms.

\end{chunk}

\section{syntax for}
\label{for}
\index{for}
\index{syntax!for}
\index{for!syntax}
\begin{chunk}{for.help}
====================================================================
for loops
====================================================================

Axiom provide the for and in keywords in repeat loops, allowing you
to integrate across all elements of a list, or to have a variable take
on integral values from a lower bound to an upper bound. We shall refer
to these modifying clauses of repeat loops as for clauses. These clauses
can be present in addition to while clauses (See )help while). As with
all other types of repeat loops, leave (see )help leave) can be used to 
prematurely terminate evaluation of the loop.

The syntax for a simple loop using for is

  for iterator repeat loopbody

The iterator has several forms. Each form has an end test which is
evaluted before loopbody is evaluated. A for loop terminates immediately
when the end test succeeds (evaluates to true) or when a leave or return
expression is evaluated in loopbody. The value returned by the loop is 
the unique value of Void.

====================================================================
for i in n..m repeat
====================================================================

If for is followed by a variable name, the in keyword and then an integer
segment of the form n..m, the end test for this loop is the predicate 
i > m. The body of the loop is evaluated m-n+1 times if this number is
greater than 0. If this number is less than or equal to 0, the loop body
is not evaluated at all.

The variable i has the value n, n+1, ..., m for successive iterations
of the loop body. The loop variable is a local variable within the loop
body. Its value is not available outside the loop body and its value and
type within the loop body completely mask any outer definition of a
variable with the same name.

  for i in 10..12 repeat output(i**3)
   1000
   1331
   1728
                      Type: Void

The loop prints the values of 10^3, 11^3, and 12^3.

  a := [1,2,3]
   [1,2,3]
                      Type: List PositiveInteger

  for i in 1..#a repeat output(a.i)
   1
   2
   3
                      Type: Void

Iterate across this list using "." to access the elements of a list
and the # operation to count its elements.

This type of iteration is applicable to anything that uses ".". You 
can also use it with functions that use indices to extract elements.

   m := matrix [ [1,2],[4,3],[9,0] ]
    +-    -+
    | 1  2 |
    | 4  3 |
    | 9  0 |
    +-    -+
                      Type: Matrix Integer

Define m to be a matrix.

   for i in 1..nrows(m) repeat output row(m.i)
    [1,2]
    [4,3]
    [9,0]
                      Type: Void

Display the rows of m.

You can iterate with for-loops.

   for i in 1..5 repeat
     if odd?(i) then iterate
     output(i)
    2
    4
                      Type: Void

Display the even integers in a segment.

====================================================================
for i in n..m by s repeat
====================================================================

By default, the difference between values taken on by a variable in
loops such as 

  for i in n..m repeat ...

is 1. It is possible to supply another, possibly negative, step value
by using the by keyword along with for and in. Like the upper and lower
bounds, the step value following the by keyword must be an integer. Note
that the loop

  for i in 1..2 by 0 repeat output(i)

will not terminate by itself, as the step value does not change the
index from its initial value of 1.

  for i in 1..5 by 2 repeat output(i)
   1
   3
   5
                      Type: Void

This expression displays the odd integers between two bounds.

  for i in 5..1 by -2 repeat output(i)
   5
   3
   1
                      Type: Void

Use this to display the numbers in reverse order.

====================================================================
for i in n.. repeat
====================================================================

If the value after the ".." is omitted, the loop has no end test. A
potentially infinite loop is thus created. The variable is given the
successive values n, n+1, n+2, ... and the loop is terminated only
if a leave or return expression is evaluated in the loop body. However,
you may also add some other modifying clause on the repeat, for example,
a while clause, to stop the loop.

  for i in 15.. while not prime?(i) repeat output(i)
   15
   16
                      Type: Void

This loop displays the integers greater than or equal to 15 and less
than the first prime number greater than 15.

====================================================================
for x in l repeat
====================================================================

Another variant of the for loop has the form:

  for x in list repeat loopbody

This form is used when you want to iterate directly over the elements
of a list. In this form of the for loop, the variable x takes on the
value of each successive element in l. The end test is most simply
stated in English: "are there no more x in l?"

  l := [0, -5, 3]
   [0, -5, 3]
                      Type: List Integer

  for x in l repeat output(x)
   0
   -5
   3
                      Type: Void

This displays all of the elements of the list l, one per line.

Since the list constructing expression 

  expand [n..m]

creates the list

  [n, n+1, ..., m]

you might be tempted to think that the loops

  for i in n..m repeat output(i)

and

  for x in expand [n..m] repeat output(x)

are equivalent. The second form first creates the expanded list
(no matter how large it might be) and then does the iteration. The
first form potentially runs in much less space, as the index variable
i is simply incremented once per loop and the list is not actually
created. Using the first form is much more efficient.

Of course, sometimes you really want to iterate across a specific list.
This displays each of the factors of 2400000:

  for f in factors(factor(2400000)) repeat output(f)
   [factor= 2, exponent= 8]
   [factor= 3, exponent= 1]
   [factor= 5, exponent= 5]
                      Type: Void

\end{chunk}

\section{syntax if}
\label{if}
\index{if}
\index{syntax!if}
\index{if!syntax}
\begin{chunk}{if.help}
====================================================================
If-then-else
====================================================================

Like many other programming languages, Axiom uses the three keywords
if, then, and else to form conditional expressions. The else part of
the conditional is optional. The expression between the if and then
keywords is a predicate: an expression that evaluates to or is
convertible to either true or false, that is, a Boolean.

The syntax for conditional expressions is

   if predicate then expression1 else expression2

where the "else expression2" part is optional. The value returned from
a conditional expression is expression1 if the predicate evaluates to
true and expression2 otherwise. If no else clause is given, the value
is always the unique value of Void.

An if-then-else expression always returns a value. If the else clause
is missing then the entire expression returns the unique value of Void.
If both clauses are present, the type of the value returned by if is
obtained by resolving the types of the values of the two clauses.

The predicate must evaluate to, or be convertible to, an object of type
Boolean: true or false. By default, the equal sign "=" creates an equation.

   x + 1 = y
    x + 1 = y
                Type: Equation Polynomial Integer

This is an equation, not a boolean condition. In particular, it is
an object of type Equation Polynomial Integer.

However, for predicates in if expressions, Axiom places a default 
target type of Boolean on the predicate and equality testing is performed.
Thus you need not qualify the "=" in any way. In other contexts you may
need to tell Axiom that you want to test for equality rather than create
an equation. In these cases, use "@" and a target type of Boolean.

The compound symbol meaning "not equal" in Axiom is "~=". This can be
used directly without a package call or a target specification. The
expression "a ~= b" is directly translated to "not(a = b)".

Many other functions have return values of type Boolean. These include
<, <=, >, >=, ~=, and member?. By convention, operations with names
ending in "?" return Boolean values.

The usual rules for piles are suspended for conditional expressions. In
.input files, the then and else keywords can begin in the same column
as the corresponding if by may also appear to the right. Each of the
following styles of writing if-then-else expressions is acceptable:

  if i>0 then output("positive") else output("nonpositive")

  if i>0 then output("positive")
    else output("nonpositive")

  if i>0 then output("positive")
  else output("nonpositive")

  if i>0 
  then output("positive")
  else output("nonpositive")

  if i>0 
    then output("positive")
    else output("nonpositive")

A block can follow the then or else keywords. In the following two 
assignments to a, the then and else clauses each are followed by two
line piles. The value returned in each is the value of the second line.

  a :=
    if i > 0 then
      j := sin(i * pi())
      exp(j + 1/j)
    else
      j := cos(i * 0.5 * pi())
      log(abs(j)**5 + i)


  a :=
    if i > 0 
      then
        j := sin(i * pi())
        exp(j + 1/j)
      else
        j := cos(i * 0.5 * pi())
        log(abs(j)**5 + i)

These are both equivalent to the following:

  a := 
    if i > 0 then (j := sin(i * pi()); exp(j + 1/j))
    else (j := cos(i * 0.5 * pi()); log(abs(j)**5 + i))

\end{chunk}

\section{syntax iterate}
\label{iterate}
\index{iterate}
\index{syntax!iterate}
\index{iterate!syntax}
\begin{chunk}{iterate.help}
====================================================================
iterate in loops
====================================================================

Axiom provides an iterate expression that skips over the remainder
of a loop body and starts the next loop execution. We first initialize
a counter.

  i := 0
   0
                      Type: NonNegativeInteger

Display the even integers from 2 to 5:

  repeat
    i := i + 1
    if i > 5 then leave
    if odd?(i) then iterate
    output(i)
   2
   4
                      Type: Void

\end{chunk}

\section{syntax leave}
\label{leave}
\index{leave}
\index{syntax!leave}
\index{leave!syntax}
\begin{chunk}{leave.help}
====================================================================
leave in loops
====================================================================

The leave keyword is often more useful in terminating a loop. A
leave causes control to transfer to the expression immediately following
the loop. As loops always return the unique value of Void, you cannot
return a value with leave. That is, leave takes no argument.

  f() ==
    i := 1
    repeat
      if factorial(i) > 1000 then leave
      i := i + 1
    i
                      Type: Void

This example is a modification of the last example in the previous
section. Instead of using return we'll use leave.

  f()
   7
                      Type: PositiveInteger

The loop terminates when factorial(i) gets big enough. The last line
of the function evaluates to the corresponding "good" value of i
and the function terminates, returning that value.

You can only use leave to terminate the evaluation of one loop. Lets
consider a loop within a loop, that is, a loop with a nested loop. 
First, we initialize two counter variables.

  (i,j) := (1,1)
   1
                      Type: PositiveInteger

  repeat
    repeat
      if (i + j) > 10 then leave
      j := j + 1
    if (i + j) > 10 then leave
    i := i + 1
                      Type: Void

Nested loops must have multiple leave expressions at the appropriate
nesting level. How would you rewrite this so (i + j) > 10 is only
evaluated once?

====================================================================
leave vs => in loop bodies
====================================================================

Compare the following two loops:

  i := 1                      i := 1
  repeat                      repeat
    i := i + 1                  i := i + 1
    i > 3 => i                  if i > 3 then leave
    output(i)                   output(i)

In the example on the left, the values 2 and 3 for i are displayed but
then the "=>" does not allow control to reach the call to output again.
The loop will not terminate until you run out of space or interrupt the
execution. The variable i will continue to be incremented because the
"=>" only means to leave the block, not the loop.

In the example on the right, upon reaching 4, the leave will be executed,
and both the block and the loop will terminate. This is one of the reasons
why both "=>" and leave are provided. Using a while clase with the "=>"
lets you simulate the action of leave.

\end{chunk}

\section{syntax parallel}
\label{parallel}
\index{parallel}
\index{syntax!parallel}
\index{parallel!syntax}
\begin{chunk}{parallel.help}
====================================================================
parallel iteration
====================================================================

Sometimes you want to iterate across two lists in parallel, or perhaps
you want to traverse a list while incrementing a variable.

The general syntax of a repeat loop is

 iterator1, iterator2, ..., iteratorN repeat loopbody

where each iterator is either a for or a while clause. The loop 
terminates immediately when the end test of any iterator succeeds or 
when a leave or return expression is evaluated in loopbody. The value
returned by the loop is the unique value of Void.

  l := [1,3,5,7]
   [1,3,5,7]
                      Type: List PositiveInteger

  m := [100,200]
   [100,200]
                      Type: List PositiveInteger

  sum := 0
   0
                      Type: NonNegativeInteger

Here we write a loop to iterate across two lists, computing the sum
of the pairwise product of the elements:

  for x in l for y in m repeat
    sum := sum + x*y
                      Type: Void

The last two elements of l are not used in the calculation because
m has two fewer elements than l.

  sum
   700
                      Type: NonNegativeInteger

This is the "dot product".

Next we write a loop to compute the sum of the products of the loop
elements with their positions in the loop.

  l := [2,3,5,7,11,13,17,19,23,29,31,37]
   [2,3,5,7,11,13,17,19,23,29,31,37]
                      Type: List PositiveInteger

  sum := 0
   0
                      Type: NonNegativeInteger

  for i in 0.. for x in l repeat sum := i * x
                      Type: Void

Here looping stops when the list l is exhaused, even though the
for i in 0.. specifies no terminating condition.

  sum 
   407
                      Type: NonNegativeInteger

When "|" is used to qualify any of the for clauses in a parallel 
iteration, the variables in the predicates can be from an outer
scope or from a for clause in or to the left of the modified clause.

This is correct:
 
  for i in 1..10 repeat
    for j in 200..300 | ood? (i+j) repeat
      output [i,j]

But this is not correct. The variable j has not been defined outside
the inner loop:

  for i in 1..01 | odd? (i+j) repeat -- wrong, j not defined
    for j in 200..300 repeat
      output [i,j]

It is possible to mix several of repeat modifying clauses on a loop:

  for i in 1..10
    for j in 151..160 | odd? j
      while i + j < 160 repeat
        output [i,j]
   [1,151]
   [3,153]
                      Type: Void

Here are useful rules for composing loop expressions:

 1. while predicates can only refer to variables that are global (or
    in an outer scope) or that are defined in for clauses to the left
    of the predicate.
 2. A "such that" predicate (somthing following "|") must directly
    follow a for clause and can only refer to variables that are
    global (or in an outer scope) or defined in the modified for clause
    or any for clause to the left.

\end{chunk}

\section{syntax repeat}
\label{repeat}
\index{repeat}
\index{syntax!repeat}
\index{repeat!syntax}
\begin{chunk}{repeat.help}
====================================================================
Repeat Loops
====================================================================

A loop is an expression that contains another expression, called the loop
body, which is to be evaluated zero or more times. All loops contain the
repeat keyword and return the unique value of Void. Loops can contain
inner loops to any depth.

The most basic loop is of the form
 
  repeat loopbody

Unless loopbody contains a leave or return expression, the loop repeats
foreer. The value returned by the loop is the unique value of Void.

Axiom tries to determine completely the type of every object in a loop
and then to translate the loop body to Lisp or even to machine code. This
translation is called compilation.

If Axiom decides that it cannot compile the loop, it issues a message
stating the problem and then the following message:

  We will attemp to step through and interpret the code

It is still possible that Axiom can evalute the loop but in interpret-code
mode.

====================================================================
Return in Loops
====================================================================

A return expression is used to exit a function with a particular value.
In particular, if a return is in a loop within the function, the loop
is terminated whenever the return is evaluated. 

  f() ==
    i := 1
    repeat
      if factorial(i) > 1000 then return i
      i := i + 1
                      Type: Void

  f()
                      Type: Void

When factorial(i) is big enough, control passes from inside the loop
all the way outside the function, returning the value of i (so we think).
What went wrong? Isn't it obvious that this function should return an
integer? Well, Axiom makes no attempt to analyze the structure of a
loop to determine if it always returns a value because, in general, this
is impossible. So Axiom has this simple rule: the type of the function is
determined by the type of its body, in this case a block. The normal value
of a block is the value of its last expression, in this case, a loop. And
the value of every loop is the unique value of Void. So the return type
of f is Void.

There are two ways to fix this. The best way is for you to tell Axiom
what the return type of f is. You do this by giving f a declaration

   f:() -> Integer

prior to calling for its value. This tells Axiom "trust me -- an integer
is returned". Another way is to add a dummy expression as follows.

  f() ==
    i := 1
    repeat
      if factorial(i) > 1000 then return i
      i := i + 1
    0
                      Type: Void

Note that the dummy expression will never be evaluated but it is the
last expression in the function and will determine the return type.

  f()
   7
                      Type: PositiveInteger

====================================================================
leave in loops
====================================================================

The leave keyword is often more useful in terminating a loop. A
leave causes control to transfer to the expression immediately following
the loop. As loops always return the unique value of Void, you cannot
return a value with leave. That is, leave takes no argument.

  f() ==
    i := 1
    repeat
      if factorial(i) > 1000 then leave
      i := i + 1
    i
                      Type: Void

This example is a modification of the last example in the previous
section. Instead of using return we'll use leave.

  f()
   7
                      Type: PositiveInteger

The loop terminates when factorial(i) gets big enough. The last line
of the function evaluates to the corresponding "good" value of i
and the function terminates, returning that value.

You can only use leave to terminate the evaluation of one loop. Lets
consider a loop within a loop, that is, a loop with a nested loop. 
First, we initialize two counter variables.

  (i,j) := (1,1)
   1
                      Type: PositiveInteger

  repeat
    repeat
      if (i + j) > 10 then leave
      j := j + 1
    if (i + j) > 10 then leave
    i := i + 1
                      Type: Void

Nested loops must have multiple leave expressions at the appropriate
nesting level. How would you rewrite this so (i + j) > 10 is only
evaluated once?

====================================================================
leave vs => in loop bodies
====================================================================

Compare the following two loops:

  i := 1                      i := 1
  repeat                      repeat
    i := i + 1                  i := i + 1
    i > 3 => i                  if i > 3 then leave
    output(i)                   output(i)

In the example on the left, the values 2 and 3 for i are displayed but
then the "=>" does not allow control to reach the call to output again.
The loop will not terminate until you run out of space or interrupt the
execution. The variable i will continue to be incremented because the
"=>" only means to leave the block, not the loop.

In the example on the right, upon reaching 4, the leave will be executed,
and both the block and the loop will terminate. This is one of the reasons
why both "=>" and leave are provided. Using a while clase with the "=>"
lets you simulate the action of leave.

====================================================================
iterate in loops
====================================================================

Axiom provides an iterate expression that skips over the remainder
of a loop body and starts the next loop execution. We first initialize
a counter.

  i := 0
   0
                      Type: NonNegativeInteger

Display the even integers from 2 to 5:

  repeat
    i := i + 1
    if i > 5 then leave
    if odd?(i) then iterate
    output(i)
   2
   4
                      Type: Void

Also See: 
o )help blocks
o )help if
o )help while
o )help for
o )help suchthat
o )help parallel
o )help lists

\end{chunk}
\footnote{
\fnref{blocks}
\fnref{if}
\fnref{while}
\fnref{for}
\fnref{suchthat}
\fnref{parallel}
\fnref{lists}}

\section{syntax suchthat}
\label{suchthat}
\index{suchthat}
\index{syntax!suchthat}
\index{suchthat!syntax}
\begin{chunk}{suchthat.help}
====================================================================
Such that predicates
====================================================================

A for loop can be followed by a "|" and then a predicate. The predicate
qualifies the use of the values from the iterator that follows the for.
Think of the vertical bar "|" as the phrase "such that".

  for n in 0..4 | odd? n repeat output n
   1
   3
                      Type: Void

This loop expression prints out the integers n in the given segment
such that n is odd.

A for loop can also be written

  for iterator | predicate repeat loopbody

which is equivalent to:

  for iterator repeat if predicate then loopbody else iterate

The predicate need not refer only to the variable in the for clause.
Any variable in an outer scope can be part of the predicate.

  for i in 1..50 repeat
    for j in 1..50 | factorial(i+j) < 25 repeat
      output [i,j]
   [1,1]
   [1,2]
   [1,3]
   [2,1]
   [2,2]
   [3,1]
                      Type: Void

\end{chunk}

\section{syntax syntax}
\label{syntax}
\begin{chunk}{syntax.help}

The Axiom Interactive Language has the following features documented here.

More information is available by typing

  )help feature

where feature is one of:

  assignment -- Immediate and delayed assignments
  blocks     -- Blocks of expressions
  collection -- creating lists with iterators
  for        -- for loops
  if         -- If-then-else statements
  iterate    -- using iterate in loops
  leave      -- using leave in loops
  parallel   -- parallel iterations
  repeat     -- repeat loops
  suchthat   -- suchthat predicates
  while      -- while loops

\end{chunk}

\section{syntax while}
\index{while}
\index{syntax!while}
\index{while!syntax}
\begin{chunk}{while.help}
====================================================================
while loops
====================================================================

The repeat in a loop can be modified by adding one or more while 
clauses. Each clause contains a predicate immediately following the
while keyword. The predicate is tested before the evaluation of the 
body of the loop. The loop body is evaluated whenever the predicate
in a while clause is true.

The syntax for a simple loop using while is

  while predicate repeat loopbody

The predicate is evaluated before loopbody is evaluated. A while loop
terminates immediately when predicate evaluates to false or when a
leave or return expression is evaluted. See )help repeat for more
information on leave and return.

Here is a simple example of using while in a loop. We first initialize
the counter.

  i := 1
   1
                      Type: PositiveInteger

  while i < 1 repeat
    output "hello"
    i := i + 1
                      Type: Void

The steps involved in computing this example are
 (1) set i to 1
 (2) test the condition i < 1 and determine that it is not true
 (3) do not evaluate the loop body and therefore do not display "hello"

  (x, y) := (1, 1)
   1
                      Type: PositiveInteger

If you have multiple predicates to be tested use the logical and
operation to separate them. Axiom evaluates these predicates from
left to right.

  while x < 4 and y < 10 repeat
    output [x,y]
    x := x + 1
    y := y + 2
   [1,1]
   [2,3]
   [3,5]
                      Type: Void


A leave expression can be included in a loop body to terminate a loop
even if the predicate in any while clauses are not false.

  (x, y) := (1, 1)
   1
                      Type: PositiveInteger

  while x < 4 and y < 10 repeat
    if x + y > 7 then leave
    output [x,y]
    x := x + 1
    y := y + 2
   [1,1]
   [2,3]
                      Type: Void

\end{chunk}

\chapter{Abstract Syntax Trees (ptrees)}
\begin{verbatim}
Abstract Syntax Trees

These functions create and examine abstract
syntax trees.  These are called pform, for short.

!! This file also contains constructors for concrete syntax, although
!! they should be somewhere else.

THE PFORM DATA STRUCTURE
 Leaves: [hd, tok, pos]
 Trees:  [hd, tree, tree, ...]
 hd is either an id or (id . alist)

\end{verbatim}

\defun{tokConstruct}{Construct a leaf token}
The tokConstruct function is a constructer and selectors for leaf tokens.
A leaf token looks like [head, token, position]
where head is either an id or (id . alist)

\calls{tokConstruct}{ifcar}
\calls{tokConstruct}{pfNoPosition?}
\calls{tokConstruct}{ncPutQ}
\begin{chunk}{defun tokConstruct}
(defun |tokConstruct| (head token &rest position)
 (let (result)
  (setq result (cons head token))
  (cond
   ((ifcar position)
    (cond
     ((|pfNoPosition?| (car position)) result)
     (t (|ncPutQ| result '|posn| (car position)) result)))
   (t result))))

\end{chunk}

\defun{pfAbSynOp}{Return a part of a node}
\calls{pfAbSynOp}{ifcar}
\begin{chunk}{defun pfAbSynOp}
(defun |pfAbSynOp| (form)
 (let (hd)
  (setq hd (car form))
  (or (ifcar hd) hd)))

\end{chunk}

\defun{pfAbSynOp?}{Compare a part of a node}
\calls{pfAbSynOp?}{eqcar}
\begin{chunk}{defun pfAbSynOp?}
(defun |pfAbSynOp?| (form op)
 (let (hd)
  (setq hd (car form))
  (or (eq hd op) (eqcar hd op))))

\end{chunk}

\defun{pfNoPosition?}{pfNoPosition?}
\calls{pfNoPosition?}{poNoPosition?}
\begin{chunk}{defun pfNoPosition?}
(defun |pfNoPosition?| (pos)
 (|poNoPosition?| pos))

\end{chunk}

\defun{poNoPosition?}{poNoPosition?}
\calls{poNoPosition?}{eqcar}
\begin{chunk}{defun poNoPosition? 0}
(defun |poNoPosition?| (pos)
 (eqcar pos '|noposition|))

\end{chunk}

\defun{tokType}{tokType}
\calls{tokType}{ncTag}
\begin{chunk}{defun tokType}
(defun |tokType| (x) (|ncTag| x))

\end{chunk}

\defun{tokPart}{tokPart}
\begin{chunk}{defun tokPart 0}
(defun |tokPart| (x) (cdr x))

\end{chunk}

\defun{tokPosn}{tokPosn}
\calls{tokPosn}{qassq}
\calls{tokPosn}{ncAlist}
\calls{tokPosn}{pfNoPosition}
\begin{chunk}{defun tokPosn}
(defun |tokPosn| (x)
 (let (a)
  (setq a (qassq '|posn| (|ncAlist| x)))
  (cond
   (a (cdr a))
   (t (|pfNoPosition|)))))

\end{chunk}

\defun{pfNoPosition}{pfNoPosition}
\calls{pfNoPosition}{poNoPosition}
\begin{chunk}{defun pfNoPosition}
(defun |pfNoPosition| () (|poNoPosition|))

\end{chunk}

\defun{poNoPosition}{poNoPosition}
\usesdollar{poNoPosition}{nopos}
\begin{chunk}{defun poNoPosition 0}
(defun |poNoPosition| ()
 (declare (special |$nopos|))
 |$nopos|)

\end{chunk}

\chapter{Attributed Structures}
For objects which are pairs where the CAR field is either just a tag
(an identifier) or a pair which is the tag and an association list.

\defun{ncTag}{ncTag}
Pick off the tag
\calls{ncTag}{ncBug}
\calls{ncTag}{qcar}
\calls{ncTag}{identp}
\begin{chunk}{defun ncTag}
(defun |ncTag| (x)
 (cond
  ((null (consp x)) (|ncBug| "bad object" nil))
  (t
   (setq x (qcar x))
   (cond
    ((identp x) x)
    ((null (consp x)) (|ncBug| "bad object" nil))
    (t (qcar x))))))

\end{chunk}

\defun{ncAlist}{ncAlist}
Pick off the property list
\calls{ncAlist}{ncBug}
\calls{ncAlist}{qcar}
\calls{ncAlist}{identp}
\calls{ncAlist}{qcdr}
\begin{chunk}{defun ncAlist}
(defun |ncAlist| (x)
 (cond
  ((null (consp x)) (|ncBug| "bad object" nil))
  (t
   (setq x (qcar x))
   (cond
    ((identp x) nil)
    ((null (consp x)) (|ncBug| "bad object" nil))
    (t (qcdr x))))))

\end{chunk}

\defun{ncEltQ}{ncEltQ}
Get the entry for key k on x's association list

\calls{ncEltQ}{qassq}
\calls{ncEltQ}{ncAlist}
\calls{ncEltQ}{ncBug}
\begin{chunk}{defun ncEltQ}
(defun |ncEltQ| (x k)
 (let (r)
  (setq r (qassq k (|ncAlist| x)))
  (cond
   ((null r) (|ncBug| "Association list search failed on %1" (list k)))
   (t (cdr r)))))

\end{chunk}

\defun{ncPutQ}{ncPutQ}
\begin{verbatim}
;-- Put (k . v) on the association list of x and return v
;-- case1: ncPutQ(x,k,v) where k is a key (an identifier), v a value
;--        put the pair (k . v) on the association list of x and return v
;-- case2: ncPutQ(x,k,v) where k is a list of keys, v a list of values
;--        equivalent to [ncPutQ(x,key,val) for key in k for val in v]
;ncPutQ(x,k,v) ==
;   LISTP k =>
;      for key in k for val in v repeat ncPutQ(x,key,val)
;      v
;   r := QASSQ(k,ncAlist x)
;   if NULL r then
;      r := CONS( CONS(k,v), ncAlist x)
;      RPLACA(x,CONS(ncTag x,r))
;   else
;      RPLACD(r,v)
;   v\end{verbatim}
\calls{ncPutQ}{qassq}
\calls{ncPutQ}{ncAlist}
\calls{ncPutQ}{ncTag}
\begin{chunk}{defun ncPutQ}
(defun |ncPutQ| (x k v)
 (let (r)
  (cond
   ((listp k)
    ((lambda (Var1 key Var2 val)
     (loop
      (cond
       ((or (atom Var1) 
            (progn (setq key (car Var1)) nil)
            (atom Var2)
            (progn (setq val (car Var2)) nil))
          (return nil))
        (t
          (|ncPutQ| x key val)))
      (setq Var1 (cdr Var1))
      (setq Var2 (cdr Var2))))
     k nil v nil)
    v)
   (t
    (setq r (qassq k (|ncAlist| x)))
    (cond
     ((null r)
      (setq r (cons (cons k v) (|ncAlist| x)))
      (rplaca x (cons (|ncTag| x) r)))
     (t
      (rplacd r v)))
    v))))

\end{chunk}

\subsection{Special Category Names}

\defdollar{EmptyMode}
The CONTAINED predicate is used to walk internal structures
such as modemaps to see if the $X$ object occurs within $Y$. One
particular use is in a function called isPartialMode to decide
if a modemap is only partially complete. If this is true then the 
modemap will contain the constant \verb|$EmptyMode|. So the call 
ends up being CONTAINED \verb|$EmptyMode| Y. 
\begin{chunk}{initvars}
(defvar |$EmptyMode| '|$EmptyMode|)

\end{chunk}

\defdollar{AnonymousFunction}
\begin{chunk}{initvars}
(defvar |$AnonymousFunction| '(|AnonymousFunction|))

\end{chunk}

\defdollar{Any}
\begin{chunk}{initvars}
(defvar |$Any|   '(|Any|))

\end{chunk}

\defdollar{BFtag}
\begin{chunk}{initvars}
(defvar |$BFtag| '|:BF:|)

\end{chunk}

\defdollar{Boolean}
\begin{chunk}{initvars}
(defvar |$Boolean| '(|Boolean|))

\end{chunk}

\defdollar{Category}
\begin{chunk}{initvars}
(defvar |$Category| '(|Category|))

\end{chunk}

\defdollar{Domain}
\begin{chunk}{initvars}
(defvar |$Domain| '(|Domain|))

\end{chunk}

\defdollar{Exit}
\begin{chunk}{initvars}
(defvar |$Exit|  '(|Exit|))

\end{chunk}

\defdollar{Expression}
\begin{chunk}{initvars}
(defvar |$Expression| '(|OutputForm|))

\end{chunk}

\defdollar{OutputForm}
\begin{chunk}{initvars}
(defvar |$OutputForm| '(|OutputForm|))

\end{chunk}

\defdollar{BigFloat}
\begin{chunk}{initvars}
(defvar |$BigFloat| '(|Float|))

\end{chunk}

\defdollar{Float}
\begin{chunk}{initvars}
(defvar |$Float| '(|Float|))

\end{chunk}

\defdollar{DoubleFloat}
\begin{chunk}{initvars}
(defvar |$DoubleFloat| '(|DoubleFloat|))

\end{chunk}

\defdollar{FontTable}
\begin{chunk}{initvars}
(defvar |$FontTable| '(|FontTable|))

\end{chunk}

\defdollar{Integer}
\begin{chunk}{initvars}
(defvar |$Integer| '(|Integer|))

\end{chunk}

\defdollar{ComplexInteger}
\begin{chunk}{initvars}
(defvar |$ComplexInteger| (LIST '|Complex| |$Integer|))

\end{chunk}

\defdollar{Mode}
\begin{chunk}{initvars}
(defvar |$Mode| '(|Mode|))

\end{chunk}

\defdollar{NegativeInteger}
\begin{chunk}{initvars}
(defvar |$NegativeInteger| '(|NegativeInteger|))

\end{chunk}

\defdollar{NonNegativeInteger}
\begin{chunk}{initvars}
(defvar |$NonNegativeInteger| '(|NonNegativeInteger|))

\end{chunk}

\defdollar{NonPositiveInteger}
\begin{chunk}{initvars}
(defvar |$NonPositiveInteger| '(|NonPositiveInteger|))

\end{chunk}

\defdollar{PositiveInteger}
\begin{chunk}{initvars}
(defvar |$PositiveInteger| '(|PositiveInteger|))

\end{chunk}

\defdollar{RationalNumber}
\begin{chunk}{initvars}
(defvar |$RationalNumber| '(|Fraction| (|Integer|)))

\end{chunk}

\defdollar{String}
\begin{chunk}{initvars}
(defvar |$String| '(|String|))

\end{chunk}

\defdollar{StringCategory}
\begin{chunk}{initvars}
(defvar |$StringCategory| '(|StringCategory|))

\end{chunk}

\defdollar{Symbol}
\begin{chunk}{initvars}
(defvar |$Symbol| '(|Symbol|))

\end{chunk}

\defdollar{Void}
\begin{chunk}{initvars}
(defvar |$Void|  '(|Void|))

\end{chunk}

\defdollar{QuotientField}
\begin{chunk}{initvars}
(defvar |$QuotientField| '|Fraction|)

\end{chunk}

\defdollar{FunctionalExpression}
\begin{chunk}{initvars}
(defvar |$FunctionalExpression| '|Expression|)

\end{chunk}

\defdollar{defaultFunctionTargets}
\begin{chunk}{initvars}
(defvar |$defaultFunctionTargets| '(()))

\end{chunk}

;; Old names
\defdollar{SmallInteger}
\begin{chunk}{initvars}
(defvar |$SmallInteger| '(|SingleInteger|))

\end{chunk}

;; New Names
\defdollar{SingleFloat}
\begin{chunk}{initvars}
(defvar |$SingleFloat| '(|SingleFloat|))

\end{chunk}

\defdollar{DoubleFloat}
\begin{chunk}{initvars}
(defvar |$DoubleFloat| '(|DoubleFloat|))

\end{chunk}

\defdollar{SingleInteger}
\begin{chunk}{initvars}
(defvar |$SingleInteger| '(|SingleInteger|))

\end{chunk}


\chapter{Function Selection}
\begin{verbatim}
New Selection of Modemaps

selection of applicable modemaps is done in two steps:
  first it tries to find a modemap inside an argument domain, and if
  this fails, by evaluation of pattern modemaps
the result is a list of functions with signatures, which have the
  following form:
  [sig,elt,cond] where
    sig is the signature gained by evaluating the modemap condition
    elt is the slot number to get the implementation
    cond are runtime checks which are the results of evaluating the
    modemap condition

the following flags are used:
 $Coerce is NIL, if function selection is done which requires exact
   matches (e.g. for coercion functions)
 if $SubDom is true, then runtime checks have to be compiled
\end{verbatim}

\defun{ofCategory}{ofCategory}
\calls{ofCategory}{identp}
\calls{ofCategory}{ofCategory}
\calls{ofCategory}{hasCaty}
\defsdollar{ofCategory}{Subst}
\defsdollar{ofCategory}{hope}
\begin{chunk}{defun ofCategory}
(defun |ofCategory| (dom cat)
 (let (|$Subst| |$hope|)
 (declare (special |$Subst| |$hope|))
  (cond
   ((identp dom) nil)
   ((and (listp cat) (eq (car cat) '|Join|))
    (every #'(lambda (c) (|ofCategory| dom c)) (cdr cat)))
   (t (not (eq (|hasCaty| dom cat nil) '|failed|))))))

\end{chunk}

\defun{isPartialMode}{isPartialMode}
The isPartialMode function tests whether m contains \verb|$EmptyMode|. The
constant \verb|$EmptyMode| evaluates to \verb?|$EmptyMode|?. This constant 
is inserted in a modemap during compile time if the modemap is not yet 
complete.

\calls{isPartialMode}{contained}
\refsdollar{isPartialMode}{EmptyMode}
\begin{chunk}{defun isPartialMode}
(defun |isPartialMode| (m)
 (declare (special |$EmptyMode|))
 (contained |$EmptyMode| m))

\end{chunk}

\defun{hasCaty}{hasCaty}
This calls hasCat, which looks up a hashtable and returns:
\begin{verbatim}
 1. T, NIL or a (has x1 x2) condition, if cat is not parameterized
 2. a list of pairs (argument to cat,condition) otherwise
\end{verbatim}
then the substitution sl is augmented, or the result is 'failed
\calls{hasCaty}{hasAttSig}
\calls{hasCaty}{subCopy}
\calls{hasCaty}{constructSubst}
\calls{hasCaty}{hasSig}
\calls{hasCaty}{hasAtt}
\calls{hasCaty}{hasCat}
\calls{hasCaty}{opOf}
\calls{hasCaty}{mkDomPvar}
\calls{hasCaty}{domArg}
\calls{hasCaty}{augmentSub}
\calls{hasCaty}{domArg2}
\calls{hasCaty}{unifyStruct}
\calls{hasCaty}{hasCaty1}
\refsdollar{hasCaty}{domPvar}
\begin{chunk}{defun hasCaty}
(defun |hasCaty| (d cat sl)
 (let (x y S z cond sp dom zp s1 ncond i)
 (declare (special |$domPvar|))
  (cond
   ((and (consp cat) (eq (qcar cat) 'category) (consp (qcdr cat)))
     (|hasAttSig| d (|subCopy| (qcddr cat) (|constructSubst| d)) sl))
   ((and (consp cat) (eq (qcar cat) 'signature) (consp (qcdr cat))
         (consp (qcddr cat)) (eq (qcdddr cat) nil))
     (|hasSig| d (qcadr cat) (|subCopy| (qcaddr cat) (|constructSubst| d)) sl))
   ((and (consp cat) (eq (qcar cat) 'attribute)
         (consp (qcdr cat)) (eq (qcddr cat) nil))
     (|hasAtt| d (|subCopy| (qcadr cat) (|constructSubst| d)) sl))
   ((setq x (|hasCat| (|opOf| d) (|opOf| cat)))
    (cond
     ((setq y (ifcdr cat))
       (setq s (|constructSubst| d))
       (do ((next x (cdr next)) (endtest nil (null (eq s1 '|failed|))))
           ((or (atom next) endtest) nil)
         (setq z (caar next))
         (setq cond (cdar next))
         (setq sp
          (loop for item in s
           collect (cons (car item) (|mkDomPvar| (car item) (cdr item) z y))))
         (when |$domPvar|
           (setq i -1)
           (setq dom
            (cons (car d)
             (loop for arg in (rest d)
              collect (|domArg| arg (incf i) z y))))
           (setq sl (|augmentSub| |$domPvar| dom (copy sl))))
         (setq zp
          (loop for a in z
           collect (|domArg2| a s sp)))
         (setq s1 (|unifyStruct| y zp (copy sl)))
         (cond
          ((null (eq s1 '|failed|))
            (setq s1
             (cond
              ((atom cond) s1)
              (t
               (setq ncond (|subCopy| cond s))
               (cond
                ((and (consp ncond) (eq (qcar ncond) '|has|)
                      (consp (qcdr ncond)) (equal (qcadr ncond) d)
                      (consp (qcddr ncond)) (eq (qcdddr ncond) nil)
                      (equal (qcaddr ncond) cat))
                  '|failed|)
                (t (|hasCaty1| ncond s1)))))))
          (t nil)))
        s1)
     ((atom x) sl)
     (t
      (setq ncond (|subCopy| x (|constructSubst| d)))
      (cond
       ((and (consp ncond) (eq (qcar ncond) '|has|) (consp (qcdr ncond))
             (equal (qcadr ncond) d) (consp (qcddr ncond))
             (eq (qcdddr ncond) nil) (equal (qcaddr ncond) cat))
         '|failed|)
       (t (|hasCaty1| ncond sl))))))
   (t '|failed|))))

\end{chunk}

\defun{domArg}{domArg}
\refsdollar{domArg}{FormalMapVariableList}
\begin{chunk}{defun domArg}
(defun |domArg| (type i subs y)
 (let (p)
  (declare (special |$FormalMapVariableList|))
  (if (setq p (member (elt |$FormalMapVariableList| i) subs))
   (elt y (- (|#| subs) (|#| p)))
   type)))

\end{chunk}

\defun{domArg2}{domArg2}
\calls{domArg2}{isSharpVar}
\calls{domArg2}{subCopy}
\refsdollar{domArg2}{domPvar}
\begin{chunk}{defun domArg2}
(defun |domArg2| (arg sl1 sl2)
 (declare (special |$domPvar|))
 (cond
  ((|isSharpVar| arg) (|subCopy| arg sl1))
  ((and (eq arg '$) |$domPvar|) |$domPvar|)
  (t (|subCopy| arg sl2))))

\end{chunk}

\defun{hasSig}{hasSig}
The function hasSig tests whether domain dom has function foo with 
signature sig under substitution sl.
\calls{hasSig}{constructor?}
\calls{hasSig}{cnstructSubst}
\calls{hasSig}{assq}
\calls{hasSig}{getOperationAlistFromLisplib}
\calls{hasSig}{hasCate}
\calls{hasSig}{subCopy}
\calls{hasSig}{hasSigAnd}
\calls{hasSig}{hasSigOr}
\calls{hasSig}{keyedSystemError}
\calls{hasSig}{unifyStruct}
\defsdollar{hasSig}{domPvar}
\begin{chunk}{defun hasSig}
(defun |hasSig| (dom foo sig sl)
 (let (|$domPvar| fun s0 p x cond s)
 (declare (special |$domPvar|))
  (cond
   ((setq fun (|constructor?| (car dom)))
     (setq s0 (|constructSubst| dom))
     (cond
      ((setq p (assq foo (|getOperationAlistFromLisplib| (car dom))))
        (do ((next (cdr p) (cdr next))
             (endtest nil (null (eq s '|failed|))))
            ((or (atom next) endtest) nil)
          (setq x (caar next))
          (setq cond (caddar next))
          (setq s
           (cond
            ((atom cond) (copy sl))
            ((and (consp cond) (eq (qcar cond) '|has|)
                  (consp (qcdr cond)) (consp (qcddr cond)) 
                  (eq (qcdr (qcddr cond)) nil))
              (|hasCate| (|subCopy| (qcadr cond) s0)
                         (|subCopy| (qcaddr cond) s0)
                         (copy sl)))
            ((and (consp cond) 
                  (or (eq (qcar cond) 'and) (eq (qcar cond) '|and|)))
              (|hasSigAnd| (qcdr cond) s0 sl))
            ((and (consp cond) 
                  (or (eq (qcar cond) 'or) (eq (qcar cond) '|or|)))
              (|hasSigOr| (qcdr cond) s0 sl))
            (t
             (|keyedSystemError| 
              "Unexpected error or improper call to system function %1: %2"
              (list "hasSig" "unexpected condition for signature")))))
          (unless (eq s '|failed|)
            (setq s (|unifyStruct| (|subCopy| x s0) sig s))))
        s)
      (t '|failed|)))
   (t '|failed|))))

\end{chunk}

\defun{hasAtt}{hasAtt}
The hasAtt function tests whether dom has attribute att under sl
needs s0 similar to hasSig.
\calls{hasAtt}{subCopy}
\calls{hasAtt}{getdatabase}
\calls{hasAtt}{constructSubst}
\calls{hasAtt}{getInfovec}
\calls{hasAtt}{unifyStruct}
\calls{hasAtt}{hasCatExpression}
\defsdollar{hasAtt}{domPvar}
\begin{chunk}{defun hasAtt}
(defun |hasAtt| (dom att sl)
 (let (|$domPvar| fun atts u x cond s)
 (declare (special |$domPvar|))
  (cond
   ((setq fun (car dom))
    (cond
     ((setq atts 
        (|subCopy| (getdatabase fun 'attributes) (|constructSubst| dom)))
       (cond
        ((consp (setq u (|getInfovec| (car dom))))
          (do ((next atts (cdr next))
               (endtest nil (null (eq s '|failed|))))
              ((or (atom next) endtest) nil)
            (setq x (caar next))
            (setq cond (cdar next))
            (setq s (|unifyStruct| x att (copy sl)))
            (cond
             ((and (null (atom cond)) (null (eq s '|failed|)))
               (setq s (|hasCatExpression| cond s)))))
          s)
        (t
         (do ((next atts (cdr next))
              (endtest nil (null (eq s '|failed|))))
             ((or (atom next) endtest) nil)
           (setq x (caar next))
           (setq cond (cadar next))
           (setq s (|unifyStruct| x att (copy sl)))
           (cond
            ((and (null (atom cond)) (null (eq s '|failed|)))
              (setq s (|hasCatExpression| cond s)))))
         s)))
     (t '|failed|)))
   (t '|failed|))))

\end{chunk}

\defun{hasSigAnd}{hasSigAnd}
\calls{hasSigAnd}{hasCate}
\calls{hasSigAnd}{subCopy}
\calls{hasSigAnd}{keyedSystemError}
\begin{chunk}{defun hasSigAnd}
(defun |hasSigAnd| (andCls s0 sl)
 (let (sa dead)
  (setq sa '|failed|)
  (loop for cls in andCls
   do
    (when dead (return))
    (setq sa
     (cond
      ((atom cls) (copy sl))
      ((and (consp cls) (eq (qcar cls) '|has|) (consp (qcdr cls))
            (consp (qcddr cls)) (eq (qcdddr cls) nil))
        (|hasCate| (|subCopy| (qcadr cls) s0) 
                   (|subCopy| (qcaddr cls) s0) 
                   (copy sl)))
      (t
        (|keyedSystemError| 
         "Unexpected error or improper call to system function %1: %2"
         (list  "hasSigAnd" "unexpected condition for signature")))))
    (when (eq sa '|failed|) (setq dead t)))
  sa))

\end{chunk}

\defun{hasSigOr}{hasSigOr}
\calls{hasSigOr}{hasCate}
\calls{hasSigOr}{hasSigAnd}
\calls{hasSigOr}{keyedSystemError}
\begin{chunk}{defun hasSigOr}
(defun |hasSigOr| (orCls s0 sl)
 (let (sa found)
  (setq sa '|failed|)
  (loop for cls in orCls 
   until found
   do
    (setq sa
     (cond
      ((atom cls) (copy sl))
      ((and (consp cls) (eq (qcar cls) '|has|) (consp (qcdr cls))
            (consp (qcddr cls)) (eq (qcdddr cls) nil))
        (|hasCate| (|subCopy| (qcadr cls) s0) 
                   (|subCopy| (qcaddr cls) s0) 
                   (copy sl)))
      ((and (consp cls) 
            (or (eq (qcar cls) 'and) (eq (qcar cls) '|and|)))
        (|hasSigAnd| (qcdr cls) s0 sl))
      (t
       (|keyedSystemError| 
        "Unexpected error or improper call to system function %1: %2"
        (list  "hasSigOr" "unexpected condition for signature")))))
    (unless (eq sa '|failed|) (setq found t)))
  sa))

\end{chunk}

\defun{hasAttSig}{hasAttSig}
The argument d is domain, x is a list of attributes and signatures.
The result is an augmented SL, if d has x, 'failed otherwise.

\calls{hasAttSig}{hasAtt}
\calls{hasAttSig}{hasSig}
\calls{hasAttSig}{keyedSystemError}
\begin{chunk}{defun hasAttSig}
(defun |hasAttSig| (d x sl)
  (loop for y in x
   until (eq sl '|failed|)
   do
    (setq sl
     (cond
      ((and (consp y) (eq (qcar y) 'attribute) 
            (consp (qcdr y)) (eq (qcddr y) nil))
        (|hasAtt| d (qcadr y) sl))
      ((and (consp y) (eq (qcar y) 'signature)
            (consp (qcdr y)) (consp (qcddr y)) (eq (qcdddr y) nil))
        (|hasSig| d (qcadr y) (qcaddr y) sl))
      (t
       (|keyedSystemError| 
        "Unexpected error or improper call to system function %1: %2"
        (list  "hasAttSig" "unexpected form of unnamed category"))))))
  sl)

\end{chunk}

\defun{hasCate1}{hasCate1}
\calls{hasCate1}{hasCate}
\defsdollar{hasCate1}{domPvar}
\begin{chunk}{defun hasCate1}
(defun |hasCate1| (dom cat sl domPvar)
 (let (|$domPvar|)
 (declare (special |$domPvar|))
  (setq |$domPvar| domPvar)
  (|hasCate| dom cat sl)))

\end{chunk}

\defun{hasCatExpression}{hasCatExpression}
\calls{hasCatExpression}{hasCatExpression}
\calls{hasCatExpression}{hasCate}
\calls{hasCatExpression}{keyedSystemError}
\begin{chunk}{defun hasCatExpression}
(defun |hasCatExpression| (cond sl)
 (let (y)
  (cond
   ((and (consp cond) (eq (qcar cond) 'or))
    (when 
     (let (result)
       (loop for x in (qcdr cond)
        do (setq result 
            (or result 
                (not (eq (setq y (|hasCatExpression| x sl)) '|failed|)))))
        result)
     y))
   ((and (consp cond) (eq (qcar cond) 'and))
    (when
     (let ((result t))
       (loop for x in (qcdr cond)
        do (setq result
            (and result 
                 (not (eq (setq sl (|hasCatExpression| x sl)) '|failed|)))))
       result)
     sl))
   ((and (consp cond) (eq (qcar cond) '|has|)
         (consp (qcdr cond)) (consp (qcddr cond)) (eq (qcdddr cond) nil))
     (|hasCate| (qcadr cond) (qcaddr cond) sl))
   (t
    (|keyedSystemError| 
     "Unexpected error or improper call to system function %1: %2"
     (list  "hasSig" "unexpected condition for attribute"))))))

\end{chunk}

\defun{unifyStruct}{unifyStruct}
\calls{unifyStruct}{isPatternVar}
\calls{unifyStruct}{unifyStructVar}
\calls{unifyStruct}{unifyStruct}
\begin{chunk}{defun unifyStruct}
(defun |unifyStruct| (s1 s2 sl)
 (declare (special |$domPvar| |$hope| |$Coerce| |$Subst|))
  (cond
   ((equal s1 s2) sl)
   (t
    (when (and (consp s1) (eq (qcar s1) '|:|)
               (consp (qcdr s1)) (consp (qcddr s1)) (eq (qcdddr s1) nil))
       (setq s1 (qcadr s1)))
    (when (and (consp s2) (eq (qcar s2) '|:|)
               (consp (qcdr s2)) (consp (qcddr s2)) (eq (qcdddr s2) nil))
       (setq s2 (qcadr s2)))
    (when (and (null (atom s1)) (eq (car s1) '|#|))
       (setq s1 (length (cadr s1))))
    (when (and (null (atom s2)) (eq (car s2) '|#|))
       (setq s2 (length (cadr s2))))
    (cond
      ((equal s1 s2) sl)
      ((|isPatternVar| s1) (|unifyStructVar| s1 s2 sl))
      ((|isPatternVar| s2) (|unifyStructVar| s2 s1 sl))
      ((or (atom s1) (atom s2)) '|failed|)
      (t
       (loop until (or (null s1) (null s2) (eq sl '|failed|))
        do
         (setq sl (|unifyStruct| (car s1) (car s2) sl))
         (setq s1 (cdr s1))
         (setq s2 (cdr s2)))
       (if (or s1 s2) '|failed| sl))))))

\end{chunk}

\defun{unifyStructVar}{unifyStructVar}
The first argument is a pattern variable, which is not substituted by sl
\calls{unifyStructVar}{contained}
\calls{unifyStructVar}{lassoc}
\calls{unifyStructVar}{unifyStruct}
\calls{unifyStructVar}{constructor?}
\calls{unifyStructVar}{subCopy}
\calls{unifyStructVar}{containsVars}
\calls{unifyStructVar}{canCoerce}
\calls{unifyStructVar}{resolveTT}
\calls{unifyStructVar}{isPatternVar}
\calls{unifyStructVar}{augmentSub}
\refsdollar{unifyStructVar}{domPvar}
\refsdollar{unifyStructVar}{Coerce}
\refsdollar{unifyStructVar}{Subst}
\defsdollar{unifyStructVar}{hope}
\begin{chunk}{defun unifyStructVar}
(defun |unifyStructVar| (v ss sl)
 (let (ps s1 s0 s ns0 ns1 s3)
  (declare (special |$domPvar| |$hope| |$Coerce| |$Subst|))
   (cond
    ((contained v ss) '|failed|)
    (t
     (setq ps (lassoc ss sl))
     (setq s1 (if ps ps ss))
     (cond
      ((or (setq s0 (lassoc v sl)) (setq s0 (lassoc v |$Subst|)))
        (setq s (|unifyStruct| s0 s1 (copy sl)))
        (cond
          ((eq s '|failed|)
           (cond
            ((and |$Coerce| (null (atom s0)) (|constructor?| (car s0)))
              (cond
               ((or (|containsVars| s0) (|containsVars| s1))
                 (setq ns0 (|subCopy| s0 sl))
                 (setq ns1 (|subCopy| s1 sl))
                 (cond
                   ((or (|containsVars| ns0) (|containsVars| ns1))
                     (setq |$hope| t)
                     '|failed|)
                   (t
                    (cond
                     ((|canCoerce| ns0 ns1) (setq s3 s1))
                     ((|canCoerce| ns1 ns0) (setq s3 s0))
                     (t (setq s3 nil)))
                    (cond
                     (s3
                      (cond
                        ((not (equal s3 s0))
                          (setq sl (|augmentSub| v s3 sl))))
                      (cond
                       ((and (not (equal s3 s1)) (|isPatternVar| ss))
                          (setq sl (|augmentSub| ss s3 sl))))
                                sl)
                      (t '|failed|)))))
               (|$domPvar|
                (setq s3 (|resolveTT| s0 s1))
                (cond
                 (s3
                  (cond
                   ((not (equal s3 s0))
                     (setq sl (|augmentSub| v s3 sl))))
                  (cond
                   ((and (not (equal s3 s1)) (|isPatternVar| ss))
                     (setq sl (|augmentSub| ss s3 sl))))
                  sl)
                 (t '|failed|)))
               (t '|failed|)))
            (t '|failed|)))
          (t (|augmentSub| v ss s))))
      (t (|augmentSub| v ss sl)))))))

\end{chunk}

\defun{containsVars}{containsVars}
The function containsVars tests whether term t contains a * variable.

\calls{containsVars}{isPatternVar}
\calls{containsVars}{containsVars1}
\begin{chunk}{defun containsVars}
(defun |containsVars| (arg)
 (if (atom arg)
  (|isPatternVar| arg)
  (|containsVars1| arg)))

\end{chunk}

\defun{isPatternVar}{isPatternVar}
\begin{chunk}{defun isPatternVar}
(defun |isPatternVar| (v)
  (and (identp v)
       (member v
             '(** *1 *2 *3 *4 *5 *6 *7 *8 *9 *10 *11 *12 *13 *14 *15
                  *16 *17 *18 *19 *20))
       t))

\end{chunk}

\defun{containsVars1}{containsVars1}
The function containsVars1 tests whether term t contains a * variable.
This is a recursive version, which works on a list.

\calls{containsVars1}{isPatternVar}
\calls{containsVars1}{containsVars1}
\begin{chunk}{defun containsVars1}
(defun |containsVars1| (arg)
 (let ((t1 (car arg)) (t2 (cdr arg)))
  (if (atom t1)
     (or (|isPatternVar| t1)
         (if (atom t2) (|isPatternVar| t2) (|containsVars1| t2)))
     (or (|containsVars1| t1)
         (if (atom t2)  (|isPatternVar| t2) (|containsVars1| t2))))))

\end{chunk}

\defun{hasCaty1}{hasCaty1}
The cond is either a (has a b) or an OR clause of such conditions.
SL is augmented, if cond is true, otherwise the result is 'failed

\calls{hasCaty1}{hasCate}
\calls{hasCaty1}{hasCaty1}
\calls{hasCaty1}{keyedSystemError}
\defsdollar{hasCaty1}{domPvar}
\begin{chunk}{defun hasCaty1}
(defun |hasCaty1| (cond sl)
 (let (|$domPvar| a s)
 (declare (special |$domPvar|))
  (setq |$domPvar| nil)
   (cond
    ((and (consp cond) (eq (qcar cond) '|has|)
          (consp (qcdr cond)) (consp (qcddr cond)) (eq (qcdddr cond) nil))
      (|hasCate| (qcadr cond) (qcaddr cond) sl))
    ((and (consp cond) (EQ (qcar cond) 'and))
     (loop for x in (qcdr cond) 
      while (not (eq s '|failed|))
      do
       (setq s
        (cond
         ((and (consp x) (eq (qcar x) '|has|)
               (consp (qcdr x)) (consp (qcddr x)) (eq (qcdr (qcddr x)) nil))
           (|hasCate| (qcadr x) (qcaddr x) sl))
         ((and (consp x) (eq (qcdr x) nil)
                (consp (qcar x)) (eq (qcaar x) '|has|)
                (consp (qcdar x)) (consp (qcddar x))
                (eq (qcdr (qcddar x)) nil))
           (|hasCate| a (qcaddar x) sl))
         (t (|hasCaty1| x sl)))))
     s)
    ((and (consp cond) (eq (qcar cond) 'or))
      (do ((next (qcdr cond) (cdr next)) (x nil)
           (nextitem nil (null (eq s '|failed|))))
          ((or (atom next)
              (progn (setq x (car next)) nil)
               nextitem)
               nil)
       (setq s
        (cond
         ((and (consp x) (eq (qcar x) '|has|)
               (consp (qcdr x)) (consp (qcddr x)) (eq (qcdddr x) nil))
           (|hasCate| (qcadr x) (qcaddr x) (copy sl)))
         ((and (consp x) (eq (qcdr x) nil) (consp (qcar x))
               (eq (qcaar x) '|has|) (consp (qcdar x)) (consp (qcddar x))
               (eq (qcdddar x) nil))
           (|hasCate| (qcadar x) (qcaddar x) (copy sl)))
         (t (|hasCaty1| x (copy sl))))))
     s)
    (t
     (|keyedSystemError| 
      "Unexpected error or improper call to system function %1: %2"
      (list  "hasCaty1" "unexpected condition from category table"))))))

\end{chunk}

\defun{mkDomPvar}{mkDomPvar}
\calls{mkDomPvar}{domArg}
\calls{mkDomPvar}{length}
\refsdollar{mkDomPvar}{FormalMapVariableList}
\begin{chunk}{defun mkDomPvar}
(defun |mkDomPvar| (p d subs y)
 (let (l)
 (declare (special |$FormalMapVariableList|))
  (if (setq l (member p |$FormalMapVariableList|))
   (|domArg| d (- (|#| |$FormalMapVariableList|) (|#| l)) subs y)
   d)))

\end{chunk}

\defun{hasCate}{hasCate}
\calls{hasCate}{isPatternVar}
\calls{hasCate}{hasCate1}
\calls{hasCate}{hasCateSpecial}
\calls{hasCate}{containsVariables}
\calls{hasCate}{subCopy}
\calls{hasCate}{hasCaty}
\refsdollar{hasCate}{EmptyMode}
\refsdollar{hasCate}{Subst}
\defsdollar{hasCate}{hope}
\begin{chunk}{defun hasCate}
(defun |hasCate| (dom cat sl)
 (let (nsl p s sl1)
 (declare (special |$hope| |$Subst| |$EmptyMode|))
  (cond
   ((equal dom |$EmptyMode|) nil)
   ((|isPatternVar| dom)
    (cond
     ((and (setq p (assq dom sl))
           (not (eq (setq nsl (|hasCate| (cdr p) cat sl)) '|failed|)))
       nsl)
     ((or (setq p (assq dom |$Subst|)) (setq p (assq dom sl)))
       (setq s (|hasCate1| (cdr p) cat sl dom))
       (cond
         ((null (eq s '|failed|)) s)
         (t (|hasCateSpecial| dom (cdr p) cat sl))))
     (t
      (when (not (eq sl '|failed|)) (setq |$hope| t))
      '|failed|)))
   (t
    (setq sl1
     (loop for item in sl
      when (null (|containsVariables| (cdr item)))
      collect item))
    (when sl1 (setq cat (|subCopy| cat sl1)))
    (|hasCaty| dom cat sl)))))

\end{chunk}

\defun{constructSubst}{constructSubst}
\calls{constructSubst}{internl}
\begin{chunk}{defun constructSubst}
(defun |constructSubst| (d)
 (let (sl (i 0))
  (setq sl (list (cons '$ d)))
  (when (listp d) 
   (dolist (x (cdr d))
    (setq i (1+ i))
    (setq sl (cons (cons (internl "#" (princ-to-string i)) x) sl))))
  sl))

\end{chunk}

\defun{hasCateSpecial}{hasCateSpecial}
The variable v is a pattern variable, dom is its binding under \verb|$Subst|.
We try to change dom so that it has category cat under sl.
The result is a substitution list or 'failed.

\calls{hasCateSpecial}{eqcar}
\calls{hasCateSpecial}{isSubDomain}
\calls{hasCateSpecial}{canCoerceFrom}
\calls{hasCateSpecial}{containsVars}
\calls{hasCateSpecial}{augmentSub}
\calls{hasCateSpecial}{hasCate}
\calls{hasCateSpecial}{hasCaty}
\calls{hasCateSpecial}{hasCateSpecialNew}
\refsdollar{hasCateSpecial}{Integer}
\refsdollar{hasCateSpecial}{QuotientField}
\begin{chunk}{defun hasCateSpecial}
(defun |hasCateSpecial| (v dom cat sl)
 (let (arg d domp nsl)
 (declare (special |$Integer| |$QuotientField|))
  (cond
   ((and (consp dom) (eq (qcar dom) '|FactoredForm|)
         (consp (qcdr dom)) (eq (qcddr dom) nil))
     (setq arg (qcadr dom))
     (when (|isSubDomain| arg |$Integer|) (setq arg |$Integer|))
     (setq d (list '|FactoredRing| arg))
     (setq sl (|hasCate| arg '(|Ring|) (|augmentSub| v d sl)))
     (if (eq sl '|failed|)
      '|failed|
      (|hasCaty| d cat sl)))
   ((or (eqcar cat '|Field|) (eqcar cat '|DivisionRing|))
     (when (|isSubDomain| dom |$Integer|) (setq dom |$Integer|))
     (setq d (list |$QuotientField| dom))
     (|hasCaty| dom '(|IntegralDomain|) (|augmentSub| v d sl)))
   ((and (consp cat) (eq (qcar cat) '|PolynomialCategory|)
         (consp (qcdr cat)))
     (setq domp (cons '|Polynomial| (list (qcadr cat))))
     (and (or (|containsVars| (qcadr cat)) (|canCoerceFrom| dom domp))
              (|hasCaty| domp cat (|augmentSub| v domp sl))))
   ((|isSubDomain| dom |$Integer|)
     (setq nsl (|hasCate| |$Integer| cat (|augmentSub| v |$Integer| sl)))
     (if (eq nsl '|failed|) 
      (|hasCateSpecialNew| v dom cat sl)
      (|hasCaty| |$Integer| cat nsl)))
   (t
     (|hasCateSpecialNew| v dom cat sl)))))

\end{chunk}

\defun{hasCateSpecialNew}{hasCateSpecialNew}
\calls{hasCateSpecialNew}{member}
\calls{hasCateSpecialNew}{eqcar}
\calls{hasCateSpecialNew}{augmentSub}
\calls{hasCateSpecialNew}{defaultTargetFE}
\calls{hasCateSpecialNew}{isEqualOrSubDomain}
\calls{hasCateSpecialNew}{underDomainOf}
\calls{hasCateSpecialNew}{hasCaty}
\refsdollar{hasCateSpecialNew}{Integer}
\refsdollar{hasCateSpecialNew}{ComplexInteger}
\refsdollar{hasCateSpecialNew}{RationalNumber}
\begin{chunk}{defun hasCateSpecialNew}
(defun |hasCateSpecialNew| (v dom cat sl)
 (let (fe alg fefull d partialResult)
 (declare (special |$RationalNumber| |$ComplexInteger| |$Integer|))
  (setq fe
   (|member| (qcar cat)
    '(|ElementaryFunctionCategory|
      |TrigonometricFunctionCategory|
      |ArcTrigonometricFunctionCategory|
      |HyperbolicFunctionCategory|
      |ArcHyperbolicFunctionCategory|
      |PrimitiveFunctionCategory|
      |SpecialFunctionCategory| 
      |Evalable|
      |CombinatorialOpsCategory|
      |TranscendentalFunctionCategory|
      |AlgebraicallyClosedFunctionSpace|
      |ExpressionSpace|
      |LiouvillianFunctionCategory|
      |FunctionSpace|)))
  (setq alg
   (|member| (qcar cat)
    '(|RadicalCategory| 
      |AlgebraicallyClosedField|)))
  (setq fefull
   (or fe alg (eqcar cat '|CombinatorialFunctionCategory|)))
  (setq partialResult
   (cond
    ((or (eqcar dom '|Variable|) (eqcar dom '|Symbol|))
      (cond
       ((|member| (car cat)
         '(|SemiGroup| 
           |AbelianSemiGroup| 
           |Monoid|
           |AbelianGroup| 
           |AbelianMonoid|
           |PartialDifferentialRing| 
           |Ring|
           |InputForm|))
         (setq d (list '|Polynomial| |$Integer|))
         (|augmentSub| v d sl))
       ((eqcar cat '|Group|)
         (setq d (list '|Fraction| (list '|Polynomial| |$Integer|)))
         (|augmentSub| v d sl))
       (fefull
        (setq d (|defaultTargetFE| dom))
        (|augmentSub| v d sl))
       (t '|failed|)))
    ((|isEqualOrSubDomain| dom |$Integer|)
      (cond
       (fe
         (setq d (|defaultTargetFE| |$Integer|))
         (|augmentSub| v d sl))
       (alg 
         (setq d '(|AlgebraicNumber|))
         (|augmentSub| v d sl))
       (t '|failed|)))
    ((equal (|underDomainOf| dom) |$ComplexInteger|)
      (setq d (|defaultTargetFE| |$ComplexInteger|))
      (|hasCaty| d cat (|augmentSub| v d sl)))
    ((and (equal dom |$RationalNumber|) alg)
      (setq d '(|AlgebraicNumber|))
      (|augmentSub| v d sl))
    (fefull 
      (setq d (|defaultTargetFE| dom))
      (|augmentSub| v d sl))
    (t '|failed|)))
  (if (eq partialResult '|failed|)
    '|failed|
    (|hasCaty| d cat partialResult))))

\end{chunk}

\defun{defaultTargetFE}{defaultTargetFE}
\calls{defaultTargetFE}{isEqualOrSubDomain}
\calls{defaultTargetFE}{ifcar}
\calls{defaultTargetFE}{defaultTargetFE}
\refsdollar{defaultTargetFE}{FunctionalExpression}
\refsdollar{defaultTargetFE}{Integer}
\refsdollar{defaultTargetFE}{Symbol}
\refsdollar{defaultTargetFE}{RationalNumber}
\begin{chunk}{defun defaultTargetFE}
(defun |defaultTargetFE| (&rest dom)
 (let (a options)
 (declare (special |$FunctionalExpression| |$Integer| |$Symbol|
                   |$RationalNumber|))
  (setq a (car dom))
  (setq options (cdr dom))
  (cond
   ((or (and (consp a) (eq (qcar a) '|Variable|)
             (consp (qcdr a)) (eq (qcddr a) nil))
        (equal a |$RationalNumber|)
        (member (qcar a) (list (qcar |$Symbol|) '|RationalRadicals| '|Pi|))
        (equal a |$SingleInteger|)
        (|isEqualOrSubDomain| a |$Integer|)
        (equal a '(|AlgebraicNumber|)))
     (if (ifcar options)
      (list |$FunctionalExpression| (list '|Complex| |$Integer|))
      (list |$FunctionalExpression| |$Integer|)))
   ((and (consp a) (eq (qcar a) '|Complex|)
         (consp (qcdr a)) (eq (qcddr a) nil))
     (|defaultTargetFE| (qcadr a) t))
   ((and (consp a) (consp (qcdr a)) (eq (qcddr a) nil)
         (member (qcar a) '(|Polynomial| |RationalFunction| |Fraction|)))
     (|defaultTargetFE| (qcadr a) (ifcar options)))
   ((and (consp a) (equal (qcar a) |$FunctionalExpression|)
         (consp (qcdr a)) (eq (qcddr a) nil))
     a)
   ((ifcar options)
     (list |$FunctionalExpression| (list '|Complex| a)))
   (t
     (list |$FunctionalExpression| a)))))

\end{chunk}

\defun{isEqualOrSubDomain}{isEqualOrSubDomain}
\calls{isEqualOrSubDomain}{isSubDomain}
\begin{chunk}{defun isEqualOrSubDomain}
(defun |isEqualOrSubDomain| (d1 d2)
  (or (equal d1 d2) 
      (|isSubDomain| d1 d2)
      (and (atom d1)
           (or (and (consp d2) (eq (qcar d2) '|Variable|)
                    (consp (qcdr d2)) (eq (qcddr d2) nil)
                    (equal (qcadr d2) d1))
               (and (consp d2) (eq (qcdr d2) nil)
                        (equal (qcar d2) d1))))
      (and (atom d2)
           (or (and (consp d1) (eq (qcar d1) '|Variable|)
                    (consp (qcdr d1)) (eq (qcddr d1) nil)
                    (equal (qcadr d1) d2))
               (and (consp d1) (eq (qcdr d1) nil)
                    (equal (qcar d1) d2))))))

\end{chunk}

\chapter{Coercions}

\begin{verbatim}
 main algorithms for canCoerceFrom and coerceInteractive

coerceInteractive and canCoerceFrom are the two coercion functions
for $InteractiveMode. They translate RN, RF and RR to QF I, QF P
and RE RN, respectively, and call coerceInt or canCoerce, which
both work in the same way (e.g. coercion from t1 to t2):
1. they try to coerce t1 to t2 directly (tower coercion), and, if
  this fails, to coerce t1 to the last argument of t2 and embed
  this last argument into t2. These embedding functions are now only
  defined in the algebra code. (RSS 2-27-87)
2. the tower coercion looks whether there is any applicable local
  coercion, which means, one defined in boot or in algebra code.
  If there is an applicable function from a constructor, which is
  inside the type tower of t1, to the top level constructor of t2,
  then this constructor is bubbled up inside t1. This means,
  special coercion functions (defined in boot) are called, which
  commute two constructors in a tower. Then the local coercion is
  called on these constructors, which both are on top level now.
example:
let t1 = A B C D E (short for (A (B (C (D (E))))), where A ... E are
  type constructors), and t2 = F D G H I J
there is no coercion from t1 to t2 directly, so we try to coerce
  t1 to s1 = D G H I J, the last argument of t2
we create the type s2 = A D B C E and call a local coercion A2A
  from t1 to s2, which, by recursively calling coerce, bubbles up
  the constructor D
then we call a commute coerce from s2 to s3 = D A B C E and a local
  coerce D2D from s3 to s1
finally we embed s1 into t2, which completes the coercion t1 to t2
the result of canCoerceFrom is TRUE or NIL
the result of coerceInteractive is a object or NIL (=failed)
all boot coercion functions have the following result:
1. if u=$fromCoerceable$, then TRUE or NIL
2. if the coercion succeeds, the coerced value (this may be NIL)
3. if the coercion fails, they throw to a catch point in
     coerceByFunction

\end{verbatim}

\defun{coerceInteractive}{coerceInteractive}
\calls{coerceInteractive}{objMode}
\calls{coerceInteractive}{objVal}
\calls{coerceInteractive}{clearDependentMaps}
\calls{coerceInteractive}{throwKeyedMsg}
\calls{coerceInteractive}{startTimingProcess}
\calls{coerceInteractive}{mkObj}
\calls{coerceInteractive}{mkObjWrap}
\calls{coerceInteractive}{coerceInt0}
\calls{coerceInteractive}{stopTimingProcess}
\usesdollar{coerceInteractive}{insideCoerceInteractive}
\usesdollar{coerceInteractive}{OutputForm}
\usesdollar{coerceInteractive}{mapName}
\usesdollar{coerceInteractive}{compilingMap}
\usesdollar{coerceInteractive}{NoValueMode}
\usesdollar{coerceInteractive}{EmptyMode}
\begin{chunk}{defun coerceInteractive}
(defun |coerceInteractive| (triple t2)
 (let (|$insideCoerceInteractive| t1 val expr2 result)
  (declare (special |$insideCoerceInteractive| |$OutputForm|
                    |$mapName| |$compilingMap| |$NoValueMode| |$EmptyMode|))
   (setq t1 (|objMode| triple))
   (setq val (|objVal| triple))
   (cond
    ((or (null t2) (equal t2 |$EmptyMode|)) nil)
    ((equal t2 t1) triple)
    ((equal t2 '|$NoValueMode|) (mkObj val t2))
    (t
     (when (eq (car t2) '|SubDomain|) (setq t2 (second t2)))
     (cond
      ((|member| t1
        '((|Category|) (|Mode|) (|Domain|) (|SubDomain| (|Domain|))))
       (when (equal t2 |$OutputForm|) (mkObj val t2)))
      ((equal t1 '|$NoValueMode|)
       (when |$compilingMap| (|clearDependentMaps| |$mapName| nil))
       (|throwKeyedMsg|
        (format nil
          "You are trying to use something (probably a loop) in a ~
           situation where a value is expected.  In particular, you ~
           are trying to convert this to the type %1p . The following ~
           information may help:  possible function name:  %2p")
         (list t2 |$mapName|)))
      (t
       (setq |$insideCoerceInteractive| t)
       (setq expr2 (equal t2 |$OutputForm|))
       (cond
        (expr2 (|startTimingProcess| '|print|))
        (t (|startTimingProcess| '|coercion|)))
       (setq result
        (cond
         ((and expr2 (equal t1 val)) (mkObj val |$OutputForm|))
         ((and expr2 (eq (car t1) '|Variable|))
           (mkObjWrap (second t1) |$OutputForm|))
         (t (|coerceInt0| triple t2))))
          (cond
           (expr2 (|stopTimingProcess| '|print|))
           (t (|stopTimingProcess| '|coercion|)))
          result))))))

\end{chunk}

\defun{coerceInt}{coerceInt}
\calls{coerceInt}{coerceInt1}
\calls{coerceInt}{objMode}
\calls{coerceInt}{getMinimalVarMode}
\calls{coerceInt}{unwrap}
\calls{coerceInt}{objVal}
\calls{coerceInt}{coerceInt}
\begin{chunk}{defun coerceInt}
(defun |coerceInt| (triple t2)
 (let (val newMode newVal)
  (if (setq val (|coerceInt1| triple t2))
    val
    (when (eq (car (|objMode| triple)) '|Variable|)
     (setq newMode (|getMinimalVarMode| (|unwrap| (|objVal| triple)) nil))
     (setq newVal (|coerceInt| triple newMode))
     (|coerceInt| newVal t2)))))

\end{chunk}

\defun{coerceInt0}{coerceInt0}
\calls{coerceInt0}{objVal}
\calls{coerceInt0}{objMode}
\calls{coerceInt0}{conCoerceFrom}
\calls{coerceInt0}{isWrapped}
\calls{coerceInt0}{intCodeGenCOERCE}
\calls{coerceInt0}{unwrap}
\calls{coerceInt0}{coerceInt0}
\calls{coerceInt0}{mkObj}
\calls{coerceInt0}{coerceInt}
\calls{coerceInt0}{objSetMode}
\usesdollar{coerceInt0}{OutputForm}
\usesdollar{coerceInt0}{Any}
\usesdollar{coerceInt0}{genValue}
This is the top level interactive coercion, which transfers all RN, RF and RR
into equivalent types
\begin{chunk}{defun coerceInt0}
(defun |coerceInt0| (triple t2)
 (prog (val t1 s1 s2 let1 t1p valp ans x)
  (declare (special |$OutputForm| |$Any| |$genValue|))
  (return
   (progn
    (setq val (|objVal| triple))
    (setq t1 (|objMode| triple))
    (cond
     ((eq val '|$fromCoerceable$|) (|canCoerceFrom| t1 t2))
     ((equal t1 t2) triple)
     (t
      (cond
       ((equal t2 |$OutputForm|) (setq s1 t1) (setq s2 t2))
       (t
        (setq s1 t1)
        (setq s2 t2)
        (when (equal s1 s2) (return (mkObj val t2)))))
      (cond
       ; handle case where we must generate code
       ((and (null (|isWrapped| val))
             (or
              (null (eq (car t1) '|FunctionCalled|))
              (null |$genValue|)))
        (|intCodeGenCOERCE| triple t2))
       ((and (equal t1 |$Any|) 
             (nequal t2 |$OutputForm|)
             (progn
              (setq let1 (|unwrap| val))
              (setq t1p (car let1))
              (setq valp (cdr let1))
              let1)
             (setq ans (|coerceInt0| (mkObjWrap valp t1p) t2)))
         ans)
       (t
        (unless (eq s1 t1) (setq triple (mkObj val s1)))
        (when (setq x (|coerceInt| triple s2))
         (cond
          ((eq s2 t2) x)
          (t 
           (|objSetMode| x t2)
           x)))))))))))

\end{chunk}

\defun{coerceInt1}{coerceInt1}
This is general interactive coercion. The result is a new triple
with type m2 or NIL (= failed).
\calls{coerceInt1}{NRTcompileEvalForm}
\calls{coerceInt1}{absolutelyCanCoerceByCheating}
\calls{coerceInt1}{asTupleAsList}
\calls{coerceInt1}{bottomUp}
\calls{coerceInt1}{coerceByFunction}
\calls{coerceInt1}{coerceInt1}
\calls{coerceInt1}{coerceInt2Union}
\calls{coerceInt1}{coerceIntAlgebraicConstant}
\calls{coerceInt1}{coerceIntFromUnion}
\calls{coerceInt1}{coerceIntTower}
\calls{coerceInt1}{coerceIntX}
\calls{coerceInt1}{coerceInt}
\calls{coerceInt1}{coerceRetract}
\calls{coerceInt1}{coerceSubDomain}
\calls{coerceInt1}{compareTypeLists}
\calls{coerceInt1}{deconstructT}
\calls{coerceInt1}{evalDomain}
\calls{coerceInt1}{getFunctionFromDomain}
\calls{coerceInt1}{getValue}
\calls{coerceInt1}{isEqualOrSubDomain}
\calls{coerceInt1}{isSubDomain}
\calls{coerceInt1}{mkAtreeNode}
\calls{coerceInt1}{mkAtree}
\calls{coerceInt1}{mkObjWrap}
\calls{coerceInt1}{mkObj}
\calls{coerceInt1}{nequal}
\calls{coerceInt1}{nreverse0}
\calls{coerceInt1}{objMode}
\calls{coerceInt1}{objVal}
\calls{coerceInt1}{selectLocalMms}
\calls{coerceInt1}{selectMms1}
\calls{coerceInt1}{transferPropsToNode}
\calls{coerceInt1}{unwrap}
\catches{coerceInt1}{coerceOrCroaker}
\usesdollar{coerceInt1}{useCoerceOrCroak}
\usesdollar{coerceInt1}{Integer}
\usesdollar{coerceInt1}{QuotientField}
\usesdollar{coerceInt1}{e}
\usesdollar{coerceInt1}{genValue}
\usesdollar{coerceInt1}{Symbol}
\usesdollar{coerceInt1}{AnonymousFunction}
\usesdollar{coerceInt1}{OutputForm}
\usesdollar{coerceInt1}{String}
\usesdollar{coerceInt1}{Any}
\usesdollar{coerceInt1}{Void}
\usesdollar{coerceInt1}{NonNegativeInteger}
\usesdollar{coerceInt1}{PositiveInteger}
\usesdollar{coerceInt1}{EmptyMode}
\usesdollar{coerceInt1}{SingleInteger}
\begin{chunk}{defun coerceInt1}
(defun |coerceInt1| (triple t2)
 (prog (|$useCoerceOrCroak| t1 sintp t1p valp s body vars tree val symNode 
        mms ml oldName intName t3 triplep let1 arg tt ans)
 (declare (special |$useCoerceOrCroak| |$Integer| |$QuotientField|
                   |$e| |$genValue| |$Symbol| |$AnonymousFunction|
                   |$OutputForm| |$String| |$Any| |$Void| |$SingleInteger|
                   |$NonNegativeInteger| |$PositiveInteger| |$EmptyMode|))
  (return
   (seq 
    (progn
     (setq |$useCoerceOrCroak| t)
     (cond
      ((equal t2 |$EmptyMode|) nil)
      (t 
       (setq t1 (|objMode| triple))
       (cond
        ((equal t1 t2) triple)
        (t
         (setq val (|objVal| triple))
         (cond
          ((|absolutelyCanCoerceByCheating| t1 t2) (mkObj val t2))
          ((|isSubDomain| t2 t1) (|coerceSubDomain| val t1 t2))
          (t
           (cond
            ((equal t1 |$SingleInteger|)
             (cond
              ((or (equal t2 |$Integer|) (equal t2 |$SingleInteger|))
                (return (mkObj val t2)))
              (t
               (setq sintp (typep val 'fixnum))
               (cond
                ((and sintp (equal t2 |$PositiveInteger|) (> val 0))
                  (return (mkObj val t2)))
                ((and sintp (equal t2 |$NonNegativeInteger|) (>= val 0))
                  (return (mkObj val t2))))))))
           (cond
            ((and (equal t2 |$SingleInteger|)
                  (|isEqualOrSubDomain| t1 |$Integer|)
                  (integerp val))
              (cond
               ((typep val 'fixnum) (mkObj val t2))
               (t nil)))
            ((equal t2 |$Void|) (mkObj (|voidValue|) |$Void|))
            ((equal t2 |$Any|) (mkObjWrap (cons t1 (|unwrap| val)) '(|Any|)))
            ((and (equal t1 |$Any|)
                  (nequal t2 |$OutputForm|)
                  (progn
                   (setq let1 (|unwrap| val))
                   (setq t1p (car let1))
                   (setq valp (cdr let1))
                   let1)
                  (setq ans (|coerceInt| (mkObjWrap valp t1p) t2)))
                ans)
              ; tagged union selectors
            ((or (and (eq (car t1) '|Variable|) (equal (cadr t1) t2))
                 (and (eq (car t2) '|Variable|) (equal (cadr t2) t1)))
              (mkObj val t2))
            ((stringp t2)
                 (cond
                  ((and (eq (first t1) '|Variable|)
                        (equal t2 (pname (second t1))))
                    (mkObjWrap t2 t2))
                  (t
                   (setq valp (|unwrap| val))
                   (when (and (equal t2 valp)
                              (or (equal valp t1) (equal t1 |$String|)))
                    (mkObj val t2)))))
            ((eq (first t1) '|Tuple|)
              (|coerceInt1|
               (mkObjWrap
                (|asTupleAsList| (|unwrap| val))
                (list '|List| (setq s (second t1))))
               t2))
            ((and (consp t1) (eq (qcar t1) '|Union|))
              (|coerceIntFromUnion| triple t2))
            ((and (consp t2) (eq (qcar t2) '|Union|))
              (|coerceInt2Union| triple t2))
            ((and (stringp t1) (equal t2 |$String|))
              (mkObj val |$String|))
            ((and (stringp t1) (eq (car t2) '|Variable|))
              (when (equal t1 (pname (second t2))) (mkObjWrap (second t2) t2)))
            ((and (stringp t1) (equal t1 (|unwrap| val)))
              (when (equal t2 |$OutputForm|) (mkObj t1 |$OutputForm|)))
            ((atom t1) nil)
            (t
             (cond
              ((and (equal t1 |$AnonymousFunction|)
                    (eq (car t2) '|Mapping|))
                (setq |$useCoerceOrCroak| nil)
                (setq let1 (|unwrap| val))
                (setq vars (cadr let1))
                (setq body (cddr let1))
                (setq vars
                 (cond
                  ((atom vars) (cons vars nil))
                  ((and (consp vars) (eq (qcar vars) '|Tuple|)) (cdr vars))
                  (t vars)))
                (cond
                 ((nequal (|#| (cddr t2)) (|#| vars)) '|continue|)
                 (t
                  (setq tree
                   (|mkAtree|
                    (cons 'adef
                     (cons vars
                      (cons (cons (cadr t2) (cddr t2))
                       (cons (loop for x in (cdr t2) collect nil)
                        body))))))
                  (cond
                   ((eq
                     (catch '|coerceOrCroaker| (|bottomUp| tree)) '|croaked|)
                     nil)
                   (t (return (|getValue| tree))))))))
           (cond
            ((and (equal t1 |$Symbol|) (eq (car t2) '|Mapping|))
              (cond
               ((null (setq mms
                       (|selectMms1| (|unwrap| val) nil 
                         (cddr t2) (cddr t2) (cadr t2))))
                 nil)
               (t
                (cond
                 ((nequal (cadaar mms) (cadr t2)) nil)
                 (|$genValue|
                  (mkObjWrap 
                   (|getFunctionFromDomain|
                    (|unwrap| val) (caaar mms) (cddaar mms)) t2))
                 (t
                  (mkObj
                   (|NRTcompileEvalForm| 
                      (|unwrap| val) (cdaar mms) (|evalDomain| (caaar mms)))
                    t2))))))
            ((and (eq (car t1) '|Variable|) (eq (car t2) '|Mapping|))
              (setq mms 
               (|selectMms1| (cadr t1) (cadr t2) (cddr t2) (cddr t2) nil))
              (cond
               ((and (null mms)
                     (null 
                      (setq mms 
                       (|selectMms1| (cadr t1) (cadr t2) 
                                     (cddr t2) (cddr t2) t))))
                 nil)
               (t
                (cond
                 ((nequal (cadaar mms) (cadr t2)) nil)
                 ((eq (caaaar mms) '|_FreeFunction_|) 
                   (mkObj (cdaaar mms) t2))
                 (|$genValue|
                   (mkObjWrap
                    (|getFunctionFromDomain| (cadr t1) (caaar mms) 
                                             (cddaar mms)) t2))
                 (t
                  (mkObj
                    (|NRTcompileEvalForm| (cadr t1) (cdr (caar mms)) 
                     (|evalDomain| (caaar mms)))
                    t2))))))
            ((and (eq (car t1) '|FunctionCalled|) (eq (qcar t2) '|Mapping|))
              (setq symNode (|mkAtreeNode| (cadr t1)))
              (|transferPropsToNode| (cadr t1) symNode)
              (cond
               ((null
                 (setq mms
                  (|selectLocalMms| symNode (cadr t1) (cddr t2) (cadr t2))))
                 nil)
               (t
                (cond
                 ((nequal (cadaar mms) (cadr t2)) nil)
                 (t
                  (setq ml (cons (cadr t2) (cddr t2)))
                  (setq intName
                   (when
                    (some #'(lambda (mm)
                             (setq oldName (second mm))
                             (|compareTypeLists| (cdar mm) ml)) mms)
                    (list oldName)))
                  (cond
                   ((null intName) nil)
                   (t (mkObjWrap intName t2))))))))
            ((eq (car t1) '|FunctionCalled|)
              (setq t3 (|get| (second t1) '|mode| |$e|))
              (when (and (eq (car t3) '|Mapping|)
                         (setq triplep (|coerceInt| triple t3)))
               (|coerceInt| triplep t2)))
            ((and (eq (car t1) '|Variable|)
                  (consp t2)
                  (or (|isEqualOrSubDomain| t2 |$Integer|)
                      (equal t2 (list |$QuotientField| |$Integer|))
                      (member (car t2)
                       '(|RationalNumber| |BigFloat|
                         |NewFloat| |Float| |DoubleFloat|))))
               nil)
            (t
             (setq ans
              (or
               (|coerceRetract| triple t2)
               (|coerceIntTower| triple t2)
               (progn
                (setq arg (cdr (|deconstructT| t2)))
                (and arg
                 (progn
                   (setq tt (|coerceInt| triple (|last| arg)))
                   (and tt (|coerceByFunction| tt t2)))))))
             (or ans
                 (and (|isSubDomain| t1 |$Integer|)
                      (|coerceInt| (mkObj val |$Integer|) t2))
                 (|coerceIntAlgebraicConstant| triple t2)
                 (|coerceIntX| val t1 t2)))))))))))))))))

\end{chunk}

\defun{coerceByFunction}{coerceByFunction}
\begin{chunk}{defun coerceByFunction}
(defun |coerceByFunction| (t$ m2)
 (let ($ m1 ud x tmp1 a tmp2 b funName mm dc tar args slot dcVector fun fn
       d val env code)
  (declare (special $ |$coerceFailure| |$Boolean|))
  (setq x (|objVal| T$))
  (cond
   ((eq x '|$fromCoerceable$|) nil)
   ((eq (car m2) '|Union|) nil)
   (t
    (setq m1 (|objMode| t$))
    (cond
     ((and (consp m2) (eq (qcar m2) '|Boolean|)
           (consp m1) (eq (qcar m1) '|Equation|)
           (PROGN
            (setq tmp1 (cdr m1))
            (and (consp tmp1) (eq (cdr tmp1) nil)
                 (progn (setq ud (car tmp1)) t))))
       (setq dcVector (|evalDomain| ud))
       (setq fun
        (cond
         ((|isWrapped| x)
          (|NRTcompiledLookup| '= (list |$Boolean| '$ '$) dcVector))
         (t
          (|NRTcompileEvalForm| '= (list |$Boolean| '$ '$) dcVector))))
       (setq fn (car fun))
       (setq d (cdr fun))
       (cond
        ((|isWrapped| x) 
         (setq x (|unwrap| x))
         (mkObjWrap (spadcall (car x) (cdr x) fun) m2))
        ((null (and (consp x) (eq (car x) 'spadcall)
               (progn
                (setq tmp1 (cdr x))
                (and (consp tmp1)
                     (progn
                      (setq a (car tmp1))
                      (setq tmp2 (cdr tmp1))
                      (and (consp tmp2)
                           (progn
                            (setq b (car tmp2)) t)))))))
          (|keyedSystemError| "Generated code is incorrect for equation" nil))
        (t
         (setq code (list 'spadcall a b fun))
         (mkObj code |$Boolean|))))
     (t
      (cond
       ((null 
         (setq mm (|coerceConvertMmSelection| (setq funName '|coerce|) m1 m2)))
        (setq mm 
         (|coerceConvertMmSelection| (setq funName '|convert|) m1 m2))))
      (when mm
        (setq dc (caar mm))
        (setq tar (cadar mm))
        (setq args (cddar mm))
        (setq slot (cadr mm))
        (setq dcVector (|evalDomain| dc))
        (setq fun
         (cond
          ((|isWrapped| x) (|NRTcompiledLookup| funName slot dcVector))
          (t (|NRTcompileEvalForm| funName slot dcVector))))
        (setq fn (car fun))
        (setq d (cdr fun))
        (cond
         ((equal fn #'|Undef|) nil)
         ((|isWrapped| x)
          (setq $ dcVector)
          (setq val (catch '|coerceFailure| (spadcall (|unwrap| x) fun)))
          (cond
           ((equal val |$coerceFailure|) nil)
           (t (mkObjWrap val m2))))
         (t
          (setq env fun)
          (setq code (list '|failCheck| (list 'spadcall x env)))
          (mkObj code m2))))))))))

\end{chunk}

\defun{coerceIntTower}{coerceIntTower}
This tries to find a coercion from top level t2 to somewhere inside t1
It builds a new argument type, for which coercion is called recursively
\calls{coerceIntTower}{coerceIntPermute}
\calls{coerceIntTower}{coerceIntSpecial}
\calls{coerceIntTower}{last}
\calls{coerceIntTower}{coerceIntTest}
\calls{coerceIntTower}{constructT}
\calls{coerceIntTower}{replaceLast}
\calls{coerceIntTower}{deconstructT}
\calls{coerceIntTower}{bubbleConstructor}
\calls{coerceIntTower}{isValidType}
\calls{coerceIntTower}{coerceIntCommute}
\calls{coerceIntTower}{coerceIntByMap}
\calls{coerceIntTower}{coerceIntTableOrFunction}
\begin{chunk}{defun coerceIntTower}
(defun |coerceIntTower| (triple t2)
 (let (t1 c1 arg1 tt c arg tl let1 c2 arg2 s x)
  (cond
   ((setq x (|coerceIntByMap| triple t2)) x)
   ((setq x (|coerceIntCommute| triple t2)) x)
   ((setq x (|coerceIntPermute| triple t2)) x)
   ((setq x (|coerceIntSpecial| triple t2)) x)
   ((setq x (|coerceIntTableOrFunction| triple t2)) x)
   (t
    (setq t1 (|objMode| triple))
    (setq let1 (|deconstructT| t1))
    (setq c1 (car let1))
    (setq arg1 (cdr let1))
    (and arg1
         (progn
          (setq tl nil)
          (setq arg arg1)
          (loop until (or x (not arg)) do
           (setq tt (|last| arg))
           (setq let1 (|deconstructT| tt))
           (setq c (car let1))
           (setq arg (cdr let1))
           (setq tl (cons c (cons arg tl)))
           (cond
            ((setq x (and arg (|coerceIntTest| tt t2)))
             (cond
              ((cddr tl)
                (setq s 
                 (|constructT| c1 
                  (|replaceLast| arg1 (|bubbleConstructor| tl))))
                (cond
                 ((null (|isValidType| s)) (setq x nil))
                 ((setq x (or (|coerceIntByMap| triple s)
                              (|coerceIntTableOrFunction| triple s)))
                   (setq let1 (|deconstructT| (|last| s)))
                   (setq c2 (car let1))
                   (setq arg2 (cdr let1))
                   (setq s (|bubbleConstructor| (list c2 arg2 c1 arg1)))
                   (cond
                    ((null (|isValidType| s)) (setq x nil))
                    ((setq x (|coerceIntCommute| x s))
                      (setq x (or (|coerceIntByMap| x t2)
                                  (|coerceIntTableOrFunction| x t2))))))))
              (t
               (setq s (|bubbleConstructor| (list c arg c1 arg1)))
               (cond
                ((null (|isValidType| s)) (setq x nil))
                ((setq x (|coerceIntCommute| triple s))
                  (setq x (or (|coerceIntByMap| x t2)
                              (|coerceIntTableOrFunction| x t2))))))))))
          x))))))

\end{chunk}

\defun{coerceIntTest}{coerceIntTest}
This looks whether there exists a table entry or a coercion function.
Thus the type can be bubbled before coerceIntTableOrFunction is called.
\calls{coerceIntTest}{coerceConvertMmSelection}
\calls{coerceIntTest}{assq}
\usesdollar{coerceIntTest}{CoerceTable}
\usesdollar{coerceIntTest}{useConvertForCoercions}
\begin{chunk}{defun coerceIntTest}
(defun |coerceIntTest| (t1 t2)
 (let (p b)
  (declare (special |$useConvertForCoercions| |$CoerceTable|))
  (or (equal t1 t2)
      (setq b
       (and (setq p (assq (car t1) |$CoerceTable|))
            (assq (car t2) (cdr p))))
      (or b 
          (|coerceConvertMmSelection| '|coerce| t1 t2)
          (and |$useConvertForCoercions|
               (|coerceConvertMmSelection| '|convert| t1 t2))))))

\end{chunk}

\defvar{coerceConvertMmSelection;AL}
\begin{chunk}{initvars}
(defvar |coerceConvertMmSelection;AL| (make-hash-table :test #'equal))

\end{chunk}

\defun{coerceConvertMmSelection}{coerceConvertMmSelection}
This calls selectMms with \verb|$Coerce=NIL| and tests for required
target type. funName is either 'coerce or 'convert.
\begin{verbatim}
  mmS := [[sig,[targ,arg],:pred] for x in l | x is [sig,[.,arg],:pred] and
    hasCorrectTarget(m2,sig) and sig is [dc,targ,oarg] and oarg = m1]
\end{verbatim}
\calls{coerceConvertMmSelection}{selectMms1}
\usesdollar{coerceConvertMmSelection}{reportBottomUpFlag}
\usesdollar{coerceConvertMmSelection}{declaredMode}
\usesdollar{coerceConvertMmSelection}{coerceConvertMmSelection;AL}
\begin{chunk}{defun coerceConvertMmSelection}
(defun |coerceConvertMmSelection| (&rest g1)
 (labels (
  (checktargets (funName m1 m2)
   (let (|$declaredMode| |$reportBottomUpFlag|)
   (declare (special |$declaredMode| |$reportBottomUpFlag|
             |coerceConvertMmSelection;AL|))
    (setq |$declaredMode| nil)
    (setq |$reportBottomUpFlag| nil)
    (car
     (loop for x in (|selectMms1| funName m2 (list m1) (list m1) nil)
      collect
      (when (and (|hasCorrectTarget| m2 (car x)) (equal (caddar x) m1))
       (cons (car x) (cons (cons (cadar x) (list (cadadr x))) (cddr x)))))))))
 (let (g3)
  (if (setq g3 (hget |coerceConvertMmSelection;AL| g1))
    (|CDRwithIncrement| g3)
    (cdr (hput |coerceConvertMmSelection;AL| g1
          (cons 1 (apply #'checktargets g1))))))))

\end{chunk}

\defun{hasCorrectTarget}{hasCorrectTarget}
This tests whether the target of signature sig is either m or a union
containing m. It also discards TEQ as it is not meant to be used at top-level
\begin{chunk}{defun hasCorrectTarget 0}
(defun |hasCorrectTarget| (m sig)
 (let (tar)
  (setq tar (second sig))
  (cond
   ((eq (caar sig) '|TypeEquivalence|) nil)
   ((equal m tar) t)
   ((and (eq (car tar) '|Union|) 
         (eq (third tar) '|failed|))
    (equal (second tar) m))
   ((and (eq (car tar) '|Union|) 
         (eq (second tar) '|failed|)
         (equal (third tar) m))))))

\end{chunk}

\defun{coerceIntPermute}{coerceIntPermute}
\calls{coerceIntPermute}{member}
\calls{coerceIntPermute}{objMode}
\calls{coerceIntPermute}{computeTTTranspositions}
\calls{coerceIntPermute}{coerceInt}
\begin{chunk}{defun coerceIntPermute}
(defun |coerceIntPermute| (object t2)
 (let (t1 towers ok)
  (cond
   ((|member| t2 '((|Integer|) (|OutputForm|))) nil)
   (t
     (setq t1 (|objMode| object))
     (setq towers (|computeTTTranspositions| t1 t2))
     ; At this point, CAR towers = t1 and last towers should be similar
     ; to t2 in the sense that the components of t1 are in the same order
     ; as in t2. If length towers = 2 and t2 = last towers, we quit to
     ; avoid an infinte loop.
     (cond
      ((or (null towers) (null (cdr towers))) nil)
      ((and (null (cddr towers)) (equal t2 (cadr towers))) nil)
      (t
       (setq ok t)
       ;  do the coercions successively, quitting if any fail
       (loop for tt in (cdr towers) while ok do
         (unless (setq object (|coerceInt| object tt)) (setq ok nil)))
       (when ok object)))))))

\end{chunk}

\defun{computeTTTranspositions}{computeTTTranspositions}
\calls{computeTTTranspositions}{decomposeTypeIntoTower}
\calls{computeTTTranspositions}{member}
\calls{computeTTTranspositions}{nequal}
\calls{computeTTTranspositions}{msort}
\calls{computeTTTranspositions}{remdup}
\calls{computeTTTranspositions}{length}
\calls{computeTTTranspositions}{list2vec}
\calls{computeTTTranspositions}{permuteToOrder}
\calls{computeTTTranspositions}{vec2list}
\calls{computeTTTranspositions}{reassembleTowerIntoType}
\begin{chunk}{defun computeTTTranspositions}
(defun |computeTTTranspositions| (t1 t2)
 (labels (
  (compress (z start len)
   (cond
    ((>= start len) z)
    ((|member| start z) (compress z (1+ start) len))
    (t
     (compress
      (loop for i in z collect (if (> start i) i (1- i))) start len)))))
 (let (tl1 tl2 p2p n1 p2 perms tower tt towers)
  ;  decompose t1 into its tower parts
  (setq tl1 (|decomposeTypeIntoTower| t1))
  (setq tl2 (|decomposeTypeIntoTower| t2))
  (cond
   ; if not at least 2 parts, don't bother working here
   ((null (and (cdr tl1) (cdr tl2))) nil)
   (t
    ; determine the relative order of the parts of t1 in t2
    (setq p2 (nreverse0 (loop for d1 in tl1 collect (position d1 tl2))))
    (cond
     ; something not present
     ((|member| (- 1) p2) nil)
     (t
      ; if they are all ascending, this function will do nothing
      (setq p2p (msort p2))
      (cond
       ((equal p2 p2p) nil)
       ; if anything is repeated twice, leave
       ((nequal p2p (msort (remdup p2p))) nil)
       (t
        ; create a list of permutations that transform the tower parts
        ; of t1 into the order they are in in t2
        (setq n1 (|#| tl1))
        (setq p2 (list2vec (compress p2 0 (|#| (remdup tl1)))))
        ; p2 now has the same position numbers as p1, we need to determine
        ; a list of permutations that takes p1 into p2. 
        (setq perms (|permuteToOrder| p2 (- n1 1) 0))
        (setq towers (list tl1))
        (setq tower (list2vec tl1))
        (loop for perm in perms do
         (setq tt (elt tower (car perm)))
         (setf (elt tower (car perm)) (elt tower (cdr perm)))
         (setf (elt tower (cdr perm)) tt)
         (setq towers (cons (vec2list tower) towers)))
        (setq towers (nreverse0
         (loop for tower in towers collect (|reassembleTowerIntoType| tower))))
        (unless (equal (car towers) t2) (setq towers (cons t2 towers)))
        (nreverse towers))))))))))

\end{chunk}

\defun{permuteToOrder}{permuteToOrder}
\calls{permuteToOrder}{permuteToOrder}
\begin{chunk}{defun permuteToOrder}
(defun |permuteToOrder| (p n start)
 (let (r x perms tt stpos)
  (setq r (- n start))
 (cond
  ((<= r 0) nil)
  ((eql r 1)
   (cond
    ((> (elt p (+ r 1)) (elt p r)) nil)
    (t (list (cons r (+ r 1))))))
  ((equal (elt p start) start) (|permuteToOrder| p n (+ start 1)))
  (t
   (setq stpos nil)
   (loop for i from (+ start 1) to n while (not stpos) do
    (when (equal (elt p i) start) (setq stpos i)))
   (setq perms nil)
   (loop while (not (equal stpos start)) do
    (setq x (- stpos 1))
    (setq perms (cons (cons x stpos) perms))
    (setq tt (elt p stpos))
    (setf (elt p stpos) (elt p x))
    (setf (elt p x) tt)
    (setq stpos x))
   (append (nreverse perms) (|permuteToOrder| p n (+ start 1)))))))

\end{chunk}

\defun{decomposeTypeIntoTower}{decomposeTypeIntoTower}
\calls{decomposeTypeIntoTower}{decomposeTypeIntoTower}
\calls{decomposeTypeIntoTower}{deconstructT}
\begin{chunk}{defun decomposeTypeIntoTower}
(defun |decomposeTypeIntoTower| (tt)
 (let (rd)
  (cond
   ((atom tt) (list tt))
   ((null (cdr (|deconstructT| tt))) (list tt))
   (t
    (setq rd (reverse tt))
    (cons (reverse (cdr rd)) (|decomposeTypeIntoTower| (car rd)))))))

\end{chunk}

\defun{reassembleTowerIntoType}{reassembleTowerIntoType}
\calls{reassembleTowerIntoType}{reassembleTowerIntoType}
\begin{chunk}{defun reassembleTowerIntoType}
(defun |reassembleTowerIntoType| (tower)
 (let (let1)
  (cond
   ((atom tower) tower)
   ((null (cdr tower)) (car tower))
   (t
    (setq let1 (reverse tower))
    (|reassembleTowerIntoType|
      (append (nreverse (cddr let1))
              (list (append (second let1) (list (first let1))))))))))

\end{chunk}

\defun{coerceIntCommute}{coerceIntCommute}
\calls{coerceIntCommute}{objMode}
\calls{coerceIntCommute}{coerceCommuteTest}
\calls{coerceIntCommute}{underDomainOf}
\calls{coerceIntCommute}{getl}
\calls{coerceIntCommute}{concat}
\calls{coerceIntCommute}{objValUnwrap}
\calls{coerceIntCommute}{mkObjWrap}
\usesdollar{coerceIntCommute}{coerceFailure}
\catches{coerceIntCommute}{coerceFailure}
\begin{chunk}{defun coerceIntCommute}
(defun |coerceIntCommute| (obj target)
 (let (source s t$ d fun u c)
  (declare (special |$coerceFailure|))
  (setq source (|objMode| obj))
  (cond
   ((null (|coerceCommuteTest| source target)) nil)
   (t
    (setq s (|underDomainOf| source))
    (setq t$ (|underDomainOf| target))
    (cond
     ((equal source t$) nil)
     ((setq d (car source))
      (setq fun
       (or (getl d '|coerceCommute|)
            (intern (concat "commute" (princ-to-string d)))))
      (cond
       ((canFuncall? fun) 
        (put d '|coerceCommute| fun)
        (setq u (|objValUnwrap| obj))
        (setq c (catch '|coerceFailure| (funcall fun u source s target t$)))
        (cond
         ((equal c |$coerceFailure|) nil)
         ((eq u '|$fromCoerceable$|) c)
         (t (mkObjWrap c target)))))))))))

\end{chunk}

\defun{coerceCommuteTest}{coerceCommuteTest}
\calls{coerceCommuteTest}{isLegitimateMode}
\calls{coerceCommuteTest}{underDomainOf}
\calls{coerceCommuteTest}{deconstructT}
\begin{chunk}{defun coerceCommuteTest}
(defun |coerceCommuteTest| (t1 t2)
 (let (u1 u2)
  (cond
   ((null (|isLegitimateMode| t2 nil nil)) nil)
   ((null (setq u1 (|underDomainOf| t1))) nil)
   ((null (setq u2 (|underDomainOf| t2))) nil)
   ((null (|underDomainOf| u1)) nil)
   ((null (|underDomainOf| u2)) nil)
   (t
    (and (equal (car (|deconstructT| t1)) (car (|deconstructT| u2)))
         (equal (car (|deconstructT| t2)) (car (|deconstructT| u1))))))))

\end{chunk}

\defun{coerceIntTableOrFunction}{coerceIntTableOrFunction}
This function does the actual coercion to t2, but not to an
argument type of t2
\calls{coerceIntTableOrFunction}{isValidType}
\calls{coerceIntTableOrFunction}{isLegitimateMode}
\calls{coerceIntTableOrFunction}{objMode}
\calls{coerceIntTableOrFunction}{assq}
\calls{coerceIntTableOrFunction}{coerceByTable}
\calls{coerceIntTableOrFunction}{objVal}
\calls{coerceIntTableOrFunction}{coerceByFunction}
\usesdollar{coerceIntTableOrFunction}{CoerceTable}
\begin{chunk}{defun coerceIntTableOrFunction}
(defun |coerceIntTableOrFunction| (triple t2)
 (let (t1 p tmp1)
  (declare (special |$CoerceTable|))
  (cond
   ((null (|isValidType| t2)) nil)
   ((null (|isLegitimateMode| t2 nil nil)) nil)
   (t
    (setq t1 (|objMode| triple))
    (setq p (assq (car t1) |$CoerceTable|))
    (cond
     ((and p (setq tmp1 (assq (car t2) (cdr p))))
      (cond
       ((eq (third tmp1) '|Identity|) (mkObj (|objVal| triple) t2))
       ((eq (second tmp1) '|total|)
         (or (|coerceByTable| (third tmp1) (|objVal| triple) t1 t2 t)
             (|coerceByFunction| triple t2)))
       (t
         (or (|coerceByTable| (third tmp1) (|objVal| triple) t1 t2 nil)
             (|coerceByFunction| triple t2)))))
     (t (|coerceByFunction| triple t2)))))))

\end{chunk}

\defun{coerceByTable}{coerceByTable}
\calls{coerceByTable}{isWrapped}
\calls{coerceByTable}{unwrap}
\calls{coerceByTable}{mkObjWrap}
\calls{coerceByTable}{isTotalCoerce}
\calls{coerceByTable}{mkObj}
\calls{coerceByTable}{mkq}
\usesdollar{coerceByTable}{OutputForm}
\usesdollar{coerceByTable}{coerceFailure}
\catches{coerceByTable}{coerceFailure}
\begin{chunk}{defun coerceByTable}
(defun |coerceByTable| (fn x t1 t2 isTotalCoerce)
 (let (c)
  (declare (special |$coerceFailure| |$OutputForm|))
  (cond
   ((equal t2 |$OutputForm|) nil)
   ((|isWrapped| x)
    (setq x (|unwrap| x))
    (setq c (catch '|coerceFailure| (funcall fn x t1 t2)))
    (unless (equal c |$coerceFailure|) (mkObjWrap c t2)))
   (isTotalCoerce (mkObj (list fn x (mkq t1) (mkq t2)) t2))
   (t
    (mkObj (list '|catchCoerceFailure| (mkq fn) x (mkq t1) (mkq t2)) t2)))))

\end{chunk}

\defun{catchCoerceFailure}{catchCoerceFailure}
This function is funcalled from code constructed by {\bf coerceByTable}.
\calls{catchCoerceFailure}{unwrap}
\calls{catchCoerceFailure}{wrap}
\calls{catchCoerceFailure}{throwKeyedMsgCannotCoerceWithValue}
\usesdollar{catchCoerceFailure}{coerceFailure}
\catches{catchCoerceFailure}{coerceFailure}
\begin{chunk}{defun catchCoerceFailure}
(defun |catchCoerceFailure| (fn x t1 t2)
 (let (c)
  (declare (special |$coerceFailure|))
  (setq c (catch '|coerceFailure| (funcall fn x t1 t2)))
  (if (equal c |$coerceFailure|)
   (|throwKeyedMsgCannotCoerceWithValue| (|wrap| (|unwrap| x)) t1 t2)
   c)))

\end{chunk}

\defun{coerceIntSpecial}{coerceIntSpecial}
\calls{coerceIntSpecial}{objMode}
\calls{coerceIntSpecial}{coerceInt}
\begin{chunk}{defun coerceIntSpecial}
(defun |coerceIntSpecial| (triple t2)
 (let (x)
  (when (and (eq (first t2) '|SimpleAlgebraicExtension|)
             (equal (second t2) (|objMode| triple)))
    (unless (setq x (|coerceInt| triple (third t2)))
     (|coerceInt| x t2))))))

\end{chunk}

\defun{coerceIntByMap}{coerceIntByMap}
The idea is this: if t1 is D U1 and t2 is D U2, then look for a map:
\verb|(U1 -> U2, D U1) -> D U2|.  If it exists, then create a function
to do the coercion on the element level and call the map function.
\calls{coerceIntByMap}{objMode}
\calls{coerceIntByMap}{length}
\calls{coerceIntByMap}{deconstructT}
\calls{coerceIntByMap}{nequal}
\calls{coerceIntByMap}{valueArgsEqual?}
\calls{coerceIntByMap}{underDomainOf}
\calls{coerceIntByMap}{member}
\calls{coerceIntByMap}{isSubDomain}
\calls{coerceIntByMap}{sayFunctionSelection}
\calls{coerceIntByMap}{selectMms1}
\calls{coerceIntByMap}{sayFunctionSelectionResult}
\calls{coerceIntByMap}{compiledLookup}
\calls{coerceIntByMap}{evalDomain}
\calls{coerceIntByMap}{wrapped2Quote}
\calls{coerceIntByMap}{objVal}
\calls{coerceIntByMap}{timedEvaluate}
\calls{coerceIntByMap}{mkObjWrap}
\catches{coerceIntByMap}{coerceFailure}
\begin{chunk}{defun coerceIntByMap}
(defun |coerceIntByMap| (triple t2)
 (let (t1 top u1 u2 args mms fun code val)
  (declare (special |$coerceFailure| |$reportBottomUpFlag|))
  (setq t1 (|objMode| triple))
  (cond
   ((equal t2 t1) triple)
   (t
    (setq u2 (|deconstructT| t2)) ; compute t2 first because of Expression
    (cond
      ((eql 1 (|#| u2)) nil)      ; no under domain
      (t
       (setq u1 (|deconstructT| t1))
       (cond
        ((eql 1 (|#| u1)) nil)
        ((nequal (caar u1) (caar u2)) nil) ; constructors not equal
        ((null (|valueArgsEqual?| t1 t2)) nil)
        (t
         ; handle a couple of special cases for subdomains of Integer
         (setq top (caar u1))
         (setq u1 (|underDomainOf| t1))
         (setq u2 (|underDomainOf| t2))
         (cond
          ((and (|member| top
                  '(|List| |Vector| |Segment| |Stream| 
                    |UniversalSegment| |Array|))
                (|isSubDomain| u1 u2))
            (mkObj (|objVal| triple) t2))
          (t
           (setq args (list (list '|Mapping| u2 u1) t1))
           (when |$reportBottomUpFlag|
            (|sayFunctionSelection| '|map| args t2 nil
                                     "coercion facility (map)"))
           (setq mms (|selectMms1| '|map| t2 args args nil))
           (when |$reportBottomUpFlag|
             (|sayFunctionSelectionResult| '|map| args mms))
           (cond
            ((null mms) nil)
            (t
             (setq fun 
              (|compiledLookup| '|map| (cdaar mms) (|evalDomain| (caaar mms))))
             (cond
              ((null fun) nil)
              (t
               (cond
                ((equal (car fun) #'|Undef|) nil)
                (t
                 ;  now compile a function to do the coercion
                 (setq code
                  (list 'spadcall
                   (list 'cons 
                    (list 'function  '|coerceIntByMapInner|) 
                     (mkq (cons u1 u2)))
                    (|wrapped2Quote| (|objVal| triple))
                     (mkq fun)))
                 ; and apply the function
                 (setq val (catch '|coerceFailure| (|timedEvaluate| code)))
                 (unless (equal val |$coerceFailure|)
                  (mkObjWrap val t2))))))))))))))))))

\end{chunk}

\defun{coerceIntByMapInner}{coerceIntByMapInner}
This is a helper function for {\bf coerceIntByMap} which constructs
a {\bf spadcall} and then evaluates it.
\calls{coerceIntByMapInner}{coerceOrThrowFailure}
\begin{chunk}{defun coerceIntByMapInner}
(defun |coerceIntByMapInner| (arg g1)
 (|coerceOrThrowFailure| arg (car g1) (cdr g1)))

\end{chunk}

\defun{coerceOrThrowFailure}{coerceOrThrowFailure}
\calls{coerceOrThrowFailure}{coerceOrRetract}
\calls{coerceOrThrowFailure}{mkObjWrap}
\calls{coerceOrThrowFailure}{coercionFailure}
\calls{coerceOrThrowFailure}{objValUnwrap}
\begin{chunk}{defun coerceOrThrowFailure}
(defun |coerceOrThrowFailure| (value t1 t2)
 (let (result)
  (or (setq result (|coerceOrRetract| (mkObjWrap value t1) t2))
      (|coercionFailure|))
  (|objValUnwrap| result)))

\end{chunk}

\defun{coercionFailure}{coercionFailure}
This does a throw on coercion failure.
\throws{coercionFailure}{coerceFailure}
\begin{chunk}{defun coercionFailure}
(defun |coercionFailure| ()
  (declare (special |$coerceFailure|))
  (throw '|coerceFailure| |$coerceFailure|))

\end{chunk}

\defun{valueArgsEqual?}{valueArgsEqual?}
\verb|[u1,:u2]| gets passed as the ``environment'', which is why we have this
slightly clumsy locution  JHD 31.July,1990

This returns true if the object-valued arguments to t1 and t2 are the same
under coercion
\calls{valueArgsEqual?}{getdatabase}
\calls{valueArgsEqual?}{getConstructorSignature}
\calls{valueArgsEqual?}{replaceSharps}
\calls{valueArgsEqual?}{coerceInt}
\calls{valueArgsEqual?}{mkObjWrap}
\calls{valueArgsEqual?}{algEqual}
\calls{valueArgsEqual?}{objValUnwrap}
\begin{chunk}{defun valueArgsEqual?}
(defun |valueArgsEqual?| (t1 t2)
 (let (coSig constrSig tl1 tl2 newVal done value trip)
  (setq coSig (cdr (getdatabase (car t1) 'cosig)))
  (setq constrSig (cdr (|getConstructorSignature| (car t1))))
  (setq tl1 (|replaceSharps| constrSig t1))
  (setq tl2 (|replaceSharps| constrSig t2))
  (cond
   ((null (member nil coSig)) t)
   (t 
    (setq done nil)
    (setq value t)
    (loop for a1 in (cdr t1) for a2 in (cdr t2) for cs in coSig 
          for m1 in tl1 for m2 in tl2 while (not done) do
          (cond
           ((null cs)
             (setq trip (mkObjWrap a1 m1))
             (setq newVal (|coerceInt| trip m2))
             (cond
              ((null newVal)
                (setq done t)
                (setq value nil))
              ((null (|algEqual| a2 (|objValUnwrap| newVal) m2))
                (setq done t)
                (setq value nil))))))
     value))))

\end{chunk}

\defun{algEqual}{algEqual}
This function sees if 2 objects of the same domain are equal by using the
$=$ from the domain. The objects should not be wrapped.
\calls{algEqual}{spadcall}
\calls{algEqual}{compiledLookupCheck}
\calls{algEqual}{evalDomain}
\usesdollar{algEqual}{Boolean}
\begin{chunk}{defun algEqual}
(defun |algEqual| (object1 object2 domain)
 (declare (special |$Boolean|))
 (spadcall object1 object2 
  (|compiledLookupCheck| '= (list |$Boolean| '$ '$) (|evalDomain| domain))))

\end{chunk}

\defun{coerceIntFromUnion}{coerceIntFromUnion}
\begin{chunk}{defun coerceIntFromUnion}
(defun |coerceIntFromUnion| (object t2)
  (|coerceInt| (|coerceUnion2Branch| object) t2))

\end{chunk}

\defun{coerceInt2Union}{coerceInt2Union}
\begin{chunk}{defun coerceInt2Union}
(defun |coerceInt2Union| (object union)
 (let (unionDoms t1 val valp noCoerce)
  (declare (special |$String|))
  (setq unionDoms (|stripUnionTags| (cdr union)))
  (setq t1 (|objMode| object))
  (cond
   ((|member| t1 unionDoms) (|coerceBranch2Union| object union))
   (t
    (setq val (|objVal| object))
    (setq valp (|unwrap| val))
    (cond
     ((and (equal t1 |$String|) (|member| valp unionDoms))
       (|coerceBranch2Union| (mkObj val valp) union))
     (t
      (setq noCoerce t)
      (setq valp nil)
      (loop for d in unionDoms while noCoerce do
       (when (setq valp (|coerceInt| object d)) (setq noCoerce nil)))
      (when valp (|coerceBranch2Union| valp union))))))))

\end{chunk}

\defun{coerceBranch2Union}{coerceBranch2Union}
\calls{coerceBranch2Union}{orderUnionEntries}
\calls{coerceBranch2Union}{mkPredList}
\calls{coerceBranch2Union}{stripUnionTags}
\calls{coerceBranch2Union}{position}
\calls{coerceBranch2Union}{keyedSystemError}
\calls{coerceBranch2Union}{objMode}
\calls{coerceBranch2Union}{objVal}
\calls{coerceBranch2Union}{mkObjWrap}
\calls{coerceBranch2Union}{removeQuote}
\calls{coerceBranch2Union}{unwrap}
\calls{coerceBranch2Union}{mkObj}
\begin{chunk}{defun coerceBranch2Union}
(defun |coerceBranch2Union| (object union)
 (let (predList doms p val tag)
  (setq doms (|orderUnionEntries| (cdr union)))
  (setq predList (|mkPredList| doms))
  (setq doms (|stripUnionTags| doms))
  (setq p (|position| (|objMode| object) doms))
  (cond
   ((equal p (- 1))
     (|keyedSystemError| "The type %1p is not branch of %2p"
      (list (|objMode| object) union)))
   (t
    (setq val (|objVal| object))
    (if (eq (car (setq tag (elt predlist p))) 'eqcar)
     (mkObjWrap (cons (|removeQuote| (third tag)) (|unwrap| val)) union)
     (mkObj val union))))))

\end{chunk}

\defun{coerceIntAlgebraicConstant}{coerceIntAlgebraicConstant}
\calls{coerceIntAlgebraicConstant}{objMode}
\calls{coerceIntAlgebraicConstant}{objValUnwrap}
\calls{coerceIntAlgebraicConstant}{ofCategory}
\calls{coerceIntAlgebraicConstant}{mkObjWrap}
\calls{coerceIntAlgebraicConstant}{getConstantFromDomain}
\begin{chunk}{defun coerceIntAlgebraicConstant}
(defun |coerceIntAlgebraicConstant| (object t2)
 (let (t1 val)
  (setq t1 (|objMode| object))
  (setq val (|objValUnwrap| object))
  (cond
   ((and (|ofCategory| t1 '(|Monoid|))
         (|ofCategory| t2 '(|Monoid|))
         (equal val (|getConstantFromDomain| '(|One|) t1)))
     (mkObjWrap (|getConstantFromDomain| '(|One|) t2) t2))
   ((and (|ofCategory| t1 '(|AbelianMonoid|))
         (|ofCategory| t2 '(|AbelianMonoid|))
         (equal val (|getConstantFromDomain| '(|Zero|) t1)))
     (mkObjWrap (|getConstantFromDomain| '(|Zero|) t2) t2)))))

\end{chunk}

\defun{getConstantFromDomain}{getConstantFromDomain}
The function {\bf getConstantFromDomain} is used to look up the 
constants $0$ and $1$ from the given domainForm.

If isPartialMode returns true then the
domain modemap contains the constant \verb|$EmptyMode| which indicates
that the domain is not fully formed. In this case we return nil.

\calls{getConstantFromDomain}{isPartialMode}
\calls{getConstantFromDomain}{opOf}
\calls{getConstantFromDomain}{lassoc}
\calls{getConstantFromDomain}{getOperationAlistFromLisplib}
\calls{getConstantFromDomain}{getConstantFromDomain}
\calls{getConstantFromDomain}{throwKeyedMsg}
\calls{getConstantFromDomain}{spadcall}
\calls{getConstantFromDomain}{compiledLookupCheck}
\calls{getConstantFromDomain}{evalDomain}
\begin{chunk}{defun getConstantFromDomain}
(defun |getConstantFromDomain| (form domainForm)
 (let (key entryList)
  (unless (|isPartialMode| domainForm)
   (setq key (|opOf| form))
   (setq entryList 
    (lassoc key (|getOperationAlistFromLisplib| (car domainForm))))
   (cond
    ((null (eq (cdr entryList) nil))
     (cond
      ((eq key '|One|)  (|getConstantFromDomain| (list '|1|) domainForm))
      ((eq key '|Zero|) (|getConstantFromDomain| (list '|0|) domainForm))
      (t
        (|throwKeyedMsg| "No such constant %1 in domain %2p ."
         (list form domainForm)))))
    (t
     ; there should be exactly one item under this key of that form
     (spadcall 
      (|compiledLookupCheck| key (caar entryList)
        (|evalDomain| domainForm))))))))

\end{chunk}

\defun{compareTypeLists}{compareTypeLists}
Rreturns true if every type in tl1 is equal or is a subdomain of
the corresponding type in tl2
\begin{chunk}{defun compareTypeLists}
(defun |compareTypeLists| (tl1 tl2)
 (not 
  (loop for t1 in tl1 for t2 in tl2
   do (when (null (|isEqualOrSubDomain| t1 t2)) (return t)))))

\end{chunk}

\defun{coerceIntX}{coerceIntX}
Try to coerce a (List (None)) into a different domain
\calls{coerceIntX}{unwrap}
\calls{coerceIntX}{underDomainOf}
\calls{coerceIntX}{coerceInt}
\calls{coerceIntX}{mkObjWrap}
\begin{chunk}{defun coerceIntX}
(defun |coerceIntX| (val t1 t2)
 (let (t0)
   (when (and (equal t1 '(|List| (|None|)))
              (null (|unwrap| val))
              (setq t0 (|underDomainOf| t2)))
    (|coerceInt| (mkObjWrap val (list '|List| t0)) t2))))

\end{chunk}

\defun{coerceSubDomain}{coerceSubDomain}
\calls{coerceSubDomain}{getdatabase}
\calls{coerceSubDomain}{coerceSubDomain}
\calls{coerceSubDomain}{coerceImmediateSubDomain}
\begin{chunk}{defun coerceSubDomain}
(defun |coerceSubDomain| (val tSuper tSub)
 (let (super)
  (unless (eq val '|$fromCoerceable$|)
   (setq super (getdatabase (car tSub) 'superdomain))
   (cond
    ((equal (car super) tSuper)
      (|coerceImmediateSubDomain| val tSuper tSub (second super)))
    ((|coerceSubDomain| val tSuper (car super))
      (|coerceImmediateSubDomain| val (car super) tSub (second super)))))))

\end{chunk}

\defun{coerceImmediateSubDomain}{coerceImmediateSubDomain}
\calls{coerceImmediateSubDomain}{getSubDomainPredicate}
\begin{chunk}{defun coerceImmediateSubDomain}
(defun |coerceImmediateSubDomain| (val tSuper tSub pred)
 (when (funcall (|getSubDomainPredicate| tSuper tSub pred) val nil)
  (mkObj val tSub)))

\end{chunk}

\defun{getSubDomainPredicate}{getSubDomainPredicate}
\calls{getSubDomainPredicate}{msubst}
\calls{getSubDomainPredicate}{removeZeroOne}
\calls{getSubDomainPredicate}{interpret}
\calls{getSubDomainPredicate}{mkAtree}
\calls{getSubDomainPredicate}{transferPropsToNode}
\calls{getSubDomainPredicate}{selectLocalMms}
\calls{getSubDomainPredicate}{hput}
\usesdollar{getSubDomainPredicate}{env}
\usesdollar{getSubDomainPredicate}{superHash}
\usesdollar{getSubDomainPredicate}{Boolean}
\usesdollar{getSubDomainPredicate}{InteractiveFrame}
\begin{chunk}{defun getSubDomainPredicate}
(defun |getSubDomainPredicate| (tSuper tSub pred)
 (let (|$env| name decl arg predp defn op predfn)
  (declare (special |$env| |$superHash| |$Boolean| |$InteractiveFrame|))
  (setq |$env| |$InteractiveFrame|)
  (cond
   ((setq predfn (hget |$superHash| (cons tSuper tSub))) predfn)
   (t
    (setq name (gensym))
    (setq decl (list '|:| name (list '|Mapping| |$Boolean| tSuper)))
    (|interpret| decl nil)
    (setq arg (gensym))
    (setq predp (msubst arg '|#1| pred))
    (setq defn
     (list 'def (list name arg) '(nil nil) '(nil nil) (|removeZeroOne| predp)))
    (|interpret| defn nil)
    (setq op (|mkAtree| name))
    (|transferPropsToNode| name op)
    (setq predfn (cadar (|selectLocalMms| op name (list tSuper) |$Boolean|)))
    (hput |$superHash| (cons tSuper tSub) predfn)
    predfn))))

\end{chunk}

\defun{absolutelyCanCoerceByCheating}{absolutelyCanCoerceByCheating}
This typically involves subdomains and towers where the only
difference is a subdomain
\calls{absolutelyCanCoerceByCheating}{isEqualOrSubDomain|}
\calls{absolutelyCanCoerceByCheating}{deconstructT}
\calls{absolutelyCanCoerceByCheating}{nequal}
\calls{absolutelyCanCoerceByCheating}{absolutelyCanCoerceByCheating}
\usesdollar{absolutelyCanCoerceByCheating}{SingleInteger}
\usesdollar{absolutelyCanCoerceByCheating}{Integer}
\begin{chunk}{defun absolutelyCanCoerceByCheating}
(defun |absolutelyCanCoerceByCheating| (t1 t2)
 (let (let1 let2)
  (declare (special |$Integer| |$SingleInteger|))
  (cond
   ((|isEqualOrSubDomain| t1 t2) t)
   ((and (equal t1 |$SingleInteger|) (equal t2 |$Integer|)) t)
   ((or (atom t1) (atom t2)) nil)
   (t
    (setq let1 (|deconstructT| t1))
    (setq let2 (|deconstructT| t2))
    (cond
     ((and (equal (car let1) '(|Stream|))
           (equal (car let2) '(|InfiniteTuple|)))
       (cond
        ((nequal (|#| (cdr let1)) (|#| (cdr let2))) nil)
        (t
         (every #'identity 
          (loop for x1 in (cdr let1) for x2 in (cdr let2) collect
           (|absolutelyCanCoerceByCheating| x1 x2))))))
     ((nequal (car let1) (car let2)) nil)
     ((nequal (|#| (cdr let1)) (|#| (cdr let2))) nil)
     (t
      (every #'identity 
       (loop for x1 in (cdr let1) for x2 in (cdr let2) collect
        (|absolutelyCanCoerceByCheating| x1 x2)))))))))

\end{chunk}

\defun{coerceOrRetract}{coerceOrRetract}
\calls{coerceOrRetract}{coerceInteractive}
\calls{coerceOrRetract}{retract}
\begin{chunk}{defun coerceOrRetract}
(defun |coerceOrRetract| (z m)
 (prog (tp tt ans)
  (return
    (cond
     ((setq tp (|coerceInteractive| z m)) tp)
     (t 
      (setq tt z) 
      (setq ans nil)
      (do () (nil nil)
       (cond
        (ans (return ans))
        (t
         (setq tt (|retract| tt))
         (cond
          ((eq tt '|failed|) (return ans))
          (t (setq ans (|coerceInteractive| tt m)))))))
      ans)))))

\end{chunk}

\defun{retract2Specialization}{retract2Specialization}
Handle some specialization retraction cases, like matrices
\calls{retract2Specialization}{objVal}
\calls{retract2Specialization}{unwrap}
\calls{retract2Specialization}{objMode}
\calls{retract2Specialization}{mkObjWrap}
\calls{retract2Specialization}{coerceUnion2Branch}
\calls{retract2Specialization}{coerceInt}
\calls{retract2Specialization}{remdup}
\calls{retract2Specialization}{varsInPoly}
\calls{retract2Specialization}{mkObj}
\calls{retract2Specialization}{member}
\calls{retract2Specialization}{retract}
\calls{retract2Specialization}{objValUnwrap}
\calls{retract2Specialization}{objMode}
\calls{retract2Specialization}{resolveTypeListAny}
\calls{retract2Specialization}{isRectangularList}
\calls{retract2Specialization}{get}
\calls{retract2Specialization}{isPartialMode}
\usesdollar{retract2Specialization}{e}
\usesdollar{retract2Specialization}{QuotientField}
\usesdollar{retract2Specialization}{Symbol}
\usesdollar{retract2Specialization}{Integer}
\usesdollar{retract2Specialization}{Any}
\usesdollar{retract2Specialization}{NonNegativeInteger}
\usesdollar{retract2Specialization}{PositiveInteger}
\begin{chunk}{defun retract2Specialization}
(defun |retract2Specialization| (object)
 (prog (val type dom obj dp bad vl tl ep vlp n D num den valp m)
 (declare (special |$e| |$QuotientField| |$Symbol| |$Integer| |$Any|
                   |$NonNegativeInteger| |$PositiveInteger|))
  (return
   (seq
    (progn
     (setq val (|objVal| object))
     (setq valp (|unwrap| val))
     (setq type (|objMode| object))
     (cond
      ; type is Any
      ((equal type |$Any|)
        (setq dom (car valp))
        (setq obj (cdr valp))
        (mkObjWrap obj dom))
      ; type is ['Union,:unionDoms]
      ((eq (car type) '|Union|) 
        (|coerceUnion2Branch| object))
      ; type is Symbol
      ((equal type |$Symbol|)
        (mkObjWrap 1 (list '|OrderedVariableList| (list valp))))
      ; type is ['OrderedVariableList,var]
      ((eq (car type) '|OrderedVariableList|)
        (|coerceInt|
         (mkObjWrap (elt (second type) (- valp 1)) |$Symbol|)
         '(|Polynomial| (|Integer|))))
      ; type is ['Polynomial,d]
      ((eq (car type) '|Polynomial|)
        (cond
         ((eql (car valp) 1)
           (when (eql 1 (|#| (remdup (|varsInPoly| valp))))
             (|coerceInt| object 
              (list '|UnivariatePolynomial| (second valp)  (second type)))))
         ((eql (car valp) 0) (|coerceInt| object (second type)))
         (t nil)))
      ; type is ['Matrix,d]
      ((eq (car type) '|Matrix|)
        (setq n (|#| valp))
        (setq m (|#| (elt valp 0)))
        (cond
         ((= n m) (mkObj val (list '|SquareMatrix| n (second type))))
         (t (mkObj val (list '|RectangularMatrix| n m (second type))))))
      ; type is ['RectangularMatrix,n,m,d]
      ((eq (first type) '|RectangularMatrix|)
        (setq n (second type))
        (setq m (third type))
        (setq d (fourth type))
        (when (eql n m) (mkObj val (list '|SquareMatrix| n d))))
      ; type is [agg,d] agg is |Vector|,|Segment|, or |UniversalSegment|
      ((|member| (first type) '(|Vector| |Segment| |UniversalSegment|))
        (cond
         ((equal (second type) |$PositiveInteger|)
          (mkObj val (cons (first type) (list |$NonNegativeInteger|))))
         ((equal (second type) |$NonNegativeInteger|)
          (mkObj val (list (first type) |$Integer|)))))
      ; type is ['Array,bds,d]
      ((eq (first type) '|Array|)
       (cond
        ((equal (third type) |$PositiveInteger|)
         (mkObj val (list '|Array| (second type) |$NonNegativeInteger|)))
        ((equal (third type) |$NonNegativeInteger|)
         (mkObj val (list '|Array| (second type) |$Integer|)))))
      ; type is ['List,d]
      ((eq (car type) '|List|)
       (setq d (second type))
       (setq dp (second d))
       (cond
        ; type isnt ['List,dp]
        ((null (eq (car d) '|List|))
          (cond
           ((equal d |$PositiveInteger|)
             (mkObj val (list '|List| |$NonNegativeInteger|)))
           ((equal d |$NonNegativeInteger|)
             (mkObj val (list '|List| |$Integer|)))
           ((null valp) nil)
           (t
            (setq vl nil)
            (setq tl nil)
            (setq bad nil)
            (loop for e in valp while (not bad) do 
             (cond
              ((equal (setq ep (|retract| (mkObjWrap e d))) '|failed|)
                (setq bad t))
              (t
               (setq vl (cons (|objValUnwrap| ep) vl))
               (setq tl (cons (|objMode| ep) tl))))) 
            (cond
             (bad nil)
             ((equal (setq m (|resolveTypeListAny| tl)) d) nil)
             ((equal d m) nil)
             (t 
              (setq vlp nil)
              (setq ep t)
              (loop for e in vl for tt in tl while ep do
               (cond
                ((equal tt m) (setq vlp (cons e vlp)))
                (t
                 (setq ep (|coerceInt| (mkObjWrap e tt) m))
                 (when ep (setq vlp (cons (|objValUnwrap| ep) vlp))))))
              (mkObjWrap vlp (list '|List| m)))))))
        ((equal dp |$PositiveInteger|)
          (mkObj val (list '|List| (list '|List| |$NonNegativeInteger|))))
        ((equal dp |$NonNegativeInteger|)
          (mkObj val (list '|List| (list '|List| |$Integer|))))
        ((or (eq (car dp) '|Variable|)
             (eq (car dp) '|OrderedVariableList|))
          (|coerceInt| object (list '|List| (list '|List| |$Symbol|))))
        (t
         (setq n (|#| valp))
         (setq m (|#| (elt valp 0)))
         (cond
          ((null (|isRectangularList| valp n m)) nil)
          (t (|coerceInt| object (list '|Matrix| dp)))))))
    ; type is ['Expression,d]
    ((eq (car type) '|Expression|)
      (setq num (car valp))
      (setq den (cdr valp))
      (cond
       ((null (equal (car num) 0)) nil)
       ((null (equal (car den) 0)) nil)
       (t 
        (mkObjWrap (cons (cdr num) (cdr den))
         (list |$QuotientField| (second type))))))
    ; type is ['SimpleAlgebraicExtension,k,rep,.]
    ; try to retract as an element of rep and see if we can get an element of k
    ((eq (car type) '|SimpleAlgebraicExtension|)
      (setq valp (|retract| (mkObj val (third type))))
      (do ()
          ((null (and (nequal valp '|failed|)
                      (nequal (|objMode| valp) (second type))))
             nil)
       (setq valp (|retract| valp)))
      (unless (equal valp '|failed|) valp))
    ; type is ['UnivariatePuiseuxSeries,coef,var,cen]
    ((eq (car type) '|UnivariatePuiseuxSeries|)
      (|coerceInt| object
        (list '|UnivariateLaurentSeries|
         (second type) (third type) (fourth type))))
    ; type is ['UnivariateLaurentSeries,coef,var,cen]
    ((eq (car type) '|UnivariateLaurentSeries|)
      (|coerceInt| object
       (list '|UnivariateTaylorSeries|
        (second type) (third type) (fourth type))))
      ; type is ['FunctionCalled,name]
    ((eq (car type) '|FunctionCalled|)
      (cond
       ((null (setq m (|get| (second type) '|mode| |$e|))) nil)
       ((|isPartialMode| m) nil)
       (t (mkObj val m))))
    (t nil)))))))

\end{chunk}

\defun{coerceUnion2Branch}{coerceUnion2Branch}
\calls{coerceUnion2Branch}{orderUnionEntries}
\calls{coerceUnion2Branch}{objMode}
\calls{coerceUnion2Branch}{mkPredList}
\calls{coerceUnion2Branch}{stripUnionTags}
\calls{coerceUnion2Branch}{objValUnwrap}
\calls{coerceUnion2Branch}{evalSharpOne}
\calls{coerceUnion2Branch}{mkObj}
\calls{coerceUnion2Branch}{objVal}
\begin{chunk}{defun coerceUnion2Branch}
(defun |coerceUnion2Branch| (object)
 (let (predList doms valp predicate targetType)
  (setq doms (|orderUnionEntries| (cdr (|objMode| object))))
  (setq predList (|mkPredList| doms))
  (setq doms (|stripUnionTags| doms))
  (setq valp (|objValUnwrap| object))
  (loop for typ in doms for pred in predList while (not targetType) do
   (when (|evalSharpOne| pred valp)
    (setq predicate pred)
    (setq targetType typ)))
  (cond
   ((null targetType)
     (|keyedSystemError| "Cannot determine branch of Union." nil))
   ((eq (car predicate) 'eqcar) (mkObjWrap (cdr valp) targetType))
   (t (mkObj (|objVal| object) targetType)))))

\end{chunk}

\defun{stripUnionTags}{stripUnionTags}
\begin{chunk}{defun stripUnionTags}
(defun |stripUnionTags| (doms)
 (loop for dom in doms 
  collect (if (eq (first dom) '|:|) (third dom) dom)))

\end{chunk}

\defun{evalSharpOne}{evalSharpOne}
\begin{chunk}{defun evalSharpOne 0}
(defun |evalSharpOne| (x |#1|)
 (declare (special |#1|))
 (eval `(let() (declare (special |#1|)) ,x)))

\end{chunk}

\defun{retractUnderDomain}{retractUnderDomain}
\calls{retractUnderDomain}{underDomainOf}
\calls{retractUnderDomain}{deconstructT}
\calls{retractUnderDomain}{nequal}
\calls{retractUnderDomain}{constructT}
\calls{retractUnderDomain}{coerceInt}
\begin{chunk}{defun retractUnderDomain}
(defun |retractUnderDomain| (object type underDomain)
 (let (ud let1 typep objectp)
  (cond
   ((null (setq ud (|underDomainOf| underDomain))) '|failed|)
   (t
    (setq let1 (|deconstructT| type))
    (cond
     ((nequal 1 (|#| (cdr let1))) '|failed|)
     ((nequal 1 (|#| (car let1))) '|failed|)
     (t
      (setq typep (|constructT| (car let1) (list ud)))
      (cond
       ((setq objectp (|coerceInt| object typep)) objectp)
       (t '|failed|))))))))

\end{chunk}

\defun{coerceRetract}{coerceRetract}
\calls{coerceRetract}{objValUnwrap}
\calls{coerceRetract}{objMode}
\calls{coerceRetract}{isEqualOrSubDomain}
\calls{coerceRetract}{mkObjWrap}
\calls{coerceRetract}{retractByFunction}
\calls{coerceRetract}{getl}
\calls{coerceRetract}{canFuncall?}
\usesdollar{coerceRetract}{coerceFailure}
\usesdollar{coerceRetract}{SingleInteger}
\usesdollar{coerceRetract}{OutputForm}
\usesdollar{coerceRetract}{Symbol}
\usesdollar{coerceRetract}{Integer}
\catches{coerceRetract}{coerceFailure}
\begin{chunk}{defun coerceRetract}
(defun |coerceRetract| (object t2)
 (let (val t1 fun c)
  (declare (special |$coerceFailure| |$OutputForm| |$Symbol| |$Integer|
           |$SingleInteger|))
  (cond
   ((eq (setq val (|objValUnwrap| object)) '|$fromCoerceable$|) nil)
   (t
    (setq t1 (|objMode| object))
    (cond
     ((equal t2 |$OutputForm|) nil)
     ((and (|isEqualOrSubDomain| t1 |$Integer|)
           (equal t2 |$SingleInteger|)
           (typep val 'fixnum))
        (mkObjWrap val t2))
     ((equal t1 |$Integer|) nil)
     ((equal t1 |$Symbol|) nil)
     ((equal t1 |$OutputForm|) nil)
     ((setq c (|retractByFunction| object t2)) c)
     ((consp t1) 
       (setq fun
        (or (getl (car t1) '|retract|)
            (intern (concat "retract" (princ-to-string (car t1))))))
       (when (canFuncall? fun) 
        (put (car t1) '|retract| fun)
        (setq c (catch '|coerceFailure| (funcall fun object t2)))
        (unless (equal c |$coerceFailure|) c))))))))

\end{chunk}

\defun{retractByFunction}{retractByFunction}
\calls{retractByFunction}{objValUnwrap}
\calls{retractByFunction}{sayFunctionSelection}
\calls{retractByFunction}{findFunctionInDomain}
\calls{retractByFunction}{orderMms}
\calls{retractByFunction}{sayFunctionSelectionResult}
\calls{retractByFunction}{evalDomain}
\calls{retractByFunction}{compiledLookup}
\calls{retractByFunction}{coerceUnion2Branch}
\calls{retractByFunction}{mkObjWrap}
\calls{retractByFunction}{spadcall}
\calls{retractByFunction}{objMode}
\usesdollar{retractByFunction}{reportBottomUpFlag}
\usesdollar{retractByFunction}{dollar}
\begin{chunk}{defun retractByFunction}
(defun |retractByFunction| (object u)
 (let (|$reportBottomUpFlag| $ tt val target funName mms dcVector fun objectp)
 (declare (special |$reportBottomUpFlag| $))
  (setq tt (|objMode| object))
  (setq val (|objValUnwrap| object))
  (setq target (list '|Union| u "failed"))
  (setq funName '|retractIfCan|)
  (when |$reportBottomUpFlag|
    (|sayFunctionSelection| funName (list tt) target
      nil "coercion facility (retraction)"))
  (when 
   (setq mms
    (append 
     (|findFunctionInDomain| funName tt target (list tt) (list tt) nil t)
     (|findFunctionInDomain| funName u target (list tt) (list tt) nil t)))
    (setq mms (|orderMms| funName mms (list tt) (list tt) target)))
  (when |$reportBottomUpFlag|
    (|sayFunctionSelectionResult| funName (list tt) mms))
  (when mms
   (setq dcVector (|evalDomain| (caaar mms)))
   (setq fun (|compiledLookup| funName (list target tt) dcVector))
   (cond
    ((null fun) nil)
    ((equal (car fun) #'|Undef|) nil)
    (t
     (setq $ dcVector)
     (setq objectp
      (|coerceUnion2Branch| (mkObjWrap (spadcall val fun) target)))
     (when (equal u (|objMode| objectp)) objectp))))))

\end{chunk}

\chapter{System Command Handling}
The system commands are the top-level commands available in Axiom
that can all be invoked by prefixing the symbol with a closed-paren. 
Thus, to see they copyright you type:
\begin{verbatim}
   )copyright
\end{verbatim}
New commands need to be added to this table. The command invoked will
be the first entry of the pair and the ``user level'' of the command
will be the second entry. 

See:\\
\begin{itemize}
\item The \fnref{abbreviations} command
\item The \fnref{boot} command
\item The \fnref{browse} command
\item The \fnref{cd} command
\item The \fnref{clear} command
\item The \fnref{close} command
\item The \fnref{compile} command
\item The \fnref{copyright} command
\item The \fnref{credits} command
\item The \fnref{display} command
\item The \fnref{edit} command
\item The \fnref{fin} command
\item The \fnref{frame} command
\item The \fnref{help} command
\item The \fnref{history} command
\item The \fnref{lisp} command
\item The \fnref{library} command
\item The \fnref{license} command
\item The \fnref{load} command
\item The \fnref{ltrace} command
\item The \fnref{pquit} command
\item The \fnref{quit} command
\item The \fnref{read} command
\item The \fnref{regress} command
\item The \fnref{savesystem} command
\item The \fnref{set} command
\item The \fnref{show} command
\item The \fnref{spool} command
\item The \fnref{summary} command
\item The \fnref{synonym} command
\item The \fnref{system} command
\item The \fnref{tangle} command
\item The \fnref{trace} command
\item The \fnref{trademark} command
\item The \fnref{undo} command
\item The \fnref{what} command
\item The \fnref{with} command
\item The \fnref{workfiles} command
\end{itemize}

\section{Variables Used}
\defdollar{systemCommands}
\begin{chunk}{initvars}
(defvar |$systemCommands| nil)

\end{chunk}

\begin{chunk}{postvars}
(eval-when (eval load)
 (setq |$systemCommands|
 '(
   (|abbreviations|                  . |compiler|   )
   (|boot|                           . |development|)
   (|browse|                         . |development|)
   (|cd|                             . |interpreter|)
   (|clear|                          . |interpreter|)
   (|close|                          . |interpreter|)
   (|compiler|                       . |compiler|   )
   (|copyright|                      . |interpreter|)
   (|credits|                        . |interpreter|)
   (|describe|                       . |interpreter|)
   (|display|                        . |interpreter|)
   (|edit|                           . |interpreter|)
   (|fin|                            . |development|)
   (|frame|                          . |interpreter|)
   (|help|                           . |interpreter|)
   (|history|                        . |interpreter|)
   (|lisp|                           . |development|)
   (|library|                        . |interpreter|)
   (|license|                        . |interpreter|)
   (|load|                           . |interpreter|)
   (|ltrace|                         . |interpreter|)
   (|pquit|                          . |interpreter|)
   (|quit|                           . |interpreter|)
   (|read|                           . |interpreter|)
   (|regress|                        . |interpreter|)
   (|savesystem|                     . |interpreter|)
   (|set|                            . |interpreter|)
   (|show|                           . |interpreter|)
   (|spool|                          . |interpreter|)
   (|summary|                        . |interpreter|)
   (|synonym|                        . |interpreter|)
   (|system|                         . |interpreter|)
   (|tangle|                         . |interpreter|)
   (|trace|                          . |interpreter|)
   (|trademark|                      . |interpreter|)
   (|undo|                           . |interpreter|)
   (|what|                           . |interpreter|)
   (|with|                           . |interpreter|)
   (|workfiles|                      . |development|)
 )))

\end{chunk}

\defdollar{syscommands}
This table is used to look up a symbol to see if it might be a command.
\begin{chunk}{initvars}
(defvar $syscommands nil)

\end{chunk}

\begin{chunk}{postvars}
(eval-when (eval load)
 (setq $syscommands (mapcar #'car |$systemCommands|)))

\end{chunk}

\defdollar{noParseCommands}
This is a list of the commands which have their arguments passed verbatim.
Certain functions, such as the lisp function need to be able to handle
all kinds of input that will not be acceptable to the interpreter. 
\begin{chunk}{initvars}
(defvar |$noParseCommands| nil)

\end{chunk}

\begin{chunk}{postvars}
(eval-when (eval load)
 (setq |$noParseCommands|
 '(|boot| |copyright| |credits| |fin| |license| |lisp| |pquit| |quit| 
   |synonym| |system| |trademark| )))

\end{chunk}

\section{Functions}
\defun{handleNoParseCommands}{handleNoParseCommands}
The system commands given by the global variable
\verb|$noParseCommands| require essentially no preprocessing/parsing
of their arguments. Here we dispatch the functions which implement
these commands.

There are four standard commands which receive arguments
\begin{itemize}
\item boot
\item lisp
\item synonym 
\item system
\end{itemize}

There are six standard commands which do not receive arguments -- 
\begin{itemize}
\item quit
\item fin
\item pquit
\item credits
\item copyright
\item trademark
\end{itemize}

As these commands do not necessarily
exhaust those mentioned in \verb|$noParseCommands|, we provide a
generic dispatch based on two conventions: commands which do not
require an argument name themselves, those which do have their names
prefixed by ``np''. This makes it possible to dynamically define
new system commands provided you handle the argument parsing.

\defun{doSystemCommand}{Handle a top level command}
\calls{doSystemCommand}{concat}
\calls{doSystemCommand}{expand-tabs}
\calls{doSystemCommand}{processSynonyms}
\calls{doSystemCommand}{substring}
\calls{doSystemCommand}{getFirstWord}
\calls{doSystemCommand}{unAbbreviateKeyword}
\calls{doSystemCommand}{member}
\calls{doSystemCommand}{handleNoParseCommands}
\calls{doSystemCommand}{splitIntoOptionBlocks}
\calls{doSystemCommand}{handleTokensizeSystemCommands}
\calls{doSystemCommand}{handleParsedSystemCommands}
\usesdollar{doSystemCommand}{tokenCommands}
\usesdollar{doSystemCommand}{noParseCommands}
\uses{doSystemCommand}{line}
\begin{chunk}{defun doSystemCommand}
(defun |doSystemCommand| (string)
 (let (line tok unab optionList)
 (declare (special line |$tokenCommands| |$noParseCommands|))
  (setq string (concat ")" (expand-tabs string)))
  (setq line string)
  (|processSynonyms|)
  (setq string line)
  (setq string (substring string 1 nil))
  (cond
   ((string= string "") nil)
   (t
    (setq tok (|getFirstWord| string))
    (cond
     (tok 
      (setq unab (|unAbbreviateKeyword| tok))
      (cond
       ((|member| unab |$noParseCommands|)
        (|handleNoParseCommands| unab string))
       (t
        (setq optionList (|splitIntoOptionBlocks| string))
        (cond
         ((|member| unab |$tokenCommands|)
          (|handleTokensizeSystemCommands| unab optionList))
         (t 
          (|handleParsedSystemCommands| unab optionList)
          nil)))))
     (t nil))))))

\end{chunk}

\defun{splitIntoOptionBlocks}{Split block into option block}
\calls{splitIntoOptionBlocks}{stripSpaces}
\begin{chunk}{defun splitIntoOptionBlocks}
(defun |splitIntoOptionBlocks| (str)
 (let (inString block (blockStart 0) (parenCount 0) blockList)
  (dotimes (i (1- (|#| str)))
   (cond
    ((char= (elt str i) #\" ) (setq inString (null inString))) 
    (t
     (when (and (char= (elt str i) #\( ) (null inString))
       (incf parenCount))
     (when (and (char= (elt str i) #\) ) (null inString))
       (decf parenCount))
     (when
      (and (char= (elt str i) #\) )
            (null inString)
            (= parenCount -1))
        (setq block (|stripSpaces| (subseq str blockStart i)))
        (setq blockList (cons block blockList))
        (setq blockStart (1+ i))
        (setq parenCount 0)))))
  (setq blockList (cons (|stripSpaces| (subseq str blockStart)) blockList))
  (nreverse blockList)))

\end{chunk}

\defun{handleTokensizeSystemCommands}{Tokenize a system command}
\calls{handleTokensizeSystemCommands}{dumbTokenize}
\calls{handleTokensizeSystemCommands}{tokTran}
\calls{handleTokensizeSystemCommands}{systemCommand}
\begin{chunk}{defun handleTokensizeSystemCommands}
(defun |handleTokensizeSystemCommands| (unabr optionList)
 (declare (ignore unabr))
 (let (parcmd)
  (setq optionList (mapcar #'(lambda (x) (|dumbTokenize| x)) optionList))
  (setq parcmd 
    (mapcar #'(lambda (opt) (mapcar #'(lambda (tok) (|tokTran| tok)) opt))
     optionLIst))
  (when parcmd (|systemCommand| parcmd))))

\end{chunk}

\defun{systemCommand}{Handle system commands}
You can type ``)?'' and see trivial help information.
You can type ``)? compile'' and see compiler related information

\calls{systemCommand}{selectOptionLC}
\calls{systemCommand}{helpSpad2Cmd}
\calls{systemCommand}{selectOption}
\calls{systemCommand}{commandsForUserLevel}
\usesdollar{systemCommand}{options}
\usesdollar{systemCommand}{e}
\usesdollar{systemCommand}{systemCommands}
\usesdollar{systemCommand}{syscommands}
\usesdollar{systemCommand}{CategoryFrame}
\begin{chunk}{defun systemCommand}
(defun |systemCommand| (cmd)
 (let (|$options| |$e| op argl options fun)
 (declare (special |$options| |$e| |$systemCommands| $syscommands
                   |$CategoryFrame|))
  (setq op (caar cmd))
  (setq argl (cdar cmd))
  (setq options (cdr cmd))
  (setq |$options| options)
  (setq |$e| |$CategoryFrame|)
  (setq fun (|selectOptionLC| op $syscommands '|commandError|))
  (if (and argl (eq (elt argl 0) '?) (not (eq fun '|synonym|)))
   (|helpSpad2Cmd| (cons fun nil))
   (progn
    (setq fun
     (|selectOption| fun (|commandsForUserLevel| |$systemCommands|)
                        '|commandUserLevelError|))
    (funcall fun argl)))))

\end{chunk}

\defun{commandsForUserLevel}{Select commands matching this user level}
The \verb|$UserLevel| contains one of three values:
{\tt compiler}, {\tt development}, or {\tt interpreter}. This variable
is used to select a subset of commands from the list stored in 
\verb|$systemCommands|, representing all of the commands that are
valid for this level.
\calls{commandsForUserLevel}{satisfiesUserLevel}
\begin{chunk}{defun commandsForUserLevel}
(defun |commandsForUserLevel| (arg)
 (let (c)
  (dolist (pair arg)
   (when (|satisfiesUserLevel| (cdr pair))
    (setq c (cons (car pair) c))))
  (nreverse c)))

\end{chunk}

\defun{commandError}{No command begins with this string}
\calls{commandError}{commandErrorMessage}
\begin{chunk}{defun commandError}
(defun |commandError| (x u)
 (|commandErrorMessage| '|command| x u)) 

\end{chunk}

\defun{optionError}{No option begins with this string}
\calls{optionError}{commandErrorMessage}
\begin{chunk}{defun optionError}
(defun |optionError| (x u)
 (|commandErrorMessage| '|option| x u)) 

\end{chunk}

\defdollar{oldline}
\begin{chunk}{initvars}
(defvar $oldline nil "used to output command lines")

\end{chunk}

\defun{commandErrorMessage}{No command/option begins with this string}
\calls{commandErrorMessage}{commandAmbiguityError}
\calls{commandErrorMessage}{sayKeyedMsg}
\calls{commandErrorMessage}{terminateSystemCommand}
\usesdollar{commandErrorMessage}{oldline}
\uses{commandErrorMessage}{line}
\begin{chunk}{defun commandErrorMessage}
(defun |commandErrorMessage| (kind x u)
 (declare (special $oldline line))
  (setq $oldline line)
  (if u
   (|commandAmbiguityError| kind x u)
   (progn
    (|sayKeyedMsg| "No %1 begins with %2 ." (list kind x))
    (|terminateSystemCommand|))))

\end{chunk}

\defun{optionUserLevelError}{Option not available at this user level}
\calls{optionUserLevelError}{userLevelErrorMessage}
\begin{chunk}{defun optionUserLevelError}
(defun |optionUserLevelError| (x u)
 (|userLevelErrorMessage| '|option| x u)) 

\end{chunk}

\defun{commandUserLevelError}{Command not available at this user level}
\calls{commandUserLevelError}{userLevelErrorMessage}
\begin{chunk}{defun commandUserLevelError}
(defun |commandUserLevelError| (x u)
 (|userLevelErrorMessage| '|command| x u)) 

\end{chunk}

\defun{userLevelErrorMessage}{Command not available error message}
\calls{userLevelErrorMessage}{commandAmbiguityError}
\calls{userLevelErrorMessage}{sayKeyedMsg}
\calls{userLevelErrorMessage}{terminateSystemCommand}
\usesdollar{userLevelErrorMessage}{UserLevel}
\begin{chunk}{defun userLevelErrorMessage}
(defun |userLevelErrorMessage| (kind x u)
 (declare (special |$UserLevel|))
 (if u
  (|commandAmbiguityError| kind x u)
  (progn
   (|sayKeyedMsg| 
    "Your %1 is ambiguous. The following are abbreviated by %2 :"
     (list |$UserLevel| kind))
   (|terminateSystemCommand|))))

\end{chunk}

\defun{satisfiesUserLevel}{satisfiesUserLevel}
\usesdollar{satisfiesUserLevel}{UserLevel}
\begin{chunk}{defun satisfiesUserLevel 0}
(defun |satisfiesUserLevel| (x)
 (declare (special |$UserLevel|))
 (cond
  ((eq x '|interpreter|) t)
  ((eq |$UserLevel| '|interpreter|) nil)
  ((eq x '|compiler|) t)
  ((eq |$UserLevel| '|compiler|) nil)
  (t t)))

\end{chunk}

\defun{hasOption}{hasOption}
\calls{hasOption}{stringPrefix?}
\calls{hasOption}{pname}
\begin{chunk}{defun hasOption}
(defun |hasOption| (al opt)
 (let ((optPname (pname opt)) found)
  (loop for pair in al do
    (when (|stringPrefix?| (pname (car pair)) optPname) (setq found pair))
    until found)
  found))

\end{chunk}

\defun{terminateSystemCommand}{terminateSystemCommand}
\calls{terminateSystemCommand}{tersyscommand}
\begin{chunk}{defun terminateSystemCommand}
(defun |terminateSystemCommand| nil (tersyscommand)) 

\end{chunk}

\defun{tersyscommand}{Terminate a system command}
\calls{tersyscommand}{spadThrow}
\begin{chunk}{defun tersyscommand}
(defun tersyscommand ()
 (let (chr tok)
  (fresh-line)
  (setq chr 'endoflinechr)
  (setq tok 'end_unit)
  (|spadThrow|)))

\end{chunk}

\defun{commandAmbiguityError}{commandAmbiguityError}
\calls{commandAmbiguityError}{sayKeyedMsg}
\calls{commandAmbiguityError}{sayMSG}
\calls{commandAmbiguityError}{bright}
\calls{commandAmbiguityError}{terminateSystemCommand}
\begin{chunk}{defun commandAmbiguityError}
(defun |commandAmbiguityError| (kind x u)
 (|sayKeyedMsg| 
  "Your %1 is ambiguous. The following are abbreviated by %2 :"
   (list kind x))
 (dolist (a u) (|sayMSG| (cons "     " (|bright| a))))
 (|terminateSystemCommand|))

\end{chunk}

\defun{getParserMacroNames}{getParserMacroNames}
The \verb|$pfMacros| is a list of all of the user-defined macros.

\usesdollar{getParserMacroNames}{pfMacros}
\begin{chunk}{defun getParserMacroNames 0}
(defun |getParserMacroNames| ()
 (declare (special |$pfMacros|))
 (remove-duplicates (mapcar #'car |$pfMacros|)))

\end{chunk}

\defun{clearParserMacro}{clearParserMacro}
Note that if a macro is defined twice this will clear the last instance.
Thus:
\begin{verbatim}
  a ==> 3
  a ==> 4
  )d macros
  a ==> 4
  )clear prop a
  )d macros
  a ==> 3
  )clear prop a
  )d macros
  nil
\end{verbatim}
\calls{clearParserMacro}{ifcdr}
\calls{clearParserMacro}{assoc}
\calls{clearParserMacro}{remalist}
\usesdollar{clearParserMacro}{pfMacros}
\begin{chunk}{defun clearParserMacro}
(defun |clearParserMacro| (macro)
 (declare (special |$pfMacros|))
 (when (ifcdr (|assoc| macro |$pfMacros|))
  (setq |$pfMacros| (remalist |$pfMacros| macro))))

\end{chunk}

\defun{displayMacro}{displayMacro}
\calls{displayMacro}{isInterpMacro}
\calls{displayMacro}{sayBrightly}
\calls{displayMacro}{bright}
\calls{displayMacro}{concat}
\calls{displayMacro}{object2String}
\calls{displayMacro}{mathprint}
\usesdollar{displayMacro}{op}
\begin{chunk}{defun displayMacro}
(defun |displayMacro| (name)
 (let (|$op| m body args)
 (declare (special |$op|))
  (setq m (|isInterpMacro| name))
  (cond
   ((null m)
    (|sayBrightly|
     (cons "  " (append (|bright| name) 
                        (cons "is not an interpreter macro." nil)))))
   (t
    (setq |$op| (concat "macro " (|object2String| name)))
    (setq args (car m))
    (setq body (cdr m))
    (setq args
     (cond
      ((null args) nil)
      ((null (cdr args)) (car args))
      (t (cons '|Tuple| args))))
    (|mathprint| (cons 'map (cons (cons args body) nil)))))))

\end{chunk}

\defun{displayWorkspaceNames}{displayWorkspaceNames}
\calls{displayWorkspaceNames}{getInterpMacroNames}
\calls{displayWorkspaceNames}{getParserMacroNames}
\calls{displayWorkspaceNames}{sayMessage}
\calls{displayWorkspaceNames}{msort}
\calls{displayWorkspaceNames}{getWorkspaceNames}
\calls{displayWorkspaceNames}{sayAsManyPerLineAsPossible}
\calls{displayWorkspaceNames}{sayBrightly}
\calls{displayWorkspaceNames}{setdifference}
\begin{chunk}{defun displayWorkspaceNames}
(defun |displayWorkspaceNames| ()
 (let (pmacs names imacs)
  (setq imacs (|getInterpMacroNames|))
  (setq pmacs (|getParserMacroNames|))
  (|sayMessage| "Names of User-Defined Objects in the Workspace:")
  (setq names (msort (append (|getWorkspaceNames|) pmacs)))
  (if names
   (|sayAsManyPerLineAsPossible| (mapcar #'|object2String| names))
   (|sayBrightly| "   * None *"))
  (setq imacs (setdifference imacs pmacs))
  (when imacs
   (|sayMessage| "Names of System-Defined Objects in the Workspace:")
   (|sayAsManyPerLineAsPossible| (mapcar #'|object2String| imacs)))))

\end{chunk}

\defun{getWorkspaceNames}{getWorkspaceNames}
\begin{verbatim}
;getWorkspaceNames() ==
;  NMSORT [n for [n,:.] in CAAR $InteractiveFrame |
;    (n ^= "--macros--" and n^= "--flags--")]
\end{verbatim}
\calls{getWorkspaceNames}{nmsort}
\usesdollar{getWorkspaceNames}{InteractiveFrame}
\begin{chunk}{defun getWorkspaceNames}
(defun |getWorkspaceNames| ()
 (declare (special |$InteractiveFrame|))
 (nmsort (loop for g2 in (caar |$InteractiveFrame|) collect (car g2))))

\end{chunk}

\defun{fixObjectForPrinting}{fixObjectForPrinting}
The \verb|$msgdbPrims| variable is set to:
\begin{verbatim}
(|%b| |%d| |%l| |%i| |%u| %U |%n| |%x| |%ce| |%rj| 
 "%U" "%b" "%d" "%l" "%i" "%u" "%U" "%n" "%x" "%ce" "%rj")
\end{verbatim}
\calls{fixObjectForPrinting}{object2Identifier}
\calls{fixObjectForPrinting}{member}
\calls{fixObjectForPrinting}{concat}
\calls{fixObjectForPrinting}{pname}
\usesdollar{fixObjectForPrinting}{msgdbPrims}
\begin{chunk}{defun fixObjectForPrinting}
(defun |fixObjectForPrinting| (v)
 (let (vp)
 (declare (special |$msgdbPrims|))
  (setq vp (|object2Identifier| v))
  (cond
   ((eq vp '%) "\\%")
   ((|member| vp |$msgdbPrims|) (concat "\\" (pname vp)))
   (t v))))

\end{chunk}

\defun{displayProperties,sayFunctionDeps}{displayProperties,sayFunctionDeps}
\begin{verbatim}
;displayProperties(option,l) ==
;  $dependentAlist : local := nil
;  $dependeeAlist  : local := nil
;  [opt,:vl]:= (l or ['properties])
;  imacs := getInterpMacroNames()
;  pmacs := getParserMacroNames()
;  macros := REMDUP append(imacs, pmacs)
;  if vl is ['all] or null vl then
;    vl := MSORT append(getWorkspaceNames(),macros)
;  if $frameMessages then sayKeyedMsg("S2IZ0065",[$interpreterFrameName])
;  null vl =>
;    null $frameMessages => sayKeyedMsg("S2IZ0066",NIL)
;    sayKeyedMsg("S2IZ0067",[$interpreterFrameName])
;  interpFunctionDepAlists()
;  for v in vl repeat
;    isInternalMapName(v) => 'iterate
;    pl := getIProplist(v)
;    option = 'flags =>     getAndSay(v,"flags")
;    option = 'value =>     displayValue(v,getI(v,'value),nil)
;    option = 'condition => displayCondition(v,getI(v,"condition"),nil)
;    option = 'mode =>      displayMode(v,getI(v,'mode),nil)
;    option = 'type =>      displayType(v,getI(v,'value),nil)
;    option = 'properties =>
;      v = "--flags--" => nil
;      pl is [ ['cacheInfo,:.],:.] => nil
;      v1 := fixObjectForPrinting(v)
;      sayMSG ['"Properties of",:bright prefix2String v1,'":"]
;      null pl =>
;        v in pmacs =>
;            sayMSG '"   This is a user-defined macro."
;            displayParserMacro v
;        isInterpMacro v =>
;            sayMSG '"   This is a system-defined macro."
;            displayMacro v
;        sayMSG '"   none"
;      propsSeen:= nil
;      for [prop,:val] in pl | ^MEMQ(prop,propsSeen) and val repeat
;        prop in '(alias generatedCode IS_-GENSYM mapBody localVars) =>
;          nil
;        prop = 'condition =>
;          displayCondition(prop,val,true)
;        prop = 'recursive =>
;          sayMSG '"   This is recursive."
;        prop = 'isInterpreterFunction =>
;          sayMSG '"   This is an interpreter function."
;          sayFunctionDeps v where
;            sayFunctionDeps x ==
;              if dependents := GETALIST($dependentAlist,x) then
;                null rest dependents =>
;                  sayMSG ['"   The following function or rule ",
;                    '"depends on this:",:bright first dependents]
;                sayMSG
;                  '"   The following functions or rules depend on this:"
;                msg := ["%b",'"     "]
;                for y in dependents repeat msg := ['" ",y,:msg]
;                sayMSG [:nreverse msg,"%d"]
;              if dependees := GETALIST($dependeeAlist,x) then
;                null rest dependees =>
;                  sayMSG ['"   This depends on the following function ",
;                    '"or rule:",:bright first dependees]
;                sayMSG
;                  '"   This depends on the following functions or rules:"
;                msg := ["%b",'"     "]
;                for y in dependees repeat msg := ['" ",y,:msg]
;                sayMSG [:nreverse msg,"%d"]
;        prop = 'isInterpreterRule =>
;          sayMSG '"   This is an interpreter rule."
;          sayFunctionDeps v
;        prop = 'localModemap =>
;          displayModemap(v,val,true)
;        prop = 'mode =>
;          displayMode(prop,val,true)
;        prop = 'value =>
;          val => displayValue(v,val,true)
;        sayMSG ['"   ",prop,'":  ",val]
;        propsSeen:= [prop,:propsSeen]
;    sayKeyedMsg("S2IZ0068",[option])
;  terminateSystemCommand()
\end{verbatim}
\calls{displayProperties,sayFunctionDeps}{seq}
\calls{displayProperties,sayFunctionDeps}{getalist}
\calls{displayProperties,sayFunctionDeps}{exit}
\calls{displayProperties,sayFunctionDeps}{sayMSG}
\calls{displayProperties,sayFunctionDeps}{bright}
\usesdollar{displayProperties,sayFunctionDeps}{dependeeAlist}
\usesdollar{displayProperties,sayFunctionDeps}{dependentAlist}
\begin{chunk}{defun displayProperties,sayFunctionDeps}
(defun |displayProperties,sayFunctionDeps| (x)
 (prog (dependents dependees msg)
 (declare (special |$dependeeAlist| |$dependentAlist|))
 (return
  (seq
   (if (setq dependents (getalist |$dependentAlist| x))
    (seq 
     (if (null (cdr dependents))
      (exit 
       (|sayMSG| (cons "   The following function or rule "
                  (cons "depends on this:" (|bright| (car dependents)))))))
     (|sayMSG| "   The following functions or rules depend on this:")
     (setq msg (cons "     " nil))
     (do ((G166397 dependents (cdr G166397)) (y nil))
         ((or (atom G166397) (progn (setq y (car G166397)) nil)) nil)
       (seq (exit (setq msg (cons " " (cons y msg))))))
     (exit (|sayMSG| (append (nreverse msg) (cons '|%d| nil)))))
    nil)
   (exit 
    (if (setq dependees (getalist |$dependeeAlist| x))
     (seq
      (if (null (cdr dependees))
       (exit 
        (|sayMSG| (cons "   This depends on the following function "
                   (cons "or rule:" (|bright| (car dependees)))))))
      (|sayMSG| "   This depends on the following functions or rules:")
      (setq msg (cons "     " nil))
      (do ((G166406 dependees (cdr G166406)) (y nil))
          ((or (atom G166406) (progn (setq y (car G166406)) nil)) nil)
        (seq (exit (setq msg (cons " " (cons y msg))))))
      (exit (|sayMSG| (append (nreverse msg) (cons '|%d| nil)))))
     nil))))))

\end{chunk}

\defun{displayValue}{displayValue}
\calls{displayValue}{sayMSG}
\calls{displayValue}{fixObjectForPrinting}
\calls{displayValue}{pname}
\calls{displayValue}{objValUnwrap}
\calls{displayValue}{objMode}
\calls{displayValue}{displayRule}
\calls{displayValue}{concat}
\calls{displayValue}{prefix2String}
\calls{displayValue}{objMode}
\calls{displayValue}{getdatabase}
\calls{displayValue}{concat}
\calls{displayValue}{form2String}
\calls{displayValue}{mathprint}
\calls{displayValue}{outputFormat}
\calls{displayValue}{objMode}
\usesdollar{displayValue}{op}
\usesdollar{displayValue}{EmptyMode}
\begin{chunk}{defun displayValue}
(defun |displayValue| (|$op| u omitVariableNameIfTrue)
 (declare (special |$op|))
 (let (expr op rhs label labmode)
 (declare (special |$EmptyMode|))
  (if (null u)
   (|sayMSG|
    (list '|   Value of | (|fixObjectForPrinting| (pname |$op|)) ":  (none)"))
   (progn
    (setq expr (|objValUnwrap| u))
    (if (or (and (consp expr) (progn (setq op (qcar expr)) t) (eq op 'map))
            (equal (|objMode| u) |$EmptyMode|))
     (|displayRule| |$op| expr)
     (progn
       (cond
        (omitVariableNameIfTrue
          (setq rhs "):  ")
          (setq label "Value (has type "))
        (t
         (setq rhs ":  ")
         (setq label (concat "Value of " (pname |$op|) ": "))))
      (setq labmode (|prefix2String| (|objMode| u)))
      (when (atom labmode) (setq labmode (list labmode)))
      (if (eq (getdatabase expr 'constructorkind) '|domain|)
       (|sayMSG| (|concat| "   " label labmode rhs (|form2String| expr)))
       (|mathprint|
        (cons 'concat
         (cons label
          (append labmode
           (cons rhs
            (cons (|outputFormat| expr (|objMode| u)) nil)))))))
       nil))))))

\end{chunk}

\defun{displayType}{displayType}
\calls{displayType}{sayMSG}
\calls{displayType}{fixObjectForPrinting}
\calls{displayType}{pname}
\calls{displayType}{prefix2String}
\calls{displayType}{objMode}
\calls{displayType}{concat}
\usesdollar{displayType}{op}
\begin{chunk}{defun displayType}
(defun |displayType| (|$op| u omitVariableNameIfTrue)
 (declare (special |$op|) (ignore omitVariableNameIfTrue))
 (let (type)
  (if (null u)
   (|sayMSG|
    (list  "   Type of value of " (|fixObjectForPrinting| (pname |$op|))
           ":  (none)"))
   (progn
    (setq type (|prefix2String| (|objMode| u)))
    (when (atom type) (setq type (list type)))
    (|sayMSG|
     (|concat|
      (cons "   Type of value of "
       (cons (|fixObjectForPrinting| (pname |$op|))
        (cons ": " type)))))
     nil))))

\end{chunk}

\defun{getAndSay}{getAndSay}
\calls{getAndSay}{getI}
\calls{getAndSay}{sayMSG}
\begin{chunk}{defun getAndSay}
(defun |getAndSay| (v prop)
 (let (val)
  (if (setq val (|getI| v prop))
   (|sayMSG| (cons '|    | (cons val (cons '|%l| nil))))
   (|sayMSG| (cons '|    none| (cons '|%l| nil))))))

\end{chunk}

\defun{displayProperties}{displayProperties}
\calls{displayProperties}{getInterpMacroNames}
\calls{displayProperties}{getParserMacroNames}
\calls{displayProperties}{remdup}
\calls{displayProperties}{qcdr}
\calls{displayProperties}{qcar}
\calls{displayProperties}{msort}
\calls{displayProperties}{getWorkspaceNames}
\calls{displayProperties}{sayKeyedMsg}
\calls{displayProperties}{interpFunctionDepAlists}
\calls{displayProperties}{isInternalMapName}
\calls{displayProperties}{getIProplist}
\calls{displayProperties}{getAndSay}
\calls{displayProperties}{displayValue}
\calls{displayProperties}{getI}
\calls{displayProperties}{displayCondition}
\calls{displayProperties}{displayMode}
\calls{displayProperties}{displayType}
\calls{displayProperties}{fixObjectForPrinting}
\calls{displayProperties}{sayMSG}
\calls{displayProperties}{bright}
\calls{displayProperties}{prefix2String}
\calls{displayProperties}{member}
\calls{displayProperties}{displayParserMacro}
\calls{displayProperties}{isInterpMacro}
\calls{displayProperties}{displayMacro}
\calls{displayProperties}{displayProperties,sayFunctionDeps}
\calls{displayProperties}{displayModemap}
\calls{displayProperties}{exit}
\calls{displayProperties}{seq}
\calls{displayProperties}{terminateSystemCommand}
\usesdollar{displayProperties}{dependentAlist}
\usesdollar{displayProperties}{dependeeAlist}
\usesdollar{displayProperties}{frameMessages}
\usesdollar{displayProperties}{interpreterFrameName}
\begin{chunk}{defun displayProperties}
(defun |displayProperties| (option al)
 (let (|$dependentAlist| |$dependeeAlist| tmp1 opt imacs pmacs macros vl pl 
       tmp2 vone prop val propsSeen)
 (declare (special |$dependentAlist| |$dependeeAlist| |$frameMessages|
                    |$interpreterFrameName|))
  (setq |$dependentAlist| nil)
  (setq |$dependeeAlist| nil)
  (setq tmp1 (or al (cons '|properties| nil)))
  (setq opt (car tmp1))
  (setq vl (cdr tmp1))
  (setq imacs (|getInterpMacroNames|))
  (setq pmacs (|getParserMacroNames|))
  (setq macros (remdup (append imacs pmacs)))
  (when (or 
         (and (consp vl) (eq (qcdr vl) nil) (eq (qcar vl) '|all|))
         (null vl))
    (setq vl (msort (append (|getWorkspaceNames|) macros))))
   (when |$frameMessages|
    (|sayKeyedMsg| "The name of the current frame is %1 ."
     (cons |$interpreterFrameName| nil)))
   (cond
    ((null vl)
     (if (null |$frameMessages|) 
      (|sayKeyedMsg| "The workspace is empty." nil))
      (|sayKeyedMsg| "The current frame, %1 , is empty."
       (cons |$interpreterFrameName| nil)))
    (t 
     (|interpFunctionDepAlists|)
     (do ((G166440 vl (cdr G166440)) (v nil))
         ((or (atom G166440) (progn (setq v (car G166440)) nil)) nil)
       (seq (exit
        (cond
         ((|isInternalMapName| v) '|iterate|)
         (t
          (setq pl (|getIProplist| v))
          (cond
           ((eq option '|flags|) 
            (|getAndSay| v '|flags|))
           ((eq option '|value|) 
            (|displayValue| v (|getI| v '|value|) nil))
           ((eq option '|condition|)
            (|displayCondition| v (|getI| v '|condition|) nil))
           ((eq option '|mode|)
            (|displayMode| v (|getI| v '|mode|) nil))
           ((eq option '|type|)
            (|displayType| v (|getI| v '|value|) nil))
           ((eq option '|properties|)
            (cond
             ((eq v '|--flags--|)
               nil)
             ((and (consp pl)
                   (progn
                    (setq tmp2 (qcar pl))
                    (and (consp tmp2) (eq (qcar tmp2) '|cacheInfo|))))
               nil)
             (t
              (setq vone (|fixObjectForPrinting| v))
              (|sayMSG|
               (cons "Properties of"
                (append (|bright| (|prefix2String| vone)) (cons ":" nil))))
              (cond
               ((null pl)
                (cond
                 ((|member| v pmacs)
                  (|sayMSG| "   This is a user-defined macro.")
                  (|displayParserMacro| v))
                 ((|isInterpMacro| v)
                  (|sayMSG| "   This is a system-defined macro.")
                  (|displayMacro| v))
                 (t
                  (|sayMSG| "   none"))))
               (t 
                (setq propsSeen nil)
                (do ((G166451 pl (cdr G166451)) (G166425 nil))
                    ((or (atom G166451)
                         (progn (setq G166425 (car G166451)) nil)
                         (progn
                          (progn
                           (setq prop (car G166425))
                           (setq val (cdr G166425))
                           G166425)
                          nil))
                       nil)
                 (seq (exit
                  (cond
                   ((and (null (member prop propsSeen)) val)
                    (cond
                     ((|member| prop 
                       '(|alias| |generatedCode| IS-GENSYM 
                         |mapBody| |localVars|))
                       nil)
                     ((eq prop '|condition|)
                      (|displayCondition| prop val t))
                     ((eq prop '|recursive|)
                      (|sayMSG| "   This is recursive."))
                     ((eq prop '|isInterpreterFunction|)
                      (|sayMSG| "   This is an interpreter function.")
                      (|displayProperties,sayFunctionDeps| v))
                     ((eq prop '|isInterpreterRule|)
                      (|sayMSG| "   This is an interpreter rule.")
                      (|displayProperties,sayFunctionDeps| v))
                     ((eq prop '|localModemap|)
                      (|displayModemap| v val t))
                     ((eq prop '|mode|)
                      (|displayMode| prop val t))
                     (t
                      (when (eq prop '|value|)
                        (exit
                         (when val
                           (exit (|displayValue| v val t)))))
                       (|sayMSG| (list "   " prop ":  " val))
                       (setq propsSeen (cons prop propsSeen))))))))))))))
           (t
            (|sayKeyedMsg| "There is nothing to display for option %1 ."
             (cons option nil)))))))))
     (|terminateSystemCommand|)))))

\end{chunk}

\defun{displayParserMacro}{displayParserMacro}
\calls{displayParserMacro}{pfPrintSrcLines}
\usesdollar{displayParserMacro}{pfMacros}
\begin{chunk}{defun displayParserMacro}
(defun |displayParserMacro| (m)
 (let ((m (assq m |$pfMacros|)))
 (declare (special |$pfMacros|))
  (when m (|pfPrintSrcLines| (caddr m)))))

\end{chunk}

\defun{displayCondition}{displayCondition}
\calls{displayCondition}{bright}
\calls{displayCondition}{sayBrightly}
\calls{displayCondition}{concat}
\calls{displayCondition}{pred2English}
\begin{chunk}{defun displayCondition}
(defun |displayCondition| (v condition giveVariableIfNil)
 (let (varPart condPart)
  (when giveVariableIfNil (setq varPart (cons '| of| (|bright| v))))
  (setq condPart (or condition '|true|))
  (|sayBrightly|
   (|concat| '|   condition| varPart '|:  | (|pred2English| condPart)))))

\end{chunk}

\defun{interpFunctionDepAlists}{interpFunctionDepAlists}
\calls{interpFunctionDepAlists}{putalist}
\calls{interpFunctionDepAlists}{getalist}
\calls{interpFunctionDepAlists}{getFlag}
\usesdollar{interpFunctionDepAlists}{e}
\usesdollar{interpFunctionDepAlists}{dependeeAlist}
\usesdollar{interpFunctionDepAlists}{dependentAlist}
\usesdollar{interpFunctionDepAlists}{InteractiveFrame}
\begin{chunk}{defun interpFunctionDepAlists}
(defun |interpFunctionDepAlists| ()
 (let (|$e|)
 (declare (special |$e| |$dependeeAlist| |$dependentAlist| 
                   |$InteractiveFrame|))
  (setq |$e| |$InteractiveFrame|)
  (setq |$dependentAlist| (cons (cons nil nil) nil))
  (setq |$dependeeAlist| (cons (cons nil nil) nil))
  (mapcar #'(lambda (dep) 
   (let (dependee dependent)
    (setq dependee (first dep))
    (setq dependent (second dep))
    (setq |$dependentAlist| 
     (putalist |$dependentAlist| dependee
      (cons dependent (getalist |$dependentAlist| dependee))))
    (setq |$dependeeAlist|
     (putalist |$dependeeAlist| dependent
      (cons dependee (getalist |$dependeeAlist| dependent)))))) 
   (|getFlag| '|$dependencies|))))


\end{chunk}

\defun{displayModemap}{displayModemap}
\calls{displayModemap}{bright}
\calls{displayModemap}{sayBrightly}
\calls{displayModemap}{concat}
\calls{displayModemap}{formatSignature}
\begin{chunk}{defun displayModemap}
(defun |displayModemap| (v val giveVariableIfNil)
 (labels (
  (g (v mm giveVariableIfNil)
   (let (local signature fn varPart prefix)
    (setq local (caar mm))
    (setq signature (cdar mm))
    (setq fn (cadr mm))
    (unless (eq local '|interpOnly|)
     (setq varPart (unless giveVariableIfNil (cons " of" (|bright| v))))
     (setq prefix
      (cons '|   Compiled function type| (append varPart (cons '|: | nil))))
     (|sayBrightly| (|concat| prefix (|formatSignature| signature)))))))
  (mapcar #'(lambda (x) (g v x giveVariableIfNil)) val)))

\end{chunk}

\defun{displayMode}{displayMode}
\calls{displayMode}{bright}
\calls{displayMode}{fixObjectForPrinting}
\calls{displayMode}{sayBrightly}
\calls{displayMode}{concat}
\calls{displayMode}{prefix2String}
\begin{chunk}{defun displayMode}
(defun |displayMode| (v mode giveVariableIfNil)
 (let (varPart)
  (when mode
   (unless giveVariableIfNil
    (setq varPart (cons '| of| (|bright| (|fixObjectForPrinting| v)))))
   (|sayBrightly|
    (|concat| '|   Declared type or mode| varPart '|:   |
     (|prefix2String| mode))))))

\end{chunk}

\defun{dumbTokenize}{Split into tokens delimted by spaces}
\calls{dumbTokenize}{stripSpaces}
\begin{chunk}{defun dumbTokenize}
(defun |dumbTokenize| (str)
 (let (inString token (tokenStart 0) previousSpace tokenList)
  (dotimes (i (1- (|#| str)))
   (cond
    ((char= (elt str i) #\") ; don't split strings
     (setq inString (null inString))
     (setq previousSpace nil))
    ((and (char= (elt str i) #\space) (null inString))
     (unless previousSpace
       (setq token (|stripSpaces| (subseq str tokenStart i)))
       (setq tokenList (cons token tokenList))
       (setq tokenStart (1+ i))
       (setq previousSpace t)))
    (t
     (setq previousSpace nil))))
  (setq tokenList (cons (|stripSpaces| (subseq str tokenStart)) tokenList))
  (nreverse tokenList)))

\end{chunk}

\defun{tokTran}{Convert string tokens to their proper type}
\calls{tokTran}{isIntegerString}
\begin{chunk}{defun tokTran}
(defun |tokTran| (tok)
 (let (tmp)
  (if (stringp tok)
   (cond
    ((eql (|#| tok) 0) nil)
    ((setq tmp (|isIntegerString| tok)) tmp)
    ((char= (elt tok 0) #\" ) (subseq tok 1 (1- (|#| tok))))
    (t (intern tok)))
   tok)))

\end{chunk}

\defun{isIntegerString}{Is the argument string an integer?}
\begin{chunk}{defun isIntegerString 0}
(defun |isIntegerString| (tok)
 (multiple-value-bind (int len) (parse-integer tok :junk-allowed t)
  (when (and int (= len (length tok))) int)))

\end{chunk}

\defun{handleParsedSystemCommands}{Handle parsed system commands}
\calls{handleParsedSystemCommands}{dumbTokenize}
\calls{handleParsedSystemCommands}{parseSystemCmd}
\calls{handleParsedSystemCommands}{tokTran}
\calls{handleParsedSystemCommands}{systemCommand}
\begin{chunk}{defun handleParsedSystemCommands}
(defun |handleParsedSystemCommands| (unabr optionList)
 (declare (ignore unabr))
 (let (restOptionList parcmd trail)
  (setq restOptionList (mapcar #'|dumbTokenize| (cdr optionList)))
  (setq parcmd (|parseSystemCmd| (car optionList)))
  (setq trail
   (mapcar #'(lambda (opt)  
              (mapcar #'(lambda (tok) (|tokTran| tok)) opt)) restOptionList))
  (|systemCommand| (cons parcmd trail))))

\end{chunk}

\defun{parseSystemCmd}{Parse a system command}
\calls{parseSystemCmd}{tokTran}
\calls{parseSystemCmd}{stripSpaces}
\calls{parseSystemCmd}{parseFromString}
\calls{parseSystemCmd}{dumbTokenize}
\begin{chunk}{defun parseSystemCmd}
(defun |parseSystemCmd| (opt)
 (let (spaceIndex)
  (if (setq spaceIndex (search " " opt))
   (list
    (|tokTran| (|stripSpaces| (subseq opt 0 spaceIndex)))
    (|parseFromString| (|stripSpaces| (subseq opt spaceIndex))))
   (mapcar #'|tokTran| (|dumbTokenize| opt)))))

\end{chunk}

\defun{getFirstWord}{Get first word in a string}
\calls{getFirstWord}{subseq}
\calls{getFirstWord}{stringSpaces}
\begin{chunk}{defun getFirstWord}
(defun |getFirstWord| (string)
 (let (spaceIndex)
  (setq spaceIndex (search " " string))
  (if spaceIndex
   (|stripSpaces| (subseq string 0 spaceIndex))
   string)))

\end{chunk}

\defun{unAbbreviateKeyword}{Unabbreviate keywords in commands}
\calls{unAbbreviateKeyword}{selectOptionLC}
\calls{unAbbreviateKeyword}{selectOption}
\calls{unAbbreviateKeyword}{commandsForUserLevel}
\usesdollar{unAbbreviateKeyword}{systemCommands}
\usesdollar{unAbbreviateKeyword}{currentLine}
\usesdollar{unAbbreviateKeyword}{syscommands}
\uses{unAbbreviateKeyword}{line}
\begin{chunk}{defun unAbbreviateKeyword}
(defun |unAbbreviateKeyword| (x)
 (let (xp)
 (declare (special |$systemCommands| |$currentLine| $syscommands line))
  (setq xp (|selectOptionLC| x $syscommands '|commandErrorIfAmbiguous|))
  (cond
   ((null xp) 
    (setq xp '|system|)
    (setq line (concat ")system " (substring line 1 (1- (|#| line)))))
    (setq |$currentLine| line)))
  (|selectOption| xp (|commandsForUserLevel| |$systemCommands|)
     '|commandUserLevelError|)))

\end{chunk}

\defun{commandErrorIfAmbiguous}{The command is ambiguous error}
\calls{commandErrorIfAmbiguous}{commandAmbiguityError}
\usesdollar{commandErrorIfAmbiguous}{oldline}
\uses{commandErrorIfAmbiguous}{line}
\begin{chunk}{defun commandErrorIfAmbiguous}
(defun |commandErrorIfAmbiguous| (x u)
 (declare (special $oldline line))
 (when u
   (setq $oldline line)
   (|commandAmbiguityError| '|command| x u)))

\end{chunk}

\calls{handleNoParseCommands}{stripSpaces}
\calls{handleNoParseCommands}{nplisp}
\calls{handleNoParseCommands}{stripLisp}
\calls{handleNoParseCommands}{sayKeyedMsg}
\calls{handleNoParseCommands}{npboot}
\calls{handleNoParseCommands}{npsystem}
\calls{handleNoParseCommands}{npsynonym}
\calls{handleNoParseCommands}{member}
\calls{handleNoParseCommands}{concat}
\begin{chunk}{defun handleNoParseCommands}
(defun |handleNoParseCommands| (unab string)
 (let (spaceindex funname)
  (setq string (|stripSpaces| string))
  (setq spaceindex (search " " string))
  (cond
   ((eq unab '|lisp|)
    (if spaceindex
     (|nplisp| (|stripLisp| string))
     (|sayKeyedMsg| "Your argument list is not valid." nil)))
   ((eq unab '|boot|)
    (if spaceindex
     (|npboot| (subseq string (1+ spaceindex)))
     (|sayKeyedMsg| "Your argument list is not valid." nil)))
   ((eq unab '|system|)
    (if spaceindex
      (|npsystem| unab string)
      (|sayKeyedMsg| "Your argument list is not valid." nil)))
   ((eq unab '|synonym|)
    (if spaceindex
     (|npsynonym| unab (subseq string (1+ spaceindex)))
     (|npsynonym| unab "")))
   ((null spaceindex)
    (funcall unab))
   ((|member| unab '(|quit| |fin| |pquit| |credits| |copyright| |trademark|))
    (|sayKeyedMsg| "Your argument list is not valid." nil))
   (t
    (setq funname (intern (concat "np" (string unab))))
    (funcall funname (subseq string (1+ spaceindex)))))))

\end{chunk}

\defun{stripSpaces}{Remove the spaces surrounding a string}
\tpdhere{This should probably be a macro or eliminated}
\begin{chunk}{defun stripSpaces 0}
(defun |stripSpaces| (str)
 (string-trim '(#\space) str))

\end{chunk}

\defun{stripLisp}{Remove the lisp command prefix}
\begin{chunk}{defun stripLisp 0}
(defun |stripLisp| (str)
 (if (string= (subseq str 0 4) "lisp")
  (subseq str 4)
  str))

\end{chunk}

\defun{nplisp}{Handle the )lisp command}
\usesdollar{nplisp}{ans}
\begin{chunk}{defun nplisp 0}
(defun |nplisp| (str)
 (declare (special |$ans|))
  (setq |$ans| (eval (read-from-string str)))
  (format t "~&Value = ~S~%" |$ans|))

\end{chunk}

\defun{npboot}{The )boot command is no longer supported}
\tpdhere{Remove all boot references from top level}
\begin{chunk}{defun npboot 0}
(defun |npboot| (str)
 (declare (ignore str))
 (format t "The )boot command is no longer supported~%"))

\end{chunk}

\defun{npsystem}{Handle the )system command}
Note that unAbbreviateKeyword returns the word ``system'' for unknown words
so we have to search for this case. This complication may never arrive 
in practice.

\calls{npsystem}{sayKeyedMsg}
\begin{chunk}{defun npsystem}
(defun |npsystem| (unab str)
 (let (spaceIndex sysPart)
  (setq spaceIndex (search " " str))
  (cond
   ((null spaceIndex) (|sayKeyedMsg| "Unknown system command: %1" (list str)))
   (t
    (setq sysPart (subseq str 0 spaceIndex))
    (if (search sysPart (string unab))
     (obey (subseq str (1+ spaceIndex)))
     (|sayKeyedMsg| "Unknown system command: %1" (list sysPart)))))))

\end{chunk}

\defun{npsynonym}{Handle the )synonym command}
\calls{npsynonym}{npProcessSynonym}
\begin{chunk}{defun npsynonym}
(defun |npsynonym| (unab str)
 (declare (ignore unab))
 (|npProcessSynonym| str)) 

\end{chunk}

\defun{npProcessSynonym}{Handle the synonym system command}
\calls{npProcessSynonym}{printSynonyms}
\calls{npProcessSynonym}{processSynonymLine}
\calls{npProcessSynonym}{putalist}
\calls{npProcessSynonym}{terminateSystemCommand}
\usesdollar{npProcessSynonym}{CommandSynonymAlist}
\begin{chunk}{defun npProcessSynonym}
(defun |npProcessSynonym| (str)
 (let (pair)
 (declare (special |$CommandSynonymAlist|))
  (if (= (length str) 0)
   (|printSynonyms| nil)
   (progn
    (setq pair (|processSynonymLine| str))
    (if |$CommandSynonymAlist|
     (putalist |$CommandSynonymAlist| (car pair) (cdr pair)))
     (setq |$CommandSynonymAlist| (cons pair nil))))
  (|terminateSystemCommand|)))

\end{chunk}

\defun{printSynonyms}{printSynonyms}
\calls{printSynonyms}{specialChar}
\calls{printSynonyms}{filterListOfStringsWithFn}
\calls{printSynonyms}{synonymsForUserLevel}
\calls{printSynonyms}{printLabelledList}
\usesdollar{printSynonyms}{CommandSynonymAlist}
\usesdollar{printSynonyms}{linelength}
\begin{chunk}{defun printSynonyms}
(defun |printSynonyms| (patterns)
 (let (ls t1)
  (declare (special |$CommandSynonymAlist| $linelength))
  (format t "~v,,,'-:@<~a~>~%" (- $linelength 2) " System Command Synonyms ")
  (setq ls
    (|filterListOfStringsWithFn| patterns
     (do ((t2 (|synonymsForUserLevel| |$CommandSynonymAlist|) (cdr t2)))
         ((atom t2) (nreverse0 t1))
        (push (cons (princ-to-string (caar t2)) (cdar t2)) t1))
     #'car))
  (|printLabelledList| ls "user" "synonyms" ")" patterns)))

\end{chunk}

\defun{printLabelledList}{Print a list of each matching synonym}
The prefix goes before each element on each side of the list, eg, ")"

\calls{printLabelledList}{sayMessage}
\calls{printLabelledList}{blankList}
\calls{printLabelledList}{substring}
\calls{printLabelledList}{entryWidth}
\calls{printLabelledList}{sayBrightly}
\calls{printLabelledList}{concat}
\calls{printLabelledList}{fillerSpaces}
\begin{chunk}{defun printLabelledList}
(defun |printLabelledList| (ls label1 label2 prefix patterns)
 (let (comm syn wid)
  (if (null ls)
   (if (null patterns)
    (|sayMessage| (list "   No " label1 "-defined " label2 " in effect."))
    (|sayMessage|
     `("   No " ,label1 "-defined " ,label2 " satisfying patterns:"
       |%l| "     " ,@(append (|blankList| patterns) (list nil)))))
   (progn
    (when patterns
      (|sayMessage|
       `(,label1 "-defined " ,label2 " satisfying patterns:" |%l| "   "
          ,@(append (|blankList| patterns) (list nil)))))
     (do ((t1 ls (cdr t1)))
         ((atom t1) nil)
      (setq syn (caar t1))
      (setq comm (cdar t1))
      (when (string= (substring syn 0 1) "|")
       (setq syn (substring syn 1 nil)))
      (when (string= syn "%i") (setq syn "%i "))
      (setq wid (max (- 30 (|#| syn)) 1))
      (|sayBrightly|
       (|concat| prefix syn (|fillerSpaces| wid ".")
         " " prefix comm)))
     (|sayBrightly| "")))))

\end{chunk}

\defdollar{tokenCommands}
This is a list of the commands that expect the interpreter to parse
their arguments. Thus the history command expects that Axiom will have
tokenized and validated the input before calling the history function.
\begin{chunk}{initvars}
(defvar |$tokenCommands| nil)

\end{chunk}

\begin{chunk}{postvars}
(eval-when (eval load)
 (setq |$tokenCommands|
 '( |abbreviations|
    |cd|
    |clear|
    |close|
    |compiler|
    |depends|
    |display|
    |describe|
    |edit|
    |frame|
    |help|
    |history|
    |input|
    |library|
    |load|
    |ltrace|
    |read|
    |regress|
    |savesystem|
    |set|
    |spool|
    |tangle|
    |undo|
    |what|
    |with|
    |workfiles|
    )))

\end{chunk}

\defdollar{InitialCommandSynonymAlist}
Axiom can create ``synonyms'' for commands. We create an initial table
of synonyms which are in common use.
\begin{chunk}{initvars}
(defvar |$InitialCommandSynonymAlist| nil)

\end{chunk}

\defun{axiomVersion}{Print the current version information}
\uses{axiomVersion}{*yearweek*}
\uses{axiomVersion}{*build-version*}
\begin{chunk}{defun axiomVersion 0}
(defun axiomVersion ()
 (declare (special *build-version* *yearweek*))
  (concatenate 'string "Axiom " *build-version* " built on " *yearweek*))

\end{chunk}

\begin{chunk}{postvars}
(eval-when (eval load)
 (setq |$InitialCommandSynonymAlist|
   '(
       (|?|          . "what commands")
       (|ap|         . "what things")
       (|apr|        . "what things")
       (|apropos|    . "what things")
       (|cache|      . "set functions cache")
       (|cl|         . "clear")
       (|cms|        . "system")
       (|co|         . "compiler")
       (|d|          . "display")
       (|dep|        . "display dependents")
       (|dependents| . "display dependents")
       (|e|          . "edit")
       (|expose|     . "set expose add constructor")
       (|fns|        . "exec spadfn")
       (|fortran|    . "set output fortran")
       (|h|          . "help")
       (|hd|         . "system hypertex &")
       (|kclam|      . "boot clearClams ( )")
       (|killcaches| . "boot clearConstructorAndLisplibCaches ( )")
       (|prompt|     . "set message prompt")
       (|recurrence| . "set functions recurrence")
       (|restore|    . "history )restore")
       (|save|       . "history )save")
       (|startGraphics|    .  "system $AXIOM/lib/viewman &")
       (|startNAGLink|     .  "system $AXIOM/lib/nagman &")
       (|stopGraphics|     .  "lisp (|sockSendSignal| 2 15)")
       (|stopNAGLink|      .  "lisp (|sockSendSignal| 8 15)")
       (|time|       . "set message time")
       (|type|       . "set message type")
       (|unexpose|   . "set expose drop constructor")
       (|version|    . "lisp (axiomVersion)")
       (|w|          . "what")
       (|wc|         . "what categories")
       (|wd|         . "what domains")
       (|who|        . "lisp (pprint credits)")
       (|wp|         . "what packages")
       (|ws|         . "what synonyms")
)))

\end{chunk}

\defdollar{CommandSynonymAlist}
The actual list of synonyms is initialized to be the same as the 
above initial list of synonyms. The user synonyms that are added
during a session are pushed onto this list for later lookup.
\begin{chunk}{initvars}
(defvar |$CommandSynonymAlist| nil)

\end{chunk}

\begin{chunk}{postvars}
(eval-when (eval load)
 (setq |$CommandSynonymAlist| (copy-alist |$InitialCommandSynonymAlist|)))

\end{chunk}

\defun{ncloopCommand}{ncloopCommand}
The \$systemCommandFunction is set in SpadInterpretStream
to point to the function InterpExecuteSpadSystemCommand.
The system commands are handled by the function in the ``hook''
variable \verb|$systemCommandFunction| which
has the default function \verb|InterpExecuteSpadSystemCommand|.
Thus, when a system command is entered this function is called.

The only exception is the \verb|)include| function which inserts
the contents of a file inline in the input stream. This is useful
for processing \verb|)read| of input files.

\calls{ncloopCommand}{ncloopPrefix?}
\calls{ncloopCommand}{ncloopInclude1}
\callsdollar{ncloopCommand}{systemCommandFunction}
\usesdollar{ncloopCommand}{systemCommandFunction}
\label{ncloopCommand}
\begin{chunk}{defun ncloopCommand}
(defun |ncloopCommand| (line n)
 (let (a)
 (declare (special |$systemCommandFunction|))
  (if (setq a (|ncloopPrefix?| ")include" line))
   (|ncloopInclude1| a n)
   (progn
    (funcall |$systemCommandFunction| line)
    n))))

\end{chunk}

\defun{ncloopPrefix?}{ncloopPrefix?}
If we find the prefix string in the whole string starting at position zero
we return the remainder of the string without the leading prefix.
\begin{chunk}{defun ncloopPrefix? 0}
(defun |ncloopPrefix?| (prefix whole)
 (when (eql (search prefix whole) 0)
  (subseq whole (length prefix))))

\end{chunk}

\defun{selectOptionLC}{selectOptionLC}
\calls{selectOptionLC}{selectOption}
\calls{selectOptionLC}{downcase}
\calls{selectOptionLC}{object2Identifier}
\begin{chunk}{defun selectOptionLC}
(defun |selectOptionLC| (x l errorFunction)
 (|selectOption| (downcase (|object2Identifier| x)) l errorFunction)) 

\end{chunk}

\defun{selectOption}{selectOption}
\calls{selectOption}{member}
\calls{selectOption}{identp}
\calls{selectOption}{stringPrefix?}
\calls{selectOption}{pname}
\calls{selectOption}{qcdr}
\calls{selectOption}{qcar}
\begin{chunk}{defun selectOption}
(defun |selectOption| (x l errorfunction)
 (let (u y)
  (cond
   ((|member| x l) x)
   ((null (identp x))
    (cond
     (errorfunction (funcall errorfunction x u))
     (t nil)))
   (t
    (setq u
     (let (t0)
       (do ((t1 l (cdr t1)) (y nil))
           ((or (atom t1) (progn (setq y (car t1)) nil)) (nreverse0 t0))
          (if (|stringPrefix?| (pname x) (pname y))
             (setq t0 (cons y t0))))))
    (cond
     ((and (consp u) (eq (qcdr u) nil) (progn (setq y (qcar u)) t)) y)
     (errorfunction (funcall errorfunction x u))
     (t nil))))))

\end{chunk}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{abbreviations}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{abbreviations.help}
====================================================================
A.2.  )abbreviation
====================================================================
 
User Level Required:  compiler
 
Command Syntax: 
 
  -  )abbreviation query  [nameOrAbbrev]
  -  )abbreviation category  abbrev  fullname [)quiet]
  -  )abbreviation domain  abbrev  fullname   [)quiet]
  -  )abbreviation package  abbrev  fullname  [)quiet]
  -  )abbreviation remove  nameOrAbbrev
 
Command Description: 
 
This command is used to query, set and remove abbreviations for category,
domain and package constructors. Every constructor must have a unique
abbreviation. This abbreviation is part of the name of the subdirectory under
which the components of the compiled constructor are stored. Furthermore, by
issuing this command you let the system know what file to load automatically
if you use a new constructor. Abbreviations must start with a letter and then
be followed by up to seven letters or digits. Any letters appearing in the
abbreviation must be in uppercase.
 
When used with the query argument, this command may be used to list the name
associated with a particular abbreviation or the abbreviation for a
constructor. If no abbreviation or name is given, the names and corresponding
abbreviations for all constructors are listed.
 
The following shows the abbreviation for the constructor List:
 
)abbreviation query List
 
The following shows the constructor name corresponding to the abbreviation
NNI:
 
)abbreviation query NNI
 
The following lists all constructor names and their abbreviations.
 
)abbreviation query
 
To add an abbreviation for a constructor, use this command with category,
domain or package. The following add abbreviations to the system for a
category, domain and package, respectively:
 
)abbreviation domain   SET Set
)abbreviation category COMPCAT  ComplexCategory
)abbreviation package  LIST2MAP ListToMap
 
If the )quiet option is used, no output is displayed from this command. You
would normally only define an abbreviation in a library source file. If this
command is issued for a constructor that has already been loaded, the
constructor will be reloaded next time it is referenced. In particular, you
can use this command to force the automatic reloading of constructors.
 
To remove an abbreviation, the remove argument is used. This is usually only
used to correct a previous command that set an abbreviation for a constructor
name. If, in fact, the abbreviation does exist, you are prompted for
confirmation of the removal request. Either of the following commands will
remove the abbreviation VECTOR2 and the constructor name VectorFunctions2
from the system:
 
)abbreviation remove VECTOR2
)abbreviation remove VectorFunctions2
 
Also See: 
o )compile
 
\end{chunk}

\defun{abbreviations}{abbreviations}
\calls{abbreviations}{abbreviationsSpad2Cmd}
\begin{chunk}{defun abbreviations}
(defun |abbreviations| (l)
 (|abbreviationsSpad2Cmd| l)) 

\end{chunk}
\defun{abbreviationsSpad2Cmd}{abbreviationsSpad2Cmd}
\calls{abbreviationsSpad2Cmd}{listConstructorAbbreviations}
\calls{abbreviationsSpad2Cmd}{abbreviation?}
\calls{abbreviationsSpad2Cmd}{abbQuery}
\calls{abbreviationsSpad2Cmd}{deldatabase}
\calls{abbreviationsSpad2Cmd}{size}
\calls{abbreviationsSpad2Cmd}{sayKeyedMsg}
\calls{abbreviationsSpad2Cmd}{mkUserConstructorAbbreviation}
\calls{abbreviationsSpad2Cmd}{setdatabase}
\calls{abbreviationsSpad2Cmd}{seq}
\calls{abbreviationsSpad2Cmd}{exit}
\calls{abbreviationsSpad2Cmd}{opOf}
\calls{abbreviationsSpad2Cmd}{helpSpad2Cmd}
\calls{abbreviationsSpad2Cmd}{selectOptionLC}
\calls{abbreviationsSpad2Cmd}{qcar}
\calls{abbreviationsSpad2Cmd}{qcdr}
\usesdollar{abbreviationsSpad2Cmd}{options}
\begin{chunk}{defun abbreviationsSpad2Cmd}
(defun |abbreviationsSpad2Cmd| (arg)
 (let (abopts quiet opt key type constructor t2 a b al)
  (declare (special |$options|))
  (if (null arg) 
   (|helpSpad2Cmd| '(|abbreviations|))
   (progn
    (setq abopts '(|query| |domain| |category| |package| |remove|))
    (setq quiet nil)
    (do ((t0 |$options| (cdr t0)) (t1 nil))
        ((or (atom t0) 
             (progn (setq t1 (car t0)) nil)
             (progn (progn (setq opt (car t1)) t1) nil))
          nil)
      (setq opt (|selectOptionLC| opt '(|quiet|) '|optionError|))
      (when (eq opt '|quiet|) (setq quiet t)))
    (when
     (and (consp arg) 
           (progn 
            (setq opt (qcar arg))
            (setq al (qcdr arg))
            t))
       (setq key (|opOf| (car al)))
       (setq type (|selectOptionLC| opt abopts '|optionError|))
       (cond
        ((eq type '|query|)
         (cond 
          ((null al) (|listConstructorAbbreviations|))
          ((setq constructor (|abbreviation?| key))
            (|abbQuery| constructor))
          (t (|abbQuery| key))))
        ((eq type '|remove|)
         (deldatabase key 'abbreviation))
        ((oddp (size al))
         (|sayKeyedMsg| 
          (format nil 
           "%1 must be followed by an alternating list of abbreviation(s) ~
            and name(s). Issue )abbrev ? for more information.")
          (list type)))
        (t
         (do () (nil nil)
          (seq 
           (exit 
            (cond
             ((null al) (return '|fromLoop|))
             (t
               (setq t2 al)
               (setq a (car t2))
               (setq b (cadr t2))
               (setq al (cddr t2))
               (|mkUserConstructorAbbreviation| b a type)
               (setdatabase b 'abbreviation a)
               (setdatabase b 'constructorkind type))))))
         (unless quiet
           (|sayKeyedMsg| "%1 abbreviates % %2 %3 %"
            (list a type (|opOf| b)))))))))))

\end{chunk}

\defun{listConstructorAbbreviations}{listConstructorAbbreviations}
\calls{listConstructorAbbreviations}{upcase}
\calls{listConstructorAbbreviations}{queryUserKeyedMsg}
\calls{listConstructorAbbreviations}{string2id-n}
\calls{listConstructorAbbreviations}{whatSpad2Cmd}
\calls{listConstructorAbbreviations}{sayKeyedMsg}
\begin{chunk}{defun listConstructorAbbreviations}
(defun |listConstructorAbbreviations| ()
 (let (x)
  (setq x
   (upcase
     (|queryUserKeyedMsg|
      (format nil
       "You have requested that all abbreviations be displayed. As there are ~
        several hundred abbreviations, please confirm your request by ~
        typing y or yes and then pressing Enter :")
       nil)))
  (if (member (string2id-n x 1) '(Y YES))
   (progn
    (|whatSpad2Cmd| '(|categories|))
    (|whatSpad2Cmd| '(|domains|))
    (|whatSpad2Cmd| '(|packages|)))
   (|sayKeyedMsg| 
    (format nil
     "Since you did not respond with y or yes the list of abbreviations ~
      will not be displayed.")
     nil))))

\end{chunk}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{boot}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{boot.help}
====================================================================
A.3.  )boot
====================================================================
 
User Level Required:  development
 
Command Syntax: 
 
  -  )boot bootExpression
 
Command Description: 
 
This command is used by AXIOM system developers to execute expressions
written in the BOOT language. For example,
 
)boot times3(x) == 3*x
 
creates and compiles the Lisp function ``times3'' obtained by translating the
BOOT code.
 
Also See: 
o )fin
o )lisp
o )set
o )system
 
\end{chunk}
\footnote{
\fnref{fin}
\fnref{lisp}
\fnref{set}
\fnref{system}}

This command is in the list of \verb|$noParseCommands|
\ref{noParseCommands} which means that its arguments are passed
verbatim. This will eventually result in a call to the function
\verb|handleNoParseCommands| \ref{handleNoParseCommands}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{browse}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{browse.help}

User Level Required: development

Command Syntax:

  )browse

Command Description:

This command is used by Axiom system users to start the Axiom top level
loop listening for browser connections.

\end{chunk}
\section{Overview}
The Axiom book on the help browser is a complete rewrite of the 
hyperdoc mechanism. There are several components that were needed
to make this function. Most of the web browser components are
described in bookvol11.pamphlet. This portion describes some of
the design issues needed to support the interface.

The axServer command takes a port (defaulting to 8085) and a
program to handle the browser interaction (defaulting to multiServ).
The axServer function opens the port, constructs the stream, and
passes the stream to multiServ. The multiServ loop processes one
interaction at a time.

So the basic process is that the Axiom ``)browse'' command opens a
socket and listens for http requests. Based on the type of request
(either 'GET' or 'POST') and the content of the request, which is
one of:
\begin{itemize}
\item command - algebra request/response
\item lispcall - a lisp s-expression to be evaluated
\item showcall - an Axiom )show command
\end{itemize}
the multiServ function will call a handler function to evaluate
the command line and construct a response. GET requests result
in a new browser page. POST requests result in an inline result.

Most responses contain the fields:
\begin{itemize}
\item stepnum - this is the Axiom step number 
\item command - this is the original command from the browser
\item algebra - this is the Axiom 2D algebra output
\item mathml - this is the MathML version of the Axiom algebra
\item type - this is the type of the Axiom result
\end{itemize}

\section{Browsers, MathML, and Fonts}
This work has the Firefox browser as its target. Firefox has built-in
support for MathML, javascript, and XMLHttpRequests. More details
are available in bookvol11.pamphlet but the very basic machinery for 
communication with the browser involves a dance between the browser
and the multiServ function (see the axserver.spad.pamphlet). 

In particular, a simple request is embedded in a web page as:
\begin{verbatim}
<ul>
 <li>
  <input type="submit" id="p3" class="subbut" 
    onclick="makeRequest('p3');"
    value="sin(x)" />
  <div id="ansp3"><div></div></div>
 </li>
</ul>
\end{verbatim}
which says that this is an html ``input'' field of type ``submit''.
The CSS display class is ``subbut'' which is of a different color
than the surrounding text to make it obvious that you can click on
this field. Clickable fields that have no response text are of class
``noresult''.

The javascript call to ``makeRequest'' gives the ``id'' of this input
field, which must be unique in the page, as an argument. In this case,
the argument is 'p3'. The ``value'' field holds the display text which
will be passed back to Axiom as a command.

When the result arrives the ``showanswer'' function will select out
the mathml field of the response, construct the ``id'' of the html
div to hold the response by concatenating the string ``ans'' (answer)
to the ``id'' of the request resulting, in this case, as ``ansp3''.
The ``showanswer'' function will find this div and replace it with a
div containing the mathml result.

The ``makeRequest'' function is:
\begin{verbatim}
 function makeRequest(arg) {
   http_request = new XMLHttpRequest();         
   var command = commandline(arg);
   //alert(command);
   http_request.open('POST', '127.0.0.1:8085', true);
   http_request.onreadystatechange = handleResponse;
   http_request.setRequestHeader('Content-Type', 'text/plain');
   http_request.send("command="+command);
   return(false);
\end{verbatim}
It contains a request to open a local server connection to Axiom,
sets ``handleResponse'' as the function to call on reply, sets up
the type of request, fills in the command field, and sends off the
http request.

When a response is received, the ``handleResponse'' function checks
for the correct reply state, strips out the important text, and
calls ``showanswer''.
\begin{verbatim}
 function handleResponse() {
  if (http_request.readyState == 4) {
   if (http_request.status == 200) {
    showanswer(http_request.responseText,'mathAns');
   } else
   {
     alert('There was a problem with the request.'+ http_request.statusText);
   }
  }
 }
\end{verbatim}
See bookvol11.pamphlet for further details.

\section{The axServer/multiServ loop}
The basic call to start an Axiom browser listener is:
\begin{verbatim}
  )set message autoload off
  )set output mathml on
  axServer(8085,multiServ)$AXSERV
\end{verbatim}

This call sets the port, opens a socket, attaches it to a stream,
and then calls ``multiServ'' with that stream. The ``multiServ''
function loops serving web responses to that port.

\section{\enspace{}The )browse command}
In order to make the whole process cleaner the function ``)browse''
handles the details. This code creates the command-line function for )browse

The browse function does the internal equivalent of the following 3 command
line statments:
\begin{verbatim}
  )set message autoload off
  )set output mathml on
  axServer(8085,multiServ)$AXSERV
\end{verbatim}
which causes Axiom to start serving web pages on port 8085

For those unfamiliar with calling algebra from lisp there are a 
few points to mention. 

The loadLib needs to be called to load the algebra code into the image.
Normally this is automatic but we are not using the interpreter so
we need to do this ``by hand''.

Each algebra file contains a "constructor function" which builds the
domain, which is a vector, and then caches the vector so that every
call to the contructor returns an EQ vector, that is, the same vector.
In this case, we call the constructor $\vert$AxiomServer$\vert$

The axServer function was mangled internally to 
$\vert$AXSERV;axServer;IMV;2$\vert$.
The multiServ function was mangled to $\vert$AXSERV;multiServ;SeV;3$\vert$
Note well that if you change axserver.spad these names might change
which will generate the error message along the lines of:
\begin{verbatim}
    System error:
    The function $\vert$AXSERV;axServer;IMV;2$\vert$ is undefined.
\end{verbatim}

To fix this you need to look at int/algebra/AXSERV.nrlib/code.lsp
and find the new mangled function name. A better solution would
be to dynamically look up the surface names in the domain vector.

Each Axiom function expects the domain vector as the last argument.
This is not obvious from the call as the interpreter supplies it.
We must do that ``by hand''.

We don't call the multiServ function. We pass it as a parameter to
the axServer function. When it does get called by the SPADCALL
macro it needs to be a lisp pair whose car is the function and
whose cdr is the domain vector. We construct that pair here as
the second argument to axServer. The third, hidden, argument to
axServer is the domain vector which we supply ``by hand''.

The socket can be supplied on the command line but defaults to 8085.
Axiom supplies the arguments as a list.

\calls{browse}{set}
\calls{browse}{loadLib}
\calls{browse}{AxiomServer}
\calls{browse}{AXSERV;axServer;IMV;2}
\begin{chunk}{defun browse}
(defun |browse| (socket)
 (let (axserv browser)
  (if socket 
    (setq socket (car socket))
    (setq socket 8085))
  (|set| '(|mes| |auto| |off|))
  (|set| '(|out| |mathml| |on|))
  (|loadLib| '|AxiomServer|)
  (setq axserv (|AxiomServer|))
  (setq browser 
   (|AXSERV;axServer;IMV;2| socket
    (cons #'|AXSERV;multiServ;SeV;3| axserv) axserv))))

\end{chunk}
Now we have to bolt it into Axiom. This involves two lookups.

We create the lisp pair 
\begin{verbatim}
  (|browse| . |development|)
\end{verbatim} 
and cons it into the \$systemCommands command table.  This allows the
command to be executed in development mode.  This lookup decides if
this command is allowed. It also has the side-effect of putting the
command into the \$SYSCOMMANDS variable which is used to determine
if the token is a command.

\section{\enspace{}The server support code}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{cd}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{cd.help}
====================================================================
A.4.  )cd
====================================================================
 
User Level Required:  interpreter
 
Command Syntax: 
 
  -  )cd directory
 
Command Description: 
 
This command sets the AXIOM working current directory. The current directory
is used for looking for input files (for )read), AXIOM library source files
(for )compile), saved history environment files (for )history )restore),
compiled AXIOM library files (for )library), and files to edit (for )edit).
It is also used for writing spool files (via )spool), writing history input
files (via )history )write) and history environment files (via )history
)save),and compiled AXIOM library files (via )compile).
 
If issued with no argument, this command sets the AXIOM current directory to
your home directory. If an argument is used, it must be a valid directory
name. Except for the ``)'' at the beginning of the command, this has the same
syntax as the operating system cd command.
 
Also See: 
o )compile
o )edit
o )history
o )library
o )read
o )spool
 
\end{chunk}
\footnote{
\fnref{edit}
\fnref{history}
\fnref{library}
\fnref{read}
\fnref{spool}}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{clear}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{clear.help}
====================================================================
A.6.  )clear
====================================================================
 
User Level Required:  interpreter
 
Command Syntax: 
 
  - )clear all
  - )clear completely
  - )clear properties all
  - )clear properties  obj1 [obj2 ...]
  - )clear value      all
  - )clear value     obj1 [obj2 ...]
  - )clear mode       all
  - )clear mode      obj1 [obj2 ...]
 
Command Description: 
 
This command is used to remove function and variable declarations,
definitions and values from the workspace. To empty the entire workspace and
reset the step counter to 1, issue
 
)clear all
 
To remove everything in the workspace but not reset the step counter, issue
 
)clear properties all
 
To remove everything about the object x, issue
 
)clear properties x
 
To remove everything about the objects x, y and f, issue
 
)clear properties x y f
 
The word properties may be abbreviated to the single letter ``p''.
 
)clear p all
)clear p x
)clear p x y f
 
All definitions of functions and values of variables may be removed by either
 
)clear value all
)clear v all
 
This retains whatever declarations the objects had. To remove definitions and
values for the specific objects x, y and f, issue
 
)clear value x y f
)clear v x y f
 
To remove the declarations of everything while leaving the definitions and
values, issue
 
)clear mode  all
)clear m all
 
To remove declarations for the specific objects x, y and f, issue
 
)clear mode x y f
)clear m x y f
 
The )display names and )display properties commands may be used to see what
is currently in the workspace.
 
The command
 
)clear completely
 
does everything that )clear all does, and also clears the internal system
function and constructor caches.
 
Also See: 
o )display
o )history
o )undo
 
\end{chunk}
\footnote{
\fnref{display}
\fnref{history}
\fnref{undo}}

\defdollar{clearOptions}
\begin{chunk}{initvars}
(defvar |$clearOptions| '(|modes| |operations| |properties| |types| |values|))

\end{chunk}

\defun{clear}{clear}
\calls{clear}{clearSpad2Cmd}
\begin{chunk}{defun clear}
(defun |clear| (l)
 (|clearSpad2Cmd| l)) 

\end{chunk}

\defdollar{clearExcept}
\begin{chunk}{initvars}
(defvar |$clearExcept| nil)

\end{chunk}

\defun{clearSpad2Cmd}{clearSpad2Cmd}
TPDHERE: Note that this function also seems to parse out )except
)completely and )scaches which don't seem to be documented.
\calls{clearSpad2Cmd}{selectOptionLC}
\calls{clearSpad2Cmd}{sayKeyedMsg}
\calls{clearSpad2Cmd}{clearCmdAll}
\calls{clearSpad2Cmd}{clearCmdCompletely}
\calls{clearSpad2Cmd}{clearCmdSortedCaches}
\calls{clearSpad2Cmd}{clearCmdExcept}
\calls{clearSpad2Cmd}{clearCmdParts}
\calls{clearSpad2Cmd}{updateCurrentInterpreterFrame}
\usesdollar{clearSpad2Cmd}{clearExcept}
\usesdollar{clearSpad2Cmd}{options}
\usesdollar{clearSpad2Cmd}{clearOptions}
\begin{chunk}{defun clearSpad2Cmd}
(defun |clearSpad2Cmd| (l)
  (let (|$clearExcept| opt optlist arg)
  (declare (special |$clearExcept| |$options| |$clearOptions|))
  (cond 
   (|$options|
    (setq |$clearExcept|
     (prog (t0)
      (setq t0 t)
      (return
       (do ((t1 nil (null t0))
            (t2 |$options| (cdr t2))
            (t3 nil))
           ((or t1 
                (atom t2)
                (progn (setq t3 (car t2)) nil)
                (progn (progn (setq opt (car t3)) t3) nil))
              t0)
        (setq t0
         (and t0 
              (eq
               (|selectOptionLC| opt '(|except|) '|optionError|)
               '|except|)))))))))
  (cond
   ((null l)
     (setq optlist
      (prog (t4)
       (setq t4 nil)
       (return
        (do ((t5 |$clearOptions| (cdr t5)) (x nil))
            ((or (atom t5) (progn (setq x (car t5)) nil)) t4)
         (setq t4 (append t4 `(|%l| "       " ,x)))))))
     (|sayKeyedMsg|
      (format nil
       "Use )clear all to clear everything in the workspace.  Use )clear ~
        completely to clear everything in the workspace and internal ~
        tables.  Other )clear keyword arguments are %1 %l or abbreviations ~
        thereof.  Issue )clear ? for more information.")
       (list optlist)))
   (t
     (setq arg
      (|selectOptionLC| (car l) '(|all| |completely| |scaches|) nil))
     (cond
      ((eq arg '|all|)        (|clearCmdAll|))
      ((eq arg '|completely|) (|clearCmdCompletely|))
      ((eq arg '|scaches|)    (|clearCmdSortedCaches|))
      (|$clearExcept|         (|clearCmdExcept| l))
      (t 
       (|clearCmdParts| l)
       (|updateCurrentInterpreterFrame|))))))) 

\end{chunk}

\defun{clearCmdSortedCaches}{clearCmdSortedCaches}
\calls{clearCmdSortedCaches}{compiledLookupCheck}
\calls{clearCmdSortedCaches}{spadcall}
\usesdollar{clearCmdSortedCaches}{lookupDefaults}
\usesdollar{clearCmdSortedCaches}{Void}
\usesdollar{clearCmdSortedCaches}{ConstructorCache}
\begin{chunk}{defun clearCmdSortedCaches}
(defun |clearCmdSortedCaches| ()
 (let (|$lookupDefaults| domain pair)
  (declare (special |$lookupDefaults| |$Void| |$ConstructorCache|))
  (do ((t0 (hget |$ConstructorCache| '|SortedCache|) (cdr t0)) 
       (t1 nil))
      ((or (atom t0) 
           (progn
            (setq t1 (car t0)) 
            (setq domain (cddr t1))
            nil))
         nil)
    (setq pair (|compiledLookupCheck| '|clearCache| (list |$Void|) domain))
    (spadcall pair))))

\end{chunk}

\defun{compiledLookupCheck}{compiledLookupCheck}
\calls{compiledLookupCheck}{compiledLookup}
\calls{compiledLookupCheck}{keyedSystemError}
\calls{compiledLookupCheck}{formatSignature}
\begin{chunk}{defun compiledLookupCheck}
(defun |compiledLookupCheck| (op sig dollar)
 (let (fn)
  (setq fn (|compiledLookup| op sig dollar))
  (cond
    ((and (null fn) (eq op '^))
      (setq fn (|compiledLookup| '** sig dollar)))
    ((and (null fn) (eq op '**))
      (setq fn (|compiledLookup| '^ sig dollar)))
    (t nil))
  (cond
   ((null fn)
    (|keyedSystemError| 
      "The function %1 with signature %2 is missing from domain %3"
      (list op (|formatSignature| sig) (elt dollar 0))))
   (t fn))))

\end{chunk}

\defdollar{functionTable}
\begin{chunk}{initvars}
(defvar |$functionTable| nil)

\end{chunk}

\defun{clearCmdCompletely}{clearCmdCompletely}
\calls{clearCmdCompletely}{clearCmdAll}
\calls{clearCmdCompletely}{sayKeyedMsg}
\calls{clearCmdCompletely}{clearClams}
\calls{clearCmdCompletely}{clearConstructorCaches}
\calls{clearCmdCompletely}{reclaim}
\usesdollar{clearCmdCompletely}{localExposureData}
\usesdollar{clearCmdCompletely}{xdatabase}
\usesdollar{clearCmdCompletely}{CatOfCatDatabase}
\usesdollar{clearCmdCompletely}{DomOfCatDatabase}
\usesdollar{clearCmdCompletely}{JoinOfCatDatabase}
\usesdollar{clearCmdCompletely}{JoinOfDomDatabase}
\usesdollar{clearCmdCompletely}{attributeDb}
\usesdollar{clearCmdCompletely}{functionTable}
\usesdollar{clearCmdCompletely}{existingFiles}
\usesdollar{clearCmdCompletely}{localExposureDataDefault}
\begin{chunk}{defun clearCmdCompletely}
(defun |clearCmdCompletely| ()
  (declare (special |$localExposureData| |$xdatabase| |$CatOfCatDatabase|
    |$DomOfCatDatabase| |$JoinOfCatDatabase| |$JoinOfDomDatabase| 
    |$attributeDb| |$functionTable| |$existingFiles| 
    |$localExposureDataDefault|))
  (|clearCmdAll|)
  (setq |$localExposureData| (copy-seq |$localExposureDataDefault|))
  (setq |$xdatabase| nil)
  (setq |$CatOfCatDatabase| nil)
  (setq |$DomOfCatDatabase| nil)
  (setq |$JoinOfCatDatabase| nil)
  (setq |$JoinOfDomDatabase| nil)
  (setq |$attributeDb| nil)
  (setq |$functionTable| nil)
  (|sayKeyedMsg| "All )browse facility databases have been cleared." nil)
  (|clearClams|)
  (|clearConstructorCaches|)
  (setq |$existingFiles| (make-hash-table :test #'equal))
  (|sayKeyedMsg|
    "Internally cached functions and constructors have been cleared." nil)
  (reclaim)
  (|sayKeyedMsg| ")clear completely is finished." nil))

\end{chunk}

\defun{clearCmdAll}{clearCmdAll}
\calls{clearCmdAll}{clearCmdSortedCaches}
\calls{clearCmdAll}{untraceMapSubNames}
\calls{clearCmdAll}{resetInCoreHist}
\calls{clearCmdAll}{deleteFile}
\calls{clearCmdAll}{histFileName}
\calls{clearCmdAll}{updateCurrentInterpreterFrame}
\calls{clearCmdAll}{clearMacroTable}
\calls{clearCmdAll}{sayKeyedMsg}
\usesdollar{clearCmdAll}{frameRecord}
\usesdollar{clearCmdAll}{previousBindings}
\usesdollar{clearCmdAll}{variableNumberAlist}
\usesdollar{clearCmdAll}{InteractiveFrame}
\usesdollar{clearCmdAll}{useInternalHistoryTable}
\usesdollar{clearCmdAll}{internalHistoryTable}
\usesdollar{clearCmdAll}{frameMessages}
\usesdollar{clearCmdAll}{interpreterFrameName}
\usesdollar{clearCmdAll}{currentLine}
\usesdollar{clearCmdAll}{traceNames}
\begin{chunk}{defun clearCmdAll}
(defun |clearCmdAll| ()
  (declare (special |$frameRecord| |$previousBindings| |$variableNumberAlist|
     |$InteractiveFrame| |$useInternalHistoryTable| |$internalHistoryTable|
     |$frameMessages| |$interpreterFrameName| |$currentLine| |$traceNames|))
  (|clearCmdSortedCaches|)
  (setq |$frameRecord| nil)
  (setq |$previousBindings| nil)
  (setq |$variableNumberAlist| nil)
  (|untraceMapSubNames| |$traceNames|)
  (setq |$InteractiveFrame| (list (list nil)))
  (|resetInCoreHist|)
  (when |$useInternalHistoryTable| 
    (setq |$internalHistoryTable| nil)
   (|deleteFile| (|histFileName|)))
  (setq |$IOindex| 1)
  (|updateCurrentInterpreterFrame|)
  (setq |$currentLine| ")clear all")
  (|clearMacroTable|)
  (when |$frameMessages|
    (|sayKeyedMsg| 
     (format nil
       "All user variables and function definitions have been cleared in ~
        the current frame ( %1 ).")
      (list |$interpreterFrameName|))
    (|sayKeyedMsg|
      "All user variables and function definitions have been cleared." nil)))

\end{chunk}

\defun{clearMacroTable}{clearMacroTable}
\usesdollar{clearMacroTable}{pfMacros}
\begin{chunk}{defun clearMacroTable 0}
(defun |clearMacroTable| ()
  (declare (special |$pfMacros|))
  (setq |$pfMacros| nil))

\end{chunk}

\defun{clearCmdExcept}{clearCmdExcept}
Clear all the options except the argument.
\calls{clearCmdExcept}{stringPrefix?}
\calls{clearCmdExcept}{object2String}
\calls{clearCmdExcept}{clearCmdParts}
\usesdollar{clearCmdExcept}{clearOptions}
\begin{chunk}{defun clearCmdExcept}
(defun |clearCmdExcept| (arg)
 (let ((opt (car arg)) (vl (cdr arg)))
 (declare (special |$clearOptions|))
  (dolist (option |$clearOptions|)
   (unless (|stringPrefix?| (|object2String| opt) (|object2String| option))
    (|clearCmdParts| (cons option vl))))))

\end{chunk}

\defun{clearCmdParts}{clearCmdParts}
\calls{clearCmdParts}{selectOptionLC}
\calls{clearCmdParts}{pname}
\calls{clearCmdParts}{types}
\calls{clearCmdParts}{modes}
\calls{clearCmdParts}{values}
\calls{clearCmdParts}{boot-equal}
\calls{clearCmdParts}{assocleft}
\calls{clearCmdParts}{remdup}
\calls{clearCmdParts}{assoc}
\calls{clearCmdParts}{isMap}
\calls{clearCmdParts}{get}
\calls{clearCmdParts}{exit}
\calls{clearCmdParts}{untraceMapSubNames}
\calls{clearCmdParts}{seq}
\calls{clearCmdParts}{recordOldValue}
\calls{clearCmdParts}{recordNewValue}
\calls{clearCmdParts}{deleteAssoc}
\calls{clearCmdParts}{sayKeyedMsg}
\calls{clearCmdParts}{getParserMacroNames}
\calls{clearCmdParts}{getInterpMacroNames}
\calls{clearCmdParts}{clearDependencies}
\calls{clearCmdParts}{member}
\calls{clearCmdParts}{clearParserMacro}
\calls{clearCmdParts}{sayMessage}
\calls{clearCmdParts}{fixObjectForPrinting}
\usesdollar{clearCmdParts}{e}
\usesdollar{clearCmdParts}{InteractiveFrame}
\usesdollar{clearCmdParts}{clearOptions}
\begin{chunk}{defun clearCmdParts}
(defun |clearCmdParts| (arg)
 (let (|$e| (opt (car arg)) option pmacs imacs (vl (cdr arg)) p1 lm prop p2)
 (declare (special |$e| |$InteractiveFrame| |$clearOptions|))
  (setq option (|selectOptionLC| opt |$clearOptions| '|optionError|))
  (setq option (intern (pname option)))
  (setq option
   (case option
    (|types| '|mode|)
    (|modes| '|mode|)
    (|values| '|value|)
    (t option)))
  (if (null vl)
   (|sayKeyedMsg| 
    (format nil
     "After the property you wish to clear you must give one or more ~
      identifiers or specify all to clear that property from everything.")
     nil)
   (progn
    (setq pmacs (|getParserMacroNames|))
    (setq imacs (|getInterpMacroNames|))
    (cond
     ((boot-equal vl '(|all|))
      (setq vl (assocleft (caar |$InteractiveFrame|)))
      (setq vl (remdup (append vl pmacs)))))
    (setq |$e| |$InteractiveFrame|)
    (do ((t0 vl (cdr t0)) (x nil))
        ((or (atom t0) (progn (setq x (car t0)) nil)) nil)
      (|clearDependencies| x t)
      (when (and (eq option '|properties|) (|member| x pmacs))
        (|clearParserMacro| x))
      (when (and (eq option '|properties|) 
                 (|member| x imacs)
                 (null (|member| x pmacs)))
        (|sayMessage| (cons 
         "   You cannot clear the definition of the system-defined macro "
          (cons (|fixObjectForPrinting| x) 
                (cons (intern "." "BOOT") nil)))))
      (cond
       ((setq p1 (|assoc| x (caar |$InteractiveFrame|)))
        (cond
         ((eq option '|properties|)
          (cond
           ((|isMap| x)
            (seq
             (cond
              ((setq lm 
                (|get| x '|localModemap| |$InteractiveFrame|))
               (cond
                ((consp lm)
                (exit (|untraceMapSubNames| (cons (cadar lm) nil))))))
              (t nil)))))
          (dolist (p2 (cdr p1))
            (setq prop (car p2))
            (|recordOldValue| x prop (cdr p2))
            (|recordNewValue| x prop nil))
          (setf (caar |$InteractiveFrame|)
           (|deleteAssoc| x (caar |$InteractiveFrame|))))
         ((setq p2 (|assoc| option (cdr p1)))
          (|recordOldValue| x option (cdr p2))
          (|recordNewValue| x option nil)
          (rplacd p2 nil))))))
    nil))))

\end{chunk}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{close}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{close.help}
====================================================================
A.5.  )close
====================================================================
 
User Level Required:  interpreter
 
Command Syntax: 
 
  - )close
  - )close )quietly
 
Command Description: 
 
This command is used to close down interpreter client processes. Such
processes are started by HyperDoc to run AXIOM examples when you click on
their text. When you have finished examining or modifying the example and you
do not want the extra window around anymore, issue
 
)close
 
to the AXIOM prompt in the window.
 
If you try to close down the last remaining interpreter client process, AXIOM
will offer to close down the entire AXIOM session and return you to the
operating system by displaying something like
 
   This is the last AXIOM session. Do you want to kill AXIOM?
 
Type "y" (followed by the Return key) if this is what you had in mind. Type
"n" (followed by the Return key) to cancel the command.
 
You can use the )quietly option to force AXIOM to close down the interpreter
client process without closing down the entire AXIOM session.
 
Also See: 
o )quit
o )pquit
 
\end{chunk}
\footnote{
\fnref{quit}
\fnref{pquit}}

\defun{queryClients}{queryClients}
Returns the number of active scratchpad clients

\calls{queryClients}{sockSendInt}
\calls{queryClients}{sockGetInt}
\usesdollar{queryClients}{SessionManager}
\usesdollar{queryClients}{QueryClients}
\begin{chunk}{defun queryClients}
(defun |queryClients| ()
  (declare (special |$SessionManager| |$QueryClients|))
  (|sockSendInt| |$SessionManager| |$QueryClients|)
  (|sockGetInt| |$SessionManager|)) 

\end{chunk}

\defun{close}{close}
\calls{close}{throwKeyedMsg}
\calls{close}{sockSendInt}
\calls{close}{closeInterpreterFrame}
\calls{close}{selectOptionLC}
\calls{close}{upcase}
\calls{close}{queryUserKeyedMsg}
\calls{close}{string2id-n}
\calls{close}{queryClients}
\usesdollar{close}{SpadServer}
\usesdollar{close}{SessionManager}
\usesdollar{close}{CloseClient}
\usesdollar{close}{currentFrameNum}
\usesdollar{close}{options}
\begin{chunk}{defun close}
(defun |close| (args)
 (declare (ignore args))
 (let (numClients opt fullopt quiet x)
 (declare (special |$SpadServer| |$SessionManager| |$CloseClient|
     |$currentFrameNum| |$options|))
  (if (null |$SpadServer|) 
   (|throwKeyedMsg| "You cannot close this Axiom session." nil))
   (progn
    (setq numClients (|queryClients|))
    (cond
     ((> numClients 1)
       (|sockSendInt| |$SessionManager| |$CloseClient|)
       (|sockSendInt| |$SessionManager| |$currentFrameNum|)
       (|closeInterpreterFrame| nil))
     (t
      (do ((t0 |$options| (cdr t0)) (t1 nil))
          ((or (atom t0) 
               (progn (setq t1 (car t0)) nil)
               (progn (progn (setq opt (car t1)) t1) nil))
             nil)
       (setq fullopt (|selectOptionLC| opt '(|quiet|) '|optionError|))
       (unless quiet (setq quiet (eq fullopt '|quiet|))))
      (cond
       (quiet
        (|sockSendInt| |$SessionManager| |$CloseClient|)
        (|sockSendInt| |$SessionManager| |$currentFrameNum|)
        (|closeInterpreterFrame| nil))
       (t
        (setq x
         (upcase
          (|queryUserKeyedMsg| 
           "This is the last Axiom session.  Do you want to kill Axiom?"
           nil)))
        (when (member (string2id-n x 1) '(yes y)) (bye)))))))))

\end{chunk}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{compile}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{compile.help}
====================================================================
A.7.  )compile
====================================================================
 
User Level Required:  compiler
 
Command Syntax: 
 
  -  )compile
  -  )compile fileName
  -  )compile fileName.spad
  -  )compile directory/fileName.spad
  -  )compile fileName )quiet
  -  )compile fileName )noquiet
  -  )compile fileName )break
  -  )compile fileName )nobreak
  -  )compile fileName )library
  -  )compile fileName )nolibrary
  -  )compile fileName )vartrace
  -  )compile fileName )constructor nameOrAbbrev
 
Command Description: 
 
You use this command to invoke the AXIOM library compiler.  This
compiles files with file extension .spad with the AXIOM system
compiler. The command first looks in the standard system directories
for files with extension .spad.
 
Should you not want the )library command automatically invoked, call )compile
with the )nolibrary option. For example,
 
)compile mycode )nolibrary
 
By default, the )library system command exposes all domains and categories it
processes. This means that the AXIOM intepreter will consider those domains
and categories when it is trying to resolve a reference to a function.
Sometimes domains and categories should not be exposed. For example, a domain
may just be used privately by another domain and may not be meant for
top-level use. The )library command should still be used, though, so that the
code will be loaded on demand. In this case, you should use the )nolibrary
option on )compile and the )noexpose option in the )library command. For
example,
 
)compile mycode.spad )nolibrary
)library mycode )noexpose
 
Once you have established your own collection of compiled code, you may find
it handy to use the )dir option on the )library command. This causes )library
to process all compiled code in the specified directory. For example,
 
)library )dir /u/jones/as/quantum
 
You must give an explicit directory after )dir, even if you want all compiled
code in the current working directory processed.
 
)library )dir .
 
You can compile category, domain, and package constructors contained in files
with file extension .spad. You can compile individual constructors or every
constructor in a file.
 
The full filename is remembered between invocations of this command and )edit
commands. The sequence of commands
 
)compile matrix.spad
)edit
)compile
 
will call the compiler, edit, and then call the compiler again on the file
matrix.spad. If you do not specify a directory, the working current directory
(see description of command )cd ) is searched for the file. If the file is
not found, the standard system directories are searched.
 
If you do not give any options, all constructors within a file are compiled.
Each constructor should have an )abbreviation command in the file in which it
is defined. We suggest that you place the )abbreviation commands at the top
of the file in the order in which the constructors are defined. The list of
commands serves as a table of contents for the file.
 
The )library option causes directories containing the compiled code for each
constructor to be created in the working current directory. The name of such
a directory consists of the constructor abbreviation and the .NRLIB file
extension. For example, the directory containing the compiled code for the
MATRIX constructor is called MATRIX.NRLIB. The )nolibrary option says that
such files should not be created. 
 
The )vartrace option causes the compiler to generate extra code for the
constructor to support conditional tracing of variable assignments. (see
description of command )trace ). Without this option, this code is suppressed
and one cannot use the )vars option for the trace command.
 
The )constructor option is used to specify a particular constructor to
compile. All other constructors in the file are ignored. The constructor name
or abbreviation follows )constructor. Thus either
 
)compile matrix.spad )constructor RectangularMatrix
 
or
 
)compile matrix.spad )constructor RMATRIX
 
compiles the RectangularMatrix constructor defined in matrix.spad.
 
The )break and )nobreak options determine what the compiler does
when it encounters an error. )break is the default and it indicates that
processing should stop at the first error. The value of the )set break
variable then controls what happens.
 
Also See: 
o )abbreviation
o )edit
o )library

\end{chunk} 
\footnote{
\fnref{abbreviation}
\fnref{edit}
\fnref{library}}

\defvar{/editfile}
\begin{chunk}{initvars}
(defvar /editfile nil)

\end{chunk}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{copyright}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{copyright.help}
The term Axiom, in the field of computer algebra software, 
along with AXIOM and associated images are common-law 
trademarks. While the software license allows copies, the 
trademarks may only be used when referring to this project.

Axiom is distributed under terms of the Modified BSD license.
Axiom was released under this license as of September 3, 2002.
Source code is freely available at:
http://savannah.nongnu.org/projects/axiom
Copyrights remain with the original copyright holders.
Use of this material is by permission and/or license.
Individual files contain reference to these applicable copyrights.
The copyright and license statements are collected here for reference.

Portions Copyright (c) 2003- The Axiom Team

The Axiom Team is the collective name for the people who have
contributed to this project. Where no other copyright statement
is noted in a file this copyright will apply. 

Portions Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    - Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    - Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in
      the documentation and/or other materials provided with the
      distribution.

    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Portions Copyright (C) 1989-95 GROUPE BULL

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of GROUPE BULL shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from GROUPE BULL.

Portions Copyright (C) 2002, Codemist Ltd.  All rights reserved.
acn@codemist.co.uk


                         CCL Public License 1.0
                         ======================

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions 
are met:

(1) Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer. 

(2) Redistributions in binary form must reproduce the above copyright
notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution. 

(3) Neither the name of Codemist nor the names of other contributors may 
be used to endorse or promote products derived from this software without
specific prior written permission. 

(4) If you distribute a modified form or either source or binary code 
  (a) you must make the source form of these modification available 
      to Codemist;
  (b) you grant Codemist a royalty-free license to use, modify
      or redistribute your modifications without limitation;
  (c) you represent that you are legally entitled to grant these rights 
      and that you are not providing Codemist with any code that violates
      any law or breaches any contract.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED 
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Portions Copyright (C) 1995-1997 Eric Young (eay@mincom.oz.au)
All rights reserved.

This package is an SSL implementation written
by Eric Young (eay@mincom.oz.au).
The implementation was written so as to conform with Netscapes SSL.
 
This library is free for commercial and non-commercial use as long as
the following conditions are aheared to.  The following conditions
apply to all code found in this distribution, be it the RC4, RSA,
lhash, DES, etc., code; not just the SSL code.  The SSL documentation
included with this distribution is covered by the same copyright terms
except that the holder is Tim Hudson (tjh@mincom.oz.au).
 
Copyright remains Eric Young's, and as such any Copyright notices in
the code are not to be removed.
If this package is used in a product, Eric Young should be given attribution
as the author of the parts of the library used.
This can be in the form of a textual message at program startup or
in documentation (online or textual) provided with the package.
 
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
1. Redistributions of source code must retain the copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. All advertising materials mentioning features or use of this software
   must display the following acknowledgement:
   "This product includes cryptographic software written by
    Eric Young (eay@mincom.oz.au)"
   The word 'cryptographic' can be left out if the rouines from the library
   being used are not cryptographic related :-).
4. If you include any Windows specific code (or a derivative thereof) from 
   the apps directory (application code) you must include an acknowledgement:
   "This product includes software written by Tim Hudson (tjh@mincom.oz.au)"

THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

The licence and distribution terms for any publically available version or
derivative of this code cannot be changed.  i.e. this code cannot simply be
copied and put under another distribution licence
[including the GNU Public Licence.]

Portions Copyright (C) 1988 by Leslie Lamport.

Portions Copyright (c) 1998 Free Software Foundation, Inc.      
                                                                         
Permission is hereby granted, free of charge, to any person obtaining a  
copy of this software and associated documentation files (the            
"Software"), to deal in the Software without restriction, including      
without limitation the rights to use, copy, modify, merge, publish,      
distribute, distribute with modifications, sublicense, and/or sell       
copies of the Software, and to permit persons to whom the Software is    
furnished to do so, subject to the following conditions:                 
                                                                         
The above copyright notice and this permission notice shall be included  
in all copies or substantial portions of the Software.                   
                                                                         
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   
IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    
THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               
                                                                         
Except as contained in this notice, the name(s) of the above copyright   
holders shall not be used in advertising or otherwise to promote the     
sale, use or other dealings in this Software without prior written       
authorization.                                                           

Portions Copyright 1989-2000 by Norman Ramsey.  All rights reserved.

Noweb is protected by copyright.  It is not public-domain
software or shareware, and it is not protected by a ``copyleft''
agreement like the one used by the Free Software Foundation.

Noweb is available free for any use in any field of endeavor.  You may
redistribute noweb in whole or in part provided you acknowledge its
source and include this COPYRIGHT file.  You may modify noweb and
create derived works, provided you retain this copyright notice, but
the result may not be called noweb without my written consent.  

You may sell noweb if you wish.  For example, you may sell a CD-ROM
including noweb.  

You may sell a derived work, provided that all source code for your
derived work is available, at no additional charge, to anyone who buys
your derived work in any form.  You must give permisson for said
source code to be used and modified under the terms of this license.
You must state clearly that your work uses or is based on noweb and
that noweb is available free of change.  You must also request that
bug reports on your work be reported to you.

Portions Copyright (c) 1987 The RAND Corporation.  All rights reserved.

Portions Copyright 1988-1995 by Stichting Mathematisch Centrum, Amsterdam, The
Netherlands.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the names of Stichting Mathematisch
Centrum or CWI not be used in advertising or publicity pertaining to
distribution of the software without specific, written prior permission.

STICHTING MATHEMATISCH CENTRUM DISCLAIMS ALL WARRANTIES WITH REGARD TO
THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS, IN NO EVENT SHALL STICHTING MATHEMATISCH CENTRUM BE LIABLE
FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

Portions Copyright (c) Renaud Rioboo and the University Paris 6.

Portions Copyright (c) 2003-2010 Jocelyn Guidry

Portions Copyright (c) 2001-2010 Timothy Daly

\end{chunk}
\defun{copyright}{copyright}
\calls{copyright}{obey}
\calls{copyright}{concat}
\calls{copyright}{getenviron}
\begin{chunk}{defun copyright}
(defun |copyright| ()
 (obey (concat "cat " (getenviron "AXIOM") "/doc/spadhelp/copyright.help")))

\end{chunk}
\defun{trademark}{trademark}
\begin{chunk}{defun trademark 0}
(defun |trademark| ()
 (format t "The term Axiom, in the field of computer algebra software, ~%")
 (format t "along with AXIOM and associated images are common-law ~%")
 (format t "trademarks. While the software license allows copies, the ~%")
 (format t "trademarks may only be used when referring to this project ~%"))

\end{chunk}

This command is in the list of \verb|$noParseCommands|
\ref{noParseCommands} which means that its arguments are passed
verbatim. This will eventually result in a call to the function
\verb|handleNoParseCommands| \ref{handleNoParseCommands}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{credits}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defun{credits}{credits}
\uses{credits}{credits}
\begin{chunk}{defun credits 0}
(defun |credits| ()
 (declare (special credits))
 (mapcar #'(lambda (x) (princ x) (terpri)) creditlist))

\end{chunk}

This command is in the list of \verb|$noParseCommands|
\ref{noParseCommands} which means that its arguments are passed
verbatim. This will eventually result in a call to the function
\verb|handleNoParseCommands| \ref{handleNoParseCommands}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{describe}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{describe.help}
====================================================================
  )describe
====================================================================
 
User Level Required:  interpreter
 
Command Syntax: 
 
  -  )describe categoryName
  -  )describe domainName
  -  )describe packageName
 
Command Description: 
 
This command is used to display the comments for the operation, category,
domain or package. The comments are part of the algebra source code.
 
The commands
 
)describe <categoryName> [internal]
)describe <domainName>   [internal]
)describe <packageName>  [internal]
 
will show a properly formatted version of the "Description:" keyword
from the comments in the algebra source for the category, domain,
or package requested. 

If 'internal' is requested, then the internal format of the domain or 
package is described. Categories do not have an internal representation.
 
\end{chunk} 

\defdollar{describeOptions}
The current value of \$describeOptions is
\begin{chunk}{initvars}
(defvar $describeOptions '(|category| |domain| |package|))

\end{chunk}

\defun{describe}{Print comment strings from algebra libraries}
This trivial function satisfies the standard pattern of making a
user command match the name of the function which implements the
command. That command immediatly invokes a ``Spad2Cmd'' version.
\calls{describe}{describespad2cmd}
\begin{chunk}{defun describe}
(defun |describe| (l)
 (describeSpad2Cmd l)) 

\end{chunk}

\defun{describeSpad2Cmd}{describeSpad2Cmd}
The describe command prints cleaned-up comment strings from the algebra
libraries. It can print strings associated with a category, domain, package,
or by operation.

This implements command line options of the form:
\begin{verbatim}
  )describe categoryName [internal]
  )describe domainName   [internal]
  )describe packageName  [internal]
\end{verbatim}
The describeInternal function will either call the ``dc'' function
to describe the internal representation of the argument or it will
print a cleaned up version of the text for the "Description" keyword
in the Category, Domain, or Package source code.

\calls{describeSpad2Cmd}{selectOptionLC}
\calls{describeSpad2Cmd}{flatten}
\calls{describeSpad2Cmd}{cleanline}
\calls{describeSpad2Cmd}{getdatabase}
\calls{describeSpad2Cmd}{sayMessage}
\usesdollar{describeSpad2Cmd}{e}
\usesdollar{describeSpad2Cmd}{EmptyEnvironment}
\usesdollar{describeSpad2Cmd}{describeOptions}
\begin{chunk}{defun describeSpad2Cmd}
(defun describeSpad2Cmd (l)
 (labels (
  (fullname (arg)
   "Convert abbreviations to the full constructor name"
   (let ((abb (getdatabase arg 'abbreviation)))
    (if abb arg (getdatabase arg 'constructor))))
  (describeInternal (cdp internal?)
   (if internal?
    (progn
     (unless (eq (getdatabase cdp 'constructorkind) '|category|) (|dc| cdp))
     (showdatabase cdp))
    (mapcar #'(lambda (x) (if (stringp x) (cleanline x)))
     (flatten  (car (getdatabase (fullname cdp) 'documentation)))))))
 (let ((|$e| |$EmptyEnvironment|) (opt (second l)))
  (declare (special |$e| |$EmptyEnvironment| $describeOptions))
  (if (and (consp l) (not (eq opt '?)))
    (describeInternal (first l) (second l))
   (|sayMessage|
    (format nil "~&~a ~{~%    ~a~^ ~}~%    ~a" 
     "  )describe keyword arguments are"
     $describeOptions
     "or abbreviations thereof"))))))

\end{chunk}

\defun{cleanline}{cleanline}
\begin{chunk}{defun cleanline}
(defun cleanline (line)
 (labels (
   (replaceInLine (thing other line)
    (do ((mark (search thing line) (search thing line)))
        ((null mark) line)
     (setq line
      (concatenate 'string (subseq line 0 mark) other
                           (subseq line (+ mark (length thing)))))))

   (removeFromLine (thing line) (replaceInLine thing "" line))

   (removeKeyword (str line)
    (do ((mark (search str line) (search str line)))
     ((null mark) line)
     (let (left point mid right)
      (setq left (subseq line 0 mark))
      (setq point (search "}" line :start2 mark))
      (setq mid (subseq line (+ mark (length str)) point))
      (setq right (subseq line (+ point 1)))
      (setq line (concatenate 'string left mid right)))))

   (addSpaces (str line)
    (do ((mark (search str line) (search str line)) (cnt))
     ((null mark) line)
     (let (left point mid right)
      (setq left (subseq line 0 mark))
      (setq point (search "}" line :start2 mark))
      (setq mid (subseq line (+ mark (length str)) point))
      (if (setq cnt (parse-integer mid :junk-allowed t))
        (setq mid (make-string cnt :initial-element #\ ))
        (setq mid ""))
      (setq right (subseq line (+ point 1)))
      (setq line (concatenate 'string left mid right)))))

   (splitAtNewline (line) 
    (do ((mark (search "~%" line) (search "~%" line)) (lines))
        ((null mark) 
          (push " " lines)
          (push line lines)
          (nreverse lines))
      (push (subseq line 0 mark) lines)
      (setq line (subseq line (+ mark 2)))))

   (wrapOneLine (line margin result) 
    (if (null line) 
      (nreverse result)
      (if (< (length line) margin)
        (wrapOneLine nil margin (append (list line) result))
        (let (oneline spill aspace)
         (setq aspace (position #\space (subseq line 0 margin) :from-end t))
         (setq oneline (string-trim '(#\space) (subseq line 0 aspace)))
         (setq spill (string-trim '(#\space) (subseq line aspace)))
         (wrapOneLine spill margin (append (list oneline) result))))))

   (reflowParagraph (line) 
    (let (lst1)
     (setq lst1 (splitAtNewLine line))
     (dolist (x lst1)
      (mapcar #'(lambda(y) (format t "~a~%" y))
       (wrapOneLine x 70 nil))))))

 (setq line (removeFromLine "{}" line))
 (setq line (replaceInLine "\\blankline" "~%~%" line))
 (setq line (replaceInLine "\\br" "~%" line))
 (setq line (removeFromLine "\\" line))
 (dolist (str '("spad{" "spadtype{" "spadop{" "spadfun{" "spadatt{"
                "axiom{" "axiomType{" "spadignore{" "axiomFun{"
                "centerline{" "inputbitmap{" "axiomOp{" "spadgloss{"))
  (setq line (removeKeyword str line)))
 (setq line (replaceInLine "{e.g.}" "e.g." line))
 (dolist (str '("tab{" "indented{" ))
   (setq line (addSpaces str line)))
  (reflowParagraph line)))

\end{chunk}

\defun{flatten}{flatten}
\begin{chunk}{defun flatten 0}
(defun flatten (x)
 (labels (
  (rec (x acc)
   (cond
    ((null x) acc)
    ((atom x) (cons x acc))
    (t (rec (car x) (rec (cdr x) acc))))))
  (rec x nil)))

\end{chunk}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{display}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{display.help}
====================================================================
A.8.  )display
====================================================================
 
User Level Required:  interpreter
 
Command Syntax: 
 
  -  )display all
  -  )display properties
  -  )display properties all
  -  )display properties [obj1 [obj2 ...] ]
  -  )display value all
  -  )display value [obj1 [obj2 ...] ]
  -  )display mode all
  -  )display mode [obj1 [obj2 ...] ]
  -  )display names
  -  )display operations opName
 
Command Description: 
 
This command is used to display the contents of the workspace and signatures
of functions with a given name. (A signature gives the argument and return
types of a function.) 
 
The command
 
)display names
 
lists the names of all user-defined objects in the workspace. This is useful
if you do not wish to see everything about the objects and need only be
reminded of their names.
 
The commands
 
)display all
)display properties
)display properties all
 
all do the same thing: show the values and types and declared modes of all
variables in the workspace. If you have defined functions, their signatures
and definitions will also be displayed.
 
To show all information about a particular variable or user functions, for
example, something named d, issue
 
)display properties d
 
To just show the value (and the type) of d, issue
 
)display value d
 
To just show the declared mode of d, issue
 
)display mode d
 
All modemaps for a given operation may be displayed by using )display
operations. A modemap is a collection of information about a particular
reference to an operation. This includes the types of the arguments and the
return value, the location of the implementation and any conditions on the
types. The modemap may contain patterns. The following displays the modemaps
for the operation FromcomplexComplexCategory:
 
)d op complex
 
Also See: 
o )clear
o )history
o )set
o )show
o )what
 
\end{chunk} 
\footnote{
\fnref{clear}
\fnref{history}
\fnref{set}
\fnref{show}
\fnref{what}}

\defdollar{displayOptions}
The current value of \$displayOptions is
\begin{chunk}{initvars}
(defvar |$displayOptions| 
 '(|abbreviations| |all| |macros| |modes| |names| |operations| 
   |properties| |types| |values|))

\end{chunk}

\defun{display}{display}
This trivial function satisfies the standard pattern of making a
user command match the name of the function which implements the
command. That command immediatly invokes a ``Spad2Cmd'' version.
\calls{display}{displayspad2cmd}
\begin{chunk}{defun display}
(defun |display| (l)
 (displaySpad2Cmd l)) 

\end{chunk}

\subsection{displaySpad2Cmd}
We process the options to the command and call the appropriate
display function. There are really only 4 display functions.
All of the other options are just subcases.

There is a slight mismatch between the \$displayOptions list of
symbols and the options this command accepts so we have a cond
branch to clean up the option variable. This allows for the options
to be plural.

If we fall all the way thru we use the \$displayOptions list
to construct a list of strings for the sayMessage function
and tell the user what options are available.
\calls{displaySpad2Cmd}{abbQuery}
\calls{displaySpad2Cmd}{opOf}
\calls{displaySpad2Cmd}{listConstructorAbbreviations}
\calls{displaySpad2Cmd}{displayOperations}
\calls{displaySpad2Cmd}{displayMacros}
\calls{displaySpad2Cmd}{displayWorkspaceNames}
\calls{displaySpad2Cmd}{displayProperties}
\calls{displaySpad2Cmd}{selectOptionLC}
\calls{displaySpad2Cmd}{sayMessage}
\usesdollar{displaySpad2Cmd}{e}
\usesdollar{displaySpad2Cmd}{EmptyEnvironment}
\usesdollar{displaySpad2Cmd}{displayOptions}
\begin{chunk}{defun displaySpad2Cmd}
(defun displaySpad2Cmd (l)
 (let ((|$e| |$EmptyEnvironment|) (opt (car l)) (vl (cdr l)) option)
  (declare (special |$e| |$EmptyEnvironment| |$displayOptions|))
  (if (and (consp l) (not (eq opt '?)))
   (progn
    (setq option (|selectOptionLC| opt |$displayOptions| '|optionError|))
    (cond
     ((eq option '|all|)
       (setq l (list '|properties|))
       (setq option '|properties|))
     ((or (eq option '|modes|) (eq option '|types|))
       (setq l (cons '|type| vl))
       (setq option '|type|))
     ((eq option '|values|)
       (setq l (cons '|value| vl))
       (setq option '|value|)))
    (cond 
     ((eq option '|abbreviations|)
      (if (null vl)
        (|listConstructorAbbreviations|)
        (dolist (v vl) (|abbQuery| (|opOf| v)))))
     ((eq option '|operations|) (|displayOperations| vl))
     ((eq option '|macros|) (|displayMacros| vl))
     ((eq option '|names|) (|displayWorkspaceNames|))
     (t (|displayProperties| option l))))
   (|sayMessage|
    (append 
      '("  )display keyword arguments are")
      (mapcar #'(lambda (x) (format nil "~%     ~a" x)) |$displayOptions|)
      (format nil "~%  or abbreviations thereof"))))))

\end{chunk}

\defun{abbQuery}{abbQuery}
\calls{abbQuery}{getdatabase}
\calls{abbQuery}{sayKeyedMsg}
\begin{chunk}{defun abbQuery}
(defun |abbQuery| (x)
 (let (abb)
  (cond
   ((setq abb (getdatabase x 'abbreviation))
    (|sayKeyedMsg| "%1 abbreviates %2 %3"
     (list abb (getdatabase x 'constructorkind) x)))
   ((setq abb (getdatabase x 'constructor))
    (|sayKeyedMsg| "%1 abbreviates %2 %3"
      (list x (getdatabase abb 'constructorkind) abb)))
   (t
     (|sayKeyedMsg|
      "%1 is neither a constructor name nor a constructor abbreviation."
      (list x))))))

\end{chunk}
\defun{displayOperations}{displayOperations}
This function takes a list of operation names. If the list is null
we query the user to see if they want all operations printed. Otherwise
we print the information for the requested symbols.

\calls{displayOperations}{reportOpSymbol}
\calls{displayOperations}{yesanswer}
\calls{displayOperations}{sayKeyedMsg}
\begin{chunk}{defun displayOperations}
(defun |displayOperations| (l)
 (if l
  (dolist (op l) (|reportOpSymbol| op))
  (if (yesanswer)
   (dolist (op (|allOperations|)) (|reportOpSymbol| op))
   (|sayKeyedMsg| 
    (format nil
     "Since you did not respond with y or yes the list of operations will ~
      not be displayed.")
     nil))))

\end{chunk}
\defun{yesanswer}{yesanswer}
This is a trivial function to simplify the logic of displaySpad2Cmd.
If the user didn't supply an argument to the )display op command
we ask if they wish to have all information about all Axiom operations
displayed. If the answer is either Y or YES we return true else nil.

\calls{yesanswer}{string2id-n}
\calls{yesanswer}{upcase}
\calls{yesanswer}{queryUserKeyedMsg}
\begin{chunk}{defun yesanswer}
(defun yesanswer ()
 (member
  (string2id-n
   (upcase
    (|queryUserKeyedMsg|
     (format nil
      "You have requested that all information about all Axiom operations ~
       (functions) be displayed.  As there are several hundred operations, ~
       please confirm your request by typing y or yes and then pressing ~
       Enter :")
      nil)) 1) '(y yes)))

\end{chunk}

\defun{displayMacros}{displayMacros}
\calls{displayMacros}{getInterpMacroNames}
\calls{displayMacros}{getParserMacroNames}
\calls{displayMacros}{remdup}
\calls{displayMacros}{sayBrightly}
\calls{displayMacros}{member}
\calls{displayMacros}{displayParserMacro}
\calls{displayMacros}{seq}
\calls{displayMacros}{exit}
\calls{displayMacros}{displayMacro}
\begin{chunk}{defun displayMacros}
(defun |displayMacros| (names)
 (let (imacs pmacs macros first)
  (setq imacs (|getInterpMacroNames|))
  (setq pmacs (|getParserMacroNames|))
  (if names
    (setq macros names)
    (setq macros (append imacs pmacs)))
  (setq macros (remdup macros))
  (cond
   ((null macros) (|sayBrightly| "   There are no Axiom macros."))
   (t
     (setq first t)
     (do ((t0 macros (cdr t0)) (macro nil))
         ((or (atom t0) (progn (setq macro (car t0)) nil)) nil)
      (seq
       (exit
        (cond
         ((|member| macro pmacs)
           (cond
            (first (|sayBrightly|
             (cons '|%l| (cons "User-defined macros:" nil))) (setq first nil)))
           (|displayParserMacro| macro))
         ((|member| macro imacs) '|iterate|)
         (t (|sayBrightly|
          (cons "   "
            (cons macro
              (cons " is not a known Axiom macro." nil)))))))))
     (setq first t)
     (do ((t1 macros (cdr t1)) (macro nil))
         ((or (atom t1) (progn (setq macro (car t1)) nil)) nil)
      (seq
       (exit
        (cond
         ((|member| macro imacs)
           (cond
            ((|member| macro pmacs) '|iterate|)
            (t 
             (cond
              (first
               (|sayBrightly|
                (cons '|%l|
                 (cons "System-defined macros:" nil))) (setq first nil)))
             (|displayMacro| macro))))
         ((|member| macro pmacs) '|iterate|)))))
     nil)))) 

\end{chunk}

\defun{sayExample}{sayExample}
This function expects 2 arguments, the documentation string and
the name of the operation. It searches the documentation string for
\verb|++X| lines. These lines are examples lines for functions. 
They look like ordinary \verb|++| comments and fit into the ordinary
comment blocks. So, for example, in the plot.spad.pamphlet file we
find the following function signature:
\begin{verbatim}
    plot: (F -> F,R) -> %
      ++ plot(f,a..b) plots the function \spad{f(x)} 
      ++ on the interval \spad{[a,b]}.
      ++ 
      ++X fp:=(t:DFLOAT):DFLOAT +-> sin(t)
      ++X plot(fp,-1.0..1.0)$PLOT
\end{verbatim}
This function splits out and prints the lines that begin with \verb|++X|.

A minor complication of printing the examples is that the lines have
been processed into internal compiler format. Thus the lines that read:
\begin{verbatim}
      ++X fp:=(t:DFLOAT):DFLOAT +-> sin(t)
      ++X plot(fp,-1.0..1.0)$PLOT
\end{verbatim}
are actually stored as one long line containing the example lines
\begin{verbatim}
"\\indented{1}{plot(\\spad{f},{}a..\\spad{b}) plots the function
 \\spad{f(x)}} \\indented{1}{on the interval \\spad{[a,{}b]}.}
 \\blankline
 \\spad{X} fp:=(t:DFLOAT):DFLOAT +-> sin(\\spad{t})
 \\spad{X} plot(\\spad{fp},{}\\spad{-1}.0..1.0)\\$PLOT"
\end{verbatim}

So when we have an example line starting with ++X, it gets
converted to the compiler to \verb|\spad{X}|. So each 
example line is delimited by \verb|\spad{X}|. 

The compiler also removes the newlines so
if there is a subsequent \verb|\spad{X}| in the docstring
then it implies multiple example lines and we loop over them, 
splitting them up at the delimiter.

If there is only one then we clean it up and print it.

\calls{sayexample}{cleanupline}
\calls{sayexample}{sayNewLine}
\begin{chunk}{defun sayExample}
(defun sayExample (docstring)
 (let (line point)
  (when (setq point (search "spad{X}" docstring))
   (setq line (subseq docstring (+ point 8)))
   (do ((mark (search "spad{X}" line) (search "spad{X}" line)))
     ((null mark))
    (princ (cleanupLine (subseq line 0 mark)))
    (terpri)
    (setq line (subseq line (+ mark 8))))
   (princ (cleanupLine line))
   (terpri)
   (terpri))))

\end{chunk}

\defun{cleanupLine}{cleanupLine}
This function expects example lines in internal format that has been
partially processed to remove the prefix. Thus we get lines that look 
like:
\begin{verbatim}
 fp:=(t:DFLOAT):DFLOAT +-> sin(\\spad{t}) 
 plot(\\spad{fp},{}\\spad{-1}.0..1.0)\\$PLOT
\end{verbatim}

It removes all instances of \verb|{}|, and \verb|\|, and unwraps the
\verb|spad{}| call, leaving only the argument.

We return lines that look like:
\begin{verbatim}
 fp:=(t:DFLOAT):DFLOAT +-> sin(t)
 plot(fp,-1.0..1.0)$PLOT
\end{verbatim}
which is hopefully exactly what the user wrote.

The compiler inserts \verb|{}| as a space so we remove it.
We remove all of the \verb|\| characters.
We remove all of the \verb|spad{...}| delimiters which will
occur around other spad variables. Technically we should
search recursively for the matching delimiter rather than the
next brace but the problem does not arise in practice.
\begin{chunk}{defun cleanupLine 0}
(defun cleanupLine (line)
 (do ((mark (search "{}" line) (search "{}" line)))
  ((null mark))
  (setq line
   (concatenate 'string (subseq line 0 mark) (subseq line (+ mark 2)))))
 (do ((mark (search "\\" line) (search "\\" line)))
  ((null mark))
  (setq line
   (concatenate 'string (subseq line 0 mark) (subseq line (+ mark 1)))))
 ; split out \spad{...}
 (do ((mark (search "spad{" line) (search "spad{" line)))
  ((null mark))
  (let (left point mid right)
   (setq left (subseq line 0 mark))
   (setq point (search "}" line :start2 mark))
   (setq mid (subseq line (+ mark 5) point))
   (setq right (subseq line (+ point 1)))
   (setq line (concatenate 'string left mid right))))
 ; split out \spadtype{...}
 (do ((mark (search "spadtype{" line) (search "spadtype{" line)))
  ((null mark))
  (let (left point mid right)
   (setq left (subseq line 0 mark))
   (setq point (search "}" line :start2 mark))
   (setq mid (subseq line (+ mark 9) point))
   (setq right (subseq line (+ point 1)))
   (setq line (concatenate 'string left mid right))))
 line)

\end{chunk}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{edit}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{edit.help}
====================================================================
A.9.  )edit
====================================================================
 
User Level Required:  interpreter
 
Command Syntax: 
 
  - )edit [filename]
 
Command Description: 
 
This command is used to edit files. It works in conjunction with the )read
and )compile commands to remember the name of the file on which you are
working. By specifying the name fully, you can edit any file you wish. Thus
 
)edit /u/julius/matrix.input
 
will place you in an editor looking at the file /u/julius/matrix.input. By
default, the editor is vi, but if you have an EDITOR shell environment
variable defined, that editor will be used. When AXIOM is running under the X
Window System, it will try to open a separate xterm running your editor if it
thinks one is necessary. For example, under the Korn shell, if you issue
 
export EDITOR=emacs
 
then the emacs editor will be used by )edit.
 
If you do not specify a file name, the last file you edited, read or compiled
will be used. If there is no ``last file'' you will be placed in the editor
editing an empty unnamed file.
 
It is possible to use the )system command to edit a file directly. For
example,
 
)system emacs /etc/rc.tcpip
 
calls emacs to edit the file.
 
Also See: 
o )system
o )compile
o )read
 
\end{chunk} 
\footnote{
\fnref{system}
\fnref{read}}

\defun{edit}{edit}
\calls{edit}{editSpad2Cmd}
\begin{chunk}{defun edit}
(defun |edit| (l) (|editSpad2Cmd| l)) 

\end{chunk}

\defun{editSpad2Cmd}{editSpad2Cmd}
\calls{editSpad2Cmd}{pathname}
\calls{editSpad2Cmd}{pathnameDirectory}
\calls{editSpad2Cmd}{pathnameType}
\callsdollar{editSpad2Cmd}{FINDFILE}
\calls{editSpad2Cmd}{pathnameName}
\calls{editSpad2Cmd}{editFile}
\calls{editSpad2Cmd}{updateSourceFiles}
\uses{editSpad2Cmd}{/editfile}
\begin{chunk}{defun editSpad2Cmd}
(defun |editSpad2Cmd| (l)
 (let (olddir filetypes ll rc)
 (declare (special /editfile))
    (setq l (cond ((null l) /editfile) (t (car l))))
    (setq l (|pathname| l))
    (setq olddir (|pathnameDirectory| l))
    (setq filetypes
     (cond 
      ((|pathnameType| l) (list (|pathnameType| l)))
      ((eq |$UserLevel| '|interpreter|) '("input" "INPUT" "spad" "SPAD"))
      ((eq |$UserLevel| '|compiler|) '("input" "INPUT" "spad" "SPAD"))
      (t '("input" "INPUT" "spad" "SPAD" "boot" "BOOT" 
           "lisp" "LISP" "meta" "META"))))
    (setq ll
     (cond
      ((string= olddir "")
        (|pathname| ($findfile (|pathnameName| l) filetypes)))
      (t l)))
    (setq l (|pathname| ll))
    (setq /editfile l)
    (setq rc (|editFile| l))
    (|updateSourceFiles| l)
    rc))

\end{chunk}

\defun{editFile}{Implement the )edit command}
\calls{editFile}{concat}
\calls{editFile}{namestring}
\calls{editFile}{pathname}
\calls{editFile}{obey}
\begin{chunk}{defun editFile}
(defun |editFile| (file)
 (cond
  ((member (intern "WIN32" (find-package 'keyword)) *features*)
   (obey (concat "notepad " (|namestring| (|pathname| file)))))
  (t
   (obey
    (concat "$AXIOM/lib/SPADEDIT " (|namestring| (|pathname| file)))))))

\end{chunk}

\subsubsection{The SPADEDIT command}
Axiom execute a shell script called SPADEDIT to open a file using
the user's chosen editor. That editor name is, by convention, in
the EDITOR shell variable. If that variable is not set we default
to the 'vi' editor. 
\begin{chunk}{spadedit}
#!/bin/sh
# this script is invoked by the spad )edit command
# can be replaced by users favorite editor
# optional second argument should be character offset in file

thefile=$1
if [ ! -f $1 ] ; then 
  thefile=$AXIOM/../../src/algebra/$1
else
  thefile=$1
fi


if [ $# = 2 ] ; then
	START=`grep -n \^$2\( $thefile | awk -F: '{print $1}'`
else
	START=1
fi

if [ ! "$EDITOR" ] ; then
	EDITOR=vi
fi

if [ "$DISPLAY" ] ; then
	if [ "$EDITOR" = "emacs" ] ; then
		emacs  +$START $thefile &
	elif [ "$EDITOR" = "vi" ] ; then
		xterm -e vi +$START $thefile &
        else
		xterm -e $EDITOR $thefile &
	fi
else
	$EDITOR $thefile
fi
\end{chunk}

\defun{updateSourceFiles}{updateSourceFiles}
\calls{updateSourceFiles}{pathname}
\calls{updateSourceFiles}{pathnameName}
\calls{updateSourceFiles}{pathnameType}
\calls{updateSourceFiles}{makeInputFilename}
\calls{updateSourceFiles}{member}
\calls{updateSourceFiles}{pathnameTypeId}
\calls{updateSourceFiles}{insert}
\usesdollar{updateSourceFiles}{sourceFiles}
\begin{chunk}{defun updateSourceFiles}
(defun |updateSourceFiles| (arg)
 (declare (special |$sourceFiles|))
  (setq arg (|pathname| arg))
  (setq arg (|pathname| (list (|pathnameName| arg) (|pathnameType| arg) "*")))
  (when (and (makeInputFilename arg)
             (|member| (|pathnameTypeId| arg) '(boot lisp meta)))
   (setq |$sourceFiles| (|insert| arg |$sourceFiles|)))
  arg)

\end{chunk}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{fin}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{fin.help}
====================================================================
A.10.  )fin
====================================================================
 
User Level Required:  development
 
Command Syntax: 
 
  -  )fin
 
Command Description: 
 
This command is used by AXIOM developers to leave the AXIOM system and return
to the underlying Lisp system. To return to AXIOM, issue the ``(spad)''
function call to Lisp.
 
Also See: 
o )pquit
o )quit
 
\end{chunk} 
\footnote{
\fnref{pquit}
\fnref{quit}}

\defun{fin}{Exit from the interpreter to lisp}
\throws{fin}{spad-reader}
\uses{fin}{eof}
\begin{chunk}{defun fin 0}
(defun |fin| ()
 (setq *eof* t)
 (throw 'spad_reader nil))

\end{chunk}

This command is in the list of \verb|$noParseCommands|
\ref{noParseCommands} which means that its arguments are passed
verbatim. This will eventually result in a call to the function
\verb|handleNoParseCommands| \ref{handleNoParseCommands}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{help}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{help.help}
====================================================================
A.12.  )help
====================================================================
 
User Level Required:  interpreter
 
Command Syntax: 
 
  - )help
  - )help commandName
  - )help syntax
 
Command Description: 
 
This command displays help information about system commands. If you issue
 
)help
 
then this very text will be shown. You can also give the name or abbreviation
of a system command to display information about it. For example,
 
)help clear
 
will display the description of the )clear system command.

The command 

)help syntax

will give further information about the Axiom language syntax.
 
All this material is available in the AXIOM User Guide and in HyperDoc. In
HyperDoc, choose the Commands item from the Reference menu.
 
====================================================================
A.1.  Introduction
====================================================================
 
 
System commands are used to perform AXIOM environment management. Among the
commands are those that display what has been defined or computed, set up
multiple logical AXIOM environments (frames), clear definitions, read files
of expressions and commands, show what functions are available, and terminate
AXIOM.
 
Some commands are restricted: the commands
 
)set userlevel interpreter
)set userlevel compiler
)set userlevel development
 
set the user-access level to the three possible choices. All commands are
available at development level and the fewest are available at interpreter
level. The default user-level is interpreter. In addition to the )set command
(discussed in description of command )set ) you can use the HyperDoc settings
facility to change the user-level. Click on [Settings] here to immediately go
to the settings facility. 
 
Each command listing begins with one or more syntax pattern descriptions plus
examples of related commands. The syntax descriptions are intended to be easy
to read and do not necessarily represent the most compact way of specifying
all possible arguments and options; the descriptions may occasionally be
redundant.
 
All system commands begin with a right parenthesis which should be in the
first available column of the input line (that is, immediately after the
input prompt, if any). System commands may be issued directly to AXIOM or be
included in .input files.
 
A system command argument is a word that directly follows the command name
and is not followed or preceded by a right parenthesis. A system command
option follows the system command and is directly preceded by a right
parenthesis. Options may have arguments: they directly follow the option.
This example may make it easier to remember what is an option and what is an
argument:
 
         )syscmd arg1 arg2 )opt1 opt1arg1 opt1arg2 )opt2 opt2arg1 ...
 
In the system command descriptions, optional arguments and options are
enclosed in brackets (``['' and ``]''). If an argument or option name is in
italics, it is meant to be a variable and must have some actual value
substituted for it when the system command call is made. For example, the
syntax pattern description
 
)read fileName [)quietly]
 
would imply that you must provide an actual file name for fileName but need
not use the )quietly option. Thus
 
)read matrix.input
 
is a valid instance of the above pattern.
 
System command names and options may be abbreviated and may be in upper or
lower case. The case of actual arguments may be significant, depending on the
particular situation (such as in file names). System command names and
options may be abbreviated to the minimum number of starting letters so that
the name or option is unique. Thus
 
)s Integer
 
is not a valid abbreviation for the )set command, because both )set and )show
begin with the letter ``s''. Typically, two or three letters are sufficient
for disambiguating names. In our descriptions of the commands, we have used
no abbreviations for either command names or options.
 
In some syntax descriptions we use a vertical line ``|'' to indicate that you
must specify one of the listed choices. For example, in
 
)set output fortran on | off
 
only on and off are acceptable words for following boot. We also sometimes
use ``...'' to indicate that additional arguments or options of the listed
form are allowed. Finally, in the syntax descriptions we may also list the
syntax of related commands.

====================================================================
Other help topics
====================================================================
Available help topics are: 

abbreviations assignment blocks     browse     boot       cd
clear         clef       close      collection compile    describe
display       edit       fin        for        frame      help       
history       if         iterate    leave      library    lisp       
load          ltrace     parallel   pquit      quit       read       
repeat        savesystem set        show       spool      suchthat   
synonym       system     syntax     trace      undo       what       
while

Available algebra help topics are:

\end{chunk} 

\defunsec{help}{The top level help command}
\calls{help}{helpSpad2Cmd}
\begin{chunk}{defun help}
(defun |help| (l)
 "The top level help command"
 (|helpSpad2Cmd| l)) 

\end{chunk}

\defunsec{helpSpad2Cmd}{The top level help command handler}
\calls{helpSpad2Cmd}{newHelpSpad2Cmd}
\calls{helpSpad2Cmd}{sayKeyedMsg}
\begin{chunk}{defun helpSpad2Cmd}
(defun |helpSpad2Cmd| (args)
 "The top level help command handler"
 (unless (|newHelpSpad2Cmd| args)
  (|sayKeyedMsg| 
   (format nil
    "If the system command or synonym %1 exists, help information is not ~
     available for it. Issue )what commands or )what synonyms to ~
     determine is %1 is a valid name.")
   (cons args nil))))

\end{chunk}

\defun{newHelpSpad2Cmd}{newHelpSpad2Cmd}
\calls{newHelpSpad2Cmd}{makeInputFilename}
\calls{newHelpSpad2Cmd}{obey}
\calls{newHelpSpad2Cmd}{concat}
\calls{newHelpSpad2Cmd}{namestring}
\calls{newHelpSpad2Cmd}{make-instream}
\calls{newHelpSpad2Cmd}{say}
\calls{newHelpSpad2Cmd}{abbreviation?}
\calls{newHelpSpad2Cmd}{poundsign}
\calls{newHelpSpad2Cmd}{sayKeyedMsg}
\calls{newHelpSpad2Cmd}{pname}
\calls{newHelpSpad2Cmd}{selectOptionLC}
\usesdollar{newHelpSpad2Cmd}{syscommands}
\usesdollar{newHelpSpad2Cmd}{useFullScreenHelp}
\begin{chunk}{defun newHelpSpad2Cmd}
(defun |newHelpSpad2Cmd| (args)
 (let (sarg arg narg helpfile filestream line unabbrev)
 (declare (special $syscommands |$useFullScreenHelp|))
  (when (null args) (setq args (list '?)))
  (if (> (|#| args) 1) 
   (|sayKeyedMsg| "The )help system command supports at most one argument."
    nil)
   (progn
    (setq sarg (pname (car args)))
    (cond
     ((string= sarg "?") (setq args (list '|help|)))
     ((string= sarg "%") (setq args (list '|history|)))
     ((string= sarg "%%") (setq args (list '|history|)))
     (t nil))
    (setq arg (|selectOptionLC| (car args) $syscommands nil))
    (cond ((null arg) (setq arg (car args))))
    (setq narg (pname arg))
    ; expand abbreviations to full constructor names
    (when 
     (setq unabbrev (|abbreviation?| (intern narg)))
      (setq narg (symbol-name unabbrev)))
    (setq narg (substitute #\q #\? narg))
    (cond
      ; if the help file does not exist, exit
     ((null (setq helpfile (makeInputFilename (list narg "help"))))
       nil)
      ; if we expect to use full screen help, call SPADEDIT
     (|$useFullScreenHelp|
      (obey (concat "$AXIOM/lib/SPADEDIT " (|namestring| helpfile))) t)
      ; otherwise dump the help file to the console
     (t
      (setq filestream (make-instream helpfile))
      (do ((line (|read-line| filestream nil) (|read-line| filestream nil)))
          ((null line) (shut filestream))
       (say line))))))))

\end{chunk}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{history}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{history.help}
====================================================================
A.13.  )history
====================================================================
 
User Level Required:  interpreter
 
Command Syntax: 
 
  - )history )on
  - )history )off
  - )history )write historyInputFileName
  - )history )show [n] [both]
  - )history )save savedHistoryName
  - )history )restore [savedHistoryName]
  - )history )reset
  - )history )change n
  - )history )memory
  - )history )file
  - %
  - %%(n)
  - )set history on | off
 
Command Description: 
 
The history facility within AXIOM allows you to restore your environment to
that of another session and recall previous computational results. Additional
commands allow you to review previous input lines and to create an .input
file of the lines typed to AXIOM.
 
AXIOM saves your input and output if the history facility is turned on (which
is the default). This information is saved if either of
 
)set history on
)history )on
 
has been issued. Issuing either
 
)set history off
)history )off
 
will discontinue the recording of information.
 
Whether the facility is disabled or not, the value of % in AXIOM always
refers to the result of the last computation. If you have not yet entered
anything, % evaluates to an object of type Variable('%). The function %% may
be used to refer to other previous results if the history facility is
enabled. In that case, %%(n) is the output from step n if n > 0. If n < 0,
the step is computed relative to the current step. Thus %%(-1) is also the
previous step, %%(-2), is the step before that, and so on. If an invalid step
number is given, AXIOM will signal an error.
 
The environment information can either be saved in a file or entirely in
memory (the default). Each frame ( description of command )frame ) has its
own history database. When it is kept in a file, some of it may also be kept
in memory for efficiency. When the information is saved in a file, the name
of the file is of the form FRAME.axh where ``FRAME'' is the name of the
current frame. The history file is placed in the current working directory
(see description of command )cd ). Note that these history database files are
not text files (in fact, they are directories themselves), and so are not in
human-readable format.
 
The options to the )history command are as follows:
 
  )change n
    will set the number of steps that are saved in memory to n. This option
    only has effect when the history data is maintained in a file. If you
    have issued )history )memory (or not changed the default) there is no
    need to use )history )change.
 
  )on
    will start the recording of information. If the workspace is not empty,
    you will be asked to confirm this request. If you do so, the workspace
    will be cleared and history data will begin being saved. You can also
    turn the facility on by issuing )set history on.
 
  )off
    will stop the recording of information. The )history )show command will
    not work after issuing this command. Note that this command may be issued
    to save time, as there is some performance penalty paid for saving the
    environment data. You can also turn the facility off by issuing )set
    history off.
 
  )file
    indicates that history data should be saved in an external file on disk.
 
  )memory
    indicates that all history data should be kept in memory rather than
    saved in a file. Note that if you are computing with very large objects
    it may not be practical to kept this data in memory.
 
  )reset
    will flush the internal list of the most recent workspace calculations so
    that the data structures may be garbage collected by the underlying Lisp
    system. Like )history )change, this option only has real effect when
    history data is being saved in a file.
 
  )restore [savedHistoryName]
    completely clears the environment and restores it to a saved session, if
    possible. The )save option below allows you to save a session to a file
    with a given name. If you had issued )history )save jacobi the command
    )history )restore jacobi would clear the current workspace and load the
    contents of the named saved session. If no saved session name is
    specified, the system looks for a file called last.axh.
 
  )save savedHistoryName
    is used to save a snapshot of the environment in a file. This file is
    placed in the current working directory (see description of command )cd
    ). Use )history )restore to restore the environment to the state
    preserved in the file. This option also creates an input file containing
    all the lines of input since you created the workspace frame (for
    example, by starting your AXIOM session) or last did a )clear all or
    )clear completely.
 
  )show [n] [both]
    can show previous input lines and output results. )show will display up
    to twenty of the last input lines (fewer if you haven't typed in twenty
    lines). )show n will display up to n of the last input lines. )show both
    will display up to five of the last input lines and output results. )show
    n both will display up to n of the last input lines and output results.
 
  )write historyInputFile
    creates an .input file with the input lines typed since the start of the
    session/frame or the last )clear all or )clear completely. If
    historyInputFileName does not contain a period (``.'') in the filename,
    .input is appended to it. For example, )history )write chaos and )history
    )write chaos.input both write the input lines to a file called
    chaos.input in your current working directory. If you issued one or more
    )undo commands, )history )write eliminates all input lines backtracked
    over as a result of )undo. You can edit this file and then use )read to
    have AXIOM process the contents.
 
Also See: 
o )frame
o )read
o )set
o )undo
 
\end{chunk} 
\footnote{
\fnref{frame}
\fnref{read}
\fnref{set}
\fnref{undo}}

History recording is done in two different ways:
\begin{itemize}
\item all changes in variable bindings (i.e. previous values) are
written to \verb|$HistList|, which is a circular list
\item all new bindings (including the binding to \verb|%|) are written to a
file called histFileName()
one older session is accessible via the file \verb|$oldHistFileName()|
\end{itemize}

\section{Initialized history variables}
The following global variables are used:
\begin{list}{}
\item \verb|$HistList|, \verb|$HistListLen| and \verb|$HistListAct| 
       which is the actual number of ``undoable'' steps)
\item \verb|$HistRecord| collects the input line, all variable bindings
      and the output of a step, before it is written to the file
      histFileName().
\item \verb|$HiFiAccess| is a flag, which is reset by )history )off
\end{list}

The result of step n can be accessed by \verb|%n|, which is translated
into a call of fetchOutput(n). The updateHist is called after every
interpreter step. The putHist function records all changes in the
environment to \verb|$HistList| and \verb|$HistRecord|.
 
\defdollar{oldHistoryFileName}
\begin{chunk}{initvars}
(defvar |$oldHistoryFileName| '|last| "vm/370 filename name component")

\end{chunk}
\defdollar{historyFileType}
\begin{chunk}{initvars}
(defvar |$historyFileType| '|axh|     "vm/370 filename type component")

\end{chunk}
\defdollar{historyDirectory}
\begin{chunk}{initvars}
(defvar |$historyDirectory| 'A        "vm/370 filename disk component")

\end{chunk}
\defdollar{useInternalHistoryTable}
\begin{chunk}{initvars}
(defvar |$useInternalHistoryTable| t  "t means keep history in core")

\end{chunk}

\defun{makeHistFileName}{makeHistFileName}
\calls{makeHistFileName}{makePathname}
\begin{chunk}{defun makeHistFileName}
(defun |makeHistFileName| (fname) 
 (|makePathname| fname |$historyFileType| |$historyDirectory|)) 

\end{chunk} 
\defun{oldHistFileName}{oldHistFileName}
\calls{oldHistFileName}{makeHistFileName}
\usesdollar{oldHistFileName}{oldHistoryFileName}
\begin{chunk}{defun oldHistFileName}
(defun |oldHistFileName| ()
 (declare (special |$oldHistoryFileName|))
 (|makeHistFileName| |$oldHistoryFileName|))

\end{chunk}
\defun{histFileName}{histFileName}
\calls{histFileName}{makeHistFileName}
\usesdollar{histFileName}{interpreterFrameName}
\begin{chunk}{defun histFileName}
(defun |histFileName| () 
 (declare (special |$interpreterFrameName|))
 (|makeHistFileName| |$interpreterFrameName|)) 

\end{chunk}
\defun{histInputFileName}{histInputFileName}
\calls{histInputFileName}{makePathname}
\usesdollar{histInputFileName}{interpreterFrameName}
\usesdollar{histInputFileName}{historyDirectory}
\begin{chunk}{defun histInputFileName}
(defun |histInputFileName| (fn)
 (declare (special |$interpreterFrameName| |$historyDirectory|))
 (if (null fn)
   (|makePathname| |$interpreterFrameName| 'input |$historyDirectory|)
   (|makePathname| fn 'input |$historyDirectory|)))

\end{chunk}

\defun{initHist}{initHist}
\calls{initHist}{initHistList}
\calls{initHist}{oldHistFileName}
\calls{initHist}{histFileName}
\calls{initHist}{histFileErase}
\calls{initHist}{makeInputFilename}
\callsdollar{initHist}{replace}
\usesdollar{initHist}{useInternalHistoryTable}
\usesdollar{initHist}{HiFiAccess}
\begin{chunk}{defun initHist}
(defun |initHist| ()
 (let (oldFile newFile)
 (declare (special |$useInternalHistoryTable| |$HiFiAccess|))
   (if |$useInternalHistoryTable| 
     (|initHistList|)
     (progn
       (setq oldFile (|oldHistFileName|))
       (setq newFile (|histFileName|))
       (|histFileErase| oldFile)
       (when (makeInputFilename newFile) (replaceFile oldFile newFile))
       (setq |$HiFiAccess| t)
       (|initHistList|)))))
 
\end{chunk}
\defun{initHistList}{initHistList}
\usesdollar{initHistList}{HistListLen}
\usesdollar{initHistList}{HistList}
\usesdollar{initHistList}{HistListAct}
\usesdollar{initHistList}{HistRecord}
\begin{chunk}{defun initHistList}
(defun |initHistList| () 
 (let (li) 
 (declare (special |$HistListLen| |$HistList| |$HistListAct| |$HistRecord|))
   (setq |$HistListLen| 20) 
   (setq |$HistList| (list nil)) 
   (setq li |$HistList|) 
   (do ((i 1 (1+ i))) 
       ((> i |$HistListLen|) nil) 
     (setq li (cons nil li)))
   (rplacd |$HistList| li) 
   (setq |$HistListAct| 0) 
   (setq |$HistRecord| nil)))
 
\end{chunk}
\defunsec{history}{The top level history command}
\calls{history}{sayKeyedMsg}
\calls{history}{historySpad2Cmd}
\usesdollar{history}{options}
\begin{chunk}{defun history}
(defun |history| (l) 
 "The top level history command"
 (declare (special |$options|))
 (if (or l (null |$options|)) 
  (|sayKeyedMsg|
   (format nil
    "You have not used the correct syntax for the history command. ~
     Issue )help history for more information.")
    nil)
  (|historySpad2Cmd|)))

\end{chunk}
\defunsec{historySpad2Cmd}{The top level history command handler}
\calls{historySpad2Cmd}{selectOptionLC}
\calls{historySpad2Cmd}{member}
\calls{historySpad2Cmd}{sayKeyedMsg}
\calls{historySpad2Cmd}{initHistList}
\calls{historySpad2Cmd}{upcase}
\calls{historySpad2Cmd}{queryUserKeyedMsg}
\calls{historySpad2Cmd}{string2id-n}
\calls{historySpad2Cmd}{histFileErase}
\calls{historySpad2Cmd}{histFileName}
\calls{historySpad2Cmd}{clearSpad2Cmd}
\calls{historySpad2Cmd}{disableHist}
\calls{historySpad2Cmd}{setHistoryCore}
\calls{historySpad2Cmd}{resetInCoreHist}
\calls{historySpad2Cmd}{saveHistory}
\calls{historySpad2Cmd}{showHistory}
\calls{historySpad2Cmd}{changeHistListLen}
\calls{historySpad2Cmd}{restoreHistory}
\calls{historySpad2Cmd}{writeInputLines}
\calls{historySpad2Cmd}{seq}
\calls{historySpad2Cmd}{exit}
\usesdollar{historySpad2Cmd}{options}
\usesdollar{historySpad2Cmd}{HiFiAccess}
\usesdollar{historySpad2Cmd}{IOindex}
\begin{chunk}{defun historySpad2Cmd}
(defun |historySpad2Cmd| () 
 "The top level history command handler"
 (let (histOptions opts opt optargs x) 
 (declare (special |$options| |$HiFiAccess| |$IOindex|))
  (setq histOptions 
    '(|on| |off| |yes| |no| |change| |reset| |restore| |write| 
      |save| |show| |file| |memory|)) 
  (setq opts 
   (prog (tmp1) 
     (setq tmp1 nil) 
     (return 
      (do ((tmp2 |$options| (cdr tmp2)) (tmp3 nil))
          ((or (atom tmp2) 
               (progn 
                 (setq tmp3 (car tmp2)) 
                 nil) 
               (progn 
                (progn 
                 (setq opt (car tmp3)) 
                 (setq optargs (cdr tmp3)) 
                 tmp3) 
                nil))
             (nreverse0 tmp1))
         (setq tmp1 
          (cons 
            (cons 
              (|selectOptionLC| opt histOptions '|optionError|)
              optargs)
            tmp1))))))
  (do ((tmp4 opts (cdr tmp4)) (tmp5 nil))
      ((or (atom tmp4) 
           (progn 
             (setq tmp5 (car tmp4))
              nil) 
           (progn 
            (progn 
             (setq opt (car tmp5)) 
             (setq optargs (cdr tmp5)) 
             tmp5) 
            nil))
        nil)
    (seq 
     (exit 
      (cond 
       ((|member| opt '(|on| |yes|))
          (cond 
           (|$HiFiAccess| 
             (|sayKeyedMsg| "The history facility is already on." nil))
           ((eql |$IOindex| 1) 
             (setq |$HiFiAccess| t)
             (|initHistList|)
             (|sayKeyedMsg| "The history facility is now on." nil))
           (t 
             (setq x ; really want to turn history on?
               (upcase
                (|queryUserKeyedMsg| 
                 (format nil
                  "Turning on the history facility will clear the contents ~
                   of the workspace. Please enter y or yes if you really ~
                   want to do this:")
                  nil)))
             (cond 
              ((member (string2id-n x 1) '(Y YES)) 
                (|histFileErase| (|histFileName|)) 
                (setq |$HiFiAccess| t)
                (setq |$options| nil) 
                (|clearSpad2Cmd| '(|all|))
                (|sayKeyedMsg| "The history facility is now on." nil)
                (|initHistList|)) 
              (t 
                (|sayKeyedMsg| "The history facility is still off." nil))))))
       ((|member| opt '(|off| |no|)) 
         (cond 
          ((null |$HiFiAccess|) 
            (|sayKeyedMsg| "The history facility is already off." nil))
          (t 
            (setq |$HiFiAccess| nil) 
            (|disableHist|) 
            (|sayKeyedMsg| "The history facility is now off." nil))))
       ((eq opt '|file|)    (|setHistoryCore| nil)) 
       ((eq opt '|memory|)  (|setHistoryCore| t)) 
       ((eq opt '|reset|)   (|resetInCoreHist|)) 
       ((eq opt '|save|)    (|saveHistory| optargs)) 
       ((eq opt '|show|)    (|showHistory| optargs)) 
       ((eq opt '|change|)  (|changeHistListLen| (car optargs))) 
       ((eq opt '|restore|) (|restoreHistory| optargs)) 
       ((eq opt '|write|)   (|writeInputLines| optargs 1)))))) 
  '|done|))

\end{chunk} 

\defun{showHistory}{showHistory}
\calls{showHistory}{sayKeyedMsg}
\calls{showHistory}{selectOptionLC}
\calls{showHistory}{sayMSG}
\calls{showHistory}{concat}
\calls{showHistory}{bright}
\calls{showHistory}{showInOut}
\calls{showHistory}{setIOindex}
\calls{showHistory}{showInput}
\usesdollar{showHistory}{printTimeSum}
\usesdollar{showHistory}{evalTimePrint}
\begin{chunk}{defun showHistory}
(defun |showHistory| (arg)
 (let (|$printTimeSum| |$evalTimePrint| maxi mini arg2 arg1
            nset n showInputOrBoth)
  (declare (special |$printTimeSum| |$evalTimePrint| |$HiFiAccess|))
  (setq |$evalTimePrint| 0)
  (setq |$printTimeSum| 0)
  (cond
    ((null |$HiFiAccess|)
     (|sayKeyedMsg|
      (format nil
       "The history facility command %1 cannot be performed because the ~
        history facility is not on.")
        (list '|show|)))
    (t
      (setq showInputOrBoth '|input|)
      (setq n 20)
      (when arg
        (setq arg1 (car arg))
        (when (integerp arg1)
          (setq n arg1)
          (setq nset t)
          (cond
            ((ifcdr arg) (setq arg1 (cadr arg)))
            (t (setq arg1 nil))))
        (when arg1
          (setq arg2 (|selectOptionLC| arg1 '(|input| |both|) nil))
          (cond
            (arg2
              (cond
                ((and (eq (setq showInputOrBoth arg2) '|both|)
                      (null nset))
                  (setq n 5))))
            (t
              (|sayMSG|
               (|concat| "  " (|bright| arg1)  "is an invalid argument."))))))
      (cond ((not (< n |$IOindex|)) (setq n (- |$IOindex| 1))))
      (setq mini (- |$IOindex| n))
      (setq maxi (- |$IOindex| 1))
      (cond
        ((eq showInputOrBoth '|both|)
          (unwind-protect
            (|showInOut| mini maxi)
            (|setIOindex| (+ maxi 1))))
        (t (|showInput| mini maxi)))))))
\end{chunk}

\defun{setHistoryCore}{setHistoryCore}
We case on the inCore argument value
\begin{list}{}
\item If history is already on and is kept in the same location as requested
(file or memory) then complain.
\item If history is not in use then start using the file or memory as 
requested. This is done by simply setting the \verb|$useInternalHistoryTable|
to the requested value, where T means use memory and NIL means
use a file. We tell the user.
\item If history should be in memory, that is inCore is not NIL,
and the history file already contains information we read the information
from the file, store it in memory, and erase the history file. We modify
\verb|$useInternalHistoryTable| to T to indicate that we're maintining
the history in memory and tell the user.
\item Otherwise history must be on and in memory. We erase any old history
file and then write the in-memory history to a new file
\end{list}
\calls{setHistoryCore}{boot-equal}
\calls{setHistoryCore}{sayKeyedMsg}
\calls{setHistoryCore}{rkeyids}
\calls{setHistoryCore}{histFileName}
\calls{setHistoryCore}{readHiFi}
\calls{setHistoryCore}{disableHist}
\calls{setHistoryCore}{histFileErase}
\calls{setHistoryCore}{rdefiostream}
\calls{setHistoryCore}{spadrwrite}
\calls{setHistoryCore}{object2Identifier}
\calls{setHistoryCore}{rshut}
\usesdollar{setHistoryCore}{useInternalHistoryTable}
\usesdollar{setHistoryCore}{internalHistoryTable}
\usesdollar{setHistoryCore}{HiFiAccess}
\usesdollar{setHistoryCore}{IOindex}
\begin{chunk}{defun setHistoryCore}
(defun |setHistoryCore| (inCore) 
 (let (l vec str n rec) 
 (declare (special |$useInternalHistoryTable| |$internalHistoryTable|
     |$HiFiAccess| |$IOindex|))
  (cond 
   ((boot-equal inCore |$useInternalHistoryTable|) 
     (if inCore 
        (|sayKeyedMsg| 
         (format nil
          "History information is already being maintained in memory (and ~
           not in an external file).")
          nil)
        (|sayKeyedMsg| 
         (format nil
          "History information is already being maintained in an external ~
           file (and not in memory).")
         nil))) ; file history already in use
   ((null |$HiFiAccess|) 
     (setq |$useInternalHistoryTable| inCore) 
     (if inCore 
        (|sayKeyedMsg|
         (format nil
          "When the history facility is active, history information will be ~
            maintained in memory (and not in an external file).")
          nil)
        (|sayKeyedMsg|
           (format nil
            "When the history facility is active, history information will be ~
             maintained in a file (and not in an internal table).")
         nil)))
   (inCore 
     (setq |$internalHistoryTable| nil) 
     (cond 
      ((not (eql |$IOindex| 0))
        (setq l (length (rkeyids (|histFileName|)))) 
        (do ((i 1 (1+ i)))
            ((> i l) nil)
          (setq vec (unwind-protect (|readHiFi| i) (|disableHist|)))
          (setq |$internalHistoryTable| 
            (cons (cons i vec) |$internalHistoryTable|)))
        (|histFileErase| (|histFileName|)))) 
     (setq |$useInternalHistoryTable| t) 
     (|sayKeyedMsg|
      (format nil
       "When the history facility is active, history information will be ~
        maintained in memory (and not in an external file).")
       nil))
   (t 
     (setq |$HiFiAccess| nil)
     (|histFileErase| (|histFileName|))
     (setq str 
      (rdefiostream 
       (cons 
         '(mode . output) 
          (cons
            (cons 'file (|histFileName|))
             nil))))
     (do ((tmp0 (reverse |$internalHistoryTable|) (cdr tmp0))
          (tmp1 nil))
         ((or (atom tmp0) 
              (progn 
                (setq tmp1 (car tmp0))
                nil) 
              (progn 
               (progn 
                (setq n (car tmp1))
                (setq rec (cdr tmp1))
                tmp1) 
               nil)) 
              nil)
       (spadrwrite (|object2Identifier| n) rec str))
     (rshut str)
     (setq |$HiFiAccess| t)
     (setq |$internalHistoryTable| nil)
     (setq |$useInternalHistoryTable| nil)
     (|sayKeyedMsg|
      (format nil
       "When the history facility is active, history information will be ~
        maintained in a file (and not in an internal table).")
      nil)))))

\end{chunk}
\defdollar{underbar}
Also used in the output routines.
\begin{chunk}{initvars}
(defvar underbar "_")

\end{chunk}

\defun{writeInputLines}{writeInputLines}
\calls{writeInputLines}{sayKeyedMsg}
\calls{writeInputLines}{throwKeyedMsg}
\calls{writeInputLines}{size}
\calls{writeInputLines}{concat}
\calls{writeInputLines}{substring}
\calls{writeInputLines}{readHiFi}
\calls{writeInputLines}{histInputFileName}
\calls{writeInputLines}{histFileErase}
\calls{writeInputLines}{defiostream}
\calls{writeInputLines}{namestring}
\calls{writeInputLines}{shut}
\uses{writeInputLines}{underbar}
\usesdollar{writeInputLines}{HiFiAccess}
\usesdollar{writeInputLines}{IOindex}
\begin{chunk}{defun writeInputLines}
(defun |writeInputLines| (fn initial) 
 (let (maxn breakChars vecl k svec done n lineList file inp) 
 (declare (special underbar |$HiFiAccess| |$IOindex|))
  (cond 
   ((null |$HiFiAccess|)
    (|sayKeyedMsg|
     (format nil 
      "The history facility is not on, so the .input file containing your ~
       user input cannot be created.")
      nil)) 
   ((null fn)
    (|throwKeyedMsg| 
      "You must specify a file name to the history write command" nil))
   (t 
     (setq maxn 72)
     (setq breakChars (cons '| | (cons '+ nil)))
     (do ((tmp0 (- |$IOindex| 1))
          (i initial (+ i 1)))
         ((> i tmp0) nil)
       (setq vecl (car (|readHiFi| i)))
       (when (stringp vecl) (setq vecl (cons vecl nil)))
       (dolist (vec vecl)
         (setq n (size vec))
         (do () 
             ((null (> n maxn)) nil) 
             (setq done nil)
             (do ((j 1 (1+ j)))
                 ((or (> j maxn) (null (null done))) nil)
               (setq k (- (1+ maxn) j))
               (when (member (elt vec k) breakChars)
                 (setq svec (concat (substring vec 0 (1+ k)) underbar))
                 (setq lineList (cons svec lineList))
                 (setq done t)
                 (setq vec (substring vec (1+ k) nil))
                 (setq n (size vec))))
             (when done (setq n 0)))
         (setq lineList (cons vec lineList))))
     (setq file (|histInputFileName| fn))
     (|histFileErase| file)
     (setq inp 
      (defiostream 
       (cons 
        '(mode . output) 
        (cons (cons 'file file) nil)) 255 0))
     (dolist (x (|removeUndoLines| (nreverse lineList)))
       (write-line x inp))
     (cond 
      ((not (eq fn '|redo|))
        (|sayKeyedMsg| "Edit %1 to see the saved input lines."
          (list (|namestring| file)))))
     (shut inp)
     nil))))

\end{chunk} 
\defun{resetInCoreHist}{resetInCoreHist}
\usesdollar{resetInCoreHist}{HistListAct}
\usesdollar{resetInCoreHist}{HistListLen}
\usesdollar{resetInCoreHist}{HistList}
\begin{chunk}{defun resetInCoreHist}
(defun |resetInCoreHist| () 
 (declare (special |$HistListAct| |$HistListLen| |$HistList|))
 (setq |$HistListAct| 0) 
 (do ((i 1 (1+ i)))
     ((> i |$HistListLen|) nil)
   (setq |$HistList| (cdr |$HistList|))
   (rplaca |$HistList| nil)))

\end{chunk}
\defun{changeHistListLen}{changeHistListLen}
\calls{changeHistListLen}{sayKeyedMsg}
\usesdollar{changeHistListLen}{HistListLen}
\usesdollar{changeHistListLen}{HistList}
\usesdollar{changeHistListLen}{HistListAct}
\begin{chunk}{defun changeHistListLen}
(defun |changeHistListLen| (n)
 (let (dif l) 
 (declare (special |$HistListLen| |$HistList| |$HistListAct|))
 (if (null (integerp n)) 
   (|sayKeyedMsg| 
    (format nil
     "The argument n for )history )change n must be a nonnegative integer ~
      and your argument, %1 , is not one.")
     (list n)) ; only positive integers
   (progn
     (setq dif (- n |$HistListLen|))
     (setq |$HistListLen| n) 
     (setq l (cdr |$HistList|)) 
     (cond 
      ((> dif 0) 
        (do ((i 1 (1+ i)))
            ((> i dif) nil)
           (setq l (cons nil l))))
      ((minusp dif)
        (do ((tmp0 (- dif)) 
             (i 1 (1+ i)))
            ((> i tmp0) nil)
           (setq l (cdr l)))
        (cond
         ((> |$HistListAct| n) (setq |$HistListAct| n))
         (t nil))))
     (rplacd |$HistList| l) 
     '|done|))))

\end{chunk}
\defun{updateHist}{updateHist}
\calls{updateHist}{startTimingProcess}
\calls{updateHist}{updateInCoreHist}
\calls{updateHist}{writeHiFi}
\calls{updateHist}{disableHist}
\calls{updateHist}{updateCurrentInterpreterFrame}
\calls{updateHist}{stopTimingProcess}
\usesdollar{updateHist}{IOindex}
\usesdollar{updateHist}{HiFiAccess}
\usesdollar{updateHist}{HistRecord}
\usesdollar{updateHist}{mkTestInputStack}
\usesdollar{updateHist}{currentLine}
\begin{chunk}{defun updateHist}
(defun |updateHist| () 
 (declare (special |$IOindex| |$HiFiAccess| |$HistRecord| |$mkTestInputStack|
   |$currentLine|))
 (when |$IOindex|
   (|startTimingProcess| '|history|)
   (|updateInCoreHist|)
   (when |$HiFiAccess| 
      (unwind-protect (|writeHiFi|) (|disableHist|))
      (setq |$HistRecord| nil))
   (incf |$IOindex|)
   (|updateCurrentInterpreterFrame|)
   (setq |$mkTestInputStack| nil)
   (setq |$currentLine| nil)
   (|stopTimingProcess| '|history|)))

\end{chunk}
\defun{updateInCoreHist}{updateInCoreHist}
\usesdollar{updateInCoreHist}{HistList}
\usesdollar{updateInCoreHist}{HistListLen}
\usesdollar{updateInCoreHist}{HistListAct}
\begin{chunk}{defun updateInCoreHist}
(defun |updateInCoreHist| ()
 (declare (special |$HistList| |$HistListLen| |$HistListAct|))
  (setq |$HistList| (cdr |$HistList|))
  (rplaca |$HistList| nil) 
  (when (> |$HistListLen| |$HistListAct|) 
    (setq |$HistListAct| (1+ |$HistListAct|))))

\end{chunk}
\defun{putHist}{putHist}
\calls{putHist}{recordOldValue}
\calls{putHist}{get}
\calls{putHist}{recordNewValue}
\calls{putHist}{putIntSymTab}
\usesdollar{putHist}{HiFiAccess}
\begin{chunk}{defun putHist}
(defun |putHist| (x prop val e)
  (declare (special |$HiFiAccess|))
  (when (null (eq x '%)) (|recordOldValue| x prop (|get| x prop e)))
  (when |$HiFiAccess| (|recordNewValue| x prop val))
  (|putIntSymTab| x prop val e))

\end{chunk}
\defun{recordNewValue}{recordNewValue}
\calls{recordNewValue}{startTimingProcess}
\calls{recordNewValue}{recordNewValue0}
\calls{recordNewValue}{stopTimingProcess}
\begin{chunk}{defun recordNewValue}
(defun |recordNewValue| (x prop val)
  (|startTimingProcess| '|history|)
  (|recordNewValue0| x prop val)
  (|stopTimingProcess| '|history|))

\end{chunk}
\defun{recordNewValue0}{recordNewValue0}
\calls{recordNewValue0}{assq}
\usesdollar{recordNewValue0}{HistRecord}
\begin{chunk}{defun recordNewValue0}
(defun |recordNewValue0| (x prop val)
 (let (p1 p2 p)
 (declare (special |$HistRecord|))
   (if (setq p1 (assq x |$HistRecord|))
    (if (setq p2 (assq prop (cdr p1))) 
      (rplacd p2 val)
      (rplacd p1 (cons (cons prop val) (cdr p1))))
    (progn
      (setq p (cons x (list (cons prop val))))
      (setq |$HistRecord| (cons p |$HistRecord|))))))

\end{chunk}
\defun{recordOldValue}{recordOldValue}
\calls{recordOldValue}{startTimingProcess}
\calls{recordOldValue}{recordOldValue0}
\calls{recordOldValue}{stopTimingProcess}
\calls{recordOldValue0}{assq}
\begin{chunk}{defun recordOldValue}
(defun |recordOldValue| (x prop val)
  (|startTimingProcess| '|history|)
  (|recordOldValue0| x prop val)
  (|stopTimingProcess| '|history|))

\end{chunk}
\defun{recordOldValue0}{recordOldValue0}
\usesdollar{recordOldValue0}{HistList}
\begin{chunk}{defun recordOldValue0}
(defun |recordOldValue0| (x prop val)
 (let (p1 p)
 (declare (special |$HistList|))
 (when (setq p1 (assq x (car |$HistList|)))
   (when (null (assq prop (cdr p1)))
      (rplacd p1 (cons (cons prop val) (cdr p1)))))
 (setq p (cons x (list (cons prop val))))
 (rplaca |$HistList| (cons p (car |$HistList|)))))

\end{chunk}
\defun{undoInCore}{undoInCore}
\calls{undoInCore}{undoChanges}
\calls{undoInCore}{readHiFi}
\calls{undoInCore}{disableHist}
\calls{undoInCore}{assq}
\calls{undoInCore}{sayKeyedMsg}
\calls{undoInCore}{putHist}
\calls{undoInCore}{updateHist}
\usesdollar{undoInCore}{HistList}
\usesdollar{undoInCore}{HistListLen}
\usesdollar{undoInCore}{IOindex}
\usesdollar{undoInCore}{HiFiAccess}
\usesdollar{undoInCore}{InteractiveFrame}
\begin{chunk}{defun undoInCore}
(defun |undoInCore| (n)
 (let (li vec p p1 val)
 (declare (special |$HistList| |$HistListLen| |$IOindex| |$HiFiAccess|
    |$InteractiveFrame|))
  (setq li |$HistList|) 
  (do ((i n (+ i 1)))
      ((> i |$HistListLen|) nil)
   (setq li (cdr li)))
  (|undoChanges| li)
  (setq n (- (- |$IOindex| n) 1))
  (and
    (> n 0)
    (if |$HiFiAccess|
     (progn
       (setq vec (cdr (unwind-protect (|readHiFi| n) (|disableHist|))))
       (setq val 
        (and 
         (setq p (assq '% vec))
         (setq p1 (assq '|value| (cdr p)))
         (cdr p1))))
      (|sayKeyedMsg| 
       "There is no history file, so value of step %1 is undefined."
       (cons n nil)))) ; no history file
  (setq |$InteractiveFrame| (|putHist| '% '|value| val |$InteractiveFrame|))
  (|updateHist|)))

\end{chunk}
\defun{undoChanges}{undoChanges}
\calls{undoChanges}{boot-equal}
\calls{undoChanges}{undoChanges}
\calls{undoChanges}{putHist}
\usesdollar{undoChanges}{HistList}
\usesdollar{undoChanges}{InteractiveFrame}
\begin{chunk}{defun undoChanges}
(defun |undoChanges| (li)
 (let (x)
 (declare (special |$HistList| |$InteractiveFrame|))
  (when (null (boot-equal (cdr li) |$HistList|)) (|undoChanges| (cdr li)))
  (dolist (p1 (car li))
    (setq x (car p1))
    (dolist (p2 (cdr p1))
     (|putHist| x (car p2) (cdr p2) |$InteractiveFrame|)))))

\end{chunk}
\defun{undoFromFile}{undoFromFile}
\calls{undoFromFile}{seq}
\calls{undoFromFile}{exit}
\calls{undoFromFile}{recordOldValue}
\calls{undoFromFile}{recordNewValue}
\calls{undoFromFile}{readHiFi}
\calls{undoFromFile}{disableHist}
\calls{undoFromFile}{putHist}
\calls{undoFromFile}{assq}
\calls{undoFromFile}{updateHist}
\usesdollar{undoFromFile}{InteractiveFrame}
\usesdollar{undoFromFile}{HiFiAccess}
\begin{chunk}{defun undoFromFile}
(defun |undoFromFile| (n)
 (let (varl prop vec x p p1 val)
 (declare (special |$InteractiveFrame| |$HiFiAccess|))
  (do ((tmp0 (caar |$InteractiveFrame|) (cdr tmp0)) (tmp1 nil))
      ((or (atom tmp0) 
           (progn (setq tmp1 (car tmp0)) nil) 
           (progn
             (progn
              (setq x (car tmp1)) 
              (setq varl (cdr tmp1))
              tmp1)
              nil))
            nil)
   (seq
    (exit
     (do ((tmp2 varl (cdr tmp2)) (p nil))
         ((or (atom tmp2) (progn (setq p (car tmp2)) nil)) nil)
      (seq
       (exit
        (progn
         (setq prop (car p))
         (setq val (cdr p))
         (when val 
           (progn
             (when (null (eq x '%))
               (|recordOldValue| x prop val))
             (when |$HiFiAccess| 
               (|recordNewValue| x prop val))
             (rplacd p nil))))))))))
  (do ((i 1 (1+ i)))
      ((> i n) nil)
    (setq vec 
      (unwind-protect (cdr (|readHiFi| i)) (|disableHist|)))
    (do ((tmp3 vec (cdr tmp3)) (p1 nil))
        ((or (atom tmp3) (progn (setq p1 (car tmp3)) nil)) nil)
     (setq x (car p1))
     (do ((tmp4 (cdr p1) (cdr tmp4)) (p2 nil))
         ((or (atom tmp4) (progn (setq p2 (car tmp4)) nil)) nil)
      (setq |$InteractiveFrame| 
         (|putHist| x (car p2) (CDR p2) |$InteractiveFrame|)))))
  (setq val
   (and 
    (setq p (assq '% vec))
    (setq p1 (assq '|value| (cdr p)))
    (cdr p1)))
  (setq |$InteractiveFrame| (|putHist| '% '|value| val |$InteractiveFrame|))
  (|updateHist|)))

\end{chunk}
\defun{saveHistory}{saveHistory}
\calls{saveHistory}{sayKeyedMsg}
\calls{saveHistory}{makeInputFilename}
\calls{saveHistory}{histFileName}
\calls{saveHistory}{throwKeyedMsg}
\calls{saveHistory}{makeHistFileName}
\calls{saveHistory}{histInputFileName}
\calls{saveHistory}{writeInputLines}
\calls{saveHistory}{histFileErase}
\calls{saveHistory}{rdefiostream}
\calls{saveHistory}{spadrwrite0}
\calls{saveHistory}{object2Identifier}
\calls{saveHistory}{rshut}
\calls{saveHistory}{namestring}
\usesdollar{saveHistory}{seen}
\usesdollar{saveHistory}{HiFiAccess}
\usesdollar{saveHistory}{useInternalHistoryTable}
\usesdollar{saveHistory}{internalHistoryTable}
\begin{chunk}{defun saveHistory}
(defun |saveHistory| (fn)
 (let (|$seen| savefile inputfile saveStr n rec val)
 (declare (special |$seen| |$HiFiAccess| |$useInternalHistoryTable|
     |$internalHistoryTable|))
 (setq |$seen| (make-hash-table :test #'eq))
 (cond 
  ((null |$HiFiAccess|) 
    (|sayKeyedMsg| 
     "The history facility is not on, so no information can be saved."
     nil)) ; the history file is not on
  ((and (null |$useInternalHistoryTable|) 
        (null (makeInputFilename (|histFileName|))))
    (|sayKeyedMsg| "No history information had been saved yet." nil))
  ((null fn) 
    (|throwKeyedMsg|
      "You must specify a file name to the history save command"
      nil))
  (t 
    (setq savefile (|makeHistFileName| fn))
    (setq inputfile (|histInputFileName| fn))
    (|writeInputLines| fn 1)
    (|histFileErase| savefile)
    (when |$useInternalHistoryTable| 
      (setq saveStr 
        (rdefiostream 
         (cons '(mode . output) 
           (cons (cons 'file savefile) nil))))
      (do ((tmp0 (reverse |$internalHistoryTable|) (cdr tmp0))
           (tmp1 nil))
          ((or (atom tmp0) 
               (progn (setq tmp1 (car tmp0)) nil)
               (progn
                (progn
                 (setq n (car tmp1)) 
                 (setq rec (cdr tmp1)) 
                 tmp1) 
                nil)) 
               nil)
        (setq val (spadrwrite0 (|object2Identifier| n) rec saveStr))
        (when (eq val '|writifyFailed|)
         (|sayKeyedMsg| 
          (format nil
           "Can't save the value of step number %1. You can re-generate ~
            this value by running the input file %2.")
          (list n inputfile))))
      (rshut saveStr))
    (|sayKeyedMsg| "The saved history file is %1 ."
      (cons (|namestring| savefile) nil))
    nil))))

\end{chunk}
\defun{restoreHistory}{restoreHistory}
\calls{restoreHistory}{qcdr}
\calls{restoreHistory}{qcar}
\calls{restoreHistory}{identp}
\calls{restoreHistory}{throwKeyedMsg}
\calls{restoreHistory}{makeHistFileName}
\calls{restoreHistory}{putHist}
\calls{restoreHistory}{makeInputFilename}
\calls{restoreHistory}{sayKeyedMsg}
\calls{restoreHistory}{namestring}
\calls{restoreHistory}{clearSpad2Cmd}
\calls{restoreHistory}{histFileName}
\calls{restoreHistory}{histFileErase}
\callsdollar{restoreHistory}{fcopy}
\calls{restoreHistory}{rkeyids}
\calls{restoreHistory}{readHiFi}
\calls{restoreHistory}{disableHist}
\calls{restoreHistory}{updateInCoreHist}
\calls{restoreHistory}{get}
\calls{restoreHistory}{rempropI}
\calls{restoreHistory}{clearCmdSortedCaches}
\usesdollar{restoreHistory}{options}
\usesdollar{restoreHistory}{internalHistoryTable}
\usesdollar{restoreHistory}{HiFiAccess}
\usesdollar{restoreHistory}{e}
\usesdollar{restoreHistory}{useInternalHistoryTable}
\usesdollar{restoreHistory}{InteractiveFrame}
\usesdollar{restoreHistory}{oldHistoryFileName}
\begin{chunk}{defun restoreHistory}
(defun |restoreHistory| (fn)
 (let (|$options| fnq restfile curfile l oldInternal vec line x a)
 (declare (special |$options| |$internalHistoryTable| |$HiFiAccess| |$e|
     |$useInternalHistoryTable| |$InteractiveFrame| |$oldHistoryFileName|))
 (cond 
   ((null fn) (setq fnq |$oldHistoryFileName|))
   ((and (consp fn) 
         (eq (qcdr fn) nil)
         (progn
          (setq fnq (qcar fn))
          t)
         (identp fnq))
     (setq fnq fnq))
   (t (|throwKeyedMsg| "%1 is not a valid filename for the history file."
        (cons fnq nil)))) ; invalid filename
 (setq restfile (|makeHistFileName| fnq))
 (if (null (makeInputFilename restfile))
  (|sayKeyedMsg|
   (format nil
    "History information cannot be restored from %1 because the file does ~
     not exist.")
    (cons (|namestring| restfile) nil))
  (progn 
    (setq |$options| nil)
    (|clearSpad2Cmd| '(|all|))
    (setq curfile (|histFileName|))
    (|histFileErase| curfile)
    ($fcopy restfile curfile)
    (setq l (length (rkeyids curfile)))
    (setq |$HiFiAccess| t)
    (setq oldInternal |$useInternalHistoryTable|)
    (setq |$useInternalHistoryTable| nil)
    (when oldInternal (setq |$internalHistoryTable| nil))
    (do ((i 1 (1+ i)))
        ((> i l) nil)
      (setq vec (unwind-protect (|readHiFi| i) (|disableHist|)))
      (when oldInternal
        (setq |$internalHistoryTable| 
         (cons (cons i vec) |$internalHistoryTable|)))
      (setq line (car vec))
      (dolist (p1 (cdr vec))
        (setq x (car p1))
        (do ((tmp1 (cdr p1) (cdr tmp1)) (p2 nil))
            ((or (atom tmp1) (progn (setq p2 (car tmp1)) nil)) nil)
         (setq |$InteractiveFrame| 
           (|putHist| x 
            (car p2) (cdr p2) |$InteractiveFrame|))))
      (|updateInCoreHist|))
    (setq |$e| |$InteractiveFrame|)
    (do ((tmp2 (caar |$InteractiveFrame|) (cdr tmp2)) (tmp3 nil))
        ((or (atom tmp2) 
             (progn
               (setq tmp3 (car tmp2))
               nil) 
             (progn
              (progn
                (setq a (car tmp3))
                tmp3) 
                nil))
             nil)
       (when (|get| a '|localModemap| |$InteractiveFrame|)
          (|rempropI| a '|localModemap|)
          (|rempropI| a '|localVars|)
          (|rempropI| a '|mapBody|)))
    (setq |$IOindex| (1+ l))
    (setq |$useInternalHistoryTable| oldInternal)
    (|sayKeyedMsg| 
     "The workspace has been successfully restored from the history file %1 ."
      (cons (|namestring| restfile) nil))
    (|clearCmdSortedCaches|)
     nil))))

\end{chunk}

\defun{setIOindex}{setIOindex}
\usesdollar{setIOindex}{IOindex}
\begin{chunk}{defun setIOindex}
(defun |setIOindex| (n)
  (declare (special |$IOindex|))
  (setq |$IOindex| n)) 

\end{chunk}
\defun{showInput}{showInput}
\calls{showInput}{tab}
\calls{showInput}{readHiFi}
\calls{showInput}{disableHist}
\calls{showInput}{sayMSG}
\begin{chunk}{defun showInput}
(defun |showInput| (mini maxi)
 (let (vec l)
  (do ((|ind| mini (+ |ind| 1)))
      ((> |ind| maxi) nil)
    (setq vec (unwind-protect (|readHiFi| |ind|) (|disableHist|)))
    (cond
     ((> 10 |ind|) (tab 2))
     ((> 100 |ind|) (tab 1))
     (t nil))
    (setq l (car vec))
    (if (stringp l)
      (|sayMSG| (list "   [" |ind| "] " (car vec)))
      (progn
       (|sayMSG| (list "   [" |ind| "] "))
       (do ((tmp0 l (cdr tmp0)) (ln nil))
           ((or (atom tmp0) (progn (setq ln (car tmp0)) nil)) nil)
         (|sayMSG| (list "      " ln))))))))

\end{chunk}
\defun{showInOut}{showInOut}
\calls{showInOut}{assq}
\calls{showInOut}{spadPrint}
\calls{showInOut}{objValUnwrap}
\calls{showInOut}{objMode}
\calls{showInOut}{readHiFi}
\calls{showInOut}{disableHist}
\calls{showInOut}{sayMSG}
\begin{chunk}{defun showInOut}
(defun |showInOut| (mini maxi)
 (let (vec Alist triple)
  (do ((ind mini (+ ind 1)))
      ((> ind maxi) nil)
   (setq vec (unwind-protect (|readHiFi| ind) (|disableHist|)))
   (|sayMSG| (cons (car vec) nil))
   (cond
    ((setq Alist (assq '% (cdr vec)))
      (setq triple (cdr (assq '|value| (cdr Alist))))
      (setq |$IOindex| ind)
      (|spadPrint| (|objValUnwrap| triple) (|objMode| triple)))))))

\end{chunk}
\defun{fetchOutput}{fetchOutput}
\calls{fetchOutput}{boot-equal}
\calls{fetchOutput}{getI}
\calls{fetchOutput}{throwKeyedMsg}
\calls{fetchOutput}{readHiFi}
\calls{fetchOutput}{disableHist}
\calls{fetchOutput}{assq}
\begin{chunk}{defun fetchOutput}
(defun |fetchOutput| (n)
 (let (vec Alist val)
  (cond
   ((and (boot-equal n (- 1)) (setq val (|getI| '% '|value|)))
     val)
   (|$HiFiAccess|
    (setq n
     (cond
      ((minusp n) (+ |$IOindex| n))
      (t n)))
    (cond
     ((>= n |$IOindex|) 
       (|throwKeyedMsg|
        "You have not reached step %1, and so its value cannot be supplied."
        (cons n nil)))
     ((> 1 n)
       (|throwKeyedMsg|
        "Cannot supply value for step %1b because 1 is the first step."
        (cons n nil))) ; only nonzero steps
     (t
       (setq vec (unwind-protect (|readHiFi| n) (|disableHist|)))
       (cond
        ((setq Alist (assq '% (cdr vec)))
          (cond
            ((setq val (cdr (assq '|value| (cdr Alist))))
              val)
            (t
              (|throwKeyedMsg| "Step %1 has no value." (cons n nil)))))
        (t (|throwKeyedMsg| "Step %1 has no value." (cons n nil)))))))
   (t (|throwKeyedMsg| 
       "The history facility is not on, so you cannot use %%."
       nil))))) ; history not on

\end{chunk}
\defunsec{readHiFi}{Read the history file using index n}
\calls{readHiFi}{assoc}
\calls{readHiFi}{keyedSystemError}
\calls{readHiFi}{qcdr}
\calls{readHiFi}{rdefiostream}
\calls{readHiFi}{histFileName}
\calls{readHiFi}{spadrread}
\calls{readHiFi}{object2Identifier}
\calls{readHiFi}{rshut}
\usesdollar{readHiFi}{useInternalHistoryTable}
\usesdollar{readHiFi}{internalHistoryTable}
\begin{chunk}{defun readHiFi}
(defun |readHiFi| (n)
 "Read the history file using index n"
 (let (pair HiFi vec)
  (declare (special |$useInternalHistoryTable| |$internalHistoryTable|))
  (if |$useInternalHistoryTable|
   (progn
    (setq pair (|assoc| n |$internalHistoryTable|))
    (if (atom pair) 
     (|keyedSystemError| "Missing element in internal history table." nil)
     (setq vec (qcdr pair))))
   (progn
     (setq HiFi
      (rdefiostream
       (cons
        '(mode . input)
         (cons
          (cons 'file (|histFileName|)) nil))))
     (setq vec (spadrread (|object2Identifier| n) HiFi))
     (rshut HiFi)))
  vec))

\end{chunk}
\defunsec{writeHiFi}{Write information of the current step to history file}
\calls{writeHiFi}{rdefiostream}
\calls{writeHiFi}{histFileName}
\calls{writeHiFi}{spadrwrite}
\calls{writeHiFi}{object2Identifier}
\calls{writeHiFi}{rshut}
\usesdollar{writeHiFi}{useInternalHistoryTable}
\usesdollar{writeHiFi}{internalHistoryTable}
\usesdollar{writeHiFi}{IOindex}
\usesdollar{writeHiFi}{HistRecord}
\usesdollar{writeHiFi}{currentLine}
\begin{chunk}{defun writeHiFi}
(defun |writeHiFi| ()
 "Writes information of the current step to history file"
 (let (HiFi)
 (declare (special |$useInternalHistoryTable| |$internalHistoryTable|
     |$IOindex| |$HistRecord| |$currentLine|))
   (if |$useInternalHistoryTable|
     (setq |$internalHistoryTable|
      (cons
       (cons |$IOindex|
        (cons |$currentLine| |$HistRecord|))
        |$internalHistoryTable|))
    (progn
      (setq HiFi
        (rdefiostream
         (cons
           '(mode . output)
            (cons (cons 'file (|histFileName|)) nil))))
      (spadrwrite (|object2Identifier| |$IOindex|)
        (cons |$currentLine| |$HistRecord|) HiFi)
      (rshut HiFi)))))

\end{chunk}
\defunsec{disableHist}{Disable history if an error occurred}
\calls{disableHist}{histFileErase}
\calls{disableHist}{histFileName}
\usesdollar{disableHist}{HiFiAccess}
\begin{chunk}{defun disableHist}
(defun |disableHist| () 
 "Disable history if an error occurred"
 (declare (special |$HiFiAccess|))
 (cond
  ((null |$HiFiAccess|) 
    (|histFileErase| (|histFileName|)))
  (t nil))) 

\end{chunk}
\defun{writeHistModesAndValues}{writeHistModesAndValues}
\calls{writeHistModesAndValues}{get}
\calls{writeHistModesAndValues}{putHist}
\usesdollar{writeHistModesAndValues}{InteractiveFrame}
\begin{chunk}{defun writeHistModesAndValues}
(defun |writeHistModesAndValues| ()
 (let (a x)
 (declare (special |$InteractiveFrame|))
  (do ((tmp0 (caar |$InteractiveFrame|) (cdr tmp0)) (tmp1 nil))
      ((or (atom tmp0) 
           (progn
             (setq tmp1 (car tmp0))
             nil)
           (progn
             (progn
               (setq a (car tmp1))
               tmp1)
           nil))
       nil)
     (cond
      ((setq x (|get| a '|value| |$InteractiveFrame|))
        (|putHist| a '|value| x |$InteractiveFrame|))
      ((setq x (|get| a '|mode| |$InteractiveFrame|))
        (|putHist| a '|mode| x |$InteractiveFrame|))))))

\end{chunk}

Lisplib output transformations

Some types of objects cannot be saved by LISP/VM in lisplibs.
These functions transform an object to a writable form and back.
\defun{spadrwrite0}{spadrwrite0}
\calls{spadrwrite0}{safeWritify}
\calls{spadrwrite0}{rwrite}
\begin{chunk}{defun spadrwrite0}
(defun spadrwrite0 (vec item stream)
 (let (val)
  (setq val (|safeWritify| item))
  (if (eq val '|writifyFailed|)
    val
    (progn
     (|rwrite| vec val stream)
     item))))

\end{chunk}

\defun{rwrite}{Random write to a stream}
\calls{rwrite}{rwrite}
\calls{rwrite}{pname}
\calls{rwrite}{identp}
\begin{chunk}{defun rwrite}
(defun |rwrite| (key val stream)
  (when (identp key) (setq key (pname key)))
  (rwrite key val stream))

\end{chunk}

\defun{spadrwrite}{spadrwrite}
\calls{spadrwrite}{spadrwrite0}
\calls{spadrwrite}{throwKeyedMsg}
\begin{chunk}{defun spadrwrite}
(defun spadrwrite (vec item stream)
 (let (val)
  (setq val (spadrwrite0 vec item stream))
  (if (eq val '|writifyFailed|)
   (|throwKeyedMsg| "The value specified cannot be saved to a file." nil)
   item)))

\end{chunk}
\defun{spadrread}{spadrread}
\calls{SPADRREAD}{dewritify}
\calls{SPADRREAD}{rread}
\begin{chunk}{defun spadrread}
(defun spadrread (vec stream)
 (|dewritify| (|rread| vec stream nil))) 

\end{chunk} 

\defun{rread}{Random read a key from a stream}
RREAD takes erroval to return if key is missing

\calls{rread}{rread}
\calls{rwrite}{identp}
\calls{rwrite}{pname}
\begin{chunk}{defun rread}
(defun |rread| (key rstream errorval)
  (when (identp key) (setq key (pname key)))
  (rread key rstream errorval))

\end{chunk}

\defun{unwritable?}{unwritable?}
\calls{unwritable?}{vecp}
\calls{unwritable?}{placep}
\begin{chunk}{defun unwritable?}
(defun |unwritable?| (ob)
 (cond
  ((or (consp ob) (simple-vector-p ob)) nil)
  ((or (compiled-function-p ob) (hash-table-p ob)) t)
  ((or (placep ob) (readtablep ob)) t)
  ((floatp ob) t)
  (t nil))) 

\end{chunk}
\defun{writifyComplain}{writifyComplain}
Create a full isomorphic object to be saved in a lisplib.  Note
that {\tt dewritify(writify(x))} preserves UEQUALity of hashtables.
HASHTABLEs go both ways.  READTABLEs cannot presently be transformed
back.
\calls{writifyComplain}{sayKeyedMsg}
\usesdollar{writifyComplain}{writifyComplained}
\begin{chunk}{defun writifyComplain}
(defun |writifyComplain| (s)
 (declare (special |$writifyComplained|))
 (unless |$writifyComplained|
  (setq |$writifyComplained| t)
  (|sayKeyedMsg|
   (format nil
    "A value containing a %1 is being saved in a history file or a ~
     compiled input file INLIB. This type is not yet usable in other ~
     history operations.  You might want to issue )history )off")
    (list s)))) ; cannot save value

\end{chunk}
\defun{safeWritify}{safeWritify}
\catches{safeWritify}{writifyTag}
\calls{safeWritify}{writify}
\begin{chunk}{defun safeWritify}
(defun |safeWritify| (ob)
 (catch '|writifyTag| (|writify| ob))) 

\end{chunk}
\defun{writify,writifyInner}{writify,writifyInner}
\throws{writify,writifyInner}{writifyTag}
\calls{writify,writifyInner}{seq}
\calls{writify,writifyInner}{exit}
\calls{writify,writifyInner}{hget}
\calls{writify,writifyInner}{qcar}
\calls{writify,writifyInner}{qcdr}
\calls{writify,writifyInner}{spadClosure?}
\calls{writify,writifyInner}{writify,writifyInner}
\calls{writify,writifyInner}{hput}
\calls{writify,writifyInner}{qrplaca}
\calls{writify,writifyInner}{qrplacd}
\calls{writify,writifyInner}{vecp}
\calls{writify,writifyInner}{isDomainOrPackage}
\calls{writify,writifyInner}{mkEvalable}
\calls{writify,writifyInner}{devaluate}
\calls{writify,writifyInner}{qvmaxindex}
\calls{writify,writifyInner}{qsetvelt}
\calls{writify,writifyInner}{qvelt}
\calls{writify,writifyInner}{constructor?}
\calls{writify,writifyInner}{hkeys}
\calls{writify,writifyInner}{hashtable-class}
\calls{writify,writifyInner}{placep}
\calls{writify,writifyInner}{boot-equal}
\usesdollar{writify,writifyInner}{seen}
\usesdollar{writify,writifyInner}{NonNullStream}
\usesdollar{writify,writifyInner}{NullStream}
\begin{chunk}{defun writify,writifyInner}
(defun |writify,writifyInner| (ob)
 (prog (e name tmp1 tmp2 tmp3 x qcar qcdr d n keys nob)
  (declare (special |$seen| |$NonNullStream| |$NullStream|))
  (return
   (seq
    (when (null ob) (exit nil))
    (when (setq e (hget |$seen| ob)) (exit e))
    (when (consp ob)
     (exit
      (seq
       (setq qcar (qcar ob))
       (setq qcdr (qcdr ob))
       (when (setq name (|spadClosure?| ob))
        (exit
         (seq
          (setq d (|writify,writifyInner| (qcdr ob)))
          (setq nob 
           (cons 'writified!!
            (cons 'spadclosure 
             (cons d (cons name nil)))))
          (hput |$seen| ob nob)
          (hput |$seen| nob nob)
          (exit nob))))
       (when 
        (and 
         (and (consp ob)
              (eq (qcar ob) 'lambda-closure)
              (progn
               (setq tmp1 (qcdr ob))
               (and (consp tmp1)
                    (progn 
                     (setq tmp2 (qcdr tmp1))
                     (and 
                      (consp tmp2)
                      (progn 
                       (setq tmp3 (qcdr tmp2))
                       (and (consp tmp3)
                            (progn
                             (setq x (qcar tmp3))
                             t)))))))) x)
        (exit
         (throw '|writifyTag| '|writifyFailed|)))
       (setq nob (cons qcar qcdr))
       (hput |$seen| ob nob)
       (hput |$seen| nob nob)
       (setq qcar (|writify,writifyInner| qcar))
       (setq qcdr (|writify,writifyInner| qcdr))
       (qrplaca nob qcar)
       (qrplacd nob qcdr)
       (exit nob))))
    (when (simple-vector-p ob)
     (exit
      (seq
       (when (|isDomainOrPackage| ob)
         (setq d (|mkEvalable| (|devaluate| ob)))
         (setq nob (list 'writified!! 'devaluated (|writify,writifyInner| d)))
         (hput |$seen| ob nob)
         (hput |$seen| nob nob)
         (exit nob))
       (setq n (qvmaxindex ob))
       (setq nob (make-array (1+ n)))
       (hput |$seen| ob nob)
       (hput |$seen| nob nob)
       (do ((i 0 (=! i)))
           ((> i n) nil)
         (qsetvelt nob i (|writify,writifyInner| (qvelt ob i))))
       (exit nob))))
    (when (eq ob 'writified!!)
     (exit
      (cons 'writified!! (cons 'self nil))))
    (when (|constructor?| ob)
     (exit ob))
    (when (compiled-function-p ob)
     (exit
      (throw '|writifyTag| '|writifyFailed|)))
    (when (hash-table-p ob)
       (setq nob (cons 'writified!! nil))
       (hput |$seen| ob nob)
       (hput |$seen| nob nob)
       (setq keys (hkeys ob))
       (qrplacd nob
        (cons 
          'hashtable
          (cons 
            (hashtable-class ob)
            (cons
              (|writify,writifyInner| keys)
              (cons
                (prog (tmp0)
                  (setq tmp0 nil)
                  (return
                   (do ((tmp1 keys (cdr tmp1)) (k nil))
                       ((or (atom tmp1)
                            (progn
                             (setq k (car tmp1))
                              nil))
                            (nreverse0 tmp0))
                    (setq tmp0 
                     (cons (|writify,writifyInner| (hget ob k)) tmp0)))))
                nil)))))
       (exit nob))
    (when (placep ob)
       (setq nob (cons 'writified!! (cons 'place nil)))
       (hput |$seen| ob nob)
       (hput |$seen| nob nob)
       (exit nob))
    (when (readtablep ob)
     (exit
      (throw '|writifyTag| '|writifyFailed|)))
    (when (stringp ob)
     (exit
      (seq
       (when (eq ob |$NullStream|)
        (exit
         (cons 'writified!! (cons 'nullstream nil))))
       (when (eq ob |$NonNullStream|)
        (exit
         (cons 'writified!! (cons 'nonnullstream nil))))
       (exit ob))))
    (when (floatp ob)
     (exit
      (seq
       (when (boot-equal ob (read-from-string (princ-to-string ob)))
        (exit ob))
       (exit
        (cons 'writified!!
         (cons 'float 
          (cons ob 
           (multiple-value-list (integer-decode-float ob)))))))))
    (exit ob))))) 

\end{chunk}
\defun{writify}{writify}
\calls{writify}{ScanOrPairVec}
\calls{writify}{function}
\calls{writify}{writify,writifyInner}
\usesdollar{writify}{seen}
\usesdollar{writify}{writifyComplained}
\begin{chunk}{defun writify}
(defun |writify| (ob)
 (let (|$seen| |$writifyComplained|)
 (declare (special |$seen| |$writifyComplained|))
  (if (null (|ScanOrPairVec| #'|unwritable?| ob))
    ob
    (progn
     (setq |$seen| (make-hash-table :test #'eq))
     (setq |$writifyComplained| nil)
     (|writify,writifyInner| ob)))))

\end{chunk}
\defun{spadClosure?}{spadClosure?}
\calls{spadClosure?}{qcar}
\calls{spadClosure?}{bpiname}
\calls{spadClosure?}{qcdr}
\calls{spadClosure?}{vecp}
\begin{chunk}{defun spadClosure?}
(defun |spadClosure?| (ob)
 (let (fun name vec)
  (setq fun (qcar ob))
  (if (null (setq name (bpiname fun)))
   nil
   (progn
     (setq vec (qcdr ob))
     (if (null (simple-vector-p vec)) 
      nil
      name)))))

\end{chunk}

\defdollar{NonNullStream}
\begin{chunk}{initvars}
(defvar |$NonNullStream| "NonNullStream")

\end{chunk}

\defdollar{NullStream}
\begin{chunk}{initvars}
(defvar |$NullStream| "NullStream")

\end{chunk}

\defun{dewritify,dewritifyInner}{dewritify,dewritifyInner}
\calls{dewritify,dewritifyInner}{seq}
\calls{dewritify,dewritifyInner}{exit}
\calls{dewritify,dewritifyInner}{hget}
\calls{dewritify,dewritifyInner}{intp}
\calls{dewritify,dewritifyInner}{gensymmer}
\calls{dewritify,dewritifyInner}{error}
\calls{dewritify,dewritifyInner}{poundsign}
\calls{dewritify,dewritifyInner}{hput}
\calls{dewritify,dewritifyInner}{dewritify,dewritifyInner}
\calls{dewritify,dewritifyInner}{concat}
\calls{dewritify,dewritifyInner}{vmread}
\calls{dewritify,dewritifyInner}{make-instream}
\calls{dewritify,dewritifyInner}{qcar}
\calls{dewritify,dewritifyInner}{qcdr}
\calls{dewritify,dewritifyInner}{qrplaca}
\calls{dewritify,dewritifyInner}{qrplacd}
\calls{dewritify,dewritifyInner}{vecp}
\calls{dewritify,dewritifyInner}{qvmaxindex}
\calls{dewritify,dewritifyInner}{qsetvelt}
\calls{dewritify,dewritifyInner}{qvelt}
\usesdollar{dewritify,dewritifyInner}{seen}
\usesdollar{dewritify,dewritifyInner}{NullStream}
\usesdollar{dewritify,dewritifyInner}{NonNullStream}
\begin{chunk}{defun dewritify,dewritifyInner}
(defun |dewritify,dewritifyInner| (ob)
 (prog (e type oname f vec name tmp1 signif expon sign fval qcar qcdr n nob)
  (declare (special |$seen| |$NullStream| |$NonNullStream|))
  (return
   (seq
    (when (null ob) 
      (exit nil))
    (when (setq e (hget |$seen| ob)) 
      (exit e))
    (when (and (consp ob) (eq (car ob) 'writified!!))
     (exit
      (seq
       (setq type (elt ob 1))
       (when (eq type 'self) 
        (exit 'writified!!))
       (when (eq type 'bpi)
        (exit
         (seq
          (setq oname (elt ob 2))
          (setq f 
           (seq 
            (when (integerp oname) (exit (eval (gensymmer oname))))
            (exit (symbol-function oname))))
          (when (null (compiled-function-p f))
           (exit (|error| "A required BPI does not exist.")))
          (when (and (> (|#| ob) 3) (not (equal (sxhash f) (elt ob 3))))
           (exit (|error| "A required BPI has been redefined.")))
          (hput |$seen| ob f)
          (exit f))))
       (when (eq type 'hashtable)
        (exit
         (seq
          (setq nob (make-hash-table :test #'equal))
          (hput |$seen| ob nob)
          (hput |$seen| nob nob)
          (do ((tmp0 (elt ob 3) (cdr tmp0))
               (k nil)
               (tmp1 (elt ob 4) (cdr tmp1))
               (e nil))
              ((or (atom tmp0) 
                   (progn
                    (setq k (car tmp0))
                    nil) 
                   (atom tmp1) 
                   (progn
                    (setq e (car tmp1))
                    nil))
                   nil)
           (seq
            (exit
             (hput nob (|dewritify,dewritifyInner| k) 
              (|dewritify,dewritifyInner| e)))))
          (exit nob))))
       (when (eq type 'devaluated)
        (exit
         (seq
          (setq nob (eval (|dewritify,dewritifyInner| (elt ob 2))))
          (hput |$seen| ob nob)
          (hput |$seen| nob nob)
          (exit nob))))
       (when (eq type 'spadclosure)
        (exit
         (seq
          (setq vec (|dewritify,dewritifyInner| (elt ob 2)))
          (setq name (ELT ob 3))
          (when (null (fboundp name))
           (exit
            (|error| 
             (concat "undefined function: " (symbol-name name)))))
          (setq nob (cons (symbol-function name) vec))
          (hput |$seen| ob nob)
          (hput |$seen| nob nob)
          (exit nob))))
       (when (eq type 'place) 
        (exit
         (seq
          (setq nob (vmread (make-instream nil)))
          (hput |$seen| ob nob)
          (hput |$seen| nob nob)
          (exit nob))))
       (when (eq type 'readtable)
        (exit (|error| "Cannot de-writify a read table.")))
       (when (eq type 'nullstream)
        (exit |$NullStream|))
       (when (eq type 'nonnullstream) 
        (exit |$NonNullStream|))
       (when (eq type 'float) 
        (exit
         (seq
          (progn
           (setq tmp1 (cddr ob))
           (setq fval (car tmp1))
           (setq signif (cadr tmp1))
           (setq expon (caddr tmp1))
           (setq sign (cadddr tmp1))
           tmp1)
          (setq fval (scale-float (float signif fval) expon))
          (when (minusp sign)
           (exit (- fval)))
          (exit fval))))
       (exit (|error| "Unknown type to de-writify.")))))
    (when (consp ob)
     (exit
      (seq
       (setq qcar (qcar ob))
       (setq qcdr (qcdr ob))
       (setq nob (cons qcar qcdr))
       (hput |$seen| ob nob)
       (hput |$seen| nob nob)
       (qrplaca nob (|dewritify,dewritifyInner| qcar))
       (qrplacd nob (|dewritify,dewritifyInner| qcdr))
       (exit nob))))
    (when (simple-vector-p ob)
     (exit
      (seq
       (setq n (qvmaxindex ob))
       (setq nob (make-array (1+ n)))
       (hput |$seen| ob nob)
       (hput |$seen| nob nob)
       (do ((i 0 (1+ i)))
           ((> i n) nil)
        (seq
         (exit
          (qsetvelt nob i 
            (|dewritify,dewritifyInner| (qvelt ob i))))))
       (exit nob))))
    (exit ob))))) 

\end{chunk}

\defun{dewritify}{dewritify}
\calls{dewritify}{ScanOrPairVec}
\calls{dewritify}{function}
\calls{dewritify}{dewritify,dewritifyInner}
\usesdollar{dewritify}{seen}
\begin{chunk}{defun dewritify}
(defun |dewritify| (ob)
 (let (|$seen|)
 (declare (special |$seen|))
   (if (null (|ScanOrPairVec| #'(lambda (a) (eq a 'writified!!)) ob))
    ob
    (progn
      (setq |$seen| (make-hash-table :test #'eq))
      (|dewritify,dewritifyInner| ob)))))

\end{chunk}

\defun{ScanOrPairVec,ScanOrInner}{ScanOrPairVec,ScanOrInner}
\throws{ScanOrPairVec,ScanOrInner}{ScanOrPairVecAnswer}
\calls{ScanOrPairVec,ScanOrInner}{hget}
\calls{ScanOrPairVec,ScanOrInner}{hput}
\calls{ScanOrPairVec,ScanOrInner}{ScanOrPairVec,ScanOrInner}
\calls{ScanOrPairVec,ScanOrInner}{qcar}
\calls{ScanOrPairVec,ScanOrInner}{qcdr}
\calls{ScanOrPairVec,ScanOrInner}{vecp}
\usesdollar{ScanOrPairVec,ScanOrInner}{seen}
\begin{chunk}{defun ScanOrPairVec,ScanOrInner}
(defun |ScanOrPairVec,ScanOrInner| (f ob)
  (declare (special |$seen|))
  (when (hget |$seen| ob) nil)
  (when (consp ob) 
    (hput |$seen| ob t)
    (|ScanOrPairVec,ScanOrInner| f (qcar ob))
    (|ScanOrPairVec,ScanOrInner| f (qcdr ob)))
  (when (simple-vector-p ob) 
     (hput |$seen| ob t)
     (do ((tmp0 (- (|#| ob) 1)) (i 0 (1+ i)))
         ((> i tmp0) nil)
       (|ScanOrPairVec,ScanOrInner| f (elt ob i))))
  (when (funcall f ob) (throw '|ScanOrPairVecAnswer| t))
  nil)

\end{chunk}

\defun{ScanOrPairVec}{ScanOrPairVec}
\catches{ScanOrPairVec}{ScanOrPairVecAnswer}
\calls{ScanOrPairVec}{ScanOrPairVec,ScanOrInner}
\usesdollar{ScanOrPairVec}{seen}
\begin{chunk}{defun ScanOrPairVec}
(defun |ScanOrPairVec| (f ob)
 (let (|$seen|) 
 (declare (special |$seen|)) 
  (setq |$seen| (make-hash-table :test #'eq))
  (catch '|ScanOrPairVecAnswer| (|ScanOrPairVec,ScanOrInner| f ob))))

\end{chunk}
\defun{gensymInt}{gensymInt}
\calls{gensymInt}{gensymp}
\calls{gensymInt}{error}
\calls{gensymInt}{pname}
\calls{gensymInt}{charDigitVal}
\begin{chunk}{defun gensymInt}
(defun |gensymInt| (g) 
 (let (p n)
  (if (null (gensymp g)) 
   (|error| "Need a GENSYM")
   (progn
     (setq p (pname g))
     (setq n 0)
     (do ((tmp0 (- (|#| p) 1)) (i 2 (1+ i)))
         ((> i tmp0) nil)
       (setq n (+ (* 10 n) (|charDigitVal| (elt p i)))))
     n))))

\end{chunk}
\defun{charDigitVal}{charDigitVal}
\calls{charDigitVal}{error}
\begin{chunk}{defun charDigitVal}
(defun |charDigitVal| (c)
 (let (digits n)
  (setq digits "0123456789")
  (setq n (- 1)) 
  (do ((tmp0 (- (|#| digits) 1)) (i 0 (1+ i)))
      ((or (> i tmp0) (null (minusp n))) nil)
   (if (char= c (elt digits i))
    (setq n i)
    nil))
  (if (minusp n) 
   (|error| "Character is not a digit")
   n)))

\end{chunk}
\defun{histFileErase}{histFileErase}
\begin{chunk}{defun histFileErase}
(defun |histFileErase| (file)
 (when (probe-file file) (delete-file file)))

\end{chunk}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{include}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{include.help}

User Level Required: interpreter

Command Syntax:

 )include filename

Command Description:

The )include command can be used in .input files to place the contents
of another file inline with the current file.  The path can be an
absolute or relative pathname.

\end{chunk}

\defun{ncloopInclude1}{ncloopInclude1}
\calls{ncloopInclude1}{ncloopIncFileName}
\calls{ncloopInclude1}{ncloopInclude}
\begin{chunk}{defun ncloopInclude1}
(defun |ncloopInclude1| (name n)
 (let (a)
  (if (setq a (|ncloopIncFileName| name))
    (|ncloopInclude| a n)
    n)))

\end{chunk}
\defunsec{ncloopIncFileName}
{Returns the first non-blank substring of the given string}
\calls{ncloopIncFileName}{incFileName}
\calls{ncloopIncFileName}{concat}
\begin{chunk}{defun ncloopIncFileName}
(defun |ncloopIncFileName| (string)
 "Returns the first non-blank substring of the given string"
 (let (fn)
  (unless (setq fn (|incFileName| string))
   (write-line (concat string " not found")))
 fn))

\end{chunk}

\defunsec{ncloopInclude}{Open the include file and read it in} 
The ncloopInclude0 function is part
of the parser and lives in int-top.boot.

\calls{ncloopInclude}{ncloopInclude0}
\begin{chunk}{defun ncloopInclude}
(defun |ncloopInclude| (name n)
 "Open the include file and read it in"
 (with-open-file (st name) (|ncloopInclude0| st name n)))

\end{chunk}

\defunsec{incFileName}{Return the include filename}
Given a string we return the first token from the string which is
the first non-blank substring.
\calls{incFileName}{incBiteOff}
\begin{chunk}{defun incFileName}
(defun |incFileName| (x)
 "Return the include filename"
  (car (|incBiteOff| x)))

\end{chunk}

\defunsec{incBiteOff}{Return the next token}
Takes a sequence and returns the a list of the first token and the
remaining string characters. If there are no remaining string characters
the second string is of length 0. Effectively it "bites off" the first 
token in the string. If the string only 0 or more blanks it returns nil.
\begin{chunk}{defun incBiteOff}
(defun |incBiteOff| (x)
 "Return the next token"
 (let (blank nonblank)
  (setq x (string x))
  (when (setq nonblank (position #\space x :test-not #'char=))
    (setq blank (position #\space x :start nonblank))
    (if blank
     (list (subseq x nonblank blank) (subseq x blank))
     (list (subseq x nonblank) "")))))

\end{chunk}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{library}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{library.help}
====================================================================
A.14.  )library
====================================================================
 
User Level Required:  interpreter
 
Command Syntax: 
 
  - )library libName1  [libName2 ...]
  - )library )dir dirName
  - )library )only objName1  [objlib2 ...]
  - )library )noexpose
 
Command Description: 
 
This command replaces the )load system command that was available in AXIOM
releases before version 2.0. The )library command makes available to AXIOM
the compiled objects in the libraries listed.
 
For example, if you )compile dopler.spad in your home directory, issue )library
dopler to have AXIOM look at the library, determine the category and domain
constructors present, update the internal database with various properties of
the constructors, and arrange for the constructors to be automatically loaded
when needed. If the )noexpose option has not been given, the constructors
will be exposed (that is, available) in the current frame.
 
If you compiled a file you will have an NRLIB present, for example,
DOPLER.NRLIB, where DOPLER is a constructor abbreviation. The command
)library DOPLER will then do the analysis and database updates as above.
 
To tell the system about all libraries in a directory, use )library )dir
dirName where dirName is an explicit directory. You may specify ``.'' as the
directory, which means the current directory from which you started the
system or the one you set via the )cd command. The directory name is required.
 
You may only want to tell the system about particular constructors within a
library. In this case, use the )only option. The command )library dopler
)only Test1 will only cause the Test1 constructor to be analyzed, autoloaded,
etc..
 
Finally, each constructor in a library are usually automatically exposed when
the )library command is used. Use the )noexpose option if you not want them
exposed. At a later time you can use )set expose add constructor to expose
any hidden constructors.
 
Note for AXIOM beta testers: At various times this command was called )local
and )with before the name )library became the official name.
 
Also See: 
o )cd
o )compile
o )frame
o )set
 
\end{chunk} 
\footnote{
\fnref{cd}
\fnref{frame}
\fnref{set}}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{license}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{license.help}
====================================================================
A.15.  )license
====================================================================
 
Command Syntax: 
 
  -  )license
 
Command Description: 
 
This command displays the Axiom license.
 
Also See: 
o )trademark
 
\end{chunk} 

\defun{license}{license}
\calls{license}{obey}
\calls{license}{concat}
\calls{license}{getenviron}
\begin{chunk}{defun license}
(defun |license| (l)
 (declare (ignore l))
 (obey (concat "cat " (getenviron "AXIOM") "/doc/spadhelp/copyright.help")))

\end{chunk}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{lisp}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{lisp.help}
====================================================================
A.15.  )lisp
====================================================================
 
User Level Required:  development
 
Command Syntax: 
 
  -  )lisp [lispExpression]
 
Command Description: 
 
This command is used by AXIOM system developers to have single expressions
evaluated by the Lisp system on which AXIOM is built. The lispExpression is
read by the Lisp reader and evaluated. If this expression is not complete
(unbalanced parentheses, say), the reader will wait until a complete
expression is entered.
 
Since this command is only useful for evaluating single expressions, the )fin
command may be used to drop out of AXIOM into Lisp.
 
Also See: 
o )system
o )boot
o )fin
 
\end{chunk} 
\footnote{
\fnref{system}
\fnref{boot}
\fnref{fin}}

This command is in the list of \verb|$noParseCommands|
\ref{noParseCommands} which means that its arguments are passed
verbatim. This will eventually result in a call to the function
\verb|handleNoParseCommands| \ref{handleNoParseCommands}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{ltrace}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{ltrace.help}
====================================================================
A.17.  )ltrace
====================================================================
 
User Level Required:  development
 
Command Syntax: 
 
This command has the same arguments as options as the )trace command.
 
Command Description: 
 
This command is used by AXIOM system developers to trace Lisp functions.
It is not supported for general use.
 
Also See: 
o )lisp
o )trace
 
\end{chunk} 
\footnote{
\fnref{lisp}
\fnref{trace}}

\defun{ltrace}{The top level )ltrace function}
\calls{ltrace}{trace}
\begin{chunk}{defun ltrace}
(defun |ltrace| (arg) (|trace| arg)) 

\end{chunk}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{pquit}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{pquit.help}
====================================================================
A.18.  )pquit
====================================================================
 
User Level Required:  interpreter
 
Command Syntax: 
 
  - )pquit
 
Command Description: 
 
This command is used to terminate AXIOM and return to the operating system.
Other than by redoing all your computations or by using the )history )restore
command to try to restore your working environment, you cannot return to
AXIOM in the same state.
 
)pquit differs from the )quit in that it always asks for confirmation that
you want to terminate AXIOM (the ``p'' is for ``protected''). When you enter
the )pquit command, AXIOM responds
 
      Please enter y or yes if you really want to leave the interactive 
                environment and return to the operating system:
 
If you respond with y or yes, you will see the message
 
            You are now leaving the AXIOM interactive environment. 
    Issue the command axiom to the operating system to start a new session.
 
and AXIOM will terminate and return you to the operating system (or the
environment from which you invoked the system). If you responded with
something other than y or yes, then the message
 
        You have chosen to remain in the AXIOM interactive environment.
 
will be displayed and, indeed, AXIOM would still be running.
 
Also See: 
o )fin
o )history
o )close
o )quit
o )system
 
\end{chunk} 
\footnote{
\fnref{fin}
\fnref{history}
\fnref{close}
\fnref{quit}
\fnref{system}}

\defunsec{pquit}{The top level pquit command}
\calls{pquit}{pquitSpad2Cmd}
\begin{chunk}{defun pquit}
(defun |pquit| ()
 "The top level pquit command"
 (|pquitSpad2Cmd|)) 

\end{chunk}

\defunsec{pquitSpad2Cmd}{The top level pquit command handler}
\calls{pquitSpad2Cmd}{quitSpad2Cmd}
\usesdollar{pquitSpad2Cmd}{quitCommandType}
\begin{chunk}{defun pquitSpad2Cmd}
(defun |pquitSpad2Cmd| ()
 "The top level pquit command handler"
 (let ((|$quitCommandType| '|protected|))
  (declare (special |$quitCommandType|))
  (|quitSpad2Cmd|)))

\end{chunk}

This command is in the list of \verb|$noParseCommands|
\ref{noParseCommands} which means that its arguments are passed
verbatim. This will eventually result in a call to the function
\verb|handleNoParseCommands| \ref{handleNoParseCommands}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{quit}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{quit.help}
====================================================================
A.19.  )quit
====================================================================
 
User Level Required:  interpreter
 
Command Syntax: 
 
  - )quit
  - )set quit protected | unprotected
 
Command Description: 
 
This command is used to terminate AXIOM and return to the operating system.
Other than by redoing all your computations or by using the )history )restore
command to try to restore your working environment, you cannot return to
AXIOM in the same state.
 
)quit differs from the )pquit in that it asks for confirmation only if the
command
 
)set quit protected
 
has been issued. Otherwise, )quit will make AXIOM terminate and return you to
the operating system (or the environment from which you invoked the system).
 
The default setting is )set quit protected so that )quit and )pquit behave in
the same way. If you do issue
 
)set quit unprotected
 
we suggest that you do not (somehow) assign )quit to be executed when you
press, say, a function key.
 
Also See: 
o )fin
o )history
o )close
o )pquit
o )system
 
\end{chunk} 
\footnote{
\fnref{fin}
\fnref{history}
\fnref{close}
\fnref{pquit}
\fnref{system}}

\defunsec{quit}{The top level quit command}
\calls{quit}{quitSpad2Cmd}
\begin{chunk}{defun quit}
(defun |quit| ()
 "The top level quit command"
 (|quitSpad2Cmd|))

\end{chunk}
\defunsec{quitSpad2Cmd}{The top level quit command handler}
\calls{quitSpad2Cmd}{upcase}
\calls{quitSpad2Cmd}{queryUserKeyedMsg}
\calls{quitSpad2Cmd}{string2id-n}
\calls{quitSpad2Cmd}{leaveScratchpad}
\calls{quitSpad2Cmd}{sayKeyedMsg}
\calls{quitSpad2Cmd}{tersyscommand}
\usesdollar{quitSpad2Cmd}{quitCommandType}
\begin{chunk}{defun quitSpad2Cmd}
(defun |quitSpad2Cmd| ()
 "The top level quit command handler"
 (declare (special |$quitCommandType|))
 (if (eq |$quitCommandType| '|protected|)
  (let (x)
   (setq x
    (upcase
     (|queryUserKeyedMsg|
      (format nil
       "Please enter y or yes if you really want to leave the interactive ~
        environment and return to the operating system:")
       nil)))
   (when (member (string2id-n x 1) '(y yes)) (|leaveScratchpad|))
   (|sayKeyedMsg| 
    "You have chosen to remain in the Axiom interactive environment." nil)
   (tersyscommand))
  (|leaveScratchpad|)))

\end{chunk}

\defunsec{leaveScratchpad}{Leave the Axiom interpreter}
\begin{chunk}{defun leaveScratchpad}
(defun |leaveScratchpad| () 
 "Leave the Axiom interpreter"
 (bye)) 

\end{chunk}

This command is in the list of \verb|$noParseCommands|
\ref{noParseCommands} which means that its arguments are passed
verbatim. This will eventually result in a call to the function
\verb|handleNoParseCommands| \ref{handleNoParseCommands}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{read}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{read.help}
====================================================================
A.20.  )read
====================================================================
 
User Level Required:  interpreter
 
Command Syntax: 
 
  -  )read [fileName]
  -  )read [fileName] [)quiet] [)ifthere]
 
Command Description: 
 
This command is used to read .input files into AXIOM. The command
 
)read matrix.input
 
will read the contents of the file matrix.input into AXIOM. The ``.input''
file extension is optional. See the AXIOM User Guide index for more
information about .input files.
 
This command remembers the previous file you edited, read or compiled. If you
do not specify a file name, the previous file will be read.
 
The )ifthere option checks to see whether the .input file exists. If it does
not, the )read command does nothing. If you do not use this option and the
file does not exist, you are asked to give the name of an existing .input
file.
 
The )quiet option suppresses output while the file is being read.
 
Also See: 
o )compile
o )edit
o )history
 
\end{chunk} 
\footnote{
\fnref{edit}
\fnref{history}}

\defun{read}{The )read command}
\calls{read}{readSpad2Cmd}
\begin{chunk}{defun read}
(defun |read| (arg) (|readSpad2Cmd| arg)) 

\end{chunk}

\defun{readSpad2Cmd}{Implement the )read command}
\calls{readSpad2Cmd}{selectOptionLC}
\calls{readSpad2Cmd}{optionError}
\calls{readSpad2Cmd}{pathname}
\calls{readSpad2Cmd}{pathnameTypeId}
\calls{readSpad2Cmd}{makePathname}
\calls{readSpad2Cmd}{pathnameName}
\calls{readSpad2Cmd}{mergePathnames}
\calls{readSpad2Cmd}{findfile}
\calls{readSpad2Cmd}{throwKeyedMsg}
\calls{readSpad2Cmd}{namestring}
\calls{readSpad2Cmd}{upcase}
\calls{readSpad2Cmd}{member}
\calls{readSpad2Cmd}{/read}
\usesdollar{readSpad2Cmd}{InteractiveMode}
\usesdollar{readSpad2Cmd}{findfile}
\usesdollar{readSpad2Cmd}{UserLevel}
\usesdollar{readSpad2Cmd}{options}
\uses{readSpad2Cmd}{/editfile}
\begin{chunk}{defun readSpad2Cmd}
(defun |readSpad2Cmd| (arg)
 (prog (|$InteractiveMode| fullopt ifthere quiet ef devFTs fileTypes 
        ll ft upft fs)
 (declare (special |$InteractiveMode| $findfile |$UserLevel| |$options|
                      /editfile))
  (setq |$InteractiveMode| t)
  (dolist (opt |$options|)
   (setq fullopt
    (|selectOptionLC| (car opt) '(|quiet| |test| |ifthere|) '|optionError|))
    (cond
     ((eq fullopt '|ifthere|) (setq ifthere t))
     ((eq fullopt '|quiet|)   (setq quiet t))))
  (setq ef (or (|pathname| /editfile) ""))
  (when (eq (|pathnameTypeId| ef) 'spad)
    (setq ef (|makePathname| (|pathnameName| ef) "*" "*")))
  (if arg 
   (setq arg (|mergePathnames| (|pathname| arg) ef))
   (setq arg ef))
  (setq devFTs '("input" "INPUT" "boot" "BOOT" "lisp" "LISP"))
  (setq fileTypes
   (cond
    ((eq |$UserLevel| '|interpreter|) '("input" "INPUT"))
    ((eq |$UserLevel| '|compiler|)    '("input" "INPUT"))
    (t devFTs)))
  (setq ll ($findfile arg fileTypes))
  (unless ll
    (if ifthere 
     (return nil)
     (|throwKeyedMsg| "The file %1 is needed but does not exist."
      (list (|namestring| arg)))))
  (setq ll (|pathname| ll))
  (setq ft (|pathnameType| ll))
  (setq upft (upcase ft))
  (cond
   ((null (|member| upft fileTypes))
     (setq fs (|namestring| arg))
     (if (|member| upft devFTs)
      (|throwKeyedMsg|
       (format nil
        "You cannot )read the file %1 because your user-level is not is ~
         not high enough. For more information about your user-level, issue ~
         )set userlevel.")
       (list fs))
      (|throwKeyedMsg| 
       (format nil
        "You cannot )read the file %1 because it is not suitable for ~
         reading by Axiom. Note that files with file extension .spad ~
         can now only be compiled with the )compile system command.")
       (list fs))))
   (t
    (setq /editfile ll)
    (when (string= upft "BOOT") (setq |$InteractiveMode| nil))
    (/read ll quiet)))))

\end{chunk}

\defun{/read}{/read}
\seebook{/read}{/rf}{9}
\seebook{/read}{/rq}{9}
\uses{/read}{/editfile}
\begin{chunk}{defun /read}
(defun /read (l q)
 (declare (special /editfile))
  (setq /editfile l)
  (cond
    (q (/rq))
    (t (/rf)) )
  (flag |boot-NewKEY| 'key)
  (|terminateSystemCommand|)
  (|spadPrompt|))


\end{chunk}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{regress}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{regress.help}
====================================================================
A.18.  )regress
====================================================================
 
User Level Required:  interpreter
 
Command Syntax: 
 
  -  )regress fileName
 
Command Description: 
 
The regress command will run the regress function that was compiled
as part of the lisp image build process. This function expects an
input filename, possibly containing a path prefix. 

If the filename contains a period then we consider it a fully formed
filename, otherwise we append ``.output'', which is the default file
extension.

  )regress matrix
  )regress matrix.output
  )regress /path/to/file/matrix
  )regress /path/to/file/matrix.output
 
will test the contents of the file matrix.output.

The idea behind regression testing is to check that the results
we currently get match the results we used to get. In order to
do that we create input files with a special comment format that
contains the prior results. These are easy to create as all you
need to do is run the Axiom function, capture the results, and
turn them input specially formed comments using the -- comment.

A regression file caches the result of an Axiom function so we
can automate the testing process. It is a file of many tests,
each with their own output.

The regression file format uses the Axiom -- comment syntax to keep
a copy of the expected output from an Axiom command. This expected
output is compared character by character against the actual output.

The regression file is broken into numbered blocks, delimited by
a --S for the beginning and a --E for the end. The total number of
blocks is also given so missing or failed tests also raise an error.

There are 4 special kinds of -- comments in regression files:

  --S n of M        this is test n of M tests in this file
  --E n             this marks the end of test n
  --R any output    this marks the actual expected output line
  --I any output    this line is compared but ignored

A regression test file looks like:

  )set break resume
  )spool foo.output
  )set message type off
  )clear all

  --S 1 of 3
  2+3
  --R                     this is the exact Axiom output
  --R   (1)  5
  --E 1

  --S 2 of 3
  2+3
  --R                     this should fail to match
  --R   (2)  7
  --E 2

  --S 3 of 3
  2+3
  --R                     this fails to match but we
  --I   (3)  7            use --I to ignore this line
  --E 3

We can now run this file with

  )read foo.input

Note that when this file is run it will create a spool file called
"foo.output" because of the lines:
  
  )spool foo.output
  )spool

The "foo.output" file contains the console image of the result. 
It will look like:

  Starts dribbling to foo.output (2012/2/28, 12:25:7).
  )set message type off
  )clear all

  --S 1 of 3
  2+3
  
     (1)  5
  --R
  --R   (1)  5
  --E 1
  
  --S 2 of 3
  2+3
  
     (2)  5
  --R
  --R   (2)  7
  --E 2

  --S 3 of 3
  2+3
  
     (3)  5
  --R
  --I   (3)  7
  --E 3

  )spool

This "foo.output" file can now be checked using the )regress command.
 
When we run the )regress foo.output we see;

  testing foo
  passed foo  1 of 3
  MISMATCH
  expected:"   (2)  7"
       got:"   (2)  5"
  FAILED foo  2 of 2
  passed foo  3 of 3
  regression result FAILED 1 of 3 stanzas file foo

Tests either pass or fail. A passing test generates the message:

    passed foo  1 of 3

A failing test will give a reversed printout of the expected vs
actual output as well as a FAILED message, as in:

  MISMATCH
  expected:"   (2)  7"
       got:"   (2)  5"
  FAILED foo  2 of 3

The last line of output is a summary:

  regression result FAILED 1 of 3 stanzas file foo

 
\end{chunk} 

\begin{chunk}{defun regress command}
(defun |regress| (arg)
 (let (|$InteractiveMode| namestring dot1 outfile (extension "output"))
 (declare (special |$InteractiveMode|))
  (setq |$InteractiveMode| t)
  (setq namestring (symbol-name (car arg)))
  (setq dot1 (position #\. namestring))
  (unless dot1
   (setq outfile (concatenate 'string (subseq namestring 0) "." extension)))
  (if (probe-file outfile)
   (regress outfile)
   (format t (concatenate 'string outfile "~% file not found")))))

\end{chunk}

\subsection{The regress function details}
This is the regression test mechanism. The input files have been
rewritten to have a standard structure. This fixed format identifies
the tests within a file. Each test is run and any mismatch between
the actual and expected results is reported.

In order to regression test axiom results we created a standard
file format. This format has 3 kinds of markers:
\begin{itemize}
\item ``--S'' marker which must have a integer test number
\item ``--R'' marker lines, one per expected output from axiom
\item ``--E'' marker which has an integer matching the preceeding ``--S''
\item ``--I'' marker ignores the line, useful for gensyms and random
\end{itemize}
Because these markers use Axiom's standard comment prefix they
are valid lines in input files and are ignored by the ``)read''
command. They are simply copied to the output file. This allows
us to include the expected output in the output file so we can
compare what Axiom computes with what it should compute.

To create these regression files all you need to do is create an
input file and run it through Axiom. Then, for each test case in
the file you mark it up by putting a ``--S number'' {\bf before}
the Axiom input line. You put ``--R'' prefixes on each line of
Axiom output, including the blank lines. Then you put a ``--E number''
line after the last output line, usually the {\tt Type:} line.
This newly marked-up input file is now a regression test.

To actually run the regression test you simply include the
marked up the input file in the {\tt src/input} subdirectory.
This file will automatically be run at build time and any failing
tests will be marked. This code will ignore any input that does
not contain proper regression markups.

Ideally the regression test files should be pamphlet files that
explain the content and purpose of each regression test case.

Thus you run the marked-up input file {\tt foo.input}
and spool the result to {\tt foo.output} and then run the 
lisp function\\ 
{\tt (regress ``foo.output'')}

If the file does not contain proper regression markups it is
ignored. Comments or any other commands in the file that are not
surrounded by ``--S'' and ``--E'' boundaries are ignored.

\defvar{*all-tests-ran*}
This variable is used to check whether all of the tests actually
ran. This is needed to see if the execution ended early.
\begin{chunk}{initvars}
(defvar *all-tests-ran* nil "true implies that all tests ran")

\end{chunk}

\defun{regress}{Scan a spool output file for failures}
This function takes an output file which has been created by the
Axiom {\tt )spool} command and looks for regression test markups.
Each regression test is checked against the actual result and any
failures are marked. 

\calls{regress}{getspoolname}
\calls{regress}{findnexttest}
\calls{regress}{testpassed}
\uses{regress}{*all-tests-ran*}
\begin{chunk}{defun regress}
(defun regress (infile)
 (let (name comment test (count 0) (passed 0) (failed 0))
 (declare (special *all-tests-ran*))
  (setq *all-tests-ran* nil)
  (with-open-file (stream infile :direction :input)
   (setq name (getspoolname stream)) 
   (when name
    (format t "testing ~a~%" name)
    (loop
     (setq *ok* nil)
     (multiple-value-setq (comment test) (findnexttest stream))
     (unless comment (return))
     (setq count (+ count 1))
     (if (testpassed test)
      (progn
       (setq passed (+ passed 1))
       (format t "passed ~a ~a~%" name comment))
      (progn
       (setq failed (+ failed 1))
       (format t "FAILED ~a ~a~%" name comment))))
   (if (= failed 0)
    (format t "regression result passed ~a of ~a stanzas ~Tfile ~a~%"
     passed count name)
    (format t "regression result FAILED ~a of ~a stanzas ~Tfile ~a~%"
     failed count name))
   (unless *all-tests-ran*
    (format t "regression result FAILED early exit in file ~a?~%" name))))))

\end{chunk}

\defun{getspoolname}{Parse test name from the spool command}
We need to parse out the name of the test. The ``)spool'' command
writes a line into the output file containing the name of the test.
We parse out the name of the test from this line.
\begin{chunk}{defun getspoolname 0}
(defun getspoolname (stream)
 (let (line point)
  (setq line (read-line stream))
  (setq point (position #\. line))
  (if (or (null point) 
      (< (length line) 30)
      (not (string= (subseq line (+ point 1) (+ point 7)) "output")))
    nil
  (subseq line 20 point))))

\end{chunk}

\defun{findnexttest}{Find the next --S marker}
We need to break the file into separate test cases. This routine
looks for the ``--S'' line which indicates a test is starting. It
collects up input lines until it encounters the ``--E'' line marking
the end of the test case. These lines are returned as a list of strings.

\calls{findnexttest}{testnumberp}
\begin{chunk}{defun findnexttest}
(defun findnexttest (stream)
 (let (teststart result)
  (do ((line (read-line stream nil 'done) (read-line stream nil 'done)))
      ((or (eq line 'done) (endedp line))
        (values (if line teststart) result))
   (if teststart 
    (push line result) 
    (setq teststart (testnumberp line))))))

\end{chunk}

\defun{testnumberp}{Parse out the test number from --S lines}
The ``--S'' line has a test number on the line. We parse out the
test number for printing.
\calls{testnumberp}{startp}
\begin{chunk}{defun testnumberp}
(defun testnumberp (oneline)
 (when (startp oneline) (subseq oneline 3)))

\end{chunk}

\defvar{*ok*}
We can mark a test as always ok by putting the word ``ok'' anywhere
on the start line. The regress function resets this value. The startp
function checks the --S line for the word ``ok''. If found, it sets
this value to true which causes a failing test to be considered as
passed.
\begin{chunk}{initvars}
(defvar *ok* nil "did we mark this test as always ok?")

\end{chunk}

\defun{testpassed}{Compare the computed and expected results}
This routine takes the test input, passes it to split to clean up
and break into two lists, and then compares the resulting lists
element by element, complaining about any mismatches. The result
is either true if everything passes or false if a mismatch occurs.

A test line can also be considered at passing if the expected line
is the string ``ignore''.

The ok variable allows us to mark failing tests as ``ok'' because
we expect the test might fail due to random values or testing known
bugs against expected output. We filter these tests marked ``ok''
so they do not count as ``real'' failures.

\calls{testpassed}{split}
\uses{testpassed}{*ok*}
\begin{chunk}{defun testpassed}
(defun testpassed (test)
 (let (answer expected (passed t) mismatchedLines)
  (declare (special *ok*))
  (multiple-value-setq (answer expected) (split test))
  (dotimes (i (length answer))
   (unless 
    (or (string= (first expected) "ignore")
        (string= (first expected) (first answer)))
    (unless *ok* (setq passed nil))
    (push (cons (first expected) (first answer)) mismatchedLines))
   (pop answer)
   (pop expected))
  (when mismatchedLines
   (dolist (pair mismatchedLines)
    (format t "expected:~s~%     got:~s~%"  (car pair) (cdr pair))))
  passed))

\end{chunk}

\defun{split}{Split the calculated and expect results into lists}
We have a list containing all of the lines in a test. The input is of
the form:
\begin{verbatim}
("--R                                         Type: List Integer"
 "--R   (1)  [1,4,2,- 6,0,3,5,4,2,3]" 
 "--R" 
 "--R "
 "                                         Type: List Integer"
 "   (1)  [1,4,2,- 6,0,3,5,4,2,3]" 
 "" 
 " "
 "l := [1,4,2,-6,0,3,5,4,2,3]")
\end{verbatim}
It removes the ``--R'' prefix from the result strings
and generates two hopefully equal-length lists, thus:
\begin{verbatim}
("                                         Type: List Integer"
 "   (1)  [1,4,2,- 6,0,3,5,4,2,3]" 
 "" 
 " ")
("                                         Type: List Integer"
 "   (1)  [1,4,2,- 6,0,3,5,4,2,3]" 
 "" 
 " "))
\end{verbatim}
Thus the first line is the start line, the second line is the Axiom 
input line, followed by the Axiom output. Then we have the lines marked
``--R'' which are the expected result. We split these into two separate
lists and throw way the lines that are the start and end lines. 

Once we have classified all of the lines we need to throw away the
input lines.  By assumption there will be more answer lines than
expected lines because the input lines are included. And given the way
we process the file these input lines are on the top of the answer
stack. Since the number of answer lines should equal the number of
expected lines we pop the stack until the numbers are equal.

Each element of the answer list should
be {\tt string=} to the corresponding element of the result list.

If the input line starts with ``--I'' we push the string ``ignore''.
This is useful for handling random results or gensym symbols.

\calls{split}{startp}
\calls{split}{endedp}
\calls{split}{ignorep}
\calls{split}{resultp}
\begin{chunk}{defun split}
(defun split (test)
 (let (answer (acnt 0) expected (ecnt 0))
  (dolist (oneline test)
   (cond
    ((startp oneline))
    ((endedp oneline))
    ((ignorep oneline)
      (setq ecnt (+ ecnt 1))
      (push "ignore" expected))
    ((resultp oneline)
      (setq ecnt (+ ecnt 1))
      (push (subseq oneline 3) expected))
    (t 
      (setq acnt (+ acnt 1))
      (push oneline answer))))
  (dotimes (i (- acnt ecnt)) (pop answer))
  (values (nreverse answer) (nreverse expected))))

\end{chunk}

\defun{startp}{Returns true on --S lines}
This test returns true if we have a ``start'' line. That is, a line
with a ``--S'' prefix. 

The *all-tests-ran* variable is true if the start line is of the form
"--S N of M" and N=M, that is, it checks that all tests were performed
since this should only occur on the last start line. This will detect
``premature exit'' in processing.

If a test is failing because of random input values or we want the
test to fail but not to count toward failing values then put the
string ``ok'' somewhere on the ``--S'' line as in:
\begin{verbatim}
--S 29 of 42 fails due to random values but that is ok
\end{verbatim}

\calls{startp}{lastcount}
\uses{startp}{*ok*}
\begin{chunk}{defun startp}
(defun startp (oneline)
 (let (result)
 (declare (special *ok*))
  (when
   (setq result
    (and (>= (length oneline) 3) (string= (subseq oneline 0 3) "--S")))
     (setq *ok* (search "ok" oneline))
     (setq *all-tests-ran* (lastcount oneline)))
  result))

\end{chunk}

\defun{endedp}{Returns true on --E lines}
This test returns true if we have a ``ended'' line. That is, a line
with a ``--E'' prefix.
\begin{chunk}{defun endedp 0}
(defun endedp (oneline)
 (and (>= (length oneline) 3) (string= (subseq oneline 0 3) "--E")))

\end{chunk}

\defun{resultp}{Returns true on --R lines}
This test returns true if we have a ``results'' line. That is, a line
with a ``--R'' prefix.
\begin{chunk}{defun resultp 0}
(defun resultp (oneline)
 (and (>= (length oneline) 3) (string= (subseq oneline 0 3) "--R")))

\end{chunk}

\defun{ignorep}{Returns true on --I lines}
This test returns true if we have an ``ignore'' line. That is, a line
with a ``--I'' prefix.
\begin{chunk}{defun ignorep 0}
(defun ignorep (oneline)
 (and (>= (length oneline) 3) (string= (subseq oneline 0 3) "--I")))

\end{chunk}

\defun{lastcount}{Check the last --S line ran}
If the ``--S'' line has the format ``--S n of m'' we return true if 
n=m, false otherwise.
Thus,
\begin{verbatim}
 "--S"              => nil
 "--S 1 of 4"       => nil
 "--S 10 of 40"     => nil
 "--S 4 of 4"       => t
 "--S 40 of 40"     => t
 "--S 1 of a"       => nil
\end{verbatim}
This is used as a final end check to make sure that all of the
tests actually ran rather than having the regression test exit
early and quietly. This will be false on all but the last test
and will be false if the ``--S'' line does not contain the optional
count marker. It is not required but is highly recommended.

\begin{chunk}{defun lastcount 0}
(defun lastcount (oneline)
 (let ((n :done) (m :done) next somemore isof)
 (when (and (>= (length oneline) 3) (string= (subseq oneline 0 3) "--S"))
  (setq somemore (string-trim " " (subseq oneline 3)))
  (when somemore
   (multiple-value-setq (n next) (read-from-string somemore nil :done))
   (when (integerp n)
    (setq somemore (string-trim " " (subseq somemore next)))
    (multiple-value-setq (isof next) (read-from-string somemore nil :done))
    (when (string= isof "OF")
     (setq somemore (string-trim " " (subseq somemore next)))
     (multiple-value-setq (m next) (read-from-string somemore nil :done))))))
  (and (integerp m) (integerp n) (= m n))))

\end{chunk}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{savesystem}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{savesystem.help}
====================================================================
A.8.  )savesystem
====================================================================
 
User Level Required:  interpreter
 
 
Command Syntax: 
 
  - )savesystem filename
 
Command Description: 
 
 This command is used to save an AXIOM image to disk.  This creates an
executable file which, when started, has everything loaded into it
that was there when the image was saved.  Thus, after executing commands
which cause the loading of some packages, the command:
 
)savesystem /tmp/savesys

will create an image that can be restarted  with the UNIX command:

axiom -ws /tmp/savesys

This new system will not need to reload the packages and domains that
were already loaded when the system was saved.

There is currently a restriction that only systems started with the 
command "AXIOMsys" may be saved.

   axiom
   (1) -> t1:=4
   (1) -> )savesystem foo

and Axiom exits. Then do

   ./foo
   (1) -> t1
   4

\end{chunk} 

\defvar{*ThisIsARunningSystem*}
When a user does
\begin{verbatim}
  )savesystem foo
\end{verbatim}
we set this variable to true. This is tested in the restart function,
which is called when the system starts, to prevent losing user
information.
\begin{chunk}{initvars}
(defvar *ThisIsARunningSystem* nil "Are we restarting a running system?")

\end{chunk}

\defun{savesystem}{The )savesystem command}
\calls{savesystem}{helpSpad2Cmd}
\calls{savesystem}{spad-save}
\begin{chunk}{defun savesystem}
(defun |savesystem| (arg)
  (if (or (not (eql (|#| arg) 1)) (null (symbolp (car arg))))
    (|helpSpad2Cmd| '(|savesystem|))
    (progn
     (setq *ThisIsARunningSystem* t)
     (spad-save (symbol-name (car arg))))))

\end{chunk}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{set}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{set.help}
====================================================================
A.21.  )set
====================================================================
 
User Level Required:  interpreter
 
Command Syntax: 
 
  -  )set
  -  )set label1 [... labelN]
  -  )set label1 [... labelN] newValue
 
Command Description: 
 
The )set command is used to view or set system variables that control what
messages are displayed, the type of output desired, the status of the history
facility, the way AXIOM user functions are cached, and so on. Since this
collection is very large, we will not discuss them here. Rather, we will show
how the facility is used. We urge you to explore the )set options to
familiarize yourself with how you can modify your AXIOM working environment.
There is a HyperDoc version of this same facility available from the main
HyperDoc menu. Click [here] to go to it. 
 
The )set command is command-driven with a menu display. It is
tree-structured. To see all top-level nodes, issue )set by itself.
 
)set
 
Variables with values have them displayed near the right margin. Subtrees of
selections have ``...'' displayed in the value field. For example, there are
many kinds of messages, so issue )set message to see the choices.
 
)set message
 
The current setting for the variable that displays whether computation times
are displayed is visible in the menu displayed by the last command. To see
more information, issue
 
)set message time
 
This shows that time printing is on now. To turn it off, issue
 
)set message time off
 
As noted above, not all settings have so many qualifiers. For example, to
change the )quit command to being unprotected (that is, you will not be
prompted for verification), you need only issue
 
)set quit unprotected
 
Also See: 
o )quit

\end{chunk}
\footnote{\fnref{quit}}

\subsection{Overview}
This section contains tree of information used to initialize the {\bf )set} 
command in the interpreter. The current list is:
\begin{verbatim}

Variable     Description                           Current Value
-----------------------------------------------------------------
compile    Library compiler options                   ... 
breakmode  execute break processing on error          break 
expose     control interpreter constructor exposure   ... 
functions  some interpreter function options          ... 
fortran    view and set options for FORTRAN output    ... 
kernel     library functions built into the kernel for 
           efficiency                                 ...
hyperdoc   options in using HyperDoc                  ... 
help       view and set some help options             ... 
history    save workspace values in a history file    on 
messages   show messages for various system features  ... 
naglink    options for NAGLink                        ... 
output     view and set some output options           ... 
quit       protected or unprotected quit              unprotected 
streams    set some options for working with streams  ... 
system     set some system development variables      ... 
userlevel  operation access level of system user      development 

Variables with current values of ... have further sub-options. 
For example, issue )set  system to see what the options are 
for system. For more information, issue )help set .

\end{verbatim}

\defunsec{initializeSetVariables}{Initialize the set variables}
The argument settree is initially the \verb|$setOption| variable.
The fourth element is a union-style switch symbol.
The fifth element is usually a variable to set.
The sixth element is a subtree to recurse for the TREE switch.
The seventh element is usually the default value. For more detailed
explanations see the list structure section \ref{Theliststructure}.
\calls{initializeSetVariables}{sayMSG}
\calls{initializeSetVariables}{literals}
\calls{initializeSetVariables}{translateYesNo2TrueFalse}
\calls{initializeSetVariables}{tree}
\calls{initializeSetVariables}{initializeSetVariables}
\begin{chunk}{defun initializeSetVariables}
(defun |initializeSetVariables| (settree) 
 "Initialize the set variables"
 (dolist (setdata settree)
  (case (fourth setdata)
   (function
      (if (canFuncall? (fifth setdata))
        (funcall (fifth setdata) '|%initialize%|)
        (|sayMSG| (concatenate 'string "   Function not implemented. "
         (package-name *package*) ":" (string (fifth setdata))))))
   (integer (set (fifth setdata) (seventh setdata)))
   (string  (set (fifth setdata) (seventh setdata)))
   (literals
       (set (fifth setdata) (|translateYesNo2TrueFalse| (seventh setdata))))
   (tree  (|initializeSetVariables| (sixth setdata))))))

\end{chunk}

\defunsec{resetWorkspaceVariables}{Reset the workspace variables}
\calls{resetWorkspaceVariables}{copy}
\calls{resetWorkspaceVariables}{initializeSetVariables}
\uses{resetWorkspaceVariables}{/editfile}
\uses{resetWorkspaceVariables}{/sourcefiles}
\uses{resetWorkspaceVariables}{/pretty}
\usesdollar{resetWorkspaceVariables}{spaceList}
\usesdollar{resetWorkspaceVariables}{countList}
\usesdollar{resetWorkspaceVariables}{timerList}
\usesdollar{resetWorkspaceVariables}{sourceFiles}
\usesdollar{resetWorkspaceVariables}{existingFiles}
\usesdollar{resetWorkspaceVariables}{functionTable}
\usesdollar{resetWorkspaceVariables}{boot}
\usesdollar{resetWorkspaceVariables}{compileMapFlag}
\usesdollar{resetWorkspaceVariables}{echoLineStack}
\usesdollar{resetWorkspaceVariables}{operationNameList}
\usesdollar{resetWorkspaceVariables}{slamFlag}
\usesdollar{resetWorkspaceVariables}{CommandSynonymAlist}
\usesdollar{resetWorkspaceVariables}{InitialCommandSynonymAlist}
\usesdollar{resetWorkspaceVariables}{UserAbbreviationsAlist}
\usesdollar{resetWorkspaceVariables}{msgAlist}
\usesdollar{resetWorkspaceVariables}{msgDatabase}
\usesdollar{resetWorkspaceVariables}{msgDatabaseName}
\usesdollar{resetWorkspaceVariables}{dependeeClosureAlist}
\usesdollar{resetWorkspaceVariables}{IOindex}
\usesdollar{resetWorkspaceVariables}{coerceIntByMapCounter}
\usesdollar{resetWorkspaceVariables}{e}
\usesdollar{resetWorkspaceVariables}{env}
\usesdollar{resetWorkspaceVariables}{setOptions}
\begin{chunk}{defun resetWorkspaceVariables}
(defun |resetWorkspaceVariables| () 
 "Reset the workspace variables"
 (declare (special |$countList| /editfile /sourcefiles |$sourceFiles| /pretty
    |$spaceList| |$timerList| |$existingFiles| |$functionTable| $boot 
    |$compileMapFlag| |$echoLineStack| |$operationNameList| |$slamFlag|
    |$CommandSynonymAlist| |$InitialCommandSynonymAlist|
    |$UserAbbreviationsAlist| |$msgAlist| |$msgDatabase| |$msgDatabaseName|
    |$dependeeClosureAlist| |$IOindex| |$coerceIntByMapCounter| |$e| |$env|
    |$setOptions|))
  (setq |$countList| nil)
  (setq /editfile nil)
  (setq /sourcefiles nil)
  (setq |$sourceFiles| nil)
  (setq /pretty nil)
  (setq |$spaceList| nil)
  (setq |$timerList| nil)
  (setq |$existingFiles| (make-hash-table :test #'equal))
  (setq |$functionTable| nil)
  (setq $boot nil)
  (setq |$compileMapFlag| nil)
  (setq |$echoLineStack| nil)
  (setq |$operationNameList| nil)
  (setq |$slamFlag| nil)
  (setq |$CommandSynonymAlist| (copy |$InitialCommandSynonymAlist|))
  (setq |$UserAbbreviationsAlist| nil)
  (setq |$msgAlist| nil)
  (setq |$msgDatabase| nil)
  (setq |$msgDatabaseName| nil)
  (setq |$dependeeClosureAlist| nil)
  (setq |$IOindex| 1)
  (setq |$coerceIntByMapCounter| 0)
  (setq |$e| (cons (cons nil nil) nil))
  (setq |$env| (cons (cons nil nil) nil))
  (|initializeSetVariables| |$setOptions|)) 

\end{chunk}

\defunsec{displaySetOptionInformation}{Display the set option information}
\calls{displaySetOptionInformation}{displaySetVariableSettings}
\calls{displaySetOptionInformation}{concat}
\calls{displaySetOptionInformation}{object2String}
\calls{displaySetOptionInformation}{specialChar}
\calls{displaySetOptionInformation}{sayBrightly}
\calls{displaySetOptionInformation}{bright}
\calls{displaySetOptionInformation}{sayMSG}
\calls{displaySetOptionInformation}{boot-equal}
\calls{displaySetOptionInformation}{sayMessage}
\calls{displaySetOptionInformation}{eval}
\calls{displaySetOptionInformation}{literals}
\calls{displaySetOptionInformation}{translateTrueFalse2YesNo}
\usesdollar{displaySetOptionInformation}{linelength}
\begin{chunk}{defun displaySetOptionInformation}
(defun |displaySetOptionInformation| (arg setdata)
 "Display the set option information"
 (let (current)
 (declare (special $linelength))
  (cond
   ((eq (fourth setdata) 'tree)
    (|displaySetVariableSettings| (sixth setdata) (first setdata)))
   (t 
     (format t "~v,,,'-:@<~a~>~%" (- $linelength 2)
      (concat " The " (|object2String| arg) " Option "))
    (|sayBrightly|
     `(|%l| ,@(|bright| "Description:") ,(second setdata)))
    (case (fourth setdata)
     (function
      (terpri)
      (if (canFuncall? (fifth setdata))
        (funcall (fifth setdata) '|%describe%|)
        (|sayMSG| "   Function not implemented.")))
     (integer
      (|sayMessage| 
        `(" The" ,@(|bright| arg) "option" 
          " may be followed by an integer in the range" 
          ,@(|bright| (elt (sixth setdata) 0)) "to" 
          |%l| ,@(|bright| (elt (sixth setdata) 1)) "inclusive." 
          " The current setting is" ,@(|bright| (|eval| (fifth setdata))))))
     (string
      (|sayMessage| 
        `(" The" ,@(|bright| arg) "option" 
          " is followed by a string enclosed in double quote marks." 
          '|%l| " The current setting is" 
          ,@(|bright| (list '|"| (|eval| (fifth setdata)) '|"|)))))
     (literals
       (|sayMessage|
        `(" The" ,@(|bright| arg) "option"
              " may be followed by any one of the following:"))
       (setq current 
        (|translateTrueFalse2YesNo| (|eval| (fifth setdata))))
       (dolist (name (sixth setdata))
         (if (boot-equal name current)
           (|sayBrightly| `( " ->" ,@(|bright| (|object2String| name))))
           (|sayBrightly| (list "    " (|object2String| name)))))
       (|sayMessage| " The current setting is indicated.")))))))

\end{chunk}

\defunsec{displaySetVariableSettings}{Display the set variable settings}
\calls{displaySetVariableSettings}{concat}
\calls{displaySetVariableSettings}{object2String}
\calls{displaySetVariableSettings}{sayBrightly}
\calls{displaySetVariableSettings}{say}
\calls{displaySetVariableSettings}{fillerSpaces}
\calls{displaySetVariableSettings}{specialChar}
\calls{displaySetVariableSettings}{concat}
\calls{displaySetVariableSettings}{satisfiesUserLevel}
\calls{displaySetVariableSettings}{poundsign}
\calls{displaySetVariableSettings}{eval}
\calls{displaySetVariableSettings}{bright}
\calls{displaySetVariableSettings}{literals}
\calls{displaySetVariableSettings}{translateTrueFalse2YesNo}
\calls{displaySetVariableSettings}{tree}
\usesdollar{displaySetVariableSettings}{linelength}
\begin{chunk}{defun displaySetVariableSettings}
(defun |displaySetVariableSettings| (settree label)
 "Display the set variable settings"
 (let (setoption opt subtree subname)
 (declare (special $linelength))
  (if (eq label '||) 
    (setq label ")set")
    (setq label (concat "  " (|object2String| label) " ")))
  (format t "~v:@<~a~>~%" (- $linelength 2)
    (concat " Current Values of" label " Variables "))
  (terpri)
  (|sayBrightly| 
   (list "Variable     " "Description                                "
         "Current Value" ))
  (say (|fillerSpaces| $linelength (|specialChar| '|hbar|)))
  (setq subtree nil)
  (dolist (setdata settree)
   (when (|satisfiesUserLevel| (third setdata))
     (setq setoption (|object2String| (first setdata)))
     (setq setoption
      (concat setoption
       (|fillerSpaces| (- 13 (|#| setoption)) " ")
       (second setdata)))
     (setq setoption
      (concat setoption
       (|fillerSpaces| (- 55 (|#| setoption)) " ")))
     (case (fourth setdata)
      (function
       (setq opt
        (if (canFuncall? (fifth setdata))
         (funcall (fifth setdata) '|%display%|)
         "unimplemented"))
       (cond
        ((consp opt)
         (setq opt
          (do ((t2 opt (cdr t2)) t1 (o nil))
              ((or (atom t2) (progn (setq o (car t2)) nil)) t1)
           (setq t1 (append t1 (cons o (cons " " nil))))))))
       (|sayBrightly| (|concat| setoption opt)))
      (string
       (setq opt (|object2String| (|eval| (fifth setdata))))
       (|sayBrightly| `(,setoption ,@(|bright| opt))))
      (integer
       (setq opt (|object2String| (|eval| (fifth setdata))))
       (|sayBrightly| `(,setoption ,@(|bright| opt))))
      (literals
       (setq opt (|object2String| 
             (|translateTrueFalse2YesNo| (|eval| (fifth setdata)))))
       (|sayBrightly| `(,setoption ,@(|bright| opt))))
      (TREE
         (|sayBrightly| `(,setoption ,@(|bright| "...")))
         (setq subtree t)
         (setq subname (|object2String| (first setdata)))))))
  (terpri)
  (when subtree
     (|sayBrightly|
      `("Variables with current values of" ,@(|bright| "...")
            "have further sub-options. For example,"))
     (|sayBrightly|
      `("issue" ,@(|bright| ")set ") ,subname
        " to see what the options are for" ,@(|bright| subname) "."
        |%l| "For more information, issue" ,@(|bright| ")help set") ".")))))

\end{chunk}

\defunsec{translateYesNo2TrueFalse}{Translate options values to t or nil}
\calls{translateYesNo2TrueFalse}{member}
\begin{chunk}{defun translateYesNo2TrueFalse}
(defun |translateYesNo2TrueFalse| (x)
 "Translate options values to t or nil"
 (cond
  ((|member| x '(|yes| |on|)) t)
  ((|member| x '(|no| |off|)) nil)
  (t x))) 

\end{chunk}

\defunsec{translateTrueFalse2YesNo}{Translate t or nil to option values}
\begin{chunk}{defun translateTrueFalse2YesNo}
(defun |translateTrueFalse2YesNo| (x)
 "Translate t or nil to option values"
 (cond
  ((eq x t) '|on|)
  ((null x) '|off|)
  (t x))) 

\end{chunk}
\subsection{The list structure}
\label{Theliststructure}
The structure of each list item consists of 7 items.  Consider this 
example:
\begin{verbatim}
  (userlevel
   "operation access level of system user"
   interpreter
   LITERALS
   $UserLevel
   (interpreter compiler development)
   development)
\end{verbatim}
The list contains (the names in bold are accessor names that can be
found in {\bf property.lisp.pamphlet}. Look for "setName".):
\begin{list}{}
\item {\bf 1} {\sl Name} the keyword the user will see. In this example
the user would say "{\bf )set output userlevel}".
\item {\bf 2} {\sl Label} the message the user will see. In this example
the user would see "operation access level of system user".
\item {\bf 3} {\sl Level} the level where the command will be 
accepted. There are three levels: interpreter, compiler, development.
These commands are restricted to keep the user from causing damage.
\item {\bf 4} {\sl Type} a symbol, one of {\bf FUNCTION}, {\bf INTEGER},
{\bf STRING}, {\bf LITERALS}, {\bf FILENAME} or {\bf TREE}. 
\item {\bf 5} {\sl Var} 
\begin{list}{}
\item FUNCTION is the function to call
\item INTEGER is the variable holding the current user setting.
\item STRING is the variable holding the current user setting.
\item LITERALS variable which holds the current user setting.
\item FILENAME is the variable that holds the current user setting.
\item TREE
\end{list}
\item {\bf 6} {\sl Leaf} 
\begin{list}{}
\item FUNCTION is the list of all possible values
\item INTEGER is the range of possible values
\item STRING is a list of all possible values
\item LITERALS is a list of all of the possible values
\item FILENAME is the function to check the filename
\item TREE
\end{list}
\item {\bf 7} {\sl Def} is the default value 
\begin{list}{}
\item FUNCTION is the default setting
\item INTEGER is the default setting
\item STRING is the default setting
\item LITERALS is the default setting
\item FILENAME is the default value
\item TREE
\end{list}
\end{list}

\section{\enspace{}set breakmode}
\begin{verbatim}
-------------------- The breakmode Option ---------------------

 Description: execute break processing on error

 The breakmode option may be followed by any one of the 
 following:

    nobreak
 -> break 
    query
    resume
    fastlinks
    quit

 The current setting is indicated.

\end{verbatim}
\defdollar{BreakMode}
\begin{chunk}{initvars}
(defvar |$BreakMode| '|nobreak| "execute break processing on error")

\end{chunk}
\begin{chunk}{breakmode}
  (|breakmode|
   "execute break processing on error"
   |interpreter|
   LITERALS
   |$BreakMode|
   (|nobreak| |break| |query| |resume| |fastlinks| |quit|)
   |nobreak|)         ; needed to avoid possible startup looping
\end{chunk}

\section{\enspace{}set debug}
\begin{verbatim}
                  Current Values of debug Variables                   

Variable     Description                           Current Value
-----------------------------------------------------------------
lambdatype   Show type information for #1 syntax     off
dalymode     Interpret leading open paren as lisp    off

\end{verbatim}
\begin{chunk}{debug}
   (|debug|
    "debug options"
    |interpreter|
    TREE
    |novar|
    (
\getchunk{debuglambdatype}
\getchunk{debugdalymode}
    ))
\end{chunk}

\subsection{set debug lambdatype}
\begin{verbatim}
---------------------- The lambdatype Option ----------------------

 Description: Show type information for #1 syntax

\end{verbatim}
\defdollar{lambdatype}
\begin{chunk}{initvars}
(defvar $lambdatype nil "show type information for #1 syntax")

\end{chunk}

\begin{chunk}{debuglambdatype}
      (|lambdatype|
       "show type information for #1 syntax"
       |interpreter|
       LITERALS
       $lambdatype
       (|on| |off|)
       |off|)
\end{chunk}

\section{\enspace{}set compiler}
\begin{verbatim}
                  Current Values of  compiler  Variables                   

Variable     Description                           Current Value
-----------------------------------------------------------------
output       library in which to place compiled code     
input        controls libraries from which to load compiled code  

\end{verbatim}
\begin{chunk}{compile}
   (|compiler|
    "Library compiler options"
    |interpreter|
    TREE
    |novar|
    (
\getchunk{compileoutput}
\getchunk{compileinput}
    ))
\end{chunk}

\subsection{set compiler output}
\begin{verbatim}
---------------------- The output Option ----------------------

 Description: library in which to place compiled code

\end{verbatim}
\begin{chunk}{compileoutput}
      (|output|
       "library in which to place compiled code "
       |interpreter|
       FUNCTION
       |setOutputLibrary|
       NIL
       |htSetOutputLibrary|
       )
\end{chunk}

\defunsec{setOutputLibrary}{The set output command handler}
\calls{setOutputLibrary}{poundsign}
\calls{setOutputLibrary}{describeOutputLibraryArgs}
\calls{setOutputLibrary}{filep}
\calls{setOutputLibrary}{openOutputLibrary}
\usesdollar{setOutputLibrary}{outputLibraryName}
\begin{chunk}{defun setOutputLibrary}
(defun |setOutputLibrary| (arg)
 "The set output command handler"
 (let (fn)
 (declare (special |$outputLibraryName|))
   (cond
    ((eq arg '|%initialize%|) (setq |$outputLibraryName| nil))
    ((eq arg '|%display%|) (or |$outputLibraryName| "user.lib"))
    ((or (null arg) (eq arg '|%describe%|) (eq (car arg) '?) (/= (|#| arg) 1))
     (|describeOutputLibraryArgs|))
    (t
     (when (probe-file (setq fn (princ-to-string (car arg))))
       (setq fn (truename fn)))
     (|openOutputLibrary| (setq |$outputLibraryName| fn))))))

\end{chunk}

\defunsec{describeOutputLibraryArgs}{Describe the set output library arguments}
\calls{describeOutputLibraryArgs}{sayBrightly}
\begin{chunk}{defun describeOutputLibraryArgs}
(defun |describeOutputLibraryArgs| ()
 "Describe the set output library arguments"
 (|sayBrightly| (list
  " )set compile output library is used to tell the compiler where to place"
  '|%l| "compiled code generated by the library compiler.  By default it goes"
  '|%l| "in a file called user.lib in the current directory.")))

\end{chunk}

\defvar{output-library}
\begin{chunk}{initvars}
(defvar output-library nil)

\end{chunk}

\defunsec{openOutputLibrary}{Open the output library}
The input-libraries and output-library are now truename based.

\calls{openOutputLibrary}{dropInputLibrary}
\uses{openOutputLibrary}{output-library}
\uses{openOutputLibrary}{input-libraries}
\begin{chunk}{defun openOutputLibrary}
(defun |openOutputLibrary| (lib)
 "Open the output library"
 (declare (special output-library input-libraries))
  (|dropInputLibrary| lib)
  (setq output-library (truename lib))
  (push output-library input-libraries))

\end{chunk}

\subsection{set compiler input}
\begin{verbatim}
---------------------- The input Option -----------------------

 Description: controls libraries from which to load compiled code

 )set compile input add library is used to tell AXIOM to add 
  library to the front of the path which determines where 
  compiled code is loaded from.
 )set compile input drop library is used to tell AXIOM to remove 
  library from this path.
\end{verbatim}
\begin{chunk}{compileinput}
      (|input|
       "controls libraries from which to load compiled code"
       |interpreter|
       FUNCTION
       |setInputLibrary|
       NIL
       |htSetInputLibrary|)
\end{chunk}


\defunsec{setInputLibrary}{The set input library command handler}
The input-libraries is now maintained as a list of truenames.

\calls{setInputLibrary}{describeInputLibraryArgs}
\calls{setInputLibrary}{qcar}
\calls{setInputLibrary}{qcdr}
\calls{setInputLibrary}{selectOptionLC}
\calls{setInputLibrary}{addInputLibrary}
\calls{setInputLibrary}{dropInputLibrary}
\calls{setInputLibrary}{setInputLibrary}
\uses{setInputLibrary}{input-libraries}
\begin{chunk}{defun setInputLibrary}
(defun |setInputLibrary| (arg)
 "The set input library command handler"
 (declare (special input-libraries))
 (let (tmp1 filename act)
  (cond
   ((eq arg '|%initialize%|) t)
   ((eq arg '|%display%|) (mapcar #'namestring input-libraries))
   ((or (null arg) (eq arg '|%describe%|) (eq (car arg) '?))
    (|describeInputLibraryArgs|))
   ((and (consp arg)
         (progn
          (setq act (qcar arg))
          (setq tmp1 (qcdr arg))
          (and (consp tmp1)
               (eq (qcdr tmp1) nil)
               (progn (setq filename (qcar tmp1)) t)))
         (setq act (|selectOptionLC| act '(|add| |drop|) nil)))
    (cond
     ((eq act '|add|)
      (|addInputLibrary| (truename (princ-to-string filename))))
     ((eq act '|drop|)
      (|dropInputLibrary| (truename (princ-to-string filename))))))
   (t (|setInputLibrary| nil)))))

\end{chunk}

\defunsec{describeInputLibraryArgs}{Describe the set input library arguments}
\calls{describeInputLibraryArgs}{sayBrightly}
\begin{chunk}{defun describeInputLibraryArgs}
(defun |describeInputLibraryArgs| ()
 "Describe the set input library arguments"
 (|sayBrightly| (list
  " )set compile input add library "
  "is used to tell AXIOM to add library to"
  '|%l| " the front of the path used to find compile code."
  '|%l|
  " )set compile input drop library is used to tell AXIOM to remove library"
  '|%l| " from this path.")))

\end{chunk}

\defunsec{addInputLibrary}{Add the input library to the list}
The input-libraries variable is now maintained as a list of truenames.
\calls{addInputLibrary}{dropInputLibrary}
\uses{addInputLibrary}{input-libraries}
\begin{chunk}{defun addInputLibrary}
(defun |addInputLibrary| (lib)
 "Add the input library to the list"
 (declare (special input-libraries))
  (|dropInputLibrary| lib)
  (push (truename lib) input-libraries))

\end{chunk}

\defvar{input-libraries}
\begin{chunk}{initvars}
(defvar input-libraries nil)

\end{chunk}

\defunsec{dropInputLibrary}{Drop an input library from the list}
\uses{dropInputLibrary}{input-libraries}
\begin{chunk}{defun dropInputLibrary}
(defun |dropInputLibrary| (lib) 
 "Drop an input library from the list"
 (declare (special input-libraries))
 (setq input-libraries (delete (truename lib) input-libraries :test #'equal)))

\end{chunk}

\section{\enspace{}set debug dalymode}
The \verb|$dalymode| variable is used in a case statement in 
intloopReadConsole. This variable can be set to any non-nil
value. When not nil the interpreter will send any line that begins
with an ``('' to be sent to the underlying lisp. This is useful
for debugging Axiom. The normal value of this variable is NIL.

This variable was created as an alternative to prefixing every lisp
command with )lisp. When doing a lot of debugging this is tedious
and error prone. This variable was created to shortcut that process.
Clearly it breaks some semantics of the language accepted by the
interpreter as parens are used for grouping expressions.

\begin{verbatim}
---------------------- The dalymode Option ----------------------

 Description: Interpret leading open paren as lisp

\end{verbatim}

\defvar{dalymode}
\begin{chunk}{initvars}
(defvar $dalymode nil "Interpret leading open paren as lisp")

\end{chunk}

\begin{chunk}{debugdalymode}
      (|dalymode|
       "Interpret leading open paren as lisp"
       |interpreter|
       LITERALS
       $dalymode
       (|on| |off|)
       |off|)
\end{chunk}

\section{\enspace{}set expose}
\begin{verbatim}
---------------------- The expose Option ----------------------

 Description: control interpreter constructor exposure

   The following groups are explicitly exposed in the current 
   frame (called initial ):
                                   basic                                   
                                categories                                 
                                  naglink                                  
                                   anna                                    
 
   The following constructors are explicitly exposed in the 
   current frame:
               there are no explicitly exposed constructors                
 
   The following constructors are explicitly hidden in the 
   current frame:
                there are no explicitly hidden constructors                
 
   When )set expose is followed by no arguments, the information
   you now see is displayed. When followed by the initialize 
   argument, the exposure group data in the file interp.exposed 
   is read and is then available. The arguments add and drop are 
   used to add or drop exposure groups or explicit constructors 
   from the local frame exposure data. Issue
                  )set expose add    or    )set expose drop 
   for more information.
\end{verbatim}

\begin{chunk}{expose}
  (|expose|
   "control interpreter constructor exposure"
   |interpreter|
   FUNCTION
   |setExpose|
   NIL
   |htSetExpose|)
\end{chunk}

\subsection{functions}
\begin{verbatim}
             Current Values of  functions  Variables                  

Variable     Description                           Current Value
-----------------------------------------------------------------
cache        number of function results to cache        0 
compile      compile, don't just define function bodies off 
recurrence   specially compile recurrence relations     on 

\end{verbatim}
\begin{chunk}{functions}
  (|functions|
   "some interpreter function options"
   |interpreter|
   TREE
   |novar|
   (
\getchunk{functionscache}
\getchunk{functionscompile}
\getchunk{functionsrecurrence}
  ))

\end{chunk}
\subsection{functions cache}
\begin{verbatim}
---------------------- The cache Option -----------------------

 Description: number of function results to cache

 )set functions cache is used to tell AXIOM how many  values 
  computed by interpreter functions should be saved.  This can 
  save quite a bit of time in recursive functions, though one 
  must consider that the cached values will take up (perhaps 
  valuable) room in the workspace.

 The value given  after cache must either be the word all or 
 a positive integer. This may be followed by any number of 
 function names whose cache sizes you wish to so set.  If no 
 functions are given, the default cache  size is set.

 Examples:   )set fun cache all
             )set fun cache 10 f g Legendre

 In general, functions will cache no returned values.
\end{verbatim}
\begin{chunk}{functionscache}
     (|cache|
      "number of function results to cache"
      |interpreter|
      FUNCTION
      |setFunctionsCache|
      NIL
      |htSetCache|)
\end{chunk}

\defdollar{cacheAlist}
\begin{chunk}{initvars}
(defvar |$cacheAlist| nil) 

\end{chunk}

\defunsec{setFunctionsCache}{The top level set functions cache handler}
\calls{setFunctionsCache}{object2String}
\calls{setFunctionsCache}{describeSetFunctionsCache}
\calls{setFunctionsCache}{sayAllCacheCounts}
\calls{setFunctionsCache}{sayMessage}
\calls{setFunctionsCache}{bright}
\calls{setFunctionsCache}{terminateSystemCommand}
\calls{setFunctionsCache}{countCache}
\usesdollar{setFunctionsCache}{options}
\usesdollar{setFunctionsCache}{cacheCount}
\usesdollar{setFunctionsCache}{cacheAlist}
\begin{chunk}{defun setFunctionsCache}
(defun |setFunctionsCache| (arg)
 "The top level set functions cache handler"
 (let (|$options| n)
  (declare (special |$options| |$cacheCount| |$cacheAlist|))
  (cond
    ((eq arg '|%initialize%|)
      (setq |$cacheCount| 0)
      (setq |$cacheAlist| nil))
    ((eq arg '|%display%|)
      (if (null |$cacheAlist|)
       (|object2String| |$cacheCount|)
       "..."))
    ((or (null arg) (eq arg '|%describe%|) (eq (car arg) '?))
      (|describeSetFunctionsCache|)
      (terpri)
      (|sayAllCacheCounts|))
    (t
      (setq n (car arg))
      (cond
       ((and (not (eq n '|all|)) (or (null (integerp n)) (minusp n)))
        (|sayMessage|
         `("Your value of" ,@(|bright| n) "is invalid because ..."))
        (|describeSetFunctionsCache|)
        (|terminateSystemCommand|))
       (t
        (when (cdr arg) (list (cons '|vars| (cdr arg))))
        (|countCache| n)))))))

\end{chunk}

\defunsec{countCache}{Display a particular cache count}
\calls{countCache}{qcdr}
\calls{countCache}{qcar}
\calls{countCache}{identp}
\calls{countCache}{sayKeyedMsg}
\calls{countCache}{insertAlist}
\calls{countCache}{internl}
\calls{countCache}{sayCacheCount}
\calls{countCache}{optionError}
\usesdollar{countCache}{options}
\usesdollar{countCache}{cacheAlist}
\usesdollar{countCache}{cacheCount}
\begin{chunk}{defun countCache}
(defun |countCache| (n)
 "Display a particular cache count"
 (let (tmp1 l cachecountname)
 (declare (special |$options| |$cacheAlist| |$cacheCount|))
 (cond 
  (|$options|
   (cond
    ((and (consp |$options|)
          (eq (qcdr |$options|) nil)
          (progn 
           (setq tmp1 (qcar |$options|))
           (and (consp tmp1)
                (eq (qcar tmp1) '|vars|)
                (progn (setq l (qcdr tmp1)) t))))
     (dolist (x l)
       (if (null (identp x))
         (|sayKeyedMsg| "%1 is not a valid function name." (list x))
         (progn
          (setq |$cacheAlist| (|insertAlist| x n |$cacheAlist|))
          (setq cachecountname (internl x ";COUNT"))
          (set cachecountname n)
          (|sayCacheCount| x n)))))
    (t (|optionError| (caar |$options|) nil))))
  (t
   (|sayCacheCount| nil (setq |$cacheCount| n))))))

\end{chunk}

\defun{insertAlist}{insertAlist}
\calls{insertAlist}{rplac}
\calls{insertAlist}{?order}
\begin{chunk}{defun insertAlist}
(defun |insertAlist| (a b z)
 (labels (
  (fn (a b z)
   (cond
    ((null (cdr z)) (rplac (cdr z) (list (cons a b))))
    ((equal a (elt (elt z 1) 0)) (rplac (cdr (elt z 1)) b))
    ((?order (elt (elt z 1) 0) a) (rplac (cdr z) (cons (cons a b) (cdr z))))
    (t (fn a b (cdr z))))))
  (cond
    ((null z) (list (cons a b)))
    ((equal a (elt (elt z 0) 0)) (rplac (cdar z) b) z)
    ((?order (elt (elt z 0) 0) a) (cons (cons a b) z))
    (t (fn a b z) z))))

\end{chunk}

\defunsec{describeSetFunctionsCache}{Describe the set functions cache}
\calls{describeSetFunctionsCache}{sayBrightly}
\begin{chunk}{defun describeSetFunctionsCache}
(defun |describeSetFunctionsCache| ()
 "Describe the set functions cache"
 (|sayBrightly| (list
  " )set functions cache "
  "is used to tell AXIOM how many"
  '|%l| " values computed by interpreter functions should be saved.  This"
  '|%l| " can save quite a bit of time in recursive functions, though one" 
  '|%l| " must consider that the cached values will take up (perhaps"
  '|%l| " valuable) room in the workspace."
  '|%l|
  '|%l| " The value given after "
   "cache must either be the word all or a positive integer."
  '|%l| " This may be followed by any number of function names whose cache"
  '|%l| " sizes you wish to so set.  If no functions are given, the default" 
  '|%l| " cache size is set."
  '|%l|
  '|%l|  " Examples:"
  '|%l|  "   )set fun cache all         )set fun cache 10 f g Legendre")))

\end{chunk}

\defunsec{sayAllCacheCounts}{Display all cache counts}
\calls{sayAllCacheCounts}{sayCacheCount}
\usesdollar{sayAllCacheCounts}{cacheCount}
\usesdollar{sayAllCacheCounts}{cacheAlist}
\begin{chunk}{defun sayAllCacheCounts}
(defun |sayAllCacheCounts| ()
 "Display all cache counts"
 (let (x n)
 (declare (special |$cacheCount| |$cacheAlist|))
   (|sayCacheCount| nil |$cacheCount|)
   (when |$cacheAlist|
     (do ((t0 |$cacheAlist| (cdr t0)) (t1 nil))
         ((or (atom t0)
              (progn (setq t1 (car t0)) nil)
              (progn
               (progn (setq x (car t1)) (setq n (cdr t1)) t1)
               nil)) 
             nil)
       (when (not (equal n |$cacheCount|)) (|sayCacheCount| x n))))))

\end{chunk}

\defunsec{sayCacheCount}{Describe the cache counts}
\calls{sayCacheCount}{bright}
\calls{sayCacheCount}{linearFormatName}
\calls{sayCacheCount}{sayBrightly}
\begin{chunk}{defun sayCacheCount}
(defun |sayCacheCount| (fn n)
 "Describe the cache counts"
 (let (prefix phrase)
    (setq prefix
     (cond 
      (fn (cons 'function (|bright| (|linearFormatName| fn))))
      ((eql n 0) (list '|interpreter functions |))
      (t (list '|In general, interpreter functions |))))
    (cond
     ((eql n 0)
      (cond
       (fn
        (|sayBrightly|
         `("   Caching for " ,prefix "is turned off")))
       (t 
        (|sayBrightly| " In general, functions will cache no returned values."
         ))))
     (t
      (setq phrase
       (cond
        ((eq n '|all|) `(,@(|bright| '|all|) |values.|))
        ((eql n 1) (list '| only the last value.|))
        (t `(| the last| ,@(|bright| n) |values.|))))
      (|sayBrightly| 
       `("   " ,@prefix "will cache" ,@phrase))))))

\end{chunk}

\subsection{functions compile}
\begin{verbatim}
--------------------- The compile Option ----------------------

 Description: compile, don't just define function bodies

 The compile option may be followed by any one of the following:

 -> on
    off 

 The current setting is indicated.

\defdollar{compileDontDefineFunctions}
\begin{chunk}{initvars}
(defvar |$compileDontDefineFunctions| t
   "compile, don't just define function bodies")

\end{chunk}
\begin{chunk}{functionscompile}
     (|compile|
      "compile, don't just define function bodies"
      |interpreter|
      LITERALS
      |$compileDontDefineFunctions|
      (|on| |off|)
      |on|)
\end{chunk}
\subsection{functions recurrence}
\begin{verbatim}
-------------------- The recurrence Option --------------------

 Description: specially compile recurrence relations

 The recurrence option may be followed by any one of the 
 following:

 -> on 
    off

 The current setting is indicated.

\end{verbatim}
\defdollar{compileRecurrence}
\begin{chunk}{initvars}
(defvar |$compileRecurrence| t "specially compile recurrence relations")

\end{chunk}
\begin{chunk}{functionsrecurrence}
     (|recurrence|
      "specially compile recurrence relations"
      |interpreter|
      LITERALS
      |$compileRecurrence|
      (|on| |off|)
      |on|)
\end{chunk}
\section{\enspace{}set fortran}
\begin{verbatim}
              Current Values of  fortran  Variables                   

Variable     Description                           Current Value
-----------------------------------------------------------------
ints2floats  where sensible, coerce integers to reals   on 
fortindent   the number of characters indented          6 
fortlength   the number of characters on a line         72 
typedecs     print type and dimension lines             on 
defaulttype  default generic type for FORTRAN object    REAL 
precision    precision of generated FORTRAN objects     double 
intrinsic    whether to use INTRINSIC FORTRAN functions off 
explength    character limit for FORTRAN expressions    1320 
segment      split long FORTRAN expressions             on 
optlevel     FORTRAN optimisation level                 0 
startindex   starting index for FORTRAN arrays          1 
calling      options for external FORTRAN calls         ... 

Variables with current values of ... have further sub-options. 
For example, issue )set calling to see what the options are for 
calling.
For more information, issue )help set .
\end{verbatim}
\begin{chunk}{fortran}
  (|fortran|
   "view and set options for FORTRAN output"
   |interpreter|
   TREE
   |novar|
    (
\getchunk{fortranints2floats}
\getchunk{fortranfortindent}
\getchunk{fortranfortlength}
\getchunk{fortrantypedecs}
\getchunk{fortrandefaulttype}
\getchunk{fortranprecision}
\getchunk{fortranintrinsic}
\getchunk{fortranexplength}
\getchunk{fortransegment}
\getchunk{fortranoptlevel}
\getchunk{fortranstartindex}
\getchunk{fortrancalling}
  ))

\end{chunk}
\subsection{set ints2floats}
\begin{verbatim}
------------------- The ints2floats Option --------------------

 Description: where sensible, coerce integers to reals

 The ints2floats option may be followed by any one of the 
 following:

 -> on 
    off

 The current setting is indicated.

\end{verbatim}
\defdollar{fortInts2Floats}
\begin{chunk}{initvars}
(defvar |$fortInts2Floats| t "where sensible, coerce integers to reals")

\end{chunk}
\begin{chunk}{fortranints2floats}
     (|ints2floats|
      "where sensible, coerce integers to reals"
      |interpreter|
      LITERALS
      |$fortInts2Floats|
      (|on| |off|)
      |on|)
\end{chunk}
\subsection{set fortindent}
\begin{verbatim}
-------------------- The fortindent Option --------------------

 Description: the number of characters indented

 The fortindent option may be followed by an integer in the range 
 0 to inclusive. The current setting is 6 

\end{verbatim}
\defdollar{fortIndent}
\begin{chunk}{initvars}
(defvar |$fortIndent| 6 "the number of characters indented")

\end{chunk}
\begin{chunk}{fortranfortindent}
     (|fortindent|
      "the number of characters indented"
      |interpreter|
      INTEGER
      |$fortIndent|
      (0 NIL)
      6)
\end{chunk}
\subsection{set fortlength}
\begin{verbatim}
-------------------- The fortlength Option --------------------

 Description: the number of characters on a line

 The fortlength option may be followed by an integer in the range 
 1 to inclusive. The current setting is 72 

\end{verbatim}
\defdollar{fortLength}
\begin{chunk}{initvars}
(defvar |$fortLength| 72 "the number of characters on a line")

\end{chunk}
\begin{chunk}{fortranfortlength}
     (|fortlength|
      "the number of characters on a line"
      |interpreter|
      INTEGER
      |$fortLength|
      (1 NIL)
      72)
\end{chunk}
\subsection{set typedecs}
\begin{verbatim}
--------------------- The typedecs Option ---------------------

 Description: print type and dimension lines

 The typedecs option may be followed by any one of the 
 following:

 -> on 
    off

 The current setting is indicated.

\end{verbatim}
\defdollar{printFortranDecs}
\begin{chunk}{initvars}
(defvar |$printFortranDecs| t "print type and dimension lines")

\end{chunk}
\begin{chunk}{fortrantypedecs}
     (|typedecs|
      "print type and dimension lines"
      |interpreter|
      LITERALS
      |$printFortranDecs|
      (|on| |off|)
      |on|)
\end{chunk}
\subsection{set defaulttype}
\begin{verbatim}
------------------- The defaulttype Option --------------------

 Description: default generic type for FORTRAN object

 The defaulttype option may be followed by any one of the 
 following:

 -> REAL 
    INTEGER
    COMPLEX
    LOGICAL
    CHARACTER

 The current setting is indicated.

\end{verbatim}
\defdollar{defaultFortranType}
\begin{chunk}{initvars}
(defvar |$defaultFortranType| 'real "default generic type for FORTRAN object")

\end{chunk}
\begin{chunk}{fortrandefaulttype}
     (|defaulttype|
      "default generic type for FORTRAN object"
      |interpreter|
      LITERALS
      |$defaultFortranType|
      (REAL INTEGER COMPLEX LOGICAL CHARACTER)
      REAL)
\end{chunk}
\subsection{set precision}
\begin{verbatim}
-------------------- The precision Option ---------------------

 Description: precision of generated FORTRAN objects

 The precision option may be followed by any one of the 
 following:

    single
 -> double 

 The current setting is indicated.

\end{verbatim}
\defdollar{fortranPrecision}
\begin{chunk}{initvars}
(defvar |$fortranPrecision| '|double| "precision of generated FORTRAN objects")

\end{chunk}
\begin{chunk}{fortranprecision}
      (|precision|
      "precision of generated FORTRAN objects"
       |interpreter|
       LITERALS
       |$fortranPrecision|
       (|single| |double|)
       |double|)
\end{chunk}
\subsection{set intrinsic}
\begin{verbatim}
-------------------- The intrinsic Option ---------------------

 Description: whether to use INTRINSIC FORTRAN functions

 The intrinsic option may be followed by any one of the 
 following:

    on
 -> off 

 The current setting is indicated.

\end{verbatim}
\defdollar{useIntrinsicFunctions}
\begin{chunk}{initvars}
(defvar |$useIntrinsicFunctions| nil
   "whether to use INTRINSIC FORTRAN functions")

\end{chunk}
\begin{chunk}{fortranintrinsic}
      (|intrinsic|
       "whether to use INTRINSIC FORTRAN functions"
       |interpreter|
       LITERALS
       |$useIntrinsicFunctions|
       (|on| |off|)
       |off|)
\end{chunk}
\subsection{set explength}
\begin{verbatim}
-------------------- The explength Option ---------------------

 Description: character limit for FORTRAN expressions

 The explength option may be followed by an integer in the range 
 0 to inclusive. The current setting is 1320 

\end{verbatim}
\defdollar{maximumFortranExpressionLength}
\begin{chunk}{initvars}
(defvar |$maximumFortranExpressionLength| 1320
  "character limit for FORTRAN expressions")

\end{chunk}
\begin{chunk}{fortranexplength}
      (|explength|
       "character limit for FORTRAN expressions"
       |interpreter|
       INTEGER
       |$maximumFortranExpressionLength|
       (0 NIL)
       1320)
\end{chunk}
\subsection{set segment}
\begin{verbatim}
--------------------- The segment Option ----------------------

 Description: split long FORTRAN expressions

 The segment option may be followed by any one of the following:

 -> on 
    off

 The current setting is indicated.

\end{verbatim}
\defdollar{fortranSegment}
\begin{chunk}{initvars}
(defvar |$fortranSegment| t "split long FORTRAN expressions")

\end{chunk}
\begin{chunk}{fortransegment}
      (|segment|
       "split long FORTRAN expressions"
       |interpreter|
       LITERALS
       |$fortranSegment|
       (|on| |off|)
       |on|)
\end{chunk}
\subsection{set optlevel}
\begin{verbatim}
--------------------- The optlevel Option ---------------------

 Description: FORTRAN optimisation level

 The optlevel option may be followed by an integer in the range 
 0 to 2 inclusive. The current setting is 0 

\end{verbatim}
\defdollar{fortranOptimizationLevel}
\begin{chunk}{initvars}
(defvar |$fortranOptimizationLevel| 0 "FORTRAN optimisation level")

\end{chunk}
\begin{chunk}{fortranoptlevel}
      (|optlevel|
       "FORTRAN optimisation level"
       |interpreter|
       INTEGER
       |$fortranOptimizationLevel|
       (0 2)
       0)
\end{chunk}
\subsection{set startindex}
\begin{verbatim}
-------------------- The startindex Option --------------------

 Description: starting index for FORTRAN arrays

 The startindex option may be followed by an integer in the range 
 0 to 1 inclusive. The current setting is 1 

\end{verbatim}
\defdollar{fortranArrayStartingIndex}
\begin{chunk}{initvars}
(defvar |$fortranArrayStartingIndex| 1 "starting index for FORTRAN arrays")

\end{chunk}
\begin{chunk}{fortranstartindex}
      (|startindex|
       "starting index for FORTRAN arrays"
       |interpreter|
       INTEGER
       |$fortranArrayStartingIndex|
       (0 1)
       1)
\end{chunk}
\subsection{set calling}
\begin{verbatim}
              Current Values of  calling  Variables                   

Variable     Description                           Current Value
-----------------------------------------------------------------
tempfile     set location of temporary data files       /tmp/ 
directory    set location of generated FORTRAN files    ./ 
linker       linker arguments (e.g. libraries to search) -lxlf 

\end{verbatim}
\begin{chunk}{fortrancalling}
      (|calling|
      "options for external FORTRAN calls"
      |interpreter|
      TREE
      |novar|
      (
\getchunk{callingtempfile}
\getchunk{callingdirectory}
\getchunk{callinglinker}
       )
      )

\end{chunk}
\subsubsection{set tempfile}
\begin{verbatim}
--------------------- The tempfile Option ---------------------

 Description: set location of temporary data files

 )set fortran calling tempfile  is used to tell AXIOM where
 to place intermediate FORTRAN data files . This must be the 
 name of a valid existing directory to which you have permission 
 to write (including the final slash).

 Syntax:
   )set fortran calling tempfile DIRECTORYNAME

 The current setting is /tmp/ 
\end{verbatim}
\defdollar{fortranTmpDir}
\begin{chunk}{initvars}
(defvar |$fortranTmpDir| "/tmp/" "set location of temporary data files ")

\end{chunk}
\begin{chunk}{callingtempfile}
        (|tempfile|
         "set location of temporary data files "
         |interpreter|
         FUNCTION
         |setFortTmpDir|
         (("enter directory name for which you have write-permission "
           DIRECTORY
           |$fortranTmpDir|
           |chkDirectory|
           "/tmp/"))
         NIL)
\end{chunk}

\defunsec{setFortTmpDir}{The top level set fortran calling tempfile handler}
\calls{setFortTmpDir}{pname}
\calls{setFortTmpDir}{describeSetFortTmpDir}
\calls{setFortTmpDir}{validateOutputDirectory}
\calls{setFortTmpDir}{sayBrightly}
\calls{setFortTmpDir}{bright}
\usesdollar{setFortTmpDir}{fortranTmpDir}
\begin{chunk}{defun setFortTmpDir}
(defun |setFortTmpDir| (arg)
 "The top level set fortran calling tempfile handler"
 (let (mode)
   (declare (special |$fortranTmpDir|))
   (cond
    ((eq arg '|%initialize%|) (setq |$fortranTmpDir| "/tmp/"))
    ((eq arg '|%display%|)
     (if (stringp |$fortranTmpDir|)
      |$fortranTmpDir|
      (pname |$fortranTmpDir|)))
    ((or (null arg) (eq arg '|%describe%|) (eq (car arg) '?))
     (|describeSetFortTmpDir|))
    ((null (setq mode (|validateOutputDirectory| arg)))
     (|sayBrightly| 
      `(" Sorry, but your argument(s)" ,@(|bright| arg) 
            "is(are) not valid." |%l|))
      (|describeSetFortTmpDir|))
    (t (setq |$fortranTmpDir| mode)))))

\end{chunk}

\defunsec{validateOutputDirectory}{Validate the output directory}
\begin{chunk}{defun validateOutputDirectory}
(defun |validateOutputDirectory| (x)
 "Validate the output directory"
 (let ((dirname (car x)))
  (when (and (pathname-directory (string dirname)) (null (probe-file dirname)))
   dirname)))

\end{chunk}

\defunsec{describeSetFortTmpDir}{Describe the set fortran calling tempfile}
\calls{describeSetFortTmpDir}{sayBrightly}
\usesdollar{describeSetFortTmpDir}{fortranTmpDir}
\begin{chunk}{defun describeSetFortTmpDir}
(defun |describeSetFortTmpDir| ()
 "Describe the set fortran calling tempfile"
 (declare (special |$fortranTmpDir|))
 (|sayBrightly| (list
  " )set fortran calling tempfile"
  " is used to tell AXIOM where"
  '|%l| " to place intermediate FORTRAN data files . This must be the "
  '|%l| " name of a valid existing directory to which you have permission "
  '|%l| " to write (including the final slash)."
  '|%l|
  '|%l| " Syntax:"
  '|%l| "   )set fortran calling tempfile DIRECTORYNAME"
  '|%l|
  '|%l| " The current setting is "
  |$fortranTmpDir|
  )))

\end{chunk}


\subsubsection{directory}
\begin{verbatim}
-------------------- The directory Option ---------------------

 Description: set location of generated FORTRAN files

 )set fortran calling directory  is used to tell AXIOM where
 to place generated FORTRAN files. This must be the name 
 of a valid existing directory to which you have permission 
 to write (including the final slash).

 Syntax:
   )set fortran calling directory DIRECTORYNAME

 The current setting is ./ 
\end{verbatim}
\defdollar{fortranDirectory}
\begin{chunk}{initvars}
(defvar |$fortranDirectory| "./" "set location of generated FORTRAN files ")

\end{chunk}
\begin{chunk}{callingdirectory}
        (|directory|
         "set location of generated FORTRAN files "
         |interpreter|
         FUNCTION
         |setFortDir|
         (("enter directory name for which you have write-permission "
           DIRECTORY
           |$fortranDirectory|
           |chkDirectory|
           "./"))
         NIL)
\end{chunk}

\defun{setFortDir}{setFortDir}
\calls{setFortDir}{pname}
\calls{setFortDir}{describeSetFortDir}
\calls{setFortDir}{validateOutputDirectory}
\calls{setFortDir}{sayBrightly}
\calls{setFortDir}{bright}
\usesdollar{setFortDir}{fortranDirectory}
\begin{chunk}{defun setFortDir}
(defun |setFortDir| (arg)
 (declare (special |$fortranDirectory|))
 (let (mode)
   (COND
    ((eq arg '|%initialize%|) (setq |$fortranDirectory| "./"))
    ((eq arg '|%display%|)
     (if (stringp |$fortranDirectory|) 
      |$fortranDirectory|
      (pname |$fortranDirectory|)))
    ((or (null arg) (eq arg '|%describe%|) (eq (car arg) '?))
      (|describeSetFortDir|))
    ((null (setq mode (|validateOutputDirectory| arg)))
     (|sayBrightly|
      `(" Sorry, but your argument(s)" ,@(|bright| arg) 
        "is(are) not valid." |%l|))
     (|describeSetFortDir|))
    (t (setq |$fortranDirectory| mode)))))

\end{chunk}
\defun{describeSetFortDir}{describeSetFortDir}
\calls{describeSetFortDir}{sayBrightly}
\usesdollar{describeSetFortDir}{fortranDirectory}
\begin{chunk}{defun describeSetFortDir}
(defun |describeSetFortDir| ()
 (declare (special |$fortranDirectory|))
 (|sayBrightly| (list
  " )set fortran calling directory"
  " is used to tell AXIOM where"
  '|%l| " to place generated FORTRAN files. This must be the name "
  '|%l| " of a valid existing directory to which you have permission "
  '|%l| " to write (including the final slash)."
  '|%l|
  '|%l| " Syntax:"
  '|%l| "   )set fortran calling directory DIRECTORYNAME"
  '|%l|
  '|%l| " The current setting is "
  |$fortranDirectory|
  )))

\end{chunk}
\subsubsection{linker}
\begin{verbatim}
---------------------- The linker Option ----------------------

 Description: linker arguments (e.g. libraries to search)

 )set fortran calling linkerargs is used to pass arguments to 
 the linker when using  mkFort  to create functions which call 
 Fortran code. For example, it might give a list of libraries 
 to be searched, and their locations.
 The string is passed verbatim, so must be the correct syntax for
 the particular linker being used.

 Example: )set fortran calling linker "-lxlf"

 The current setting is -lxlf 
\end{verbatim}
\defdollar{fortranLibraries}
\begin{chunk}{initvars}
(defvar |$fortranLibraries| "-lxlf" 
  "linker arguments (e.g. libraries to search)")

\end{chunk}
\begin{chunk}{callinglinker}
        (|linker|
         "linker arguments (e.g. libraries to search) "
         |interpreter|
         FUNCTION
         |setLinkerArgs|
         (("enter linker arguments "
           STRING
           |$fortranLibraries|
           |chkDirectory|
           "-lxlf"))
         NIL
         )
\end{chunk}

\defun{setLinkerArgs}{setLinkerArgs}
\calls{setLinkerArgs}{object2String}
\calls{setLinkerArgs}{describeSetLinkerArgs}
\usesdollar{setLinkerArgs}{fortranLibraries}
\begin{chunk}{defun setLinkerArgs}
(defun |setLinkerArgs| (arg)
 (declare (special |$fortranLibraries|))
 (cond
  ((eq arg '|%initialize%|) (setq |$fortranLibraries| "-lxlf"))
  ((eq arg '|%display%|) (|object2String| |$fortranLibraries|))
  ((or (null arg) (eq arg '|%describe%|) (eq (car arg) '?))
    (|describeSetLinkerArgs|))
  ((and (listp arg) (stringp (car arg)))
    (setq |$fortranLibraries| (car arg)))
  (t (|describeSetLinkerArgs|)))) 

\end{chunk}

\defun{describeSetLinkerArgs}{describeSetLinkerArgs}
\calls{describeSetLinkerArgs}{sayBrightly}
\usesdollar{describeSetLinkerArgs}{fortranLibraries}
\begin{chunk}{defun describeSetLinkerArgs}
(defun |describeSetLinkerArgs| ()
 (declare (special |$fortranLibraries|))
 (|sayBrightly| (list
  " )set fortran calling linkerargs"
  " is used to pass arguments to the linker"
  '|%l| " when using "
  "mkFort to create functions which call Fortran code."
  '|%l| " For example, it might give a list of libraries to be searched,"
  '|%l| " and their locations."
  '|%l| " The string is passed verbatim, so must be the correct syntax for"
  '|%l| " the particular linker being used."
  '|%l|
  '|%l| " Example: )set fortran calling linker \"-lxlf\""
  '|%l|
  '|%l| " The current setting is "
  |$fortranLibraries|
  )))

\end{chunk}

\section{\enspace{}set hyperdoc}
\begin{verbatim}
             Current Values of  hyperdoc  Variables                   

Variable     Description                           Current Value
-----------------------------------------------------------------
fullscreen   use full screen for this facility          off
mathwidth    screen width for history output            120 

\end{verbatim}
\begin{chunk}{hyperdoc}
  (|hyperdoc|
   "options in using HyperDoc"
   |interpreter|
   TREE
   |novar|
   (
\getchunk{hyperdocfullscreen}
\getchunk{hyperdocmathwidth}
   ))
\end{chunk}
\subsection{fullscreen}
\begin{verbatim}
-------------------- The fullscreen Option --------------------

 Description: use full screen for this facility

 The fullscreen option may be followed by any one of the 
 following:

    on
 -> off 

 The current setting is indicated.

\end{verbatim}
\defdollar{fullScreenSysVars}
\begin{chunk}{initvars}
(defvar |$fullScreenSysVars| nil "use full screen for this facility")

\end{chunk}
\begin{chunk}{hyperdocfullscreen}
     (|fullscreen|
      "use full screen for this facility"
      |interpreter|
      LITERALS
      |$fullScreenSysVars|
      (|on| |off|)
      |off|)
\end{chunk}
\subsection{mathwidth}
\begin{verbatim}
-------------------- The mathwidth Option ---------------------

 Description: screen width for history output

 The mathwidth option may be followed by an integer in the range 
 0 to inclusive. The current setting is 120 

\end{verbatim}
\defdollar{historyDisplayWidth}
\begin{chunk}{initvars}
(defvar |$historyDisplayWidth| 120 "screen width for history output")

\end{chunk}
\begin{chunk}{hyperdocmathwidth}
     (|mathwidth|
      "screen width for history output"
      |interpreter|
      INTEGER
      |$historyDisplayWidth|
      (0 NIL)
      120)
\end{chunk}

\section{\enspace{}set help}
\begin{verbatim}
               Current Values of  help  Variables                     

Variable     Description                           Current Value
-----------------------------------------------------------------
fullscreen   use fullscreen facility, if possible       on 

\end{verbatim}
\begin{chunk}{help}
  (|help|
   "view and set some help options"
   |interpreter|
   TREE
   |novar|
   (
\getchunk{helpfullscreen}
   ))

\end{chunk}
\subsection{fullscreen}
\begin{verbatim}
-------------------- The fullscreen Option --------------------

 Description: use fullscreen facility, if possible

 The fullscreen option may be followed by any one of the 
 following:

 -> on
   off 

 The current setting is indicated.

\end{verbatim}
\defdollar{useFullScreenHelp}
\begin{chunk}{initvars}
(defvar |$useFullScreenHelp| t "use fullscreen facility, if possible")

\end{chunk}
\begin{chunk}{helpfullscreen}
    (|fullscreen|
     "use fullscreen facility, if possible"
     |interpreter|
     LITERALS
     |$useFullScreenHelp|
     (|on| |off|)
     |on|)
\end{chunk}

\section{\enspace{}set history}
\begin{verbatim}
--------------------- The history Option ----------------------

 Description: save workspace values in a history file

 The history option may be followed by any one of the 
 following:

 -> on 
    off

 The current setting is indicated.

\end{verbatim}
\defdollar{HiFiAccess}
\begin{chunk}{initvars}
(defvar |$HiFiAccess| t "save workspace values in a history file")

\end{chunk}
\begin{chunk}{history}
  (|history|
   "save workspace values in a history file"
   |interpreter|
   LITERALS
   |$HiFiAccess|
   (|on| |off|)
   |on|)
\end{chunk}

\section{\enspace{}set messages}
\begin{verbatim}
             Current Values of  messages  Variables                   

Variable     Description                           Current Value
-----------------------------------------------------------------
autoload     print file auto-load messages              off 
bottomup     display bottom up modemap selection        off 
coercion     display datatype coercion messages         off 
dropmap      display old map defn when replaced         off 
expose       warning for unexposed functions            off 
file         print msgs also to SPADMSG LISTING         off 
frame        display messages about frames              off 
highlighting use highlighting in system messages        off 
instant      present instantiation summary              off 
insteach     present instantiation info                 off 
interponly   say when function code is interpreted      on 
number       display message number with message        off 
prompt       set type of input prompt to display        step 
selection    display function selection msgs            off 
set          show )set setting after assignment         off 
startup      display messages on start-up               off 
summary      print statistics after computation         off 
testing      print system testing header                off 
time         print timings after computation            off 
type         print type after computation               on 
void         print Void value when it occurs            off 
any          print the internal type of objects of domain Any on 
naglink      show NAGLink messages                      on 

\end{verbatim}
\begin{chunk}{messages}
  (|messages|
   "show messages for various system features"
   |interpreter|
   TREE
   |novar|
   (
\getchunk{messagesany}
\getchunk{messagesautoload}
\getchunk{messagesbottomup}
\getchunk{messagescoercion}
\getchunk{messagesdropmap}
\getchunk{messagesexpose}
\getchunk{messagesfile}
\getchunk{messagesframe}
\getchunk{messageshighlighting}
\getchunk{messagesinstant}
\getchunk{messagesinsteach}
\getchunk{messagesinterponly}
\getchunk{messagesnaglink}
\getchunk{messagesnumber}
\getchunk{messagesprompt}
\getchunk{messagesselection}
\getchunk{messagesset}
\getchunk{messagesstartup}
\getchunk{messagessummary}
\getchunk{messagestesting}
\getchunk{messagestime}
\getchunk{messagestype}
\getchunk{messagesvoid}
   ))

\end{chunk}

\subsection{set message any}
\begin{verbatim}
----------------------- The any Option ------------------------

 Description: print the internal type of objects of domain Any

 The any option may be followed by any one of the following:

 -> on 
    off

 The current setting is indicated.

\end{verbatim}
\defdollar{printAnyIfTrue}
\begin{chunk}{initvars}
(defvar |$printAnyIfTrue| t
   "print the internal type of objects of domain Any")

\end{chunk}
\begin{chunk}{messagesany}
     (|any|
      "print the internal type of objects of domain Any"
      |interpreter|
      LITERALS
      |$printAnyIfTrue|
      (|on| |off|)
      |on|)
\end{chunk}

\subsection{set message autoload}
\begin{verbatim}
--------------------- The autoload Option ---------------------

 Description: print file auto-load messages

\end{verbatim}
\defdollar{printLoadMsgs}
\begin{chunk}{initvars}
(defvar |$printLoadMsgs| nil "print file auto-load messages")

\end{chunk}
\begin{chunk}{messagesautoload}
     (|autoload|
      "print file auto-load messages"
      |interpreter|
      LITERALS
      |$printLoadMsgs|
      (|on| |off|)
      |on|)

\end{chunk}

\subsection{set message bottomup}
\begin{verbatim}
--------------------- The bottomup Option ---------------------

 Description: display bottom up modemap selection

 The bottomup option may be followed by any one of the 
 following:

    on
 -> off 

 The current setting is indicated.

\end{verbatim}
\defdollar{reportBottomUpFlag}
\begin{chunk}{initvars}
(defvar |$reportBottomUpFlag| nil "display bottom up modemap selection")

\end{chunk}
\begin{chunk}{messagesbottomup}
     (|bottomup|
      "display bottom up modemap selection"
      |development|
      LITERALS
      |$reportBottomUpFlag|
      (|on| |off|)
      |off|)

\end{chunk}

\subsection{set message coercion}
\begin{verbatim}
--------------------- The coercion Option ---------------------

 Description: display datatype coercion messages

 The coercion option may be followed by any one of the 
 following:

    on
 -> off 

 The current setting is indicated.

\end{verbatim}
\defdollar{reportCoerceIfTrue}
\begin{chunk}{initvars}
(defvar |$reportCoerceIfTrue| nil "display datatype coercion messages")

\end{chunk}
\begin{chunk}{messagescoercion}
     (|coercion|
      "display datatype coercion messages"
      |development|
      LITERALS
      |$reportCoerceIfTrue|
      (|on| |off|)
      |off|)

\end{chunk}

\subsection{set message dropmap}
\begin{verbatim}
--------------------- The dropmap Option ----------------------

 Description: display old map defn when replaced

 The dropmap option may be followed by any one of the 
 following:

    on
 -> off 

 The current setting is indicated.

\end{verbatim}
\defdollar{displayDroppedMap}
\begin{chunk}{initvars}
(defvar |$displayDroppedMap| nil "display old map defn when replaced")

\end{chunk}
\begin{chunk}{messagesdropmap}
     (|dropmap|
      "display old map defn when replaced"
      |interpreter|
      LITERALS
      |$displayDroppedMap|
      (|on| |off|)
      |off|)

\end{chunk}

\subsection{set message expose}
\begin{verbatim}
---------------------- The expose Option ----------------------

 Description: warning for unexposed functions

 The expose option may be followed by any one of the 
 following:

    on
 -> off 

 The current setting is indicated.

\end{verbatim}
\defdollar{giveExposureWarning}
\begin{chunk}{initvars}
(defvar |$giveExposureWarning| nil "warning for unexposed functions")

\end{chunk}
\begin{chunk}{messagesexpose}
     (|expose|
      "warning for unexposed functions"
      |interpreter|
      LITERALS
      |$giveExposureWarning|
      (|on| |off|)
      |off|)

\end{chunk}

\subsection{set message file}
\begin{verbatim}
----------------------- The file Option -----------------------

 Description: print msgs also to SPADMSG LISTING

 The file option may be followed by any one of the 
 following:

    on
 -> off 

 The current setting is indicated.

\end{verbatim}
\defdollar{printMsgsToFile}
\begin{chunk}{initvars}
(defvar |$printMsgsToFile| nil "print msgs also to SPADMSG LISTING")

\end{chunk}
\begin{chunk}{messagesfile}
     (|file|
      "print msgs also to SPADMSG LISTING"
      |development|
      LITERALS
      |$printMsgsToFile|
      (|on| |off|)
      |off|)

\end{chunk}

\subsection{set message frame}
\label{setmessageframe}
\begin{verbatim}
---------------------- The frame Option -----------------------

 Description: display messages about frames

 The frame option may be followed by any one of the following:

    on
 -> off 

 The current setting is indicated.

\end{verbatim}
\defdollar{frameMessages}
\begin{chunk}{initvars}
(defvar |$frameMessages| nil "display messages about frames")

\end{chunk}
\begin{chunk}{messagesframe}
     (|frame|
      "display messages about frames"
      |interpreter|
      LITERALS
      |$frameMessages|
      (|on| |off|)
      |off|)

\end{chunk}

\subsection{set message highlighting}
\begin{verbatim}
------------------- The highlighting Option -------------------

 Description: use highlighting in system messages

 The highlighting option may be followed by any one of the 
 following:

    on
 -> off 

 The current setting is indicated.

\end{verbatim}
\defdollar{highlightAllowed}
\begin{chunk}{initvars}
(defvar |$highlightAllowed| nil "use highlighting in system messages")

\end{chunk}
\begin{chunk}{messageshighlighting}
     (|highlighting|
      "use highlighting in system messages"
      |interpreter|
      LITERALS
      |$highlightAllowed|
      (|on| |off|)
      |off|)

\end{chunk}

\subsection{set message instant}
\begin{verbatim}
--------------------- The instant Option ----------------------

 Description: present instantiation summary

 The instant option may be followed by any one of the 
 following:

    on
 -> off 

 The current setting is indicated.

\end{verbatim}
\defdollar{reportInstantiations}
\begin{chunk}{initvars}
(defvar |$reportInstantiations| nil "present instantiation summary")

\end{chunk}
\begin{chunk}{messagesinstant}
     (|instant|
      "present instantiation summary"
      |development|
      LITERALS
      |$reportInstantiations|
      (|on| |off|)
      |off|)

\end{chunk}

\subsection{set message insteach}
\begin{verbatim}
--------------------- The insteach Option ---------------------

 Description: present instantiation info

 The insteach option may be followed by any one of the 
 following:

    on
 -> off 

 The current setting is indicated.

\end{verbatim}
\defdollar{reportEachInstantiation|}
\begin{chunk}{initvars}
(defvar |$reportEachInstantiation| nil "present instantiation info")

\end{chunk}
\begin{chunk}{messagesinsteach}
     (|insteach|
      "present instantiation info"
      |development|
      LITERALS
      |$reportEachInstantiation|
      (|on| |off|)
      |off|)

\end{chunk}

\subsection{set message interponly}
\begin{verbatim}
-------------------- The interponly Option --------------------

 Description: say when function code is interpreted

 The interponly option may be followed by any one of the 
 following:

 -> on 
    off

 The current setting is indicated.

\end{verbatim}
\defdollar{reportInterpOnly}
\begin{chunk}{initvars}
(defvar |$reportInterpOnly| t "say when function code is interpreted")

\end{chunk}
\begin{chunk}{messagesinterponly}
     (|interponly|
      "say when function code is interpreted"
      |interpreter|
      LITERALS
      |$reportInterpOnly|
      (|on| |off|)
      |on|)

\end{chunk}

\subsection{set message naglink}
\begin{verbatim}
--------------------- The naglink Option ----------------------

 Description: show NAGLink messages

 The naglink option may be followed by any one of the 
 following:

 -> on 
    off

 The current setting is indicated.

\end{verbatim}
\defdollar{nagMessages}
\begin{chunk}{initvars}
(defvar |$nagMessages| t "show NAGLink messages")

\end{chunk}
\begin{chunk}{messagesnaglink}
     (|naglink|
      "show NAGLink messages"
      |interpreter|
      LITERALS
      |$nagMessages|
      (|on| |off|)
      |on|)

\end{chunk}

\subsection{set message number}
\begin{verbatim}
---------------------- The number Option ----------------------

 Description: display message number with message

 The number option may be followed by any one of the 
 following:

    on
 -> off 

 The current setting is indicated.

\end{verbatim}
\defdollar{displayMsgNumber}
\begin{chunk}{initvars}
(defvar |$displayMsgNumber| nil "display message number with message")

\end{chunk}
\begin{chunk}{messagesnumber}
     (|number|
      "display message number with message"
      |interpreter|
      LITERALS
      |$displayMsgNumber|
      (|on| |off|)
      |off|)

\end{chunk}

\subsection{set message prompt}
\begin{verbatim}
---------------------- The prompt Option ----------------------

 Description: set type of input prompt to display

 The prompt option may be followed by any one of the following:

    none
    frame
    plain
 -> step 
    verbose

 The current setting is indicated.

\end{verbatim}
\defdollar{inputPromptType}
\begin{chunk}{initvars}
(defvar |$inputPromptType| '|step| "set type of input prompt to display")

\end{chunk}
\begin{chunk}{messagesprompt}
     (|prompt|
      "set type of input prompt to display"
      |interpreter|
      LITERALS
      |$inputPromptType|
      (|none| |frame| |plain| |step| |verbose|)
      |step|)

\end{chunk}

\subsection{set message selection}
\begin{verbatim}
-------------------- The selection Option ---------------------

 Description: display function selection msgs

 The selection option may be followed by any one of the 
 following:

    on
 -> off 

 The current setting is indicated.

\end{verbatim}

TPDHERE: This is a duplicate of )set mes bot on because both use the
\verb|$reportBottomUpFlag| flag
\index{\$reportBottomUpFlag}
\index{defvar!\$reportBottomUpFlag}
\index{\$reportBottomUpFlag!defvar}
\begin{chunk}{messagesselection}
     (|selection|
      "display function selection msgs"
      |interpreter|
      LITERALS
      |$reportBottomUpFlag|
      (|on| |off|)
      |off|)

\end{chunk}

\subsection{set}
\begin{verbatim}
----------------------- The set Option ------------------------

 Description: show )set setting after assignment

 The set option may be followed by any one of the following:

    on
 -> off 

 The current setting is indicated.

\end{verbatim}
\defdollar{displaySetValue}
\begin{chunk}{initvars}
(defvar |$displaySetValue| nil "show )set setting after assignment")

\end{chunk}
\begin{chunk}{messagesset}
     (|set|
      "show )set setting after assignment"
      |interpreter|
      LITERALS
      |$displaySetValue|
      (|on| |off|)
      |off|)

\end{chunk}
\subsection{set message startup}
\begin{verbatim}
--------------------- The startup Option ----------------------

 Description: display messages on start-up

 The startup option may be followed by any one of the 
 following:

    on
 -> off 

 The current setting is indicated.

\end{verbatim}
\defdollar{displayStartMsgs}
\begin{chunk}{initvars}
(defvar |$displayStartMsgs| t "display messages on start-up")

\end{chunk}
\begin{chunk}{messagesstartup}
     (|startup|
      "display messages on start-up"
      |interpreter|
      LITERALS
      |$displayStartMsgs|
      (|on| |off|)
      |on|)

\end{chunk}
\subsection{set message summary}
\begin{verbatim}
--------------------- The summary Option ----------------------

 Description: print statistics after computation

 The summary option may be followed by any one of the 
 following:

    on
 -> off 

 The current setting is indicated.

\end{verbatim}
\defdollar{printStatisticsSummaryIfTrue}
\begin{chunk}{initvars}
(defvar |$printStatisticsSummaryIfTrue| nil
     "print statistics after computation")

\end{chunk}
\begin{chunk}{messagessummary}
     (|summary|
      "print statistics after computation"
      |interpreter|
      LITERALS
      |$printStatisticsSummaryIfTrue|
      (|on| |off|)
      |off|)

\end{chunk}

\subsection{set message testing}
\begin{verbatim}
--------------------- The testing Option ----------------------

 Description: print system testing header

 The testing option may be followed by any one of the 
 following:

    on
 -> off 

 The current setting is indicated.

\end{verbatim}
\defdollar{testingSystem}
\begin{chunk}{initvars}
(defvar |$testingSystem| nil "print system testing header")

\end{chunk}
\begin{chunk}{messagestesting}
     (|testing|
      "print system testing header"
      |development|
      LITERALS
      |$testingSystem|
      (|on| |off|)
      |off|)

\end{chunk}

\subsection{set message time}
\begin{verbatim}
----------------------- The time Option -----------------------

 Description: print timings after computation

 The time option may be followed by any one of the following:

    on
 -> off 
    long

 The current setting is indicated.

\end{verbatim}
\defdollar{printTimeIfTrue}
\begin{chunk}{initvars}
(defvar |$printTimeIfTrue| nil "print timings after computation")

\end{chunk}
\begin{chunk}{messagestime}
     (|time|
      "print timings after computation"
      |interpreter|
      LITERALS
      |$printTimeIfTrue|
      (|on| |off| |long|)
      |off|)

\end{chunk}

\subsection{set message type}
\begin{verbatim}
----------------------- The type Option -----------------------

 Description: print type after computation

 The type option may be followed by any one of the following:

 -> on 
    off

 The current setting is indicated.

\end{verbatim}
\defdollar{printTypeIfTrue}
\begin{chunk}{initvars}
(defvar |$printTypeIfTrue| t "print type after computation")

\end{chunk}
\begin{chunk}{messagestype}
     (|type|
      "print type after computation"
      |interpreter|
      LITERALS
      |$printTypeIfTrue|
      (|on| |off|)
      |on|)

\end{chunk}

\subsection{set message void}
\begin{verbatim}
----------------------- The void Option -----------------------

 Description: print Void value when it occurs

 The void option may be followed by any one of the following:

    on
 -> off 

 The current setting is indicated.

\end{verbatim}
\defdollar{printVoidIfTrue}
\begin{chunk}{initvars}
(defvar |$printVoidIfTrue| nil "print Void value when it occurs")

\end{chunk}
\begin{chunk}{messagesvoid}
     (|void|
      "print Void value when it occurs"
      |interpreter|
      LITERALS
      |$printVoidIfTrue|
      (|on| |off|)
      |off|)

\end{chunk}

\section{\enspace{}set naglink}
\begin{verbatim}
              Current Values of  naglink  Variables                   

Variable     Description                           Current Value
-----------------------------------------------------------------
host         internet address of host for NAGLink       localhost 
persistence  number of (fortran) functions to remember  1 
messages     show NAGLink messages                      on 
double       enforce DOUBLE PRECISION ASPs              on 

\end{verbatim}
\begin{chunk}{naglink}
  (|naglink|
   "options for NAGLink"
   |interpreter|
   TREE
   |novar|
   (
\getchunk{naglinkhost}
\getchunk{naglinkpersistence}
\getchunk{naglinkmessages}
\getchunk{naglinkdouble}
   ))

\end{chunk}

\subsection{set naglink host}
\begin{verbatim}
----------------------- The host Option -----------------------

 Description: internet address of host for NAGLink

 )set naglink host is used to tell  AXIOM which  host to contact
 for a NAGLink request. An Internet address should be supplied. 
 The host specified must be running the NAGLink daemon.

 The current setting is localhost 
\end{verbatim}
\defdollar{nagHost}
\begin{chunk}{initvars}
(defvar |$nagHost| "localhost" "internet address of host for NAGLink")

\end{chunk}
\begin{chunk}{naglinkhost}
     (|host|
      "internet address of host for NAGLink "
      |interpreter|
      FUNCTION
      |setNagHost|
      (("enter host name"
        DIRECTORY
        |$nagHost|
        |chkDirectory|
        "localhost"))
      NIL)

\end{chunk}

\defun{setNagHost}{setNagHost}
\calls{setNagHost}{object2String}
\calls{setNagHost}{describeSetNagHost}
\usesdollar{setNagHost}{nagHost}
\begin{chunk}{defun setNagHost}
(defun |setNagHost| (arg)
 (declare (special |$nagHost|))
 (cond
  ((eq arg '|%initialize%|) (setq |$nagHost| "localhost"))
  ((eq arg '|%display%|) (|object2String| |$nagHost|))
  ((or (null arg) (eq arg '|%describe%|) (eq (car arg) '?)) 
   (|describeSetNagHost|))
  (t (setq |$nagHost| (|object2String| arg)))))

\end{chunk}

\defun{describeSetNagHost}{describeSetNagHost}
\calls{describeSetNagHost}{sayBrightly}
\usesdollar{describeSetNagHost}{nagHost}
\begin{chunk}{defun describeSetNagHost}
(defun |describeSetNagHost| ()
 (declare (special |$nagHost|))
 (|sayBrightly| (list
  " )set naglink host "
  "is used to tell  AXIOM which  host to contact for"
  '|%l| " a NAGLink request. An Internet address should be supplied. The host"
  '|%l| " specified must be running the NAGLink daemon."
  '|%l|
  '|%l| " The current setting is "
  |$nagHost|
  )))

\end{chunk}

\subsection{set naglink persistence}
\begin{verbatim}
------------------- The persistence Option --------------------

 Description: number of (fortran) functions to remember

 )set naglink persistence is used to tell  the  nagd  daemon how
  many ASP source and object files to keep around in case you 
  reuse them. This helps to avoid needless recompilations. The 
  number specified should be a non-negative integer.

 The current setting is 1 
\end{verbatim}
\defdollar{fortPersistence}
\begin{chunk}{initvars}
(defvar |$fortPersistence| 1 "number of (fortran) functions to remember")

\end{chunk}
\begin{chunk}{naglinkpersistence}
     (|persistence|
      "number of (fortran) functions to remember "
      |interpreter|
      FUNCTION
      |setFortPers|
      (("Requested remote storage (for asps):"
       INTEGER
       |$fortPersistence|
       (0 NIL)
       10))
      NIL)

\end{chunk}

\defun{setFortPers}{setFortPers}
\calls{setFortPers}{describeFortPersistence}
\calls{setFortPers}{sayMessage}
\calls{setFortPers}{bright}
\calls{setFortPers}{terminateSystemCommand}
\usesdollar{setFortPers}{fortPersistence}
\begin{chunk}{defun setFortPers}
(defun |setFortPers| (arg)
 (let (n)
 (declare (special |$fortPersistence|))
   (cond
    ((eq arg '|%initialize%|) (setq |$fortPersistence| 1))
    ((eq arg '|%display%|) |$fortPersistence|)
    ((or (null arg) (eq arg '|%describe%|) (eq (car arg) '?))
     (|describeFortPersistence|))
    (t
     (setq n (car arg))
     (cond
      ((or (null (integerp n)) (minusp n))
       (|sayMessage| 
        `("Your value of" ,@(|bright| n) "is invalid because ..."))
         (|describeFortPersistence|)
         (|terminateSystemCommand|))
      (t (setq |$fortPersistence| (car arg)))))))) 

\end{chunk}

\defun{describeFortPersistence}{describeFortPersistence}
\calls{describeFortPersistence}{sayBrightly}
\usesdollar{describeFortPersistence}{fortPersistence}
\begin{chunk}{defun describeFortPersistence}
(defun |describeFortPersistence| ()
 (declare (special |$fortPersistence|))
 (|sayBrightly| (list
 " )set naglink persistence "
 "is used to tell the "
 '|nagd|
 '| daemon how  many ASP|
 '|%l|
 " source and object files to keep around in case you reuse them. This helps"
 '|%l| " to avoid needless recompilations. The number specified should be a "
 '|%l| " non-negative integer."
 '|%l|
 '|%l| " The current setting is "
 |$fortPersistence|
 )))

\end{chunk}

\subsection{set naglink messages}
\begin{verbatim}
--------------------- The messages Option ---------------------

 Description: show NAGLink messages

 The messages option may be followed by any one of the 
 following:

 -> on 
    off

 The current setting is indicated.

\end{verbatim}
TPDHERE: this is the same as )set nag mes on
\index{\$nagMessages}
\index{defvar!\$nagMessages}
\index{\$nagMessages!defvar}
\begin{chunk}{naglinkmessages}
     (|messages|
      "show NAGLink messages"
      |interpreter|
      LITERALS
      |$nagMessages|
      (|on| |off|)
       |on|)

\end{chunk}
\subsection{set naglink double}
\begin{verbatim}
---------------------- The double Option ----------------------

 Description: enforce DOUBLE PRECISION ASPs

 The double option may be followed by any one of the following:

 -> on 
    off

 The current setting is indicated.

\end{verbatim}
\defdollar{nagEnforceDouble}
\begin{chunk}{initvars}
(defvar |$nagEnforceDouble| t "enforce DOUBLE PRECISION ASPs")

\end{chunk}
\begin{chunk}{naglinkdouble}
     (|double|
      "enforce DOUBLE PRECISION ASPs"
      |interpreter|
      LITERALS
      |$nagEnforceDouble|
      (|on| |off|)
      |on|)

\end{chunk}

\section{\enspace{}set output}
The result of the {\bf )set output} command is:
\begin{verbatim}
Variable     Description                           Current Value
-----------------------------------------------------------------
abbreviate  abbreviate type names                    off 
algebra     display output in algebraic form         On:CONSOLE 
characters  choose special output character set      plain 
fortran     create output in FORTRAN format          Off:CONSOLE 
fraction    how fractions are formatted              vertical 
html        create output in HTML style              Off:CONSOLE 
length      line length of output displays           77 
mathml      create output in MathML style            Off:CONSOLE 
openmath    create output in OpenMath style          Off:CONSOLE
script      display output in SCRIPT formula format  Off:CONSOLE 
scripts     show subscripts,... linearly             off 
showeditor  view output of )show in editor           off 
tex         create output in TeX style               Off:CONSOLE 
\end{verbatim}
Since the output option has a bunch of sub-options each suboption 
is defined within the output structure.
\begin{chunk}{output}
  (|output|
   "view and set some output options"
   |interpreter|
   TREE
   |novar|
    (
\getchunk{outputabbreviate}
\getchunk{outputalgebra}
\getchunk{outputcharacters}
\getchunk{outputfortran}
\getchunk{outputfraction}
\getchunk{outputhtml}
\getchunk{outputlength}
\getchunk{outputmathml}
\getchunk{outputopenmath}
\getchunk{outputscript}
\getchunk{outputscripts}
\getchunk{outputshoweditor}
\getchunk{outputtex}
 ))

\end{chunk}

\subsection{set output abbreviate}
\begin{verbatim}
-------------------- The abbreviate Option --------------------

 Description: abbreviate type names

 The abbreviate option may be followed by any one of the 
 following:

    on
 -> off 

 The current setting is indicated.
\end{verbatim}
\defdollar{abbreviateTypes}
\begin{chunk}{initvars}
(defvar |$abbreviateTypes| nil "abbreviate type names")

\end{chunk}
\begin{chunk}{outputabbreviate}
     (|abbreviate|
      "abbreviate type names"
      |interpreter|
      LITERALS
      |$abbreviateTypes|
      (|on| |off|)
      |off|)

\end{chunk}

\subsection{set output algebra}
\begin{verbatim}
--------------------- The algebra Option ----------------------

 Description: display output in algebraic form

 )set output algebra is used to tell AXIOM to turn algebra-style
  output printing on and off, and where to place the output.  By
  default, the destination for the output is the screen but 
  printing is turned off.

Syntax:   )set output algebra <arg>
    where arg can be one of
  on          turn algebra printing on (default state)
  off         turn algebra printing off
  console     send algebra output to screen (default state)
  fp<.fe>     send algebra output to file with file prefix fp
              and file extension .fe. If not given, 
              .fe defaults to .spout.

If you wish to send the output to a file, you may need to issue
this command twice: once with on and once with the file name. 
For example, to send algebra output to the file polymer.spout,
issue the two commands

  )set output algebra on
  )set output algebra polymer

The output is placed in the directory from which you invoked 
AXIOM or the one you set with the )cd system command.
The current setting is:  On:CONSOLE 
\end{verbatim}
\defdollar{algebraFormat}
\begin{chunk}{initvars}
(defvar |$algebraFormat| t "display output in algebraic form ")

\end{chunk}
\defdollar{algebraOutputFile}
\begin{chunk}{initvars}
(defvar |$algebraOutputFile| "CONSOLE" 
  "where algebra printing goes (enter {\em console} or a pathname)?")

\end{chunk}
\begin{chunk}{outputalgebra}
     (|algebra|
      "display output in algebraic form "
      |interpreter|
      FUNCTION
      |setOutputAlgebra|
      (("display output in algebraic form "
        LITERALS
        |$algebraFormat|
        (|off| |on|)
        |on|)
       (break $algebraFormat)
       ("where algebra printing goes (enter {\em console} or a pathname)?"
        FILENAME
        |$algebraOutputFile|
        |chkOutputFileName|
        "console"))
      NIL)

\end{chunk}

\defdollar{algebraOutputStream}
\begin{chunk}{initvars}
(defvar |$algebraOutputStream| *standard-output*)
 
\end{chunk}

\defun{setOutputAlgebra}{setOutputAlgebra}
\calls{setOutputAlgebra}{defiostream}
\calls{setOutputAlgebra}{concat}
\calls{setOutputAlgebra}{describeSetOutputAlgebra}
\calls{setOutputAlgebra}{qcdr}
\calls{setOutputAlgebra}{qcar}
\calls{setOutputAlgebra}{member}
\calls{setOutputAlgebra}{upcase}
\calls{setOutputAlgebra}{sayKeyedMsg}
\calls{setOutputAlgebra}{shut}
\calls{setOutputAlgebra}{pathnameType}
\calls{setOutputAlgebra}{pathnameDirectory}
\calls{setOutputAlgebra}{pathnameName}
\callsdollar{setOutputAlgebra}{filep}
\calls{setOutputAlgebra}{make-outstream}
\calls{setOutputAlgebra}{object2String}
\usesdollar{setOutputAlgebra}{algebraOutputStream}
\usesdollar{setOutputAlgebra}{algebraOutputFile}
\usesdollar{setOutputAlgebra}{filep}
\usesdollar{setOutputAlgebra}{algebraFormat}
\begin{chunk}{defun setOutputAlgebra}
(defun |setOutputAlgebra| (arg)
 (let (label tmp1 tmp2 ptype fn ft fm filename teststream)
 (declare (special |$algebraOutputStream| |$algebraOutputFile| $filep
  |$algebraFormat|))
   (cond
    ((eq arg '|%initialize%|)
     (setq |$algebraOutputStream|
      (defiostream '((mode . output) (device . console)) 255 0))
     (setq |$algebraOutputFile| "CONSOLE")
     (setq |$algebraFormat| t))
    ((eq arg '|%display%|)
     (if |$algebraFormat|
      (setq label "On:")
      (setq label "Off:"))
     (concat label |$algebraOutputFile|))
    ((or (null arg) (eq arg '|%describe%|) (eq (car arg) '?))
     (|describeSetOutputAlgebra|))
    (t
     (cond
      ((and (consp arg)
            (eq (qcdr arg) nil)
            (progn (setq fn (qcar arg)) t)
            (|member| fn '(y n ye yes no o on of off console 
                    |y| |n| |ye| |yes| |no| |o| |on| |of| |off| |console|)))
       '|ok|)
      (t (setq arg (list fn '|spout|))))
     (cond
      ((and (consp arg)
            (eq (qcdr arg) nil)
            (progn (setq fn (qcar arg)) t))
       (cond
        ((|member| (upcase fn) '(y n ye o of))
         (|sayKeyedMsg| 
            (format nil
              "To toggle %1 printing on and off, specify %l )set output %2 ~
               yes/no/on/off %l Yes, no, on and off cannot be abbreviated.")
          '(|algebra| |algebra|)))
        ((|member| (upcase fn) '(no off)) (setq |$algebraFormat| nil))
        ((|member| (upcase fn) '(yes on)) (setq |$algebraFormat| t))
        ((eq (upcase fn) 'console)
         (shut |$algebraOutputStream|)
         (setq |$algebraOutputStream| 
          (defiostream '((mode . output) (device . console)) 255 0))
         (setq |$algebraOutputFile| "CONSOLE"))))
      ((or
        (and (consp arg)
             (progn
              (setq fn (qcar arg))
              (setq tmp1 (qcdr arg))
              (and (consp tmp1)
                   (eq (qcdr tmp1) nil)
                   (progn (setq ft (qcar tmp1)) t))))
        (and (consp arg)
             (progn (setq fn (qcar arg))
                    (setq tmp1 (qcdr arg))
                    (and (consp tmp1)
                         (progn (setq ft (qcar tmp1))
                                (setq tmp2 (qcdr tmp1))
                                (and (consp tmp2)
                                     (eq (qcdr tmp2) nil)
                                     (progn
                                      (setq fm (qcar tmp2))
                                      t)))))))
       (when (setq ptype (|pathnameType| fn))
        (setq fn (concat (|pathnameDirectory| fn) (|pathnameName| fn)))
        (setq ft ptype))
       (unless fm (setq fm 'a))
       (setq filename ($filep fn ft fm))
       (cond
        ((null filename)
         (|sayKeyedMsg|
          "It is not possible to open or create a file called %1 %2 %3 ."
          (list fn ft fm)))
        ((setq teststream (make-outstream filename 255 0))
         (shut |$algebraOutputStream|)
         (setq |$algebraOutputStream| teststream)
         (setq |$algebraOutputFile| (|object2String| filename))
         (|sayKeyedMsg| 
          "%1 output will be written to file %2 ."
          (list "Algebra" |$algebraOutputFile|)))
        (t (|sayKeyedMsg|
            "It is not possible to open or create a file called %1 %2 %3 ."
            (list fn ft fm)))))
      (t
       (|sayKeyedMsg| "Your argument list is not valid." nil)
       (|describeSetOutputAlgebra|)))))))

\end{chunk}

\defun{describeSetOutputAlgebra}{describeSetOutputAlgebra}
\calls{describeSetOutputAlgebra}{sayBrightly}
\calls{describeSetOutputAlgebra}{setOutputAlgebra}
\begin{chunk}{defun describeSetOutputAlgebra}
(defun |describeSetOutputAlgebra| ()
 (|sayBrightly| (list
 " )set output algebra "
 "is used to tell AXIOM to turn algebra-style output"
 '|%l| "printing on and off, and where to place the output.  By default, the"
 '|%l| "destination for the output is the screen but printing is turned off."
 '|%l|
 '|%l| "Syntax:   )set output algebra <arg>"
 '|%l| "    where arg can be one of"
 '|%l| "  on          turn algebra printing on (default state)"
 '|%l| "  off         turn algebra printing off"
 '|%l| "  console     send algebra output to screen (default state)"
 '|%l| "  fp<.fe>     send algebra output to file with file prefix fp"
 '|%l|
  "              and file extension .fe. If not given, .fe defaults to .spout."
 '|%l|
 '|%l|
 "If you wish to send the output to a file, you may need to issue this command"
 '|%l| "twice: once with"
 " on and once with the file name. For example, to send"
 '|%l| "algebra output to the file polymer.spout, issue the two commands"
 '|%l|
 '|%l| "  )set output algebra on"
 '|%l| "  )set output algebra polymer"
 '|%l|
 '|%l| "The output is placed in the directory from which you invoked AXIOM or"
 '|%l| "the one you set with the )cd system command."
 '|%l| "The current setting is: "
 (|setOutputAlgebra| '|%display%|)
 ))) 

\end{chunk}

\subsection{set output characters}
\begin{verbatim}
-------------------- The characters Option --------------------

 Description: choose special output character set


 The characters option may be followed by any one of the 
 following:

    default
 -> plain 

 The current setting is indicated.  This 
 option  determines the special characters used for algebraic 
 output. This is what the current choice of special characters 
 looks like:
   ulc is shown as +          urc is shown as +       
   llc is shown as +          lrc is shown as +       
   vbar is shown as |         hbar is shown as -      
   quad is shown as ?         lbrk is shown as [      
   rbrk is shown as ]         lbrc is shown as {      
   rbrc is shown as }         ttee is shown as +      
   btee is shown as +         rtee is shown as +      
   ltee is shown as +         ctee is shown as +      
   bslash is shown as \    
\end{verbatim}
\begin{chunk}{outputcharacters}
     (|characters|
      "choose special output character set "
      |interpreter|
      FUNCTION
      |setOutputCharacters|
      NIL
      |htSetOutputCharacters|)

\end{chunk}

\defun{setOutputCharacters}{setOutputCharacters}
\calls{setOutputCharacters}{sayMessage}
\calls{setOutputCharacters}{bright}
\calls{setOutputCharacters}{sayBrightly}
\calls{setOutputCharacters}{concat}
\calls{setOutputCharacters}{pname}
\calls{setOutputCharacters}{specialChar}
\calls{setOutputCharacters}{sayAsManyPerLineAsPossible}
\calls{setOutputCharacters}{qcdr}
\calls{setOutputCharacters}{qcar}
\calls{setOutputCharacters}{downcase}
\calls{setOutputCharacters}{setOutputCharacters}
\usesdollar{setOutputCharacters}{specialCharacters}
\usesdollar{setOutputCharacters}{plainRTspecialCharacters}
\usesdollar{setOutputCharacters}{RTspecialCharacters}
\usesdollar{setOutputCharacters}{specialCharacterAlist}
\begin{chunk}{defun setOutputCharacters}
(defun |setOutputCharacters| (arg)
 (let (current char s l fn)
 (declare (special |$specialCharacters| |$plainRTspecialCharacters|
   |$RTspecialCharacters| |$specialCharacterAlist|))
    (if (eq arg '|%initialize%|) 
     (setq |$specialCharacters| |$plainRTspecialCharacters|)
     (progn
      (setq current
       (cond
        ((eq |$specialCharacters| |$RTspecialCharacters|) "default")
        ((eq |$specialCharacters| |$plainRTspecialCharacters|) "plain")
        (t "unknown")))
      (cond
       ((eq arg '|%display%|) current)
       ((or (null arg) (eq arg '|%describe%|) (eq (car arg) '?))
        (format t
         " The characters option may be followed by any one ~
           of the following:~%~%")
        (dolist (name '("default" "plain"))
         (if (string= (string current) name) 
          (|sayBrightly| `(" ->" ,@(|bright| name)))
          (|sayBrightly|  (list "    " name))))
        (terpri)
        (format t
          " The current setting is indicated within the list.  ~
            This option determines ~% the special characters used ~
            for algebraic output.  This is what the~% current choice of ~
            special characters looks like:~%")
        (do ((t1 |$specialCharacterAlist| (CDR t1)) (t2 nil))
           ((or (atom t1) 
                (progn (setq t2 (car t1)) nil)
                (progn (progn (setq char (car t2)) t2) nil)) nil)
         (setq s
          (concat "   " (pname char) " is shown as " 
           (pname (|specialChar| char))))
          (setq l (cons s l)))
        (|sayAsManyPerLineAsPossible| (reverse l)))
       ((and (consp arg)
             (eq (qcdr arg) NIL)
             (progn (setq fn (qcar arg)) t)
             (setq fn (downcase fn)))
        (cond
         ((eq fn '|default|) 
          (setq |$specialCharacters| |$RTspecialCharacters|))
         ((eq fn '|plain|)
          (setq |$specialCharacters| |$plainRTspecialCharacters|))
         (t (|setOutputCharacters| nil))))
       (t (|setOutputCharacters| nil)))))))

\end{chunk}

\subsection{set output fortran}
\begin{verbatim}
--------------------- The fortran Option ----------------------

 Description: create output in FORTRAN format

 )set output fortran is used to tell AXIOM to turn FORTRAN-style
  output printing on and off, and where to place the output.  By
  default, the destination for the output is the screen but 
  printing is turned off.

Also See: )set fortran

Syntax:   )set output fortran <arg>
    where arg can be one of
  on          turn FORTRAN printing on
  off         turn FORTRAN printing off (default state)
  console     send FORTRAN output to screen (default state)
  fp<.fe>     send FORTRAN output to file with file prefix 
              fp and file extension .fe. If not given, 
              .fe defaults to .sfort.

If you wish to send the output to a file, you must issue 
this command twice: once with on and once with the file name.
For example, to send FORTRAN output to the file polymer.sfort,
 issue the two commands

  )set output fortran on
  )set output fortran polymer

The output is placed in the directory from which you invoked
AXIOM or the one you set with the )cd system command.
The current setting is:  Off:CONSOLE 
\end{verbatim}
\defdollar{fortranFormat}
\begin{chunk}{initvars}
(defvar |$fortranFormat| nil "create output in FORTRAN format ")

\end{chunk}
\defdollar{fortranOutputFile}
\begin{chunk}{initvars}
(defvar |$fortranOutputFile| "CONSOLE" 
   "where FORTRAN output goes (enter {\em console} or a a pathname)")

\end{chunk}
\begin{chunk}{outputfortran}
     (|fortran|
      "create output in FORTRAN format "
      |interpreter|
      FUNCTION
      |setOutputFortran|
      (("create output in FORTRAN format "
        LITERALS
        |$fortranFormat|
        (|off| |on|)
        |off|)
       (|break| |$fortranFormat|)
       ("where FORTRAN output goes (enter {\em console} or a a pathname)"
        FILENAME
        |$fortranOutputFile|
        |chkOutputFileName|
        "console"))
      NIL)

\end{chunk}

\defun{setOutputFortran}{setOutputFortran}
\calls{setOutputFortran}{defiostream}
\calls{setOutputFortran}{concat}
\calls{setOutputFortran}{describeSetOutputFortran}
\calls{setOutputFortran}{upcase}
\calls{setOutputFortran}{qcdr}
\calls{setOutputFortran}{qcar}
\calls{setOutputFortran}{member}
\calls{setOutputFortran}{sayKeyedMsg}
\calls{setOutputFortran}{shut}
\calls{setOutputFortran}{pathnameType}
\calls{setOutputFortran}{pathnameDirectory}
\calls{setOutputFortran}{pathnameName}
\callsdollar{setOutputFortran}{filep}
\calls{setOutputFortran}{makeStream}
\calls{setOutputFortran}{object2String}
\usesdollar{setOutputFortran}{fortranOutputStream}
\usesdollar{setOutputFortran}{fortranOutputFile}
\usesdollar{setOutputFortran}{filep}
\usesdollar{setOutputFortran}{fortranFormat}
\begin{chunk}{defun setOutputFortran}
(defun |setOutputFortran| (arg)
 (let (label APPEND quiet tmp1 tmp2 ptype fn ft fm filename teststream)
 (declare (special |$fortranOutputStream| |$fortranOutputFile| $filep
    |$fortranFormat|))
  (cond
   ((eq arg '|%initialize%|) 
    (setq |$fortranOutputStream|
     (defiostream '((mode . output) (device . console)) 255 0))
    (setq |$fortranOutputFile| "CONSOLE")
    (setq |$fortranFormat| nil))
   ((eq arg '|%display%|)
    (if |$fortranFormat| 
     (setq label "On:")
     (setq label "Off:"))
    (concat label |$fortranOutputFile|))
   ((or (null arg) (eq arg '|%describe%|) (eq (car arg) '?)) 
    (|describeSetOutputFortran|))
   (t
    (DO ()
        ((null (and (listp arg) 
                    (|member| (upcase (car arg)) '(append quiet))))
       nil)
     (cond
      ((eq (upcase (car arg)) 'append) (setq append t))
      ((eq (upcase (car arg)) 'quiet) (setq quiet t))
      (t nil))
     (setq arg (cdr arg)))
    (cond
     ((and (consp arg)
           (eq (qcdr arg) nil)
           (progn (setq fn (qcar arg)) t)
           (|member| fn '(Y N YE YES NO O ON OF OFF CONSOLE 
             |y| |n| |ye| |yes| |no| |o| |on| |of| |off| |console|)))
       '|ok|)
     (t (setq arg (list fn '|sfort|))))
    (cond
     ((and (consp arg) (eq (qcdr arg) nil) (progn (setq fn (qcar arg)) t))
      (cond
       ((|member| (upcase fn) '(y n ye o of))
        (|sayKeyedMsg|
         (format nil
          "To toggle %1 printing on and off, specify %l )set output %2 ~
           yes/no/on/off %l Yes, no, on and off cannot be abbreviated.")
         '(fortran |fortran|)))
       ((|member| (upcase fn) '(no off)) (setq |$fortranFormat| nil))
       ((|member| (upcase fn) '(yes on)) (setq |$fortranFormat| t))
       ((eq (upcase fn) 'console)
         (shut |$fortranOutputStream|)
         (setq |$fortranOutputStream|
          (defiostream '((mode . output) (device . console)) 255 0)) 
         (setq |$fortranOutputFile| "CONSOLE"))))
     ((or 
       (and (consp arg) 
            (progn
             (setq fn (qcar arg))
             (setq tmp1 (qcdr arg))
             (and (consp tmp1)
                  (eq (qcdr tmp1) nil)
                  (progn (setq ft (qcar tmp1)) t))))
       (and (consp arg)
            (progn
             (setq fn (qcar arg))
             (setq tmp1 (qcdr arg))
             (and (consp tmp1)
                  (progn
                   (setq ft (qcar tmp1))
                   (setq tmp2 (qcdr tmp1))
                   (and (consp tmp2)
                        (eq (qcdr tmp2) nil)
                        (progn (setq fm (qcar tmp2)) t)))))))
      (when (setq ptype (|pathnameType| fn))
        (setq fn (concat (|pathnameDirectory| fn) (|pathnameName| fn)))
        (setq ft ptype))
      (unless fm (setq fm 'a))
      (setq filename ($filep fn ft fm))
      (cond
       ((null filename)
        (|sayKeyedMsg|
         "It is not possible to open or create a file called %1 %2 %3 ."
         (list fn ft fm)))
       ((setq teststream (|makeStream| append filename 255 0))
        (SHUT |$fortranOutputStream|)
        (setq |$fortranOutputStream| teststream)
        (setq |$fortranOutputFile| (|object2String| filename))
        (unless quiet
          (|sayKeyedMsg|
           "%1 output will be written to file %2 ."
           (list 'fortran |$fortranOutputFile|))))
       ((null quiet)
        (|sayKeyedMsg|
         "It is not possible to open or create a file called %1 %2 %3 ."
         (list fn ft fm)))
       (t nil)))
     (t
      (unless quiet (|sayKeyedMsg| "Your argument list is not valid." nil))
      (|describeSetOutputFortran|)))))))

\end{chunk}

\defun{describeSetOutputFortran}{describeSetOutputFortran}
\calls{describeSetOutputFortran}{sayBrightly}
\calls{describeSetOutputFortran}{setOutputFortran}
\begin{chunk}{defun describeSetOutputFortran}
(defun |describeSetOutputFortran| ()
 (|sayBrightly| (list
  " )set output fortran"
  " is used to tell AXIOM to turn FORTRAN-style output "
  '|%l| "printing on and off, and where to place the output.  By default, the"
  '|%l| "destination for the output is the screen but printing is turned off."
  '|%l|
  '|%l| "Also See: )set fortran"
  '|%l|
  '|%l| "Syntax:   )set output fortran <arg>"
  '|%l| "    where arg can be one of"
  '|%l| "  on          turn FORTRAN printing on"
  '|%l| "  off         turn FORTRAN printing off (default state)"
  '|%l| "  console     send FORTRAN output to screen (default state)"
  '|%l|
  "  fp<.fe>     send FORTRAN output to file with file prefix fp and file"
  '|%l| "              extension .fe. If not given, .fe defaults to .sfort."
  '|%l|
  '|%l| "If you wish to send the output to a file, you must issue this command"
  '|%l| "twice: once with"
  " on and once with the file name. For example, to send "
  '|%l| "FORTRAN output to the file polymer.sfort, issue the two commands"
  '|%l|
  '|%l| "  )set output fortran on"
  '|%l| "  )set output fortran polymer"
  '|%l|
  '|%l| "The output is placed in the directory from which you invoked AXIOM or"
  '|%l| "the one you set with the )cd system command."
  '|%l| "The current setting is: "
  (|setOutputFortran| '|%display%|)
  )))

\end{chunk}

\subsection{set output fraction}
\begin{verbatim}
--------------------- The fraction Option ---------------------

 Description: how fractions are formatted

 The fraction option may be followed by any one of the following:

 -> vertical 
    horizontal

 The current setting is indicated.

\end{verbatim}
\defdollar{fractionDisplayType}
\begin{chunk}{initvars}
(defvar |$fractionDisplayType| '|vertical| "how fractions are formatted")

\end{chunk}
\begin{chunk}{outputfraction}
     (|fraction|
      "how fractions are formatted"
      |interpreter|
      LITERALS
      |$fractionDisplayType|
      (|vertical| |horizontal|)
      |vertical|)

\end{chunk}

\subsection{set output html}
\begin{verbatim}
----------------------- The html Option ------------------------

 Description: create output in html style

 )set output html is used to tell AXIOM to turn html-style output
printing on and off, and where to place the output.  By default,
the destination for the output is the screen but printing is 
turned off.

Syntax:   )set output html <arg>
    where arg can be one of
  on          turn html printing on
  off         turn html printing off (default state)
  console     send html output to screen (default state)
  fp<.fe>     send html output to file with file prefix fp
              and file extension .fe. If not given, 
              .fe defaults to .html.

If you wish to send the output to a file, you must issue 
this command twice: once with on and once with the file name. 
For example, to send MathML output to the file polymer.html, 
issue the two commands

  )set output html on
  )set output html polymer

The output is placed in the directory from which you invoked 
Axiom or the one you set with the )cd system command.
The current setting is:  Off:CONSOLE 
\end{verbatim}
\defdollar{htmlFormat}
\begin{chunk}{initvars}
(defvar |$htmlFormat| nil "create output in HTML format ")

\end{chunk}
\defdollar{htmlOutputFile}
\begin{chunk}{initvars}
(defvar |$htmlOutputFile| "CONSOLE" 
   "where HTML output goes (enter {\em console} or a pathname)")

\end{chunk}
\begin{chunk}{outputhtml}
     (|html|
      "create output in HTML style "
      |interpreter|
      FUNCTION
      |setOutputHtml|
      (("create output in HTML format "
        LITERALS
        |$htmlFormat|
        (|off| |on|)
        |off|)
       (|break| |$htmlFormat|)
       ("where HTML output goes (enter {\em console} or a pathname)"
        FILENAME
        |$htmlOutputFile|
        |chkOutputFileName|
        "console"))
      NIL)

\end{chunk}

\defun{setOutputHtml}{setOutputHtml}
\calls{setOutputHtml}{defiostream}
\calls{setOutputHtml}{concat}
\calls{setOutputHtml}{describeSetOutputHtml}
\calls{setOutputHtml}{qcdr}
\calls{setOutputHtml}{qcar}
\calls{setOutputHtml}{member}
\calls{setOutputHtml}{upcase}
\calls{setOutputHtml}{sayKeyedMsg}
\calls{setOutputHtml}{shut}
\calls{setOutputHtml}{pathnameType}
\calls{setOutputHtml}{pathnameDirectory}
\calls{setOutputHtml}{pathnameName}
\callsdollar{setOutputHtml}{filep}
\calls{setOutputHtml}{make-outstream}
\calls{setOutputHtml}{object2String}
\usesdollar{setOutputHtml}{htmlOutputStream}
\usesdollar{setOutputHtml}{htmlOutputFile}
\usesdollar{setOutputHtml}{htmlFormat}
\usesdollar{setOutputHtml}{filep}
\begin{chunk}{defun setOutputHtml}
(defun |setOutputHtml| (arg)
 (let (label tmp1 tmp2 ptype fn ft fm filename teststream)
 (declare (special |$htmlOutputStream| |$htmlOutputFile| |$htmlFormat|
           $filep))
   (cond
    ((eq arg '|%initialize%|)
     (setq |$htmlOutputStream|
      (defiostream '((mode . output) (device . console)) 255 0))
     (setq |$htmlOutputFile| "CONSOLE")
     (setq |$htmlFormat| nil))
    ((eq arg '|%display%|)
     (if |$htmlFormat| 
      (setq label "On:")
      (setq label "Off:"))
     (concat label |$htmlOutputFile|))
    ((or (null arg) (eq arg '|%describe%|) (eq (car arg) '?))
     (|describeSetOutputHtml|))
    (t
     (cond
      ((and (consp arg) 
            (eq (qcdr arg) nil)
            (progn (setq fn (qcar arg)) t)
            (|member| fn '(y n ye yes no o on of off console 
                   |y| |n| |ye| |yes| |no| |o| |on| |of| |off| |console|)))
        '|ok|)
      (t (setq arg (list fn '|smml|))))
     (cond
      ((and (consp arg) 
            (eq (qcdr arg) nil)
            (progn (setq fn (qcar arg)) t))
       (cond
        ((|member| (upcase fn) '(y n ye o of))
         (|sayKeyedMsg| 
            (format nil
              "To toggle %1 printing on and off, specify %l )set output %2 ~
               yes/no/on/off %l Yes, no, on and off cannot be abbreviated.")
            '(|HTML| |html|)))
        ((|member| (upcase fn) '(no off)) (setq |$htmlFormat| nil))
        ((|member| (upcase fn) '(yes on)) (setq |$htmlFormat| t))
        ((eq (upcase fn) 'console)
         (shut |$htmlOutputStream|)
         (setq |$htmlOutputStream|
          (defiostream '((mode . output) (device . console)) 255 0))
         (setq |$htmlOutputFile| "CONSOLE"))))
      ((or 
        (and (consp arg)
             (progn
              (setq fn (qcar arg))
              (setq tmp1 (qcdr arg))
              (and (consp tmp1)
                   (eq (qcdr tmp1) nil)
                   (progn (setq ft (qcar tmp1)) t))))
        (and (consp arg)
             (progn (setq fn (qcar arg))
                    (setq tmp1 (qcdr arg))
                    (and (consp tmp1)
                         (progn
                          (setq ft (qcar tmp1))
                          (setq tmp2 (qcdr tmp1))
                          (and (consp tmp2)
                               (eq (qcdr tmp2) nil)
                               (progn
                                (setq fm (qcar tmp2))
                                t)))))))
          (when (setq ptype (|pathnameType| fn))
           (setq fn 
            (concat (|pathnameDirectory| fn) (|pathnameName| fn)))
           (setq ft ptype))
          (unless fm (setq fm 'a))
          (setq filename ($filep fn ft fm))
          (cond
           ((null filename)
            (|sayKeyedMsg|
             "It is not possible to open or create a file called %1 %2 %3 ."
             (list fn ft fm)))
           ((setq teststream (make-outstream filename 255 0))
            (shut |$htmlOutputStream|)
            (setq |$htmlOutputStream| teststream)
            (setq |$htmlOutputFile| (|object2String| filename))
            (|sayKeyedMsg| 
             "%1 output will be written to file %2 ."
             (list "HTML" |$htmlOutputFile|)))
           (t (|sayKeyedMsg|
               "It is not possible to open or create a file called %1 %2 %3 ."
               (list fn ft fm)))))
      (t 
       (|sayKeyedMsg| "Your argument list is not valid." nil)
       (|describeSetOutputHtml|))))))) 

\end{chunk}

\defun{describeSetOutputHtml}{describeSetOutputHtml}
\calls{describeSetOutputHtml}{sayBrightly}
\calls{describeSetOutputHtml}{setOutputHtml}
\begin{chunk}{defun describeSetOutputHtml}
(defun |describeSetOutputHtml| ()
 (|sayBrightly| (LIST
 " )set output html "
 "is used to tell AXIOM to turn HTML-style output"
 '|%l| "printing on and off, and where to place the output.  By default, the"
 '|%l| "destination for the output is the screen but printing is turned off."
 '|%l|
 '|%l| "Syntax:   )set output html <arg>"
 '|%l| "    where arg can be one of"
 '|%l| "  on          turn HTML printing on"
 '|%l| "  off         turn HTML printing off (default state)"
 '|%l| "  console     send HTML output to screen (default state)"
 '|%l| "  fp<.fe>     send HTML output to file with file prefix fp and file"
 '|%l| "              extension .fe. If not given, .fe defaults to .stex."
 '|%l|
 '|%l| "If you wish to send the output to a file, you must issue this command"
 '|%l| "twice: once with "
 "on and once with the file name. For example, to send"
 '|%l| "HTML output to the file polymer.smml, issue the two commands"
 '|%l|
 '|%l| "  )set output html on"
 '|%l| "  )set output html polymer"
 '|%l|
 '|%l| "The output is placed in the directory from which you invoked AXIOM or"
 '|%l| "the one you set with the )cd system command."
 '|%l| "The current setting is: "
 (|setOutputHtml| '|%display%|)
 )))

\end{chunk}

\subsection{set output length}
\begin{verbatim}
---------------------- The length Option ----------------------

 Description: line length of output displays

 The length option may be followed by an integer in the range 
 10 to 245 inclusive. The current setting is 77 

\end{verbatim}

\defdollar{margin}
\begin{chunk}{initvars}
(defvar $margin 3)

\end{chunk}

\defdollar{linelength}
\begin{chunk}{initvars}
(defvar $linelength 77 "line length of output displays")

\end{chunk}

\begin{chunk}{outputlength}
     (|length|
      "line length of output displays"
      |interpreter|
      INTEGER
      $LINELENGTH
      (10 245)
      77)

\end{chunk}

\subsection{set output mathml}
\begin{verbatim}
----------------------- The mathml Option ------------------------

 Description: create output in MathML style

 )set output mathml is used to tell AXIOM to turn MathML-style output
printing on and off, and where to place the output.  By default,
the destination for the output is the screen but printing is 
turned off.

Syntax:   )set output mathml <arg>
    where arg can be one of
  on          turn MathML printing on
  off         turn MathML printing off (default state)
  console     send MathML output to screen (default state)
  fp<.fe>     send MathML output to file with file prefix fp
              and file extension .fe. If not given, 
              .fe defaults to .smml.

If you wish to send the output to a file, you must issue 
this command twice: once with on and once with the file name. 
For example, to send MathML output to the file polymer.smml, 
issue the two commands

  )set output mathml on
  )set output mathml polymer

The output is placed in the directory from which you invoked 
AXIOM or the one you set with the )cd system command.
The current setting is:  Off:CONSOLE 
\end{verbatim}
\defdollar{mathmlFormat}
\begin{chunk}{initvars}
(defvar |$mathmlFormat| nil "create output in MathML format ")

\end{chunk}
\defdollar{mathmlOutputFile}
\begin{chunk}{initvars}
(defvar |$mathmlOutputFile| "CONSOLE" 
   "where MathML output goes (enter {\em console} or a pathname)")

\end{chunk}
\begin{chunk}{outputmathml}
     (|mathml|
      "create output in MathML style "
      |interpreter|
      FUNCTION
      |setOutputMathml|
      (("create output in MathML format "
        LITERALS
        |$mathmlFormat|
        (|off| |on|)
        |off|)
       (|break| |$mathmlFormat|)
       ("where MathML output goes (enter {\em console} or a pathname)"
        FILENAME
        |$mathmlOutputFile|
        |chkOutputFileName|
        "console"))
      NIL)

\end{chunk}

\defun{setOutputMathml}{setOutputMathml}
\calls{setOutputMathml}{defiostream}
\calls{setOutputMathml}{concat}
\calls{setOutputMathml}{describeSetOutputMathml}
\calls{setOutputMathml}{qcdr}
\calls{setOutputMathml}{qcar}
\calls{setOutputMathml}{member}
\calls{setOutputMathml}{upcase}
\calls{setOutputMathml}{sayKeyedMsg}
\calls{setOutputMathml}{shut}
\calls{setOutputMathml}{pathnameType}
\calls{setOutputMathml}{pathnameDirectory}
\calls{setOutputMathml}{pathnameName}
\callsdollar{setOutputMathml}{filep}
\calls{setOutputMathml}{make-outstream}
\calls{setOutputMathml}{object2String}
\usesdollar{setOutputMathml}{mathmlOutputStream}
\usesdollar{setOutputMathml}{mathmlOutputFile}
\usesdollar{setOutputMathml}{mathmlFormat}
\usesdollar{setOutputMathml}{filep}
\begin{chunk}{defun setOutputMathml}
(defun |setOutputMathml| (arg)
 (let (label tmp1 tmp2 ptype fn ft fm filename teststream)
 (declare (special |$mathmlOutputStream| |$mathmlOutputFile| |$mathmlFormat|
           $filep))
   (cond
    ((eq arg '|%initialize%|)
     (setq |$mathmlOutputStream|
      (defiostream '((mode . output) (device . console)) 255 0))
     (setq |$mathmlOutputFile| "CONSOLE")
     (setq |$mathmlFormat| nil))
    ((eq arg '|%display%|)
     (if |$mathmlFormat| 
      (setq label "On:")
      (setq label "Off:"))
     (concat label |$mathmlOutputFile|))
    ((or (null arg) (eq arg '|%describe%|) (eq (car arg) '?))
     (|describeSetOutputMathml|))
    (t
     (cond
      ((and (consp arg) 
            (eq (qcdr arg) nil)
            (progn (setq fn (qcar arg)) t)
            (|member| fn '(y n ye yes no o on of off console 
                   |y| |n| |ye| |yes| |no| |o| |on| |of| |off| |console|)))
        '|ok|)
      (t (setq arg (list fn '|smml|))))
     (cond
      ((and (consp arg) 
            (eq (qcdr arg) nil)
            (progn (setq fn (qcar arg)) t))
       (cond
        ((|member| (upcase fn) '(y n ye o of))
         (|sayKeyedMsg|
            (format nil
              "To toggle %1 printing on and off, specify %l )set output %2 ~
               yes/no/on/off %l Yes, no, on and off cannot be abbreviated.")
           '(|MathML| |mathml|)))
        ((|member| (upcase fn) '(no off)) (setq |$mathmlFormat| nil))
        ((|member| (upcase fn) '(yes on)) (setq |$mathmlFormat| t))
        ((eq (upcase fn) 'console)
         (shut |$mathmlOutputStream|)
         (setq |$mathmlOutputStream|
          (defiostream '((mode . output) (device . console)) 255 0))
         (setq |$mathmlOutputFile| "CONSOLE"))))
      ((or 
        (and (consp arg)
             (progn
              (setq fn (qcar arg))
              (setq tmp1 (qcdr arg))
              (and (consp tmp1)
                   (eq (qcdr tmp1) nil)
                   (progn (setq ft (qcar tmp1)) t))))
        (and (consp arg)
             (progn (setq fn (qcar arg))
                    (setq tmp1 (qcdr arg))
                    (and (consp tmp1)
                         (progn
                          (setq ft (qcar tmp1))
                          (setq tmp2 (qcdr tmp1))
                          (and (consp tmp2)
                               (eq (qcdr tmp2) nil)
                               (progn
                                (setq fm (qcar tmp2))
                                t)))))))
          (when (setq ptype (|pathnameType| fn))
           (setq fn 
            (concat (|pathnameDirectory| fn) (|pathnameName| fn)))
           (setq ft ptype))
          (unless fm (setq fm 'a))
          (setq filename ($filep fn ft fm))
          (cond
           ((null filename)
             (|sayKeyedMsg|
               "It is not possible to open or create a file called %1 %2 %3 ."
               (list fn ft fm)))
           ((setq teststream (make-outstream filename 255 0))
            (shut |$mathmlOutputStream|)
            (setq |$mathmlOutputStream| teststream)
            (setq |$mathmlOutputFile| (|object2String| filename))
            (|sayKeyedMsg|
             "%1 output will be written to file %2 ."
             (list "MathML" |$mathmlOutputFile|)))
           (t (|sayKeyedMsg| 
               "It is not possible to open or create a file called %1 %2 %3 ."
               (list fn ft fm)))))
      (t 
       (|sayKeyedMsg| "Your argument list is not valid." nil)
       (|describeSetOutputMathml|))))))) 

\end{chunk}

\defun{describeSetOutputMathml}{describeSetOutputMathml}
\calls{describeSetOutputMathml}{sayBrightly}
\calls{describeSetOutputMathml}{setOutputMathml}
\begin{chunk}{defun describeSetOutputMathml}
(defun |describeSetOutputMathml| ()
 (|sayBrightly| (LIST
 " )set output mathml "
 "is used to tell AXIOM to turn MathML-style output"
 '|%l| "printing on and off, and where to place the output.  By default, the"
 '|%l| "destination for the output is the screen but printing is turned off."
 '|%l|
 '|%l| "Syntax:   )set output mathml <arg>"
 '|%l| "    where arg can be one of"
 '|%l| "  on          turn MathML printing on"
 '|%l| "  off         turn MathML printing off (default state)"
 '|%l| "  console     send MathML output to screen (default state)"
 '|%l| "  fp<.fe>     send MathML output to file with file prefix fp and file"
 '|%l| "              extension .fe. If not given, .fe defaults to .stex."
 '|%l|
 '|%l| "If you wish to send the output to a file, you must issue this command"
 '|%l| "twice: once with"
 " on and once with the file name. For example, to send"
 '|%l| "MathML output to the file polymer.smml, issue the two commands"
 '|%l|
 '|%l| "  )set output mathml on"
 '|%l| "  )set output mathml polymer"
 '|%l|
 '|%l| "The output is placed in the directory from which you invoked AXIOM or"
 '|%l| "the one you set with the )cd system command."
 '|%l| "The current setting is: "
 (|setOutputMathml| '|%display%|)
 )))

\end{chunk}

\subsection{set output openmath}
\begin{verbatim}
----------------------- The openmath Option ------------------------

 Description: create output in OpenMath style

 )set output tex is used to tell AXIOM to turn OpenMath output
printing on and off, and where to place the output.  By default,
the destination for the output is the screen but printing is 
turned off.

Syntax:   )set output tex <arg>
    where arg can be one of
  on          turn OpenMath printing on
  off         turn OpenMath printing off (default state)
  console     send OpenMath output to screen (default state)
  fp<.fe>     send OpenMath output to file with file prefix fp
              and file extension .fe. If not given, 
              .fe defaults to .sopen.

If you wish to send the output to a file, you must issue 
this command twice: once with on and once with the file name. 
For example, to send OpenMath output to the file polymer.sopen, 
issue the two commands

  )set output openmath on
  )set output openmath polymer

The output is placed in the directory from which you invoked 
AXIOM or the one you set with the )cd system command.
The current setting is:  Off:CONSOLE 
\end{verbatim}
\defdollar{openMathFormat}
\begin{chunk}{initvars}
(defvar |$openMathFormat| nil "create output in OpenMath format ")

\end{chunk}
\defdollar{openMathOutputFile}
\begin{chunk}{initvars}
(defvar |$openMathOutputFile| "CONSOLE"
  "where TeX output goes (enter {\em console} or a pathname)")

\end{chunk}
\begin{chunk}{outputopenmath}
     (|openmath|
      "create output in OpenMath style "
      |interpreter|
      FUNCTION
      |setOutputOpenMath|
      (("create output in OpenMath format "
        LITERALS
        |$openMathFormat|
        (|off| |on|)
        |off|)
       (|break| |$openMathFormat|)
       ("where TeX output goes (enter {\em console} or a pathname)"
        FILENAME
        |$openMathOutputFile|
        |chkOutputFileName|
        "console"))
      NIL)

\end{chunk}

\defun{setOutputOpenMath}{setOutputOpenMath}
\calls{setOutputOpenMath}{defiostream}
\calls{setOutputOpenMath}{concat}
\calls{setOutputOpenMath}{describeSetOutputOpenMath}
\calls{setOutputOpenMath}{qcdr}
\calls{setOutputOpenMath}{qcar}
\calls{setOutputOpenMath}{member}
\calls{setOutputOpenMath}{upcase}
\calls{setOutputOpenMath}{sayKeyedMsg}
\calls{setOutputOpenMath}{shut}
\calls{setOutputOpenMath}{pathnameType}
\calls{setOutputOpenMath}{pathnameDirectory}
\calls{setOutputOpenMath}{pathnameName}
\callsdollar{setOutputOpenMath}{filep}
\calls{setOutputOpenMath}{make-outstream}
\calls{setOutputOpenMath}{object2String}
\usesdollar{setOutputOpenMath}{openMathOutputStream}
\usesdollar{setOutputOpenMath}{openMathFormat}
\usesdollar{setOutputOpenMath}{filep}
\usesdollar{setOutputOpenMath}{openMathOutputFile}
\begin{chunk}{defun setOutputOpenMath}
(defun |setOutputOpenMath| (arg)
 (let (label tmp1 tmp2 ptype fn ft fm filename teststream)
 (declare (special |$openMathOutputStream| |$openMathFormat| $filep
     |$openMathOutputFile|))
   (cond
    ((eq arg '|%initialize%|)
     (setq |$openMathOutputStream| 
      (defiostream  '((mode . output) (device . console)) 255 0))
     (setq |$openMathOutputFile| "CONSOLE")
     (setq |$openMathFormat| NIL))
    ((eq arg '|%display%|)
     (if |$openMathFormat| 
      (setq label "On:")
      (setq label "Off:"))
     (concat label |$openMathOutputFile|))
    ((or (null arg) (eq arg '|%describe%|) (eq (car arg) '?))
     (|describeSetOutputOpenMath|))
    (t
     (cond
      ((and (consp arg)
            (eq (qcdr arg) nil)
            (progn (setq fn (qcar arg)) t)
            (|member| fn '(y n ye yes no o on of off console
                   |y| |n| |ye| |yes| |no| |o| |on| |of| |off| |console|)))
        '|ok|)
      (t (setq arg (list fn '|som|))))
     (cond
      ((and (consp arg)
            (eq (qcdr arg) nil)
            (progn (setq fn (qcar arg)) t))
       (cond
        ((|member| (upcase fn) '(y n ye o of))
         (|sayKeyedMsg|
            (format nil
              "To toggle %1 printing on and off, specify %l )set output %2 ~
               yes/no/on/off %l Yes, no, on and off cannot be abbreviated.")
           '(|OpenMath| |openmath|)))
        ((|member| (upcase fn) '(no off)) (setq |$openMathFormat| nil))
        ((|member| (upcase fn) '(yes on)) (setq |$openMathFormat| t))
        ((eq (upcase fn) 'console)
         (shut |$openMathOutputStream|)
         (setq |$openMathOutputStream|
          (defiostream '((mode . output) (device . console)) 255 0))
         (setq |$openMathOutputFile| "CONSOLE"))))
      ((or
        (and (consp arg)
             (progn (setq fn (qcar arg))
                    (setq tmp1 (qcdr arg))
                    (and (consp tmp1)
                         (eq (qcdr tmp1) nil)
                         (progn (setq ft (qcar tmp1)) t))))
        (and (consp arg)
             (progn
              (setq fn (qcar arg))
              (setq tmp1 (qcdr arg))
              (and (consp tmp1)
                   (progn (setq ft (qcar tmp1))
                          (setq tmp2 (qcdr tmp1))
                          (and (consp tmp2)
                               (eq (qcdr tmp2) nil)
                               (progn (setq fm (qcar tmp2)) t)))))))
        (when (setq ptype (|pathnameType| fn))
         (setq fn (concat (|pathnameDirectory| fn) (|pathnameName| fn)))
         (setq ft ptype))
        (unless fm (setq fm 'a))
        (setq filename ($filep fn ft fm))
        (cond
         ((null filename)
          (|sayKeyedMsg|
           "It is not possible to open or create a file called %1 %2 %3 ."
           (list fn ft fm)))
         ((setq teststream (make-outstream filename 255 0))
          (shut |$openMathOutputStream|)
          (setq |$openMathOutputStream| teststream)
          (setq |$openMathOutputFile| (|object2String| filename))
          (|sayKeyedMsg|
           "%1 output will be written to file %2 ."
           (list "OpenMath" |$openMathOutputFile|)))
         (t
          (|sayKeyedMsg|
           "It is not possible to open or create a file called %1 %2 %3 ."
           (list fn ft fm)))))
      (t
       (|sayKeyedMsg| "Your argument list is not valid." nil)
       (|describeSetOutputOpenMath|))))))) 

\end{chunk}

\defun{describeSetOutputOpenMath}{describeSetOutputOpenMath}
\calls{describeSetOutputOpenMath}{sayBrightly}
\calls{describeSetOutputOpenMath}{setOutputOpenMath}
\begin{chunk}{defun describeSetOutputOpenMath}
(defun |describeSetOutputOpenMath| ()
 (|sayBrightly| (list
 " )set output openmath "
 "is used to tell AXIOM to turn OpenMath output"
 '|%l| "printing on and off, and where to place the output.  By default, the"
 '|%l| "destination for the output is the screen but printing is turned off."
 '|%l|
 '|%l| "Syntax:   )set output openmath <arg>"
 '|%l| "    where arg can be one of"
 '|%l| "  on          turn OpenMath printing on"
 '|%l| "  off         turn OpenMath printing off (default state)"
 '|%l| "  console     send OpenMath output to screen (default state)"
 '|%l| 
 "  fp<.fe>     send OpenMath output to file with file prefix fp and file"
 '|%l| "              extension .fe. If not given, .fe defaults to .som."
 '|%l|
 '|%l| "If you wish to send the output to a file, you must issue this command"
 '|%l| "twice: once with"
 " on and once with the file name. For example, to send"
 '|%l| "OpenMath output to the file polymer.som, issue the two commands"
 '|%l|
 '|%l| "  )set output openmath on"
 '|%l| "  )set output openmath polymer"
 '|%l|
 '|%l| "The output is placed in the directory from which you invoked AXIOM or"
 '|%l| "the one you set with the )cd system command."
 '|%l| "The current setting is: "
 (|setOutputOpenMath| '|%display%|)
 )))

\end{chunk}

\subsection{set output script}
\begin{verbatim}
---------------------- The script Option ----------------------

 Description: display output in SCRIPT formula format

 )set output script is used to tell AXIOM to turn IBM Script
 formula-style output printing on and off, and where to place
 the output.  By default, the destination for the output is the 
 screen but printing is turned off.

Syntax:   )set output script <arg>
    where arg can be one of
  on      turn IBM Script formula printing on
  off     turn IBM Script formula printing off 
          (default state)
  console send IBM Script formula output to screen 
          (default state)
  fp<.fe> send IBM Script formula output to file with file 
          prefix fp and file extension .fe. If not given, 
          .fe defaults to .sform.

If you wish to send the output to a file, you must issue 
this command twice: once with on and once with the file 
name. For example, to send IBM Script formula output to 
the file polymer.sform, issue the two commands

  )set output script on
  )set output script polymer

The output is placed in the directory from which you 
invoked AXIOM or the one you set with the )cd system command.
The current setting is:  Off:CONSOLE 
\end{verbatim}
\defdollar{formulaFormat}
\begin{chunk}{initvars}
(defvar |$formulaFormat| nil "display output in SCRIPT format")

\end{chunk}
\defdollar{formulaOutputFile}
\begin{chunk}{initvars}
(defvar |$formulaOutputFile| "CONSOLE"
    "where script output goes (enter {\em console} or a a pathname)")

\end{chunk}
\begin{chunk}{outputscript}
     (|script|
      "display output in SCRIPT formula format "
      |interpreter|
      FUNCTION
      |setOutputFormula|
      (("display output in SCRIPT format "
        LITERALS
        |$formulaFormat|
        (|off| |on|)
        |off|)
       (|break| |$formulaFormat|)
       ("where script output goes (enter {\em console} or a a pathname)"
        FILENAME
        |$formulaOutputFile|
        |chkOutputFileName|
        "console"))
      NIL)

\end{chunk}

\defun{setOutputFormula}{setOutputFormula}
\calls{setOutputFormula}{defiostream}
\calls{setOutputFormula}{concat}
\calls{setOutputFormula}{describeSetOutputFormula}
\calls{setOutputFormula}{qcdr}
\calls{setOutputFormula}{qcar}
\calls{setOutputFormula}{member}
\calls{setOutputFormula}{upcase}
\calls{setOutputFormula}{sayKeyedMsg}
\calls{setOutputFormula}{shut}
\calls{setOutputFormula}{pathnameType}
\calls{setOutputFormula}{pathnameDirectory}
\calls{setOutputFormula}{pathnameName}
\callsdollar{setOutputFormula}{filep}
\calls{setOutputFormula}{make-outstream}
\calls{setOutputFormula}{object2String}
\usesdollar{setOutputFormula}{formulaOutputStream}
\usesdollar{setOutputFormula}{formulaOutputFile}
\usesdollar{setOutputFormula}{filep}
\usesdollar{setOutputFormula}{formulaFormat}
\begin{chunk}{defun setOutputFormula}
(defun |setOutputFormula| (arg)
 (let (label tmp1 tmp2 ptype fn ft fm filename teststream)
 (declare (special |$formulaOutputStream| |$formulaOutputFile| $filep
    |$formulaFormat|))
   (cond
    ((eq arg '|%initialize%|)
     (setq |$formulaOutputStream|
      (defiostream '((mode . output) (device . console)) 255 0))
     (setq |$formulaOutputFile| "CONSOLE")
     (setq |$formulaFormat| nil))
    ((eq arg '|%display%|)
     (if |$formulaFormat|
      (setq label "On:")
      (setq label "Off:"))
     (concat label |$formulaOutputFile|))
    ((or (null arg) (eq arg '|%describe%|) (eq (car arg) '?)) 
     (|describeSetOutputFormula|))
    (t
     (cond
      ((and (consp arg)
            (eq (qcdr arg) nil)
            (progn (setq fn (qcar arg)) t)
            (|member| fn '(y n ye yes no o on of off console
                      |y| |n| |ye| |yes| |no| |o| |on| |of| |off| |console|)))
        '|ok|)
      (t (setq arg (list fn '|sform|))))
     (cond
      ((and (consp arg)
            (eq (qcdr arg) nil)
            (progn (setq fn (qcar arg)) t))
       (cond
        ((|member| (upcase fn) '(y n ye o of))
         (|sayKeyedMsg|
            (format nil
              "To toggle %1 printing on and off, specify %l )set output %2 ~
               yes/no/on/off %l Yes, no, on and off cannot be abbreviated.")
            '(|script| |script|)))
        ((|member| (upcase fn) '(no off)) (setq |$formulaFormat| nil))
        ((|member| (upcase fn) '(yes on)) (setq |$formulaFormat| t))
        ((eq (upcase fn) 'console)
         (SHUT |$formulaOutputStream|)
         (setq |$formulaOutputStream|
          (defiostream '((mode . output) (device . console)) 255 0))
         (setq |$formulaOutputFile| "CONSOLE"))))
      ((or
        (and (consp arg)
             (progn (setq fn (qcar arg))
                    (setq tmp1 (qcdr arg))
                    (and (consp tmp1)
                         (eq (qcdr tmp1) nil)
                         (progn (setq ft (qcar tmp1)) t))))
        (and (consp arg)
             (progn (setq fn (qcar arg))
                    (setq tmp1 (qcdr arg))
                    (and (consp tmp1)
                         (progn (setq ft (qcar tmp1))
                                (setq tmp2 (qcdr tmp1))
                                (and (consp tmp2)
                                     (eq (qcdr tmp2) nil)
                                     (progn 
                                      (setq fm (qcar tmp2)) t)))))))
        (if (setq ptype (|pathnameType| fn))
          (setq fn (concat (|pathnameDirectory| fn) (|pathnameName| fn)))
          (setq ft ptype))
        (unless fm (setq fm 'a))
        (setq filename ($filep fn ft fm))
        (cond
         ((null filename)
          (|sayKeyedMsg|
           "It is not possible to open or create a file called %1 %2 %3 ."
           (list fn ft fm)))
         ((setq teststream (make-outstream filename 255 0))
          (shut |$formulaOutputStream|)
          (setq |$formulaOutputStream| teststream)
          (setq |$formulaOutputFile| (|object2String| filename))
          (|sayKeyedMsg|
           "%1 output will be written to file %2 ." 
           (list "IBM Script formula" |$formulaOutputFile| )))
         (t
          (|sayKeyedMsg|
           "It is not possible to open or create a file called %1 %2 %3 ."
           (list fn ft fm)))))
      (t
       (|sayKeyedMsg| '"Your argument list is not valid." nil)
       (|describeSetOutputFormula|))))))) 

\end{chunk}
\defun{describeSetOutputFormula}{describeSetOutputFormula}
\calls{describeSetOutputFormula}{sayBrightly}
\calls{describeSetOutputFormula}{setOutputFormula}
\begin{chunk}{defun describeSetOutputFormula}
(defun |describeSetOutputFormula| ()
 (|sayBrightly| (list
 " )set output script "
 "is used to tell AXIOM to turn IBM Script formula-style"
 '|%l|
 "output printing on and off, and where to place the output.  By default, the"
 '|%l| "destination for the output is the screen but printing is turned off."
 '|%l|
 '|%l| "Syntax:   )set output script <arg>"
 '|%l| "    where arg can be one of"
 '|%l| "  on          turn IBM Script formula printing on"
 '|%l| "  off         turn IBM Script formula printing off (default state)"
 '|%l| "  console     send IBM Script formula output to screen (default state)"
 '|%l|
 "  fp<.fe>     send IBM Script formula output to file with file prefix fp"
 '|%l|
 "              and file extension .fe. If not given, .fe defaults to .sform."
 '|%l|
 '|%l| "If you wish to send the output to a file, you must issue this command"
 '|%l| "twice: once with"
 " on and once with the file name. For example, to send "
 '|%l| "IBM Script formula output to the file polymer.sform,"
 " issue the two commands"
 '|%l|
 '|%l| "  )set output script on"
 '|%l| "  )set output script polymer"
 '|%l|
 '|%l| "The output is placed in the directory from which you invoked AXIOM or"
 '|%l| "the one you set with the )cd system command."
 '|%l| "The current setting is: "
 (|setOutputFormula| '|%display%|)
 )))

\end{chunk}

\subsection{set output scripts}
\begin{verbatim}
--------------------- The scripts Option ----------------------

 Description: show subscripts,... linearly

 The scripts option may be followed by any one of the following:

    yes
    no

 The current setting is indicated.

\end{verbatim}
\defdollar{linearFormatScripts}
\begin{chunk}{initvars}
(defvar |$linearFormatScripts| nil "show subscripts,... linearly")

\end{chunk}
\begin{chunk}{outputscripts}
     (|scripts|
      "show subscripts,... linearly"
      |interpreter|
      LITERALS
      |$linearFormatScripts|
      (|on| |off|)
      |off|)

\end{chunk}
\subsection{set output showeditor}
\begin{verbatim}
-------------------- The showeditor Option --------------------

 Description: view output of )show in editor

 The showeditor option may be followed by any one of the 
 following:

    on
 -> off 

 The current setting is indicated.

\end{verbatim}
\defdollar{useEditorForShowOutput}
\begin{chunk}{initvars}
(defvar |$useEditorForShowOutput| nil "view output of )show in editor")

\end{chunk}
\begin{chunk}{outputshoweditor}
     (|showeditor|
      "view output of )show in editor"
      |interpreter|
      LITERALS
      |$useEditorForShowOutput|
      (|on| |off|)
      |off|)

\end{chunk}
\subsection{set output tex}
\begin{verbatim}
----------------------- The tex Option ------------------------

 Description: create output in TeX style

 )set output tex is used to tell AXIOM to turn TeX-style output
printing on and off, and where to place the output.  By default,
the destination for the output is the screen but printing is 
turned off.

Syntax:   )set output tex <arg>
    where arg can be one of
  on          turn TeX printing on
  off         turn TeX printing off (default state)
  console     send TeX output to screen (default state)
  fp<.fe>     send TeX output to file with file prefix fp
              and file extension .fe. If not given, 
              .fe defaults to .stex.

If you wish to send the output to a file, you must issue 
this command twice: once with on and once with the file name. 
For example, to send TeX output to the file polymer.stex, 
issue the two commands

  )set output tex on
  )set output tex polymer

The output is placed in the directory from which you invoked 
AXIOM or the one you set with the )cd system command.
The current setting is:  Off:CONSOLE 
\end{verbatim}
\defdollar{texFormat}
\begin{chunk}{initvars}
(defvar |$texFormat| nil "create output in TeX format ")

\end{chunk}
\defdollar{texOutputFile}
\begin{chunk}{initvars}
(defvar |$texOutputFile| "CONSOLE" 
    "where TeX output goes (enter {\em console} or a pathname)")

\end{chunk}
\begin{chunk}{outputtex}
     (|tex|
      "create output in TeX style "
      |interpreter|
      FUNCTION
      |setOutputTex|
      (("create output in TeX format "
        LITERALS
        |$texFormat|
        (|off| |on|)
        |off|)
       (|break| |$texFormat|)
       ("where TeX output goes (enter {\em console} or a pathname)"
        FILENAME
        |$texOutputFile|
        |chkOutputFileName|
        "console"))
      NIL)

\end{chunk}

\defun{setOutputTex}{setOutputTex}
\calls{setOutputTex}{defiostream}
\calls{setOutputTex}{concat}
\calls{setOutputTex}{describeSetOutputTex}
\calls{setOutputTex}{qcdr}
\calls{setOutputTex}{qcar}
\calls{setOutputTex}{member}
\calls{setOutputTex}{upcase}
\calls{setOutputTex}{sayKeyedMsg}
\calls{setOutputTex}{shut}
\calls{setOutputTex}{pathnameType}
\calls{setOutputTex}{pathnameDirectory}
\calls{setOutputTex}{pathnameName}
\callsdollar{setOutputTex}{filep}
\calls{setOutputTex}{make-outstream}
\calls{setOutputTex}{object2String}
\usesdollar{setOutputTex}{texOutputStream}
\usesdollar{setOutputTex}{texOutputFile}
\usesdollar{setOutputTex}{texFormat}
\usesdollar{setOutputTex}{filep}
\begin{chunk}{defun setOutputTex}
(defun |setOutputTex| (arg)
 (let (label tmp1 tmp2 ptype fn ft fm filename teststream)
  (declare (special |$texOutputStream| |$texOutputFile| |$texFormat| $filep))
  (cond 
   ((eq arg '|%initialize%|)
    (setq |$texOutputStream| 
     (defiostream '((mode . output) (device . console)) 255 0))
    (setq |$texOutputFile| "CONSOLE")
    (setq |$texFormat| nil))
   ((eq arg '|%display%|)
    (if |$texFormat| 
     (setq label "On:")
     (setq label "Off:"))
    (concat label |$texOutputFile|))
   ((or (null arg) (eq arg '|%describe%|) (eq (car arg) '?))
    (|describeSetOutputTex|))
   (t
    (cond
     ((and (consp arg)
           (eq (qcdr arg) nil)
           (progn (setq fn (qcar arg)) t)
           (|member| fn '(y n ye yes no o on of off console 
                 |y| |n| |ye| |yes| |no| |o| |on| |of| |off| |console|)))
       '|ok|)
     (t (setq arg (list fn '|stex| nil))))
    (cond
     ((and (consp arg)
           (eq (qcdr arg) nil)
           (progn (setq fn (qcar arg)) t))
      (cond 
       ((|member| (upcase fn) '(y n ye o of))
        (|sayKeyedMsg|
            (format nil
              "To toggle %1 printing on and off, specify %l )set output %2 ~
               yes/no/on/off %l Yes, no, on and off cannot be abbreviated.")
           '(|TeX| |tex|)))
       ((|member| (upcase fn) '(no off)) (setq |$texFormat| nil))
       ((|member| (upcase fn) '(yes on)) (setq |$texFormat| t))
       ((eq (upcase fn) 'console)
        (shut |$texOutputStream|)
        (setq |$texOutputStream|
          (defiostream '((mode . output) (device . console)) 255 0))
        (setq |$texOutputFile| "CONSOLE"))))
     ((or 
       (and (consp arg)
            (progn (setq fn (qcar arg))
                   (setq tmp1 (qcdr arg))
                   (and (consp tmp1)
                        (eq (qcdr tmp1) nil)
                        (progn (setq ft (qcar tmp1)) t))))
      (and (consp arg)
           (progn (setq fn (qcar arg))
                  (setq tmp1 (qcdr arg))
                  (and (consp tmp1)
                  (progn (setq ft (qcar tmp1))
                         (setq tmp2 (qcdr tmp1))
                         (and (consp tmp2)
                              (eq (qcdr tmp2) nil)
                              (progn (setq fm (qcar tmp2)) t)))))))
      (when (setq ptype (|pathnameType| fn))
       (setq fn (concat (|pathnameDirectory| fn) (|pathnameName| fn)))
       (setq ft ptype))
      (unless fm (setq fm 'A))
      (setq filename ($filep fn ft fm))
      (cond
       ((null filename)
         (|sayKeyedMsg|
          "It is not possible to open or create a file called %1 %2 %3 ."
          (list fn ft fm )))
       ((setq teststream (make-outstream filename 255 0))
        (shut |$texOutputStream|)
        (setq |$texOutputStream| teststream)
        (setq |$texOutputFile| (|object2String| filename))
        (|sayKeyedMsg|
         "%1 output will be written to file %2 ."
         (list "TeX" |$texOutputFile|)))
       (t (|sayKeyedMsg|
           "It is not possible to open or create a file called %1 %2 %3 ."
           (list fn ft fm )))))
     (t
      (|sayKeyedMsg| "Your argument list is not valid." nil)
      (|describeSetOutputTex|))))))) 

\end{chunk}

\defun{describeSetOutputTex}{describeSetOutputTex}
\calls{describeSetOutputTex}{sayBrightly}
\calls{describeSetOutputTex}{setOutputTex}
\begin{chunk}{defun describeSetOutputTex}
(defun |describeSetOutputTex| ()
 (|sayBrightly| (list
 " )set output tex "
 "is used to tell AXIOM to turn TeX-style output"
 '|%l| "printing on and off, and where to place the output.  By default, the"
 '|%l| "destination for the output is the screen but printing is turned off."
 '|%l|
 '|%l| "Syntax:   )set output tex <arg>"
 '|%l| "    where arg can be one of"
 '|%l| "  on          turn TeX printing on"
 '|%l| "  off         turn TeX printing off (default state)"
 '|%l| "  console     send TeX output to screen (default state)"
 '|%l| "  fp<.fe>     send TeX output to file with file prefix fp and file"
 '|%l| "              extension .fe. If not given, .fe defaults to .stex."
 '|%l|
 '|%l| "If you wish to send the output to a file, you must issue this command"
 '|%l| "twice: once with"
 " on and once with the file name. For example, to send"
 '|%l| "TeX output to the file polymer.stex, issue the two commands"
 '|%l|
 '|%l| "  )set output tex on"
 '|%l| "  )set output tex polymer"
 '|%l|
 '|%l| "The output is placed in the directory from which you invoked AXIOM or"
 '|%l| "the one you set with the )cd system command."
 '|%l| "The current setting is: "
 (|setOutputTex| '|%display%|)
 )))

\end{chunk}

\section{\enspace{}quit}
\begin{verbatim}
----------------------- The quit Option -----------------------

 Description: protected or unprotected quit

 The quit option may be followed by any one of the following:

    protected
 -> unprotected 

 The current setting is indicated.

\end{verbatim}
\defdollar{quitCommandType}
\begin{chunk}{initvars}
(defvar |$quitCommandType| '|unprotected| "protected or unprotected quit")

\end{chunk}
\begin{chunk}{quit}
  (|quit|
   "protected or unprotected quit"
   |interpreter|
   LITERALS
   |$quitCommandType|
   (|protected| |unprotected|)
   |unprotected|)

\end{chunk}

\section{\enspace{}streams}
\begin{verbatim}
              Current Values of  streams  Variables                   

Variable     Description                           Current Value
-----------------------------------------------------------------
calculate    specify number of elements to calculate    10 
showall      display all stream elements computed       off 

\end{verbatim}
\begin{chunk}{streams}
  (|streams|
   "set some options for working with streams"
   |interpreter|
   TREE
   |novar|
   (
\getchunk{streamscalculate}
\getchunk{streamsshowall}
  ))

\end{chunk}

\subsection{set streams calculate}
\begin{verbatim}
-------------------- The calculate Option ---------------------

 Description: specify number of elements to calculate

   )set streams calculate is used to tell AXIOM how many elements
    of a stream to calculate when a computation uses the stream. 
    The value given after calculate must either be the word all 
    or a positive integer.

      The current setting is 10 .
\end{verbatim}
\defdollar{streamCount}
\begin{chunk}{initvars}
(defvar |$streamCount| 10 
    "number of initial stream elements you want calculated")

\end{chunk}
\begin{chunk}{streamscalculate}
     (|calculate|
      "specify number of elements to calculate "
      |interpreter|
      FUNCTION
      |setStreamsCalculate|
      (("number of initial stream elements you want calculated "
       INTEGER
       |$streamCount|
       (0 NIL)
       10))
      NIL)

\end{chunk}

\defun{setStreamsCalculate}{setStreamsCalculate}
\calls{setStreamsCalculate}{object2String}
\calls{setStreamsCalculate}{describeSetStreamsCalculate}
\calls{setStreamsCalculate}{sayMessage}
\calls{setStreamsCalculate}{bright}
\calls{setStreamsCalculate}{terminateSystemCommand}
\usesdollar{setStreamsCalculate}{streamCount}
\begin{chunk}{defun setStreamsCalculate}
(defun |setStreamsCalculate| (arg) 
 (let (n) 
  (declare (special |$streamCount|))
  (cond 
   ((eq arg '|%initialize%|) (setq |$streamCount| 10))
   ((eq arg '|%display%|) (|object2String| |$streamCount|))
   ((or (null arg) (eq arg '|%describe%|) (eq (car arg) '?))
     (|describeSetStreamsCalculate|))
   (t
     (setq n (car arg))
     (cond 
      ((and (not (eq n '|all|)) (or (null (integerp n)) (minusp n)))
        (|sayMessage| 
         `("Your value of" ,@(|bright| n) "is invalid because ..."))
        (|describeSetStreamsCalculate|)
        (|terminateSystemCommand|))
      (t (setq |$streamCount| n)))))))

\end{chunk}

\defun{describeSetStreamsCalculate}{describeSetStreamsCalculate}
\calls{describeSetStreamsCalculate}{sayKeyedMsg}
\usesdollar{describeSetStreamsCalculate}{streamCount}
\begin{chunk}{defun describeSetStreamsCalculate}
(defun |describeSetStreamsCalculate| ()
 (declare (special |$streamCount|))
 (|sayKeyedMsg|
  (format nil
   ")set streams calculate is used to tell Axiom how many elements of a ~
    stream to calculate when a computation uses the stream. The value ~
    given after calculate must either be the word all or a positive ~
    integer.  %l %l The current setting is %1 .")
   (list |$streamCount|))) 

\end{chunk}

\subsection{set streams showall}
\begin{verbatim}
--------------------- The showall Option ----------------------

 Description: display all stream elements computed

 The showall option may be followed by any one of the following:

    on
 -> off 

 The current setting is indicated.

\end{verbatim}
\defdollar{streamsShowAll}
\begin{chunk}{initvars}
(defvar |$streamsShowAll| nil "display all stream elements computed")

\end{chunk}
\begin{chunk}{streamsshowall}
    (|showall|
     "display all stream elements computed"
     |interpreter|
     LITERALS
     |$streamsShowAll|
     (|on| |off|)
     |off|)

\end{chunk}

\section{\enspace{}set system}
\begin{verbatim}
              Current Values of  system  Variables                    

Variable     Description                           Current Value
-----------------------------------------------------------------
functioncode show gen. LISP for functions when compiled off 
optimization show optimized LISP code                   off 
prettyprint  prettyprint BOOT func's as they compile    off 

\end{verbatim}
\begin{chunk}{system}
  (|system|
   "set some system development variables"
   |development|
   TREE
   |novar|
   (
\getchunk{systemfunctioncode}
\getchunk{systemoptimization}
\getchunk{systemprettyprint}
   ))

\end{chunk}

\subsection{set system functioncode}
\begin{verbatim}
------------------- The functioncode Option -------------------

 Description: show gen. LISP for functions when compiled

 The functioncode option may be followed by any one of the 
 following:

    on
 -> off 

 The current setting is indicated.

\end{verbatim}
\defdollar{reportCompilation}
\begin{chunk}{initvars}
(defvar |$reportCompilation| nil "show gen. LISP for functions when compiled")

\end{chunk}
\begin{chunk}{systemfunctioncode}
     (|functioncode|
      "show gen. LISP for functions when compiled"
      |development|
      LITERALS
      |$reportCompilation|
      (|on| |off|)
      |off|)

\end{chunk}

\subsection{set system optimization}
\begin{verbatim}
------------------- The optimization Option -------------------

 Description: show optimized LISP code

 The optimization option may be followed by any one of the 
 following:

    on
 -> off 

 The current setting is indicated.

\end{verbatim}
\defdollar{reportOptimization}
\begin{chunk}{initvars}
(defvar |$reportOptimization| nil "show optimized LISP code")

\end{chunk}
\begin{chunk}{systemoptimization}
     (|optimization|
      "show optimized LISP code"
      |development|
      LITERALS
      |$reportOptimization|
      (|on| |off|)
      |off|)

\end{chunk}

\subsection{set system prettyprint}
\begin{verbatim}
------------------- The prettyprint Option --------------------

 Description: prettyprint BOOT func's as they compile

 The prettyprint option may be followed by any one of the 
 following:

    on
 -> off 

 The current setting is indicated.

\end{verbatim}
\defdollar{prettyprint}
\begin{chunk}{initvars}
(defvar $prettyprint t "prettyprint BOOT func's as they compile")

\end{chunk}
\begin{chunk}{systemprettyprint}
     (|prettyprint|
      "prettyprint BOOT func's as they compile"
      |development|
      LITERALS
      $prettyprint
      (|on| |off|)
      |on|)

\end{chunk}

\section{\enspace{}set userlevel}
\begin{verbatim}
-------------------- The userlevel Option ---------------------

 Description: operation access level of system user

 The userlevel option may be followed by any one of the 
 following:

    interpreter
    compiler
 -> development 

 The current setting is indicated.

\end{verbatim}
\defdollar{UserLevel}
\begin{chunk}{initvars}
(defvar |$UserLevel| '|development| "operation access level of system user")

\end{chunk}
\begin{chunk}{userlevel}
  (|userlevel|
   "operation access level of system user"
   |interpreter|
   LITERALS
   |$UserLevel|
   (|interpreter| |compiler| |development|)
   |development|)

\end{chunk}
\begin{chunk}{initvars}
(defvar |$setOptions| '(
\getchunk{breakmode}
\getchunk{compile}
\getchunk{debug}
\getchunk{expose}
\getchunk{functions}
\getchunk{fortran}
\getchunk{kernel}
\getchunk{hyperdoc}
\getchunk{help}
\getchunk{history}
\getchunk{messages}
\getchunk{naglink}
\getchunk{output}
\getchunk{quit}
\getchunk{streams}
\getchunk{system}
\getchunk{userlevel}
 ))

\end{chunk}

\defdollar{setOptionNames}
\begin{chunk}{initvars}
(defvar |$setOptionNames| (mapcar #'car |$setOptions|))

\end{chunk}

\begin{chunk}{postvars}
(eval-when (eval load)
 (|initializeSetVariables| |$setOptions|))

\end{chunk}

\section{\enspace{}Set code}

\defun{set}{set}
\calls{set}{set1}
\usesdollar{set}{setOptions}
\begin{chunk}{defun set}
(defun |set| (l)
 (declare (special |$setOptions|))
 (|set1| l |$setOptions|)) 

\end{chunk}
\defun{set1}{set1}
This function will be called with the top level arguments to )set.
For instance, given the command
\begin{verbatim}
   )set break break
\end{verbatim}
this function gets 
\begin{verbatim}
   (set1 (|break| |break|) ....)
\end{verbatim}
and given the command
\begin{verbatim}
   )set mes auto off
\end{verbatim}
this function gets 
\begin{verbatim}
   (set1 (|mes| |auto| |off|) ....)
\end{verbatim}
which, because ``message'' is a TREE, generates the recursive call:
\begin{verbatim}
   (set1 (|auto| |off|) <the message subtree>)
\end{verbatim}
The ``autoload'' subtree contains a FUNCTION called 
printLoadMessages, which gets called with \verb|%describe%|

\calls{set1}{displaySetVariableSettings}
\calls{set1}{seq}
\calls{set1}{exit}
\calls{set1}{selectOption}
\calls{set1}{downcase}
\calls{set1}{lassoc}
\calls{set1}{satisfiesUserLevel}
\calls{set1}{sayKeyedMsg}
\calls{set1}{poundsign}
\calls{set1}{displaySetOptionInformation}
\calls{set1}{sayMSG}
\calls{set1}{sayMessage}
\calls{set1}{bright}
\calls{set1}{object2String}
\calls{set1}{translateYesNo2TrueFalse}
\calls{set1}{use-fast-links}
\calls{set1}{literals}
\calls{set1}{tree}
\calls{set1}{set1}
\usesdollar{set1}{setOptionNames}
\usesdollar{set1}{UserLevel}
\usesdollar{set1}{displaySetValue}
\begin{chunk}{defun set1}
(defun |set1| (l settree)
 (let (|$setOptionNames| arg setdata st setfunarg num upperlimit arg2)
  (declare (special |$setOptionNames| |$UserLevel| |$displaySetValue|))
  (cond
   ((null l) (|displaySetVariableSettings| settree '||))
   (t
    (setq |$setOptionNames|
      (do ((t1 settree (cdr t1)) t0 (x nil))
          ((or (atom t1) (progn (setq x (car t1)) nil)) (nreverse0 t0))
       (seq
        (exit 
         (setq t0 (cons (elt x 0) t0))))))
    (setq arg 
     (|selectOption| (downcase (car l)) |$setOptionNames| '|optionError|))
    (setq setdata (cons arg (lassoc arg settree)))
    (cond
     ((null (|satisfiesUserLevel| (third setdata)))
      (|sayKeyedMsg| 
        "Your %1 is ambiguous. The following are abbreviated by %2 :"
        (list |$UserLevel| "set option" nil)))
     ((eql 1 (|#| l)) (|displaySetOptionInformation| arg setdata))
     (t
      (setq st (fourth setdata))
      (case (fourth setdata)
       (function
        (setq setfunarg
         (if (eq (elt l 1) 'default) 
          '|%initialize%|
          (ifcdr l)))
        (if (canFuncall? (fifth setdata))
          (funcall (fifth setdata) setfunarg)
          (|sayMSG| (concatenate 'string "   Function not implemented. "
           (string (fifth setdata)))))
        (when |$displaySetValue|
         (|displaySetOptionInformation| arg setdata))
        NIL)
       (string
        (setq arg2 (elt l 1))
        (cond
         ((eq arg2 'default) (set (fifth setdata) (seventh setdata)))
         (arg2 (set (fifth setdata) arg2))
         (t nil))
        (when (or |$displaySetValue| (null arg2))
         (|displaySetOptionInformation| arg setdata))
        NIL)
       (integer
        (setq arg2
         (progn
          (setq num (elt l 1))
          (cond
           ((and (integerp num)
                 (>= num (elt (sixth setdata) 0))
                 (or (null (setq upperlimit (elt (sixth setdata) 1)))
                     (<= num upperlimit)))
            num)
           (t
            (|selectOption| 
             (elt l 1)
             (cons '|default| (sixth setdata)) nil)))))
        (cond
         ((eq arg2 'default) (set (fifth setdata) (seventh setdata)))
         (arg2 (set (fifth setdata) arg2))
         (t nil))
        (cond
         ((or |$displaySetValue| (null arg2))
          (|displaySetOptionInformation| arg setdata)))
        (cond
         ((null arg2)
          (|sayMessage| 
           `(" Your value" ,@(|bright| (|object2String| (elt l 1)))
             "is not among the valid choices.")))
         (t nil)))
       (literals
        (cond
         ((setq arg2
          (|selectOption| (elt l 1) 
           (cons '|default| (sixth setdata)) nil))
          (cond
           ((eq arg2 'default)
            (set (fifth setdata) 
              (|translateYesNo2TrueFalse| (seventh setdata))))
           (t
            (cond ((eq arg2 '|nobreak|) 
              #+:GCL (si::use-fast-links t)))
            (cond 
             ((eq arg2 '|fastlinks|)
              #+:GCL (si::use-fast-links nil)
              (setq arg2 '|break|)))
            (set (fifth setdata) (|translateYesNo2TrueFalse| arg2))))))
        (when (or |$displaySetValue| (null arg2))
          (|displaySetOptionInformation| arg setdata))
        (cond
         ((null arg2)
          (|sayMessage|
           (cons " Your value"
            (append (|bright| (|object2String| (elt l 1)))
             (cons "is not among the valid choices." nil)))))
         (t nil)))
       (tree (|set1| (ifcdr l) (sixth setdata)) nil)
       (t 
        (|sayMessage|
         `("Cannot handle set tree node type" ,@(|bright| st) |yet|))
        nil))))))))

\end{chunk}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{show}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{show.help}
====================================================================
A.22.  )show
====================================================================
 
User Level Required:  interpreter
 
Command Syntax: 
 
  - )show nameOrAbbrev
  - )show nameOrAbbrev )operations
  - )show nameOrAbbrev )attributes
 
Command Description: 
This command displays information about AXIOM domain, package and category
constructors. If no options are given, the )operations option is assumed. For
example,
 
)show POLY
)show POLY )operations
)show Polynomial
)show Polynomial )operations
 
each display basic information about the Polynomial domain constructor and
then provide a listing of operations. Since Polynomial requires a Ring (for
example, Integer) as argument, the above commands all refer to a unspecified
ring R. In the list of operations, $ means Polynomial(R).
 
The basic information displayed includes the signature of the constructor
(the name and arguments), the constructor abbreviation, the exposure status
of the constructor, and the name of the library source file for the
constructor.
 
If operation information about a specific domain is wanted, the full or
abbreviated domain name may be used. For example,
 
)show POLY INT
)show POLY INT )operations
)show Polynomial Integer
)show Polynomial Integer )operations
 
are among the combinations that will display the operations exported by the
domain Polynomial(Integer) (as opposed to the general domain constructor
Polynomial). Attributes may be listed by using the )attributes option.
 
Also See: 
o )display
o )set
o )what
 
\end{chunk} 
\footnote{
\fnref{display}
\fnref{set}
\fnref{what}}

\defun{show}{The )show command}
\calls{show}{showSpad2Cmd}
\begin{chunk}{defun show}
(defun |show| (arg) (|showSpad2Cmd| arg)) 

\end{chunk}

\defun{showSpad2Cmd}{The internal )show command}
\calls{showSpad2Cmd}{member}
\calls{showSpad2Cmd}{helpSpad2Cmd}
\calls{showSpad2Cmd}{sayKeyedMsg}
\calls{showSpad2Cmd}{qcar}
\calls{showSpad2Cmd}{reportOperations}
\usesdollar{showSpad2Cmd}{showOptions}
\usesdollar{showSpad2Cmd}{e}
\usesdollar{showSpad2Cmd}{env}
\usesdollar{showSpad2Cmd}{InteractiveFrame}
\usesdollar{showSpad2Cmd}{options}
\begin{chunk}{defun showSpad2Cmd}
(defun |showSpad2Cmd| (arg)
 (let (|$showOptions| |$e| |$env| constr)
 (declare (special |$showOptions| |$e| |$env| |$InteractiveFrame| |$options|))
  (if (equal arg (list nil))
   (|helpSpad2Cmd| '(|show|))
   (progn
    (setq |$showOptions| '(|attributes| |operations|))
    (unless |$options| (setq |$options| '((|operations|))))
    (setq |$e| |$InteractiveFrame|)
    (setq |$env| |$InteractiveFrame|)
    (cond
     ((and (consp arg) (eq (qcdr arg) nil) (progn (setq constr (qcar arg)) t))
      (cond
       ((|member| constr '(|Union| |Record| |Mapping|))
        (cond
         ((eq constr '|Record|)
           (|sayKeyedMsg|
            (format nil
             "Record(a:A,...,b:B) %l Record takes any number of ~
              selector-domain pairs as arguments: %i %l a, a selector, an ~
              element of domain Symbol %l A, a domain of category ~
              SetCategory %l ... %l b, a selector, an element of domain ~
              Symbol %l B, a domain of category SetCategory %u %l ~
              This constructor is a primitive in Axiom. ~
              The selectors a,...,b of a Record type must be distinct. %l %l ~
              In order for more information to be displayed about %1 , ~
              you must give it specific arguments. For example: %2 %l ~
              You can also use the HyperDoc Browser.")
            (list constr ")show Record(a: Integer, b: String)" )))
         ((eq constr '|Mapping|)
           (|sayKeyedMsg|
            (format nil
             "Mapping(T, S, ...) %l Mapping takes any number of arguments ~
              of the form: %i %l T, a domain of category SetCategory %l ~
              S, a domain of category SetCategory %l ... %u %l ~
              Mapping(T, S, ...) denotes the class of objects which are ~
              mappings from a source domain (S, ...) into a target domain T. ~
              The Mapping constructor can take any number of arguments. ~
              All but the first argument is regarded as part of a source ~
              tuple for the mapping. For example, Mapping(T, A, B) denotes ~
              the class of mappings from (A, B) into T. %l ~
              This constructor is a primitive in Axiom. ~
              For more information, use the HyperDoc Browser.")
            nil))
         (t
          (|sayKeyedMsg| 
            (format nil
             "Tagged union: Union(a:A, ..., b:B) %l Union takes any number ~
              of 'tag'-domain pairs of arguments: %i %l a, a tag, an ~
              element of domain Symbol %l A, a domain of category ~
              SetCategory %l ... %l b, a tag, an element of domain ~
              Symbol %l B, a domain of category SetCategory %u %l ~
              This constructor is a primitive in Axiom. ~
              In this tagged Union, tags a, ..., b must be distinct. %l %l ~
              In order for more information to be displayed about %1 , ~
              you must give it specific arguments. For example: %2 %l ~
              You can also use the HyperDoc Browser.")
            (list constr ")show Union(a: Integer, b: String)" )))
          (|sayKeyedMsg| 
           (format nil
            "Untagged union: Union(A, ..., B) %l Union takes any number ~
             of domain arguments: %i %l A, a domain of category ~
             SetCategory %l ... %l B, a domain of category SetCategory %u %l ~
             In this untagged form of Union, domains A, ..., B must be ~
             distinct. In order for more information to be displayed about ~
             %1 , you must give it specific arguments. For example: %2 %l ~
             You can also use the HyperDoc Browser.")
            (list constr ")show Union(Integer, String)" ))))
       ((and (consp constr) (eq (qcar constr) '|Mapping|))
          (|sayKeyedMsg| 
            (format nil
             "Mapping(T, S, ...) %l Mapping takes any number of arguments ~
              of the form: %i %l T, a domain of category SetCategory %l ~
              S, a domain of category SetCategory %l ... %u %l ~
              Mapping(T, S, ...) denotes the class of objects which are ~
              mappings from a source domain (S, ...) into a target domain T. ~
              The Mapping constructor can take any number of arguments. ~
              All but the first argument is regarded as part of a source ~
              tuple for the mapping. For example, Mapping(T, A, B) denotes ~
              the class of mappings from (A, B) into T. %l ~
              This constructor is a primitive in Axiom. ~
              For more information, use the HyperDoc Browser.")
            nil))
       (t (|reportOperations| constr constr))))
     (t (|reportOperations| arg arg)))))))

\end{chunk}

\defun{reportOperations}{reportOperations}
\calls{reportOperations}{sayBrightly}
\calls{reportOperations}{bright}
\calls{reportOperations}{sayKeyedMsg}
\calls{reportOperations}{qcar}
\calls{reportOperations}{isNameOfType}
\calls{reportOperations}{isDomainValuedVariable}
\calls{reportOperations}{reportOpsFromUnitDirectly0}
\calls{reportOperations}{opOf}
\calls{reportOperations}{unabbrev}
\calls{reportOperations}{reportOpsFromLisplib0}
\calls{reportOperations}{evaluateType}
\calls{reportOperations}{mkAtree}
\calls{reportOperations}{removeZeroOneDestructively}
\calls{reportOperations}{isType}
\usesdollar{reportOperations}{env}
\usesdollar{reportOperations}{eval}
\usesdollar{reportOperations}{genValue}
\usesdollar{reportOperations}{quadSymbol}
\usesdollar{reportOperations}{doNotAddEmptyModeIfTrue}
\begin{chunk}{defun reportOperations}
(defun |reportOperations| (oldArg u)
 (let (|$env| |$eval| |$genValue| |$doNotAddEmptyModeIfTrue|
                tmp1 v unitForm tree unitFormp)
 (declare (special |$env| |$eval| |$genValue| |$quadSymbol|
                      |$doNotAddEmptyModeIfTrue|))
  (setq |$env| (list (list nil)))
  (setq |$eval| t)
  (setq |$genValue| t)
  (when u
   (setq |$doNotAddEmptyModeIfTrue| t)
   (cond 
    ((equal u |$quadSymbol|)
     (|sayBrightly|
       (cons "   mode denotes" (append (|bright| "any") (list '|type|)))))
    ((eq u '%)
     (|sayKeyedMsg|
      (format nil
       "The )show system command is used to display information about ~
        types or partial types.  For example, )show Integer will show ~
        information about Integer.")
       nil)
     (|sayKeyedMsg| 
      (format nil
       "%l %% is a special variable holding the result of the last ~
        computation. Issue )display properties %% to see this value.")
        nil))
    ((and (null (and (consp u) (eq (qcar u) '|Record|)))
          (null (and (consp u) (eq (qcar u) '|Union|)))
          (null (|isNameOfType| u))
          (null (and (consp u)
                     (eq (qcar u) '|typeOf|)
                     (progn
                      (setq tmp1 (qcdr u))
                      (and (consp tmp1) (eq (qcdr tmp1) nil))))))
     (when (atom oldArg) (setq oldArg (list oldArg)))
     (|sayKeyedMsg|
      (format nil
       "The )show system command is used to display information about ~
        types or partial types.  For example, )show Integer will show ~
        information about Integer.")
       nil)
     (dolist (op oldArg)
       (|sayKeyedMsg|
        (format nil
         "%l %1 is not the name of a known type constructor. If you want ~
          to see information about any operations named %1, issue ~
          %ceon )display operations %1 %ceoff")
        (list (|opOf| op)))))
    ((setq v (|isDomainValuedVariable| u)) (|reportOpsFromUnitDirectly0| v))
    (t
      (if (atom u)
       (setq unitForm (|opOf| (|unabbrev| u)))
       (setq unitForm (|unabbrev| u)))
      (if (atom unitForm)
       (|reportOpsFromLisplib0| unitForm u)
       (progn
        (setq unitFormp (|evaluateType| unitForm))
        (setq tree (|mkAtree| (|removeZeroOneDestructively| unitForm)))
        (if (setq unitFormp (|isType| tree))
          (|reportOpsFromUnitDirectly0| unitFormp)
          (|sayKeyedMsg|
           (format nil
            "It is not known what %1p is, so no information about it can be ~
             displayed.")
           (list unitForm))))))))))

\end{chunk}

\defun{reportOpsFromLisplib0}{reportOpsFromLisplib0}
\calls{reportOpsFromLisplib0}{reportOpsFromLisplib1}
\calls{reportOpsFromLisplib0}{reportOpsFromLisplib}
\usesdollar{reportOpsFromLisplib0}{useEditorForShowOutput}
\begin{chunk}{defun reportOpsFromLisplib0}
(defun |reportOpsFromLisplib0| (unitForm u)
 (declare (special |$useEditorForShowOutput|))
  (if |$useEditorForShowOutput|
   (|reportOpsFromLisplib1| unitForm u)
   (|reportOpsFromLisplib| unitForm u)))

\end{chunk}

\defun{reportOpsFromLisplib1}{reportOpsFromLisplib1}
\calls{reportOpsFromLisplib1}{pathname}
\calls{reportOpsFromLisplib1}{erase}
\calls{reportOpsFromLisplib1}{defiostream}
\calls{reportOpsFromLisplib1}{sayShowWarning}
\calls{reportOpsFromLisplib1}{reportOpsFromLisplib}
\calls{reportOpsFromLisplib1}{shut}
\calls{reportOpsFromLisplib1}{editFile}
\usesdollar{reportOpsFromLisplib1}{sayBrightlyStream}
\usesdollar{reportOpsFromLisplib1}{erase}
\begin{chunk}{defun reportOpsFromLisplib1}
(defun |reportOpsFromLisplib1| (unitForm u)
 (let (|$sayBrightlyStream| showFile)
 (declare (special |$sayBrightlyStream| $erase))
  (setq showFile (|pathname| (list 'show 'listing 'a)))
  ($erase showFile)
  (setq |$sayBrightlyStream|
   (defiostream `((file ,showFile) (mode . output)) 255 0))
  (|sayShowWarning|)
  (|reportOpsFromLisplib| unitForm u)
  (shut |$sayBrightlyStream|)
  (|editFile| showFile)))

\end{chunk}

\defun{reportOpsFromLisplib}{reportOpsFromLisplib}
\calls{reportOpsFromLisplib}{constructor?}
\calls{reportOpsFromLisplib}{sayKeyedMsg}
\calls{reportOpsFromLisplib}{getConstructorSignature}
\calls{reportOpsFromLisplib}{ifcdr}
\calls{reportOpsFromLisplib}{getdatabase}
%\calls{reportOpsFromLisplib}{#}
\calls{reportOpsFromLisplib}{eqsubstlist}
\calls{reportOpsFromLisplib}{nreverse0}
\calls{reportOpsFromLisplib}{sayBrightly}
\calls{reportOpsFromLisplib}{concat}
\calls{reportOpsFromLisplib}{bright}
\calls{reportOpsFromLisplib}{form2StringWithWhere}
\calls{reportOpsFromLisplib}{isExposedConstructor}
\calls{reportOpsFromLisplib}{concat}
\calls{reportOpsFromLisplib}{namestring}
\calls{reportOpsFromLisplib}{selectOptionLC}
\calls{reportOpsFromLisplib}{dc1}
\calls{reportOpsFromLisplib}{specialChar}
\calls{reportOpsFromLisplib}{remdup}
\calls{reportOpsFromLisplib}{msort}
\calls{reportOpsFromLisplib}{form2String}
\calls{reportOpsFromLisplib}{say2PerLine}
\calls{reportOpsFromLisplib}{formatAttribute}
\calls{reportOpsFromLisplib}{displayOperationsFromLisplib}
\usesdollar{reportOpsFromLisplib}{linelength}
\usesdollar{reportOpsFromLisplib}{showOptions}
\usesdollar{reportOpsFromLisplib}{options}
\usesdollar{reportOpsFromLisplib}{FormalMapVariableList}
\begin{chunk}{defun reportOpsFromLisplib}
(defun |reportOpsFromLisplib| (op u)
 (let (fn s typ nArgs argList functorForm argml tmp1 functorFormWithDecl 
       verb sourceFile opt attList)
 (declare (special $linelength |$showOptions| |$options|
                   |$FormalMapVariableList|))
  (if (null (setq fn (|constructor?| op)))
   (|sayKeyedMsg| "%1 is unknown, so no information is available." (list u))
   (progn
    (setq argml (when (setq s (|getConstructorSignature| op)) (ifcdr s)))
    (setq typ (getdatabase op 'constructorkind))
    (setq nArgs (|#| argml))
    (setq argList (ifcdr (getdatabase op 'constructorform)))
    (setq functorForm (cons op argList))
    (setq argml (eqsubstlist argList |$FormalMapVariableList| argml))
    (mapcar #'(lambda (a m) (push (list '|:| a m) tmp1)) argList argml)
    (setq functorFormWithDecl (cons op (nreverse0 tmp1)))
    (|sayBrightly|
     (|concat| (|bright| (|form2StringWithWhere| functorFormWithDecl))
               "is a" (|bright| typ) "constructor"))
    (|sayBrightly|
     (cons " Abbreviation for"
      (append (|bright| op) (cons "is" (|bright| fn)))))
    (if (|isExposedConstructor| op)
     (setq verb "is")
     (setq verb "is not"))
    (|sayBrightly|
     (cons " This constructor"
      (append (|bright| verb) (list "exposed in this frame."))))
    (setq sourceFile (getdatabase op 'sourcefile))
    (|sayBrightly|
     (cons " Issue"
      (append (|bright| (concat ")edit " (|namestring| sourceFile)))
              (cons "to see algebra source code for"
               (append (|bright| fn) (list '|%l|))))))
;TPDHERE -- add domain doc to output
;    (setq domaindoc (car (cdadar (getdatabase op 'documentation))))
;    (|sayBrightly| (cleanupLine domaindoc))
;    (terpri)
    (dolist (item |$options|)
     (setq opt (|selectOptionLC| (car item) |$showOptions| '|optionError|))
     (cond
      ((eq opt '|layout|) (|dc1| fn))
      ((eq opt '|views|)
       (|sayBrightly|
        (cons "To get" (append (|bright| "views")
          (list "you must give parameters of constructor")))))
      ((eq opt '|attributes|)
       (format t "~v,,,'-:@<~a~>~%" (- $linelength 2) " Attributes ")
       (|sayBrightly| "")
       (setq attList
        (remdup
         (msort
          (mapcar #'(lambda (x) (caar x))
           (reverse (getdatabase op 'attributes))))))
       (if (null attList)
        (|sayBrightly|
         (|concat| (|form2String| functorForm)
                   '|has no attributes.| '|%l|))
         (|say2PerLine| (mapcar #'|formatAttribute| attList))))
      ((eq opt '|operations|)
       (|displayOperationsFromLisplib| functorForm))))))))

\end{chunk}

\defun{isExposedConstructor}{isExposedConstructor}
\calls{isExposedConstructor}{getalist}
\refsdollar{isExposedConstructor}{localExposureData}
\refsdollar{isExposedConstructor}{globalExposureGroupAlist}
\begin{chunk}{defun isExposedConstructor}
(defun |isExposedConstructor| (name)
 (let (x found)
 (declare (special |$globalExposureGroupAlist| |$localExposureData|))
  (cond
    ((member name '(|Union| |Record| |Mapping|)) t)
    ((member name (elt |$localExposureData| 2)) nil)
    ((member name (elt |$localExposureData| 1)) t)
    (t 
     (loop for g in (elt |$localExposureData| 0) 
      when (not found)
      do
        (setq x (getalist |$globalExposureGroupAlist| g))
        (when (and x (getalist x name)) (setq found t)))
     found))))

\end{chunk}

\defun{displayOperationsFromLisplib}{displayOperationsFromLisplib}
\calls{displayOperationsFromLisplib}{getdatabase}
\calls{displayOperationsFromLisplib}{specialChar}
\calls{displayOperationsFromLisplib}{remdup}
\calls{displayOperationsFromLisplib}{msort}
\calls{displayOperationsFromLisplib}{eqsubstlist}
\calls{displayOperationsFromLisplib}{formatOperationAlistEntry}
\calls{displayOperationsFromLisplib}{say2PerLine}
\usesdollar{displayOperationsFromLisplib}{FormalMapVariableList}
\usesdollar{displayOperationsFromLisplib}{linelength}
\begin{chunk}{defun displayOperationsFromLisplib}
(defun |displayOperationsFromLisplib| (form)
 (let (name argl kind opList opl ops)
 (declare (special |$FormalMapVariableList| $linelength))
  (setq name (car form))
  (setq argl (cdr form))
  (setq kind (getdatabase name 'constructorkind))
  (setq opList (getdatabase name 'operationalist))
  (when opList
    (format t "~v,,,'-:@<~a~>~%" (- $linelength 2) " Operations ")
    (setq opl
     (remdup (msort (eqsubstlist argl |$FormalMapVariableList| opList))))
    (setq ops nil)
    (dolist (x opl)
     (setq ops (append ops (|formatOperationAlistEntry| x))))
    (|say2PerLine| ops))))

\end{chunk}

\defun{reportOpsFromUnitDirectly0}{reportOpsFromUnitDirectly0}
\calls{reportOpsFromUnitDirectly0}{reportOpsFromUnitDirectly1}
\calls{reportOpsFromUnitDirectly0}{reportOpsFromUnitDirectly}
\usesdollar{reportOpsFromUnitDirectly0}{useEditorForShowOutput}
\begin{chunk}{defun reportOpsFromUnitDirectly0}
(defun |reportOpsFromUnitDirectly0| (D)
 (declare (special |$useEditorForShowOutput|))
  (if |$useEditorForShowOutput|
   (|reportOpsFromUnitDirectly1| D)
   (|reportOpsFromUnitDirectly| D)))

\end{chunk}

\defun{reportOpsFromUnitDirectly}{reportOpsFromUnitDirectly}
\calls{reportOpsFromUnitDirectly}{member}
\calls{reportOpsFromUnitDirectly}{qcar}
\calls{reportOpsFromUnitDirectly}{evalDomain}
\calls{reportOpsFromUnitDirectly}{getdatabase}
\calls{reportOpsFromUnitDirectly}{sayBrightly}
\calls{reportOpsFromUnitDirectly}{concat}
\calls{reportOpsFromUnitDirectly}{formatOpType}
\calls{reportOpsFromUnitDirectly}{isExposedConstructor}
\calls{reportOpsFromUnitDirectly}{bright}
\calls{reportOpsFromUnitDirectly}{sayBrightly}
\calls{reportOpsFromUnitDirectly}{concat}
\calls{reportOpsFromUnitDirectly}{namestring}
\calls{reportOpsFromUnitDirectly}{selectOptionLC}
\calls{reportOpsFromUnitDirectly}{specialChar}
\calls{reportOpsFromUnitDirectly}{remdup}
\calls{reportOpsFromUnitDirectly}{msort}
\calls{reportOpsFromUnitDirectly}{formatAttribute}
\calls{reportOpsFromUnitDirectly}{getl}
\calls{reportOpsFromUnitDirectly}{systemErrorHere}
\calls{reportOpsFromUnitDirectly}{nreverse0}
\calls{reportOpsFromUnitDirectly}{getOplistForConstructorForm}
\calls{reportOpsFromUnitDirectly}{say2PerLine}
\calls{reportOpsFromUnitDirectly}{formatOperation}
\usesdollar{reportOpsFromUnitDirectly}{commentedOps}
\usesdollar{reportOpsFromUnitDirectly}{CategoryFrame}
\usesdollar{reportOpsFromUnitDirectly}{linelength}
\usesdollar{reportOpsFromUnitDirectly}{options}
\usesdollar{reportOpsFromUnitDirectly}{showOptions}
\begin{chunk}{defun reportOpsFromUnitDirectly}
(defun |reportOpsFromUnitDirectly| (unitForm)
 (let (|$commentedOps| isRecordOrUnion unit top kind abb sourceFile verb opt 
       attList constructorFunction tmp1 funlist a sigList tmp2)
 (declare (special |$commentedOps| |$CategoryFrame| $linelength |$options|
                      |$showOptions|))
  (setq isRecordOrUnion
   (and (consp unitForm)
        (progn (setq a (qcar unitForm)) t)
        (|member| a '(|Record| |Union|))))
  (setq unit (|evalDomain| unitForm))
  (setq top (car unitForm))
  (setq kind (getdatabase top 'constructorkind))
  (|sayBrightly|
   (|concat| " " (|formatOpType| unitForm)
             " is a " kind " constructor."))
  (unless isRecordOrUnion
     (setq abb (getdatabase top 'abbreviation))
     (setq sourceFile (getdatabase top 'sourcefile))
     (|sayBrightly|
      (cons " Abbreviation for"
       (append (|bright| top) (cons "is" (|bright| abb)))))
     (if (|isExposedConstructor| top)
      (setq verb "is")
      (setq verb "is not"))
     (|sayBrightly|
      (cons " This constructor"
       (append (|bright| verb) (list "exposed in this frame." ))))
     (|sayBrightly|
      (cons " Issue"
       (append (|bright| (concat ")edit " (|namestring| sourceFile)))
               (cons "to see algebra source code for"
                (append (|bright| abb) (list '|%l|)))))))
  (dolist (item |$options|)
   (setq opt (|selectOptionLC| (car item) |$showOptions| '|optionError|))
   (cond
    ((eq opt '|attributes|)
     (format t "~v,,,'-:@<~a~>~%" (- $linelength 2) " Attributes ")
     (if isRecordOrUnion
       (|sayBrightly| "   Records and Unions have no attributes.")
       (progn
        (|sayBrightly| "")
        (setq attList
         (remdup
          (msort
           (mapcar #'(lambda (unit2) (car unit2)) (reverse (elt unit 2))))))
        (|say2PerLine|
         (mapcar #'|formatAttribute| attList))
        nil)))
    ((eq opt '|operations|)
     (setq |$commentedOps| 0)
;      --new form is (<op> <signature> <slotNumber> <condition> <kind>)
     (format t "~v,,,'-:@<~a~>~%" (- $linelength 2) " Operations ")
     (|sayBrightly| "")
     (cond
      (isRecordOrUnion
       (setq constructorFunction (getl top '|makeFunctionList|))
       (unless constructorFunction
        (|systemErrorHere| "reportOpsFromUnitDirectly"))
       (setq tmp1
        (funcall constructorFunction '$ unitForm |$CategoryFrame|))
       (setq funlist (car tmp1))
       (setq sigList
        (remdup
         (msort
          (dolist (fun funlist (nreverse0 tmp2))
           (push `(((,(caar fun) ,(cadar fun)) t (,(caddar fun) 0 1)))
             tmp2))))))
       (t
        (setq sigList 
         (remdup (msort (|getOplistForConstructorForm| unitForm))))))
      (|say2PerLine|
       (mapcar #'(lambda (x) (|formatOperation| x unit)) sigList))
      (unless (= |$commentedOps| 0)
       (|sayBrightly|
        (list "Functions that are not yet implemented are preceded by"
              (|bright| "--"))))
      (|sayBrightly| ""))))
  nil))

\end{chunk}

\defun{getOplistForConstructorForm}{getOplistForConstructorForm}
The new form is an op-Alist which has entries 
\begin{verbatim}
  (<op> . signature-Alist)
\end{verbatim}
where signature-Alist has entries 
\begin{verbatim}
  (<signature> . item)
\end{verbatim}
where item has form (<slotNumber> <condition> <kind>)
\begin{verbatim}
  (<slotNumber> <condition> <kind>)
\end{verbatim}
where <kind> =  ELT | CONST | Subsumed | (XLAM..) ..
\begin{verbatim}
  <kind> =  ELT | CONST | Subsumed | (XLAM..) ..
\end{verbatim}
\begin{chunk}{defun getOplistForConstructorForm}
(defun |getOplistForConstructorForm| (form)
 (let (argl pairlis opAlist op signatureAlist result)
 (declare (special |$FormalMapVariableList|))
  (setq op (car form))
  (setq argl (cdr form))
  (setq pairlis
   (loop for fv in |$FormalMapVariableList|
         for arg in argl
    collect (cons fv arg)))
  (setq opAlist (|getOperationAlistFromLisplib| op))
  (loop for item in opAlist do
    (setq op (car item))
    (setq signatureAlist (cdr item))
    (setq result 
     (append result 
      (|getOplistWithUniqueSignatures| op pairlis signatureAlist))))
  result))

\end{chunk}

\defun{getOplistWithUniqueSignatures}{getOplistWithUniqueSignatures}
\begin{chunk}{defun getOplistWithUniqueSignatures}
(defun |getOplistWithUniqueSignatures| (op pairlis signatureAlist)
 (let (sig slotNumber pred kind alist)
  (loop for item in signatureAlist 
   when (not (eq (fourth item) '|Subsumed|))
   do
     (setq sig (first item))
     (setq slotNumber (second item))
     (setq pred (third item))
     (setq kind (fourth item))
     (setq alist
      (|insertAlist| 
       (sublis pairlis (list op sig))
       (sublis pairlis (list pred (list kind  nil slotNumber)))
       alist)))
  alist))

\end{chunk}

\defun{reportOpsFromUnitDirectly1}{reportOpsFromUnitDirectly1}
\calls{reportOpsFromUnitDirectly1}{pathname}
\calls{reportOpsFromUnitDirectly1}{erase}
\calls{reportOpsFromUnitDirectly1}{defiostream}
\calls{reportOpsFromUnitDirectly1}{sayShowWarning}
\calls{reportOpsFromUnitDirectly1}{reportOpsFromUnitDirectly}
\calls{reportOpsFromUnitDirectly1}{shut}
\calls{reportOpsFromUnitDirectly1}{editFile}
\usesdollar{reportOpsFromUnitDirectly1}{sayBrightlyStream}
\usesdollar{reportOpsFromUnitDirectly1}{erase}
\begin{chunk}{defun reportOpsFromUnitDirectly1}
(defun |reportOpsFromUnitDirectly1| (D)
 (let (|$sayBrightlyStream| showFile)
 (declare (special |$sayBrightlyStream| $erase))
  (setq showFile (|pathname| (list 'show 'listing 'a)))
  ($erase showFile)
  (setq |$sayBrightlyStream|
   (defiostream `((file ,showFile) (mode . output)) 255 0))
  (|sayShowWarning|)
  (|reportOpsFromUnitDirectly| D)
  (shut |$sayBrightlyStream|)
  (|editFile| showFile)))

\end{chunk}

\defun{sayShowWarning}{sayShowWarning}
\calls{sayShowWarning}{sayBrightly}
\begin{chunk}{defun sayShowWarning}
(defun |sayShowWarning| ()
 (|sayBrightly|
   "Warning: this is a temporary file and will be deleted the next")
 (|sayBrightly|
   "         time you use )show. Rename it and FILE if you wish to")
 (|sayBrightly| "         save the contents.")
 (|sayBrightly| ""))

\end{chunk}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{spool}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{spool.help}
====================================================================
A.23.  )spool
====================================================================
 
User Level Required:  interpreter
 
Command Syntax: 
 
  - )spool [fileName]
  - )spool
 
Command Description: 
 
This command is used to save (spool) all AXIOM input and output into a file,
called a spool file. You can only have one spool file active at a time. To
start spool, issue this command with a filename. For example,
 
)spool integrate.out
 
To stop spooling, issue )spool with no filename.
 
If the filename is qualified with a directory, then the output will be placed
in that directory. If no directory information is given, the spool file will
be placed in the current directory. The current directory is the directory
from which you started AXIOM or is the directory you specified using the )cd
command.
 
Also See: 
o )cd
 
\end{chunk} 
\footnote{\fnref{cd}}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{summary}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{summary.help}
 )credits      : list the people who have contributed to Axiom

 )help <command> gives more information
 )quit         : exit AXIOM 

 )abbreviation : query, set and remove abbreviations for constructors
 )browse       : start an Axiom http server on 127.0.0.1 port 8085
 )cd           : set working directory
 )clear        : remove declarations, definitions or values
 )close        : throw away an interpreter client and workspace
 )compile      : invoke constructor compiler
 )copyright    : show copyright and trademark information
 )describe     : show database information for a category, domain, or package 
 )display      : display Library operations and objects in your workspace
 )edit         : edit a file
 )fin          : drop into lisp, use (restart) to return to the session
 )frame        : manage interpreter workspaces
 )history      : manage aspects of interactive session
 )include      : insert a file into a .input file
 )library      : introduce new constructors 
 )license      : display the Axiom license file
 )lisp         : evaluate a LISP expression
 )ltrace       : trace functions
 )pquit        : ask if you really want to exit Axiom
 )quit         : exit Axiom
 )read         : execute AXIOM commands from a file
 )regress      : regression test an output spool file
 )savesystem   : save LISP image to a file
 )set          : view and set system variables
 )show         : show constructor information
 )spool        : log input and output to a file
 )synonym      : define an abbreviation for system commands
 )system       : issue shell commands
 )tangle       : extract chunks from a literate program to an input file
 )trace        : trace execution of functions
 )trademark    : declare that Axiom is a trademark of this software effort
 )undo         : restore workspace to earlier state
 )what         : search for various things by name

\end{chunk}

\defun{summary}{summary}
\calls{summary}{obey}
\calls{summary}{concat}
\calls{summary}{getenviron}
\begin{chunk}{defun summary}
(defun |summary| (l)
 (declare (ignore l))
 (obey (concat "cat " (getenviron "AXIOM") "/doc/spadhelp/summary.help")))

\end{chunk}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{synonym}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{synonym.help}
====================================================================
A.24.  )synonym
====================================================================
 
User Level Required:  interpreter
 
Command Syntax: 
 
  - )synonym
  - )synonym synonym fullCommand
  - )what synonyms
 
Command Description: 
 
This command is used to create short synonyms for system command expressions.
For example, the following synonyms might simplify commands you often use.
 
)synonym save         history )save
)synonym restore      history )restore
)synonym mail         system mail
)synonym ls           system ls
)synonym fortran      set output fortran
 
Once defined, synonyms can be used in place of the longer command
expressions. Thus
 
)fortran on
 
is the same as the longer
 
)set fortran output on
 
To list all defined synonyms, issue either of
 
)synonyms
)what synonyms
 
To list, say, all synonyms that contain the substring ``ap'', issue
 
)what synonyms ap
 
Also See: 
o )set
o )what
 
\end{chunk} 
\footnote{
\fnref{set}
\fnref{what}}

\defun{synonym}{The )synonym command}
\calls{synonym}{synonymSpad2Cmd}
\begin{chunk}{defun synonym}
(defun |synonym| (&rest ignore)
 (declare (ignore ignore))
 (|synonymSpad2Cmd|))

\end{chunk}

\defun{synonymSpad2Cmd}{The )synonym command implementation}
\calls{synonymSpad2Cmd}{getSystemCommandLine}
\calls{synonymSpad2Cmd}{printSynonyms}
\calls{synonymSpad2Cmd}{processSynonymLine}
\calls{synonymSpad2Cmd}{putalist}
\calls{synonymSpad2Cmd}{terminateSystemCommand}
\usesdollar{synonymSpad2Cmd}{CommandSynonymAlist}
\begin{chunk}{defun synonymSpad2Cmd}
(defun |synonymSpad2Cmd| ()
 (let (line pair)
 (declare (special |$CommandSynonymAlist|))
  (setq line (|getSystemCommandLine|))
  (if (string= line "")
   (|printSynonyms| nil)
   (progn
    (setq pair (|processSynonymLine| line))
    (if |$CommandSynonymAlist|
     (putalist |$CommandSynonymAlist| (car pair) (cdr pair))
     (setq |$CommandSynonymAlist| (cons pair nil)))))
  (|terminateSystemCommand|)))

\end{chunk}

\defun{synonymsForUserLevel}{Return a sublist of applicable synonyms}
The argument is a list of synonyms, and this returns a sublist of applicable
synonyms at the current user level.
\calls{synonymsForUserLevel}{string2id-n}
\calls{synonymsForUserLevel}{selectOptionLC}
\calls{synonymsForUserLevel}{commandsForUserLevel}
\usesdollar{synonymsForUserLevel}{systemCommands}
\usesdollar{synonymsForUserLevel}{UserLevel}
\begin{chunk}{defun synonymsForUserLevel}
(defun |synonymsForUserLevel| (arg)
 (let (cmd nl)
 (declare (special |$systemCommands| |$UserLevel|))
  (if (eq |$UserLevel| '|development|)
   arg
   (dolist (syn (reverse arg))
    (setq cmd (string2id-n (cdr syn) 1))
    (when (|selectOptionLC| cmd (|commandsForUserLevel| |$systemCommands|) nil)
     (push syn nl))))
   nl))

\end{chunk}

\defun{getSystemCommandLine}{Get the system command from the input line}
\calls{getSystemCommandLine}{strpos}
\calls{getSystemCommandLine}{substring}
\usesdollar{getSystemCommandLine}{currentLine}
\begin{chunk}{defun getSystemCommandLine}
(defun |getSystemCommandLine| ()
 (let (p line)
 (declare (special |$currentLine|))
  (setq p (strpos ")" |$currentLine| 0 nil))
  (if p
   (setq line (substring |$currentLine| p nil))
   (setq line |$currentLine|))
 (string-left-trim '(#\space) line)))

\end{chunk}

\defun{processSynonymLine,removeKeyFromLine}{Remove system keyword}
\calls{processSynonymLine,removeKeyFromLine}{maxindex}
\begin{chunk}{defun processSynonymLine,removeKeyFromLine}
(defun |processSynonymLine,removeKeyFromLine| (line)
 (prog (mx)
  (return
   (seq
    (setq line (string-left-trim " " line))
    (setq mx (maxindex line))
    (exit 
     (do ((i 0 (1+ i)))
         ((> i mx) nil)
       (seq
        (exit
         (if (char= (elt line i) #\space)
          (exit
           (return
            (do ((j (1+ i) (1+ j)))
                ((> j mx) nil)
              (seq
               (exit
                (if (char\= (elt line j) #\space)
                 (exit
                  (return
                   (substring line j nil))))))))))))))))))

\end{chunk}

\defun{processSynonymLine}{processSynonymLine}
\calls{processSynonymLine}{processSynonymLine,removeKeyFromLine}
\begin{chunk}{defun processSynonymLine}
(defun |processSynonymLine| (line)
 (cons
  (string2id-n line 1)
  (|processSynonymLine,removeKeyFromLine| line)))

\end{chunk}

This command is in the list of \verb|$noParseCommands|
\ref{noParseCommands} which means that its arguments are passed
verbatim. This will eventually result in a call to the function
\verb|handleNoParseCommands| \ref{handleNoParseCommands}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{system}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{system.help}
====================================================================
A.25.  )system
====================================================================
 
User Level Required:  interpreter
 
Command Syntax: 
 
  - )system cmdExpression
 
Command Description: 
 
This command may be used to issue commands to the operating system while
remaining in AXIOM. The cmdExpression is passed to the operating system for
execution.
 
To get an operating system shell, issue, for example, )system sh. When you
enter the key combination, Ctrl-D (pressing and holding the Ctrl key and then
pressing the D key) the shell will terminate and you will return to AXIOM. We
do not recommend this way of creating a shell because Lisp may field some
interrupts instead of the shell. If possible, use a shell running in another
window.
 
If you execute programs that misbehave you may not be able to return to
AXIOM. If this happens, you may have no other choice than to restart AXIOM
and restore the environment via )history )restore, if possible.
 
Also See: 
o )boot
o )fin
o )lisp
o )pquit
o )quit
 
\end{chunk} 
\footnote{
\fnref{boot}
\fnref{fin}
\fnref{lisp}
\fnref{pquit}
\fnref{quit}}

This command is in the list of \verb|$noParseCommands|
\ref{noParseCommands} which means that its arguments are passed
verbatim. This will eventually result in a call to the function
\verb|handleNoParseCommands| \ref{handleNoParseCommands}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{tangle}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{tangle.help}
====================================================================
A.19.  )tangle
====================================================================
 
User Level Required:  interpreter
 
Command Syntax: 
 
  -  )tangle [fileName]
 
Command Description: 
 
This command is used to tangle pamphlet files.
 
)tangle matrix.input.pamphlet
 
will tangle the contents of the file matrix.input.pamphlet into 
matrix.input. The ``.input.pamphlet'' is optional.
 
\end{chunk} 

\begin{chunk}{defun tangle}
(defun |tangle| (arg)
 (let (|$InteractiveMode| namestring dot1 dot2 outfile 
       (chunkname "*") (extension "input"))      
 (declare (special |$InteractiveMode| |$options|))
  (setq |$InteractiveMode| t)
  (setq namestring (symbol-name (car arg)))
  (setq dot1 (position #\. namestring))
  (if dot1
   (setq outfile 
    (concatenate 'string (subseq namestring 0 dot1) "." extension))
   (setq outfile 
    (concatenate 'string (subseq namestring 0) "." extension)))
  (setq dot2 (position #\. namestring :from-end t))
  (cond
   ((and (numberp dot1) (numberp dot2) (< dot1 dot2)))
   ((and (numberp dot1) (numberp dot2) (= dot1 dot2))
    (setq namestring (concatenate 'string namestring ".pamphlet")))
   (t
    (setq namestring (concatenate 'string namestring ".input.pamphlet"))))
  (if (probe-file namestring)
   (progn
    (tangle namestring chunkname outfile)
    (format t (concatenate 'string outfile " created from " namestring "~%")))
   (format t (concatenate 'string namestring " file not found~%")))))

\end{chunk}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{trademark}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{trademark.help}
====================================================================
A.15.  )trademark
====================================================================
 
Command Syntax: 
 
  -  )trademark
 
Command Description: 
 
This command displays the Axiom trademark information.
 
Also See: 
o )license
 
\end{chunk} 

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{undo}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{undo.help}
====================================================================
A.27.  )undo
====================================================================
 
User Level Required:  interpreter
 
Command Syntax: 
 
  - )undo
  - )undo integer
  - )undo integer [option]
  - )undo )redo
 
where option is one of
 
  - )after
  - )before
 
Command Description: 
 
This command is used to restore the state of the user environment to an
earlier point in the interactive session. The argument of an )undo is an
integer which must designate some step number in the interactive session.
 
)undo n
)undo n )after
 
These commands return the state of the interactive environment to that
immediately after step n. If n is a positive number, then n refers to step
nummber n. If n is a negative number, it refers to the nth previous command
(that is, undoes the effects of the last -n commands).
 
A )clear all resets the )undo facility. Otherwise, an )undo undoes the effect
of )clear with options properties, value, and mode, and that of a previous
undo. If any such system commands are given between steps n and n + 1 (n >
0), their effect is undone for )undo m for any 0 < m <= n .
 
The command )undo is equivalent to )undo -1 (it undoes the effect of the
previous user expression). The command )undo 0 undoes any of the above system
commands issued since the last user expression.
 
)undo n )before
 
This command returns the state of the interactive environment to that
immediately before step n. Any )undo or )clear system commands given before
step n will not be undone.
 
)undo )redo
 
This command reads the file redo.input. created by the last )undo command.
This file consists of all user input lines, excluding those backtracked over
due to a previous )undo.
 
The command )history )write will eliminate the ``undone'' command lines of
your program.

Also See: 
o )history
 
\end{chunk} 
\footnote{\fnref{history}}

\section{\enspace{}Evaluation}
Some Antique Comments About the Interpreter

EVAL BOOT contains the top level interface to the Scratchhpad-II
interpreter.  The Entry point into the interpreter from the parser is
processInteractive.

The type analysis algorithm is contained in the file BOTMUP BOOT,
and MODSEL boot,
the map handling routines are in MAP BOOT and NEWMAP BOOT, and
the interactive coerce routines are in COERCE BOOT and COERCEFN BOOT.

{\bf Conventions:}
All spad values in the interpreter are passed around in triples.
These are lists of three items: 
\begin{verbatim}
   [value,mode,environment]
\end{verbatim}
The value
may be wrapped (this is a pair whose CAR is the atom WRAPPED and
whose CDR is the value), which indicates that it is a real value,
or unwrapped in which case it needs to be EVALed to produce the
proper value.  The mode is the type of value, and should always be
completely specified (not contain \verb|$EmptyMode|).  The environment
is always empty, and is included for historical reasons.

{\bf Modemaps:}
Modemaps are descriptions of compiled Spad function which the
interpreter uses to perform type analysis. They consist of patterns
of types for the arguments, and conditions the types must satisfy
for the function to apply.  For each function name there is a list
of modemaps in file modemap DATABASE for each distinct function with
that name. The following is the list of the modemaps for ``*''
(multiplication. The first modemap (the one with the labels) is for
module mltiplication which is multiplication of an element of a
module by a member of its scalar domain.

This is the signature pattern for the modemap, it is of the form:
\begin{verbatim}
    (DomainOfComputation TargetType <ArgumentType ...>)
          |
          |                This is the predicate that needs to be
          |                 satisfied for the modemap to apply
          |                            |
          V                            |
     /-----------/                     |
 ( ( (*1 *1 *2 *1)                     V
       /-----------------------------------------------------------/
     ( (AND (ofCategory *1 (Module *2)) (ofCategory *2 (SimpleRing))) )
      . CATDEF) <-- This is the file where the function was defined
   ( (*1 *1 *2 *1)
     ( (AND (isDomain *2 (Integer)) (ofCategory *1 (AbelianGroup))) )
      . CATDEF)
   ( (*1 *1 *2 *1)
     ( (AND
         (isDomain *2 (NonNegativeInteger))
         (ofCategory *1 (AbelianMonoid))) )
      . CATDEF)
   ((*1 *1 *1 *1) ((ofCategory *1 (SemiGroup)) ) . CATDEF)
      )
\end{verbatim}
{\bf Environments:}
Environments associate properties with atoms.

Some common properties are:
\begin{itemize}
\item {\bf modeSet:}
During interpretation we build a modeSet property for each node in
the expression.  This is (in theory) a list of all the types
possible for the node.  In the current implementation these
modeSets always contain a single type.
\item {\bf value:}
Value properties are always triples.  This is where the values of
variables are stored.  We also build value properties for internal
nodes during the bottom up phase.
\item {\bf mode:}
This is the declared type of an identifier.
\end{itemize}

Frequently used global variables:
\begin{itemize}
\item {\bf \verb|$genValue|}: if true then evaluate generated code,
otherwise leave code unevaluated.  If \verb|$genValue| is false then
we are compiling.
\item {\bf \verb|$op|}: name of the top level operator 
(unused except in map printing)
\item {\bf \verb|$mapList|}: list of maps being type analyzed, used in
recursive map type anlysis.
\item {\bf \verb|$compilingLoop|}: true when compiling a loop body,
used to control nesting level of interp-only loop CATCH points
\item {\bf \verb|$interpOnly|}: true when in interpret only mode, used
to call alternate forms of COLLECT and REPEAT.
\item {\bf \verb|$inCOLLECT|}: true when compiling a COLLECT, used
only for hacked stream compiler.
\item {\bf \verb|$StreamFrame|}: used in printing streams, it is the
environment where local stream variables are stored
\item {\bf \verb|$declaredMode|}: Weak type propagation for symbols,
set in upCOERCE and upLET.  This variable is used to determine the
alternate polynomial types of Symbols.
\item {\bf \verb|$localVars|}: list of local variables in a map body
\item {\bf \verb|$MapArgumentTypeList|}: hack for stream compilation
\end{itemize}

\defun{evalDomain}{evalDomain}
\calls{evalDomain}{sayMSG}
\calls{evalDomain}{concat}
\calls{evalDomain}{prefix2String}
\calls{evalDomain}{startTimingProcess}
\calls{evalDomain}{eval}
\calls{evalDomain}{mkEvalable}
\calls{evalDomain}{stopTimingProcess}
\refsdollar{evalDomain}{evalDomain}
\begin{chunk}{defun evalDomain}
(defun |evalDomain| (form)
 (let (result)
 (declare (special |$evalDomain|))
  (when |$evalDomain|
    (|sayMSG| (|concat| "   instantiating " (|prefix2String| form))))
  (|startTimingProcess| '|instantiation|)
  (setq result (|eval| (|mkEvalable| form)))
  (|stopTimingProcess| '|instantiation|)
  result))

\end{chunk}

\defun{mkEvalable}{mkEvalable}
\calls{mkEvalable}{qcar}
\calls{mkEvalable}{qcdr}
\calls{mkEvalable}{mkEvalable}
\calls{mkEvalable}{devaluate}
\calls{mkEvalable}{mkEvalableRecord}
\calls{mkEvalable}{mkEvalableUnion}
\calls{mkEvalable}{mkEvalableMapping}
\calls{mkEvalable}{loadLibIfNecessary}
\calls{mkEvalable}{getdatabase}
\calls{mkEvalable}{mkq}
\calls{mkEvalable}{constructor?}
\calls{mkEvalable}{fbpip}
\calls{mkEvalable}{bpiname}
\refsdollar{mkEvalable}{Integer}
\refsdollar{mkEvalable}{EmptyMode}
\begin{chunk}{defun mkEvalable}
(defun |mkEvalable| (form)
 (let (op argl kind cosig)
 (declare (special |$Integer| |$EmptyMode|))
  (cond
   ((consp form)
     (setq op (qcar form))
     (setq argl (qcdr form))
     (cond
      ((eq op 'quote) form)
      ((eq op 'wrapped) (|mkEvalable| (|devaluate| argl)))
      ((eq op '|Record|) (|mkEvalableRecord| form))
      ((eq op '|Union|) (|mkEvalableUnion| form))
      ((eq op '|Mapping|) (|mkEvalableMapping| form))
      ((eq op '|Enumeration|) form)
      (t
       (|loadLibIfNecessary| op t)
       (setq kind (getdatabase op 'constructorkind))
       (cond
         ((setq cosig (getdatabase op 'cosig))
          (cons op
           (loop for x in argl for typeFlag in (rest cosig)
            collect 
             (cond
              (typeFlag
               (cond
                ((eq kind '|category|) (mkq x))
                ((simple-vector-p x) (mkq x))
                (t
                  (|loadLibIfNecessary| x t)
                  (|mkEvalable| x))))
              ((and (consp x) (eq (qcar x) 'quote)) x)
              ((and (consp x) (eq (qcar x) '|#|) (consp (qcdr x)) 
                    (eq (qcdr (qcdr x)) nil))
                (list 'size (mkq (qcar (qcdr x)))))
              (t (mkq x))))))
         (t
          (cons op
           (loop for x in argl
            collect (|mkEvalable| x))))))))
     ((equal form |$EmptyMode|) |$Integer|)
     ((and (identp form) (|constructor?| form)) (list form))
     ((fbpip form) (bpiname form))
     (t form))))

\end{chunk}

\defun{mkEvalableUnion}{mkEvalableUnion}
\calls{mkEvalableUnion}{mkEvalable}
\begin{chunk}{defun mkEvalableUnion}
(defun |mkEvalableUnion| (form)
  (cond
   ((|isTaggedUnion| form)
    (cons
     (car form)
     (loop for item in (rest form)
      collect (list '|:| (second item) (|mkEvalable| (third item))))))
   (t
    (cons (car form)
     (loop for d in (rest form)
      collect (|mkEvalable| d))))))

\end{chunk}

\defun{isTaggedUnion}{isTaggedUnion}
\begin{chunk}{defun isTaggedUnion}
(defun |isTaggedUnion| (u)
 (and (eq (car u) '|Union|) (eq (caadr u) '|:|)))

\end{chunk}

\defun{mkEvalableRecord}{mkEvalableRecord}
\calls{mkEvalableRecord}{mkEvalable}
\begin{chunk}{defun mkEvalableRecord}
(defun |mkEvalableRecord| (form)
  (cons
   (car form)
   (loop for item in (rest form)
    collect (list (quote |:|) (second item) (|mkEvalable| (third item))))))

\end{chunk}

\defun{mkEvalableMapping}{mkEvalableMapping}
\calls{mkEvalableMapping}{mkEvalable}
\begin{chunk}{defun mkEvalableMapping}
(defun |mkEvalableMapping| (form)
 (cons
  (car form)
  (loop for d in (rest form)
   collect (|mkEvalable| d))))

\end{chunk}

\defun{evaluateType}{evaluateType}
Takes a parsed, unabbreviated type and evaluates it, replacing
type valued variables with their values, and calling bottomUp
on non-type valued arguemnts to the constructor
and finally checking to see whether the type satisfies the
conditions of its modemap.

\calls{evaluateType}{isDomainValuedVariable}
\calls{evaluateType}{qcar}
\calls{evaluateType}{qcdr}
\calls{evaluateType}{mkAtree}
\calls{evaluateType}{bottomUp}
\calls{evaluateType}{objVal}
\calls{evaluateType}{getValue}
\calls{evaluateType}{evaluateSignature}
\calls{evaluateType}{member}
\calls{evaluateType}{evaluateType}
\calls{evaluateType}{constructor?}
\calls{evaluateType}{throwEvalTypeMsg}
\refsdollar{evaluateType}{EmptyMode}
\defsdollar{evaluateType}{expandSegments}
\begin{chunk}{defun evaluateType}
(defun |evaluateType| (form)
 (let (|$expandSegments| domain formp op argl)
  (declare (special |$expandSegments| |$EmptyMode|))
  (cond
    ((setq domain (|isDomainValuedVariable| form)) domain)
    ((equal form |$EmptyMode|) form)
    ((eq form '?) |$EmptyMode|)
    ((stringp form) form)
    ((eq form '$) form)
    (t
     (setq |$expandSegments| nil)
     (cond
       ((and (consp form) (eq (qcar form) '|typeOf|) (consp (qcdr form)) 
             (eq (qcdr (qcdr form)) nil))
         (setq formp (|mkAtree| form))
         (|bottomUp| formp)
         (|objVal| (|getValue| formp)))
       ((consp form)
         (setq op (qcar form))
         (setq argl (qcdr form))
         (cond
          ((eq op 'category)
            (cond
             ((consp argl)
               (cons op
                (cons (qcar argl)
                 (loop for s in (qcdr argl)
                  collect (|evaluateSignature| s)))))
             (t form)))
          ((|member| op '(|Join| |Mapping|))
            (cons op
             (loop for arg in argl
              collect (|evaluateType| arg))))
          ((eq op '|Union|)
            (cond
             ((and argl (consp (car argl)) (consp (qcdr (car argl)))
                   (consp (qcdr (qcdr (car argl))))
                   (eq (qcdr (qcdr (qcdr (car argl)))) nil)
                   (|member| (qcar (car argl)) '(|:| |Declare|)))
               (cons op
                (loop for item in argl
                 collect
                  (list '|:| (second item) (|evaluateType| (third item))))))
             (t
              (cons op
               (loop for arg in argl
                collect (|evaluateType| arg))))))
          ((eq op '|Record|)
            (cons op
             (loop for item in argl
              collect
               (list '|:| (second item) (|evaluateType| (third item))))))
          ((eq op '|Enumeration|) form)
          (t (|evaluateType1| form))))
       ((|constructor?| form)
         (if (atom form)
           (|evaluateType| (list form))
           (|throwEvalTypeMsg|
            (format nil
             "Although %1 is the name of a constructor, a full type must be ~
              specified in the context you have used it.  Issue )show %2 ~
              for more information.")
             (list form form))))
       (t (|throwEvalTypeMsg| "%1p is not a valid type." (list form))))))))

\end{chunk}

\defun{evaluateType1}{Eval args passed to a constructor}
Evaluates the arguments passed to a constructor.

\calls{evaluateType1}{constructor?}
\calls{evaluateType1}{getConstructorSignature}
\calls{evaluateType1}{throwEvalTypeMsg}
\calls{evaluateType1}{replaceSharps}
\calls{evaluateType1}{categoryForm?}
\calls{evaluateType1}{evaluateType}
\calls{evaluateType1}{evalCategory}
\calls{evaluateType1}{getdatabase}
\calls{evaluateType1}{mkAtree}
\calls{evaluateType1}{putTarget}
\calls{evaluateType1}{bottumUp}
\calls{evaluateType1}{qcar}
\calls{evaluateType1}{qcdr}
\calls{evaluateType1}{getAndEvalConstructorArgument}
\calls{evaluateType1}{coerceOrRetract}
\calls{evaluateType1}{objValUnwrap}
\calls{evaluateType1}{throwKeyedMsgCannotCoerceWithValue}
\calls{evaluateType1}{makeOrdinal}
\refsdollar{evaluateType1}{quadSymbol}
\refsdollar{evaluateType1}{EmptyMode}
\begin{chunk}{defun evaluateType1}
(defun |evaluateType1| (form)
 (let (op argl sig ml xp tree tmp1 m1 z1 zt zv v typeList (argnum 0))
 (declare (special |$quadSymbol| |$EmptyMode|))
  (setq op (car form))
  (setq argl (cdr form))
  (cond
   ((|constructor?| op)
     (cond
      ((null (setq sig (|getConstructorSignature| form)))
       (|throwEvalTypeMsg| 
        "You cannot now use %1p in the context you have it." (list form)))
      (t
       (setq ml (cdr sig))
       (setq ml (|replaceSharps| ml form))
       (cond
        ((not (eql (|#| argl) (|#| ml)))
          (|throwEvalTypeMsg|
           (format nil
            "Although %1 is the name of a constructor, a full type must be ~
             specified in the context you have used it.  Issue )show %2 ~
             for more information.")
          (list form form)))
        (t
         (loop for x in argl for m in ml 
          do
           (setq typeList
            (cons
             (cond
              ((|categoryForm?| m)
                (setq m (|evaluateType| (subst x '$ m)))
                (if (|evalCategory| (setq xp (|evaluateType| x)) m)
                   xp
                   (|throwEvalTypeMsg| "%1p is not a valid type."
                     (list form))))
              (t
               (setq m (|evaluateType| m))
               (cond
                ((and (eq (getdatabase (|opOf| m) 'constructorkind) '|domain|)
                      (setq tree (|mkAtree| x))
                      (|putTarget| tree m)
                      (progn
                       (setq tmp1 (|bottomUp| tree))
                       (and (consp tmp1)
                            (eq (qcdr tmp1) nil))))
                  (setq m1 (qcar tmp1))
                  (setq z1 (|getAndEvalConstructorArgument| tree))
                  (setq zt (car z1))
                  (setq zv (cdr z1))
                  (if (setq v (|coerceOrRetract| z1 m))
                    (|objValUnwrap| v)
                    (|throwKeyedMsgCannotCoerceWithValue| zv zt m)))
                (t
                 (when (equal x |$EmptyMode|) (setq x |$quadSymbol|))
                 (|throwEvalTypeMsg|
                  "Cannot convert the %1 argument of %3p to the type %2p ."
                  (list (|makeOrdinal| (incf argnum)) m form))))))
             typeList)))
       (cons op (nreverse typeList)))))))
    (t (|throwEvalTypeMsg|
         "Category, domain or package constructor %1 is not available."
          (list op))))))

\end{chunk}

\defdollar{noEvalTypeMsg}
\begin{chunk}{initvars}
(defvar |$noEvalTypeMsg| nil)

\end{chunk}

\defun{throwEvalTypeMsg}{throwEvalTypeMsg}
\calls{throwEvalTypeMsg}{spadThrow}
\calls{throwEvalTypeMsg}{throwKeyedMsg}
\refsdollar{throwEvalTypeMsg}{noEvalTypeMsg}
\begin{chunk}{defun throwEvalTypeMsg}
(defun |throwEvalTypeMsg| (msg args)
 (declare (special |$noEvalTypeMsg|))
 (if |$noEvalTypeMsg|
  (|spadThrow|)
  (|throwKeyedMsg| msg args)))

\end{chunk}

\defun{makeOrdinal}{makeOrdinal}
\begin{chunk}{defun makeOrdinal}
(defun |makeOrdinal| (i)
 (elt '(|first| |second| |third| |fourth| |fifth| |sixth| |seventh| 
        |eighth| |ninth| |tenth|)
  (1- i)))

\end{chunk}

\defun{evaluateSignature}{evaluateSignature}
Calls evaluateType on a signature.

\calls{evaluateSignature}{evaluateType}
\begin{chunk}{defun evaluateSignature}
(defun |evaluateSignature| (sig)
  (cond
   ((and (consp sig) (eq (qcar sig) 'signature) (consp (qcdr sig))
         (consp (qcdr (qcdr sig))) (eq (qcdr (qcdr (qcdr sig))) nil))
    (cons 'signature (cons (qcar (qcdr sig))
      (list
       (loop for z in (qcar (qcdr (qcdr sig)))
        collect (if (eq z '$) z (|evaluateType| z)))))))
   (t sig)))

\end{chunk}

\defun{recordFrame}{recordFrame}
\calls{recordFrame}{diffAlist}
\calls{recordFrame}{seq}
\calls{recordFrame}{exit}
\usesdollar{recordFrame}{frameRecord}
\usesdollar{recordFrame}{InteractiveFrame}
\usesdollar{recordFrame}{previousBindings}
\begin{chunk}{defun recordFrame}
(defun recordFrame (systemNormal)
 (prog (currentAlist delta)
 (declare (special |$frameRecord| |$InteractiveFrame| |$previousBindings|))
  (return
   (seq
     (setq currentAlist (ifcar |$frameRecord|))
     (setq delta (|diffAlist| (caar |$InteractiveFrame|) |$previousBindings|))
     (cond
        ((eq systemNormal 'system)
          (cond 
           ((null delta)
             (return nil))
           (t
             (setq delta (cons '|systemCommand| delta))))))
     (setq |$frameRecord| (cons delta |$frameRecord|))
     ; copy all but the individual properties
     ; note that this loop makes no sense. In boot it read:
     ; [cons(first x, [cons(first y,rest y) for y in rest x]) for x 
     ;  in caar $InteractiveFrame
     ; ... but cons(first y, rest y) == y
     (setq |$previousBindings|
        (prog (tmp0)
         (setq tmp0 nil)
         (return
          (do ((tmp1 (caar |$InteractiveFrame|) (cdr tmp1)) (x nil))
              ((or (atom tmp1) 
                   (progn (setq x (car tmp1)) nil))
                (nreverse0 tmp0))
           (seq
            (exit
             (setq tmp0
              (cons 
               (cons 
                (car x)
                (prog (tmp2)
                 (setq tmp2 nil)
                 (return
                  (do ((tmp3 (cdr x) (cdr tmp3)) (y nil))
                      ((or (atom tmp3) 
                           (progn (setq y (car tmp3)) nil))
                        (nreverse0 tmp2))
                   (seq
                    (exit
                     (setq tmp2 (cons (cons (car y) (cdr y)) tmp2))))))))
                tmp0))))))))
     (first |$frameRecord|)))))

\end{chunk}

\defun{diffAlist}{diffAlist}
\begin{verbatim}
diffAlist(new,old) ==
--record only those properties which are different
  for (pair := [name,:proplist]) in new repeat
    -- name has an entry both in new and old world
    -- (1) if the old world had no proplist for that variable, then
    --     record NIL as the value of each new property
    -- (2) if the old world does have a proplist for that variable, then
    --     a) for each property with a value: give the old value
    --     b) for each property missing:      give NIL as the old value
    oldPair := ASSQ(name,old) =>
      null (oldProplist := CDR oldPair) =>
      --record old values of new properties as NIL
        acc := [ [name,:[ [prop] for [prop,:.] in proplist] ],:acc]
      deltas := nil
      for (propval := [prop,:val]) in proplist repeat
        null (oldPropval := ASSOC(prop,oldProplist)) => --missing property
          deltas := [ [prop],:deltas]
        EQ(CDR oldPropval,val) => 'skip
        deltas := [oldPropval,:deltas]
      deltas => acc := [ [name,:NREVERSE deltas],:acc]
    acc := [ [name,:[ [prop] for [prop,:.] in proplist] ],:acc]
--record properties absent on new list (say, from a )cl all)
  for (oldPair := [name,:r]) in old repeat
    r and null LASSQ(name,new) =>
      acc := [oldPair,:acc]
    -- name has an entry both in new and old world
    -- (1) if the new world has no proplist for that variable
    --     (a) if the old world does, record the old proplist
    --     (b) if the old world does not, record nothing
    -- (2) if the new world has a proplist for that variable, it has
    --     been handled by the first loop.
  res := NREVERSE acc
  if BOUNDP '$reportundo and $reportundo then reportUndo res
  res
\end{verbatim}
\calls{diffAlist}{assq}
\calls{diffAlist}{tmp1}
\calls{diffAlist}{seq}
\calls{diffAlist}{exit}
\calls{diffAlist}{assoc}
\calls{diffAlist}{lassq}
\calls{diffAlist}{reportUndo}
\begin{chunk}{defun diffAlist}
(defun |diffAlist| (new old)
 (prog (proplist oldPair oldProplist val oldPropval deltas prop name r acc res)
  (return
   (seq
    (progn
     (do ((tmp0 new (cdr tmp0)) (pair nil))
         ((or (atom tmp0) 
              (progn (setq pair (car tmp0)) nil)
              (progn 
               (progn 
                (setq name (car pair))
                (setq proplist (cdr pair))
                pair) 
               nil))
             nil)
      (seq
       (exit
        (cond
         ((setq oldPair (assq name old))
          (cond
           ((null (setq oldProplist (cdr oldPair)))
             (setq acc
              (cons
               (cons
                 name 
                 (prog (tmp1)
                  (setq tmp1 nil)
                  (return
                   (do ((tmp2 proplist (cdr tmp2)) (tmp3 nil))
                       ((or (atom tmp2) 
                            (progn (setq tmp3 (car tmp2)) nil)
                            (progn 
                             (progn (setq prop (car tmp3)) tmp3)
                             nil))
                         (nreverse0 tmp1))
                    (seq
                     (exit
                      (setq tmp1 (cons (cons prop nil) tmp1))))))))
               acc)))
           (t 
             (setq deltas nil)
             (do ((tmp4 proplist (cdr tmp4)) (|propval| nil))
                 ((or (atom tmp4) 
                      (progn (setq |propval| (car tmp4)) nil)
                      (progn
                       (progn
                        (setq prop (car |propval|))
                        (setq val (cdr |propval|))
                        |propval|)
                       nil))
                   nil)
              (seq
               (exit
                (cond
                 ((null (setq oldPropval (|assoc| prop oldProplist)))
                   (setq deltas (cons (cons prop nil) deltas)))
                 ((eq (cdr oldPropval) val) '|skip|)
                 (t (setq deltas (cons oldPropval deltas)))))))
             (when deltas
               (setq acc 
                (cons (cons name (nreverse deltas)) acc))))))
         (t
           (setq acc
            (cons
             (cons
              name
              (prog (tmp5)
               (setq tmp5 nil)
               (return
                (do ((tmp6 proplist (cdr tmp6)) (tmp7 nil))
                    ((or (atom tmp6) 
                         (progn (setq tmp7 (CAR tmp6)) nil)
                         (progn
                          (progn (setq prop (CAR tmp7)) tmp7)
                          nil))
                       (nreverse0 tmp5))
                 (seq
                  (exit
                   (setq tmp5 (cons (cons prop nil) tmp5))))))))
             acc)))))))
     (seq
      (do ((tmp8 old (cdr tmp8)) (oldPair nil))
          ((or (atom tmp8) 
               (progn (setq oldPair (car tmp8)) nil)
               (progn
                (progn
                 (setq name (car oldPair))
                 (setq r (cdr oldPair))
                 oldPair)
                nil))
              nil)
       (seq
        (exit
         (cond
          ((and r (null (lassq name new)))
            (exit 
             (setq acc (cons oldPair acc))))))))
      (setq res (nreverse acc))
      (cond 
       ((and (boundp '|$reportundo|) |$reportundo|)
         (|reportUndo| res)))
      (exit res))))))) 

\end{chunk}

\defun{clearFrame}{clearFrame}
\calls{clearFrame}{clearCmdAll}
\usesdollar{clearFrame}{frameRecord}
\usesdollar{clearFrame}{previousBindings}
\begin{chunk}{defun clearFrame}
(defun |clearFrame| ()
 (declare (special |$frameRecord| |$previousBindings|))
  (|clearCmdAll|)
  (setq |$frameRecord| nil) 
  (setq |$previousBindings| nil))

\end{chunk}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{what}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chunk}{what.help}
====================================================================
A.28.  )what
====================================================================
 
User Level Required:  interpreter
 
Command Syntax: 
 
  - )what categories pattern1 [pattern2 ...]
  - )what commands   pattern1 [pattern2 ...]
  - )what domains    pattern1 [pattern2 ...]
  - )what operations pattern1 [pattern2 ...]
  - )what packages   pattern1 [pattern2 ...]
  - )what synonym    pattern1 [pattern2 ...]
  - )what things     pattern1 [pattern2 ...]
  - )apropos         pattern1 [pattern2 ...]
 
Command Description: 
 
This command is used to display lists of things in the system. The patterns
are all strings and, if present, restrict the contents of the lists. Only
those items that contain one or more of the strings as substrings are
displayed. For example,
 
)what synonym
 
displays all command synonyms,
 
)what synonym ver
 
displays all command synonyms containing the substring ``ver'',
 
)what synonym ver pr
 
displays all command synonyms containing the substring ``ver'' or the
substring ``pr''. Output similar to the following will be displayed
 
---------------- System Command Synonyms -----------------
 

user-defined synonyms satisfying patterns:
      ver pr
 

  )apr ........................... )what things
  )apropos ....................... )what things
  )prompt ........................ )set message prompt
  )version ....................... )lisp *yearweek*
 
Several other things can be listed with the )what command:
 
  categories displays a list of category constructors.
  commands  displays a list of  system commands available  at your
    user-level. Your user-level is set via the )set userlevel command. To get
    a description of a particular command, such as ``)what'', issue )help
    what.
  domains   displays a list of domain constructors.
  operations displays a list of operations in  the system library.
    It is recommended that you qualify this command with one or more
    patterns, as there are thousands of operations available. For example,
    say you are looking for functions that involve computation of
    eigenvalues. To find their names, try )what operations eig. A rather
    large list of operations is loaded into the workspace when this command
    is first issued. This list will be deleted when you clear the workspace
    via )clear all or )clear completely. It will be re-created if it is
    needed again.
  packages  displays a list of package constructors.
  synonym  lists system command synonyms.
  things    displays all  of the  above types for  items containing
    the pattern strings as substrings. The command synonym )apropos is
    equivalent to )what things.
 
Also See: 
o )display
o )set
o )show
 
\end{chunk}
\footnote{
\fnref{display}
\fnref{set}
\fnref{show}}

\defdollar{whatOptions}
\begin{chunk}{initvars}
(defvar |$whatOptions| '(|operations| |categories| |domains| |packages| 
                         |commands| |synonyms| |things|))

\end{chunk}

\defun{what}{what}
\calls{what}{whatSpad2Cmd}
\begin{chunk}{defun what}
(defun |what| (l)
 (|whatSpad2Cmd| l)) 

\end{chunk}

\defun{whatSpad2Cmd,fixpat}{whatSpad2Cmd,fixpat}
\calls{whatSpad2Cmd,fixpat}{qcar}
\calls{whatSpad2Cmd,fixpat}{downcase}
\begin{chunk}{defun whatSpad2Cmd,fixpat}
(defun |whatSpad2Cmd,fixpat| (x)
 (let (xp)
  (if (and (consp x) (progn (setq xp (qcar x)) t))
   (downcase xp)
   (downcase x))))

\end{chunk}

\defun{whatSpad2Cmd}{whatSpad2Cmd}
\calls{whatSpad2Cmd}{reportWhatOptions}
\calls{whatSpad2Cmd}{selectOptionLC}
\calls{whatSpad2Cmd}{sayKeyedMsg}
\calls{whatSpad2Cmd}{seq}
\calls{whatSpad2Cmd}{exit}
\calls{whatSpad2Cmd}{whatSpad2Cmd,fixpat}
\calls{whatSpad2Cmd}{whatSpad2Cmd}
\calls{whatSpad2Cmd}{filterAndFormatConstructors}
\calls{whatSpad2Cmd}{whatCommands}
\calls{whatSpad2Cmd}{apropos}
\calls{whatSpad2Cmd}{printSynonyms}
\usesdollar{whatSpad2Cmd}{e}
\usesdollar{whatSpad2Cmd}{whatOptions}
\begin{chunk}{defun whatSpad2Cmd}
(defun |whatSpad2Cmd| (arg)
 (prog (|$e| |key0| key args)
  (declare (special |$e| |$whatOptions|))
  (return
   (seq
    (progn
     (setq |$e| |$EmptyEnvironment|)
     (cond
      ((null arg) (|reportWhatOptions|))
      (t
        (setq |key0| (car arg))
        (setq args (cdr arg))
        (setq key (|selectOptionLC| |key0| |$whatOptions| nil))
        (cond
         ((null key)
          (|sayKeyedMsg|
           (format nil
            "Your argument is not valid for the )what system command. %l %l ~
             Use the )show system command to display the operations for a ~
             constructor. Use the )display operations system command to see ~
             information about an operation. These may be abbreviated to ~
             )sh and )d op, respectively.")
            nil))
         (t
          (setq args
           (prog (t0)
            (setq t0 nil)
            (return
              (do ((t1 args (cdr t1)) (p nil))
                  ((or (atom t1)
                       (progn (setq p (car t1)) nil))
                 (nreverse0 t0))
               (seq
                (exit
                 (setq t0 (cons (|whatSpad2Cmd,fixpat| p) t0))))))))
          (seq
           (cond
            ((eq key '|things|)
              (do ((t2 |$whatOptions| (cdr t2)) (opt nil))
                  ((or (atom t2) (progn (setq opt (CAR t2)) nil)) nil)
               (seq
                (exit
                 (cond
                  ((null (member opt '(|things|)))
                    (exit (|whatSpad2Cmd| (cons opt args)))))))))
            ((eq key '|categories|)
              (|filterAndFormatConstructors| '|category| "Categories" args))
            ((eq key '|commands|) (|whatCommands| args))
            ((eq key '|domains|)
              (|filterAndFormatConstructors| '|domain| "Domains" args))
            ((eq key '|operations|)
               (|apropos| args))
            ((eq key '|packages|)
              (|filterAndFormatConstructors| '|package| "Packages" args))
            (t
             (cond ((eq key '|synonyms|)
                      (|printSynonyms| args))))))))))))))) 

\end{chunk}

\defun{reportWhatOptions}{Show keywords for )what command}
\calls{reportWhatOptions}{sayBrightly}
\usesdollar{reportWhatOptions}{whatOptions}
\begin{chunk}{defun reportWhatOptions}
(defun |reportWhatOptions| ()
 (let (optlist)
 (declare (special |$whatOptions|))
  (setq optlist
   (reduce #'append
    (mapcar #'(lambda (x) `(|%l| "        " ,x)) |$whatOptions|)))
  (|sayBrightly|
   `("  )what" "argument keywords are" ,@optlist
     |%l| "   or abbreviations thereof." |%l| |%l| "   Issue" ")what ?"
     "for more information."))))

\end{chunk}

\defun{whatCommands}{The )what commands implementation}
\calls{whatCommands}{concat}
\calls{whatCommands}{specialChar}
\calls{whatCommands}{filterListOfStrings}
\calls{whatCommands}{commandsForUserLevel}
\calls{whatCommands}{sayMessage}
\calls{whatCommands}{blankList}
\calls{whatCommands}{sayAsManyPerLineAsPossible}
\calls{whatCommands}{say}
\calls{whatCommands}{sayKeyedMsg}
\usesdollar{whatCommands}{systemCommands}
\usesdollar{whatCommands}{linelength}
\usesdollar{whatCommands}{UserLevel}
\begin{chunk}{defun whatCommands}
(defun |whatCommands| (patterns)
 (let (label ell)
 (declare (special |$systemCommands| $linelength |$UserLevel|))
  (setq label 
   (concat '|System Commands for User Level: | 
     (princ-to-string |$UserLevel|)))
  (format t "~v,,,'-:@< ~a ~>~%" (- $linelength 2) label)
  (setq ell
   (|filterListOfStrings| patterns
    (mapcar #'princ-to-string (|commandsForUserLevel| |$systemCommands|))))
  (when patterns
   (if ell
     (|sayMessage|
      `("System commands at this level matching patterns:" |%l| "   "
         ,@(append (|blankList| patterns) (list nil))))
     (|sayMessage|
      `("No system commands at this level matching patterns:" |%l| "   "
        ,@(append (|blankList| patterns) (list nil))))))
  (when ell
   (|sayAsManyPerLineAsPossible| ell)
   (say " "))
  (unless patterns
   (|sayKeyedMsg|
    (format nil
     "For more information about individual commands, use the )help ~
      system command followed by the command name or the command name ~
      followed by a question mark. Some commands (such as )lisp ) may ~
      require the )help lisp format.  For example, issue )help help or ~
      )help %x1 ? to find out more about the help command itself.")
     nil))))

\end{chunk}

\defun{filterListOfStrings}{Find all names contained in a pattern}
Names and patterns are lists of strings. This returns a list of strings 
in names that contains any of the strings in the patterns
\calls{filterListOfStrings}{satisfiesRegularExpressions}
\begin{chunk}{defun filterListOfStrings}
(defun |filterListOfStrings| (patterns names)
 (let (result)
 (if (or (null patterns) (null names))
  names
  (dolist (name (reverse names) result)
   (when (|satisfiesRegularExpressions| name patterns)
    (push name result))))))

\end{chunk}

\defun{filterListOfStringsWithFn}{Find function of names contained in pattern}
The argument names and patterns are lists of strings.
The argument fn is something like CAR or CADR
This returns a list of strings in names that contains any of the strings
in patterns.

\calls{filterListOfStringsWithFn}{satisfiesRegularExpressions}
\begin{chunk}{defun filterListOfStringsWithFn}
(defun |filterListOfStringsWithFn| (patterns names fn)
 (let (result)
 (if (or (null patterns) (null names))
  names
  (dolist (name (reverse names) result)
   (when (|satisfiesRegularExpressions| (funcall fn name) patterns)
    (push name result))))))

\end{chunk}

\defun{satisfiesRegularExpressions}{satisfiesRegularExpressions}
\calls{satisfiesRegularExpressions}{strpos}
\begin{chunk}{defun satisfiesRegularExpressions}
(defun |satisfiesRegularExpressions| (name patterns)
 (let ((dname (downcase (copy name))))
  (dolist (pattern patterns)
   (when (strpos pattern dname 0 "@")
    (return-from nil t)))))

\end{chunk}

\defun{filterAndFormatConstructors}{filterAndFormatConstructors}
\calls{filterAndFormatConstructors}{sayMessage}
\calls{filterAndFormatConstructors}{blankList}
\calls{filterAndFormatConstructors}{pp2Cols}
\calls{filterAndFormatConstructors}{specialChar}
\calls{filterAndFormatConstructors}{filterListOfStringsWithFn}
\calls{filterAndFormatConstructors}{whatConstructors}
\calls{filterAndFormatConstructors}{function}
\usesdollar{filterAndFormatConstructors}{linelength}
\begin{chunk}{defun filterAndFormatConstructors}
(defun |filterAndFormatConstructors| (constrType label patterns)
 (prog (l)
 (declare (special $linelength))
  (return
   (progn
    (format t "~v,,,'-:@< ~a ~>~%" (- $linelength 2) label)
    (setq l
     (|filterListOfStringsWithFn| patterns
       (|whatConstructors| constrType)
       #'cdr))
    (cond (patterns
     (cond
      ((null l)
       (|sayMessage|
        (cons "   No "
         (cons label
          (cons " with names matching patterns:"
           (cons '|%l|
            (cons "    "
              (append (|blankList| patterns) 
               (cons " " nil)))))))))
      (t
        (|sayMessage|
         (cons label
          (cons " with names matching patterns:"
           (cons '|%l|
            (cons "    "
              (append (|blankList| patterns)
               (cons " " nil)))))))))))
    (cond (l (|pp2Cols| l)))))))

\end{chunk} 

\defun{whatConstructors}{whatConstructors}
\calls{whatConstructors}{boot-equal}
\calls{whatConstructors}{getdatabase}
\calls{whatConstructors}{seq}
\calls{whatConstructors}{msort}
\calls{whatConstructors}{exit}
\begin{chunk}{defun whatConstructors}
(defun |whatConstructors| (constrType)
 (prog nil
  (return 
   (seq
    (msort
     (prog (t0)
      (setq t0 nil)
      (return
       (do ((t1 (|allConstructors|) (cdr t1)) (|con| nil))
           ((or (atom t1) (progn (setq |con| (car t1)) nil)) (nreverse0 t0))
        (seq
         (exit
          (cond
           ((equal (getdatabase |con| 'constructorkind) constrType)
             (setq t0
              (cons
               (cons
                (getdatabase |con| 'abbreviation)
                (string |con|))
               t0)))))))))))))) 

\end{chunk}

\defunsec{apropos}{Display all operation names containing the fragment}
Argument l is a list of operation name fragments.
This displays all operation names containing these fragments.

\calls{apropos}{allOperations}
\calls{apropos}{filterListOfStrings}
\calls{apropos}{seq}
\calls{apropos}{exit}
\calls{apropos}{downcase}
\calls{apropos}{sayMessage}
\calls{apropos}{sayAsManyPerLineAsPossible}
\calls{apropos}{msort}
\calls{apropos}{sayKeyedMsg}
\begin{chunk}{defun apropos}
(defun |apropos| (arg)
 "Display all operation names containing the fragment"
 (prog (ops)
  (return
   (seq
    (progn
     (setq ops
      (cond 
       ((null arg) (|allOperations|))
       (t
         (|filterListOfStrings|
          (prog (t0)
           (setq t0 nil)
           (return
            (do ((t1 arg (cdr t1)) (p nil))
                ((or (atom t1) (progn (setq p (car t1)) nil))
                  (nreverse0 t0))
            (seq (exit (setq t0 (cons (downcase (princ-to-string p)) t0)))))))
          (|allOperations|)))))
     (cond
      (ops
       (|sayMessage| "Operations whose names satisfy the above pattern(s):")
       (|sayAsManyPerLineAsPossible| (msort ops))
       (|sayKeyedMsg| 
        (format nil
         "%l To get more information about an operation such as %1, issue ~
         the command )display op %1")
         (cons (car ops) nil)))
      (t
       (|sayMessage| "   There are no operations containing those patterns")
       nil))))))) 

\end{chunk}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cmdhead{workfiles}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defun{workfiles}{workfiles}
\calls{workfiles}{workfilesSpad2Cmd}
\begin{chunk}{defun workfiles}
(defun |workfiles| (l)
 (|workfilesSpad2Cmd| l)) 

\end{chunk}

\defun{workfilesSpad2Cmd}{workfilesSpad2Cmd}
\calls{workfilesSpad2Cmd}{throwKeyedMsg}
\calls{workfilesSpad2Cmd}{selectOptionLC}
\calls{workfilesSpad2Cmd}{pathname}
\calls{workfilesSpad2Cmd}{delete}
\calls{workfilesSpad2Cmd}{makeInputFilename}
\calls{workfilesSpad2Cmd}{sayKeyedMsg}
\calls{workfilesSpad2Cmd}{namestring}
\calls{workfilesSpad2Cmd}{updateSourceFiles}
\calls{workfilesSpad2Cmd}{say}
\calls{workfilesSpad2Cmd}{specialChar}
\calls{workfilesSpad2Cmd}{sortby}
\calls{workfilesSpad2Cmd}{sayBrightly}
\usesdollar{workfilesSpad2Cmd}{options}
\usesdollar{workfilesSpad2Cmd}{sourceFiles}
\usesdollar{workfilesSpad2Cmd}{linelength}
\begin{chunk}{defun workfilesSpad2Cmd}
(defun |workfilesSpad2Cmd| (args)
 (let (deleteflag type flist type1 fl)
  (declare (special |$options| |$sourceFiles| $linelength))
  (cond 
   (args
    (|throwKeyedMsg|
     (format nil
      "Arguments are not allowed for the )workfiles system command. ~
       The )boot, )lisp, )meta and )delete options may be used with this ~
       command, however. Issue )help workfiles for more information.")  
     nil))
   (t
     (setq deleteflag nil)
     (do ((t0 |$options| (cdr t0)) (t1 nil))
         ((or (atom t0)
              (progn (setq t1 (car t0)) nil)
              (progn (progn (setq type (car t1)) t1) nil))
           nil)
       (setq type1
          (|selectOptionLC| type '(|boot| |lisp| |meta| |delete|) nil))
       (cond
        ((null type1) 
         (|throwKeyedMsg|
          (format nil 
           "%1 is not an allowable option for the )workfiles system command. ~
            The )boot, )lisp, )meta and )delete options may be used with this ~
            command, however. Issue )help workfiles for more information.")
           (cons type nil)))
        ((eq type1 '|delete|) (setq deleteflag t))))
     (do ((t2 |$options| (cdr t2)) (t3 nil))
         ((or (atom t2)
          (progn (setq t3 (CAR t2)) nil)
          (progn
           (progn 
            (setq type (car t3))
            (setq flist (cdr t3)) t3)
           nil))
          nil)
      (setq type1 (|selectOptionLC| type '(|boot| |lisp| |meta| |delete|) nil))
      (unless (eq type1 '|delete|)
        (dolist (file flist)
         (setq fl (|pathname| (list file type1 "*")))
         (cond 
          (deleteflag
           (setq |$sourceFiles| (|delete| fl |$sourceFiles|)))
          ((null (makeInputFilename fl))
           (|sayKeyedMsg| 
            (format nil
             "The file %1 will not be added to the list of working source ~
              files because the file does not exist.")
            (list (|namestring| fl))))
          (t (|updateSourceFiles| fl))))))
     (say " ")
     (format t "~v,,,'-:@<~a~>~%" (- $linelength 2)
       " User-specified work files ")
     (say " ")
     (if (null |$sourceFiles|)
      (say "   no files specified")
      (progn
        (setq |$sourceFiles| (sortby '|pathnameType| |$sourceFiles|))
        (do ((t5 |$sourceFiles| (cdr t5)) (fl nil))
            ((or (atom t5) (progn (setq fl (car t5)) nil)) nil)
           (|sayBrightly| (list "   " (|namestring| fl))))))))))

\end{chunk}

\chapter{Handlers for Special Forms}
This file contains the functions which do type analysis and
evaluation of special functions in the interpreter.
Special functions are ones which are not defined in the algebra
code, such as assignment, construct, COLLECT and declaration.

Operators which require special handlers all have a LISP ``up''
property which is the name of the special handler, which is
always the word ``up'' followed by the operator name.
If an operator has this ``up'' property the handler is called
automatically from bottomUp instead of general modemap selection.

The up handlers are usually split into two pieces, the first is
the up function itself, which performs the type analysis, and an
``eval'' function, which generates (and executes, if required) the
code for the function.

The up functions always take a single argument, which is the
entire attributed tree for the operation, and return the modeSet
of the node, which is a singleton list containing the type
computed for the node.

The eval functions can take any arguments deemed necessary.
Actual evaluation is done if \verb|$genValue| is true, otherwise code is
generated.

(See the function analyzeMap for other things that may affect
what is generated in these functions.)

These functions are required to do two things:
\begin{enumerate}
\item do a putValue on the operator vector with the computed value
     of the node, which is a triple.  This is usually done in the
     eval functions.
\item do a putModeSet on the operator vector with a list of the
     computed type of the node.  This is usually done in the
     up functions.
\end{enumerate}

There are several special modes used in these functions:
\begin{enumerate}
\item Void is the mode that should be used for all statements
     that do not otherwise return values, such as declarations,
     loops, IF-THEN's without ELSE's, etc..
\item \verb|$NoValueMode| and \verb|$ThrowAwayMode| used to be used 
      in situations where Void is now used, and are being phased out 
      completely.
\end{enumerate}

\defun{getAndEvalConstructorArgument}{getAndEvalConstructorArgument}
\calls{getAndEvalConstructorArgument}{getValue}
\calls{getAndEvalConstructorArgument}{objMode}
\calls{getAndEvalConstructorArgument}{isWrapped}
\calls{getAndEvalConstructorArgument}{objVal}
\calls{getAndEvalConstructorArgument}{isLocalVar}
\calls{getAndEvalConstructorArgument}{compFailure}
\calls{getAndEvalConstructorArgument}{mkObjWrap}
\calls{getAndEvalConstructorArgument}{timedEVALFUN}
\begin{chunk}{defun getAndEvalConstructorArgument}
(defun |getAndEvalConstructorArgument| (tree)
 (let (triple)
  (setq triple (|getValue| tree))
  (cond
   ((eq (|objMode| triple) '(|Domain|)) triple)
   ((|isWrapped| (|objVal| triple)) triple)
   ((|isLocalVar| (|objVal| triple))
     (|compFailure| "   Local variable or parameter used in type"))
   (t
    (mkObjWrap (|timedEVALFUN| (|objVal| triple)) (|objMode| triple))))))

\end{chunk}

\defun{replaceSharps}{replaceSharps}
Replaces all sharps in x by the arguments of domain d.
Replaces all replaces the triangle variables.

\calls{replaceSharps}{subCopy}
\refsdollar{replaceSharps}{TriangleVariableList}
\refsdollar{replaceSharps}{FormalMapVariableList}
\begin{chunk}{defun replaceSharps}
(defun |replaceSharps| (x d)
 (let (sl)
 (declare (special |$TriangleVariableList| |$FormalMapVariableList|))
  (loop for e in (rest d) for var in |$FormalMapVariableList| 
   do (setq sl (cons (cons var e) sl)))
  (setq x (|subCopy| x sl))
  (setq sl nil)
  (loop for e in (rest d) for var in |$TriangleVariableList| 
   do (setq sl (cons (cons var e) sl)))
  (|subCopy| x sl)))

\end{chunk}

\defun{isDomainValuedVariable}{isDomainValuedVariable}
Returns the value of form if form is a variable with a type value.

\calls{isDomainValuedVariable}{identp}
\calls{isDomainValuedVariable}{get}
\calls{isDomainValuedVariable}{member}
\calls{isDomainValuedVariable}{objMode}
\calls{isDomainValuedVariable}{objValUnwrap}
\refsdollar{isDomainValuedVariable}{e}
\refsdollar{isDomainValuedVariable}{env}
\refsdollar{isDomainValuedVariable}{InteractiveFrame}
\begin{chunk}{defun isDomainValuedVariable}
(defun |isDomainValuedVariable| (form)
 (let (val)
 (declare (special |$e| |$env| |$InteractiveFrame|))
  (when (and (identp form)
             (setq val
               (or (|get| form '|value| |$InteractiveFrame|)
                   (and (consp |$env|)  (|get| form '|value| |$env|))
                   (and (consp |$e|)    (|get| form '|value| |$e|))))
             (|member| (|objMode| val) '((|Domain|) (|SubDomain| (|Domain|)))))
    (|objValUnwrap| val))))

\end{chunk}

\defun{evalCategory}{evalCategory}
\calls{evalCategory}{ofCategory}
\calls{evalCategory}{isPartialMode}
\begin{chunk}{defun evalCategory}
(defun |evalCategory| (d c)
  (or (|isPartialMode| d) (|ofCategory| d c)))

\end{chunk}

\chapter{Handling input files}
\defun{readSpadProfileIfThere}{Handle .axiom.input file}
\uses{readSpadProfileIfThere}{/editfile}
\begin{chunk}{defun readSpadProfileIfThere}
(defun |readSpadProfileIfThere| ()
 (let ((file (list '|.axiom| '|input|)))
 (declare (special /editfile))
  (when (makeInputFilename file) (setq /editfile file) (/rq))))

\end{chunk}

\defvar{boot-line-stack}
\begin{chunk}{initvars}
(defvar boot-line-stack nil "List of lines returned from preparse")

\end{chunk}

\defvar{in-stream}
\begin{chunk}{initvars}
(defvar in-stream t "Current input stream.")

\end{chunk}
\defvar{out-stream}
\begin{chunk}{initvars}
(defvar out-stream t "Current output stream.")

\end{chunk}
\defvar{file-closed}
\begin{chunk}{initvars}
(defvar file-closed nil  "Way to stop EOF tests for console input.")

\end{chunk}
\defvar{echo-meta}
\begin{chunk}{initvars}
(defvar echo-meta nil "T if you want a listing of what has been read.")

\end{chunk}

\defdollar{noSubsumption}
\begin{chunk}{initvars}
(defvar |$noSubsumption| t)

\end{chunk}

\defdollar{envHashTable}
The \verb|$envHashTable| variable is a hashtable that optimizes lookups
in the environment, which normally involve search. This gets populated
in the addBinding function.
\begin{chunk}{initvars}
(defvar |$envHashTable| nil) 

\end{chunk}

\defun{addBinding}{Dynamically add bindings to the environment}
\calls{addBinding}{getProplist}
\calls{addBinding}{addBindingInteractive}
\calls{addBinding}{hput}
\usesdollar{addBinding}{InteractiveMode}
\usesdollar{addBinding}{envHashTable}
\begin{chunk}{defun addBinding}
(defun |addBinding| (var proplist e)
 (let (tailContour tailEnv tmp1 curContour lx)
 (declare (special |$InteractiveMode| |$envHashTable|))
  (setq curContour (caar e))
  (setq tailContour (cdar e))
  (setq tailEnv (cdr e))
  (cond
   ((eq proplist (|getProplist| var e)) e)
   (t
    (when |$envHashTable|
      (do ((prop proplist (cdr prop)) (u nil))
          ((or (atom prop)
               (progn (setq u (car prop)) nil))
            nil)
        (hput |$envHashTable| (list var (car u)) t)))
    (cond
     (|$InteractiveMode| (|addBindingInteractive| var proplist e))
     (t
      (when (and (consp curContour)
                 (progn
                  (setq tmp1 (qcar curContour))
                  (and (consp tmp1) (equal (qcar tmp1) var))))
        (setq curContour (cdr curContour)))
      (setq lx (cons var proplist))
      (cons (cons (cons lx curContour) tailContour) tailEnv)))))))

\end{chunk}

\defun{getProplist}{Fetch a property list for a symbol from CategoryFrame}
\calls{getProplist}{getProplist}
\calls{getProplist}{search}
\usesdollar{getProplist}{CategoryFrame}
\begin{chunk}{defun getProplist}
(defun |getProplist| (x e)
 (let (u pl)
 (declare (special |$CategoryFrame|))
  (cond
   ((null (atom x)) (|getProplist| (car x) e))
   ((setq u (|search| x e)) u)
   ((setq pl (|search| x |$CategoryFrame|)) pl))))

\end{chunk}

\defun{search}{Search for a binding in the environment list}
\calls{search}{searchCurrentEnv}
\calls{search}{searchTailEnv}
\begin{chunk}{defun search}
(defun |search| (x e)
 (let ((curEnv (car e)) (tailEnv (cdr e)))
  (or (|searchCurrentEnv| x curEnv) (|searchTailEnv| x tailEnv))))

\end{chunk}

\defun{searchCurrentEnv}{Search for a binding in the current environment}
\begin{verbatim}
searchCurrentEnv(x,currentEnv) ==
  for contour in currentEnv repeat
    if u:= ASSQ(x,contour) then return (signal:= u)
  KDR signal
\end{verbatim}
\calls{searchCurrentEnv}{assq}
\begin{chunk}{defun searchCurrentEnv}
(defun |searchCurrentEnv| (x currentEnv)
 (prog (u signal)
  (return
   (seq
    (progn
     (do ((thisenv currentEnv (cdr thisenv)) (contour nil))
         ((or (atom thisenv) (progn (setq contour (car thisenv)) nil)) nil)
      (seq
       (exit
        (cond
         ((setq u (assq x contour)) (return (setq signal u)))
         (t nil)))))
     (ifcdr signal))))))

\end{chunk}

\defun{searchTailEnv}{searchTailEnv}
\begin{verbatim}
;searchTailEnv(x,e) ==
;  for env in e repeat
;    signal:=
;      for contour in env repeat
;        if (u:= ASSQ(x,contour)) and ASSQ("FLUID",u) then return (signal:= u)
;      if signal then return signal
;  KDR signal
\end{verbatim}
\calls{searchTailEnv}{assq}
\begin{chunk}{defun searchTailEnv}
(defun |searchTailEnv| (x e)
 (prog (u signal)
  (return
   (seq
    (progn
     (do ((thise e (cdr thise)) (env nil))
         ((or (atom thise) (progn (setq env (car thise)) nil)) nil)
       (seq
        (exit
         (setq signal
          (progn
           (do ((cone env (cdr cone)) (contour nil))
               ((or (atom cone) (progn (setq contour (car cone)) nil)) nil)
             (seq
              (exit
               (cond
                ((and (setq u (assq x contour)) (assq 'fluid u))
                 (return (setq signal u)))
                (t nil)))))
           (cond
            (signal (return signal))
            (t nil)))))))
     (ifcdr signal))))))

\end{chunk}

\chapter{Line Handling}

\subsection{Line Buffer}
The philosophy of lines is that
\begin{itemize}
\item NEXT LINE will always return a non-blank line or fail.
\item Every line is terminated by a blank character.
\end{itemize}
Hence there is always a current character, because there is never a 
non-blank line, and there is always a separator character between tokens 
on separate lines. Also, when a line is read, the character pointer is 
always positioned ON the first character.
\defstruct{line}
\begin{chunk}{initvars}
(defstruct line "Line of input file to parse."
           (buffer (make-string 0) :type string)
           (current-char #\Return :type character)
           (current-index 1 :type fixnum)
           (last-index 0 :type fixnum)
           (number 0 :type fixnum))

\end{chunk}

\defvar{current-line}
The current input line.
\begin{chunk}{initvars}
(defvar current-line (make-line))

\end{chunk}


\defmacro{line-clear}
\usesstruct{line-clear}{line}
\begin{chunk}{defmacro line-clear 0}
(defmacro line-clear (line)
 `(let ((l ,line))
   (setf (line-buffer l) (make-string 0))
   (setf (line-current-char l) #\return)
   (setf (line-current-index l) 1)
   (setf (line-last-index l) 0)
   (setf (line-number l) 0)))

\end{chunk}

\defun{line-print}{line-print}
\usesstruct{line-print}{line}
\refsdollar{line-print}{out-stream}
\begin{chunk}{defun line-print 0}
(defun line-print (line)
 (declare (special out-stream))
  (format out-stream "~&~5D> ~A~%" (Line-Number line) (Line-Buffer Line))
  (format out-stream "~v@T^~%" (+ 7 (Line-Current-Index line))))

\end{chunk}

\defun{line-at-end-p}{line-at-end-p}
\usesstruct{line-at-end-p}{line}
\begin{chunk}{defun line-at-end-p 0}
(defun line-at-end-p (line)
  "Tests if line is empty or positioned past the last character."
  (>= (line-current-index line) (line-last-index line)))

\end{chunk}

\defun{line-past-end-p}{line-past-end-p}
\usesstruct{line-past-end-p}{line}
\begin{chunk}{defun line-past-end-p 0}
(defun line-past-end-p (line)
  "Tests if line is empty or positioned past the last character."
  (> (line-current-index line) (line-last-index line)))

\end{chunk}

\defun{line-next-char}{line-next-char}
\usesstruct{line-next-char}{line}
\begin{chunk}{defun line-next-char 0}
(defun line-next-char (line)
  (elt (line-buffer line) (1+ (line-current-index line))))

\end{chunk}

\defun{line-advance-char}{line-advance-char}
\usesstruct{line-advance-char}{line}
\begin{chunk}{defun line-advance-char 0}
(defun line-advance-char (line)
  (setf (line-current-char line)
        (elt (line-buffer line) (incf (line-current-index line)))))

\end{chunk}

\defun{line-current-segment}{line-current-segment}
\usesstruct{line-print}{line}
\begin{chunk}{defun line-current-segment 0}
(defun line-current-segment (line)
  "Buffer from current index to last index."
  (if (line-at-end-p line) 
   (make-string 0)
   (subseq (line-buffer line)
           (line-current-index line)
           (line-last-index line))))

\end{chunk}

\defun{line-new-line}{line-new-line}
\usesstruct{line-new-line}{line}
\begin{chunk}{defun line-new-line 0}
(defun line-new-line (string line &optional (linenum nil))
  "Sets string to be the next line stored in line."
  (setf (line-last-index line) (1- (length string)))
  (setf (line-current-index line) 0)
  (setf (line-current-char line)
        (or (and (> (length string) 0) (elt string 0)) #\Return))
  (setf (line-buffer line) string)
  (setf (line-number line) (or linenum (1+ (line-number line)))))

\end{chunk}

\defun{next-line}{next-line}
\refsdollar{next-line}{in-stream}
\refsdollar{next-line}{line-handler}
\begin{chunk}{defun next-line 0}
(defun next-line (&optional (in-stream t))
 (declare (special in-stream line-handler))
 (funcall Line-Handler in-stream))

\end{chunk}

\defun{Advance-Char}{Advance-Char}
\calls{Advance-Char}{Line-At-End-P}
\calls{Advance-Char}{Line-Advance-Char}
\calls{Advance-Char}{next-line}
\calls{Advance-Char}{current-char}
\refsdollar{Advance-Char}{in-stream}
\usesstruct{Advance-Char}{line}
\begin{chunk}{defun Advance-Char}
(defun Advance-Char ()
  "Advances IN-STREAM, invoking Next Line if necessary."
 (declare (special in-stream))
 (loop
  (cond
   ((not (Line-At-End-P Current-Line))
    (return (Line-Advance-Char Current-Line)))
   ((next-line in-stream) 
    (return (current-char)))
   ((return nil)))))

\end{chunk}

\defun{storeblanks}{storeblanks}
\begin{chunk}{defun storeblanks 0}
(defun storeblanks (line n)
 (do ((i 0 (1+ i)))
     ((= i n) line)
  (setf (char line i) #\ )))

\end{chunk}
 
\defun{initial-substring}{initial-substring}
\begin{chunk}{defun initial-substring 0}
(defun initial-substring (pattern line)
   (let ((ind (mismatch pattern line)))
     (or (null ind) (eql ind (size pattern)))))

\end{chunk}
 
\defun{get-a-line}{get-a-line}
\calls{get-a-line}{is-console}
\seebook{get-a-line}{mkprompt}{5}
\calls{get-a-line}{read-a-line}
\sig{get-a-line}{FileStream}{String}
where FileStream might be
\begin{verbatim}
   #<input stream "/research/t1/src/algebra/EQ.spad">
\end{verbatim}
and the returned string might be
\begin{verbatim}
   ")abbrev domain EQ Equation"
\end{verbatim}
\begin{chunk}{defun get-a-line 0}
(defun get-a-line (stream)
 (when (is-console stream) (princ (mkprompt)))
 (let ((ll (read-a-line stream)))
  (if (and (stringp ll) (adjustable-array-p ll))
   (make-array (array-dimensions ll) :element-type 'string-char
                  :adjustable t :initial-contents ll)
   ll)))

\end{chunk}

\chapter{File Parsing}
\defun{addBindingInteractive}{Bind a variable in the interactive environment}
\calls{addBindingInteractive}{assq}
\begin{chunk}{defun addBindingInteractive}
(defun |addBindingInteractive| (var proplist e)
 (let ((curContour (caar e)) u)
  (cond
   ((setq u (assq var curContour)) (rplacd u proplist) e)
   (t (rplac (caar e) (cons (cons var proplist) curContour)) e))))

\end{chunk}

\defvar{line-handler}
\begin{chunk}{initvars}
(defparameter line-handler 'next-META-line "Who grabs lines for us.")

\end{chunk}

\defdollar{spad-errors}
\begin{chunk}{initvars}
(defvar $spad_errors (vector 0 0 0))

\end{chunk}

\defvar{xtokenreader}
\begin{chunk}{initvars}
(defvar xtokenreader 'spadtok)

\end{chunk}

\defun{init-boot/spad-reader}{Initialize the spad reader}
\calls{init-boot/spad-reader}{ioclear}
\usesdollar{init-boot/spad-reader}{spad-errors}
\uses{init-boot/spad-reader}{spaderrorstream}
\uses{init-boot/spad-reader}{*standard-output* }
\uses{init-boot/spad-reader}{xtokenreader}
\uses{init-boot/spad-reader}{line-handler}
\uses{init-boot/spad-reader}{meta-error-handler}
\uses{init-boot/spad-reader}{file-closed}
\uses{init-boot/spad-reader}{boot-line-stack}
\begin{chunk}{defun init-boot/spad-reader}
(defun init-boot/spad-reader ()
 (declare (special $spad_errors spaderrorstream *standard-output* 
           xtokenreader line-handler meta-error-handler file-closed
           boot-line-stack))
  (setq $spad_errors (vector 0 0 0))
  (setq spaderrorstream *standard-output*)
  (setq xtokenreader 'get-BOOT-token)
  (setq line-Handler 'next-BOOT-line)
  (setq meta-error-handler 'spad-syntax-error)
  (setq file-closed nil)
  (setq boot-line-stack nil)
  (ioclear))

\end{chunk}

\defun{spad-syntax-error}{spad-syntax-error}
\calls{spad-syntax-error}{bumperrorcount}
\calls{spad-syntax-error}{consoleinputp}
\calls{spad-syntax-error}{spad-long-error}
\calls{spad-syntax-error}{spad-short-error}
\calls{spad-syntax-error}{ioclear}
\uses{spad-syntax-error}{debugmode}
\throws{spad-syntax-error}{spad-reader}
\begin{chunk}{defun spad-syntax-error}
(defun spad-syntax-error (&rest byebye)
  "Print syntax error indication, underline character, scrub line."
  (declare (special debugmode byebye))
  (bumperrorcount '|syntax|)
  (cond ((and (eq debugmode 'yes) (not(consoleinputp in-stream)))
         (spad-long-error))
        ((spad-short-error)))
  (ioclear)
  (throw 'spad_reader nil))

\end{chunk}

\defun{spad-long-error}{spad-long-error}
\calls{spad-long-error}{spad-error-loc}
\calls{spad-long-error}{iostat}
\uses{spad-long-error}{out-stream}
\uses{spad-long-error}{spaderrorstream}
\begin{chunk}{defun spad-long-error}
(defun spad-long-error ()
 (declare (special spaderrorstream))
  (spad-error-loc spaderrorstream)
  (iostat)
  (unless (equal out-stream spaderrorstream)
    (spad-error-loc out-stream)
    (terpri out-stream)))

\end{chunk}

\defun{spad-short-error}{spad-short-error}
\calls{spad-short-error}{line-past-end-p}
\calls{spad-short-error}{line-print}
\usesstruct{spad-short-error}{current-line}
\begin{chunk}{defun spad-short-error}
(defun spad-short-error ()
 (if (line-past-end-p Current-Line)
    (format t "~&The current line is empty.~%")
    (progn
     (format t "~&The current line is:~%~%")
     (line-print current-line))))

\end{chunk}

\defun{spad-error-loc}{spad-error-loc}
\begin{chunk}{defun spad-error-loc}
(defun spad-error-loc (str)
  (format str "******** Boot Syntax Error detected ********"))

\end{chunk}

\defun{iostat}{iostat}
\calls{iostat}{line-past-end-p}
\calls{iostat}{line-print}
\calls{iostat}{token-stack-show}
\calls{iostat}{next-lines-show}
\usesdollar{iostat}{boot}
\usesdollar{iostat}{spad}
\usesstruct{iostat}{current-line}
\begin{chunk}{defun iostat}
(defun iostat ()
  "Tell me what the current state of the parsing world is."
  (declare (special $boot $spad))
  (if (line-past-end-p Current-Line)
    (format t "~&The current line is empty.~%")
    (progn
     (format t "~&The current line is:~%~%")
     (line-print current-line)))
  (if (or $boot $spad) (next-lines-show))
  (token-stack-show)
  nil)

\end{chunk}

\defun{next-lines-show}{next-lines-show}
\uses{next-lines-show}{boot-line-stack}
\begin{chunk}{defun next-lines-show}
(defun next-lines-show ()
  (declare (special boot-line-stack))
  (and boot-line-stack (format t "Currently preparsed lines are:~%~%"))
  (mapcar #'(lambda (line)
              (format t "~&~5D> ~A~%" (car line) (cdr Line)))
          boot-line-stack))

\end{chunk}

\defun{token-stack-show}{token-stack-show}
\calls{token-stack-show}{token-type}
\uses{token-stack-show}{valid-tokens}
\uses{token-stack-show}{current-token}
\uses{token-stack-show}{next-token}
\uses{token-stack-show}{prior-token}
\begin{chunk}{defun token-stack-show}
(defun token-stack-show ()
  (if (= valid-tokens 0) 
   (format t "~%There are no valid tokens.~%")
   (format t "~%The number of valid tokens is ~S.~%" valid-tokens))
  (when (> valid-tokens 0)
   (format t "The current token is~%")
   (describe current-token))
  (when (> valid-tokens 1)
   (format t "The next token is~%")
   (describe next-token))
  (when (token-type prior-token)
   (format t "The prior token was~%")
   (describe prior-token)))

\end{chunk}

\defun{ioclear}{ioclear}
The IO state manipulation routines assume that
\begin{itemize}
\item one I/O stream pair is in effect at any moment
\item there is a current line
\item there is a current token and a next token
\item there is a reduction stack
\end{itemize}
\calls{ioclear}{line-clear}
\calls{ioclear}{reduce-stack-clear}
\uses{ioclear}{current-fragment}
\uses{ioclear}{current-line}
\seebook{ioclear}{token-install}{9}
\usesdollar{ioclear}{boot}
\usesdollar{ioclear}{spad}
\begin{chunk}{defun ioclear}
(defun ioclear (&optional (in t) (out t))
 (declare (special current-fragment current-line $boot $spad)
          (ignore in out))
  (setq current-fragment nil)
  (line-clear current-line)
  (token-install nil nil current-token nil)
  (token-install nil nil next-token nil)
  (token-install nil nil prior-token nil)
  (reduce-stack-clear)
  (if (or $boot $spad) (setq boot-line-stack nil))
  nil)

\end{chunk}


\chapter{Handling output}
\section{Special Character Tables}

\defdollar{defaultSpecialCharacters}
\begin{chunk}{initvars}
(defvar |$defaultSpecialCharacters| (list
 (int-char 28)    ; upper left corner
 (int-char 27)    ; upper right corner
 (int-char 30)    ; lower left corner
 (int-char 31)    ; lower right corner
 (int-char 79)    ; vertical bar
 (int-char 45)    ; horizontal bar
 (int-char 144)   ; APL quad
 (int-char 173)   ; left bracket
 (int-char 189)   ; right bracket
 (int-char 192)   ; left brace
 (int-char 208)   ; right brace
 (int-char 59)    ; top    box tee
 (int-char 62)    ; bottom box tee
 (int-char 63)    ; right  box tee
 (int-char 61)    ; left   box tee
 (int-char 44)    ; center box tee
 (int-char 224))) ; back slash

\end{chunk}

\defdollar{plainSpecialCharacters0}
\begin{chunk}{initvars}
(defvar |$plainSpecialCharacters0| (list
 (int-char 78)     ; upper left corner   (+)
 (int-char 78)     ; upper right corner  (+)
 (int-char 78)     ; lower left corner   (+)
 (int-char 78)     ; lower right corner  (+)
 (int-char 79)     ; vertical bar
 (int-char 96)     ; horizontal bar      (-)
 (int-char 111)    ; APL quad            (?)
 (int-char 173)    ; left bracket
 (int-char 189)    ; right bracket
 (int-char 192)    ; left brace
 (int-char 208)    ; right brace
 (int-char 78)     ; top    box tee      (+)
 (int-char 78)     ; bottom box tee      (+)
 (int-char 78)     ; right  box tee      (+)
 (int-char 78)     ; left   box tee      (+)
 (int-char 78)     ; center box tee      (+)
 (int-char 224)))  ; back slash

\end{chunk}

\defdollar{plainSpecialCharacters1}
\begin{chunk}{initvars}
(defvar |$plainSpecialCharacters1| (list
 (int-char 107)    ; upper left corner   (,)
 (int-char 107)    ; upper right corner  (,)
 (int-char 125)    ; lower left corner   (')
 (int-char 125)    ; lower right corner  (')
 (int-char 79)     ; vertical bar
 (int-char 96)     ; horizontal bar      (-)
 (int-char 111)    ; APL quad            (?)
 (int-char 173)    ; left bracket
 (int-char 189)    ; right bracket
 (int-char 192)    ; left brace
 (int-char 208)    ; right brace
 (int-char 78)     ; top    box tee      (+)
 (int-char 78)     ; bottom box tee      (+)
 (int-char 78)     ; right  box tee      (+)
 (int-char 78)     ; left   box tee      (+)
 (int-char 78)     ; center box tee      (+)
 (int-char 224)))  ; back slash

\end{chunk}

\defdollar{plainSpecialCharacters2}
\begin{chunk}{initvars}
(defvar |$plainSpecialCharacters2| (list
 (int-char 79)     ; upper left corner   (|)
 (int-char 79)     ; upper right corner  (|)
 (int-char 79)     ; lower left corner   (|)
 (int-char 79)     ; lower right corner  (|)
 (int-char 79)     ; vertical bar
 (int-char 96)     ; horizontal bar      (-)
 (int-char 111)    ; APL quad            (?)
 (int-char 173)    ; left bracket
 (int-char 189)    ; right bracket
 (int-char 192)    ; left brace
 (int-char 208)    ; right brace
 (int-char 78)     ; top    box tee      (+)
 (int-char 78)     ; bottom box tee      (+)
 (int-char 78)     ; right  box tee      (+)
 (int-char 78)     ; left   box tee      (+)
 (int-char 78)     ; center box tee      (+)
 (int-char 224)))  ; back slash

\end{chunk}

\defdollar{plainSpecialCharacters3}
\begin{chunk}{initvars}
(defvar |$plainSpecialCharacters3| (list
 (int-char 96)     ; upper left corner   (-)
 (int-char 96)     ; upper right corner  (-)
 (int-char 96)     ; lower left corner   (-)
 (int-char 96)     ; lower right corner  (-)
 (int-char 79)     ; vertical bar
 (int-char 96)     ; horizontal bar      (-)
 (int-char 111)    ; APL quad            (?)
 (int-char 173)    ; left bracket
 (int-char 189)    ; right bracket
 (int-char 192)    ; left brace
 (int-char 208)    ; right brace
 (int-char 78)     ; top    box tee      (+)
 (int-char 78)     ; bottom box tee      (+)
 (int-char 78)     ; right  box tee      (+)
 (int-char 78)     ; left   box tee      (+)
 (int-char 78)     ; center box tee      (+)
 (int-char 224)))  ; back slash

\end{chunk}

\defdollar{plainRTspecialCharacters}
\begin{chunk}{initvars}
(defvar |$plainRTspecialCharacters| (list
 (QUOTE +)       ; upper left corner   (+)
 (QUOTE +)       ; upper right corner  (+)
 (QUOTE +)       ; lower left corner   (+)
 (QUOTE +)       ; lower right corner  (+)
 (QUOTE |\||)    ; vertical bar
 (QUOTE -)       ; horizontal bar      (-)
 (QUOTE ?)       ; APL quad            (?)
 (QUOTE [)       ; left bracket
 (QUOTE ])       ; right bracket
 (QUOTE {)       ; left brace
 (QUOTE })       ; right brace
 (QUOTE +)       ; top    box tee      (+)
 (QUOTE +)       ; bottom box tee      (+)
 (QUOTE +)       ; right  box tee      (+)
 (QUOTE +)       ; left   box tee      (+)
 (QUOTE +)       ; center box tee      (+)
 (QUOTE |\\|)))  ; back slash

\end{chunk}

\defdollar{RTspecialCharacters}
\begin{chunk}{initvars}
(defvar |$RTspecialCharacters| (list
 (intern (string (code-char 218))) ;-- upper left corner   (+)
 (intern (string (code-char 191))) ;-- upper right corner  (+)
 (intern (string (code-char 192))) ;-- lower left corner   (+)
 (intern (string (code-char 217))) ;-- lower right corner  (+)
 (intern (string (code-char 179))) ;-- vertical bar
 (intern (string (code-char 196))) ;-- horizontal bar      (-)
 (list (code-char #x1d) (code-char #xe2))
                                   ;-- APL quad            (?)
 (QUOTE [)                         ;-- left bracket
 (QUOTE ])                         ;-- right bracket
 (QUOTE {)                         ;-- left brace
 (QUOTE })                         ;-- right brace
 (intern (string (code-char 194))) ;-- top    box tee      (+)
 (intern (string (code-char 193))) ;-- bottom box tee      (+)
 (intern (string (code-char 180))) ;-- right  box tee      (+)
 (intern (string (code-char 195))) ;-- left   box tee      (+)
 (intern (string (code-char 197))) ;-- center box tee      (+)
 (QUOTE |\\|)))                    ;-- back slash

\end{chunk}

\defdollar{specialCharacters}
\begin{chunk}{initvars}
(defvar |$specialCharacters| |$RTspecialCharacters|)

\end{chunk}

\defdollar{specialCharacterAlist}
\begin{chunk}{initvars}
(defvar |$specialCharacterAlist| 
 '((|ulc| . 0) 
   (|urc| . 1)
   (|llc| . 2)
   (|lrc| . 3)
   (|vbar| . 4)
   (|hbar| . 5)
   (|quad| . 6)
   (|lbrk| . 7)
   (|rbrk| . 8)
   (|lbrc| . 9)
   (|rbrc| . 10)
   (|ttee| . 11)
   (|btee| . 12)
   (|rtee| . 13)
   (|ltee| . 14)
   (|ctee| . 15)
   (|bslash| . 16)))

\end{chunk}

\defun{specialChar}{Look up a special character code for a symbol}
This function looks up a symbol in \verb|$specialCharacterAlist|, 
gets the index into the EBCDIC table, and returns the appropriate character. 
\tpdhere{Make this more international, not EBCDIC}.

\calls{specialChar}{ifcdr}
\calls{specialChar}{assq}
\usesdollar{specialChar}{specialCharacters}
\usesdollar{specialChar}{specialCharacterAlist}
\begin{chunk}{defun specialChar}
(defun |specialChar| (symbol)
 (let (code)
 (declare (special |$specialCharacters| |$specialCharacterAlist|))
  (if (setq code (ifcdr (assq symbol |$specialCharacterAlist|)))
   (elt |$specialCharacters| code)
   "?")))

\end{chunk}

\chapter{Stream and File Handling}
\defun{make-instream}{make-instream}
\calls{make-instream}{makeInputFilename}
\begin{chunk}{defun make-instream}
(defun make-instream (filespec &optional (recnum 0))
 (declare (ignore recnum))
   (cond ((numberp filespec) (make-synonym-stream '*terminal-io*))
         ((null filespec) (error "not handled yet"))
         (t (open (makeInputFilename filespec)
                  :direction :input :if-does-not-exist nil))))

\end{chunk}

\defun{make-outstream}{make-outstream}
\calls{make-outstream}{make-filename}
\begin{chunk}{defun make-outstream}
(defun make-outstream (filespec &optional (width nil) (recnum 0))
 (declare (ignore width) (ignore recnum))
   (cond ((numberp filespec) (make-synonym-stream '*terminal-io*))
         ((null filespec) (error "not handled yet"))
         (t (open (make-filename filespec) :direction :output))))

\end{chunk}

\defun{make-appendstream}{make-appendstream}
\calls{make-appendstream}{make-filename}
\begin{chunk}{defun make-appendstream}
(defun make-appendstream (filespec &optional (width nil) (recnum 0))
 "fortran support"
 (declare (ignore width) (ignore recnum))
 (cond 
  ((numberp filespec) (make-synonym-stream '*terminal-io*))
  ((null filespec) (error "make-appendstream: not handled yet"))
  ('else (open (make-filename filespec) :direction :output
          :if-exists :append :if-does-not-exist :create))))

\end{chunk}

\defun{defiostream}{defiostream}
\begin{chunk}{defun defiostream}
(defun defiostream (stream-alist buffer-size char-position)
 (declare (ignore buffer-size))
   (let ((mode (or (cdr (assoc 'mode stream-alist)) 'input))
         (filename (cdr (assoc 'file stream-alist)))
         (dev (cdr (assoc 'device stream-alist))))
      (if (eq dev 'console) (make-synonym-stream '*terminal-io*)
       (let ((strm (case mode
                          ((output o) (open (make-filename filename)
                                           :direction :output))
                          ((input i) (open (makeInputFilename filename)
                                           :direction :input)))))
         (if (and (numberp char-position) (> char-position 0))
           (file-position strm char-position))
           strm))))

\end{chunk}

\defun{shut}{shut}
\seebook{shut}{is-console}{9}
\begin{chunk}{defun shut}
(defun shut (st)
  (if (is-console st) 
   st
   (if (streamp st) (close st) -1)))

\end{chunk}

\defun{eofp}{eofp}
\begin{chunk}{defun eofp}
(defun eofp (stream) (null (peek-char nil stream nil nil)))

\end{chunk}

\defun{makeStream}{makeStream}
\calls{makeStream}{make-appendstream}
\calls{makeStream}{make-outstream}
\begin{chunk}{defun makeStream}
(defun |makeStream| (append filename i j)
 (if append 
  (make-appendstream filename i j)
  (make-outstream filename i j)))

\end{chunk}

\defun{makeInputFilename}{Construct a new input file name}
\begin{chunk}{defun makeInputFilename}
(defun makeInputFilename (filearg &optional (filetype nil))
 (let*
  ((filename  (make-filename filearg filetype))
   (dirname (pathname-directory filename))
   (ft (pathname-type filename))
   (dirs (getDirectoryList ft))
   (newfn nil))   
  (if (or (null dirname) (eqcar dirname :relative))
   (dolist (dir dirs (probeName filename))
    (when (probe-file (setq newfn (concatenate 'string dir filename)))
     (return newfn)))
   (probeName filename))))

\end{chunk}

\defun{getDirectoryList}{getDirectoryList}
\usesdollar{getDirectoryList}{current-directory}
\usesdollar{getDirectoryList}{UserLevel}
\usesdollar{getDirectoryList}{library-directory-list}
\usesdollar{getDirectoryList}{directory-list}
\begin{chunk}{defun getDirectoryList}
(defun getDirectoryList (ft &aux (cd (namestring $current-directory)))
 (declare (special $current-directory |$UserLevel| $library-directory-list
                   $directory-list))
 (if (member ft '("nrlib" "daase" "exposed") :test #'string=)
   (if (eq |$UserLevel| '|development|)
    (cons cd $library-directory-list)
    $library-directory-list)
   (adjoin cd 
    (adjoin (namestring (user-homedir-pathname)) $directory-list 
      :test #'string=) 
    :test #'string=)))


\end{chunk}

\defun{probeName}{probeName}
Sometimes we are given a file and sometimes we are given the name of
an Axiom KAF (Keyed-Access File). KAF files are actually directories
with a single file called ``index.kaf''. We check for the latter case
and return the directory name as the filename, per Axiom convention.
\begin{chunk}{defun probeName}
(defun probeName (file)
 (when (or (probe-file file) 
           (probe-file (concatenate 'string (namestring file) "/index.kaf")))
 (namestring file)))

\end{chunk}

\defun{makeFullNamestring}{makeFullNamestring}
\begin{chunk}{defun makeFullNamestring}
(defun makeFullNamestring (filearg &optional (filetype nil))
  (namestring (merge-pathnames (make-filename filearg filetype))))

\end{chunk}

\defun{replaceFile}{Replace a file by erase and rename}
\calls{makeStream}{makeFullNamestring}
\begin{chunk}{defun replaceFile}
(defun replaceFile (filespec1 filespec2)
 ($erase (setq filespec1 (makeFullNamestring filespec1)))
 (rename-file (makeFullNamestring filespec2) filespec1))

\end{chunk}

\chapter{The Spad Server Mechanism}
\defun{openserver}{openserver}
This is a cover function for the C code used for communication interface.
\begin{chunk}{defun openserver}
(defun openserver (name)
  (open_server name))

\end{chunk}

\chapter{Axiom Build-time Functions}
\defun{spad-save}{spad-save}
The {\bf spad-save} function is just a cover function for more
lisp system specific save functions. There is no standard name
for saving a lisp image so we make one and conditionalize it
at compile time.

This function is passed the name of an image that will be saved.
The saved image contains all of the loaded functions.

This is used in the src/interp/Makefile.pamphlet in three places:
\begin{itemize}
\item creating depsys, an image for compiling axiom.

Some of the Common Lisp code we compile uses macros which
are assumed to be available at compile time. The {\bf DEPSYS}
image is created to contain the compile time environment
and saved. We pipe compile commands into this environment
to compile from Common Lisp to machine dependent code.
\begin{verbatim}
DEPSYS=${OBJ}/${SYS}/bin/depsys
\end{verbatim}

\item creating savesys, an image for running axiom.

Once we've compile all of the Common Lisp files we fire up
a clean lisp image called {\bf LOADSYS}, load all of the
final executable code and save it out as {\bf SAVESYS}.
The {\bf SAVESYS} image is copied to the \verb|${MNT}/${SYS}/bin|
subdirectory and becomes the axiom executable image.
\begin{verbatim}
LOADSYS= ${OBJ}/${SYS}/bin/lisp
SAVESYS= ${OBJ}/${SYS}/bin/interpsys
AXIOMSYS= ${MNT}/${SYS}/bin/AXIOMsys
\end{verbatim}


\item creating debugsys, an image with all interpreted functions loaded.

Occasionally we need to really get into the system internals.
The best way to do this is to run almost all of the lisp code
interpreted rather than compiled (note that cfuns.lisp and sockio.lisp
still need to be loaded in compiled form as they depend on the 
loader to link with lisp internals). This image is nothing more
than a load of the file src/interp/debugsys.lisp.pamphlet. If
you need to make test modifications you can add code to that
file and it will show up here.
\begin{verbatim}
DEBUGSYS=${OBJ}/${SYS}/bin/debugsys
\end{verbatim}
\end{itemize}
\calls{spad-save}{save-system}
\usesdollar{spad-save}{SpadServer}
\usesdollar{spad-save}{openServerIfTrue}
\begin{chunk}{defun spad-save}
(defun user::spad-save (save-file)
  (declare (special |$SpadServer| $openServerIfTrue))
  (setq |$SpadServer| nil)
  (setq $openServerIfTrue t)
#+:AKCL
  (system::save-system save-file)
#+:allegro
  (if (fboundp 'boot::restart)
   (excl::dumplisp :name save-file :restart-function #'boot::restart)
   (excl::dumplisp :name save-file))
#+Lucid
  (if (fboundp 'boot::restart)
   (sys::disksave save-file :restart-function #'boot::restart)
   (sys::disksave save-file))
#+:CCL
  (preserve)
)

\end{chunk}

\chapter{Exposure Groups}
Exposure groups are a way of controlling the namespace available
to the user. Certain algebra files are only useful for internal
purposes but they contain functions have common names (like 
``map''. In order to separate the user visible  functions
from the internal functions the algebra files are collected into
``exposure groups''. These large groups are grouped into sets in
the variable \verb|$globalExposureGroupAlist|.

Exposure group information is kept in the local frame. For more
information ``The Frame Mechanism'' \ref{TheFrameMechanism} on
page~\pageref{TheFrameMechanism}.

\chapter{Databases}
\section{Database structure}
In order to understand this program you need to understand some details
of the structure of the databases it reads. Axiom has 5 databases,
the interp.daase, operation.daase, category.daase, and
browse.daase. 

\subsection{kaf File Format}
This documentation refers to kaf files which are random access files.
nrlib files are kaf files (look for nrlib/index.kaf)
The format of a random access file is
\begin{verbatim}
byte-offset-of-key-table
first-entry
second-entry
...
last-entry
((key1 . first-entry-byte-address)
 (key2 . second-entry-byte-address)
 ...
 (keyN . last-entry-byte-address))
\end{verbatim}
The key table is a standard lisp alist.

To open a database you fetch the first number, seek to that location,
and (read) which returns the key-data alist. To look up data you
index into the key-data alist, find the ith-entry-byte-address,
seek to that address, and (read).

For instance, see src/share/algebra/users.daase/index.kaf

One existing optimization is that if the data is a simple thing like a
symbol then the nth-entry-byte-address is replaced by immediate data.

Another existing one is a compression algorithm applied to the
data so that the very long names don't take up so much space.
We could probably remove the compression algorithm as 64k is no
longer considered 'huge'. The database-abbreviation routine
handles this on read and write-compress handles this on write.

Indeed, a faster optimization is to simply read the whole database
into the image before it is saved. The system would be easier to
understand and the interpreter would be faster.

The fastest optimization is to fix the time stamp mechanism
which is currently broken. Making this work requires a small
bit of coordination at 'make' time which I forgot to implement.

\subsection{Database Files}

Database files are very similar to kaf files except that there
is an optimization (currently broken) which makes the first
item a pair of two numbers. The first number in the pair is
the offset of the key-value table, the second is a time stamp.
If the time stamp in the database matches the time stamp in
the image the database is not needed (since the internal hash
tables already contain all of the information). When the database
is built the time stamp is saved in both the gcl image and the
database.

Regarding the 'ancestors field in a category: At database build
time there exists a *ancestors-hash* hash table that gets filled
with CATEGORY (not domain) ancestor information. This later provides
the information that goes into interp.daase This *ancestors-hash*
does not exist at normal runtime (it can be made by a call to
genCategoryTable). Note that the ancestor information in
*ancestors-hash* (and hence interp.daase) involves \verb|#1|, \verb|#2|, etc
instead of R, Coef, etc. The latter thingies appear in all
.nrlib/index.kaf files. So we need to be careful when we )lib
categories and update the ancestor info.

This file contains the code to build, open and access the .daase
files. This file contains the code to )library nrlibs and asy files

There is a major issue about the data that resides in these
databases.  the fundamental problem is that the system requires more
information to build the databases than it needs to run the
interpreter.  in particular, modemap.daase is constructed using
properties like "modemaps" but the interpreter will never ask for
this information.

So, the design is as follows:
\begin{itemize}
\item the modemap.daase needs to be built. this is done by doing
a )library on ALL of the nrlib files that are going into the system.
this will bring in "modemap" information and add it to the
*modemaps-hash* hashtable.
\item database build proceeds, accessing the "modemap" property
from the hashtables. once this completes this information is never
used again.
\item the interp.daase database is built. this contains only the
information necessary to run the interpreter. note that during the
running of the interpreter users can extend the system by do a
)library on a new nrlib file. this will cause fields such as "modemap"
to be read and hashed.
\end{itemize}

Each constructor (e.g. LIST) had one library directory (e.g. LIST.nrlib). 
This directory contained a random access file called the index.kaf file. 
These files contain runtime information such as the operationAlist and
the ConstructorModemap. At system build time we merge all of these 
.nrlib/index.kaf files into one database, INTERP.daase.  Requests to 
get information from this database are cached so that multiple 
references do not cause additional disk i/o.

This database is left open at all times as it is used frequently by
the interpreter. one minor complication is that newly compiled files
need to override information that exists in this database.

The design calls for constructing a random read (kaf format) file
that is accessed by functions that cache their results. when the
database is opened the list of constructor-index pairs is hashed
by constructor name. a request for information about a constructor
causes the information to replace the index in the hash table. since
the index is a number and the data is a non-numeric sexpr there is
no source of confusion about when the data needs to be read.

The format of this new database is as follows:
\begin{verbatim}
 first entry:
   an integer giving the byte offset to the constructor alist
   at the bottom of the file
 second and subsequent entries (one per constructor)
   (operationAlist)
   (constructorModemap)
   ....
 last entry: (pointed at by the first entry)
   an alist of (constructor . index) e.g.
      ( (PI offset-of-operationAlist offset-of-constructorModemap)
      (NNI offset-of-operationAlist offset-of-constructorModemap)
       ....)
  This list is read at open time and hashed by the car of each item.
\end{verbatim}

The system has been changed to use the property list of the
symbols rather than hash tables. since we already hashed once
to get the symbol we need only an offset to get the property
list. this also has the advantage that eq hash tables no longer
need to be moved during garbage collection.

There are 3 potential speedups that could be done. 
\begin{itemize}
\item the best would be to use the value cell of the symbol rather than the
property list but i'm unable to determine all uses of the
value cell at the present time.
\item a second speedup is to guarantee that the property list is
a single item, namely the database structure. this removes
an assoc but leaves one open to breaking the system if someone
adds something to the property list. this was not done because
of the danger mentioned.
\item a third speedup is to make the getdatabase call go away, either
by making it a macro or eliding it entirely. this was not done
because we want to keep the flexibility of changing the database forms.
\end{itemize}

The new design does not use hash tables. the database structure
contains an entry for each item that used to be in a hash table.
initially the structure contains file-position pointers and
these are replaced by real data when they are first looked up.
the database structure is kept on the property list of the
constructor, thus, (get '|DenavitHartenbergMatrix| 'database)
will return the database structure object.

Each operation has a property on its symbol name called 'operation
which is a list of all of the signatures of operations with that name.

\defstruct{database}
\begin{chunk}{initvars}
(defstruct database
 abbreviation               ; interp.
 ancestors                  ; interp.
 constructor                ; interp.
 constructorcategory        ; interp.
 constructorkind            ; interp.
 constructormodemap         ; interp.
 cosig                      ; interp.
 defaultdomain              ; interp.
 modemaps                   ; interp.
 niladic                    ; interp.
 object                     ; interp.
 operationalist             ; interp.
 documentation              ; browse.
 constructorform            ; browse.
 attributes                 ; browse.
 predicates                 ; browse.
 sourcefile                 ; browse.
 parents                    ; browse.
 users                      ; browse.
 dependents                 ; browse.
 spare                      ; superstition
 ) ; database structure

\end{chunk}

\defvar{*defaultdomain-list*}
There are only a small number of domains that have default domains.
rather than keep this slot in every domain we maintain a list here.
\begin{chunk}{initvars}
(defvar *defaultdomain-list* '(
  (|MultisetAggregate| |Multiset|)
  (|FunctionSpace| |Expression|)
  (|AlgebraicallyClosedFunctionSpace| |Expression|)
  (|ThreeSpaceCategory| |ThreeSpace|)
  (|DequeueAggregate| |Dequeue|)
  (|ComplexCategory| |Complex|)
  (|LazyStreamAggregate| |Stream|)
  (|AssociationListAggregate| |AssociationList|)
  (|QuaternionCategory| |Quaternion|)
  (|PriorityQueueAggregate| |Heap|)
  (|PointCategory| |Point|)
  (|PlottableSpaceCurveCategory| |Plot3D|)
  (|PermutationCategory| |Permutation|)
  (|StringCategory| |String|)
  (|FileNameCategory| |FileName|)
  (|OctonionCategory| |Octonion|)))

\end{chunk}

\defvar{*operation-hash*}
\begin{chunk}{initvars}
(defvar *operation-hash* nil "given an operation name, what are its modemaps?")

\end{chunk}

\defvar{*hasCategory-hash*}
This hash table is used to answer the question``does domain x
have category y?''. this is answered by constructing a pair of
(x . y) and doing an equal hash into this table.
\begin{chunk}{initvars}
(defvar *hasCategory-hash* nil "answers x has y category questions")

\end{chunk}

\defvar{*miss*}
This variable is used for debugging. If a hash table lookup fails
and this variable is non-nil then a message is printed.
\begin{chunk}{initvars}
(defvar *miss* nil "print out cache misses on getdatabase calls")

\end{chunk}

Note that constructorcategory information need only be kept for
items of type category. this will be fixed in the next iteration
when the need for the various caches are reviewed

Note that the *modemaps-hash* information does not need to be kept
for system files. these are precomputed and kept in modemap.daase
however, for user-defined files these are needed.
Currently these are added to the database for 2 reasons;
there is a still-unresolved issue of user database extensions and
this information is used during database build time

\subsection{Database streams}
This are the streams for the databases. They are always open.
There is an optimization for speeding up system startup. If the
database is opened and the ..-stream-stamp* variable matches the
position information in the database then the database is NOT
read in and is assumed to match the in-core version

\defvar{*interp-stream*}
\begin{chunk}{initvars}
(defvar *interp-stream* nil "an open stream to the interpreter database")

\end{chunk}

\defvar{*interp-stream-stamp*}
\begin{chunk}{initvars}
(defvar *interp-stream-stamp* 0 "*interp-stream* (position . time)")

\end{chunk}

\defvar{*operation-stream*}
This is indexed by operation, not constructor
\begin{chunk}{initvars}
(defvar *operation-stream* nil "the stream to operation.daase")

\end{chunk}

\defvar{*operation-stream-stamp*}
\begin{chunk}{initvars}
(defvar *operation-stream-stamp* 0 "*operation-stream* (position . time)")

\end{chunk}

\defvar{*browse-stream*}
\begin{chunk}{initvars}
(defvar *browse-stream* nil "an open stream to the browser database")

\end{chunk}

\defvar{*browse-stream-stamp*}
\begin{chunk}{initvars}
(defvar *browse-stream-stamp* 0 "*browse-stream* (position . time)")

\end{chunk}

\defvar{*category-stream*}
This is indexed by (domain . category)
\begin{chunk}{initvars}
(defvar *category-stream* nil "an open stream to the category table")

\end{chunk}

\defvar{*category-stream-stamp*}
\begin{chunk}{initvars}
(defvar *category-stream-stamp* 0 "*category-stream* (position . time)")

\end{chunk}

\defvar{*allconstructors*}
\begin{chunk}{initvars}
(defvar *allconstructors* nil "a list of all the constructors in the system")

\end{chunk}

\defvar{*allOperations*}
\begin{chunk}{initvars}
(defvar *allOperations* nil "a list of all the operations in the system")

\end{chunk}

\defun{resethashtables}{Reset all hash tables before saving system}
\calls{resethashtables}{interpopen}
\calls{resethashtables}{operationopen}
\calls{resethashtables}{browseopen}
\calls{resethashtables}{categoryopen}
\calls{resethashtables}{initial-getdatabase}
\uses{resethashtables}{*sourcefiles*}
\uses{resethashtables}{*interp-stream*}
\uses{resethashtables}{*operation-stream*}
\uses{resethashtables}{*category-stream*}
\uses{resethashtables}{*browse-stream*}
\uses{resethashtables}{*category-stream-stamp*}
\uses{resethashtables}{*operation-stream-stamp*}
\uses{resethashtables}{*interp-stream-stamp*}
\uses{resethashtables}{*allconstructors*}
\uses{resethashtables}{*operation-hash*}
\uses{resethashtables}{*hascategory-hash*}
\begin{chunk}{defun resethashtables}
(defun resethashtables ()
 "set all -hash* to clean values. used to clean up core before saving system"
 (declare (special *sourcefiles* *interp-stream* *operation-stream*
                    *category-stream* *browse-stream* *category-stream-stamp*
                    *operation-stream-stamp* *interp-stream-stamp*
                    *allconstructors* *operation-hash* *hascategory-hash*))
 (setq *hascategory-hash* (make-hash-table :test #'equal))
 (setq *operation-hash* (make-hash-table))
 (setq *allconstructors* nil)
 (setq *sourcefiles* nil)
 (setq *interp-stream-stamp* '(0 . 0))
 (interpopen)
 (setq *operation-stream-stamp* '(0 . 0))
 (operationopen)
 (setq *browse-stream-stamp* '(0 . 0))
 (browseopen)
 (setq *category-stream-stamp* '(0 . 0))
 (categoryopen) ;note: this depends on constructorform in browse.daase
 (initial-getdatabase)
 (close *interp-stream*)
 (close *operation-stream*)
 (close *category-stream*)
 (close *browse-stream*)
 (gbc t))

\end{chunk}

\defun{initial-getdatabase}{Preload algebra into saved system}
\calls{initial-getdatabase}{getdatabase}
\calls{initial-getdatabase}{getenviron}
\begin{chunk}{defun initial-getdatabase}
(defun initial-getdatabase ()
 "fetch data we want in the saved system"
 (let (hascategory constructormodemapAndoperationalist operation constr)
 (format t "Initial getdatabase~%")
 (setq hascategory '(
  (|Equation| . |Ring|)
  (|Expression| . |CoercibleTo|) (|Expression| . |CommutativeRing|)
  (|Expression| . |IntegralDomain|) (|Expression| . |Ring|)
  (|Float| . |RetractableTo|)
  (|Fraction| . |Algebra|) (|Fraction| . |CoercibleTo|)
  (|Fraction| . |OrderedSet|) (|Fraction| . |RetractableTo|)
  (|Integer| . |Algebra|) (|Integer| . |CoercibleTo|)
  (|Integer| . |ConvertibleTo|) (|Integer| . |LinearlyExplicitRingOver|)
  (|Integer| . |RetractableTo|)
  (|List| . |CoercibleTo|) (|List| . |FiniteLinearAggregate|)
  (|List| . |OrderedSet|)
  (|Polynomial| . |CoercibleTo|) (|Polynomial| . |CommutativeRing|)
  (|Polynomial| . |ConvertibleTo|) (|Polynomial| . |OrderedSet|)
  (|Polynomial| . |RetractableTo|)
  (|Symbol| . |CoercibleTo|) (|Symbol| . |ConvertibleTo|)
  (|Variable| . |CoercibleTo|)))
 (dolist (pair hascategory) (getdatabase pair 'hascategory))
 (setq constructormodemapAndoperationalist '(
  |BasicOperator|  |Boolean|
  |CardinalNumber| |Color|  |Complex|
  |Database|
  |Equation| |EquationFunctions2| |Expression|
  |Float| |Fraction| |FractionFunctions2|
  |Integer| |IntegralDomain|
  |Kernel|
  |List|
  |Matrix| |MappingPackage1|
  |Operator| |OutputForm|
  |NonNegativeInteger|
  |ParametricPlaneCurve| |ParametricSpaceCurve| |Point| |Polynomial|
  |PolynomialFunctions2| |PositiveInteger|
  |Ring|
  |SetCategory| |SegmentBinding| |SegmentBindingFunctions2| |DoubleFloat|
  |SparseMultivariatePolynomial| |SparseUnivariatePolynomial| |Segment|
  |String| |Symbol|
  |UniversalSegment|
  |Variable|  |Vector|))
 (dolist (con constructormodemapAndoperationalist)
  (getdatabase con 'constructormodemap)
  (getdatabase con 'operationalist))
 (setq operation '(
  |+| |-| |*| |/| |**| |coerce| |convert| |elt| |equation|
  |float| |sin| |cos| |map| |SEGMENT|))
 (dolist (op operation) (getdatabase op 'operation))
 (setq constr '( ;these are sorted least-to-most freq. delete early ones first
  |Factored| |SparseUnivariatePolynomialFunctions2| |TableAggregate&|
  |RetractableTo&| |RecursiveAggregate&| |UserDefinedPartialOrdering|
  |None| |UnivariatePolynomialCategoryFunctions2| |IntegerPrimesPackage|
  |SetCategory&| |IndexedExponents| |QuotientFieldCategory&| |Polynomial|
  |EltableAggregate&| |PartialDifferentialRing&| |Set|
  |UnivariatePolynomialCategory&| |FlexibleArray|
  |SparseMultivariatePolynomial| |PolynomialCategory&|
  |DifferentialExtension&| |IndexedFlexibleArray| |AbelianMonoidRing&|
  |FiniteAbelianMonoidRing&| |DivisionRing&| |FullyLinearlyExplicitRingOver&|
  |IndexedVector| |IndexedOneDimensionalArray| |LocalAlgebra| |Localize|
  |Boolean| |Field&| |Vector| |IndexedDirectProductObject| |Aggregate&|
  |PolynomialRing| |FreeModule| |IndexedDirectProductAbelianGroup|
  |IndexedDirectProductAbelianMonoid| |SingletonAsOrderedSet|
  |SparseUnivariatePolynomial| |Fraction| |Collection&| |HomogeneousAggregate&|
  |RepeatedSquaring| |IntegerNumberSystem&| |AbelianSemiGroup&|
  |AssociationList| |OrderedRing&| |SemiGroup&| |Symbol|
  |UniqueFactorizationDomain&| |EuclideanDomain&| |IndexedAggregate&|
  |GcdDomain&| |IntegralDomain&| |DifferentialRing&| |Monoid&| |Reference|
  |UnaryRecursiveAggregate&| |OrderedSet&| |AbelianGroup&| |Algebra&|
  |Module&| |Ring&| |StringAggregate&| |AbelianMonoid&|
  |ExtensibleLinearAggregate&| |PositiveInteger| |StreamAggregate&|
  |IndexedString| |IndexedList| |ListAggregate&| |LinearAggregate&|
  |Character| |String| |NonNegativeInteger| |SingleInteger|
  |OneDimensionalArrayAggregate&| |FiniteLinearAggregate&| |PrimitiveArray|
  |Integer| |List| |OutputForm|))
 (dolist (con constr)
  (let ((c (concatenate 'string
             (getenviron "AXIOM") "/algebra/"
             (string (getdatabase con 'abbreviation)) ".o")))
    (format t "   preloading ~a.." c)
    (if (probe-file c)
     (progn
      (put con 'loaded c)
      (load c)
      (format t "loaded.~%"))
     (format t "skipped.~%"))))
 (format t "~%")))

\end{chunk}

\defun{interpopen}{Open the interp database}
Format of an entry in interp.daase:
\begin{verbatim}
  (constructor-name
    operationalist
    constructormodemap
    modemaps            -- this should not be needed. eliminate it.
    object              -- the name of the object file to load for this con.
    constructorcategory -- note that this info is the cadar of the
          constructormodemap for domains and packages so it is stored
          as NIL for them. it is valid for categories.
    niladic             -- t or nil directly
    unused
    cosig                -- kept directly
    constructorkind      -- kept directly
    defaultdomain        -- a short list, for %i
    ancestors            -- used to compute new category updates
  )
\end{verbatim}
\calls{interpopen}{make-database}
\calls{interpopen}{DaaseName}
\usesdollar{interpopen}{spadroot}
\uses{interpopen}{*allconstructors*}
\uses{interpopen}{*interp-stream*}
\uses{interpopen}{*interp-stream-stamp*}
\begin{chunk}{defun interpopen}
(defun interpopen ()
 "open the interpreter database and hash the keys"
 (declare (special $spadroot *allconstructors* *interp-stream*
                   *interp-stream-stamp*))
 (let (constructors pos stamp dbstruct)
  (setq *interp-stream* (open (DaaseName "interp.daase" nil)))
  (setq stamp (read *interp-stream*))
  (unless (equal stamp *interp-stream-stamp*)
   (format t "   Re-reading interp.daase")
   (setq *interp-stream-stamp* stamp)
   (setq pos (car stamp))
   (file-position *interp-stream* pos)
   (setq constructors (read *interp-stream*))
   (dolist (item constructors)
    (setq *allconstructors* (adjoin (first item) *allconstructors*))
    (setq dbstruct (make-database))
    (setf (get (car item) 'database) dbstruct)
    (setf (database-operationalist dbstruct) (second item))
    (setf (database-constructormodemap dbstruct) (third item))
    (setf (database-modemaps dbstruct) (fourth item))
    (setf (database-object dbstruct) (fifth item))
    (setf (database-constructorcategory dbstruct) (sixth item))
    (setf (database-niladic dbstruct) (seventh item))
    (setf (database-abbreviation dbstruct) (eighth item))
    (setf (get (eighth item) 'abbreviationfor) (first item)) ;invert
    (setf (database-cosig dbstruct) (ninth item))
    (setf (database-constructorkind dbstruct) (tenth item))
    (setf (database-ancestors dbstruct) (nth 11 item))))
  (format t "~&")))

\end{chunk}

This is an initialization function for the constructor database
it sets up 2 hash tables, opens the database and hashes the index values.

There is a slight asymmetry in this code. The sourcefile information for
system files is only the filename and extension. For user files it
contains the full pathname. when the database is first opened the
sourcefile slot contains system names. The lookup function
has to prefix the ``\$spadroot'' information if the directory-namestring is
null (we don't know the real root at database build time).

An object-hash table is set up to look up nrlib and ao information.
this slot is empty until a user does a )library call. We remember
the location of the nrlib or ao file for the users local library
at that time. A {\tt NIL} result from this probe means that the
library is in the system-specified place. When we get into multiple
library locations this will also contain system files.

\defun{browseopen}{Open the browse database}
Format of an entry in browse.daase:
\begin{verbatim}
 ( constructorname
     sourcefile
     constructorform
     documentation
     attributes
     predicates
 )
\end{verbatim}
\usesdollar{browseopen}{spadroot}
\uses{browseopen}{*allconstructors*}
\uses{browseopen}{*browse-stream*}
\uses{browseopen}{*browse-stream-stamp*}
\begin{chunk}{defun browseopen}
(defun browseopen ()
 "open the constructor database and hash the keys"
 (declare (special $spadroot *allconstructors* *browse-stream*
                   *browse-stream-stamp*))
 (let (constructors pos stamp dbstruct)
  (setq *browse-stream* (open (DaaseName "browse.daase" nil)))
  (setq stamp (read *browse-stream*))
  (unless (equal stamp *browse-stream-stamp*)
   (format t "   Re-reading browse.daase")
   (setq *browse-stream-stamp* stamp)
   (setq pos (car stamp))
   (file-position *browse-stream* pos)
   (setq constructors (read *browse-stream*))
   (dolist (item constructors)
    (unless (setq dbstruct (get (car item) 'database))
     (format t "browseopen:~%")
     (format t "the browse database contains a contructor ~a~%" item)
     (format t "that is not in the interp.daase file. we cannot~%")
     (format t "get the database structure for this constructor and~%")
     (warn "will create a new one~%")
     (setf (get (car item) 'database) (setq dbstruct (make-database)))
     (setq *allconstructors* (adjoin item *allconstructors*)))
    (setf (database-sourcefile dbstruct) (second item))
    (setf (database-constructorform dbstruct) (third item))
    (setf (database-documentation dbstruct) (fourth item))
    (setf (database-attributes dbstruct) (fifth item))
    (setf (database-predicates dbstruct) (sixth item))
    (setf (database-parents dbstruct) (seventh item))))
  (format t "~&")))

\end{chunk}

\defun{categoryopen}{Open the category database}
\usesdollar{categoryopen}{spadroot}
\uses{categoryopen}{*hasCategory-hash*}
\uses{categoryopen}{*category-stream*}
\uses{categoryopen}{*category-stream-stamp*}
\begin{chunk}{defun categoryopen}
(defun categoryopen ()
 "open category.daase and hash the keys"
 (declare (special $spadroot *hasCategory-hash* *category-stream*
                   *category-stream-stamp*))
 (let (pos keys stamp)
  (setq *category-stream* (open (DaaseName "category.daase" nil)))
  (setq stamp (read *category-stream*))
  (unless (equal stamp *category-stream-stamp*)
   (format t "   Re-reading category.daase")
   (setq *category-stream-stamp* stamp)
   (setq pos (car stamp))
   (file-position *category-stream* pos)
   (setq keys (read *category-stream*))
   (setq *hasCategory-hash* (make-hash-table :test #'equal))
   (dolist (item keys)
    (setf (gethash (first item) *hasCategory-hash*) (second item))))
  (format t "~&")))

\end{chunk}

\defun{operationopen}{Open the operations database}
\usesdollar{operationopen}{spadroot}
\uses{operationopen}{*operation-hash*}
\uses{operationopen}{*operation-stream*}
\uses{operationopen}{*operation-stream-stamp*}
\begin{chunk}{defun operationopen}
(defun operationopen ()
 "read operation database and hash the keys"
 (declare (special $spadroot *operation-hash* *operation-stream*
                   *operation-stream-stamp*))
 (let (operations pos stamp)
  (setq *operation-stream* (open (DaaseName "operation.daase" nil)))
  (setq stamp (read *operation-stream*))
  (unless (equal stamp *operation-stream-stamp*)
   (format t "   Re-reading operation.daase")
   (setq *operation-stream-stamp* stamp)
   (setq pos (car stamp))
   (file-position *operation-stream* pos)
   (setq operations (read *operation-stream*))
   (dolist (item operations)
    (setf (gethash (car item) *operation-hash*) (cdr item))))
  (format t "~&")))

\end{chunk}

\defun{addoperations}{Add operations from newly compiled code}
\calls{addoperations}{getdatabase}
\uses{addoperations}{*operation-hash*}
\begin{chunk}{defun addoperations}
(defun addoperations (constructor oldmaps)
 "add ops from a )library domain to *operation-hash*"
 (declare (special *operation-hash*))
 (dolist (map oldmaps) ; out with the old
  (let (oldop op)
   (setq op (car map))
   (setq oldop (getdatabase op 'operation))
   (setq oldop (lisp::delete (cdr map) oldop :test #'equal))
   (setf (gethash op *operation-hash*) oldop)))
 (dolist (map (getdatabase constructor 'modemaps)) ; in with the new
  (let (op newmap)
   (setq op (car map))
   (setq newmap (getdatabase op 'operation))
   (setf (gethash op *operation-hash*) (cons (cdr map) newmap)))))

\end{chunk}

\defun{showdatabase}{Show all database attributes of a constructor}
\calls{showdatabase}{getdatabase}
\begin{chunk}{defun showdatabase}
(defun showdatabase (constructor)
 (format t "~&~a: ~a~%" 'constructorkind
  (getdatabase constructor 'constructorkind))
 (format t "~&~a: ~a~%" 'cosig
  (getdatabase constructor 'cosig))
 (format t "~&~a: ~a~%" 'operation
  (getdatabase constructor 'operation))
 (format t "~&~a: ~%" 'constructormodemap)
  (pprint (getdatabase constructor 'constructormodemap))
 (format t "~&~a: ~%" 'constructorcategory)
  (pprint (getdatabase constructor 'constructorcategory))
 (format t "~&~a: ~%" 'operationalist)
  (pprint (getdatabase constructor 'operationalist))
 (format t "~&~a: ~%" 'modemaps)
  (pprint (getdatabase constructor 'modemaps))
 (format t "~&~a: ~a~%" 'hascategory
  (getdatabase constructor 'hascategory))
 (format t "~&~a: ~a~%" 'object
  (getdatabase constructor 'object))
 (format t "~&~a: ~a~%" 'niladic
  (getdatabase constructor 'niladic))
 (format t "~&~a: ~a~%" 'abbreviation
  (getdatabase constructor 'abbreviation))
 (format t "~&~a: ~a~%" 'constructor?
  (getdatabase constructor 'constructor?))
 (format t "~&~a: ~a~%" 'constructor
  (getdatabase constructor 'constructor))
 (format t "~&~a: ~a~%" 'defaultdomain
  (getdatabase constructor 'defaultdomain))
 (format t "~&~a: ~a~%" 'ancestors
  (getdatabase constructor 'ancestors))
 (format t "~&~a: ~a~%" 'sourcefile
  (getdatabase constructor 'sourcefile))
 (format t "~&~a: ~a~%" 'constructorform
  (getdatabase constructor 'constructorform))
 (format t "~&~a: ~a~%" 'constructorargs
  (getdatabase constructor 'constructorargs))
 (format t "~&~a: ~a~%" 'attributes
  (getdatabase constructor 'attributes))
 (format t "~&~a: ~%" 'predicates)
  (pprint (getdatabase constructor 'predicates))
 (format t "~&~a: ~a~%" 'documentation
  (getdatabase constructor 'documentation))
 (format t "~&~a: ~a~%" 'parents
  (getdatabase constructor 'parents)))

\end{chunk}

\defun{setdatabase}{Set a value for a constructor key in the database}
\calls{setdatabase}{make-database}
\begin{chunk}{defun setdatabase}
(defun setdatabase (constructor key value)
 (let (struct)
  (when (symbolp constructor)
   (unless (setq struct (get constructor 'database))
    (setq struct (make-database))
    (setf (get constructor 'database) struct))
   (case key
    (abbreviation
     (setf (database-abbreviation struct) value)
     (when (symbolp value)
      (setf (get value 'abbreviationfor) constructor)))
    (constructorkind
     (setf (database-constructorkind struct) value))))))

\end{chunk}

\defun{deldatabase}{Delete a value for a constructor key in the database}
\begin{chunk}{defun deldatabase}
(defun deldatabase (constructor key)
  (when (symbolp constructor)
   (case key
    (abbreviation
     (setf (get constructor 'abbreviationfor) nil)))))

\end{chunk}

\defun{getdatabase}{Get constructor information for a database key}
\calls{getdatabase}{warn}
\usesdollar{getdatabase}{spadroot}
\uses{getdatabase}{*miss*}
\uses{getdatabase}{*hascategory-hash*}
\uses{getdatabase}{*operation-hash*}
\uses{getdatabase}{*browse-stream*}
\uses{getdatabase}{*defaultdomain-list*}
\uses{getdatabase}{*interp-stream*}
\uses{getdatabase}{*category-stream*}
\uses{getdatabase}{*hasCategory-hash*}
\uses{getdatabase}{*operation-stream*}
\begin{chunk}{defun getdatabase}
(defun getdatabase (constructor key)
 (declare (special $spadroot) (special *miss*))
 (when (eq *miss* t) (format t "getdatabase call: ~20a ~a~%" constructor key))
 (let (data table stream ignore struct)
  (declare (ignore ignore) 
           (special *hascategory-hash* *operation-hash* 
                    *browse-stream* *defaultdomain-list* *interp-stream*
                    *category-stream* *hasCategory-hash* *operation-stream*))
  (when (or (symbolp constructor)
          (and (eq key 'hascategory) (consp constructor)))
  (case key
; note that abbreviation, constructorkind and cosig are heavy hitters
; thus they occur first in the list of things to check
   (abbreviation
    (setq stream *interp-stream*)
    (when (setq struct (get constructor 'database))
      (setq data (database-abbreviation struct))))
   (constructorkind
    (setq stream *interp-stream*)
    (when (setq struct (get constructor 'database))
     (setq data (database-constructorkind struct))))
   (cosig
    (setq stream *interp-stream*)
    (when (setq struct (get constructor 'database))
     (setq data (database-cosig struct))))
   (operation
    (setq stream *operation-stream*)
    (setq data (gethash constructor *operation-hash*)))
   (constructormodemap
    (setq stream *interp-stream*)
    (when (setq struct (get constructor 'database))
     (setq data (database-constructormodemap struct))))
   (constructorcategory
    (setq stream *interp-stream*)
    (when (setq struct (get constructor 'database))
     (setq data (database-constructorcategory struct))
     (when (null data) ;domain or package then subfield of constructormodemap
      (setq data (cadar (getdatabase constructor 'constructormodemap))))))
   (operationalist
    (setq stream *interp-stream*)
    (when (setq struct (get constructor 'database))
     (setq data (database-operationalist struct))))
   (modemaps
    (setq stream *interp-stream*)
    (when (setq struct (get constructor 'database))
     (setq data (database-modemaps struct))))
   (hascategory
    (setq table  *hasCategory-hash*)
    (setq stream *category-stream*)
    (setq data (gethash constructor table)))
   (object
    (setq stream *interp-stream*)
    (when (setq struct (get constructor 'database))
     (setq data (database-object struct))))
   (niladic
    (setq stream *interp-stream*)
    (when (setq struct (get constructor 'database))
     (setq data (database-niladic struct))))
   (constructor?
    (when (setq struct (get constructor 'database))
      (setq data (when (database-operationalist struct) t))))
   (superdomain ; only 2 superdomains in the world
    (case constructor
     (|NonNegativeInteger|
      (setq data '((|Integer|) (IF (< |#1| 0) |false| |true|))))
     (|PositiveInteger|
      (setq data '((|NonNegativeInteger|) (< 0 |#1|))))))
   (constructor
    (when (setq data (get constructor 'abbreviationfor))))
   (defaultdomain
    (setq data (cadr (assoc constructor *defaultdomain-list*))))
   (ancestors
    (setq stream *interp-stream*)
    (when (setq struct (get constructor 'database))
     (setq data (database-ancestors struct))))
   (sourcefile
    (setq stream *browse-stream*)
    (when (setq struct (get constructor 'database))
     (setq data (database-sourcefile struct))))
   (constructorform
    (setq stream *browse-stream*)
    (when (setq struct (get constructor 'database))
     (setq data (database-constructorform struct))))
   (constructorargs
    (setq data (cdr (getdatabase constructor 'constructorform))))
   (attributes
    (setq stream *browse-stream*)
    (when (setq struct (get constructor 'database))
     (setq data (database-attributes struct))))
   (predicates
    (setq stream *browse-stream*)
    (when (setq struct (get constructor 'database))
     (setq data (database-predicates struct))))
   (documentation
    (setq stream *browse-stream*)
    (when (setq struct (get constructor 'database))
     (setq data (database-documentation struct))))
   (parents
    (setq stream *browse-stream*)
    (when (setq struct (get constructor 'database))
     (setq data (database-parents struct))))
   (users
    (setq stream *browse-stream*)
    (when (setq struct (get constructor 'database))
     (setq data (database-users struct))))
   (dependents
    (setq stream *browse-stream*)
    (when (setq struct (get constructor 'database))
     (setq data (database-dependents struct))))
   (otherwise  (warn "~%(GETDATABASE ~a ~a) failed~%" constructor key)))
  (when (numberp data)      ;fetch the real data
   (when *miss* (format t "getdatabase miss: ~20a ~a~%" constructor key))
   (file-position stream data)
   (setq data (read stream))
   (case key ; cache the result of the database read
    (operation           (setf (gethash constructor *operation-hash*) data))
    (hascategory         (setf (gethash constructor *hascategory-hash*) data))
    (constructorkind     (setf (database-constructorkind struct) data))
    (cosig               (setf (database-cosig struct) data))
    (constructormodemap  (setf (database-constructormodemap struct) data))
    (constructorcategory (setf (database-constructorcategory struct) data))
    (operationalist      (setf (database-operationalist struct) data))
    (modemaps            (setf (database-modemaps struct) data))
    (object              (setf (database-object struct) data))
    (niladic             (setf (database-niladic struct) data))
    (abbreviation        (setf (database-abbreviation struct) data))
    (constructor         (setf (database-constructor struct) data))
    (ancestors           (setf (database-ancestors struct) data))
    (constructorform     (setf (database-constructorform struct) data))
    (attributes          (setf (database-attributes struct) data))
    (predicates          (setf (database-predicates struct) data))
    (documentation       (setf (database-documentation struct) data))
    (parents             (setf (database-parents struct) data))
    (users               (setf (database-users struct) data))
    (dependents          (setf (database-dependents struct) data))
    (sourcefile          (setf (database-sourcefile struct) data))))
   (case key ; fixup the special cases
    (sourcefile
     (when (and data (string= (directory-namestring data) "")
             (string= (pathname-type data) "spad"))
      (setq data
       (concatenate 'string $spadroot "/../../src/algebra/" data))))
    (object                                ; fix up system object pathname
     (if (consp data)
       (setq data
             (if (string= (directory-namestring (car data)) "")
                 (concatenate 'string $spadroot "/algebra/" (car data) ".o")
               (car data)))
      (when (and data (string= (directory-namestring data) ""))
       (setq data (concatenate 'string $spadroot "/algebra/" data ".o")))))))
  data))

\end{chunk}

\defun{library}{The {\tt )library} top level command}
\calls{library}{localdatabase}
\calls{library}{extendLocalLibdb}
\seebook{serverReadLine}{is-console}{9}
\calls{library}{tersyscommand}
\usesdollar{library}{newConlist}
\usesdollar{library}{options}
\begin{chunk}{defun library}
(defun |library| (args)
 (let (original-directory)
 (declare (special |$options| |$newConlist|))
  (setq original-directory (get-current-directory))
  (setq |$newConlist| nil)
  (localdatabase args |$options|)
  (|extendLocalLibdb| |$newConlist|)
  (system::chdir original-directory)
  (tersyscommand)))

\end{chunk}

\defun{localdatabase}{Read a local filename and update the hash tables}
The localdatabase function tries to find files in the order of:
nrlib/index.kaf
\calls{localdatabase}{sayKeyedMsg}
\calls{localdatabase}{localnrlib}
\usesdollar{localdatabase}{forceDatabaseUpdate}
\usesdollar{localdatabase}{ConstructorCache}
\uses{localdatabase}{*index-filename*}
\begin{chunk}{defun localdatabase}
(defun localdatabase (filelist options &optional (make-database? nil))
 "read a local filename and update the hash tables"
 (labels (
  (processOptions (options)
   (let (only dir noexpose)
    (when (setq only (assoc '|only| options))
     (setq options (lisp::delete only options :test #'equal))
     (setq only (cdr only)))
    (when (setq dir (assoc '|dir| options))
     (setq options (lisp::delete dir options :test #'equal))
     (setq dir (second dir))
     (when (null dir)
      (|sayKeyedMsg| 
       "Ignoring )dir because an explicit directory was not given after )dir."
        nil)))
    (when (setq noexpose (assoc '|noexpose| options))
     (setq options (lisp::delete noexpose options :test #'equal))
     (setq noexpose 't) )
    (when options
     (format t "   Ignoring unknown )library option: ~a~%" options))
    (values only dir noexpose)))
  (processDir (dirarg thisdir)
   (let (allfiles)
    (declare (special vmlisp::*index-filename*))
    (system::chdir (string dirarg))
    (setq allfiles (directory "*"))
    (system::chdir thisdir)
     (mapcan #'(lambda (f)
      (when (string-equal (pathname-type f) "nrlib")
       (list (concatenate 'string (namestring f) "/"
                          vmlisp::*index-filename*)))) allfiles))))
 (let (thisdir nrlibs object only dir key  (|$forceDatabaseUpdate| t) noexpose)
  (declare (special |$forceDatabaseUpdate| vmlisp::*index-filename*
                    |$ConstructorCache|))
  (setq thisdir (namestring (truename ".")))
  (setq noexpose nil)
  (multiple-value-setq (only dir noexpose) (processOptions options))
     ;don't force exposure during database build
  (if make-database? (setq noexpose t))
  (when dir (setq nrlibs (processDir dir thisdir)))
  (dolist (file filelist)
   (let* ((file (string file))
          (filename (pathname-name file))
          (namedir (directory-namestring file)))
    (unless namedir (setq thisdir (concatenate 'string thisdir "/")))
    (cond
     ((setq file (probe-file
       (concatenate 'string namedir filename ".nrlib/"
                    vmlisp::*index-filename*)))
      (push (namestring file) nrlibs))
     ('else (format t "   )library cannot find the file ~a.~%" filename)))))
  (dolist (file (nreverse nrlibs))
   (setq key (pathname-name (first (last (pathname-directory file)))))
   (setq object (concatenate 'string (directory-namestring file) "code"))
   (localnrlib key file object make-database? noexpose))
  (clrhash |$ConstructorCache|))))

\end{chunk}

\defun{localnrlib}{Update the database from an nrlib index.kaf file}
\calls{localnrlib}{getdatabase}
\calls{localnrlib}{make-database}
\calls{localnrlib}{addoperations}
\calls{localnrlib}{sublislis}
\calls{localnrlib}{updateDatabase}
\calls{localnrlib}{installConstructor}
\calls{localnrlib}{updateCategoryTable}
\calls{localnrlib}{categoryForm?}
\calls{localnrlib}{setExposeAddConstr}
\calls{localnrlib}{startTimingProcess}
\calls{localnrlib}{loadLibNoUpdate}
\calls{localnrlib}{sayKeyedMsg}
\usesdollar{localnrlib}{FormalMapVariableList}
\uses{localnrlib}{*allOperations*}
\uses{localnrlib}{*allconstructors*}
\begin{chunk}{defun localnrlib}
(defun localnrlib (key nrlib object make-database? noexpose)
 "given a string pathname of an index.kaf and the object update the database"
 (labels (
  (fetchdata (alist in index)
   (let (pos)
    (setq pos (third (assoc index alist :test #'string=)))
    (when pos
     (file-position in pos)
     (read in)))))
 (let (alist kind (systemdir? nil) pos constructorform oldmaps abbrev dbstruct)
  (declare (special *allOperations* *allconstructors*
                    |$FormalMapVariableList|))
  (with-open-file (in nrlib)
   (file-position in (read in))
   (setq alist (read in))
   (setq pos (third (assoc "constructorForm" alist :test #'string=)))
   (file-position in pos)
   (setq constructorform (read in))
   (setq key (car constructorform))
   (setq oldmaps (getdatabase key 'modemaps))
   (setq dbstruct (make-database))
   (setq *allconstructors* (adjoin key *allconstructors*))
   (setf (get key 'database) dbstruct) ; store the struct, side-effect it...
   (setf (database-constructorform dbstruct) constructorform)
   (setq *allOperations* nil)   ; force this to recompute
   (setf (database-object dbstruct) object)
   (setq abbrev
     (intern (pathname-name 
               (first (last (pathname-directory (string object)))))))
   (setf (database-abbreviation dbstruct) abbrev)
   (setf (get abbrev 'abbreviationfor) key)
   (setf (database-operationalist dbstruct) nil)
   (setf (database-operationalist dbstruct)
    (fetchdata alist in "operationAlist"))
   (setf (database-constructormodemap dbstruct)
    (fetchdata alist in "constructorModemap"))
   (setf (database-modemaps dbstruct) (fetchdata alist in "modemaps"))
   (setf (database-sourcefile dbstruct) (fetchdata alist in "sourceFile"))
   (when make-database?
    (setf (database-sourcefile dbstruct)
     (file-namestring  (database-sourcefile dbstruct))))
   (setf (database-constructorkind dbstruct)
    (setq kind (fetchdata alist in "constructorKind")))
   (setf (database-constructorcategory dbstruct)
    (fetchdata alist in "constructorCategory"))
   (setf (database-documentation dbstruct)
    (fetchdata alist in "documentation"))
   (setf (database-attributes dbstruct)
    (fetchdata alist in "attributes"))
   (setf (database-predicates dbstruct)
    (fetchdata alist in "predicates"))
   (setf (database-niladic dbstruct)
    (when (fetchdata alist in "NILADIC") t))
  (addoperations key oldmaps)
  (unless make-database?
   (if (eq kind '|category|)
    (setf (database-ancestors dbstruct)
     (sublislis |$FormalMapVariableList|
      (cdr constructorform) (fetchdata alist in "ancestors"))))
   (|updateDatabase| key key systemdir?) ;makes many hashtables???
   (|installConstructor| key kind) ;used to be key cname ...
   (|updateCategoryTable| key kind)
   (if |$InteractiveMode| (setq |$CategoryFrame| |$EmptyEnvironment|)))
  (setf (database-cosig dbstruct)
    (cons nil (mapcar #'|categoryForm?|
     (cddar (database-constructormodemap dbstruct)))))
  (remprop key 'loaded)
  (if (null noexpose) (|setExposeAddConstr| (cons key nil)))
  (setf (symbol-function key) ; sets the autoload property for cname
    #'(lambda (&rest args)
     (unless (get key 'loaded)
      (|startTimingProcess| '|load|)
      (|loadLibNoUpdate| key key object)) ; used to be cname key
     (apply key args)))
  (|sayKeyedMsg| "%1 will be automatically loaded when needed from %2"
   (list key object))))))

\end{chunk}

\defun{updateDatabase}{updateDatabase}
For now in NRUNTIME do database update only if forced
\calls{updateDatabase}{constructor?}
\calls{updateDatabase}{clearClams}
\calls{updateDatabase}{clearAllSlams}
\refsdollar{updateDatabase}{forceDatabaseUpdate}
\begin{chunk}{defun updateDatabase}
(defun |updateDatabase| (fname cname systemdirp)
 (declare (ignore fname))
 (declare (special |$forceDatabaseUpdate|))
  (when |$forceDatabaseUpdate|
   (when (|constructor?| cname)
    (|clearClams|)
    (|clearAllSlams| nil)
    (when (getl cname 'loaded) (|clearConstructorCaches|)))
   (when (or |$forceDatabaseUpdate| (null systemdirp))
    (|clearClams|)
    (|clearAllSlams| nil))))

\end{chunk}

\defvar{*sourcefiles*}
\begin{chunk}{initvars}
(defvar *sourcefiles* nil)

\end{chunk}

\defun{make-databases}{Make new databases}
Making new databases consists of:
\begin{enumerate}
\item reset all of the system hash tables
\item set up Union, Record and Mapping
\item map )library across all of the system files (fills the databases)
\item loading some normally autoloaded files
\item making some database entries that are computed (like ancestors)
\item writing out the databases
\item write out 'warm' data to be loaded into the image at build time
\end{enumerate}

Note that this process should be done in a clean image
followed by a rebuild of the system image to include
the new index pointers (e.g. *interp-stream-stamp*)

The system will work without a rebuild but it needs to
re-read the databases on startup. Rebuilding the system
will cache the information into the image and the databases
are opened but not read, saving considerable startup time.
Also note that the order the databases are written out is
critical. The interp.daase depends on prior computations and has
to be written out last.

The build-name-to-pamphlet-hash builds a hash table whose key->value is:
\begin{itemize}
\item abbreviation $->$ pamphlet file name
\item abbreviation-line $->$ pamphlet file position
\item constructor $->$ pamphlet file name
\item constructor-line $->$ pamphlet file position
\end{itemize}
is the symbol of the constructor name and whose value is the name of
the source file without any path information. We  hash the 
constructor abbreviation to pamphlet file name.

\calls{make-databases}{localdatabase}
\calls{make-databases}{getenviron}
\calls{make-databases}{browserAutoloadOnceTrigger}
\calls{make-databases}{mkTopicHashTable}
\calls{make-databases}{buildLibdb}
\calls{make-databases}{dbSplitLibdb}
\calls{make-databases}{mkUsersHashTable}
\calls{make-databases}{saveUsersHashTable}
\calls{make-databases}{mkDependentsHashTable}
\calls{make-databases}{saveDependentsHashTable}
\calls{make-databases}{write-browsedb}
\calls{make-databases}{write-operationdb}
\calls{make-databases}{write-categorydb}
\calls{make-databases}{allConstructors}
\calls{make-databases}{categoryForm?}
\calls{make-databases}{domainsOf}
\calls{make-databases}{getConstructorForm}
\calls{make-databases}{write-interpdb}
\calls{make-databases}{write-warmdata}
\usesdollar{make-databases}{constructorList}
\uses{make-databases}{*sourcefiles*}
\uses{make-databases}{*allconstructors*}
\uses{make-databases}{*operation-hash*}
\begin{chunk}{defun make-databases}
(defun make-databases (ext dirlist)
 (labels (
  (build-name-to-pamphlet-hash (dir)
   (let ((ht (make-hash-table)) (eof '(done)) point mark abbrev name file ns)
    (dolist (fn (directory dir))
     (when (and (string= (pathname-type fn) "pamphlet")
            (or (string= (pathname-name fn) "bookvol10.2")   ; category
                (string= (pathname-name fn) "bookvol10.3")   ; domain
                (string= (pathname-name fn) "bookvol10.4")   ; package
                (string= (pathname-name fn) "bookvol10.5"))) ; numerics
      (with-open-file (f fn)
       (do ((ln (read-line f nil eof) (read-line f nil eof))
            (line 0 (incf line)))
           ((eq ln eof))
      (when (and (setq mark (search ")abb" ln)) (= mark 0))
        (setq mark (position #\space ln :from-end t))
        (setq name (intern (string-trim '(#\space) (subseq ln mark))))
        (cond
          ((setq mark (search "domain" ln)) (setq mark (+ mark 7)))
          ((setq mark (search "package" ln)) (setq mark (+ mark 8)))
          ((setq mark (search "category" ln)) (setq mark (+ mark 9))))
        (setq point (position #\space ln :start (+ mark 1)))
        (setq abbrev 
         (intern (string-trim '(#\space) (subseq ln mark point))))
        (setq ns (namestring fn))
        (setq mark (position #\/ ns :from-end t))
        (setq file (subseq ns (+ mark 1)))
        (setf (gethash abbrev ht) file)
        (setf (gethash (format nil "~a-line" abbrev) ht) line)
        (setf (gethash name ht) file)
        (setf (gethash (format nil "~a-line" name) ht) line))))))
     ht))
    ;; these are types which have no library object associated with them.
    ;; we store some constructed data to make them perform like library
    ;; objects, the *operationalist-hash* key entry is used by allConstructors
  (withSpecialConstructors ()
   (declare (special *allconstructors*))
   ; note: if item is not in *operationalist-hash* it will not be written
   ; Category
   (setf (get '|Category| 'database)
     (make-database :operationalist nil :niladic t))
   (push '|Category| *allconstructors*)
   ; UNION
   (setf (get '|Union| 'database)
     (make-database :operationalist nil :constructorkind '|domain|))
   (push '|Union| *allconstructors*)
   ; RECORD
   (setf (get '|Record| 'database)
    (make-database :operationalist nil :constructorkind '|domain|))
   (push '|Record| *allconstructors*)
   ; MAPPING
   (setf (get '|Mapping| 'database)
    (make-database :operationalist nil :constructorkind '|domain|))
   (push '|Mapping| *allconstructors*)
   ; ENUMERATION
   (setf (get '|Enumeration| 'database)
    (make-database :operationalist nil :constructorkind '|domain|))
   (push '|Enumeration| *allconstructors*)
   )
  (final-name (root) 
    (format nil "~a.daase~a" root ext))
  )
 (let (d)
  (declare (special |$constructorList| *sourcefiles*
                    *allconstructors* *operation-hash*))
  (do-symbols (symbol)
   (when (get symbol 'database)
    (setf (get symbol 'database) nil)))
  (setq *hascategory-hash* (make-hash-table :test #'equal))
  (setq *operation-hash* (make-hash-table))
  (setq *allconstructors* nil)
  (withSpecialConstructors)
  (localdatabase nil
     (list (list '|dir| (namestring (truename "./")) ))
     'make-database)
  (dolist (dir dirlist)
   (localdatabase nil 
    (list (list '|dir| (namestring (truename (format nil "./~a" dir)))))
    'make-database))
;browse.daase
  (load (concatenate 'string (getenviron "AXIOM") "/autoload/topics"))  ;; hack
  (|browserAutoloadOnceTrigger|)
  (|mkTopicHashTable|)
  (setq |$constructorList| nil) ;; affects buildLibdb
  (setq *sourcefiles* (build-name-to-pamphlet-hash 
    (concatenate 'string (getenviron "AXIOM") "/../../books/*.pamphlet")))
  (|buildLibdb|)
  (|dbSplitLibdb|)
; (|dbAugmentConstructorDataTable|)
  (|mkUsersHashTable|)
  (|saveUsersHashTable|)
  (|mkDependentsHashTable|)
  (|saveDependentsHashTable|)
; (|buildGloss|)
  (write-browsedb)
  (write-operationdb)
 ; note: genCategoryTable creates a new *hascategory-hash* table
 ; this smashes the existing table and regenerates it.
 ; write-categorydb does getdatabase calls to write the new information
  (write-categorydb)
  (dolist (con (|allConstructors|))
   (let (dbstruct)
     (when (setq dbstruct (get con 'database))
           (setf (database-cosig dbstruct)
                 (cons nil (mapcar #'|categoryForm?|
                           (cddar (database-constructormodemap dbstruct)))))
           (when (and (|categoryForm?| con)
                      (= (length (setq d (|domainsOf| (list con) NIL NIL))) 1))
                 (setq d (caar d))
                 (when (= (length d) (length (|getConstructorForm| con)))
               (format t "   ~a has a default domain of ~a~%" con (car d))
                       (setf (database-defaultdomain dbstruct) (car d)))))))
        ; note: genCategoryTable creates *ancestors-hash*. write-interpdb
        ; does gethash calls into it rather than doing a getdatabase call.
  (write-interpdb)
  (write-warmdata)
  (when (probe-file (final-name "interp"))
        (delete-file (final-name "interp")))
  (rename-file "interp.build" (final-name "interp"))
  (when (probe-file (final-name "operation"))
        (delete-file (final-name "operation")))
  (rename-file "operation.build" (final-name "operation"))
  (when (probe-file (final-name "browse")) 
        (delete-file (final-name "browse")))
  (rename-file "browse.build" 
               (final-name "browse"))
  (when (probe-file (final-name "category"))
        (delete-file (final-name "category")))
  (rename-file "category.build" 
               (final-name "category")))))

\end{chunk}

\defun{saveDependentsHashTable}{saveDependentsHashTable}
\calls{saveDependentsHashTable}{erase}
\calls{saveDependentsHashTable}{writeLib1}
\calls{saveDependentsHashTable}{msort}
\calls{saveDependentsHashTable}{hkeys}
\calls{saveDependentsHashTable}{rwrite}
\calls{saveDependentsHashTable}{hget}
\calls{saveDependentsHashTable}{rshut}
\refsdollar{saveDependentsHashTable}{depTb}
\refsdollar{saveDependentsHashTable}{erase}
\begin{chunk}{defun saveDependentsHashTable}
(defun |saveDependentsHashTable| ()
 (let (stream)
 (declare (special |$depTb| $erase))
  ($erase '|dependents| 'database '|a|)
  (setq stream (|writeLib1| '|dependents| 'database '|a|))
  (dolist (k (msort (hkeys |$depTb|)))
    (|rwrite| k (hget |$depTb| k) stream))
  (rshut stream)))

\end{chunk}

\defun{saveUsersHashTable}{saveUsersHashTable}
\calls{saveUsersHashTable}{erase}
\calls{saveUsersHashTable}{writeLib1}
\calls{saveUsersHashTable}{msort}
\calls{saveUsersHashTable}{hkeys}
\calls{saveUsersHashTable}{rwrite}
\calls{saveUsersHashTable}{hget}
\calls{saveUsersHashTable}{rshut}
\refsdollar{saveUsersHashTable}{erase}
\refsdollar{saveUsersHashTable}{usersTb}
\begin{chunk}{defun saveUsersHashTable}
(defun |saveUsersHashTable| ()
 (let (stream)
 (declare (special |$usersTb| $erase))
  ($erase '|users| 'database '|a|)
  (setq stream (|writeLib1| '|users| 'database '|a|))
  (dolist (k (msort (hkeys |$usersTb|)))
    (|rwrite| k (HGET |$usersTb| k) stream))
  (rshut stream)))

\end{chunk}

\defun{DaaseName}{Construct the proper database full pathname}
\calls{DaaseName}{getenviron}
\usesdollar{DaaseName}{spadroot}
\begin{chunk}{defun DaaseName}
(defun DaaseName (name erase?)
 (let (daase filename)
  (declare (special $spadroot))
  (if (setq daase (getenviron "DAASE"))
   (progn
    (setq filename  (concatenate 'string daase "/algebra/" name))
    (format t "   Using local database ~a.." filename))
   (setq filename (concatenate 'string $spadroot "/algebra/" name)))
  (when erase? (system::system (concatenate 'string "rm -f " filename)))
  filename))

\end{chunk}

\subsection{Building the interp.daase from hash tables} 
\begin{verbatim}
 format of an entry in interp.daase:
  (constructor-name
    operationalist
    constructormodemap
    modemaps             -- this should not be needed. eliminate it.
    object               -- the name of the object file to load for this con.
    constructorcategory -- note that this info is the cadar of the
          constructormodemap for domains and packages so it is stored
          as NIL for them. it is valid for categories.
    niladic              -- t or nil directly
    unused
    cosig                -- kept directly
    constructorkind      -- kept directly
    defaultdomain        -- a short list, for %i
    ancestors            -- used to compute new category updates
  )
\end{verbatim}

Here I'll try to outline the interp database write procedure

\begin{verbatim}
(defun write-interpdb ()
 "build interp.daase from hash tables"
 (declare (special $spadroot *ancestors-hash*))
 (let (opalistpos modemapspos cmodemappos master masterpos obj *print-pretty*
        concategory categorypos kind niladic cosig abbrev defaultdomain
        ancestors ancestorspos out)
  (declare (special *print-pretty*))
  (print "building interp.daase")

; 1. We open the file we're going to create

  (setq out (open "interp.build" :direction :output))

; 2. We reserve some space at the top of the file for the key-time pair
;    We will overwrite these spaces just before we close the file.

  (princ "                              " out)

; 3. Make sure we write it out
  (finish-output out)

; 4. For every constructor in the system we write the parts:

  (dolist (constructor (|allConstructors|))
   (let (struct)

; 4a. Each constructor has a property list. A property list is a list
;     of (key . value) pairs. The property we want is called 'database
;     so there is a ('database . something) in the property list

    (setq struct (get constructor 'database))

; 5 We write the "operationsalist"
; 5a. We remember the current file position before we write
;     We need this information so we can seek to this position on read

    (setq opalistpos (file-position out))

; 5b. We get the "operationalist" and write it out

    (print (database-operationalist struct) out)

; 5c. We make sure it was written

    (finish-output out)

; 6 We write the "constructormodemap"
; 6a. We remember the current file position before we write

    (setq cmodemappos (file-position out))

; 6b. We get the "constructormodemap" and write it out

    (print (database-constructormodemap struct) out)

; 6c. We make sure it was written

    (finish-output out)

; 7. We write the "modemaps"
; 7a. We remember the current file position before we write

    (setq modemapspos (file-position out))

; 7b. We get the "modemaps" and write it out

    (print (database-modemaps struct) out)

; 7c. We make sure it was written

    (finish-output out)

; 8. We remember source file pathnames in the obj variable

    (setq obj
     (pathname-name
       (first (last (pathname-directory (database-object struct))))))

; 9. We write the "constructorcategory", if it is a category, else nil
; 9a. Get the constructorcategory 

    (setq concategory (database-constructorcategory struct))

; 9b. If we have any data we write it out, else we don't write it
;     Note that if there is no data then the byte index for the
;     constructorcatagory will not be a number but will be nil.

    (if concategory  ; if category then write data else write nil
     (progn
      (setq categorypos (file-position out))
      (print concategory out)
      (finish-output out))
     (setq categorypos nil))

; 10. We get a set of properties which are kept as "immediate" data
;     This means that the key table will hold this data directly
;     rather than as a byte index into the file.
; 10a. niladic data

    (setq niladic (database-niladic struct))

; 10b. abbreviation data (e.g. POLY for polynomial)

    (setq abbrev (database-abbreviation struct))

; 10c. cosig data

    (setq cosig (database-cosig struct))

; 10d. kind data

    (setq kind (database-constructorkind struct))

; 10e. defaultdomain data

    (setq defaultdomain (database-defaultdomain struct))

; 11. The ancestor data might exist. If it does we fetch it
;     and write it out. If it does not we place
;     and immediate value of nil in the key-value table

    (setq ancestors (gethash constructor *ancestors-hash*)) ;cattable.boot
    (if ancestors
     (progn
      (setq ancestorspos (file-position out))
      (print ancestors out)
      (finish-output out))
     (setq ancestorspos nil))

; 12. "master" is an alist. Each element of the alist has the name of
;     the constructor and all of the above attributes. When the loop
;     finishes we will have constructed all of the data for the key-value
;     table

    (push (list constructor opalistpos cmodemappos modemapspos
      obj categorypos niladic abbrev cosig kind defaultdomain
      ancestorspos) master)))

; 13. The loop is done, we make sure all of the data is written

  (finish-output out)

; 14. We remember where the key-value table will be written in the file

  (setq masterpos (file-position out))

; 15. We print the key-value table

  (print master out)

; 16. We make sure we write the table

  (finish-output out)

; 17. We go to the top of the file

  (file-position out 0)

; 18. We write out the (master-byte-position . universal-time) pair
;     Note that if the universal-time value matches the value of
;     *interp-stream-stamp* then there is no reason to read the
;     interp database because all of the data is already cached in
;     the image. This happens if you build a database and immediatly
;     save the image. The saved image already has the data since we
;     just wrote it out. If the *interp-stream-stamp* and the database
;     time stamp differ we "reread" the database on startup. Actually
;     we just open the database and fetch as needed. You can see fetches
;     by setting the *miss* variable non-nil.

  (print (cons masterpos (get-universal-time)) out)

; 19. We make sure we write it.

  (finish-output out)

; 20 And we are done

  (close out)))
\end{verbatim}

\defun{write-interpdb}{Write the interp database}
\usesdollar{write-interpdb}{spadroot}
\uses{write-interpdb}{*ancestors-hash*}
\uses{write-interpdb}{*print-pretty*}
\begin{chunk}{defun write-interpdb}
(defun write-interpdb ()
 "build interp.daase from hash tables"
 (declare (special $spadroot *ancestors-hash*))
 (let (opalistpos modemapspos cmodemappos master masterpos obj *print-pretty*
        concategory categorypos kind niladic cosig abbrev defaultdomain
        ancestors ancestorspos out)
  (declare (special *print-pretty*))
  (print "building interp.daase")
  (setq out (open "interp.build" :direction :output))
  (princ "                              " out)
  (finish-output out)
  (dolist (constructor (|allConstructors|))
   (let (struct)
    (setq struct (get constructor 'database))
    (setq opalistpos (file-position out))
    (print (database-operationalist struct) out)
    (finish-output out)
    (setq cmodemappos (file-position out))
    (print (database-constructormodemap struct) out)
    (finish-output out)
    (setq modemapspos (file-position out))
    (print (database-modemaps struct) out)
    (finish-output out)
    (setq obj
     (pathname-name
       (first (last (pathname-directory (database-object struct))))))
    (setq concategory (database-constructorcategory struct))
    (if concategory  ; if category then write data else write nil
     (progn
      (setq categorypos (file-position out))
      (print concategory out)
      (finish-output out))
     (setq categorypos nil))
    (setq niladic (database-niladic struct))
    (setq abbrev (database-abbreviation struct))
    (setq cosig (database-cosig struct))
    (setq kind (database-constructorkind struct))
    (setq defaultdomain (database-defaultdomain struct))
    (setq ancestors (gethash constructor *ancestors-hash*)) ;cattable.boot
    (if ancestors
     (progn
      (setq ancestorspos (file-position out))
      (print ancestors out)
      (finish-output out))
     (setq ancestorspos nil))
    (push (list constructor opalistpos cmodemappos modemapspos
      obj categorypos niladic abbrev cosig kind defaultdomain
      ancestorspos) master)))
  (finish-output out)
  (setq masterpos (file-position out))
  (print master out)
  (finish-output out)
  (file-position out 0)
  (print (cons masterpos (get-universal-time)) out)
  (finish-output out)
  (close out)))

\end{chunk}

\subsection{Building the browse.daase from hash tables} 
\begin{verbatim}
 format of an entry in browse.daase:
 ( constructorname
     sourcefile
     constructorform
     documentation
     attributes
     predicates
 )
\end{verbatim}
This is essentially the same overall process as write-interpdb.

We reserve some space for the (key-table-byte-position . timestamp)

We loop across the list of constructors dumping the data and
remembering the byte positions in a key-value pair table.

We dump the final key-value pair table, write the byte position and
time stamp at the top of the file and close the file.

\defun{write-browsedb}{Write the browse database}
\calls{write-browsedb}{allConstructors}
\usesdollar{write-browsedb}{spadroot}
\uses{write-browsedb}{*sourcefiles*}
\uses{write-browsedb}{*print-pretty*}
\begin{chunk}{defun write-browsedb}
(defun write-browsedb ()
 "make browse.daase from hash tables"
 (declare (special $spadroot *sourcefiles*))
 (let (master masterpos src formpos docpos attpos predpos *print-pretty* out)
  (declare (special *print-pretty*))
  (print "building browse.daase")
  (setq out (open "browse.build" :direction :output))
  (princ "                              " out)
  (finish-output out)
  (dolist (constructor (|allConstructors|))
   (let (struct)
    (setq struct (get constructor 'database))
     ; sourcefile is small. store the string directly
    (setq src (gethash constructor *sourcefiles*))
    (setq formpos (file-position out))
    (print (database-constructorform struct) out)
    (finish-output out)
    (setq docpos (file-position out))
    (print (database-documentation struct) out)
    (finish-output out)
    (setq attpos (file-position out))
    (print (database-attributes struct) out)
    (finish-output out)
    (setq predpos (file-position out))
    (print (database-predicates struct) out)
    (finish-output out)
    (push (list constructor src formpos docpos attpos predpos) master)))
  (finish-output out)
  (setq masterpos (file-position out))
  (print master out)
  (finish-output out)
  (file-position out 0)
  (print (cons masterpos (get-universal-time)) out)
  (finish-output out)
  (close out)))

\end{chunk}

\subsection{Building the category.daase from hash tables} 
This is a single table of category hash table information, dumped in the 
database format.

\defun{write-categorydb}{Write the category database}
\calls{write-categorydb}{genCategoryTable}
\uses{write-categorydb}{*print-pretty*}
\uses{write-categorydb}{*hasCategory-hash*}
\begin{chunk}{defun write-categorydb}
(defun write-categorydb ()
 "make category.daase from scratch. contains the *hasCategory-hash* table"
 (let (out master pos *print-pretty*)
  (declare (special *print-pretty* *hasCategory-hash*))
  (print "building category.daase")
  (|genCategoryTable|)
  (setq out (open "category.build" :direction :output))
  (princ "                              " out)
  (finish-output out)
  (maphash #'(lambda (key value)
    (if (or (null value) (eq value t))
     (setq pos value)
     (progn
      (setq pos (file-position out))
      (print value out)
      (finish-output out)))
     (push (list key pos) master))
     *hasCategory-hash*)
  (setq pos (file-position out))
  (print master out)
  (finish-output out)
  (file-position out 0)
  (print (cons pos (get-universal-time)) out)
  (finish-output out)
  (close out)))

\end{chunk}

\subsection{Building the operation.daase from hash tables} 
This is a single table of operations hash table information, dumped in the 
database format.
\defun{write-operationdb}{Write the operations database}
\uses{write-operationdb}{*operation-hash*}
\begin{chunk}{defun write-operationdb}
(defun write-operationdb ()
 (let (pos master out)
  (declare (special leaves *operation-hash*))
  (setq out (open "operation.build" :direction :output))
  (princ "                              " out)
  (finish-output out)
  (maphash #'(lambda (key value)
   (setq pos (file-position out))
   (print value out)
   (finish-output out)
   (push (cons key pos) master))
   *operation-hash*)
  (finish-output out)
  (setq pos (file-position out))
  (print master out)
  (file-position out 0)
  (print (cons pos (get-universal-time)) out)
  (finish-output out)
  (close out)))

\end{chunk}

\subsection{Database support operations} 

\defun{write-warmdata}{Data preloaded into the image at build time}
\usesdollar{write-warmdata}{topicHash}
\begin{chunk}{defun write-warmdata}
(defun write-warmdata ()
 "write out information to be loaded into the image at build time"
 (declare (special |$topicHash|))
 (with-open-file (out "warm.data" :direction :output)
  (format out "(in-package \"BOOT\")~%")
  (format out "(setq |$topicHash| (make-hash-table))~%")
  (maphash #'(lambda (k v)
   (format out "(setf (gethash '|~a| |$topicHash|) ~a)~%" k v)) |$topicHash|)))

\end{chunk}

\defun{allConstructors}{Return all constructors}
\uses{allConstructors}{*allconstructors*}
\begin{chunk}{defun allConstructors}
(defun |allConstructors| ()
 (declare (special *allconstructors*))
 *allconstructors*)

\end{chunk}

\defun{allOperations}{Return all operations}
\uses{allOperations}{*allOperations*}
\uses{allOperations}{*operation-hash*}
\begin{chunk}{defun allOperations}
(defun |allOperations| ()
 (declare (special *allOperations* *operation-hash*))
 (unless *allOperations*
  (maphash #'(lambda (k v) (declare (ignore v)) (push k *allOperations*))
    *operation-hash*))
 *allOperations*)

\end{chunk}

\chapter{System Statistics}
\defun{statisticsInitialization}{statisticsInitialization}
\calls{statisticsInitialization}{gbc-time}
\begin{chunk}{defun statisticsInitialization}
(defun |statisticsInitialization| () 
 "initialize the garbage collection timer"
 #+:akcl (system:gbc-time 0)
 nil)

\end{chunk}

\section{Lisp Library Handling}

\defun{loadLib}{loadLib}
\calls{loadLib}{startTimingProcess}
\calls{loadLib}{getdatabase}
\calls{loadLib}{isSystemDirectory}
\calls{loadLib}{pathnameDirectory}
\calls{loadLib}{loadLibNoUpdate}
\calls{loadLib}{sayKeyedMsg}
\calls{loadLib}{namestring}
\calls{loadLib}{clearConstructorCache}
\calls{loadLib}{updateDatabase}
\calls{loadLib}{installConstructor}
\calls{loadLib}{updateCategoryTable}
\calls{loadLib}{categoryForm?}
\calls{loadLib}{remprop}
\calls{loadLib}{stopTimingProcess}
\refsdollar{loadLib}{InteractiveMode}
\refsdollar{loadLib}{printLoadMsgs}
\refsdollar{loadLib}{forceDatabaseUpdate}
\defsdollar{loadLib}{CategoryFrame}
\begin{chunk}{defun loadLib}
(defun |loadLib| (cname)
 (let (fullLibName systemdir? update? kind u sig coSig)
 (declare (special |$CategoryFrame| |$InteractiveMode| |$printLoadMsgs|
                   |$forceDatabaseUpdate|))
  (|startTimingProcess| '|load|)
  (when (setq fullLibName (getdatabase cname 'object))
   (setq systemdir? (|isSystemDirectory| (|pathnameDirectory| fullLibName)))
   (setq update? (or |$forceDatabaseUpdate| (null systemdir?)))
   (cond
    ((null update?) (|loadLibNoUpdate| cname cname fullLibName))
    (t
     (setq kind (getdatabase cname 'constructorkind))
     (when |$printLoadMsgs|
       (|sayKeyedMsg| "Loading %1 for %2 %3"
        (list (|namestring| fullLibName) kind cname)))
     (load fullLibName)
     (|clearConstructorCache| cname)
     (|updateDatabase| cname cname systemdir?)
     (|installConstructor| cname kind)
     (setq u (getdatabase cname 'constructormodemap))
     (|updateCategoryTable| cname kind)
     (setq coSig
      (when u
        (setq sig (cdar u))
        (cons nil (loop for x in (cdr sig) collect (|categoryForm?| x)))))
     (if (null (cdr (getdatabase cname 'constructorform)))
       (setf (get cname 'niladic) t)
       (remprop cname 'niladic))
     (setf (get cname 'loaded) fullLibName)
     (when |$InteractiveMode| (setq |$CategoryFrame| (list (list nil))))
     (|stopTimingProcess| '|load|)
     t)))))

\end{chunk}

\defun{isSystemDirectory}{isSystemDirectory}
\calls{isSystemDirectory}{function}
\refsdollar{isSystemDirectory}{spadroot}
\begin{chunk}{defun isSystemDirectory}
(defun |isSystemDirectory| (dir)
 (declare (special $spadroot))
 (every #'char= $spadroot dir))

\end{chunk}

\defun{loadLibNoUpdate}{loadLibNoUpdate}
\calls{loadLibNoUpdate}{getdatabase}
\calls{loadLibNoUpdate}{sayKeyedMsg}
\calls{loadLibNoUpdate}{toplevel}
\calls{loadLibNoUpdate}{clearConstructorCache}
\calls{loadLibNoUpdate}{installConstructor}
\calls{loadLibNoUpdate}{stopTimingProcess}
\refsdollar{loadLibNoUpdate}{printLoadMsgs}
\refsdollar{loadLibNoUpdate}{InteractiveMode}
\defsdollar{loadLibNoUpdate}{CategoryFrame}
\begin{chunk}{defun loadLibNoUpdate}
(defun |loadLibNoUpdate| (cname libName fullLibName)
 (declare (ignore libName))
 (let (kind)
 (declare (special |$CategoryFrame| |$InteractiveMode| |$printLoadMsgs|))
  (setq kind (getdatabase cname 'constructorkind))
  (when |$printLoadMsgs|
    (|sayKeyedMsg| "Loading %1 for %2 %3"
     (list (|namestring| fullLibName) kind cname)))
  (cond
   ((equal (catch 'versioncheck (load fullLibName)) (- 1))
     (princ "   wrong library version...recompile ")
     (princ fullLibName)
     (terpri)
     (toplevel))
   (t
     (|clearConstructorCache| cname)
     (|installConstructor| cname kind)
     (setf (get cname 'loaded) fullLibName)
     (when |$InteractiveMode| (setq |$CategoryFrame| (list (list nil))))
     (|stopTimingProcess| '|load|)))
  t))

\end{chunk}

\defun{loadFunctor}{loadFunctor}
\calls{loadFunctor}{loadFunctor}
\calls{loadFunctor}{loadLibIfNotLoaded}
\begin{chunk}{defun loadFunctor}
(defun |loadFunctor| (u)
 (cond
   ((null (atom u)) (|loadFunctor| (car u)))
   (t
     (|loadLibIfNotLoaded| u)
     u)))

\end{chunk}

\chapter{Special Lisp Functions}
\defun{compiledLookup}{compiledLookup}
\calls{compiledLookup}{isDomain}
\calls{compiledLookup}{NRTevalDomain}
\begin{chunk}{defun compiledLookup}
(defun |compiledLookup| (op sig dollar)
 (setq dollar (|NRTevalDomain| dollar))
 (|basicLookup| op sig dollar dollar))

\end{chunk}

\defmacro{hashCode?}
\begin{chunk}{defmacro hashCode? 0}
(defmacro |hashCode?| (x)
 `(integerp ,x)) 

\end{chunk}

\defun{basicLookup}{basicLookup}
\calls{basicLookup}{spadcall}
\calls{basicLookup}{hashCode?}
\calls{basicLookup}{opIsHasCat}
\calls{basicLookup}{HasCategory}
\calls{basicLookup}{hashType}
\calls{basicLookup}{hashString}
\calls{basicLookup}{error}
\calls{basicLookup}{vecp}
\calls{basicLookup}{isNewWorldDomain}
\calls{basicLookup}{oldCompLookup}
\calls{basicLookup}{lookupInDomainVector}
\refsdollar{basicLookup}{hashSeg}
\refsdollar{basicLookup}{hashOpSet}
\refsdollar{basicLookup}{hashOpApply}
\refsdollar{basicLookup}{hashOp0}
\refsdollar{basicLookup}{hashOp1}
\begin{chunk}{defun basicLookup}
(defun |basicLookup| (op sig domain dollar)
 (let (hashPercent box dispatch lookupFun hashSig val boxval)
 (declare (special |$hashSeg| |$hashOpSet| |$hashOpApply| |$hashOp0|
                   |$hashOp1|))
  (cond
   ((simple-vector-p domain)
    (if (|isNewWorldDomain| domain)
      (|oldCompLookup| op sig domain dollar)
      (|lookupInDomainVector| op sig domain dollar)))
  (t
   (setq hashPercent
    (if (simple-vector-p dollar)
     (|hashType| (elt dollar 0) 0)
     (|hashType| dollar 0)))
   (setq box (cons nil nil))
   (cond
    ((null (simple-vector-p (setq dispatch (car domain))))
      (|error| '|bad domain format|))
    (t 
      (setq lookupFun (elt dispatch 3))
      (cond
        ((eql (elt dispatch 0) 0)
          (setq hashSig
           (cond
            ((|hashCode?| sig) sig)
            ((|opIsHasCat| op) (|hashType| sig hashPercent))
            (t (|hashType| (cons '|Mapping| sig) hashPercent))))
          (when (symbolp op)
           (cond
             ((eq op '|Zero|)   (setq op |$hashOp0|))
             ((eq op '|One|)    (setq op |$hashOp1|))
             ((eq op '|elt|)    (setq op |$hashOpApply|))
             ((eq op '|setelt|) (setq op |$hashOpSet|))
             (t                 (setq op (|hashString| (symbol-name op))))))
          (cond
           ((setq val
              (car
                (spadcall (cdr domain) dollar op hashSig box nil lookupFun)))
             val)
           ((|hashCode?| sig) nil)
           ((or (> (|#| sig) 1) (|opIsHasCat| op)) nil)
           ((setq boxval
            (spadcall (cdr dollar) dollar op
                      (|hashType| (car sig) hashPercent)
                      box nil lookupFun))
             (cons #'identity (car boxval)))
           (t nil)))
        ((|opIsHasCat| op) (|HasCategory| domain sig))
        (t
         (when (|hashCode?| op)
          (cond
           ((eql op |$hashOp1|)     (setq op '|One|))
           ((eql op |$hashOp0|)     (setq op '|Zero|))
           ((eql op |$hashOpApply|) (setq op '|elt|))
           ((eql op |$hashOpSet|)   (setq op '|setelt|))
           ((eql op |$hashSeg|)     (setq op 'segment))))
         (cond
          ((and (|hashCode?| sig) (eql sig hashPercent))
            (spadcall
             (car (spadcall (cdr dollar) dollar op '($) box nil lookupFun))))
          (t
           (car 
            (spadcall (cdr dollar) dollar op sig box nil lookupFun))))))))))))

\end{chunk}

\defun{lookupInDomainVector}{lookupInDomainVector}
\calls{lookupInDomainVector}{basicLookupCheckDefaults}
\calls{lookupInDomainVector}{spadcall}
\begin{chunk}{defun lookupInDomainVector}
(defun |lookupInDomainVector| (op sig domain dollar)
 (if (consp domain)
   (|basicLookupCheckDefaults| op sig domain domain)
   (spadcall op sig dollar (elt domain 1))))

\end{chunk}

\defun{basicLookupCheckDefaults}{basicLookupCheckDefaults}
\calls{basicLookupCheckDefaults}{vecp}
\calls{basicLookupCheckDefaults}{error}
\calls{basicLookupCheckDefaults}{hashType}
\calls{basicLookupCheckDefaults}{hashCode?}
\calls{basicLookupCheckDefaults}{hashString}
\calls{basicLookupCheckDefaults}{spadcall}
\refsdollar{basicLookupCheckDefaults}{lookupDefaults}
\begin{chunk}{defun basicLookupCheckDefaults}
(defun |basicLookupCheckDefaults| (op sig domain dollar)
 (declare (ignore domain))
 (let (box dispatch lookupFun hashPercent hashSig)
 (declare (special |$lookupDefaults|))
  (setq box (cons nil nil))
  (cond
   ((null (simple-vector-p (setq dispatch (car dollar))))
     (|error| '|bad domain format|))
   (t
     (setq lookupFun (elt dispatch 3))
     (cond
      ((eql (elt dispatch 0) 0)
        (setq hashPercent
         (if (simple-vector-p dollar)
           (|hashType| (elt dollar 0) 0)
           (|hashType| dollar 0)))
        (setq hashSig
         (if (|hashCode?| sig) 
          sig
          (|hashType| (cons '|Mapping| sig) hashPercent)))
        (when (symbolp op) (setq op (|hashString| (symbol-name op))))
        (car (spadcall (cdr dollar) dollar op hashSig
                        box (null |$lookupDefaults|) lookupFun)))
      (t
        (car (spadcall (cdr dollar) dollar op sig box
                       (null |$lookupDefaults|) lookupFun))))))))

\end{chunk}

\defun{oldCompLookup}{oldCompLookup}
\calls{oldCompLookup}{lookupInDomainVector}
\defsdollar{oldCompLookup}{lookupDefaults}
\begin{chunk}{defun oldCompLookup}
(defun |oldCompLookup| (op sig domvec dollar)
 (let (|$lookupDefaults| u)
 (declare (special |$lookupDefaults|))
  (setq |$lookupDefaults| nil)
  (cond
   ((setq u (|lookupInDomainVector| op sig domvec dollar))
     u)
   (t
    (setq |$lookupDefaults| t)
    (|lookupInDomainVector| op sig domvec dollar)))))

\end{chunk}

\defun{NRTevalDomain}{NRTevalDomain}
\calls{NRTevalDomain}{qcar}
\calls{NRTevalDomain}{eval}
\calls{NRTevalDomain}{evalDomain}
\begin{chunk}{defun NRTevalDomain}
(defun |NRTevalDomain| (form)
 (if (and (consp form) (eq (qcar form) 'setelt))
  (|eval| form)
  (|evalDomain| form)))

\end{chunk}

\section{Axiom control structure macros}
Axiom used various control structures in the boot code which are not
available in Common Lisp. We write some macros here to make the boot
to lisp translations easier to read.

\defun{put}{put}
\begin{chunk}{defun put}
(defun put (sym ind val) (setf (get sym ind) val))

\end{chunk}

\defmacro{while}
While the condition is true, repeat the body. 
When the condition is false, return t.
\begin{chunk}{defmacro while}
(defmacro while (condition &rest body)
 `(loop (if (not ,condition) (return t)) ,@body))

\end{chunk}

\defmacro{whileWithResult}
While the condition is true, repeat the body. 
When the condition is false, return the result form's value.
\begin{chunk}{defmacro whileWithResult}
(defmacro whileWithResult (condition result &rest body)
 `(loop (if (not ,condition) ,@result) ,@body))

\end{chunk}

\section{Filename Handling}
This code implements the Common Lisp pathname functions for
Lisp/VM.  On VM, a filename is 3-list consisting of the filename,
filetype and filemode. We also UPCASE everything.

\defun{namestring}{namestring}
\calls{namestring}{pathname}
\begin{chunk}{defun namestring}
(defun |namestring| (arg)
 (namestring (|pathname| arg)))

\end{chunk}

\defun{pathnameName}{pathnameName}
\calls{pathnameName}{pathname}
\begin{chunk}{defun pathnameName}
(defun |pathnameName| (arg)
 (pathname-name (|pathname| arg)))

\end{chunk}

\defun{pathnameType}{pathnameType}
\calls{pathnameType}{pathname}
\begin{chunk}{defun pathnameType}
(defun |pathnameType| (arg)
 (pathname-type (|pathname| arg))) 

\end{chunk}

\defun{pathnameTypeId}{pathnameTypeId}
\calls{pathnameTypeId}{upcase}
\calls{pathnameTypeId}{object2Identifier}
\calls{pathnameTypeId}{pathnameType}
\begin{chunk}{defun pathnameTypeId}
(defun |pathnameTypeId| (arg)
 (upcase (|object2Identifier| (|pathnameType| arg))))

\end{chunk}

\defun{mergePathnames}{mergePathnames}
\calls{mergePathnames}{pathnameName}
\calls{mergePathnames}{pathnameType}
\calls{mergePathnames}{pathnameDirectory}
\begin{chunk}{defun mergePathnames}
(defun |mergePathnames| (a b)
 (let (fn ft fm)
  (cond
   ((string= (setq fn (|pathnameName| a)) "*") b)
   ((not (equal fn (|pathnameName| b))) a)
   ((string= (setq ft (|pathnameType| a)) "*") b)
   ((not (equal ft (|pathnameType| b))) a)
   ((equal (setq fm (|pathnameDirectory| a)) (list "*" )) b)
   (t a))))

\end{chunk}

\defun{pathnameDirectory}{pathnameDirectory}
\calls{pathnameDirectory}{pathname}
\begin{chunk}{defun pathnameDirectory}
(defun |pathnameDirectory| (arg)
 (namestring (make-pathname :directory (pathname-directory (|pathname| arg)))))

\end{chunk}

\defun{pathname}{Axiom pathnames}
\calls{pathname}{pathname}
\calls{pathname}{make-filename}
\begin{chunk}{defun pathname}
(defun |pathname| (p)
 (cond
  ((null p) p)
  ((pathnamep p) p)
  ((symbolp p) (pathname (string p)))
  ((null (consp p)) (pathname p))
  (t
   (when (> (|#| p) 2) (setq p (cons (elt p 0) (cons (elt p 1) nil))))
   (pathname (apply #'make-filename p)))))

\end{chunk}

\defun{makePathname}{makePathname}
\calls{makePathname}{pathname}
\calls{makePathname}{object2String}
\begin{chunk}{defun makePathname}
(defun |makePathname| (name type dir)
 (declare (ignore dir))
 (|pathname| (list (|object2String| name) (|object2String| type))))

\end{chunk}

\defun{deleteFile}{Delete a file}
\calls{deleteFile}{erase}
\calls{deleteFile}{pathname}
\usesdollar{deleteFile}{erase}
\begin{chunk}{defun deleteFile}
(defun |deleteFile| (arg) 
 (declare (special $erase))
 ($erase (|pathname| arg)))

\end{chunk}

\defun{wrap}{wrap}
\calls{wrap}{lotsof}
\calls{wrap}{wrap}
\begin{chunk}{defun wrap}
(defun wrap (list-of-items wrapper)
 (prog nil
  (cond
   ((or (not (consp list-of-items)) (not wrapper))
    (return list-of-items))
   ((not (consp wrapper))
    (setq wrapper (lotsof wrapper))))
  (return
    (cons
     (if (first wrapper)
      `(,(first wrapper) ,(first list-of-items))
       (first list-of-items))
     (wrap (cdr list-of-items) (cdr wrapper))))))

\end{chunk}

\defun{lotsof}{lotsof}
\begin{chunk}{defun lotsof}
(defun lotsof (&rest items)
  (setq items (copy-list items))
  (nconc items items))

\end{chunk}

\defmacro{startsId?}
\begin{chunk}{defmacro startsId?}
(defmacro |startsId?| (x)
 `(or (alpha-char-p ,x) (member ,x '(#\? #\% #\!) :test #'char=)))

\end{chunk}

\defun{hput}{hput}
\begin{chunk}{defun hput}
(defun hput (table key value)
 (setf (gethash key table) value))

\end{chunk}

\defmacro{hget}
\begin{chunk}{defmacro hget}
(defmacro HGET (table key &rest default)
   `(gethash ,key ,table ,@default))

\end{chunk}

\defun{hkeys}{hkeys}
\begin{chunk}{defun hkeys}
(defun hkeys (table)
 (let (keys)
  (maphash
   #'(lambda (key val) (declare (ignore val)) (push key keys)) table)
   keys))

\end{chunk}

\defun{digitp}{digitp}
\calls{digitp}{digitp}
\begin{chunk}{defun digitp}
(defun digitp (x)
  (or (and (symbolp x) (digitp (symbol-name x)))
      (and (characterp x) (digit-char-p x))
      (and (stringp x) (= (length x) 1) (digit-char-p (char x 0)))))

\end{chunk}

\defun{pname}{pname}
Note it is important that PNAME returns nil not an error for non-symbols
\begin{chunk}{defun pname 0}
(defun pname (x)
  (cond ((symbolp x) (symbol-name x))
        ((characterp x) (string x))
        (t nil)))

\end{chunk}

\defun{size}{size}
\begin{chunk}{defun size}
(defun size (l) 
 (cond
  ((vectorp l) (length l))
  ((consp l)   (list-length l))
  (t 0)))

\end{chunk}

\defun{strpos}{strpos}
\begin{chunk}{defun strpos}
(defun strpos (what in start dontcare)
 (setq what (string what) in (string in))
 (if dontcare 
  (progn 
   (setq dontcare (character dontcare))
   (search what in :start2 start
                   :test #'(lambda (x y) (or (eql x dontcare) (eql x y)))))
  (if (= start 0)
   (search what in)
   (search what in :start2 start))))

\end{chunk}

\defun{strposl}{strposl}
Note that this assumes ``table'' is a string.
\begin{chunk}{defun strposl}
(defun strposl (table cvec sint item)
 (setq cvec (string cvec))
 (if (not item)
  (position table cvec :test #'(lambda (x y) (position y x)) :start sint)
  (position table cvec :test-not #'(lambda (x y) (position y x)) :start sint)))

\end{chunk}

\defmacro{identp}
\begin{chunk}{defmacro identp 0}
(defmacro identp (x) 
 (if (atom x)
  `(and ,x (symbolp ,x))
   (let ((xx (gensym)))
    `(let ((,xx ,x))
      (and ,xx (symbolp ,xx))))))

\end{chunk}

\defun{concat}{concat}
\calls{concat}{string-concatenate}
\begin{chunk}{defun concat 0}
(defun concat (a b &rest l)
 (if (bit-vector-p a)
   (if l 
     (apply #'concatenate 'bit-vector a b l)
     (concatenate 'bit-vector a b))
   (if l 
     (apply #'system:string-concatenate a b l)
     (system:string-concatenate a b))))

\end{chunk}

This function was called \verb?|functionp|? which is a lower-case
version of the common lisp function called functionp. Camm Maguire
found a bug related to this ambiguity so this was renamed.

\defun{canFuncall?}{canFuncall?}
\begin{chunk}{defun canFuncall?}
(defun canFuncall? (fn)
 (if (identp fn)
  (and (fboundp fn) (not (macro-function fn)))
  (functionp fn)))

\end{chunk}

;; -------------------- NEW DEFINITION (override in msgdb.boot.pamphlet)
\defun{brightprint}{brightprint}
\calls{brightprint}{messageprint}
\begin{chunk}{defun brightprint}
(defun brightprint (x)
 (messageprint x))

\end{chunk}
 
;; -------------------- NEW DEFINITION (override in msgdb.boot.pamphlet)
\defun{brightprint-0}{brightprint-0}
\calls{brightprint-0}{messageprint-1}
\begin{chunk}{defun brightprint-0}
(defun brightprint-0 (x)
 (messageprint-1 x))
 
\end{chunk}

\defun{member}{member}
\begin{chunk}{defun member 0}
(defun |member| (item sequence)
 (cond
   ((symbolp item) (member item sequence :test #'eq))
   ((stringp item) (member item sequence :test #'equal))
   ((and (atom item) (not (arrayp item))) (member item sequence))
   (t (member item sequence :test #'equalp))))

\end{chunk}

\defun{messageprint}{messageprint}
\begin{chunk}{defun messageprint}
(defun messageprint (x)
 (mapc #'messageprint-1 x))
 
\end{chunk}

\defun{messageprint-1}{messageprint-1}
\calls{messageprint-1}{identp}
\calls{messageprint-1}{messageprint-1}
\calls{messageprint-1}{messageprint-2}
\begin{chunk}{defun messageprint-1}
(defun messageprint-1 (x)
 (cond
  ((or (eq x '|%l|) (equal x "%l")) (terpri))
  ((stringp x) (princ x))
  ((identp x) (princ x))
  ((atom x) (princ x))
  ((princ "(") 
   (messageprint-1 (car x))
   (messageprint-2 (cdr x))
   (princ ")"))))

\end{chunk}

\defun{messageprint-2}{messageprint-2}
\calls{messageprint-2}{messageprint-1}
\calls{messageprint-2}{messageprint-2}
\begin{chunk}{defun messageprint-2}
(defun messageprint-2 (x)
  (if (atom x)
   (unless x (progn (princ " . ") (messageprint-1 x)))
   (progn (princ " ") (messageprint-1 (car x)) (messageprint-2 (cdr x)))))

\end{chunk}
 
\defun{sayBrightly1}{sayBrightly1}
\calls{saybrightly1}{brightprint-0}
\calls{saybrightly1}{brightprint}
\begin{chunk}{defun sayBrightly1}
(defun sayBrightly1 (x *standard-output*)
  (if (atom x)
   (progn (brightprint-0 x) (terpri) (force-output))
   (progn (brightprint   x) (terpri) (force-output))))

\end{chunk}
 
\defmacro{assq}
\tpdhere{This could probably be replaced by the default assoc using eql}
\begin{chunk}{defmacro assq}
(defmacro assq (a b)
 `(assoc ,a ,b :test #'eq))
\end{chunk}
 
\defun{getl}{A version of GET that works with lists}
\begin{chunk}{defun getl 0}
(defun getl (op prop)
 (when (and op (symbolp op)) (get op prop)))
\end{chunk}

\chapter{Record, Union, Mapping, and Enumeration}
\begin{chunk}{postvars}
(eval-when (eval load)
 (mapcar #'(lambda (alist) 
            (setf (get (first alist) '|makeFunctionList|) (second alist)))
 '((|Record| |mkRecordFunList|)
   (|Union| |mkUnionFunList|)
   (|Mapping| |mkMappingFunList|)
   (|Enumeration| |mkEnumerationFunList|))))

\end{chunk}

\chapter{Numeric Function Support}

\defmacro{fracpart}
\sig{fracpart}{or rational float}{or rational float}
\begin{chunk}{defmacro fracpart 0}
(defmacro fracpart (x)
 `(cadr (multiple-value-list (floor ,x))))

\end{chunk}

\defun{s-to-c}{list to complex conversion}
\begin{chunk}{defun s-to-c 0}
(defun s-to-c (c)
 (complex (car c) (cdr c)))

\end{chunk}

\defun{c-to-s}{complex to list conversion}
\begin{chunk}{defun c-to-s 0}
(defun c-to-s (c)
 (cons (realpart c) (imagpart c)))

\end{chunk}

\defun{c-to-r}{complex to real conversion}
\begin{chunk}{defun c-to-r}
(defun c-to-r (c)
 (let ((r (realpart c)) (i (imagpart c)))
   (if (or (zerop i) (< (abs i) (* 1.0E-10 (abs r))))
     r
     (|error| "Result is not real.")) ))

\end{chunk}

\defmacro{FloatError}
\begin{chunk}{defmacro FloatError 0}
(defmacro FloatError (formatstring arg)
  `(error (format nil ,formatstring ,arg)))

\end{chunk}

\defun{lnrgammaRatapprox}{Rational approximation to $\Gamma(x)$}
\calls{lnrgammaRatapprox}{phiRatapprox}
\begin{chunk}{defun lnrgammaRatapprox}
(defun lnrgammaRatapprox (x)
 "(x-.5)*log(x) - x + log(sqrt(2.0*Pi)) + phiRatapprox(x)"
  (+ (+ (- (* (- x 0.5) (log x)) x)
        (log (sqrt (* 2.0 Pi))))
     (phiRatapprox x)))

\end{chunk}

\defun{phiRatapprox}{phiRatapprox}
\calls{phiRatapprox}{horner}
\begin{chunk}{defun phiRatapprox}
(defun phiRatapprox (x)
 (let ((arg (/ 1 (* x x))))
  (/
   (horner
    '(0.066662907040200753 0.64507302912899211
      0.67082783834332138 0.12398282342474939) arg)
   (* x
    (horner
     '(1.0 7.9966911236636431 8.0995271894897574 1.4877938810969931) arg)))))

\end{chunk}

\defun{lnrgamma}{Log approximation to $\Gamma(x)$}
\calls{lnrgamma}{lnrgammaRatapprox}
\calls{lnrgamma}{gammaRatapprox}
\begin{chunk}{defun lnrgamma}
(defun lnrgamma (x)
 (if (< 20 x)
   (lnrgammaRatapprox x)
   (log (gammaRatapprox x))))

\end{chunk}

\defun{gammaStirling}{Stirling's approximation to $\Gamma(x)$}
\calls{gammaStirling}{lnrgamma}
\begin{chunk}{defun gammaStirling}
(defun gammaStirling (x)
  (exp (lnrgamma x)))

\end{chunk}

\defun{rgammaImpl}{rgammaImpl}
This code implements the real $\Gamma(x)$ function used in 
DoubleFloatSpecialFunctions.
\calls{rgammaImpl}{FloatError}
\calls{rgammaImpl}{gammaStirling}
\calls{rgammaImpl}{gammaRatapprox}
\begin{chunk}{defun rgammaImpl}
(defun rgammaImpl (x)
 (when (complexp x)
   (FloatError "Gamma not implemented for complex value ~D" x))
  (if (zerop (- x 1.0)) 
    1.0
    (if (< 20 x)
     (gammaStirling x)
     (gammaRatapprox x))))

\end{chunk}

\defun{gammaRatapprox}{gammaRatapprox}
\calls{gammaRatapprox}{gammaRatapprox}
\calls{gammaRatapprox}{FloatError}
\calls{gammaRatapprox}{gammaRatkernel}
\begin{chunk}{defun gammaRatapprox}
(defun gammaRatapprox (x)
 (let (restx intpartx lx prod reducedarg a n result)
  (cond
   ((and (not (< x 2)) (not (< 3 x)))
     (setq result (gammaRatkernel x)))
   ((< 3 x)
     (setq n (- (floor x) 2))
     (setq a (- (- x n) 2))
     (setq reducedarg (+ 2 a))
     (setq prod
      (reduce #'* (loop for i from 0 to (- n 1) collect (+ reducedarg i))))
     (setq result (* prod (gammaRatapprox reducedarg))))
   ((and (< x 2) (< 0 x))
    (setq n (- 2 (floor x)))
    (setq a (- x (floor x)))
    (setq reducedarg (+ 2 a))
    (setq prod (reduce #'* (loop for i from 0 to (- n 1) collect (+ x i))))
    (setq result (/ (gammaRatapprox reducedarg) prod)))
   (t
    (setq lx (multiple-value-list (floor x)))
    (setq intpartx (+ (car lx) 1))
    (setq restx (cadr lx))
    (cond
     ((zerop restx)
       (FloatError "Gamma undefined for non-positive integers: ~D" x)
       (setq result (/ 1.0 (complex 0.0))))
     (t
      (setq result
       (/ Pi
         (* (* (gammaRatapprox (- 1.0 x))
               (expt (- 1.0) (+ intpartx 1)))
            (sin (* restx Pi)))))))))
  result))

\end{chunk}

\defun{gammaRatkernel}{gammaRatkernel}
\calls{gammaRatkernel}{horner}
\begin{chunk}{defun gammaRatkernel}
(defun gammaRatkernel (x)
  (/
   (horner
    '(0.77807958561330059 6.1260674503360839 48.95434622790993 
     222.11239616801177   893.58180452374972 2077.4597938941874
     3786.0105034825724)
     (- x 2))
   (horner
    '(1  -13.400414785781347 50.788475328895402 83.550058667919771 
         -867.23098753110298 476.79386050368794 3786.0105034825719)
     (- x 2.0))))

\end{chunk}

\defun{horner}{Horner's rule of polynomial evaluation}
\begin{chunk}{defun horner 0}
(defun horner (l x)
 (let ((result 0))
  (loop for el in l do (setq result (+ (* x result) el)))
  result))

\end{chunk}

\defun{cgammaImpl}{Complex implementation of $\Gamma(z)$}
\calls{cgammaImpl}{rgammaImpl}
\calls{cgammaImpl}{clngammaImpl}
\begin{chunk}{defun cgammaImpl}
(defun cgammaImpl (z)
  (if (zerop (imagpart z))
    (rgammaImpl (realpart z))
    (exp (clngammaImpl (realpart z) (imagpart z) z))))

\end{chunk}

Compute the conjugate of gamma which is the gamma of the conjugate. 
Map the 2nd and the 4th quadrants to first and third quadrants.

\defun{clngammaImpl}{Compute the conjugate of $\Gamma(z)$}
\calls{clngammaImpl}{clngammacase1}
\calls{clngammaImpl}{clngammacase23}
\begin{chunk}{defun clngammaImpl}
(defun clngammaImpl (real imag z)
  (cond
   ((< real 0.0)
     (if (< 0.0 imag)
       (conjugate (clngammacase1 real (- imag) (complex real (- imag))))
       (clngammacase1 real imag z)))
   ((< imag 0.0)
     (conjugate (clngammacase23 real (- imag) (complex real (- imag)))))
   (t
     (clngammacase23 real imag z))))

\end{chunk}

\defun{clngammacase1}{$\Gamma(z)$ negative real branch}
\calls{clngammacase1}{PiMinusLogSinPi}
\calls{clngammacase1}{clngammaImpl}
\begin{chunk}{defun clngammacase1}
(defun clngammacase1 (real imag z)
 (- (PiMinusLogSinPi real imag z)
    (clngammaImpl (- 1.0 real) (- imag) (- 1.0 z))))

\end{chunk}

\defun{PiMinusLogSinPi}{PiMinusLogSinPi}
\calls{PiMinusLogSinPi}{cgammaG}
\calls{PiMinusLogSinPi}{logH}
\begin{chunk}{defun PiMinusLogSinPi}
(defun PiMinusLogSinPi (real imag z)
 (- (cgammaG real imag) (logH real imag z)))

\end{chunk}

\defun{cgammaG}{cgammaG}
\begin{chunk}{defun cgammaG 0}
(defun cgammaG (real imag)
  (- (+ (log (* 2 Pi)) (* Pi imag))
     (* (* (complex 0.0 1.0) Pi) (- real 0.5))))))

\end{chunk}

\defun{logH}{logH}
\begin{chunk}{defun logH 0}
(defun logH (real imag z)
 (declare (ignore z))
 (let (part1 part2 twopiz2 z1bar)
   (setq z1bar (cadr (multiple-value-list (floor real))))
   (setq twopiz2 (* 2.0 (* Pi imag)))
   (setq part2
     (* (exp twopiz2)
       (+ (* 2.0 (expt (sin (* Pi z1bar)) 2))
          (* (sin (* 2.0 (* Pi z1bar))) (complex 0.0 1.0)))))
   ;--- part1 is another way of saying 1 - exp(2*Pi*z1bar)
   (setq part1 (- (* (tanh (* Pi imag)) (+ 1.0 (exp twopiz2)))))
   (log (+ part1 part2))))

\end{chunk}

\defun{clngammacase23}{$\Gamma(z)$ positive real branch}
\calls{clngammacase23}{cgammat}
\calls{clngammacase23}{clngammacase2}
\calls{clngammacase23}{clngammacase3}
\begin{chunk}{defun clngammacase23}
(defun clngammacase23 (real imag z)
 (let ((tz2 (cgammat imag)))
  (if (< real tz2)
    (clngammacase2 real imag tz2 z)
    (clngammacase3 z))))

\end{chunk}

\defun{cgammat}{cgammat}
The cgammat is auxiliary "t" function \cite{kuki72a,kuki72b}
\begin{chunk}{defun cgammat 0}
(defun cgammat (x)
 (max 0.10000000000000001 (min 10.0 (- (* 10.0 (sqrt 2.0)) (abs x)))))

\end{chunk}

\defun{clngammacase2}{$\Gamma(z)$ case 2}
\calls{clngammacase2}{cgammaBernsum}
\calls{clngammacase2}{cgammaAdjust}
\calls{clngammacase2}{logS}
\begin{chunk}{defun clngammacase2}
(defun clngammacase2 (real imag tz2 z)
 (let (zpn n)
  (setq n (float (ceiling (- tz2 real))))
  (setq zpn (+ z n))
  (- (+ (- (* (- z 0.5) (log zpn)) zpn) (cgammaBernsum zpn))
     (cgammaAdjust (logS real imag z n zpn)))))

\end{chunk}

\defun{logS}{logS}
\begin{chunk}{defun logS 0}
(defun logS (real imag z n zpn)
 (let ((sum 0.0))
  (dotimes (k n)
   (if (< (+ real k) (- 5.0 (* 0.60000000000000009 imag)))
    (setq sum (+ sum (log (/ (+ z k) zpn)))))
    (setq sum (+ sum (log (- 1.0 (/ (- n k) zpn))))))
  sum))

\end{chunk}

\defun{cgammaAdjust}{Adjust logS if imaginary part is negative}
The logS result should have its imaginary part adjusted by $2\pi$ 
if it is negative. \cite{kuki72a,kuki72b}
\begin{chunk}{defun cgammaAdjust 0}
(defun cgammaAdjust (z)
 (if (< (imagpart z) 0.0)
  (+ z (complex 0.0 (* 2.0 Pi)))
  z))

\end{chunk}

\defun{clngammacase3}{$\Gamma(z)$ case 3}
\calls{clngammacase3}{cgammaBernsum}
\begin{chunk}{defun clngammacase3}
(defun clngammacase3 (z)
 (+ (- (* (- z 0.5) (log z)) z) (cgammaBernsum z)))

\end{chunk}

\defun{cgammaBernsum}{cgammaBernsum}
\begin{chunk}{defun cgammaBernsum 0}
(defun cgammaBernsum (z)
 (let (l zsquaredinv zterm sum)
  (setq sum (/ (log (* 2.0 Pi)) 2.0))
  (setq zterm z)
  (setq zsquaredinv (/ 1.0 (* z z)))
  (setq l
   (list 0.083333333333333315 (- 0.0027777777777777779)
         7.9365079365079376E-4 (- 5.9523809523809529E-4)
         8.4175084175084182E-4 (- 0.0019175269175269176)
         0.0064102564102564109))
  (loop for el in l do
    (setq zterm (* zterm zsquaredinv))
    (setq sum (+ sum (* el zterm))))
  sum))

\end{chunk}

\defun{BesselI}{BesselI}
\calls{BesselI}{BesselI}
\calls{BesselI}{FloatError}
\calls{BesselI}{besselIback}
\calls{BesselI}{besselIcheb}
\begin{chunk}{defun BesselI}
(defun BesselI (v z)
 (let ((b1 15.0))
  (cond
   ((and (zerop z) (floatp v) (not (< v 0.0)))
     (if (zerop v) 1.0 0.0))
   ; Transformations for negative integer orders
   ((and (floatp v) (zerop (fracpart v)) (minusp v))
     (BesselI (- v) z))
   ; Halfplane transformations for Re(z)<0
   ((< (realpart z) 0.0)
     (* (BesselI v (- z)) (expt (- 1.0) v)))
   ; Conjugation for complex order and real argument
   ((and (< (realpart v) 0.0) (null (zerop (imagpart v))) (floatp z))
     (conjugate (BesselI (conjugate v) z)))
   ; We now know that Re(z)>= 0.0 (asymptotic argument case)
   ((< b1 (abs z))
     (FloatError "BesselI not implemented for ~S" (list v z)))
   ((< b1 (abs v))
     (FloatError "BesselI not implemented for ~S" (list v z)))
   ; case of small argument and order
   ((not (< (realpart v) 0.0))
     (besselIback v z))
   ((< (realpart v) 0.0)
     (besselIcheb z v 50))
   (t
     (FloatError "BesselI not implemented for ~S" (list v z))))))

\end{chunk}

\defun{besselIback}{besselIback}
\calls{besselIback}{BesselIBackRecur}
\calls{besselIback}{cgammaImpl}
\begin{chunk}{defun besselIback}
(defun besselIback (v z)
 (let (result vp1 tv n m lm rpv ipv)
  (setq ipv (imagpart v))
  (setq rpv (realpart v))
  (setq lm (multiple-value-list (floor rpv)))
  (setq m (car lm))                ; floor of real part of v
  (setq n (* 2 (max 20 (+ m 10)))) ; how large the back recurrence should be
  (setq tv (+ (cadr lm) (- v rpv))); fractional part of real part of v
                                   ; plus imaginary part of v
  (setq vp1 (+ tv 1.0))
  (setq result (BesselIBackRecur v m tv z "I" n))
  (setq result (* (/ result (cgammaImpl vp1)) (expt (/ z 2.0) tv)))))

\end{chunk}

\defun{BesselIBackRecur}{Backward recurrence for Bessel functions}
Backward recurrence for Bessel functions.  Luke (1975), p. 247.
works for $-\pi < arg z <= \pi$ and  $-\pi < arg v <= \pi$
\begin{chunk}{defun BesselIBackRecur 0}
(defun BesselIBackRecur (largev argm v z type n)
 (declare (ignore largev))
 (let (v1 pn ct1 xm m m1 val w m2 z2 start zero two one)
  (setq one 1.0)
  (setq two 2.0)
  (setq zero 0.0)
  (setq start (expt 10.0 (- 40)))
  (setq z2 (/ two z))
  (setq m2 (+ n 3))
  (setq w (make-array (+ m2 1)))
  (setf (aref w m2) zero)
  (if (string= type "I")
    (setq val one)
    (setq val (- one)))
  (setq m1 (+ n 2))
  (setf (aref w m1) start)
  (setq m (+ n 1))
  (setq xm (float m))
  (setq ct1 (* z2 (+ xm v)))
  ; initialize
  (loop for m from (+ n 1) downto 1 by 1 do
    (setf (aref w m) (+ (* (aref w (+ m 1)) ct1) (* val (aref w (+ m 2)))))
    (setq ct1 (- ct1 z2)))
  (setq m (+ 1 (floor (/ n 2))))
  (setq m2 (- (+ m m) 1))
  (cond
    ((eql v 0)
     (setq pn (aref w (+ m2 2)))
     (loop for m2 from (- (* 2 m) 1) downto 3 by 2 do
       (setq pn (- (aref w m2) (* val pn))))
     (setq pn (- (aref w 1) (* val (+ pn pn)))))
    ('T (setq v1 (- v one)) (setq xm (float m))
     (setq ct1 (+ (+ v xm) xm))
     (setq pn (* ct1 (aref w (+ m2 2))))
     (loop for m2 from (- (+ m m) 1) downto 3 by 2 do
       (setq ct1 (- ct1 two))
       (setq pn (- (* ct1 (aref w m2)) (* (/ (* val pn) xm) (+ v1 xm))))
       (setq xm (- xm one)))
     (setq pn (- (aref w 1) (* val pn)))))
  (setq m1 (+ n 2))
  (loop for m from 1 to m1 do
    (setf (aref w m) (/ (aref w m) pn)))
  (aref w (+ argm 1))))

\end{chunk}


\defun{besselIcheb}{Compute n terms of the chebychev series for f01}
\calls{besselIcheb}{chebf01coefmake}
\calls{besselIcheb}{chebstarevalarr}
\calls{besselIcheb}{cgammaImpl}
\begin{chunk}{defun besselIcheb}
(defun besselIcheb (z v n)
 (let (result arr sum tmp1 vp1 w arg)
  (setq arg (/ (* z z) 4.0))
  (setq w (* 2.0 arg))
  (setq vp1 (+ v 1.0))
  (setq tmp1 (chebf01coefmake vp1 w n))
  (setq sum (car tmp1))
  (setq arr (cadr tmp1))
  (setq result
    (* (/ (chebstarevalarr arr (/ arg w) n) (cgammaImpl vp1))
       (expt (/ z 2.0) v)))))

\end{chunk}

\defun{chebf01coefmake}{chebf01coefmake}
Program transcribed from Fortran,, p. 80 Luke 1977 \cite{Luke77}

where $c$ is a parameter to 0F1, $w$ is a scale factor so that $0<z/w<1$,
$n$ such that $n+2$ coefficients will be produced stored in an array
indexed from $0$ to $n+1$.
The $arr$ array will be used to store the Cheb. series coefficients

\begin{chunk}{defun chebf01coefmake 0}
(defun chebf01coefmake (c w n)
 (let (p sum rho divfac c1 x1 arr ncount z1 a1 a2 a3 n2 n1 start four)
  (setq four 4.0)
  (setq start (expt 10.0 (- 200)))
  (setq n1 (+ n 1))
  (setq n2 (+ n 2))
  (setq a3 0.0)
  (setq a2 0.0)
  (setq a1 start)      ; arbitrary starting value
  (setq z1 (/ four w))
  (setq ncount n1)
  (setq arr (make-array n2))
  (setf (aref arr ncount) start) ; start off
  (setq x1 n2)
  (setq c1 (- 1.0 c))
  (loop for ncount from n downto 0 do
    (setq divfac (/ 1.0 x1))
    (setq x1 (- x1 1.0))
    (setf (aref arr ncount)
      (* x1
       (- (+ (* (+ divfac (* z1 (- x1 c1))) a1)
             (* (+ (/ 1.0 x1) (* z1 (+ (+ x1 c1) 1.0))) a2))
          (* divfac a3))))
    (setq a3 a2)
    (setq a2 a1)
    (setq a1 (aref arr ncount)))
  (setf (aref arr 0) (/ (aref arr 0) 2.0))
  ; compute scale factor
  (setq rho (aref arr 0))
  (setq sum rho)
  (setq p 1.0)
  (loop for i from 1 to n1 do
   (setq rho (- rho (* p (aref arr i))))
   (setq sum (+ sum (aref arr i)))
   (setq p (- p)))
  (loop for l from 0 to n1 do
   (setf (aref arr l) (/ (aref arr l) rho)))
  (setq sum (/ sum rho))
  (list sum arr)))

\end{chunk}

\defun{chebstarevalarr}{chebstarevalarr}
Evaluation of the sum(C(n)*T*(n,x))
\begin{chunk}{defun chebstarevalarr 0}
(defun chebstarevalarr (coefarr x n)
 (let (c y temp b)
  (setq b 0)
  (setq temp 0)
  (setq y (* 2 (- (* 2 x) 1)))
  (loop for i from (+ n 1) downto 0 do
    (setq c b)
    (setq b temp)
    (setq temp (+ (- (* y b) c) (aref coefarr i))))
   (- temp (/ (* y b) 2))))

\end{chunk}

\defun{lncgamma}{lncgamma}
\calls{lncgamma}{clngamma}
\begin{chunk}{defun lncgamma}
(defun lncgamma (z)
 (clngammaImpl (realpart z) (imagpart z) z))

\end{chunk}

\defun{rPsiImpl}{rPsiImpl}
\calls{rPsiImpl}{FloatError}
\calls{rPsiImpl}{cotdiffeval}
\calls{rPsiImpl}{rPsiImpl}
\calls{rPsiImpl}{rPsiW}
\calls{rPsiImpl}{rgammaImpl}
\begin{chunk}{defun rPsiImpl}
(defun rPsiImpl (n x)
 (let (skipit sign m)
  (cond
   ((not (< 0.0 x))
     (cond
       ((zerop (fracpart x))
         (FloatError "singularity encountered at ~D" x))
       (t
        (setq m (mod n 2))
        (setq sign (expt (- 1) m))
        (if (equal (fracpart x) 0.5)
         (setq skipit 1)
         (setq skipit 0))
        (* sign
          (+ (* (expt Pi (+ n 1))
                (cotdiffeval n (* Pi (- x)) skipit))
             (rPsiImpl n (- 1.0 x)))))))
   ((eql n 0) (- (rPsiW n x)))
   (t
     (* (* (rgammaImpl (float (+ n 1))) (rPsiW n x))
        (expt (- 1) (mod (+ n 1) 2)))))))

\end{chunk}

\defun{cotdiffeval}{cotdiffeval}
Code for computation of derivatives of cot(z), necessary for
polygamma reflection formula.  If you want to compute $n^{th}$ derivatives of
$\cot(\pi*x)$, you have to multiply the result of cotdiffeval by $\pi^n$.

Set $skip=1$ if arg $z$ is known to be an exact multiple of $\pi/2$
\begin{chunk}{defun cotdiffeval 0}
(defun cotdiffeval (n z skipit)
 (let (s sq v t2 t1 m a)
  (setq a (make-array (+ n 2)))
  (setf (aref a 0) 0.0)
  (setf (aref a 1) 1.0)
  (loop for i from 2 to n do 
    (setf (aref a i) 0.0))
  (loop for r from 1 to n do
    (setq m (mod (+ r 1) 2))
    (loop for k from m to (+ z 1) by 2 do
      (if (< k 1)
        (setq t1 0)
        (setq t1 (- (* (aref a (- k 1)) (- k 1)))))
      (if (< r k)
        (setq t2 0)
        (setq t2 (- (* (aref a (+ k 1)) (+ k 1)))))
      (setf (aref a k) (+ t1 t2))))
  ; evaluate d^N/dX^N cot(z) via Horner-like rule
  (setq v (cot z))
  (setq sq (* v v))
  (setq s (aref a (+ n 1)))
  (loop for i from (- n 1) downto 0 by 2 do
    (setq s (+ (* s sq) (aref a i))))
  (setq m (mod n 2))
  (when (eql m 0) (setq s (* s v)))
  (if (eql skipit 1)
   (if (eql m 0) 0 (aref a 0))
   s)))

\end{chunk}

\defun{rPsiW}{Amos' w function}
Amos' w function, with w(0,x) picked to be $-\psi(x)$ for $x>0$
\calls{rPsiW}{PsiAsymptoticOrder}
\calls{rPsiW}{PsiAsymptotic}
\calls{rPsiW}{PsiBack}
\begin{chunk}{defun rPsiW}
(defun rPsiW (n x)
 (let (bign fln c a xmin beta alpha nd result)
  (when (or (not (< 0 x)) (minusp n))
   (error "rPsiW not implemented for negative n or non-positive x"))
  (setq nd 6) ; magic number for number of digits in a word?
  (setq alpha (+ 3.5 (* 0.40000000000000002 nd)))
  (setq beta
   (+ (+ 0.20999999999999999 (* 8.6770000000000001E-6 (- nd 3)))
      (* 6.0380000000000002E-8 (expt (- nd 3) 2))))
  (setq xmin (float (+ (floor (+ alpha (* beta n))) 1)))
  (when (< 0 n)
    (setq a
     (min 0 (* (/ 1.0 (float n)) (log (/ double-float-epsilon (min 1.0 x))))))
    (setq c (exp a))
    (if (not (< (abs a) 0.001))
      (setq fln (* (/ x c) (- 1.0 c)))
      (setq fln (- (/ (* x a) c))))
    (setq bign (+ (floor fln) 1))
    ; Amos says to use alternative series for large order if ordinary
    ; backwards recurrence too expensive
    (when (and (< bign 15) (< (+ 7.0 x) xmin))
      (setq result (PsiAsymptoticOrder n x bign))))
  (when (and (not result) (not (< x xmin)))
    (setq result (PsiAsymptotic n x)))
  (unless result
    ; ordinary case -- use backwards recursion
    (setq result (PsiBack n x xmin)))
  result))

\end{chunk}

\defun{PsiAsymptoticOrder}{PsiAsymptoticOrder}
\begin{chunk}{defun PsiAsymptoticOrder 0}
(defun PsiAsymptoticOrder (n x nterms)
  (loop for k from 0 to nterms 
   sum (/ 1.0 (expt (+ x (float k)) (+ n 1)))))

\end{chunk}

\defun{PsiBack}{PsiBack}
\calls{PsiBack}{PsiIntpart}
\calls{PsiBack}{PsiAsymptotic}
\begin{chunk}{defun PsiBack}
(defun PsiBack (n x xmin)
 (let (result x0 xintpart)
  (setq xintpart (PsiIntpart x))
  (setq x0 (- x xintpart)) ; frac part of x
  (setq result (PsiAsymptotic n (+ (+ x0 xmin) 1.0)))
  ; Why not decrement from x?   See Amos p. 498
  (loop for k from xmin downto xintpart by 1 do
    (setq result (+ result (/ 1.0 (expt (+ x0 (float k)) (+ n 1))))))
  result))

\end{chunk}

\defvar{PsiAsymptoticBern}
The $n^{th}$ derivatives of ln gamma for real $x$, $n = 0,1,\ldots$
\begin{chunk}{initvars}
(defvar |$PsiAsymptoticBern|
  (vector 0.0 0.16666666666666669   (- 0.033333333333333333)
              0.023809523809523812  (- 0.033333333333333333)
              0.07575757575757576   (- 0.2531135531135531)
              1.1666666666666672    (- 7.0921568627450986)
             54.971177944862163   (- 529.12424242424242)
           6192.123188405797    (- 86580.253113553103)
        1425517.166666667           (- 2.729823106781609E7)
              6.015808739006424E8   (- 1.5116315767092161E10)
              4.2961464306116675E11 (- 1.371165520508833E13)
              4.8833231897359325E14 (- 1.9296579341940072E16)
              8.4169304757368269E17 (- 4.0338071854059463E19)))

\end{chunk}

\defun{PsiAsymptotic}{PsiAsymptotic}
\usesdollar{PsiAsymptotic}{PsiAsymptoticBern}
\calls{PsiAsymptotic}{rgammaImpl}
\calls{PsiAsymptotic}{PsiEps}
\begin{chunk}{defun PsiAsymptotic}
(defun PsiAsymptotic (n x)
 (let (sum factterm xterm xsq xnp1 xn)
 (declare (special |$PsiAsymptoticBern|))
  (setq xn (expt x n))
  (setq xnp1 (* xn x))
  (setq xsq (* x x))
  (setq xterm xsq)
  (setq factterm (/ (/ (rgammaImpl (+ n 2)) 2.0) (rgammaImpl (float (+ n 1)))))
  ; initialize to 1/n!
  (setq sum (/ (* (aref |$PsiAsymptoticBern| 1) factterm) xterm))
  (loop for k from 2 to 22 do
    (setq xterm (* xterm xsq))
    (cond
     ((eql n 0) (setq factterm (/ 1.0 (float (* 2 k)))))
     ((eql n 1) (setq factterm 1))
     (t
      (setq factterm
       (/ (* (* factterm (float (- (+ (* 2 k) n) 1)))
             (float (- (+ (* 2 k) n) 2)))
          (* (float (* 2 k)) (float (- (* 2 k) 1)))))))
    (setq sum (+ sum (/ (* (aref |$PsiAsymptoticBern| k) factterm) xterm))))
  (+ (+ (PsiEps n x) (/ 1.0 (* 2.0 xnp1))) (* (/ 1.0 xn) sum))))

\end{chunk}

\defun{PsiEps}{PsiEps}
\begin{chunk}{defun PsiEps 0}
(defun PsiEps (n x)
  (if (eql n 0)
    (- (log x))
    (/ 1.0 (* (float n) (expt x n)))))

\end{chunk}

\defun{PsiIntpart}{PsiIntpart}
\begin{chunk}{defun PsiIntpart 0}
(defun PsiIntpart (x)
 (if (minusp x)
  (- (PsiIntpart (- x)))
  (floor x)))

\end{chunk}

\defun{cPsiImpl}{cPsiImpl}
\begin{chunk}{defun cPsiImpl}
(defun cPsiImpl (n z)
 (prog (result m bound nterms conjresult y x)
  (return
   (progn
    (setq x (realpart z))
    (setq y (imagpart z))
    (cond ((zerop y) (return (rPsiImpl n x)))) ; call real function if real
    (when (< y 0.0) ; if imagpart(z) negative, take conjugate of conjugate
      (setq conjresult (cPsiImpl n (complex x (- y))))
      (return (complex (realpart conjresult) (- (imagpart conjresult)))))
    (setq nterms 22)
    (setq bound 10.0)
    (cond
      ((< x 0.0)
        (FloatError "Psi implementation can't compute at ~S " (list n z)))
      ((and (< 0.0 x) (< bound (abs z)))
        (return (PsiXotic n (PsiAsymptotic n z))))
      (t  ; use recursion formula
       (setq m (ceiling (+ (- (sqrt (- (* bound bound) (* y y))) x) 1.0)))
       (setq result (complex 0.0 0.0))
       (loop for k from 0 to (- m 1) do
         (setq result (+ result (/ 1.0 (expt (+ z (float k)) (+ n 1))))))
       (return (PsiXotic n (+ result (PsiAsymptotic n (+ z m)))))))))))

\end{chunk}

\defun{PsiXotic}{PsiXotic}
The $n^{th}$ derivatives of ln gamma for complex $z$, $n=0,1,\ldots$
requires files rpsi (and dependents), floaterrors
currently defined only in right half plane until reflection formula works
\begin{chunk}{defun PsiXotic}
(defun PsiXotic (n result)
 (* (* (rgammaImpl (float (+ n 1))) (expt (- 1) (mod (+ n 1) 2))) result))

\end{chunk}

\defun{BesselJ}{BesselJ}
BesselJ works for complex and real values of v and z
\begin{chunk}{defun BesselJ}
(defun BesselJ (v z)
 (let (arr sum t1 vp1 w arg rz rv n b2 b1)
  (setq b1 10)  ; Ad hoc boundaries for approximation
  (setq b2 10)
  (setq n 50)   ; number of terms in Chebychev series.
  (cond
   ; tests for negative integer order
   ((or (and (floatp v) (zerop (fracpart v)) (minuspl v))
        (and (complexp v) (zerop (imagpart v)) (zerop (fracpart (realpart v)))
             (< (realpart v) 0.0)))
     ; odd or even according to v (9.1.5 A&S)
     ; $J_{-n}(z)=(-1)^{n} J_{n}(z)$
     (* (BesselJ (- v) z) (expt (- 1.0) v)))
   ((or (and (floatp z) (minusp z)) (and (complexp z) (< (realpart z) 0.0)))
     ; negative argument (9.1.35 A&S) 
     ; $J_{\nu}(z e^{m \pi i}) = e^{m \nu \pi i} J_{\nu}(z)$
     (* (BesselJ v (- z)) (expt (- 1.0) v)))
   ((and (zerop z)
         (or (and (floatp v) (not (< v 0.0)))
             (and (complexp v) (zerop (imagpart v)) 
                  (not (< (realpart v) 0.0)))))
     ; zero arg, pos. real order
     (if (zerop v) 1.0 0.0))
    (t
      (setq rv (abs v))
      (setq rz (abs z))
      (cond
       ((and (< b1 rz) (< (* b2 rv) rz))   ; asymptotic argument
         (BesselJAsympt v z))
       ((and (< b1 rv) (< (* b2 rz) rv))   ; asymptotic order
         (BesselJAsymptOrder v z))
       ((and (< rz b1) (< rv b1))          ; small order and argument
          (setq arg (- (/ (* z z) 4.0)))
          (setq w (* 2.0 arg))
          (setq vp1 (+ v 1.0))
          (setq t1 (chebf01coefmake vp1 w n))
          (setq sum (car t1))
          (setq arr (cadr t1))
          ; if we get NaNs then half n
          ((lambda ()
             (loop
              (cond
               ((= sum sum) (return nil))
               (t
                 (setq n (floor (/ n 2)))
                 (setq t1 (chebf01coefmake vp1 w n))
                 (setq sum (car t1))
                 (setq arr (cadr t1))
                 t1)))))
          ; now n is safe, can we increase it (we know that 2*n is bad)?
          (* (/ (chebstarevalarr arr (/ arg w) n) (cgammaImpl vp1))
             (expt (/ z 2.0) v)))
      (t (BesselJRecur v z)))))))

\end{chunk}

Asymptotic functions for large values of z.  See Luke \cite{Luke69a} p. 204
where 
{\bf mu} is $4v^2$, {\bf zsqr} is $z^2$, and {\bf zfth}  is $z^4$

\defun{BesselJAsympt}{Asymptotic series for BesselJ}
Asymptotic series only works when $|v| < |z|$.
\begin{chunk}{defun BesselJAsympt}
(defun BesselJAsympt (v z)
 (let (zfth zsqr mu)
   (setq mu (* (* 4.0 v) v))
   (setq zsqr (* z z))
   (setq zfth (* zsqr zsqr))
   (* (* (sqrt (/ 2.0 (* Pi z))) (exp (BesselasymptA mu zsqr zfth)))
      (cos (- (- (BesselasymptB mu z zsqr zfth)
                 (/ (* Pi v) 2.0))
              (/ Pi 4.0))))))

\end{chunk}

\defun{BesselasymptA}{BesselasymptA}
\begin{chunk}{defun BesselasymptA 0}
(defun BesselasymptA (mu zsqr zfth)
  (* (/ (- mu 1) (* 16.0 zsqr))
     (+ (+ 1 (/ (- mu 13.0) (* 8.0 zsqr)))
        (/ (+ (- (* mu mu) (* 53.0 mu)) 412.0)
           (* 48.0 zfth)))))

\end{chunk}

\defun{BesselasymptB}{BesselasymptB}
\begin{chunk}{defun BesselasymptB 0}
(defun BesselasymptB (mu z zsqr zfth)
 (let ((musqr (* mu mu)))
   (+ z
      (* (/ (- mu 1.0) (* 8.0 z))
         (+ (+ (+ 1.0 (/ (- mu 25.0) (* 48.0 zsqr)))
               (/ (+ (- musqr (* 114.0 mu)) 1073.0) (* 640.0 zfth)))
            (/ (- (+ (- (* (* 5.0 mu) musqr) (* 1535.0 musqr))
                     (* 54703.0 mu))
                  375733.0)
               (* (* 128.0 zsqr) zfth)))))))

\end{chunk}

\defun{BesselJRecur}{BesselJRecur}
\begin{chunk}{defun BesselJRecur}
(defun BesselJRecur (v z)
 (let (w m so)
  ; boost order. Numerical.Recipes. suggest so:=v+sqrt(n.s.f.^2*v)
  (setq so (* 15.0 z))
  ; reduce order until non-zero
  (loop while (not (zerop (abs (BesselJAsymptOrder so z)))) do
    (setq so (/ so 2.0)))
  (when (< (abs so) (abs z))
    (setq so (+ v (* 18.0 (sqrt v)))))
  (setq m (+ (floor (abs (- so v))) 1))
  (setq w (make-array m))
  (setf (aref w (- m 1)) (BesselJAsymptOrder (- (+ v m) 1) z))
  (setf (aref w (- m 2)) (BesselJAsymptOrder (- (+ v m) 2) z))
  (loop for i from (- m 3) downto 0 by 1 do
    (setf (aref w i)
      (- (/ (* (* 2.0 (+ (+ v i) 1.0)) (aref w (+ i 1))) z)
         (aref w (+ i 2)))))
  (aref w 0)))

\end{chunk}

\defun{BesselJAsymptOrder}{BesselJAsymptOrder}

Asymptotic formula for BesselJ when order is large comes from
Debye (1909).  See Olver, Asymptotics and Special Functions, p. 134.

Expansion good for $0 <= phase(v) < \pi$

A\&S recommend ``uniform expansion'' with complicated coefficients 
and Airy function.

Debye's Formula is in 9.3.7,9.3.9,9.3.10 of A\&S

AXIOM recurrence for $u_{k}$
\begin{verbatim}
  f(0)==1::EXPR INT
  f(n)== (t^2)*(1-t^2)*D(f(n-1),t)/2 + (1/8)*integrate( (1-5*t^2)*f(n-1),t)
\end{verbatim}

\begin{chunk}{defun BesselJAsymptOrder}
(defun BesselJAsymptOrder (v z)
 (let (ca8 ca4 ca2 ca tanhalpha alpha sechalpha)
  (setq sechalpha (/ z v))
  (setq alpha (acosh (/ 1.0 sechalpha)))
  (setq tanhalpha (sqrt (- 1.0 (* sechalpha sechalpha))))
  (setq ca (/ 1.0 tanhalpha))
  (setq ca2 (* ca ca))
  (setq ca4 (* ca2 ca2))
  (setq ca8 (* ca4 ca4))
  (* (/ (exp (- (* v (- alpha tanhalpha))))
              (sqrt (* (* (* 2.0 Pi) v) tanhalpha)))
     (+ (+ (+ (+ (+ (+ 1.0 (/ (* (horner '(-5.0 3.0) ca2) ca)
                              (* v 24.0)))
                    (/ (* (horner '(385.0 -462.0 81.0) ca2) ca2)
                       (* (* 1152.0 v) v)))
                 (/ (* (* (horner
                            '(-425425.0 765765.0 -369603.0 30375.0)
                            ca2)
                          ca2)
                       ca)
                    (* (* (* 414720.0 v) v) v)))
              (/ (* (horner
                      '(1.85910725E8 -4.4618574E8 3.4992243E8 
                        -9.4121676E7 4465125.0)
                      ca2)
                    ca4)
                 (* (* (* (* 3.981312E7 v) v) v) v)))
           (/ (* (* (horner
                      '(-1.88699385875E11 5.66098157625E11
                        -6.1413587235E11  2.84499769554E11
                        -4.9286948607E10  1.519035525E9)
                      ca2)
                    ca4)
                  ca)
              (* (* (* (* (* 6.68860416E9 v) v) v) v) v)))
        (/ (* (* (horner
                   '(1.023694168371875E15 -3.6852990061387505E15
                     5.104696716244125E15 -3.36903206826186E15
                     1.050760774457901E15 -1.2757729835475E14
                     2.757049477875E12)
                   ca2)
                 ca4)
              ca2)
           (* (* (* (* (* (* 4.8157949952E12 v) v) v) v) v) v))))))

\end{chunk}

\defun{chebf01}{chebf01}
Where:

$c$ parameter to 0F1, possibly complex\\
$z$ argument to 0F1\\
$w$ scale factor so that $0 < \frac{z}{w} < 1$\\
$n$, $n+2$ coefficients will be produced stored in an array
indexed from $0$ to $n+1$.

Program transcribed from Fortran,, p. 80 \cite{Luke77}

\begin{chunk}{defun chebf01}
(defun chebf01 (c z)
 (let (cc temp b p sum rho divfac c1 x1 arr
       ncount z1 a1 a2 a3 n2 n1 start four w n)
  (setq n 75)                       ; ad hoc decision
  (setq w (* 2.0 z))
  ; arr will be used to store the Cheb. series coefficients
  (setq four 4.0)
  (setq start (expt 10.0 -200))
  (setq n1 (+ n 1))
  (setq n2 (+ n 2))
  (setq a3 0.0)
  (setq a2 0.0)
  (setq a1 start)                   ; arbitrary starting value
  (setq z1 (/ four w))
  (setq ncount n1)
  (setq arr (make-array n2))
  (setf (aref arr ncount) start)  ; start off
  (setq x1 n2)
  (setq c1 (- 1.0 c))
  (loop for ncount from n downto 0 by 1 do
    (setq divfac (/ 1.0 x1))
    (setq x1 (- x1 1.0))
    (setf (aref arr ncount)
      (* x1 (- (+ (* (+ divfac (* z1 (- x1 c1))) a1)
                  (* (+ (/ 1.0 x1) (* z1 (+ (+ x1 c1) 1.0))) a2))
               (* divfac a3))))
    (setq a3 a2)
    (setq a2 a1)
    (setq a1 (aref arr ncount)))
  (setf (aref arr 0) (/ (aref arr 0) 2.0))
  ; compute scale factor
  (setq rho (aref arr 0))  
  (setq sum rho)
  (setq p 1.0)
  (loop for i from 1 to n1 do
    (setq rho (- rho (* p (aref arr i))))
    (setq sum (+ sum (aref arr i)))
    (setq p (- p)))
  (loop for m from 0 to n1 do
    (setf (aref arr m) (/ (aref arr m) rho)))
  (setq sum (/ sum rho))
  ; Now evaluate array at argument
  (setq b 0.0)
  (setq temp 0.0)
  (loop for i from (+ n 1) downto 0 by 1 do
    (setq cc b)
    (setq b temp)
    (setq temp (+ (- cc) (aref arr i))))
  temp))

\end{chunk}

\chapter{Common Lisp Algebra Support}
These functions are called directly from the algebra source code.
They fall into two basic categories, one are the functions that are
raw Comon Lisp calls and the other are Axiom specific functions or macros.

Raw function calls are used where there is an alignment of the Axiom
type and the underlying representation in Common Lisp. These form the
support pillars upon which Axiom rests. For instance, the 'EQ' function is
called to support the Axiom equivalent 'eq?' function.

Macros are used to add type information in order to make low level
operations faster. An example is the use of macros in DoubleFloat to
add Common Lisp type information. Since DoubleFloat is machine arithmetic
we give the compiler explicit type information so it can generate fast code.

Functions are used to do manipulations which are Common Lisp operations
but the Axiom semantics are not the same. Because Axiom was originally
written in Maclisp, then VMLisp, and then Common Lisp some of these old
semantics survive. 

%%% A %%%

\section{\enspace{}AlgebraicFunction}
\defun{retract}{retract}
\calls{retract}{objMode}
\calls{retract}{objVal}
\calls{retract}{isWrapped}
\calls{retract}{qcar}
\calls{retract}{retract1}
\calls{retract}{mkObj}
\refsdollar{retract}{EmptyMode}
\begin{chunk}{defun retract}
(defun |retract| (object)
 (labels (
  (retract1 (object)
   (let (type val underDomain objectp)
   (declare (special |$SingleInteger| |$Integer| |$NonNegativeInteger|
                     |$PositiveInteger|))
    (setq type (|objMode| object))
    (cond
     ((stringp type) '|failed|)
     (t 
       (setq val (|objVal| object))
       (cond
        ((equal type |$PositiveInteger|) (mkObj val |$NonNegativeInteger|))
        ((equal type |$NonNegativeInteger|) (mkObj val |$Integer|))
        ((and (equal type |$Integer|) (typep (|unwrap| val) 'fixnum))
          (mkObj val |$SingleInteger|))
        (t 
          (cond
           ((or (eql 1 (|#| type))
                (and (consp type) (eq (qcar type) '|Union|))
                (and (consp type) (eq (qcar type) '|FunctionCalled|)
                     (and (consp (qcdr type)) (eq (qcddr type) nil)))
                (and (consp type) (eq (qcar type) '|OrderedVariableList|)
                     (and (consp (qcdr type)) (eq (qcddr type) nil)))
                (and (consp type) (eq (qcar type) '|Variable|)
                     (and (consp (qcdr type)) (eq (qcddr type) nil))))
             (if (setq objectp (|retract2Specialization| object))
               objectp
               '|failed|))
           ((null (setq underDomain (|underDomainOf| type)))
             '|failed|)
          ; try to retract the "coefficients", e.g. P RN -> P I or M RN -> M I
           (t
            (setq objectp (|retractUnderDomain| object type underDomain))
            (cond
             ((not (eq objectp '|failed|)) objectp)
             ; see if we can use the retract functions
             ((setq objectp (|coerceRetract| object underDomain)) objectp)
             ; see if we have a special case here
             ((setq objectp (|retract2Specialization| object)) objectp)
           (t '|failed|)))))))))))
 (let (type val ans)
 (declare (special |$EmptyMode|))
  (setq type (|objMode| object))
  (cond
   ((stringp type) '|failed|)
   ((equal type |$EmptyMode|) '|failed|)
   (t 
    (setq val (|objVal| object))
    (cond
     ((and (null (|isWrapped| val))
           (null (and (consp val) (eq (qcar val) 'map))))
       '|failed|)
     (t 
      (cond
       ((eq (setq ans (retract1 (mkObj val type))) '|failed|)
         ans)
       (t
        (mkObj (|objVal| ans) (|objMode| ans)))))))))))

\end{chunk}

\section{\enspace{}Any}
\defun{spad2BootCoerce}{spad2BootCoerce}
\begin{chunk}{defun spad2BootCoerce}
(defun |spad2BootCoerce| (x source target)
 (let (xp)
  (cond
   ((null (|isValidType| source))
    (|throwKeyedMsg| "%1p is not a valid type." (list source)))
   ((null (|isValidType| target))
    (|throwKeyedMsg| "%1p is not a valid type." (list target)))
   ((setq xp (|coerceInteractive| (mkObjWrap x source) target))
     (|objValUnwrap| xp))
   (t
    (|throwKeyedMsgCannotCoerceWithValue| (|wrap| x) source target)))))

\end{chunk}

\section{ApplicationProgramInterface}
\defun{reportinstantiations}{Report what domains get instantiated}
\usesdollar{reportinstantiations}{reportinstantiations}
\begin{chunk}{defun reportinstantiations}
(defun reportinstantiations (b)
 (setq |$reportInstantiations| b))
\end{chunk}

%%% B %%%

\section{\enspace{}Boolean}
\defun{BooleanEquality}{The Boolean = function support}
\begin{chunk}{defun BooleanEquality 0}
(defun |BooleanEquality| (x y) (if x y (null y)))

\end{chunk}

%%% C %%%

\section{\enspace{}Char}

\defun{upcase}{upcase}
\calls{upcase}{identp}
\calls{upcase}{upcase}
\begin{chunk}{defun upcase}
(defun upcase (l)
  (cond ((stringp l) (string-upcase l))
        ((identp l) (intern (string-upcase (symbol-name l))))
        ((characterp l) (char-upcase l))
        ((atom l) l)
        (t (mapcar #'upcase l))))

\end{chunk}

\defun{downcase}{downcase}
\calls{downcase}{identp}
\calls{downcase}{downcase}
\begin{chunk}{defun downcase}
(defun downcase (l)
  (cond ((stringp l) (string-downcase l))
        ((identp l) (intern (string-downcase (symbol-name l))))
        ((characterp l) (char-downcase L))
        ((atom l) l)
        (t (mapcar #'downcase l))))

\end{chunk}

\section{\enspace{}ComplexDoubleFloatMatrix}

\defmacro{make-cdouble-matrix}{ComplexDoubleFloatMatrix function support}
\begin{chunk}{defmacro make-cdouble-matrix 0}
(defmacro make-cdouble-matrix (n m)
 `(make-array (list ,n (* 2 ,m)) :element-type 'double-float))

\end{chunk}

\defmacro{cdaref2}{ComplexDoubleFloatMatrix function support}
\begin{chunk}{defmacro cdaref2 0}
(defmacro cdaref2 (ov oi oj)
   (let ((v (gensym))
         (i (gensym))
         (j (gensym)))
   `(let ((,v ,ov)
          (,i ,oi)
          (,j ,oj))
        (cons
            (aref (the (simple-array double-float (* *)) ,v) ,i (* 2 ,j))
            (aref (the (simple-array double-float (* *)) ,v)
                  ,i (+ (* 2 ,j) 1))))))

\end{chunk}

\defmacro{cdsetaref2}{ComplexDoubleFloatMatrix function support}
\begin{chunk}{defmacro cdsetaref2 0}
(defmacro cdsetaref2 (ov oi oj os)
   (let ((v (gensym))
         (i (gensym))
         (j (gensym))
         (s (gensym)))
   `(let ((,v ,ov)
          (,i ,oi)
          (,j ,oj)
          (,s ,os))
         (setf (aref (the (simple-array double-float (* *)) ,v) ,i (* 2 ,j))
               (car ,s))
         (setf (aref (the (simple-array double-float (* *)) ,v)
                     ,i (+ (* 2 ,j) 1))
               (cdr ,s))
         ,s)))

\end{chunk}

\defmacro{cdanrows}{ComplexDoubleFloatMatrix function support}
\begin{chunk}{defmacro cdanrows 0}
(defmacro cdanrows (v)
    `(array-dimension (the (simple-array double-float (* *)) ,v) 0))

\end{chunk}

\defmacro{cdancols}{ComplexDoubleFloatMatrix function support}
\begin{chunk}{defmacro cdancols 0}
(defmacro cdancols (v)
 `(truncate 
    (array-dimension (the (simple-array double-float (* *)) ,v) 1) 2))

\end{chunk}

\section{\enspace{}ComplexDoubleFloatVector}
Complex Double Float Vectors are simple arrays of lisp double-floats
made available at the Spad language level. Note that these vectors
are 0 based whereas other Spad language vectors are 1-based.
Complex array is implemented as an array of doubles. Each complex number
occupies two positions in the real array.

\defmacro{make-cdouble-vector}{ComplexDoubleFloatVector Qnew function support}
\begin{chunk}{defmacro make-cdouble-vector 0}
(defmacro make-cdouble-vector (n)
   `(make-array (list (* 2 ,n)) :element-type 'double-float))

\end{chunk}

\defmacro{cdelt}{ComplexDoubleFloatVector Qelt1 function support}
\begin{chunk}{defmacro cdelt 0}
(defmacro CDELT(ov oi)
   (let ((v (gensym))
         (i (gensym)))
   `(let ((,v ,ov)
          (,i ,oi))
      (cons
          (aref (the (simple-array double-float (*)) ,v) (* 2 ,i))
          (aref (the (simple-array double-float (*)) ,v) (+ (* 2 ,i) 1))))))

\end{chunk}

\defmacro{cdsetelt}{ComplexDoubleFloatVector Qsetelt1 function support}
\begin{chunk}{defmacro cdsetelt 0}
(defmacro cdsetelt(ov oi os)
   (let ((v (gensym))
         (i (gensym))
         (s (gensym)))
   `(let ((,v ,ov)
          (,i ,oi)
          (,s ,os))
        (setf (aref (the (simple-array double-float (*)) ,v) (* 2 ,i))
           (car ,s))
        (setf (aref (the (simple-array double-float (*)) ,v) (+ (* 2 ,i) 1))
           (cdr ,s))
        ,s)))

\end{chunk}

\defmacro{cdlen}{ComplexDoubleFloatVector Qsize function support}
\begin{chunk}{defmacro cdlen 0}
(defmacro cdlen(v)
  `(truncate (length (the (simple-array double-float (*)) ,v)) 2))

\end{chunk}

%%% D %%%

\section{\enspace{}Database}
\defun{stringMatches?}{Database elt function support}
\calls{stringMatches?}{basicMatch?}
\begin{chunk}{defun stringMatches?}
(defun |stringMatches?| (pattern subject)
 (when (integerp (|basicMatch?| pattern subject)) t))

\end{chunk}

\section{\enspace{}DirectProduct}
\defun{vec2list}{vec2list}
\begin{chunk}{defun vec2list 0}
(defun vec2list (vec)
 (coerce vec 'list))

\end{chunk}

\section{\enspace{}DoubleFloat}
These macros wrap their arguments with strong type information in
order to optimize doublefloat computatations. They are used directly
in the DoubleFloat domain (see Volume 10.3).

\defmacro{DFLessThan}
Compute a strongly typed doublefloat comparison
See Steele Common Lisp 1990 p293
\begin{chunk}{defmacro DFLessThan 0}
(defmacro DFLessThan (x y) 
 `(< (the double-float ,x) (the double-float ,y)))

\end{chunk}

\section{\enspace{}DoubleFloatSpecialFunctions}

\defun{rgamma}{Real Gamma $\Gamma(x)$}
\calls{rgamma}{rgammaImpl}
\begin{chunk}{defun rgamma}
(defun rgamma (x)
  (rgammaImpl x))

\end{chunk}

\defun{cgamma}{Complex Gamma $\Gamma(z)$}

The cgamma(z) function is the $\Gamma$ function for complex arguments 
implemented by Bruce Char, April-May, 1990.

Our text for complex gamma is H. Kuki's paper Complex Gamma
Function with Error Control"\cite{kuki72a}

It uses the reflection formula and the basic $z+1$ recurrence to
transform the argument into something that Stirling's asymptotic
formula can handle.

However along the way it does a few tricky things to reduce
problems due to roundoff/cancellation error for particular values.

Small float implementation of Gamma function.  Valid for
real arguments.  Maximum error (relative) seems to be
2-4 ulps for real $x$ $2<x<9$, and up to ten ulps for larger $x$
up to overflow.  See Hart and Cheney.
(Bruce Char, April, 1990).

\calls{cgamma}{cgammaImpl}
\calls{cgamma}{c-to-s}
\calls{cgamma}{s-to-c}
\begin{chunk}{defun cgamma}
(defun cgamma (z)
  (c-to-s (cgammaImpl (s-to-c z)) ))

\end{chunk}

\defun{clngamma}{The complex logGamma function}
\calls{clngamma}{lncgamma}
\calls{clngamma}{c-to-s}
\calls{clngamma}{s-to-c}
\begin{chunk}{defun clngamma}
(defun clngamma (z)
  (c-to-s (lncgamma (s-to-c z)) ))

\end{chunk}

\defun{rlngamma}{The real logGamma function}
\calls{rlngamma}{lnrgamma}
\begin{chunk}{defun rlngamma}
(defun rlngamma (x)
  (lnrgamma x))

\end{chunk}

\defun{rpsi}{The real Psi function}
\calls{rpsi}{rPsiImpl}
\begin{chunk}{defun rpsi}
(defun rpsi (n x)
  (rPsiImpl n x))

\end{chunk}

\defun{cpsi}{The complex Psi function}
\calls{cpsi}{c-to-s}
\calls{cpsi}{cPsi}
\calls{cpsi}{s-to-c}
\begin{chunk}{defun cpsi}
(defun cpsi (n z)
  (c-to-s (cPsiImpl n (s-to-c z)) ))

\end{chunk}

\defun{rbesselj}{The real BesselJ function}
\calls{rbesselj}{c-to-r}
\calls{rbesselj}{BesselJ}
\begin{chunk}{defun rbesselj}
(defun rbesselj (n x)
  (c-to-r (BesselJ n x)) ))

\end{chunk}

\defun{cbesselj}{The complex BesselJ function}
\calls{cbesselj}{c-to-s}
\calls{cbesselj}{BesselJ}
\calls{cbesselj}{s-to-c}
\begin{chunk}{defun cbesselj}
(defun cbesselj (v z)
  (c-to-s (BesselJ (s-to-c v) (s-to-c z)) ))

\end{chunk}
 
\defun{rbesseli}{The real BesselI function}
\calls{rbesseli}{c-to-r}
\calls{rbesseli}{BesselI}
\begin{chunk}{defun rbesseli}
(defun rbesseli (n x)
  (c-to-r (BesselI n x)) ))

\end{chunk}

\defun{cbesseli}{The complex BesselI function}
\calls{cbesseli}{c-to-s}
\calls{cbesseli}{BesselI}
\calls{cbesseli}{s-to-c}
\begin{chunk}{defun cbesseli}
(defun cbesseli (v z)
  (c-to-s (BesselI (s-to-c v) (s-to-c z)) ))

\end{chunk}

\defun{chyper0f1}{The complex hypergeometric function}
\calls{chyper0f1}{c-to-s}
\calls{chyper0f1}{chebf01}
\calls{chyper0f1}{s-to-c}
\begin{chunk}{defun chyper0f1}
(defun chyper0f1 (a z)
  (c-to-s (chebf01 (s-to-c a) (s-to-c z)) ))

\end{chunk}

\defmacro{DFUnaryMinus}
Compute a strongly typed unary doublefloat minus
See Steele Common Lisp 1990 p295
\begin{chunk}{defmacro DFUnaryMinus 0}
(defmacro DFUnaryMinus (x)
 `(the double-float (- (the double-float ,x))))

\end{chunk}

\defmacro{DFMinusp}
Compute a strongly typed unary doublefloat test for negative
See Steele Common Lisp 1990 p292
\begin{chunk}{defmacro DFMinusp 0}
(defmacro DFMinusp (x)
 `(minusp (the double-float ,x)))

\end{chunk}

\defmacro{DFZerop}
Compute a strongly typed unary doublefloat test for zero
See Steele Common Lisp 1990 p292
\begin{chunk}{defmacro DFZerop 0}
(defmacro DFZerop (x)
 `(zerop (the double-float ,x)))

\end{chunk}

\defmacro{DFAdd}
Compute a strongly typed doublefloat addition
See Steele Common Lisp 1990 p295
\begin{chunk}{defmacro DFAdd 0}
(defmacro DFAdd (x y) 
 `(the double-float (+ (the double-float ,x) (the double-float ,y))))

\end{chunk}

\defmacro{DFSubtract}
Compute a strongly typed doublefloat subtraction
See Steele Common Lisp 1990 p295
\begin{chunk}{defmacro DFSubtract 0}
(defmacro DFSubtract (x y) 
 `(the double-float (- (the double-float ,x) (the double-float ,y))))

\end{chunk}

\defmacro{DFMultiply}
Compute a strongly typed doublefloat multiplication
See Steele Common Lisp 1990 p296
\begin{chunk}{defmacro DFMultiply 0}
(defmacro DFMultiply (x y) 
 `(the double-float (* (the double-float ,x) (the double-float ,y))))

\end{chunk}

\defmacro{DFIntegerMultiply}
Compute a strongly typed doublefloat multiplication by an integer.
See Steele Common Lisp 1990 p296
\begin{chunk}{defmacro DFIntegerMultiply 0}
(defmacro DFIntegerMultiply (i y) 
 `(the double-float (* (the integer ,i) (the double-float ,y))))

\end{chunk}

\defmacro{DFMax}
Choose the maximum of two doublefloats.
See Steele Common Lisp 1990 p294
\begin{chunk}{defmacro DFMax 0}
(defmacro DFMax (x y) 
 `(the double-float (max (the double-float ,x) (the double-float ,y))))

\end{chunk}

\defmacro{DFMin}
Choose the minimum of two doublefloats.
See Steele Common Lisp 1990 p294
\begin{chunk}{defmacro DFMin 0}
(defmacro DFMin (x y) 
 `(the double-float (min (the double-float ,x) (the double-float ,y))))

\end{chunk}

\defmacro{DFEql}
Compare two doublefloats for equality, where equality is eq, or numbers of
the same type with the same value.
See Steele Common Lisp 1990 p105
\begin{chunk}{defmacro DFEql 0}
(defmacro DFEql (x y) 
 `(eql (the double-float ,x) (the double-float ,y)))

\end{chunk}

\defmacro{DFDivide}
Divide a doublefloat by a a doublefloat
See Steele Common Lisp 1990 p296
\begin{chunk}{defmacro DFDivide 0}
(defmacro DFDivide (x y) 
 `(the double-float (/ (the double-float ,x) (the double-float ,y))))

\end{chunk}

\defmacro{DFIntegerDivide}
Divide a doublefloat by an integer
See Steele Common Lisp 1990 p296
\begin{chunk}{defmacro DFIntegerDivide 0}
(defmacro DFIntegerDivide (x i) 
 `(the double-float (/ (the double-float ,x) (the integer ,i))))

\end{chunk}

\defmacro{DFSqrt}
Compute the doublefloat square root of $x$. The result will be complex
if the argument is negative.
See Steele Common Lisp 1990 p302
\begin{chunk}{defmacro DFSqrt 0}
(defmacro DFSqrt (x)
 `(sqrt (the double-float ,x)))

\end{chunk}

\defmacro{DFLogE}
Compute the doublefloat log of $x$ with the base $e$.
The result will be complex if the argument is negative.
See Steele Common Lisp 1990 p301
\begin{chunk}{defmacro DFLogE 0}
(defmacro DFLogE (x)
 `(log (the double-float ,x)))

\end{chunk}

\defmacro{DFLog}
Compute the doublefloat log of $x$ with a given base $b$.
The result will be complex if $x$ is negative.
See Steele Common Lisp 1990 p301
\begin{chunk}{defmacro DFLog 0}
(defmacro DFLog (x b)
 `(log (the double-float ,x) (the fixnum ,b)))

\end{chunk}

\defmacro{DFIntegerExpt}
Compute the doublefloat expt of $x$ with a given integer power $i$
See Steele Common Lisp 1990 p300
\begin{chunk}{defmacro DFIntegerExpt 0}
(defmacro DFIntegerExpt (x i)
 `(the double-float (expt (the double-float ,x) (the integer ,i))))

\end{chunk}

\defmacro{DFExpt}
Compute the doublefloat expt of $x$ with a given power $p$. 
The result could be complex if the base is negative and the power is 
not an integer.
See Steele Common Lisp 1990 p300
\begin{chunk}{defmacro DFExpt 0}
(defmacro DFExpt (x p)
 `(expt (the double-float ,x) (the double-float ,p)))

\end{chunk}

\defmacro{DFExp}
Compute the doublefloat exp with power $e$
See Steele Common Lisp 1990 p300
\begin{chunk}{defmacro DFExp 0}
(defmacro DFExp (x)
 `(the double-float (exp (the double-float ,x))))

\end{chunk}

\defmacro{DFSin}
Compute a strongly typed doublefloat sin
See Steele Common Lisp 1990 p304
\begin{chunk}{defmacro DFSin 0}
(defmacro DFSin (x)
 `(the double-float (sin (the double-float ,x))))

\end{chunk}

\defmacro{DFCos}
Compute a strongly typed doublefloat cos
See Steele Common Lisp 1990 p304
\begin{chunk}{defmacro DFCos 0}
(defmacro DFCos (x)
 `(the double-float (cos (the double-float ,x))))

\end{chunk}

\defmacro{DFTan}
Compute a strongly typed doublefloat tan
See Steele Common Lisp 1990 p304
\begin{chunk}{defmacro DFTan 0}
(defmacro DFTan (x)
 `(the double-float (tan (the double-float ,x))))

\end{chunk}

\defmacro{DFAsin}
Compute a strongly typed doublefloat asin. The result is complex if the 
absolute value of the argument is greater than 1.
See Steele Common Lisp 1990 p305
\begin{chunk}{defmacro DFAsin 0}
(defmacro DFAsin (x)
 `(asin (the double-float ,x)))

\end{chunk}

\defmacro{DFAcos}
Compute a strongly typed doublefloat acos. The result is complex if the 
absolute value of the argument is greater than 1.
See Steele Common Lisp 1990 p305
\begin{chunk}{defmacro DFAcos 0}
(defmacro DFAcos (x)
 `(acos (the double-float ,x)))

\end{chunk}

\defmacro{DFAtan}
Compute a strongly typed doublefloat atan
See Steele Common Lisp 1990 p305
\begin{chunk}{defmacro DFAtan 0}
(defmacro DFAtan (x)
 `(the double-float (atan (the double-float ,x))))

\end{chunk}

\defmacro{DFAtan2}
Compute a strongly typed doublefloat atan with 2 arguments

\begin{tabular}{lllc}
$y = 0$ & $x > 0$ & Positive x-axis & 0\\
$y > 0$ & $x > 0$ & Quadrant I      & $0 <$ result $< \pi/2$\\
$y > 0$ & $x = 0$ & Positive y-axis & $\pi/2$\\
$y > 0$ & $x < 0$ & Quadrant II     & $\pi/2 <$ result $<\pi$\\
$y = 0$ & $x < 0$ & Negative x-axis & $\pi$\\
$y < 0$ & $x < 0$ & Quadrant III    & $-\pi <$ result $< -\pi/2$\\
$y < 0$ & $x = 0$ & Negative y-axis & $-\pi/2$\\
$y < 0$ & $x > 0$ & Quadrant IV     & $-\pi/2 <$ result $< 0$\\
$y = 0$ & $x = 0$ & Origin          & error
\end{tabular}

See Steele Common Lisp 1990 p306
\begin{chunk}{defmacro DFAtan2 0}
(defmacro DFAtan2 (y x)
 `(the double-float (atan (the double-float ,x) (the double-float ,y))))

\end{chunk}

\defmacro{DFSinh}
Compute a strongly typed doublefloat sinh
\[(e^z-e^{-z})/2\]
See Steele Common Lisp 1990 p308
\begin{chunk}{defmacro DFSinh 0}
(defmacro DFSinh (x)
 `(the double-float (sinh (the double-float ,x))))

\end{chunk}

\defmacro{DFCosh}
Compute a strongly typed doublefloat cosh
\[(e^z+e^{-z})/2\]
See Steele Common Lisp 1990 p308
\begin{chunk}{defmacro DFCosh 0}
(defmacro DFCosh (x)
 `(the double-float (cosh (the double-float ,x))))

\end{chunk}

\defmacro{DFTanh}
Compute a strongly typed doublefloat tanh
\[(e^z-e^{-z})/(e^z+e^{-z})\]
See Steele Common Lisp 1990 p308
\begin{chunk}{defmacro DFTanh 0}
(defmacro DFTanh (x)
 `(the double-float (tanh (the double-float ,x))))

\end{chunk}

\defmacro{DFAsinh}
Compute the inverse hyperbolic sin.
\[log\left(z+\sqrt{1+z^2}\right)\]
See Steele Common Lisp 1990 p308
\begin{chunk}{defmacro DFAsinh 0}
(defmacro DFAsinh (x)
 `(the double-float (asinh (the double-float ,x))))

\end{chunk}

\defmacro{DFAcosh}
Compute the inverse hyperbolic cos. Note that the acosh function will return
a complex result if the argument is less than 1.
\[log\left(z+(z+1)\sqrt{(z-1)/(z+1)}\right)\]
See Steele Common Lisp 1990 p308
\begin{chunk}{defmacro DFAcosh 0}
(defmacro DFAcosh (x)
 `(acosh (the double-float ,x)))

\end{chunk}

\defmacro{DFAtanh}
Compute the inverse hyperbolic tan. Note that the acosh function will return
a complex result if the argument is greater than 1.
\[log\left((1+z)\sqrt{1/(1-z^2)}\right)\]
See Steele Common Lisp 1990 p308
\begin{chunk}{defmacro DFAtanh 0}
(defmacro DFAtanh (x)
 `(atanh (the double-float ,x)))

\end{chunk}

\defun{integer-decode-float-numerator}{Machine specific float numerator}
This is used in the DoubleFloat integerDecode function
\begin{chunk}{defun integer-decode-float-numerator 0}
(defun integer-decode-float-numerator (x)
 (integer-decode-float x))

\end{chunk}

\defun{integer-decode-float-denominator}{Machine specific float denominator}
This is used in the DoubleFloat integerDecode function
\begin{chunk}{defun integer-decode-float-denominator 0}
(defun integer-decode-float-denominator (x)
 (multiple-value-bind (mantissa exponent sign) (integer-decode-float x)
  (declare (ignore mantissa sign)) (expt 2 (abs exponent))))

\end{chunk}

\defun{integer-decode-float-sign}{Machine specific float sign}
This is used in the DoubleFloat integerDecode function
\begin{chunk}{defun integer-decode-float-sign 0}
(defun integer-decode-float-sign (x)
 (multiple-value-bind (mantissa exponent sign) (integer-decode-float x)
  (declare (ignore mantissa exponent)) sign))

\end{chunk}

\defun{integer-decode-float-exponent}{Machine specific float bit length}
This is used in the DoubleFloat integerDecode function
\begin{chunk}{defun integer-decode-float-exponent 0}
(defun integer-decode-float-exponent (x)
 (multiple-value-bind (mantissa exponent sign) (integer-decode-float x)
  (declare (ignore mantissa sign)) exponent))

\end{chunk}

\defun{manexp}{Decode floating-point values}
This function is used by DoubleFloat to implement the ``mantissa'' and
``exponent'' functions.
\begin{chunk}{defun manexp 0}
(defun manexp (u)
  (multiple-value-bind (f e s) 
    (decode-float u)
    (cons (* s f) e)))

\end{chunk}

\defun{cot}{The cotangent routine}
The cotangent function is defined as
\[cot(z) = \frac{1}{tan(z)}\]
\begin{chunk}{defun cot 0}
(defun cot (a)
  (if (or (> a 1000.0) (< a -1000.0))
    (/ (cos a) (sin a))
    (/ 1.0 (tan a))))

\end{chunk}

\defun{acot}{The inverse cotangent function}
The inverse cotangent (arc-cotangent) function is defined as
\[acot(z) = cot^{-1}(z) = tan^{-1}(\frac{1}{z})\]
See Steele Common Lisp 1990 pp305-307
\begin{chunk}{defun acot 0}
(defun acot (a)
  (if (> a 0.0)
    (if (> a 1.0)
       (atan (/ 1.0 a))
       (- (/ pi 2.0) (atan a)))
    (if (< a -1.0)
       (- pi (atan (/ -1.0 a)))
       (+ (/ pi 2.0) (atan (- a))))))

\end{chunk}

\defun{sec}{The secant function}
\[sec(x) = \frac{1}{cos(x)}\]
\begin{chunk}{defun sec 0}
(defun sec (x) (/ 1 (cos x)))

\end{chunk}

\defun{asec}{The inverse secant function}
\[asec(x) = acos\left(\frac{1}{x}\right)\]
\begin{chunk}{defun asec 0}
(defun asec (x) (acos (/ 1 x)))

\end{chunk}

\defun{csc}{The cosecant function}
\[csc(x) = \frac{1}{sin(x)}\]
\begin{chunk}{defun csc 0}
(defun csc (x) (/ 1 (sin x)))

\end{chunk}

\defun{acsc}{The inverse cosecant function}
\[acsc(x) = \frac{1}{asin(x)}\]
\begin{chunk}{defun acsc 0}
(defun acsc (x) (asin (/ 1 x)))

\end{chunk}

\defun{csch}{The hyperbolic cosecant function}
\[csch(x) = \frac{1}{sinh(x)} \]
\begin{chunk}{defun csch 0}
(defun csch (x) (/ 1 (sinh x)))

\end{chunk}

\defun{coth}{The hyperbolic cotangent function}
\[coth(x) = cosh(x) csch(x)\]
\begin{chunk}{defun coth 0}
(defun coth (x) (* (cosh x) (csch x)))

\end{chunk}

\defun{sech}{The hyperbolic secant function}
\[sech(x) = \frac{1}{cosh(x)}\]
\begin{chunk}{defun sech 0}
(defun sech (x) (/ 1 (cosh x)))

\end{chunk}

\defun{acsch}{The inverse hyperbolic cosecant function}
\[acsch(x) = asinh\left(\frac{1}{x}\right)\]
\begin{chunk}{defun acsch 0}
(defun acsch (x) (asinh (/ 1 x)))

\end{chunk}

\defun{acoth}{The inverse hyperbolic cotangent function}
\[acoth(x) = atanh\left(\frac{1}{x}\right)\]
\begin{chunk}{defun acoth 0}
(defun acoth (x) (atanh (/ 1 x)))

\end{chunk}

\defun{asech}{The inverse hyperbolic secant function}
\[asech(x) = acosh\left(\frac{1}{x}\right)\]
\begin{chunk}{defun asech 0}
(defun asech (x) (acosh (/ 1 x)))

\end{chunk}

\section{\enspace{}DoubleFloatMatrix}
\defmacro{make-double-matrix}{DoubleFloatMatrix qnew function support}
\begin{chunk}{defmacro make-double-matrix 0}
(defmacro make-double-matrix (n m)
   `(make-array (list ,n ,m) :element-type 'double-float))

\end{chunk}

\defmacro{make-double-matrix1}{DoubleFloatMatrix new function support}
\begin{chunk}{defmacro make-double-matrix1 0}
(defmacro make-double-matrix1 (n m s)
 `(make-array (list ,n ,m) :element-type 'double-float :initial-element ,s))

\end{chunk}

\defmacro{daref2}{DoubleFloatMatrix qelt function support}
\begin{chunk}{defmacro daref2 0}
(defmacro daref2 (v i j)
 `(aref (the (simple-array double-float (* *)) ,v) ,i ,j))

\end{chunk}

\defmacro{dsetaref2}{DoubleFloatMatrix qsetelt! function support}
\begin{chunk}{defmacro dsetaref2 0}
(defmacro dsetaref2 (v i j s)
  `(setf (aref (the (simple-array double-float (* *)) ,v) ,i ,j) ,s))

\end{chunk}

\defmacro{danrows}{DoubleFloatMatrix nrows function support}
\begin{chunk}{defmacro danrows 0}
(defmacro danrows (v)
  `(array-dimension (the (simple-array double-float (* *)) ,v) 0))

\end{chunk}

\defmacro{dancols}{DoubleFloatMatrix ncols function support}
\begin{chunk}{defmacro dancols 0}
(defmacro dancols (v)
  `(array-dimension (the (simple-array double-float (* *)) ,v) 1))

\end{chunk}

\section{\enspace{}DoubleFloatVector}
Double Float Vectors are simple arrays of lisp double-floats
made available at the Spad language level. Note that these vectors
are 0 based whereas other Spad language vectors are 1-based.

\defmacro{dlen}{DoubleFloatVector Qsize function support}
\begin{chunk}{defmacro dlen 0}
(defmacro dlen (v)
 `(length (the (simple-array double-float (*)) ,v)))

\end{chunk}

\defmacro{make-double-vector}{DoubleFloatVector Qnew function support}
\begin{chunk}{defmacro make-double-vector 0}
(defmacro make-double-vector (n)
 `(make-array (list ,n) :element-type 'double-float))

\end{chunk}

\defmacro{make-double-vector1}{DoubleFloatVector Qnew1 function support}
\begin{chunk}{defmacro make-double-vector1 0}
(defmacro make-double-vector1 (n s)
 `(make-array (list ,n) :element-type 'double-float :initial-element ,s))

\end{chunk}

\defmacro{delt}{DoubleFloatVector Qelt1 function support}
\begin{chunk}{defmacro delt 0}
(defmacro delt (v i)
 `(aref (the (simple-array double-float (*)) ,v) ,i))

\end{chunk}

\defmacro{dsetelt}{DoubleFloatVector Qsetelt1 function support}
\begin{chunk}{defmacro dsetelt 0}
(defmacro dsetelt (v i s)
 `(setf (aref (the (simple-array double-float (*)) ,v) ,i) ,s))

\end{chunk}

%%% E %%%
%%% F %%% 

\section{\enspace{}File}
\defvar{*read-place-holder*}
\begin{chunk}{initvars}
(defvar *read-place-holder* (make-symbol "%.EOF")
   "default value returned by read and read-line at end-of-file")

\end{chunk}

\defun{placep}{placep}
\uses{placep}{*read-place-holder*}
\begin{chunk}{defun placep 0}
(defun placep (item)
 (declare (special *read-place-holder*))
 (eq item *read-place-holder*))

\end{chunk}

\defun{vmread}{vmread}
\begin{chunk}{defun vmread 0}
(defun vmread (&optional (st *standard-input*) (eofval *read-place-holder*))
  (read st nil eofval))

\end{chunk}

\section{\enspace{}FileName}
\defun{fnameMake}{FileName filename function implementation}
\calls{fnameMake}{StringToDir}
\begin{chunk}{defun fnameMake}
(defun |fnameMake| (d n e)
  (if (string= e "") (setq e nil))
  (make-pathname :directory (|StringToDir| d) :name  n :type e))

\end{chunk}

\defun{StringToDir}{FileName filename support function}
\calls{StringToDir}{lastc}
\begin{chunk}{defun StringToDir}
(defun |StringToDir| (s)
  (cond
    ((string= s "/") '(:root))
    ((string= s "")  nil)
    (t
      (let ((lastc (aref s (- (length s) 1))))
        (if (char= lastc #\/)
          (pathname-directory (concat s "name.type"))
          (pathname-directory (concat s "/name.type")) ))) ))

\end{chunk}

\defun{fnameDirectory}{FileName directory function implementation}
\calls{fnameDirectory}{DirToString}
\begin{chunk}{defun fnameDirectory}
(defun |fnameDirectory| (f)
  (|DirToString| (pathname-directory (string f))))

\end{chunk}

\defun{DirToString}{FileName directory function support}
For example,  ``/''  ``/u/smwatt''  ``../src''
\begin{chunk}{defun DirToString 0}
(defun |DirToString| (d)
  (cond
    ((equal d '(:root)) "/")
    ((null d) "")
    ('t (string-right-trim "/" (namestring (make-pathname :directory d)))) ))

\end{chunk}

\defun{fnameName}{FileName name function implementation}
\begin{chunk}{defun fnameName 0}
(defun |fnameName| (f)
  (let ((s (pathname-name (string f))))
    (if s s "") ))

\end{chunk}

\defun{fnameType}{FileName extension function implementation}
\begin{chunk}{defun fnameType 0}
(defun |fnameType| (f)
  (let ((s (pathname-type (string f))))
    (if s s "") ))

\end{chunk}

\defun{fnameExists?}{FileName exists? function implementation}
\begin{chunk}{defun fnameExists? 0}
(defun |fnameExists?| (f)
  (if (probe-file (namestring f)) 't nil))

\end{chunk}

\defun{fnameReadable?}{FileName readable? function implementation}
\begin{chunk}{defun fnameReadable? 0}
(defun |fnameReadable?| (f)
 (let ((s (open f :direction :input :if-does-not-exist nil)))
  (cond (s (close s) t) (t nil)) ))

\end{chunk}

\defun{fnameWritable?}{FileName writeable? function implementation}
\calls{fnameWritable?}{myWriteable?}
\begin{chunk}{defun fnameWritable?}
(defun |fnameWritable?| (f)
  (|myWritable?| (namestring f)) )

\end{chunk}

\defun{myWritable?}{FileName writeable? function support}
\calls{myWritable?}{error}
\calls{myWritable?}{fnameExists?}
\calls{myWritable?}{fnameDirectory}
\calls{myWritable?}{writeablep}
\begin{chunk}{defun myWritable?}
(defun |myWritable?| (s)
  (if (not (stringp s)) (|error| "``myWritable?'' requires a string arg."))
  (if (string= s "") (setq s "."))
  (if (not (|fnameExists?| s)) (setq s (|fnameDirectory| s)))
  (if (string= s "") (setq s "."))
  (if (> (|writeablep| s) 0) 't nil) )

\end{chunk}

\defun{fnameNew}{FileName new function implementation}
\calls{fnameNew}{fnameMake}
\begin{chunk}{defun fnameNew}
(defun |fnameNew| (d n e)
  (if (not (|myWritable?| d))
    nil
    (do ((fn))
        (nil)
        (setq fn (|fnameMake| d (string (gensym n)) e))
        (if (not (probe-file (namestring fn)))
           (return-from |fnameNew| fn)) )))

\end{chunk}

%%% G %%%
%%% H %%%
%%% I %%%

\section{\enspace{}IndexedBits}
\defmacro{truth-to-bit}{IndexedBits new function support}
\begin{chunk}{defmacro truth-to-bit}
(defmacro truth-to-bit (x) `(cond (,x 1) ('else 0)))

\end{chunk}

\defun{bvec-make-full}{IndexedBits new function support}
\begin{chunk}{defun bvec-make-full 0}
(defun bvec-make-full (n x) 
 (make-array (list n) :element-type 'bit :initial-element x))

\end{chunk}

\defmacro{bit-to-truth}{IndexedBits elt function support}
\begin{chunk}{defmacro bit-to-truth 0}
(defmacro bit-to-truth (b) `(eq ,b 1))

\end{chunk}

\defmacro{bvec-elt}{IndexedBits elt function support}
\begin{chunk}{defmacro bvec-elt 0}
(defmacro bvec-elt (bv i) `(sbit ,bv ,i))

\end{chunk}

\defmacro{bvec-setelt}{IndexedBits setelt function support}
\begin{chunk}{defmacro bvec-setelt}
(defmacro bvec-setelt (bv i x) `(setf (sbit ,bv ,i) ,x))

\end{chunk}

\defmacro{bvec-size}{IndexedBits length function support}
\begin{chunk}{defmacro bvec-size}
(defmacro bvec-size (bv) `(size ,bv))

\end{chunk}

\defun{bvec-concat}{IndexedBits concat function support}
\begin{chunk}{defun bvec-concat 0}
(defun bvec-concat (bv1 bv2) (concatenate '(vector bit) bv1 bv2))

\end{chunk}

\defun{bvec-copy}{IndexedBits copy function support}
\begin{chunk}{defun bvec-copy 0}
(defun bvec-copy (bv) (copy-seq bv))

\end{chunk}

\defun{bvec-equal}{IndexedBits = function support}
\begin{chunk}{defun bvec-equal 0}
(defun bvec-equal (bv1 bv2) (equal bv1 bv2))

\end{chunk}

\defun{bvec-greater}{IndexedBits $<$ function support}
\begin{chunk}{defun bvec-greater 0}
(defun bvec-greater (bv1 bv2)
  (let ((pos (mismatch bv1 bv2)))
    (cond ((or (null pos) (>= pos (length bv1))) nil)
          ((< pos (length bv2)) (> (bit bv1 pos) (bit bv2 pos)))
          ((find 1 bv1 :start pos) t)
          (t nil))))

\end{chunk}

\defun{bvec-and}{IndexedBits And function support}
\begin{chunk}{defun bvec-and 0}
(defun bvec-and (bv1 bv2) (bit-and  bv1 bv2))

\end{chunk}

\defun{bvec-or}{IndexedBits Or function support}
\begin{chunk}{defun bvec-or 0}
(defun bvec-or (bv1 bv2) (bit-ior  bv1 bv2))

\end{chunk}

\defun{bvec-xor}{IndexedBits xor function support}
\begin{chunk}{defun bvec-xor 0}
(defun bvec-xor (bv1 bv2) (bit-xor  bv1 bv2))

\end{chunk}

\defun{bvec-nand}{IndexedBits nand function support}
\begin{chunk}{defun bvec-nand 0}
(defun bvec-nand (bv1 bv2) (bit-nand bv1 bv2))

\end{chunk}

\defun{bvec-nor}{IndexedBits nor function support}
\begin{chunk}{defun bvec-nor 0}
(defun bvec-nor (bv1 bv2) (bit-nor  bv1 bv2))

\end{chunk}

\defun{bvec-not}{IndexedBits not function support}
\begin{chunk}{defun bvec-not 0}
(defun bvec-not (bv) (bit-not  bv))

\end{chunk}

\section{\enspace{}IndexCard}
\defun{alqlGetOrigin}{IndexCard origin function support}
\calls{alqlGetOrigin}{dbPart}
\calls{alqlGetOrigin}{charPosition}
\calls{alqlGetOrigin}{substring}
\begin{chunk}{defun alqlGetOrigin}
(defun |alqlGetOrigin| (x)
 (let (field k)
  (setq field (|dbPart| x 5 1))
  (setq k (|charPosition| #\( field 2))
  (substring field 1 (1- k))))

\end{chunk}

\defun{alqlGetParams}{IndexCard origin function support}
\calls{alqlGetParams}{dbPart}
\calls{alqlGetParams}{charPosition}
\calls{alqlGetParams}{substring}
\begin{chunk}{defun alqlGetParams}
(defun |alqlGetParams| (x)
 (let (field k)
  (setq field (|dbPart| x 5 1))
  (setq k (|charPosition| #\( field 2))
  (substring field k nil)))

\end{chunk}

\defun{alqlGetKindString}{IndexCard elt function support}
\calls{alqlGetKindString}{dbPart}
\calls{alqlGetKindString}{substring}
\begin{chunk}{defun alqlGetKindString}
(defun |alqlGetKindString| (x)
 (if (or (char= (elt x 0) #\a) (char= (elt x 0) #\o))
  (substring (|dbPart| x 5 1) 0 1)
  (substring x 0 1)))

\end{chunk}

\section{IndexedString}

\defun{qenum}{qenum}
This is also used in bookvol10.3 in the CHAR domain.
\begin{chunk}{defun qenum 0}
(defun qenum (cvec ind)
 (char-code (char cvec ind)))

\end{chunk}

\begin{chunk}{defmacro qcsize 0}
(defmacro qcsize (x)
 `(the fixnum (length (the simple-string ,x))))

\end{chunk}

\begin{chunk}{defun qeset 0}
(defun qeset (cvec ind charnum)
  (setf (char cvec ind) (code-char charnum)))

\end{chunk}

\begin{chunk}{defmacro qsgreaterp 0}
(defmacro qsgreaterp (a b)
 `(> (the fixnum ,a) (the fixnum ,b)))

\end{chunk}

\section{InputForm}

\defun{mkobjFn}{called by interpret function}
\begin{chunk}{defun mkObjFn 0}
(defun |mkObjFn| (val mode)
 (cons mode val)) 

\end{chunk}

\defun{objValFn}{called by interpret function}
\begin{chunk}{defun objValFn 0}
(defun |objValFn| (obj)
 (cdr obj)) 

\end{chunk}

\defun{objModeFn}{called by interpret function}
\begin{chunk}{defun objModeFn 0}
(defun |objModeFn| (obj)
 (car obj)) 

\end{chunk}

\defun{unparseInputForm}{unparseInputForm}
This fixes bug 7217. The default title generation is bogus.
This is called from the unparse function in InputForm, bookvol10.3
Given a form, $u$, we try to recover the input line that created it.

\defsdollar{unparseInputForm}{InteractiveMode}
\defsdollar{unparseInputForm}{formatSigAsTex}
\begin{chunk}{defun unparseInputForm}
(defun |unparseInputForm| (u)
 (let (|$formatSigAsTeX| |$InteractiveMode|)
 (declare (special |$formatSigAsTeX| |$InteractiveMode|))
  (setq |$formatSigAsTeX| 1)
  (setq |$InteractiveMode| nil)
  (|form2StringLocal| u)))

\end{chunk}

\section{\enspace{}Integer}
\defun{divide2}{Integer divide function support}
Note that this is defined as a SPADReplace function in Integer
so that algebra code that uses the Integer divide function actually inlines
a call to this code. The Integer domain contains the line:
\begin{verbatim}
(PUT (QUOTE |INT;divide;2$R;44|) (QUOTE |SPADreplace|) (QUOTE DIVIDE2)) 
\end{verbatim}
\begin{chunk}{defun divide2 0}
(defun divide2 (x y)
 (multiple-value-call #'cons (truncate x y)))

\end{chunk}

\defun{remainder2}{Integer quo function support}
Note that this is defined as a SPADReplace function in Integer
so that algebra code that uses the Integer quo function actually inlines
a call to this code. The Integer domain contains the line:
\begin{verbatim}
(PUT (QUOTE |INT;rem;3$;46|) (QUOTE |SPADreplace|) (QUOTE REMAINDER2)) 
\end{verbatim}
Because these are identical except for name we make the symbol-functions
equivalent. This was done in the original code for efficiency.
\begin{chunk}{defun remainder2 0}
(setf (symbol-function 'remainder2) #'rem)

\end{chunk}

\defun{quotient2}{Integer quo function support}
Note that this is defined as a SPADReplace function in Integer
so that algebra code that uses the Integer quo function actually inlines
a call to this code. The Integer domain contains the line:
\begin{verbatim}
(PUT (QUOTE |INT;quo;3$;45|) (QUOTE |SPADreplace|) (QUOTE QUOTIENT2)) 
\end{verbatim}
\begin{chunk}{defun quotient2 0}
(defun quotient2 (x y)
 (values (truncate x y)))

\end{chunk}

\defun{random}{Integer random function support}
This is used for calls to random with no arguments.
If an argument is supplied to random then the common lisp random
function is called directly. This could be lifted up into the spad code.
\begin{chunk}{defun random 0}
(defun |random| () (random (expt 2 26)))

\end{chunk}

%%% J %%%
%%% K %%%

\section{\enspace{}KeyedAccessFile}
\defun{rdefinstream}{KeyedAccessFile defstream function support}
This is a simpler interpface to RDEFIOSTREAM
\calls{rdefinstream}{rdefiostream}
\begin{chunk}{defun rdefinstream}
(defun rdefinstream (&rest fn)
  ;; following line prevents rdefiostream from adding a default filetype
  (unless (rest fn) (setq fn (list (pathname (car fn)))))
  (rdefiostream (list (cons 'file fn) '(mode . input))))

\end{chunk}

\defun{rdefoutstream}{KeyedAccessFile defstream function support}
\calls{rdefoutstream}{rdefiostream}
\begin{chunk}{defun rdefoutstream}
(defun rdefoutstream (&rest fn)
  ;; following line prevents rdefiostream from adding a default filetype
  (unless (rest fn) (setq fn (list (pathname (car fn)))))
  (rdefiostream (list (cons 'FILE fn) '(mode . OUTPUT))))

\end{chunk}

%%% L %%%
%%% M %%%
%%% N %%%

\section{\enspace{}NumberFormats}
\defun{ncParseFromString}{ncParseFromString}
\begin{chunk}{defun ncParseFromString}
(defun |ncParseFromString| (s)
  (|zeroOneTran| (catch 'SPAD_READER (|parseFromString| s))))

\end{chunk}

%%% O %%%

\section{\enspace{}OperationsQuery}

\defun{getBrowseDatabase}{OperationQuery getDatabase function support}
This function, called as \verb|getBrowseDatabase(arg)| returns a list of
appropriate entries in the browser database. The legal values for arg are
\begin{itemize}
\item ``o'' (operations)
\item ``k'' (constructors)
\item ``d'' (domains)
\item ``c'' (categories)
\item ``p'' (packages)
\end{itemize}
\calls{getBrowseDatabase}{member}
\calls{getBrowseDatabase}{grepConstruct}
\usesdollar{getBrowseDatabase}{includeUnexposed?}
\begin{chunk}{defun getBrowseDatabase}
(defun |getBrowseDatabase| (kind)
 (let (|$includeUnexposed?|)
 (declare (special |$includeUnexposed?|))
  (setq |$includeUnexposed?| t)
  (when (|member| kind '("o" "k" "c" "d" "p"))
   (|grepConstruct| "*" (intern kind)))))

\end{chunk}

%%% P %%%

\section{\enspace{}ParametricLinearEquations}
\defun{algCoerceInteractive}{algCoerceInteractive}
\begin{chunk}{defun algCoerceInteractive}
(defun |algCoerceInteractive| (p source target)
 (let (|$useConvertForCoercions| u)
 (declare (special |$useConvertForCoercions|))
  (setq |$useConvertForCoercions| t)
  (setq source (|devaluate| source))
  (setq target (|devaluate| target))
  (setq u (|coerceInteractive| (mkObjWrap p source) target))
  (if u
   (|objValUnwrap| u)
   (|error| (list "can't convert" p "of mode" source "to mode" target)))))

\end{chunk}

\section{\enspace{}Plot3d}
We catch numeric errors and throw a different failure than normal.
The trapNumericErrors macro will return a pair of the the form
{\tt Union(type-of-form, "failed")}. This pair is tested for eq-ness
so it has to be unique. It lives in the defvar \verb|$numericFailure|.
The old value of the \verb|$BreakMode| variable is saved in a defvar
named \verb|$oldBreakMode|.

\defdollar{numericFailure}
This is a failed union branch which is the value returned for numeric failure.
\begin{chunk}{initvars}
(defvar |$numericFailure| (cons 1 "failed")) 

\end{chunk}

\defdollar{oldBreakMode}
\begin{chunk}{initvars}
(defvar |$oldBreakMode| nil "the old value of the $BreakMode variable")

\end{chunk}

\defmacro{trapNumericErrors}
The following macro evaluates form returning Union(type-of form, "failed").
It is used in the {\tt myTrap} local function in Plot3d.
\begin{chunk}{defmacro trapNumericErrors}
(defmacro |trapNumericErrors| (form)
 `(let ((|$oldBreakMode| |$BreakMode|) (|$BreakMode| '|trapNumerics|) (val))
  (declare (special |$BreakMode| |$numericFailure| |$oldBreakMode|))
   (setq val (catch '|trapNumerics| ,form))
   (if (eq val |$numericFailure|) val (cons 0 val))))

\end{chunk}

%%% Q %%%
%%% R %%%
%%% S %%%

\section{\enspace{}SingleInteger}
\defun{qsquotient}{qsquotient}
\begin{chunk}{defun qsquotient 0}
(defun qsquotient (a b)
 (the fixnum (truncate (the fixnum a) (the fixnum b))))

\end{chunk}

\defun{qsremainder}{qsremainder}
\begin{chunk}{defun qsremainder 0}
(defun qsremainder (a b)
 (the fixnum (rem (the fixnum a) (the fixnum b))))

\end{chunk}

\defmacro{qsdifference}
\begin{chunk}{defmacro qsdifference 0}
(defmacro qsdifference (x y)
 `(the fixnum (- (the fixnum ,x) (the fixnum ,y))))

\end{chunk}

\defmacro{qslessp}
This is also used in IndexedString
\begin{chunk}{defmacro qslessp 0}
(defmacro qslessp (a b)
 `(< (the fixnum ,a) (the fixnum ,b)))

\end{chunk}

\defmacro{qsadd1}
\begin{chunk}{defmacro qsadd1 0}
(defmacro qsadd1 (x)
 `(the fixnum (1+ (the fixnum ,x))))

\end{chunk}

\defmacro{qssub1}
\begin{chunk}{defmacro qssub1 0}
(defmacro qssub1 (x)
 `(the fixnum (1- (the fixnum ,x))))

\end{chunk}

\defmacro{qsminus}
\begin{chunk}{defmacro qsminus 0}
(defmacro qsminus (x)
 `(the fixnum (minus (the fixnum ,x))))

\end{chunk}

\defmacro{qsplus}
\begin{chunk}{defmacro qsplus 0}
(defmacro qsplus (x y)
 `(the fixnum (+ (the fixnum ,x) (the fixnum ,y))))

\end{chunk}

\defmacro{qstimes}
\begin{chunk}{defmacro qstimes 0}
(defmacro qstimes (x y)
 `(the fixnum (* (the fixnum ,x) (the fixnum ,y))))

\end{chunk}

\defmacro{qsabsval}
\begin{chunk}{defmacro qsabsval 0}
(defmacro qsabsval (x)
  `(the fixnum (abs (the fixnum ,x))))

\end{chunk}

\defmacro{qsoddp}
\begin{chunk}{defmacro qsoddp 0}
(defmacro qsoddp (x)
 `(oddp (the fixnum ,x)))

\end{chunk}

\defmacro{qszerop}
\begin{chunk}{defmacro qszerop 0}
(defmacro qszerop (x)
 `(zerop (the fixnum ,x)))

\end{chunk}

\defmacro{qsmax}
\begin{chunk}{defmacro qsmax 0}
(defmacro qsmax (x y)
 `(the fixnum (max (the fixnum ,x) (the fixnum ,y))))

\end{chunk}

\defmacro{qsmin}
\begin{chunk}{defmacro qsmin 0}
(defmacro qsmin (x y)
 `(the fixnum (min (the fixnum ,x) (the fixnum ,y))))

\end{chunk}

%%% T %%%

\section{\enspace{}Table}
\defun{hashable}{Table InnerTable support}
We look inside the Key domain given to Table and find if there is an
equality predicate associated with the domain. If found then
Table will use a HashTable representation, otherwise it will use
an AssociationList representation.

\calls{hashable}{knownEqualPred}
\calls{hashable}{compiledLookup}
\calls{hashable}{Boolean}
\calls{hashable}{bpiname}
\calls{hashable}{knownEqualPred}
\begin{chunk}{defun hashable}
(defun |hashable| (dom)
 (labels (
  (|knownEqualPred| (dom)
    (let ((fun (|compiledLookup| '= '((|Boolean|) $ $) dom)))
     (if fun 
      (get (bpiname (car fun)) '|SPADreplace|)
      nil))))
  (member (|knownEqualPred| dom) '(eq eql equal))))

\end{chunk}

%%% U %%%

\section{U8Vector}

\defmacro{qvlenU8}
\begin{chunk}{defmacro qvlenU8}
(defmacro qvlenU8 (v)
 `(length (the (simple-array (unsigned-byte 8) (*)) ,v)))

\end{chunk}

\defmacro{eltU8}
\begin{chunk}{defmacro eltU8}
(defmacro eltU8 (v i)
 `(aref (the (simple-array (unsigned-byte 8) (*)) ,v) ,i))

\end{chunk}

\defmacro{seteltU8}
\begin{chunk}{defmacro seteltU8}
(defmacro seteltU8 (v i s)
 `(setf (aref (the (simple-array (unsigned-byte 8) (*)) ,v) ,i), s))

\end{chunk}

\defun{getRefvU8}{getRefvU8}
\begin{chunk}{defun getRefvU8}
(defun getRefvU8 (n x)
  (make-array n :initial-element x :element-type '(unsigned-byte 8)))

\end{chunk}

\section{U16Vector}

\defmacro{qvlenU16}
\begin{chunk}{defmacro qvlenU16}
(defmacro qvlenU16 (v)
 `(length (the (simple-array (unsigned-byte 16) (*)) ,v)))

\end{chunk}

\defmacro{eltU16}
\begin{chunk}{defmacro eltU16}
(defmacro eltU16 (v i)
 `(aref (the (simple-array (unsigned-byte 16) (*)) ,v) ,i))

\end{chunk}

\defmacro{seteltU16}
\begin{chunk}{defmacro seteltU16}
(defmacro seteltU16 (v i s)
 `(setf (aref (the (simple-array (unsigned-byte 16) (*)) ,v) ,i), s))

\end{chunk}

\defun{getRefvU16}{getRefvU16}
\begin{chunk}{defun getRefvU16}
(defun getRefvU16 (n x)
  (make-array n :initial-element x :element-type '(unsigned-byte 16)))

\end{chunk}

\section{U32Vector}

\defmacro{qvlenU32}
\begin{chunk}{defmacro qvlenU32}
(defmacro qvlenU32 (v)
 `(length (the (simple-array (unsigned-byte 32) (*)) ,v)))

\end{chunk}

\defmacro{eltU32}
\begin{chunk}{defmacro eltU32}
(defmacro eltU32 (v i)
 `(aref (the (simple-array (unsigned-byte 32) (*)) ,v) ,i))

\end{chunk}

\defmacro{seteltU32}
\begin{chunk}{defmacro seteltU32}
(defmacro seteltU32 (v i s)
 `(setf (aref (the (simple-array (unsigned-byte 32) (*)) ,v) ,i), s))

\end{chunk}

\defun{getRefvU32}{getRefvU32}
\begin{chunk}{defun getRefvU32}
(defun getRefvU32 (n x)
  (make-array n :initial-element x :element-type '(unsigned-byte 32)))

\end{chunk}

\section{U8Matrix}

\defmacro{aref2U8}
\begin{chunk}{defmacro aref2U8}
(defmacro aref2U8 (v i j)
 `(aref (the (simple-array (unsigned-byte 8) (* *)) ,v) ,i ,j))

\end{chunk}

\defmacro{setAref2U8}
\begin{chunk}{defmacro setAref2U8}
(defmacro setAref2U8 (v i j s)
 `(setf (aref (the (simple-array (unsigned-byte 8) (* *)) ,v) ,i ,j), s))

\end{chunk}

\defmacro{anrowsU8}
\begin{chunk}{defmacro anrowsU8}
(defmacro anrowsU8 (v)
 `(array-dimension (the (simple-array (unsigned-byte 8) (* *)) ,v) 0))

\end{chunk}

\defmacro{ancolsU8}
\begin{chunk}{defmacro ancolsU8}
(defmacro ancolsU8 (v)
 `(array-dimension (the (simple-array (unsigned-byte 8) (* *)) ,v) 1))

\end{chunk}

\defmacro{makeMatrixU8}
\begin{chunk}{defmacro makeMatrixU8}
(defmacro makeMatrixU8 (n m)
 `(make-array (list ,n ,m) :element-type '(unsigned-byte 8)
                           :initial-element 0))

\end{chunk}

\defmacro{makeMatrix1U8}
\begin{chunk}{defmacro makeMatrix1U8}
(defmacro makeMatrix1U8 (n m s)
 `(make-array (list ,n ,m) :element-type '(unsigned-byte 8)
                           :initial-element ,s))

\end{chunk}

\section{U16Matrix}

\defmacro{aref2U16}
\begin{chunk}{defmacro aref2U16}
(defmacro aref2U16 (v i j)
 `(aref (the (simple-array (unsigned-byte 16) (* *)) ,v) ,i ,j))

\end{chunk}

\defmacro{setAref2U16}
\begin{chunk}{defmacro setAref2U16}
(defmacro setAref2U16 (v i j s)
 `(setf (aref (the (simple-array (unsigned-byte 16) (* *)) ,v) ,i ,j), s))

\end{chunk}

\defmacro{anrowsU16}
\begin{chunk}{defmacro anrowsU16}
(defmacro anrowsU16 (v)
 `(array-dimension (the (simple-array (unsigned-byte 16) (* *)) ,v) 0))

\end{chunk}

\defmacro{ancolsU16}
\begin{chunk}{defmacro ancolsU16}
(defmacro ancolsU16 (v)
 `(array-dimension (the (simple-array (unsigned-byte 16) (* *)) ,v) 1))

\end{chunk}

\defmacro{makeMatrixU16}
\begin{chunk}{defmacro makeMatrixU16}
(defmacro makeMatrixU16 (n m)
 `(make-array (list ,n ,m) :element-type '(unsigned-byte 16)
                           :initial-element 0))

\end{chunk}

\defmacro{makeMatrix1U16}
\begin{chunk}{defmacro makeMatrix1U16}
(defmacro makeMatrix1U16 (n m s)
 `(make-array (list ,n ,m) :element-type '(unsigned-byte 16)
                           :initial-element ,s))

\end{chunk}

\section{\enspace{}U32Matrix}

\defmacro{aref2U32}
\begin{chunk}{defmacro aref2U32}
(defmacro aref2U32 (v i j)
 `(aref (the (simple-array (unsigned-byte 32) (* *)) ,v) ,i ,j))

\end{chunk}

\defmacro{setAref2U32}
\begin{chunk}{defmacro setAref2U32}
(defmacro setAref2U32 (v i j s)
 `(setf (aref (the (simple-array (unsigned-byte 32) (* *)) ,v) ,i ,j), s))

\end{chunk}

\defmacro{anrowsU32}
\begin{chunk}{defmacro anrowsU32}
(defmacro anrowsU32 (v)
 `(array-dimension (the (simple-array (unsigned-byte 32) (* *)) ,v) 0))

\end{chunk}

\defmacro{ancolsU32}
\begin{chunk}{defmacro ancolsU32}
(defmacro ancolsU32 (v)
 `(array-dimension (the (simple-array (unsigned-byte 32) (* *)) ,v) 1))

\end{chunk}

\defmacro{makeMatrixU32}
\begin{chunk}{defmacro makeMatrixU32}
(defmacro makeMatrixU32 (n m)
 `(make-array (list ,n ,m) :element-type '(unsigned-byte 32)
                           :initial-element 0))

\end{chunk}

\defmacro{makeMatrix1U32}
\begin{chunk}{defmacro makeMatrix1U32}
(defmacro makeMatrix1U32 (n m s)
 `(make-array (list ,n ,m) :element-type '(unsigned-byte 32)
                           :initial-element ,s))

\end{chunk}

\section{\enspace{}U32VectorPolynomialOperations}

\defmacro{qsMulAdd6432}
\begin{chunk}{defmacro qsMulAdd6432}
(defmacro qsMulAdd6432 (x y z)
  `(the (unsigned-byte 64)
     (+ (the (unsigned-byte 64)
          (* (the (unsigned-byte 32) ,x)
             (the (unsigned-byte 32) ,y)))
        (the (unsigned-byte 64) ,z))))

\end{chunk}

\defmacro{qsMulMod32}
\begin{chunk}{defmacro qsMulMod32}
(defmacro qsMulMod32 (x y &optional z)
  (declare (ignore z))
  `(the (unsigned-byte 64)
     (* (the (unsigned-byte 32) ,x)
        (the (unsigned-byte 32) ,y))))

\end{chunk}

\defmacro{qsMod6432}
\begin{chunk}{defmacro qsMod6432}
(defmacro qsMod6432 (x p)
  `(the (unsigned-byte 32)
     (rem (the (unsigned-byte 64) ,x) (the (unsigned-byte 32) ,p))))

\end{chunk}

\defmacro{qsMulAddMod6432}
\begin{chunk}{defmacro qsMulAddMod6432}
(defmacro qsMulAddMod6432 (x y z p)
  `(qsMod6432 (qsMulAdd6432 ,x ,y ,z) ,p))

\end{chunk}

\defmacro{qsMul6432}
\begin{chunk}{defmacro qsMul6432}
(defmacro qsMul6432 (x y)
  `(the (unsigned-byte 64)
     (* (the (unsigned-byte 32) ,x)
        (the (unsigned-byte 32) ,y))))

\end{chunk}

\defmacro{qsDot26432}
\begin{chunk}{defmacro qsDot26432}
(defmacro qsDot26432 (a1 b1 a2 b2)
  `(qsMulAdd6432 ,a1 ,b1 (qsMul6432 ,a2 ,b2)))

\end{chunk}

\defmacro{qsDot2Mod6432}
\begin{chunk}{defmacro qsDot2Mod6432}
(defmacro qsDot2Mod6432 (a1 b1 a2 b2 p)
  `(qsMod6432 (qsDot26432 ,a1 ,b1 ,a2 ,b2) ,p))

\end{chunk}

%%% V %%%

\section{Void}
\defun{voidValue}{voidValue}
\begin{chunk}{defun voidValue}
(defun |voidValue| () "()") 

\end{chunk}

\chapter{OpenMath}
\section{A Technical Overview}

OpenMath\cite{Dewa} is a standard for representing mathematical data in as
unambiguous a way as possible. It can be used to exchange mathematical
objects between software packages or via email, or as a persistent
data format in a database. It is tightly focussed on representing
semantic information and is not intended to be used directly for
presentation, although tools exist to facilitate this.

The original motivation for OpenMath came from the Computer Algebra
community. Computer Algebra packages were getting bigger and more
unwieldy, and it seemed reasonable to adopt a generic "plug and play"
architecture to allow specialised programs to be used from general
purpose environments. There were plenty of mechanisms for connecting
software components together, but no common format for representing
the underlying data objects. It quickly became clear that any standard
had to be vendor-neutral and that objects encoded in OpenMath should
not be too verbose. This has led to the design outlined below.

In 1998, the Worldwide Web Consortium (W3C) produced its first
recommendation for the Extensible Markup Language (XML), intended to
be a universal format for representing structured information on the
worldwide web. It was swiftly followed by the first MathML
recommendation which is an XML application oriented mainly towards the
presentation (i.e. the rendering) of mathematical expressions.

The formal definition of OpenMath is contained within The OpenMath
Standard and its accompanying documents, and the reader is referred
there for more details.  

\subsection{The OpenMath Architecture}

The OpenMath representation of a mathematical structure is referred to
as an OpenMath object. This is an abstract structure which is
represented concretely via an OpenMath encoding. These encoded objects
are what an OpenMath application would read and write, and in practice
the OpenMath objects themselves almost never exist, except on
paper. The advantage of this is that OpenMath is not tied to any one
underlying mechanism: in the past we have used functional, SGML and
binary encodings. The current favourite is XML, as described below,
and we will tend to use XML notation when describing OpenMath objects
(even though strictly speaking the XML representation is an encoding).
OpenMath Objects

Formally, an OpenMath object is a labelled tree whose leaves are the
basic OpenMath objects integers, IEEE double precision floats, unicode
strings, byte arrays, variables or symbols. Of these, symbols are the
most interesting since they consist of a name and a reference to a
definition in an external document called a content dictionary (or
CD). Using XML notation where the element name OMS indicates an
OpenMath symbol, the following: 
\begin{verbatim}
    <OMS name="sin" cd="transc1"/>
\end{verbatim}
represents the usual sine function, as defined in the CD "transc1". A
basic OpenMath object is an OpenMath object, although its XML
representation will be:
\begin{verbatim}
  <OMOBJ>
    <OMS name="sin" cd="transc1"/>
  </OMOBJ>
\end{verbatim}

OpenMath objects can be built up recursively in a number of ways. The
simplest is function application, for example the expression sin(x)
can be represented by the XML:
\begin{verbatim}
  <OMOBJ>
    <OMA>
      <OMS name="sin" cd="transc1"/>
      <OMV name="x"/>
    </OMA>
  </OMOBJ>
\end{verbatim}
where OMV introduces a variable and OMA is the application
element. Another straightforward method is attribution which as the
name suggests can be used to add additional information (for example
"the AXIOM command which generated me was ...") to an object without
altering its fundamental meaning. More interesting are binding objects
which are used to represent an expression containing bound variables,
for example:
\begin{verbatim}
  <OMOBJ>
    <OMA>
      <OMS cd="calculus1" name="int"/>
      <OMS cd="transc1" name="sin"/>
    </OMA>
  </OMOBJ>
\end{verbatim}
represents the integral of the sin function, but the encoding:
\begin{verbatim}
  <OMOBJ>
    <OMA>
      <OMS cd="calculus1" name="int"/>
      <OMBIND>
        <OMS cd="fns1" name="lambda"/>
        <OMBVAR> <OMV name="x"/> </OMBVAR>
        <OMA>
          <OMS name="sin" cd="transc1"/>
          <OMV name="x"/>
        </OMA>
      </OMBIND>
    </OMA>
  </OMOBJ>
\end{verbatim}
represents $\int\sin(x)dx$. This may appear overly complicated but it is
useful, for example when searching in a database for expressions which
match $\int\sin(y)dy$ . The definition of a symbol in the CD specifies
whether or not it may be used to bind variables, which is why 
\begin{verbatim}
   <OMS cd="calculus1" name="int"/> 
\end{verbatim}
cannot be used as a binding symbol.

The final kind of OpenMath object is an error which is built up from a
symbol describing the error and a sequence of OpenMath objects. For
example:
\begin{verbatim}
  <OMOBJ>
    <OME>
      <OMS name="unexpected_symbol" cd="error1">
      <OMS name="sine" cd="transc1">
    </OME>
  </OMOBJ>
\end{verbatim}
represents the error which might be generated when an application sees
a symbol it doesn't recognise from a CD it thought it knew about.

\subsection{OpenMath Encodings}

We have already seen some examples of the XML encoding, but it is by
no means the only encoding. In the past there was a functional
encoding (which looked like Lisp) and an SGML encoding which evolved
into the current XML. Both of these are now obsolete, but there is
still a binary encoding described in the standard , which is much more
compact than the XML one.

In fact the XML encoding is not \verb|100%| XML. When XML was in its infancy
the developers of OpenMath realised that it might become significant
and decided to add some XML-like features to the SGML encoding so that
an an OpenMath object could be encoded as valid XML. Thus it is
currently the case that any well-formed OpenMath object encoded using
the XML encoding as described in the standard is a valid XML
document. However, if one uses standard XML tools to generate an
OpenMath object in the XML encoding from the DTD given in chapter 4 of
the standard, it is possible that the result will not be valid
OpenMath, although in practice this is highly unlikely. To cover all
the possibilities allowed by XML would make it much more complicated
to write an application to read any OpenMath object from
scratch. Whether to adopt XML completely remains a hot topic of debate
within the OpenMath community!

Generally speaking, it is not intended that the existing encodings
should be readable by a human user or writable by hand. It is
desirable that they be compact and it is also desirable that they be
linear, but neither of these is a requirement. It is a property of
encodings that it is possible to convert between them with no loss of
information.  

\subsection{Content Dictionaries}

Content Dictionaries (or CDs for short) are the most important, and
the most interesting, aspect of OpenMath because they define the
meaning of the objects being transmitted. A CD is a collection of
related symbols and their definitions, encoded in an XML
format. Defining the meaning of a symbol is not a trivial task, and
even referring to well-known references can be fraught with pitfalls
Formal definitions and properties can be very useful but
time-consuming to produce and verbose, not to mention difficult to get
right. A symbol definition in an OpenMath CD consists of the following
pieces of information:
\begin{verbatim}
    the symbol name;
    a description in plain text;
    optionally, a set of this symbol's properties in plain text 
       (Commented Mathematical Properties, or CMPs);
    optionally, a set of this symbol's properties encoded in OpenMath 
       (Formal Mathematical Properties, or FMPs);
    optionally, one or more examples of its use (encoded in OpenMath).
\end{verbatim}
In practice the CMPs and FMPs can come as pairs, and often serve in
the place of examples.

A very simple instance of a CD definition is:
\begin{verbatim}
<CDDefinition>
<Name> log </Name>

<Description> 
This symbol represents a binary log function; the first argument is
the base, to which the second argument is log'ed.
It is defined in Abramowitz and Stegun, Handbook of Mathematical
Functions, section 4.1
</Description>
<CMP>
  a^b = c implies log_a c = b
</CMP>
<FMP>
  <OMOBJ>
    <OMA>
      <OMS cd="logic1" name="implies"/>
      <OMA>
        <OMS cd="relation1" name="eq"/>

        <OMA>
          <OMS cd="arith1" name="power"/>
          <OMV name="a"/>
          <OMV name="b"/>
        </OMA>
        <OMV name="c"/>
      </OMA>
      <OMA>
        <OMS cd="relation1" name="eq"/>

        <OMA>
          <OMS cd="transc1" name="log"/>
          <OMV name="a"/>
          <OMV name="c"/>
        </OMA>
        <OMV name="b"/>
      </OMA>
    </OMA>
  </OMOBJ>

</FMP>

<Example>
log 100 to base 10 (which is 2).
<OMOBJ>
  <OMA>
    <OMS cd="transc1" name="log"/>
    <OMF dec="10"/>
    <OMF dec="100"/>
  </OMA>
</OMOBJ>
</Example>

</CDDefinition>
\end{verbatim}

Another example would be to print the list
\begin{verbatim}
   [ 1, 1/2 ]
\end{verbatim}
as
\begin{verbatim}
<OMOBJ>
 <OMA>
  <OMS cd="list1" name="list"/>
  <OMI>1</OMI>
  <OMA>
   <OMS cd="nums1" name="rational"/>
   <OMI>1</OMI>
   <OMI>2</OMI>
  </OMA>
 </OMA>
</OMOBJ>
\end{verbatim}

This provides a symbol to represent the log function by giving a
pointer to a standard reference book. It provides the property that:
\[ a^b=c \rightarrow log_a(c)=b \]
both as plain text and as OpenMath, and also gives an example of how
the symbol is used.

CDs usually consist of related symbols and collections of related CDs
can be grouped together, for convenience, as CD Groups. One very
important CD Group is that corresponding to the content part of
MathML. 

It is possible to associate extra information with CDs, in particular
type information. Since there are many type systems available, each of
which has its own strengths and advocates, the OpenMath community does
not mandate any single system. Simple signatures can be encoded using
the Simple Type System, while more formal definitions are possible
using the Extended Calculus of Constructorss. Other associated
information can include style sheets for rendering OpenMath symbols in
MathML, and mathematical definitions to be used by formal logic
systems.

Given the evolutionary nature of mathematics, it is clear that the set
of CDs should be forever growing and never complete. Currently there
are CDs for high-school mathematics, linear algebra, polynomials and
group theory to name a few, and new contributions are always
welcome. There is no requirement that applications use the standard
set of CDs and it is often very useful to design a "private" CD for a
specific purpose.

\subsection{OpenMath in Action}

There is no definitive way in which OpenMath should be used, as the
protocol has been designed to be as flexible as possible. Nevertheless
many OpenMath applications share common characteristics which we shall
discuss here.

Suppose that we wish to have two applications communicating by sending
OpenMath objects to each other, e.g. a client program and a
computational server. It is unlikely that the internal data structures
used by the applications will be OpenMath, and so translation between
the internal representations and OpenMath (almost certainly OpenMath
encodings rather than objects) will have to take place. The piece of
software which does this is usually referred to as a phrase-book.

It is possible to write a generic phrase-book which can handle any
piece of OpenMath, but applications where this makes sense are few and
far between. In practice an OpenMath phrase book will usually only
handle a fixed set of CDs (and hence a fixed set of symbols). What
``handle'' means will vary from case to case: a computer algebra system
will usually try and evaluate its input and return a result or an
error, while a typesetter will print its input according to some
rendering rules and not return anything. OpenMath carefully avoids
defining what the ``right'' behaviour is in a given circumstance, and
leaves that up to the phrase-book writer. Indeed it is quite possible
that a piece of software could have multiple phrase-books associated
with it for different purposes. OpenMath symbols should not be
regarded as verbs since they are used to construct objects rather than
to send commands, and the presence of both nouns and verbs in a CD
(e.g. ``integral'' and ``integrate'') is strongly discouraged.

Writing a phrase-book may be non-trivial, and requires an
understanding of the semantics of the underlying software. An OpenMath
object may not map directly into a private object and vice-versa, for
example in some systems a rational number might have to be represented
by a float, or a sparse matrix by a dense one.

The OpenMath standard includes a section on compliance, which
describes the behaviour of an OpenMath application when certain errors
occur. It also insists that all compliant software has the capability
to use the XML encoding, to guarantee a degree of interoperability. 
This is an area where the standard is expected to evolve as more 
OpenMath applications become available.

\section{Technical Details}

This chapter describes the Axiom implementation of the 
OpenMath project\cite{Dalm97}
at INRIA. The code enables the exchange of OpenMath objects
between two processes and more generally the input and output of OpenMath
objects. First we describe the library API and then we implement the
functions used by Axiom.
\section{The Structure of the API}
The library and its API are logically structured in four parts:
\begin{itemize} 
\item Functions that deal with {\sl devices}, the abstraction
from which OpenMath objects are read and written to.
\item Functions that read from and write to OpenMath devices. These functions 
use a simple model that read and write tokens.
\item Functions that create I/O  structures to be used by devices, so that,
for example, an OpenMath object can be read from a file or a socket. This part
is extensible by the user. 
\item Functions that deal with interprocess communication.
\end{itemize} 

\section{OpenMath Expressions}

\subsection{Expressions}

The library understands the following kinds of basic OpenMath expressions:
\begin{itemize} 
\item integers
\item double precision  floating-point numbers (64 bits, following IEEE 754)
\item byte arrays
\item character strings
\item symbols
\item variables
\end{itemize} 
and the four kinds of constructions: 
\begin{itemize} 
\item applications $e_0(e_1, \ldots e_n)$
\item errors $s(e_1, \ldots e_n)$
\item binders $e_1, (v_1, \ldots v_n), e_2 $
\item attributed expressions $[s_1 e_1, \ldots s_n e_n] e$
\end{itemize} 
where $e_i$ are OpenMath expressions, $v_i$ are OpenMath variables and $s$ and
$s_i$ are OpenMath symbols. 

\subsection{Symbols}

Symbols are constructed from a content dictionary (abbreviated as CD
in the sequel) and a name.  A content dictionary is identified by its
name.  The API permits the creation of any symbol in any content
dictionary: there is nothing that prevents creating symbols that do
not belong to a known CD.

\subsection{Encoding and Decoding OpenMath Expressions}

An OpenMath object is encoded as a sequence of bytes that is read and
written sequentially. The library views this sequence as a stream of
tokens.  Expressions are linearized in a way that looks like Lisp with
typed parenthesis. For example, the linearization of the application
of $S$ to $E_1\ldots E_n$ is:
\begin{itemize} 
\item indicating that this is an application (a ``begin application'' token)
\item linearizing $S$
\item linearizing $E_1$,\ldots $E_n$
\item indicating that all arguments have been given (an ``end application''
token) 
\end{itemize} 

The other constructions are linearized the same way (each one with its
own begin and end tokens).  Note that there is no explicit arity
indication so that we don't have to introduce a special mechanism when
we don't know beforehand how many arguments there are.

To give attributes to an expression, the attributes and their
associated values are put before the expression. To give the
attributes $a_i$ with values $v_i$ (where $a_i$ are symbols and $v_i$
are OpenMath expressions) to an expression $E$ the process is:
\begin{itemize} 
\item put a ``begin attributed expression'' token
\item put a ``begin attribute pairs'' token
\item put the symbol $a_1$ followed by the linearization of $v_1$ {\sl etc}
\item put an ``end attribute pairs'' token
\item linearize $E$
\item put an ``end attributed expression'' token

\end{itemize} 

Decoding is done by first querying the type of the next OpenMath token and
then invoking the right function to get this particular kind of token.

\section{Big Integers}

The library supports big integers that can potentially be given in
various formats. The {\tt OMBigIntType} describes the different
possible formats.
\begin{verbatim} 
typedef enum OMbigIntType {
  OMBIunknown = 0,  /* this is base 10, digits in normal order */
  OMBIbase10        /* this is base 16, digits in normal order (MSB) */
  OMbigIntBase16
} OMbigIntType;
\end{verbatim} 

\section{Functions Dealing with OpenMath Devices}

OpenMath expressions are read and written through {\sl devices}.
Basically, an OpenMath device has an associated encoding and an I/O
method.  There are basically two encodings defined and implemented.
The first one is a human readable and writable one that can be used
for example as the encoding for sending OpenMath objects via e-mail or
storing OpenMath objects to files.  This encoding is SGML compatible
in the sense that it can be used to represent OpenMath objects in SGML
texts. I has an XML variant.  The second encoding is a binary one that
can be used when compactness and speed of encoding and decoding is
important.  The encodings are defined by the {\tt OMencodingType} type
which is an enumerated type defined as
\begin{verbatim} 
typedef enum OMencodingType 
   { OMencodingUnknown, 
     OMencodingBinary, 
     OMencodingSGML, 
     OMencodingXML} OMencodingType;
\end{verbatim} 
{\tt OMencodingUnknown} is to be used when creating a device that does not
know which kind of encoding will be used. It must be used only for input
devices.

A device is created with the following function, given an encoding and
an appropriate I/O method:
\begin{itemize} 
\item {\tt OMdev OMmakeDevice(OMencodingType encoding, OMIO IO)}
\end{itemize} 
Devices are closed with the following function
\begin{itemize} 
\item {\tt void OMcloseDevice(OMdev dev)}
\end{itemize} 

Whether a device could be used both for reading and writing is entirely
dependent on its I/O method. 

The user can define its own I/O method as a function returning
an {\tt OMIO} object. This could enable him, for example, to use an
existing transport protocol to exchange OpenMath expressions or to implement
cut-and-paste of OpenMath expression by writing I/O structures that input and
output to strings. The I/O section describes the available I/O structures in
the library.

An {\tt OMdev} object is a pointer to a structure that contains a lot
of state. Almost all functions taking an {\tt OMdev} object modify
it. Likewise, an {\tt OMIO} object carries a lot of state.

\section{Functions to Write OpenMath Expressions to Devices}

\subsection{Beginning and Ending Objects}

The following two functions mark the beginning and end of an OpenMath object.
\begin{itemize} 
\item \verb+OMstatus OMputObject(OMdev dev)+
\item \verb+OMstatus OMputEndObject(OMdev dev)+
\end{itemize} 
These functions should be called before and after an OpenMath object
in constructed in a device.  In particular, the \verb+OMputEndObject+
function insures that the object has been completely written if any
buffering was used.

\subsection{Writing Basic Objects}

Basic OpenMath objects are written using these functions:
\begin{itemize} 
\item \verb+OMstatus OMputInt32(OMdev dev, int n)+
\item 
\begin{verbatim}
OMstatus OMputBigInt(OMdev dev, const char *data, int len, int sign, 
                     OMbigIntType format)
\end{verbatim}
\item \verb+OMstatus OMputFloat64(OMdev dev, double *f)+
\item \verb+OMstatus OMputByteArray(OMdev dev, const char *data, int len)+
\item \verb+OMstatus OMputString(OMdev dev, const char *s)+
\item \verb+OMstatus OMputVar(OMdev dev, const char *name)+
\item \verb+OMstatus OMputSymbol(OMdev dev, const char *cd, const char *name)+
\end{itemize} 

The {\tt char *} arguments of {\tt OMputString}, {\tt OMputVar} and {\tt
OMputSymbol} are null-terminated strings. There are other functions that
accept non null-terminated arrays of characters with their length.
These are 
\begin{itemize} 
\item \verb+OMstatus OMputStringN(OMdev dev, const char *str, int len)+
\item \verb+OMstatus OMputVarN(OMdev dev, const char *var, int len)+
\item
\begin{verbatim}
OMstatus OMputSymbolN(OMdev dev, const char *cd, int clen, 
                      const char *name, int nlen)
\end{verbatim}
\end{itemize} 

The format for the {\tt data} argument of the {\tt OMputBigInt} function is
given by {\tt format}. When {\tt format} is {\tt OMBIbase10}, it is the
sequence of character of its base 10 representation without sign (most
significant digit first). The sign of the big integer is given by the 
{\tt sign} argument that should be an integer greater or
equal to zero for a positive integer and less than zero for a negative
one. For example, the following line outputs the value of $20!$ to {\tt dev}:
\begin{verbatim} 
OMputBigInt(dev, "265252859812191058636308480000000", 33, 1, OMBIbase10);
\end{verbatim} 

\subsection{Writing Structured Objects}

The following functions are used to mark the beginning and end of the
structured objects. They should be called in nested pairs, correctly
bracketed:  
\begin{itemize} 
\item \verb+OMstatus OMputApp(OMdev dev)+
\item \verb+OMstatus OMputEndApp(OMdev dev)+
\item \verb+OMstatus OMputAttr(OMdev dev)+
\item \verb+OMstatus OMputEndAttr(OMdev dev)+
\item \verb+OMstatus OMputBind(OMdev dev)+
\item \verb+OMstatus OMputEndBind(OMdev dev)+
\item \verb+OMstatus OMputBVar(OMdev dev)+
\item \verb+OMstatus OMputEndBVar(OMdev dev)+
\item \verb+OMstatus OMputAtp(OMdev dev)+
\item \verb+OMstatus OMputEndAtp(OMdev dev)+
\item \verb+OMstatus OMputError(OMdev dev)+
\item \verb+OMstatus OMputEndError(OMdev dev)+
\end{itemize} 

Here is an example showing how to use these functions to output $\sin x + y$,
where $x$ and $y$ are represented as variables and $\sin$ is the symbol whose
name is {\tt sin} in the {\tt Basic} content dictionary. This can be done
using the following sequence:
\begin{verbatim} 
OMputObject(dev);
OMputApp(dev);
  OMputSymbol(dev, "Basic", "sin");
  OMputApp(dev)
    OMputSymbol(dev, "Basic", "+");
    OMputVar(dev, "x");
    OMputVar(dev, "y");
  OMputEndApp(dev);
OMputEndApp(dev);
OMputEndObject(dev);
\end{verbatim} 

\section{Functions to Extract OpenMath Expressions from Devices}

\subsection{Testing the type of the current token}

The first step in decoding an expression from a device is to call the 
{\tt OMgetType} function
\begin{itemize} 
\item \verb+OMstatus OMgetType(OMdev dev, OMtokenType *type)+
\end{itemize} 
so that the correct function can be called to recover the current token.

{\tt OMgetType} returns via its {\tt type} argument an {\tt OMtokenType}
object indicating the type of the next object to be read from the device. 
{\tt OMtokenType} is an enumerated type defined as 
\begin{verbatim} 
typedef enum OMtokenType {
  OMtokenUnknown, /* error catching trick */
  OMtokenInt32,
  OMtokenBigInt,
  OMtokenFloat64,
  OMtokenByteArray,
  OMtokenVar,
  OMtokenString,
  OMtokenSymbol,
  OMtokenComment,
  OMtokenApp,    OMtokenEndApp,
  OMtokenAttr,   OMtokenEndAttr,
  OMtokenAtp,    OMtokenEndAtp,
  OMtokenError,  OMtokenEndError,
  OMtokenObject, OMtokenEndObject,
  OMtokenBind,   OMtokenEndBind, 
  OMtokenBVar,   OMtokenEndBVar,
} OMtokenType;
\end{verbatim} 
Note that the type of the current token can be tested multiple times. Two
successive calls to {\tt OMgetType} will always return the same result if no
other {\tt OMget...} function was called in between. 

\subsection{Extracting the current token}

\noindent
The following functions are used to read the basic OpenMath objects from
devices: 
\begin{itemize} 
\item \verb+OMstatus OMgetInt32(OMdev dev, int *i)+
\item \verb+OMstatus OMgetFloat64(OMdev dev, double *d)+
\item 
\begin{verbatim}
OMstatus OMgetBigInt(OMdev dev, char **data, int *len, int *sign, 
                     OMbigIntType *fmt)
\end{verbatim}
\item 
\begin{verbatim}
OMstatus OMgetBigIntN(OMdev dev, char *data, int len, int *sign, 
                      OMbigIntType *fmt)
\end{verbatim}
\item \verb+OMstatus OMgetByteArray(OMdev dev, char **data, int *len)+
\item \verb+OMstatus OMgetByteArrayN(OMdev dev, char *data, int len)+
\item \verb+OMstatus OMgetString(OMdev dev, char **str)+
\item \verb+OMstatus OMgetStringN(OMdev dev, char *str, int len)+
\item \verb+OMstatus OMgetVar(OMdev dev, char **var)+
\item \verb+OMstatus OMgetVarN(OMdev dev, char *var, int len)+
\item \verb+OMstatus OMgetSymbol(OMdev dev, char **cd, char **name)+
\item 
\begin{verbatim}
OMstatus OMgetSymbolN(OMdev dev,char *cd,int clen,char *name,int nlen)
\end{verbatim}
\end{itemize} 
The functions that return variable size data exist in two versions. A simple
version that does the necessary memory allocation itself 
(using {\tt OMmalloc}) and a
version (suffixed with {\tt N}) that lets the user do the allocation itself.
The size of the needed area can be determined with the following function:
\begin{itemize} 
\item \verb+int OMgetLength(OMdev dev)+ returns the length of the next
object. 
\end{itemize} 
that works for big integers, byte arrays, strings and variables. For symbols,
the following function returns both the length of the content dictionary name
and the length of the symbol name:
\begin{itemize} 
\item \verb+OMstatus OMgetSymbolLength(OMdev dev, int *clen, int *nlen)+
\end{itemize} 

When the current token does not carry any data i.e. when 
{\tt OMgetType} returns a marker, i.e. one of:
\begin{itemize}
\item {\tt OMtokenApp},
\item {\tt OMtokenEndApp},
\item {\tt OMtokenAttr},
\item {\tt OM tokenEndAttr},
\item {\tt OMtokenAtp},
\item {\tt OMtokenEndAtp},
\item {\tt OMtokenError},
\item {\tt OMtokenEndError},
\item {\tt OMtokenObject},
\item {\tt OMtokenEndObject},
\item {\tt OMtokenBind},
\item {\tt OMtokenEndBind},
\item {\tt OMtokenBVar}
\item {\tt OMtokenEndBVar} 
\end{itemize}
it is necessary to call the correct function to remove the marker. The
available functions are

\begin{itemize} 
\item \verb+OMstatus OMgetObject(OMdev dev)+
\item \verb+OMstatus OMgetEndObject(OMdev dev)+
\item \verb+OMstatus OMgetApp(OMdev dev)+
\item \verb+OMstatus OMgetEndApp(OMdev dev)+
\item \verb+OMstatus OMgetAttr(OMdev dev)+
\item \verb+OMstatus OMgetEndAttr(OMdev dev)+
\item \verb+OMstatus OMgetAtp(OMdev dev)+
\item \verb+OMstatus OMgetEndAtp(OMdev dev)+
\item \verb+OMstatus OMgetBind(OMdev dev)+
\item \verb+OMstatus OMgetEndBind(OMdev dev)+
\item \verb+OMstatus OMgetBVar(OMdev dev)+
\item \verb+OMstatus OMgetEndBVar(OMdev dev)+
\item \verb+OMstatus OMgetError(OMdev dev)+
\item \verb+OMstatus OMgetEndError(OMdev dev)+
\end{itemize} 

All the previous functions return {\tt OMsuccess} when they succeed. When
they return something else, there has been a problem such as calling the
wrong function ({\tt OMgetApp} when there is not a ``beginning of
application'' mark) or a system error. 

The sequence of calls to read an expression is thus completely similar
(if we omit the calls to {\tt OMgetType}) to the sequence of calls to
write the expression. For example, the previous expression ($\sin x + y$)
can be recovered via the sequence:
\begin{verbatim} 
OMgetObject(dev);
OMgetApp(dev);
  OMgetSymbol(dev, ...);
  OMgetApp(dev);
    OMgetSymbol(dev, ...);
    OMgetVar(dev, ...);
    OMgetVar(dev, ...);
  OMgetEndApp(dev);
OMgetEndApp(dev);
OMgetEndObject(dev);
\end{verbatim} 

\verb+OMgetInt32(OMdev dev, int *i)+ returns the integer through its {\tt i}
argument. 

\begin{verbatim}
OMgetBigInt(OMdev dev, char **data, int *len, int *sign, OMbigIntType *fmt)
\end{verbatim}
returns the data corresponding to the big integer in {\tt data}, its length
in {\tt len}, its sign in {\tt sign} and its format in {\tt fmt}.

\begin{verbatim}
OMgetBigIntN(OMdev dev, char *data, int len, int *sign, OMbigIntType *fmt)
\end{verbatim}
copies the data corresponding to the big integer in {\tt data} buffer that
should be (at least) {\tt len} characters long. The sign and format are
returned in the {\tt sign} and {\tt fmt} arguments.

\verb+OMgetByteArray(OMdev dev, char **data, int *len)+ returns the byte
array through its {\tt data} argument. Its length is returned via the 
{\tt len} argument.

\verb+OMgetByteArrayN(OMdev dev, char *data, int len)+ copies the byte array
in the {\tt data} buffer that should be (at least) {\tt len} characters
long. 

\verb+OMgetString(OMdev dev, char **str)+ returns the string trough its 
{\tt str} argument.

\verb+OMgetStringN(OMdev dev, char *str, int len)+ copies the string
in the {\tt str} buffer whose length should be (at least) {\tt len}.
If {\tt len} is greater than the actual length of the string, a null
character is added at the end of {\tt str}.

\verb+OMgetVar(OMdev dev, char **var)+ returns the name of the
variable (as a null-terminated string) in its {\tt var} argument

\verb+OMgetVarN(OMdev dev, char *var, int len)+ copies the name of the
variable in the {\tt var} buffer, whose length should be (at least) 
{\tt len}. 
If {\tt len} is greater than the actual length of the variable name, a null 
character is added at the end of {\tt var}.

\verb+OMgetSymbol(OMdev dev, char **cd, char **name)+ returns the content
dictionary and the name of the symbol through the {\tt cd} and {\tt name}
arguments. 

\verb+OMgetSymbolN(OMdev dev, char *cd, int clen, char *name, int nlen)+ 
copies the content dictionary and the name of the symbols in the {\tt cd} and
{\tt name} buffers. {\tt cd} should be at least {\tt clen} character long and
{\tt name} should be at least {\tt nlen} long. When there is enough room
(based on {\tt clen} or {\tt nlen}) a null character is added after the last
character of the name ({\tt cd} or {\tt name}).

\section{Comments in the SGML/XML Encodings}

The library can also output and read comments (SGML/XML comments) with the
following functions:
\begin{itemize} 
\item \verb+OMstatus OMputComment(OMdev dev, char *comment)+
\item \verb+OMstatus OMputCommentN(OMdev dev, char *comment, int len)+
\item \verb+OMstatus OMgetComment(OMdev dev, char **comment)+
\item \verb+OMstatus OMgetCommentN(OMdev dev, char *comment, int len)+
\end{itemize} 

By default, comments are silently ignored by the library when reading
OpenMath objects (and writing them using the binary encoding).
The function 
\begin{itemize} 
\item \verb+OMbool OMignoreComment(OMdev dev, OMbool set)+
\end{itemize} 
changes this behaviour. When called with {\tt OMfalse}, comments are passed
to the application: the {\tt OMgetType} function will return
{\tt OMtokenComment} when the current token is a comment and the 
{\tt OMgetComment} or {\tt OMgetCommentN} functions should be used to get the
comments. When {\tt OMignoreComment} is called with {\tt OMtrue}, comments
are ignored.

\section{\enspace{}I/O Functions for Devices}

We provide four functions that produce {\tt OMIO} objects for
devices. These functions provide I/O through the {\tt stdio} library
(on {\tt FILE} object), file descriptors and character strings.

\begin{itemize} 
\item \verb+OMIO OMmakeIOFile(FILE *f)+ associates the device with the
file pointer {\tt f}.
\item \verb+OMIO OMmakeIOfd(int fd)+ associates the device with the file
descriptor {\tt fd}.
\item \verb+OMIO OMmakeIOHandle(HANDLE handle)+ associates the device with a 
file handle *Windows specific version of \verb+OMmakeIOfd()+.{\tt fd}.
\item \verb+OMIO OMmakeIOString(char **s)+  associates the device with a 
string.
\end{itemize} 
For example, the following code opens a device that reads from standard
input: 
\begin{verbatim} 
dev = OMmakeDevice(OMencodingSGML, OMmakeIOFile(stdin));
\end{verbatim} 

The {\tt OMmakeIOString} builds an input device that reads from a string
or an output device that writes to a string. For input, {\tt s} must point to
a character string (null terminated). For output, {\tt s} will point to a
string allocated by the library (note that the string {\tt s} points to can
be reallocated by the library).

\section{\enspace{}Communications}

A communication layer can be put above the device layer.  In fact, the
I/O structure in a device provides all the necessary support to use
any transmission or communication means.  This library directly
provides some connection-oriented, client-server facilities (based on
{\sc tcp}).

A set of functions are used to set up connections. Connections are described
by the {\tt OMconn} type. An {\tt OMconn} is a (pointer to a) structure with
two user-accessible fields {\tt in} and {\tt out}. {\tt in} is a pointer to a
device to be used for input. {\tt out} is pointer to a device to be used for
output. These devices use the binary encoding.

An {\tt OMconn} object is made with the following function:
\begin{itemize} 
\item \verb+OMconn OMmakeConn(int timeout)+
\end{itemize} 
where {\tt timeout} is a timeout for the connection, expressed in
milliseconds. 

\begin{itemize} 
\item \verb+OMdev OMconnIn(OMconn conn)+ returns the input device
associated with the connection.
\item \verb+OMdev OMconnOut(OMconn conn)+ returns the output device
associated with the connection.
\end{itemize} 

\subsection{Functions to Initiate an {\tt OMconn}}

The functions we provide can be divided in two classes. The first one
simply establishes an interprocess communication using {\sc IP} addresses.
The second one provides functions that can be used to launch a server. 
The addresses used are then generated by the library.

\subsubsection{Simple Connections Functions}

The following functions allow a client OpenMath application to contact an
OpenMath server at a specified address:
\begin{itemize} 
\item \verb+OMstatus OMconnTCP(OMconn conn, char *machine, int port)+
\item \verb+OMstatus OMconnUnix(OMconn conn, char *file)+
\end{itemize} 
These functions first physically establish the connection. Then, they enter
negotiation with the server (they send the first message). When they return,
the negotiation is finished and the devices in the {\tt conn} argument are
ready. 

On the server side, the following functions provide bindings at specified
addresses and take care of the negotiation:
\begin{itemize} 
\item \verb+OMstatus OMbindTCP(OMconn conn, int port)+
\item \verb+OMstatus OMbindUnix(OMconn conn, char *file)+
\end{itemize} 

All four the previous  functions block until the connection is established
(and negotiation is over) or the timeout of the {\tt conn} argument is
reached.

The following function returns the file descriptor associated with a device.
This is intended to be used when there is a need to poll the device (through
the {\tt select} or {\tt poll} system calls).
\begin{itemize}
\item \verb+OMdeviceFd(OMdev dev)+
\end{itemize} 

\subsubsection{Functions that Launch Servers}

These functions provide the same functionalities for launching a
server that were provided in the {\sc asap} library.

In this model, the client calls {\tt OMlaunch} with a machine name
{\tt mach} and a string {\tt cmd} that is executed via {\tt rsh} on
machine {\tt mach} as a shell command line. This command is supposed
to launch the server program. The command is executed in an
environment (in the {\sc unix} sense) where some variables are
associated with an address on the machine that runs the client. The
server can then connect to the client with the {\tt OMserveClient}
function.

If the machine name is {\tt localhost}, the command is started on the
same machine (without calling {\tt rsh}).

\begin{itemize} 
\item 
\begin{verbatim}
OMstatus OMlaunchEnv(OMconn conn, char *machine, char *command, char *env)
\end{verbatim}
\item \verb+OMstatus OMlaunch(OMconn conn, char *machine, char *command)+
\item \verb+OMstatus OMserveClient(OMconn conn)+
\end{itemize} 

The environment variables sent to the server (launched program) are
{\verb+OM_CALLER_UNIX_SOCKET+} (when a local connection is required) and 
{\verb+OM_CALLER_MACHINE+} and {\verb+OM_CALLER_PORT+} (for internet
connections).

The {\tt OMlaunchEnv} function enables the command to be run with a
particular environment (in the {\sc unix} sense). For example to run a
{\tt plot} server on the {\tt kama} machine, we could use a piece of code
such as 
\begin{verbatim} 
conn = OMmakeConn(2000);
OMlaunchEnv(conn, "kama", "plot", "DISPLAY=rati:0 PATH=/users/bin");
\end{verbatim} 

\subsubsection{Termination}

\begin{itemize} 
\item \verb+OMstatus OMconnClose(OMconn conn)+
\end{itemize} 

\section{\enspace{}Parameters}

The library internally uses three functions that can be supplied by the user.
\begin{itemize} 
\item \verb+extern void *(*OMmalloc) (size_t size)+
\item \verb+extern void *(*OMrealloc) (void *ptr, size_t size)+
\item \verb+extern void (*OMfree) (void *ptr)+
\end{itemize} 

\begin{itemize} 
\item {\tt OMmalloc} is used for all memory allocations in the library. 
The default value is the {\tt malloc} function.
\item {\tt OMfree} is used for deallocations. The default value is the 
{\tt free} function. 
\item {\tt OMfatal} is invoked when a fatal error is detected in the library
(for example when memory allocation failed or when an inconsistency is
detected in the library code data structures). The default value just does an
{\tt exit}.
\end{itemize}
{\tt OMfatal} is declared as 
{\tt \verb+extern void (*OMfatal)(OMstatus status)+}. 
All memory allocations and deallocations in the library are done through the
{\tt OMmalloc} and {\tt OMfree} functions.

\section{\enspace{}Miscellaneous Functions and Variables}

\begin{itemize} 
\item \verb+char *OMstatusToString(OMstatus status)+ make a status into a
human readable string.
\item \verb+char *OMtokenTypeToString(OMtokenType ttype)+ makes a
{\tt tokenType} into a human readable string.
\item \verb+OMencodingType OMgetDeviceEncoding(OMdev dev)+ returns the
encoding actually used by the device.
\item \verb+char *OMlibDynamicInfo(void)+
\item \verb+extern const char *OMlibVersion+ is the version of the library.
\item \verb+extern const char *OMlibInfo+ contains some textual information
about the library.
\end{itemize} 

\section{\enspace{}The OM.h header file}
\begin{verbatim}
#ifndef __OM_h__
#define __OM_h__

/*
 *                      All types used through API.
 */

/* These types are anonymized by the mean of a generic pointer.
 * You should not allocate or dereference objects of these types.
 * API (hopefully) provides you with all needed methods.
 * If you find any that are not included, please refer to 
 * us rather than using private structures.
 * ie: If you need to do something like 
 *   malloc(sizeof(OMdevStruct));
 * or
 *   OMdevStruct * pDev;
 *   pDev->anyField = something;
 * this probably means we need to discuss your problem.
 */

/* A device is an abstraction for put/get of OpenMath tokens */
typedef struct OMdevStruct *OMdev;

/* IO is a device field, (the physical IO channel) */
typedef struct OMIOStruct *OMIO;


/* Error status that may be returned 
 */
typedef enum OMstatus {
  /* Last call was successful. */
  OMsuccess = 0,
  /* Last call failed for some undetermined reason. */
  OMfailed = 1,
  /* Last call failed for memory reasons. */
  OMnoMem,
  /* Last call failed during some system call. */
  OMerrorSys,
  /* Last call to some OMget* function failed due to an unexpected EOF 
     on input IO. */
  OMemptyIO,
  /* Last call to some OMget* function failed because there is no more 
     token on device. */
  OMnoMoreToken,
  /* Last call to some OMget* function timeouted. */
  OMtimeoutedRead,
  /* Last call to some OMget* function failed due to malformed input. 
    (this error covers all low level lexical or syntactic problems). */
  OMmalformedInput,
  /* Last call to OMbindTCP failed because address is already in use 
     (EADDRINUSE). */
  OMaddrInUse,
  /* Last call to OMconnTCP failed to set connection. */
  OMconnectFailed,
  /* Last call trigered some not (yet) implemented code in this lib. */
  OMnotImplemented,
  /* Last call caused some internal trouble. */
  OMinternalError
} OMstatus;

/* All OpenMath token kinds are identified by one of these types.
 * Values given in this enum have been chosen to:
 * - avoid  conflicts whith specific XML characters 
 *   to help automatic detection of encoding type.
 *   (no: '\t'(9) '\r'(13) '\n'(10) '<'(60) or ' '(32))
 * - keep some bits (3) available for special encodings purpose
 *   (eg: sharing or big len flags in binary encoding)
 */
typedef enum OMtokenType {
  OMtokenUnknown = 0, /* error catching trick */
  OMtokenInt32 = 1,
  OMtokenBigInt = 2,
  OMtokenFloat64 = 3,
  OMtokenByteArray = 4,
  OMtokenVar = 5,
  OMtokenString = 6,
  OMtokenWCString = 7,
  OMtokenSymbol = 8,
  OMtokenComment = 15,
  OMtokenApp = 16, OMtokenEndApp = 17,
  OMtokenAttr = 18, OMtokenEndAttr = 19,
  OMtokenAtp = 20, OMtokenEndAtp = 21,
  OMtokenError = 22, OMtokenEndError = 23,
  OMtokenObject = 24, OMtokenEndObject = 25,
  OMtokenBind = 26,   OMtokenEndBind = 27, 
  OMtokenBVar = 28,   OMtokenEndBVar = 29
} OMtokenType;

typedef enum OMbigIntType {
  OMbigIntUnknown = 0,
  /* this is base 10, digits in normal order (MSB) */
  OMbigIntBase10,
  /* this is base 16, digits in normal order (MSB) */
  OMbigIntBase16
} OMbigIntType;

/* Encodings should not be "user visible"
 * We thus refer to encoding as "symbolic constants" from this enum type. */
typedef enum OMencodingType {
  /* You may set an input stream to "unknown encoding".
   * By doing this, you let library auto detect the
   * encoding type of the device during first token input.*/
  OMencodingUnknown = 0,
  /* Binary encoding, more compact than XML one. */
  OMencodingBinary,
  /* XML-like encoding, human readable. */
  OMencodingXML,
} OMencodingType;

/* This is a portable equivalent to wchar_t for unicode strings */
typedef unsigned short OMUCS2;

/* Replacment for lacking C bools */
typedef unsigned char OMbool;
#define OMfalse (0)
#define OMtrue  (1)

/*
 *                        Some global variables
 */

/* Version of this lib (eg: "1.0") */
extern const char *OMlibVersion;

/* Some textual information about this lib (eg: "debug is on" */
extern const char *OMlibInfo;

/* These pointers allow you to redefine memory managment functions 
   used in lib. */
extern void *(*OMmalloc) (size_t size);
extern void *(*OMrealloc) (void *ptr, size_t size);
extern void (*OMfree) (void *ptr);

/* If set, this function will be called by OMfatal, thus you may use it for 
   error handling (by default it is set to exit()) */
extern void (*OMfatal) (OMstatus status);



/* for C++ includes */
#ifdef  __cplusplus
#define OMbeginPrototypes   extern "C" {
#define OMendPrototypes     }
#else /*__cplusplus */
#define OMbeginPrototypes   
#define OMendPrototypes     
#endif /*__cplusplus */

/*
 *                       Prototypes of OpenMath API
 */

/* Prototypes that are spread along all headers are repeated here.
 * - This should ease the API users.
 *   (docs are fine but source is always the ultimate help)
 * - This allow a cleaner embeding of library 
 *   (no need to install all .h! just take this one and the .a)
 */
OMbeginPrototypes
#ifndef OM_DEV
/* this part is automaticaly updated, do NOT edit below */
/** Prototypes */
/* OMPut* functions. 
 *    They all take a device <dev> to put token to.
 *    Some of them need more parameters to define the token content.
 *    They are thoroughly documented in OpenMath Specification shiped 
 *    with the library.
 * return: a status that reflect the operation success. 
 */
extern OMstatus OMputInt32(OMdev dev, int n);
extern OMstatus OMputFloat64(OMdev dev, double *d);
extern OMstatus OMputBigInt(OMdev dev, const char *data, int len, 
                            int sign, OMbigIntType format);
extern OMstatus OMputByteArray(OMdev dev, const char *data, int len);
/* OMputString*
 *   If you want to output plain 8bits C like strings there is no need
 *   to use the OMputWCString* functions. This one is more efficient
 *   (faster and more compact output for some encodings)
 */
extern OMstatus OMputString(OMdev dev, const char *str);
extern OMstatus OMputStringN(OMdev dev, const char *str, int len);
/* OMputWCString
 *   If you are using wide char strings you need to output them 
 *   with that function rather than with OMputString.
 *   (It takes endianess into account) 
 */
extern OMstatus OMputWCString(OMdev dev, const OMUCS2 * wcstr);
extern OMstatus OMputVar(OMdev dev, const char *var);
extern OMstatus OMputVarN(OMdev dev, const char *var, int len);
extern OMstatus OMputSymbol(OMdev dev, const char *cd, const char *name);
extern OMstatus OMputSymbolN(OMdev dev, const char *cd, int clen, 
                             const char *name, int nlen);
extern OMstatus OMputApp(OMdev dev);
extern OMstatus OMputEndApp(OMdev dev);
extern OMstatus OMputAttr(OMdev dev);
extern OMstatus OMputEndAttr(OMdev dev);
extern OMstatus OMputAtp(OMdev dev);
extern OMstatus OMputEndAtp(OMdev dev);
extern OMstatus OMputBind(OMdev dev);
extern OMstatus OMputEndBind(OMdev dev);
extern OMstatus OMputBVar(OMdev dev);
extern OMstatus OMputEndBVar(OMdev dev);
extern OMstatus OMputObject(OMdev dev);
extern OMstatus OMputEndObject(OMdev dev);
extern OMstatus OMputError(OMdev dev);
extern OMstatus OMputEndError(OMdev dev);
extern OMstatus OMputComment(OMdev dev, const char *comment);
extern OMstatus OMputCommentN(OMdev dev, const char *comment, int len);
/* OMgetType
 *   Get the type of the current token on device <dev>/
 * dev: device to look at.
 * type: where to store returned type.
 * return: 0 or some error code
 */
extern OMstatus OMgetType(OMdev dev, OMtokenType * type);
/* OMgetLength
 *   Get the current token length.
 * dev: device to read from
 * len: where to put the token length 
 *      the last '\0' for string like tokens is not counted
 *      (rem: for WCString it is the number of bytes not the number of 
 *       wide chars)
 * return: 0 or some error code
 */
extern OMstatus OMgetLength(OMdev dev, int *len);
/* OMgetSymbolLength
 *   Get the current token (wich is assumed to be a symbol) lengths.
 * dev: device to read from
 * clen: where to put the cd length (not counting the last '\0')
 * nlen: where to put the name length (not counting the last '\0')
 * return: 0 or some error code
 */
extern OMstatus OMgetSymbolLength(OMdev dev, int *clen, int *nlen);
/* OMGet* functions. 
 *    They all take a device <dev> to get token from.
 *    Some of them need more parameters to fill with the token content.
 *    They are thoroughly documented in OpenMath Specification shiped with 
 *    the library.
 * return: a status that reflect the operation success. 
 */
extern OMstatus OMgetInt32(OMdev dev, int *i);
extern OMstatus OMgetFloat64(OMdev dev, double *d);
extern OMstatus OMgetBigInt(OMdev dev, char **data, int *len, int *sign, 
                            OMbigIntType * format);
extern OMstatus OMgetBigIntN(OMdev dev, char *data, int len, int *sign, 
                             OMbigIntType * format);
extern OMstatus OMgetByteArray(OMdev dev, char **data, int *len);
extern OMstatus OMgetByteArrayN(OMdev dev, char *data, int len);
/* OMgetString*
 *   Beware! You are not suposed to use these functions unless you know
 *   for sure you are reading plain 8bits strings.
 *   Thus it is here only for speed/space consideration in very 
 *   specific applications.
 *   If input is a 16 bit char string and you read it with these 
 *   functions you will lose the 8 most significant bits of each char.
 *   You should rather refer to OMgetWCString* functions.
 */
extern OMstatus OMgetString(OMdev dev, char **str);
extern OMstatus OMgetStringN(OMdev dev, char *str, int len);
/* OMgetWCString*
 *   These functions return 16 bits wide strings. (regardless input 
 *   was done in 8 or 16 bits mode).
 *   Thus, most if not all applications should use these functions 
 *   preferably to OMgetString*.
 */
extern OMstatus OMgetWCString(OMdev dev, OMUCS2 ** wcstr);
/* BEWARE: the <len> is suposed to be the length in bytes for the 
 * preallocated buffer <wcstr> (not the length in number of wide chars)
 */
extern OMstatus OMgetWCStringN(OMdev dev, OMUCS2 * wcstr, int len);
extern OMstatus OMgetVar(OMdev dev, char **var);
extern OMstatus OMgetVarN(OMdev dev, char *var, int len);
extern OMstatus OMgetSymbol(OMdev dev, char **cd, char **name);
extern OMstatus OMgetSymbolN(OMdev dev, char *cd, int clen, char *name, 
                             int nlen);
extern OMstatus OMgetApp(OMdev dev);
extern OMstatus OMgetEndApp(OMdev dev);
extern OMstatus OMgetAttr(OMdev dev);
extern OMstatus OMgetEndAttr(OMdev dev);
extern OMstatus OMgetAtp(OMdev dev);
extern OMstatus OMgetEndAtp(OMdev dev);
extern OMstatus OMgetBind(OMdev dev);
extern OMstatus OMgetEndBind(OMdev dev);
extern OMstatus OMgetBVar(OMdev dev);
extern OMstatus OMgetEndBVar(OMdev dev);
extern OMstatus OMgetObject(OMdev dev);
extern OMstatus OMgetEndObject(OMdev dev);
extern OMstatus OMgetError(OMdev dev);
extern OMstatus OMgetEndError(OMdev dev);
extern OMstatus OMgetComment(OMdev dev, char **comment);
extern OMstatus OMgetCommentN(OMdev dev, char *comment, int len);
/* OMbeginObject
 *   Must be called before every new OpenMath object put.
 *   (Not before every token!)
 * dev: device where new object is to be put.
 * return: status describing operation success
 */
extern OMstatus OMbeginObject(OMdev dev);
/* OMendObject
 *   Must be called after every OpenMath object put.
 *   (Not after every token!)
 * dev: device where object has been put.
 * return: status describing operation success
 */
extern OMstatus OMendObject(OMdev dev);
/* OMignoreComment
 *   Set behavior of a device concerning comments.
 *   (Comments on an input device may safely be ignored.)
 * dev: device to modify
 * set: If set == OMtrue then device will ignore incoming comments
 *      If set == OMfalse then device will process incoming comments 
 *                         like other tokens.
 *      By default comments are ignored.
 *      Whatever is <set> value, output of comments is always done.
 * return: previous value
 */
extern OMbool OMignoreComment(OMdev dev, OMbool set);
/* OMtokenCount
 *   Reports the numbe rof tokens that have been in/output on a device
 * dev: devive to examine
 * inTokenNb: where to store number of input tokens (if not NULL)
 * outTokenNb: where to store number of output tokens (if not NULL)
 */
extern void OMtokenCount(OMdev dev, int *inTokenNb, int *outTokenNb);
/* OMgetDeviceEncoding
 *   Get the currnet encoding used by a device
 * dev: device to examine
 * return: current encoding
 */
extern OMencodingType OMgetDeviceEncoding(OMdev dev);
/* OMsetDeviceEncoding
 *   Set the encoding that will be used on a device
 *   BEWARE: changing encoding on a device that has already been used 
 *   for IO is unsafe.
 *   but seting encoding on a new device is safe. 
 *   (in some occasions, it is not easy to know which encoding to 
 *    use at device creation)  
 * dev: device to modify
 * encoding: encoding to use
 */
extern void OMsetDeviceEncoding(OMdev dev, OMencodingType encoding);
/* OMmakeDevice
 *   Create a device from a low level IO 
 *   Warning: "IO" should be a "generated" (new) structure as it contains some 
 *   state that is private to the device. It is very dangerous for two devices 
 *   to share the same "IO" structure.
 * encoding: encoding scheme used by device
 * IO: low level I/O suport for device
 * return: a newly allocated device
 */
extern OMdev OMmakeDevice(OMencodingType encoding, OMIO IO);
/* OMcloseDevice
 *   Close a device previously created with OMmakeDevice
 *   (embedded IO is closed too)
 * dev: device to close
 */
extern void OMcloseDevice(OMdev dev);
/* OMmakeIOFd
 *   Create a low level IO object from a file descriptor.
 *   (May be used on socket for instance.)
 * fd: file descriptor to wrap into the OpenMath IO object.
 * return: a newly allocated IO object.
 */
extern OMIO OMmakeIOFd(int fd);
/* OMmakeIOFile
 *   Create a low level IO object from a FILE*.
 *   (May be used on stdin for instance.)
 * fd: FILE* to wrap into the OpenMath IO object.
 * return: a newly allocated IO object.
 */
extern OMIO OMmakeIOFile(FILE * f);
/* OMmakeIOString
 *   Create a low level IO object from a string (NUL terminator is not needed).
 *   (May be used for copy/paste for instance.)
 * s: pointer to string to use into the OpenMath IO object.
 *    - In case of input device the string must be NUL terminated.
 *    - In case of output device string may be reallocated
 *      to fit size of outcoming objects.
 * return: a newly allocated IO object.
 */
extern OMIO OMmakeIOString(char **s);
/* OMstatusToString
 *   Convert a status to a human readable string that explain its meaning
 * status: status to explain
 * return: corresponding string
 */
extern char *OMstatusToString(OMstatus status);
/* OMtokenTypeToString
 *   Convert a tokenType to a human readable string
 * ttype: type to convert
 * return: corresponding string
 */
extern char *OMtokenTypeToString(OMtokenType ttype);
/* OMsetVerbosityLevel
 *   When using API some infos may be loged.
 *   This set the required verbosity level.
 * level: level of verbosity.
 *        0 means nothing is nether printed
 *        1 everything is printed (default)
 *        2,... less verbose
 * return: last verbosity level
 */
extern int OMsetVerbosityLevel(int level);
/* OMsetVerbosityOutput
 *   When using API some infos may be loged.
 *   This set the destination for logs.
 * logFile: where to output logs (default is stderr)
 * return: last output
 */
extern FILE *OMsetVerbosityOutput(FILE * logFile);
/* OMlibDynamicInfo
 *   Gather some informations about lib that can't be statically determined.
 *   Complete them with some relevant static infornation too.
 * return: a newly allocated string
 */
extern char *OMlibDynamicInfo(void);
/*** End Prototypes */
/* end of automaticaly updated part */

#ifdef WIN32
#include "windows.h"

/* OMmakeIOHandle
 *   Create a low level IO object from a widows handle.
 * handle: windows handle to wrap into the OpenMath IO object.
 * return: a newly allocated IO object.
 */
extern OMIO OMmakeIOHandle(HANDLE handle);
extern void OMfreeIOHandle(OMIO io);
#endif

#else /* OM_DEV */
/* The prototypes above are in fact collected from all these .h files */
#include "OMbase.h"
#include "OMdev.h"
#include "OMdevFd.h"
#include "OMdevFile.h"
#include "OMdevString.h"
#include "OMdevHandle.h"
#include "OMencBin.h"
#include "OMencXml.h"
#include "OMmisc.h"
#include "OMutf7.h"
#endif /* OM_DEV */

OMendPrototypes

#endif /* __OM_h__ */
\end{verbatim}

\section{\enspace{}Axiom OpenMath stub functions}
These stub functions will eventually be expanded to handle OpenMath.
See the OpenMathDevice domain in Volume 10.3. Note that the argument
list for the Spad functions does not always match the argument list
specified in the OpenMath specification.

There are 4 known OpenMath encodings which are set up in the OpenMathEncoding
domain in Volume 10.3.
\begin{itemize}
\item Unknown 
\item Binary
\item XML
\item SGML
\end{itemize}

\subsection{Axiom specific functions}
This is used in OpenMathPackage in Volume 10.4.
\begin{verbatim}
(read OMdev)              -> LispObject
(listCDs)                 -> List(String)
(listSymbols)             -> List(String)
(supportsCD cd)           -> Boolean
(supportsSymbol cd name)  -> Boolean
\end{verbatim}

\defun{om-Read}{om-Read}
Read an OpenMath object from dev.
\begin{chunk}{defun om-Read}
(defun om-Read (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-listCDs}{om-listCDs}
Lists all of the CDs supported by Axiom.
\begin{chunk}{defun om-listCDs}
(defun om-listCDs ())

\end{chunk}

\defun{om-listSymbols}{om-listSymbols}
Lists all the symbols in CD
\begin{chunk}{defun om-listSymbols}
(defun om-listSymbols ())

\end{chunk}

\defun{om-supportsCD}{om-supportsCD}
Return true if Axiom supports this CD.
\begin{chunk}{defun om-supportsCD}
(defun om-supportsCD (cd)
 (declare (ignore cd)))

\end{chunk}

\defun{om-supportsSymbol}{om-supportsSymbol}
\begin{chunk}{defun om-supportsSymbol}
(defun om-supportsSymbol (cd name)
 (declare (ignore cd name)))

\end{chunk}

\subsection{Lisp conversion functions}
The lisp conversion functions are:
\begin{verbatim}
 (toDev                 LispObject)                   -> OMdev
 (fromDev               OMdev)                        -> LispObject
 (toStatus              LispObject)                   -> LispObject
 (fromStatus            OMstatus)                     -> LispObject
 (toEncodingType        LispObject)                   -> OMencodingType
 (fromEncodingType      OMencodingType)               -> LispObject
 (toBigNumStr           LispObject)                   -> char *
 (fromBigNumStr         char *,int,int, OMbigIntType) -> LispObject
 (toConn                LispObject)                   -> OMconn
 (fromConn              OMconn)                       -> LispObject
 (toCString             LispObject)                   -> char **
 (fromCString           char **)                      -> LispObject
 (lispStringFromCString LispObject)                   -> LispObject
 (cStringFromLispString LispObject)                   -> LispObject
\end{verbatim}

\defun{om-setDevEncoding}{om-setDevEncoding}
This sets the encoding used for reading or writeing OpenMath objects to
or from dev to enc.
\begin{chunk}{defun om-setDevEncoding}
(defun om-setDevEncoding (dev enc)
 (declare (ignore dev enc)))

\end{chunk}

\subsection{Device manipulation functions}
\begin{verbatim}
(openFileDev LispObject, ints, ...)              -> LispObject
(openStrDev  LispObject, LispObject, LispObject) -> LispObject
(closeDev    LispObject, LispObject)             -> LispObject
\end{verbatim}

\defun{om-openFileDev}{om-openFileDev}
This opens file fname for reading or writing OpenMath objects.
The mode can be ``r'' for read, ``w'' for write, or ''a'' for append.
\begin{chunk}{defun om-openFileDev}
(defun om-openFileDev (fname fmode enc)
 (declare (ignore fname fmode enc)))

\end{chunk}

\defun{om-openStringDev}{om-openStringDev}
This opens the string str for reading and writing OpenMath objects in 
encoding enc.
\begin{chunk}{defun om-openStringDev}
(defun om-openStringDev (str enc)
 (declare (ignore str enc)))

\end{chunk}

\defun{om-closeDev}{om-closeDev}
This closes dev, flushing output if necessary.
\begin{chunk}{defun om-closeDev}
(defun om-closeDev (dev)
 (declare (ignore dev)))

\end{chunk}

\subsection{Connection manipulation functions}
These are covered in the OpenMathConnection domain in Volume 10.3.
\begin{verbatim}
 (makeConn      LispObject, LispObject) -> LispObject
 (closeConn     LispObject, LispObject) -> LispObject
 (getConnInDev  LispObject, LispObject) -> LispObject
 (getConnOutDev LispObject, LispObject) -> LispObject
\end{verbatim}

\defun{om-makeConn}{om-makeConn}
\begin{chunk}{defun om-makeConn}
(defun om-makeConn (conn)
 (declare (ignore conn)))

\end{chunk}

\defun{om-closeConn}{om-closeConn}
\begin{chunk}{defun om-closeConn}
(defun om-closeConn (conn)
 (declare (ignore conn)))

\end{chunk}

\defun{om-getConnInDev}{om-getConnInDev}
\begin{chunk}{defun om-getConnInDev}
(defun om-getConnInDev (conn)
 (declare (ignore conn)))

\end{chunk}

\defun{om-getConnOutDev}{om-getConnOutDev}
\begin{chunk}{defun om-getConnOutDev}
(defun om-getConnOutDev (conn)
 (declare (ignore conn)))

\end{chunk}

\subsection{Client/Server functions}
These are covered in the OpenMathConnection domain in Volume 10.3.
See OMconn.h
\begin{verbatim}
(bindTCP    LispObject, LispObject, LispObject) -> LispObject
(connectTCP LispObject, int, ...)               -> LispObject
\end{verbatim}

\defun{om-bindTCP}{om-bindTCP}
\begin{chunk}{defun om-bindTCP}
(defun om-bindTCP (conn port)
 (declare (ignore conn port)))

\end{chunk}

\defun{om-connectTCP}{om-connectTCP}
\begin{chunk}{defun om-connectTCP}
(defun om-connectTCP (conn host port)
 (declare (ignore conn host port)))

\end{chunk}

\subsection{Device input/output functions}
Most of these functions are in the OpenMathDevice domain in Volume 10.3.
The only exception seems to be the om-stringPtrToString and 
om-stringToStringPtr functions which are called in the domains that
export primitives. Currently these are:
\begin{itemize}
\item Complex (10.3)
\item DoubleFloat (10.3)
\item Float (10.3)
\item Fraction (10.3)
\item Integer (10.3)
\item List (10.3)
\item SingleInteger (10.3)
\item String (10.3)
\item Symbol (10.3)
\item ExpressionToOpenMath (10.4)
\item OpenMathPackage (10.4)
\end{itemize}

Note that putSymbol2 is not implemented.
\begin{verbatim}
(getApp            LispObject, LispObject) -> LispObject
(getAtp            LispObject, LispObject) -> LispObject
(getAttr           LispObject, LispObject) -> LispObject
(getBind           LispObject, LispObject) -> LispObject
(getBVar           LispObject, LispObject) -> LispObject
(getByteArray      LispObject, LispObject) -> LispObject
(getEndApp         LispObject, LispObject) -> LispObject
(getEndAtp         LispObject, LispObject) -> LispObject
(getEndAttr        LispObject, LispObject) -> LispObject
(getEndBind        LispObject, LispObject) -> LispObject
(getEndBVar        LispObject, LispObject) -> LispObject
(getEndError       LispObject, LispObject) -> LispObject
(getEndObject      LispObject, LispObject) -> LispObject
(getError          LispObject, LispObject) -> LispObject
(getFloat          LispObject, LispObject) -> LispObject
(getInt            LispObject, LispObject) -> LispObject
(getObject         LispObject, LispObject) -> LispObject
(getString         LispObject, LispObject) -> LispObject
(getSymbol         LispObject, LispObject) -> LispObject
(getType           LispObject, LispObject) -> LispObject
(getVar            LispObject, LispObject) -> LispObject
(putApp            LispObject, LispObject) -> LispObject
(putAtp            LispObject, LispObject) -> LispObject
(putAttr           LispObject, LispObject) -> LispObject
(putBind           LispObject, LispObject) -> LispObject
(putBVar           LispObject, LispObject) -> LispObject
(putByteArray      LispObject, LispObject, LispObject) -> LispObject
(putEndApp         LispObject, LispObject) -> LispObject
(putEndAtp         LispObject, LispObject) -> LispObject
(putEndAttr        LispObject, LispObject) -> LispObject
(putEndBind        LispObject, LispObject) -> LispObject
(putEndBVar        LispObject, LispObject) -> LispObject
(putEndError       LispObject, LispObject) -> LispObject
(putEndObject      LispObject, LispObject) -> LispObject
(putError          LispObject, LispObject) -> LispObject
(putFloat          LispObject, LispObject, LispObject) -> LispObject
(putInt            LispObject, LispObject, LispObject) -> LispObject
(putObject         LispObject, LispObject) -> LispObject
(putString         LispObject, LispObject, LispObject) -> LispObject
(putSymbol         LispObject, LispObject, LispObject) -> LispObject
(putSymbol2        LispObject, int nargs, ...) -> LispObject
(putVar            LispObject, LispObject, LispObject) -> LispObject
(stringPtrToString LispObject, LispObject) -> LispObject
(stringToStringPtr LispObject, LispObject) -> LispObject
\end{verbatim}

\defun{om-getApp}{om-getApp}
Reads a begin application token from dev.
\begin{chunk}{defun om-getApp}
(defun om-getApp (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-getAtp}{om-getAtp}
Reads a begin attribute pair token from dev.
\begin{chunk}{defun om-getAtp}
(defun om-getAtp (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-getAttr}{om-getAttr}
Reads a begin attribute token from dev
\begin{chunk}{defun om-getAttr}
(defun om-getAttr (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-getBind}{om-getBind}
Reads a begin binder token from dev.
\begin{chunk}{defun om-getBind}
(defun om-getBind (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-getBVar}{om-getBVar}
Reads a begin bound variable list token from dev.
\begin{chunk}{defun om-getBVar}
(defun om-getBVar (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-getByteArray}{om-getByteArray}
Reads a byte array from dev.
\begin{chunk}{defun om-getByteArray}
(defun om-getByteArray (dev))

\end{chunk}

\defun{om-getEndApp}{om-getEndApp}
Reads an end application token from dev
\begin{chunk}{defun om-getEndApp}
(defun om-getEndApp (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-getEndAtp}{om-getEndAtp}
Reads an end attribute pair token from dev.
\begin{chunk}{defun om-getEndAtp}
(defun om-getEndAtp (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-getEndAttr}{om-getEndAttr}
Reads an end attribute token from dev.
\begin{chunk}{defun om-getEndAttr}
(defun om-getEndAttr (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-getEndBind}{om-getEndBind}
Reads an end binder token from dev.
\begin{chunk}{defun om-getEndBind}
(defun om-getEndBind (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-getEndBVar}{om-getEndBVar}
Reads an end bound variable list token from dev.
\begin{chunk}{defun om-getEndBVar}
(defun om-getEndBVar (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-getEndError}{om-getEndError}
Reads an end error token from dev.
\begin{chunk}{defun om-getEndError}
(defun om-getEndError (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-getEndObject}{om-getEndObject}
Reads an end object token from dev.
\begin{chunk}{defun om-getEndObject}
(defun om-getEndObject (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-getError}{om-getError}
Reads a begin error token from dev.
\begin{chunk}{defun om-getError}
(defun om-getError (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-getFloat}{om-getFloat}
Reads a float from dev.
\begin{chunk}{defun om-getFloat}
(defun om-getFloat (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-getInt}{om-getInt}
Reads an integer from dev.
\begin{chunk}{defun om-getInt}
(defun om-getInt (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-getObject}{om-getObject}
Reads a begin object token from dev.
\begin{chunk}{defun om-getObject}
(defun om-getObject (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-getString}{om-getString}
Reads a string from dev.
\begin{chunk}{defun om-getString}
(defun om-getString (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-getSymbol}{om-getSymbol}
Reads a symbol from dev.
\begin{chunk}{defun om-getSymbol}
(defun om-getSymbol (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-getType}{om-getType}
Returns the type of the next object on dev.
\begin{chunk}{defun om-getType}
(defun om-getType (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-getVar}{om-getVar}
Reads a variable from dev.
\begin{chunk}{defun om-getVar}
(defun om-getVar (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-putApp}{om-putApp}
Writes a begin application token to dev.
\begin{chunk}{defun om-putApp}
(defun om-putApp (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-putAtp}{om-putAtp}
This writea a begin application pair token to dev.
\begin{chunk}{defun om-putAtp}
(defun om-putAtp (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-putAttr}{om-putAttr}
This writes a begin attribute token to dev.
\begin{chunk}{defun om-putAttr}
(defun om-putAttr (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-putBind}{om-putBind}
This writes a begin binder token to dev.
\begin{chunk}{defun om-putBind}
(defun om-putBind (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-putBVar}{om-putBVar}
This writes a begin bound variable list token to dev.
\begin{chunk}{defun om-putBVar}
(defun om-putBVar (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-putByteArray}{om-putByteArray}
This writes a byte array to dev.
\begin{chunk}{defun om-putByteArray}
(defun om-putByteArray (dev b)
 (declare (ignore dev b)))

\end{chunk}

\defun{om-putEndApp}{om-putEndApp}
This writes an end application token to dev.
\begin{chunk}{defun om-putEndApp}
(defun om-putEndApp (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-putEndAtp}{om-putEndAtp}
This writes an end attribute pair to dev.
\begin{chunk}{defun om-putEndAtp}
(defun om-putEndAtp (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-putEndAttr}{om-putEndAttr}
This writes an end attribute token to dev.
\begin{chunk}{defun om-putEndAttr}
(defun om-putEndAttr (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-putEndBind}{om-putEndBind}
This writes an end binder token to dev.
\begin{chunk}{defun om-putEndBind}
(defun om-putEndBind (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-putEndBVar}{om-putEndBVar}
This writes and end bound variable list token to dev
\begin{chunk}{defun om-putEndBVar}
(defun om-putEndBVar (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-putEndError}{om-putEndError}
This writes an end error token to dev
\begin{chunk}{defun om-putEndError}
(defun om-putEndError (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-putEndObject}{om-putEndObject}
This writes an end object token to dev.
\begin{chunk}{defun om-putEndObject}
(defun om-putEndObject (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-putError}{om-putError}
This writes a begin error token to dev.
\begin{chunk}{defun om-putError}
(defun om-putError (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-putFloat}{om-putFloat}
This writes the float f to dev.
\begin{chunk}{defun om-putFloat}
(defun om-putFloat (dev f)
 (declare (ignore dev f)))

\end{chunk}

\defun{om-putInt}{om-putInt}
This writes the integer i to dev
\begin{chunk}{defun om-putInt}
(defun om-putInt (dev i)
 (declare (ignore dev i)))

\end{chunk}

\defun{om-putObject}{om-putObject}
This writes a begin object token to dev.
\begin{chunk}{defun om-putObject}
(defun om-putObject (dev)
 (declare (ignore dev)))

\end{chunk}

\defun{om-putString}{om-putString}
This writes the string s to dev.
\begin{chunk}{defun om-putString}
(defun om-putString (dev s)
 (declare (ignore dev s)))

\end{chunk}

\defun{om-putSymbol}{om-putSymbol}
This writes the symbol nm using semantics from cd to dev.
\begin{chunk}{defun om-putSymbol}
(defun om-putSymbol (dev cd nm)
 (declare (ignore dev cd nm)))

\end{chunk}

\defun{om-putVar}{om-putVar}
This writes the variable v to dev.
\begin{chunk}{defun om-putVar}
(defun om-putVar (dev v)
 (declare (ignore dev v)))

\end{chunk}

\defun{om-stringToStringPtr}{om-stringToStringPtr}
This is used in the SingleInteger domain in Volume 10.3.
This is supposed to return the string from its address?
It would appear to be a nop in lisp.
\begin{chunk}{defun om-stringToStringPtr}
(defun om-stringToStringPtr (str)
 (declare (ignore str)))

\end{chunk}

\defun{om-stringPtrToString}{om-stringPtrToString}
This is used in the SingleInteger domain in Volume 10.3.
This is supposed to return the string address from a string?
It would appear to be a nop in lisp.
\begin{chunk}{defun om-stringPtrToString}
(defun om-stringPtrToString (str)
 (declare (ignore str)))

\end{chunk}

\chapter{NRLIB code.lisp support code}

\defun{makeByteWordVec2}{makeByteWordVec2}
\begin{chunk}{defun makeByteWordVec2 0}
(defun |makeByteWordVec2| (maxelement initialvalue)
  (let ((n (cond ((null initialvalue) 7) ('t maxelement))))
    (make-array (length initialvalue)
      :element-type (list 'mod (1+ n))
      :initial-contents initialvalue)))

\end{chunk}

\defmacro{spadConstant}
\begin{chunk}{defmacro spadConstant 0}
(defmacro |spadConstant| (dollar n)
 `(spadcall (svref ,dollar (the fixnum ,n))))

\end{chunk}

\chapter{Monitoring execution}
\begin{verbatim}
MONITOR                                                                
                                                                       
This file contains a set of function for monitoring the execution      
of the functions in a file. It constructs a hash table that contains   
the function name as the key and monitor-data structures as the value  
                                                                       
The technique is to use a :cond parameter on trace to call the         
monitor-incr function to incr the count every time a function is called
                                                                       
*monitor-table*                                HASH TABLE              
   is the monitor table containing the hash entries                    
*monitor-nrlibs*                               LIST of STRING
   list of nrlib filenames that are monitored
*monitor-domains*                              LIST of STRING
   list of domains to monitor-report (default is all exposed domains)
monitor-data                                   STRUCTURE               
   is the defstruct name of records in the table                       
   name is the first field and is the name of the monitored function   
   count contains a count of times the function was called             
   monitorp is a flag that skips counting if nil, counts otherwise     
   sourcefile is the name of the file that contains the source code    
                                                                       
 ***** SETUP, SHUTDOWN ****                                            
                                                                       
monitor-inittable ()                           FUNCTION                
   creates the hashtable and sets *monitor-table*                      
   note that it is called every time this file is loaded               
monitor-end ()                                 FUNCTION                
   unhooks all of the trace hooks                                      
                                                                       
 ***** TRACE, UNTRACE *****                                            
                                                                       
monitor-add (name &optional sourcefile)        FUNCTION                
   sets up the trace and adds the function to the table                
monitor-delete (fn)                            FUNCTION                
   untraces a function and removes it from the table                   
monitor-enable (&optional fn)                  FUNCTION                
   starts tracing for all (or optionally one) functions that           
   are in the table                                                    
monitor-disable (&optional fn)                 FUNCTION                
   stops tracing for all (or optionally one) functions that            
   are in the table                                                    
                                                                       
***** COUNTING, RECORDING  *****                                       
                                                                       
monitor-reset (&optional fn)                   FUNCTION                
   reset the table count for the table (or optionally, for a function) 
monitor-incr (fn)                              FUNCTION                
   increments the count information for a function                     
   it is called by trace to increment the count                        
monitor-decr (fn)                              FUNCTION                
   decrements the count information for a function                     
monitor-info (fn)                              FUNCTION                
   returns the monitor-data structure for a function                   
                                                                       
***** FILE IO *****                                                    
                                                                       
monitor-write (items file)                     FUNCTION                
   writes a list of symbols or structures to a file                    
monitor-file (file)                            FUNCTION                
   will read a file, scan for defuns, monitor each defun               
   NOTE: monitor-file assumes that the file has been loaded            
                                                                       
***** RESULTS *****                                                    
                                                                       
monitor-results ()                             FUNCTION                
   returns a list of the monitor-data structures                       
monitor-untested ()                            FUNCTION                
   returns a list of files that have zero counts                       
monitor-tested (&optional delete)              FUNCTION                
   returns a list of files that have nonzero counts                    
   optionally calling monitor-delete on those functions

***** CHECKPOINT/RESTORE *****
monitor-checkpoint (file)                     FUNCTION
   save the *monitor-table* in a loadable form
monitor-restore (file)                        FUNCTION
  restore a checkpointed file so that everything is monitored

***** ALGEBRA *****
monitor-autoload ()                           FUNCTION
  traces autoload of algebra to monitor corresponding source files
  NOTE: this requires the /spad/int/algebra directory
monitor-dirname (args)                        FUNCTION
  expects a list of 1 libstream (loadvol's arglist) and monitors the source
  this is a function called by monitor-autoload 
monitor-nrlib (nrlib)                         FUNCTION
  takes an nrlib name as a string (eg POLY) and returns a list of 
  monitor-data structures from that source file
monitor-report ()                             FUNCTION
  generate a report of the monitored activity for domains in 
  *monitor-domains*
monitor-spadfile (name)                       FUNCTION
  given a spad file, report all nrlibs it creates
  this adds each nrlib name to *monitor-domains* but does not
  trace the functions from those domains
monitor-percent ()                            FUNCTION
  ratio of (functions executed)/(functions traced)
monitor-apropos (str)                         FUNCTION
  given a string, find all monitored symbols containing the string
  the search is case-insensitive. returns a list of monitor-data items

for example:
 suppose we have a file "/u/daly/testmon.lisp" that contains:
 (defun foo1 () (print 'foo1))
 (defun foo2 () (print 'foo2))
 (defun foo3 () (foo1) (foo2) (print 'foo3))
 (defun foo4 () (print 'foo4))

 an example session is:

 ; FIRST WE LOAD THE FILE (WHICH INITS *monitor-table*)

 >(load "/u/daly/monitor.lisp")
 Loading /u/daly/monitor.lisp
 Finished loading /u/daly/monitor.lisp
 T

 ; SECOND WE LOAD THE TESTMON FILE
 >(load "/u/daly/testmon.lisp")
 T

 ; THIRD WE MONITOR THE FILE
 >(monitor-file "/u/daly/testmon.lisp")
 monitoring "/u/daly/testmon.lisp"
 NIL
 
 ; FOURTH WE CALL A FUNCTION FROM THE FILE (BUMP ITS COUNT)
 >(foo1)
 
 FOO1 
 FOO1
 
 ; AND ANOTHER FUNCTION (BUMP ITS COUNT)
 >(foo2)
 
 FOO2 
 FOO2
 
 ; AND A THIRD FUNCTION THAT CALLS THE OTHER TWO (BUMP ALL THREE)
 >(foo3)

 FOO1 
 FOO2 
 FOO3 
 FOO3
 
 ; CHECK THAT THE RESULTS ARE CORRECT

 >(monitor-results)
 (#S(MONITOR-DATA NAME FOO1 COUNT 2 MONITORP T SOURCEFILE
        "/u/daly/testmon.lisp")
  #S(MONITOR-DATA NAME FOO2 COUNT 2 MONITORP T SOURCEFILE
        "/u/daly/testmon.lisp")
  #S(MONITOR-DATA NAME FOO3 COUNT 1 MONITORP T SOURCEFILE
        "/u/daly/testmon.lisp"))
  #S(MONITOR-DATA NAME FOO4 COUNT 0 MONITORP T SOURCEFILE
        "/u/daly/testmon.lisp"))

 ; STOP COUNTING CALLS TO FOO2
 
 >(monitor-disable 'foo2)
 NIL

 ; INVOKE FOO2 THRU FOO3

 >(foo3)
 
 FOO1 
 FOO2 
 FOO3 
 FOO3

 ; NOTICE THAT FOO1 AND FOO3 WERE BUMPED BUT NOT FOO2 
 >(monitor-results)
 (#S(MONITOR-DATA NAME FOO1 COUNT 3 MONITORP T SOURCEFILE
        "/u/daly/testmon.lisp")
  #S(MONITOR-DATA NAME FOO2 COUNT 2 MONITORP NIL SOURCEFILE
        "/u/daly/testmon.lisp")
  #S(MONITOR-DATA NAME FOO3 COUNT 2 MONITORP T SOURCEFILE
        "/u/daly/testmon.lisp"))
  #S(MONITOR-DATA NAME FOO4 COUNT 0 MONITORP T SOURCEFILE
        "/u/daly/testmon.lisp"))
 
 ; TEMPORARILY STOP ALL MONITORING

 >(monitor-disable)
 NIL

 ; CHECK THAT NOTHING CHANGES
 
 >(foo3)
 
 FOO1 
 FOO2 
 FOO3 
 FOO3

 ; NO COUNT HAS CHANGED
 
 >(monitor-results)
 (#S(MONITOR-DATA NAME FOO1 COUNT 3 MONITORP NIL SOURCEFILE
        "/u/daly/testmon.lisp")
  #S(MONITOR-DATA NAME FOO2 COUNT 2 MONITORP NIL SOURCEFILE
        "/u/daly/testmon.lisp")
  #S(MONITOR-DATA NAME FOO3 COUNT 2 MONITORP NIL SOURCEFILE
        "/u/daly/testmon.lisp"))
  #S(MONITOR-DATA NAME FOO4 COUNT 0 MONITORP T SOURCEFILE
        "/u/daly/testmon.lisp"))

 ; MONITOR ONLY CALLS TO FOO1
 
 >(monitor-enable 'foo1)
 T

 ; FOO3 CALLS FOO1
 
 >(foo3)
 
 FOO1 
 FOO2 
 FOO3 
 FOO3

 ; FOO1 HAS CHANGED BUT NOT FOO2 OR FOO3
 
 >(monitor-results)
 (#S(MONITOR-DATA NAME FOO1 COUNT 4 MONITORP T SOURCEFILE
        "/u/daly/testmon.lisp")
  #S(MONITOR-DATA NAME FOO2 COUNT 2 MONITORP NIL SOURCEFILE
        "/u/daly/testmon.lisp")
  #S(MONITOR-DATA NAME FOO3 COUNT 2 MONITORP NIL SOURCEFILE
        "/u/daly/testmon.lisp"))
  #S(MONITOR-DATA NAME FOO4 COUNT 0 MONITORP T SOURCEFILE
        "/u/daly/testmon.lisp"))
 
 ; MONITOR EVERYBODY

 >(monitor-enable)
 NIL

 ; CHECK THAT EVERYBODY CHANGES
 
 >(foo3)
 
 FOO1 
 FOO2 
 FOO3 
 FOO3

 ; EVERYBODY WAS BUMPED
 
 >(monitor-results)
 (#S(MONITOR-DATA NAME FOO1 COUNT 5 MONITORP T SOURCEFILE
        "/u/daly/testmon.lisp")
  #S(MONITOR-DATA NAME FOO2 COUNT 3 MONITORP T SOURCEFILE
        "/u/daly/testmon.lisp")
  #S(MONITOR-DATA NAME FOO3 COUNT 3 MONITORP T SOURCEFILE
        "/u/daly/testmon.lisp"))
  #S(MONITOR-DATA NAME FOO4 COUNT 0 MONITORP T SOURCEFILE
        "/u/daly/testmon.lisp"))

 ; WHAT FUNCTIONS WERE TESTED?

 >(monitor-tested)
 (FOO1 FOO2 FOO3)

 ; WHAT FUNCTIONS WERE NOT TESTED?

 >(monitor-untested)
 (FOO4)

 ; UNTRACE THE WHOLE WORLD, MONITORING CANNOT RESTART
 
 >(monitor-end)
 NIL

 ; CHECK THE RESULTS
 
 >(monitor-results)
 (#S(MONITOR-DATA NAME FOO1 COUNT 5 MONITORP T SOURCEFILE
        "/u/daly/testmon.lisp")
  #S(MONITOR-DATA NAME FOO2 COUNT 3 MONITORP T SOURCEFILE
        "/u/daly/testmon.lisp")
  #S(MONITOR-DATA NAME FOO3 COUNT 3 MONITORP T SOURCEFILE
        "/u/daly/testmon.lisp"))
  #S(MONITOR-DATA NAME FOO4 COUNT 0 MONITORP T SOURCEFILE
        "/u/daly/testmon.lisp"))

 ; CHECK THAT THE FUNCTIONS STILL WORK
 
 >(foo3)
 
 FOO1 
 FOO2 
 FOO3 
 FOO3
 
 ; CHECK THAT MONITORING IS NOT OCCURING

 >(monitor-results)
 (#S(MONITOR-DATA NAME FOO1 COUNT 5 MONITORP T SOURCEFILE
        "/u/daly/testmon.lisp")
  #S(MONITOR-DATA NAME FOO2 COUNT 3 MONITORP T SOURCEFILE
        "/u/daly/testmon.lisp")
  #S(MONITOR-DATA NAME FOO3 COUNT 3 MONITORP T SOURCEFILE
        "/u/daly/testmon.lisp"))
  #S(MONITOR-DATA NAME FOO4 COUNT 0 MONITORP T SOURCEFILE
        "/u/daly/testmon.lisp"))

\end{verbatim}

\defvar{*monitor-domains*}
\begin{chunk}{initvars}
(defvar *monitor-domains* nil "a list of domains to report")

\end{chunk}

\defvar{*monitor-nrlibs*}
\begin{chunk}{initvars}
(defvar *monitor-nrlibs* nil "a list of nrlibs that have been traced")

\end{chunk}

\defvar{*monitor-table*}
\begin{chunk}{initvars}
(defvar *monitor-table* nil "a table of all of the monitored data")

\end{chunk}

\begin{chunk}{postvars}
(eval-when (eval load) 
 (unless *monitor-table* (monitor-inittable)))

\end{chunk}

\defstruct{monitor-data}
\begin{chunk}{initvars}
(defstruct monitor-data name count monitorp sourcefile)

\end{chunk}

\defstruct{libstream}
\begin{chunk}{initvars}
(defstruct libstream  mode dirname (indextable nil)  (indexstream nil))

\end{chunk}

\defun{monitor-inittable}{Initialize the monitor statistics hashtable}
\uses{monitor-inittable}{*monitor-table*}
\begin{chunk}{defun monitor-inittable 0}
(defun monitor-inittable ()
 "initialize the monitor statistics hashtable"
 (declare (special *monitor-table*))
 (setq *monitor-table* (make-hash-table)))

\end{chunk}

\defun{monitor-end}{End the monitoring process, we cannot restart}
\uses{monitor-end}{*monitor-table*}
\begin{chunk}{defun monitor-end 0}
(defun monitor-end ()
 "End the monitoring process. we cannot restart"
 (declare (special *monitor-table*))
 (maphash 
  #'(lambda (key value)
     (declare (ignore value))
     (eval `(untrace ,key)))
   *monitor-table*))

\end{chunk}

\defun{monitor-results}{Return a list of the monitor-data structures}
\uses{monitor-results}{*monitor-table*}
\begin{chunk}{defun monitor-results 0}
(defun monitor-results ()
 "return a list of the monitor-data structures"
 (let (result)
 (declare (special *monitor-table*))
  (maphash 
  #'(lambda (key value)
     (declare (ignore key))
     (push value result))
   *monitor-table*)
  (mapcar #'(lambda (x) (pprint x)) 
   (sort result #'string-lessp :key #'monitor-data-name))))

\end{chunk}

\defun{monitor-add}{Add a function to be monitored}
\calls{monitor-add}{monitor-delete}
\calls{monitor-add}{make-monitor-data}
\uses{monitor-add}{*monitor-table*}
\begin{chunk}{defun monitor-add 0}
(defun monitor-add (name &optional sourcefile)
 "add a function to be monitored"
 (declare (special *monitor-table*))
 (unless (fboundp name) (load sourcefile))
 (when (gethash name *monitor-table*) 
  (monitor-delete name))
 (eval `(trace (,name :cond (progn (monitor-incr ',name) nil))))
 (setf (gethash name *monitor-table*)
  (make-monitor-data 
     :name name :count 0 :monitorp t :sourcefile sourcefile)))

\end{chunk}

\defun{monitor-delete}{Remove a function being monitored}
\uses{monitor-delete}{*monitor-table*}
\begin{chunk}{defun monitor-delete 0}
(defun monitor-delete (fn)
 "Remove a function being monitored"
 (declare (special *monitor-table*))
 (eval `(untrace ,fn))
 (remhash fn *monitor-table*))

\end{chunk}

\defun{monitor-enable}{Enable all (or optionally one) function for monitoring}
\uses{monitor-enable}{*monitor-table*}
\begin{chunk}{defun monitor-enable 0}
(defun monitor-enable (&optional fn)
 "enable all (or optionally one) function for monitoring"
 (declare (special *monitor-table*))
 (if fn 
  (progn
   (eval `(trace (,fn :cond (progn (monitor-incr ',fn) nil))))
   (setf (monitor-data-monitorp (gethash fn *monitor-table*)) t))
  (maphash 
   #'(lambda (key value)
      (declare (ignore value))
      (eval `(trace (,key :cond (progn (monitor-incr ',key) nil))))
      (setf (monitor-data-monitorp (gethash key *monitor-table*)) t))
   *monitor-table*)))

\end{chunk}

\defun{monitor-disable}{Disable all (optionally one) function for monitoring}
\uses{monitor-disable}{*monitor-table*}
\begin{chunk}{defun monitor-disable 0}
(defun monitor-disable (&optional fn)
 "disable all (optionally one) function for monitoring"
 (declare (special *monitor-table*))
 (if fn
  (progn
   (eval `(untrace ,fn))   
   (setf (monitor-data-monitorp (gethash fn *monitor-table*)) nil))
  (maphash 
   #'(lambda (key value)
      (declare (ignore value))
      (eval `(untrace ,key))
      (setf (monitor-data-monitorp (gethash key *monitor-table*)) nil))
   *monitor-table*)))

\end{chunk}

\defun{monitor-reset}{Reset the table count for the table (or a function)}
\uses{monitor-reset}{*monitor-table*}
\begin{chunk}{defun monitor-reset 0}
(defun monitor-reset (&optional fn)
 "reset the table count for the table (or a function)"
 (declare (special *monitor-table*))
 (if fn
  (setf (monitor-data-count (gethash fn *monitor-table*)) 0)
  (maphash 
   #'(lambda (key value)
      (declare (ignore value))
      (setf (monitor-data-count (gethash key *monitor-table*)) 0))
   *monitor-table*)))

\end{chunk}

\defun{monitor-incr}{Incr the count of fn by 1}
\uses{monitor-incr}{*monitor-table*}
\begin{chunk}{defun monitor-incr 0}
(defun monitor-incr (fn)
 "incr the count of fn by 1"
 (let (data)
  (declare (special *monitor-table*))
  (setq data (gethash fn *monitor-table*))
  (if data 
   (incf (monitor-data-count data))  ;; change table entry by side-effect
   (warn "~s is monitored but not in table..do (untrace ~s)~%" fn fn))))

\end{chunk}

\defun{monitor-decr}{Decr the count of fn by 1}
\uses{monitor-decr}{*monitor-table*}
\begin{chunk}{defun monitor-decr 0}
(defun monitor-decr (fn)
 "decr the count of fn by 1"
 (let (data)
  (declare (special *monitor-table*))
  (setq data (gethash fn *monitor-table*))
  (if data 
   (decf (monitor-data-count data))  ;; change table entry by side-effect
   (warn "~s is monitored but not in table..do (untrace ~s)~%" fn fn))))

\end{chunk}

\defun{monitor-info}{Return the monitor information for a function}
\uses{monitor-info}{*monitor-table*}
\begin{chunk}{defun monitor-info 0}
(defun monitor-info (fn)
 "return the monitor information for a function"
 (declare (special *monitor-table*))
 (gethash fn *monitor-table*))

\end{chunk}

\defun{monitor-file}{Hang a monitor call on all of the defuns in a file}
\catches{monitor-file}{done}
\throws{monitor-file}{done}
\calls{monitor-file}{monitor-add}
\begin{chunk}{defun monitor-file 0}
(defun monitor-file (file)
 "hang a monitor call on all of the defuns in a file"
 (let (expr (package "BOOT"))
  (format t "monitoring ~s~%" file)
  (with-open-file (in file)
   (catch 'done
    (loop
     (setq expr (read in nil 'done))
     (when (eq expr 'done) (throw 'done nil))
     (if (and (consp expr) (eq (car expr) 'in-package))
      (if (and (consp (second expr)) (eq (first (second expr)) 'quote))
       (setq package (string (second (second expr))))
       (setq package (second expr)))
      (when (and (consp expr) (eq (car expr) 'defun))
       (monitor-add (intern (string (second expr)) package) file))))))))

\end{chunk}

\defun{monitor-untested}{Return a list of the functions with zero count fields}
\uses{monitor-untested}{*monitor-table*}
\begin{chunk}{defun monitor-untested 0}
(defun monitor-untested ()
 "return a list of the functions with zero count fields"
 (let (result)
  (declare (special *monitor-table*))
  (maphash 
   #'(lambda (key value)
      (if (and (monitor-data-monitorp value) (= (monitor-data-count value) 0))
       (push key result)))
    *monitor-table*)
 (sort result #'string-lessp )))

\end{chunk}

\defun{monitor-tested}{Return a list of functions with non-zero counts}
\calls{monitor-tested}{monitor-delete}
\uses{monitor-tested}{*monitor-table*}
\begin{chunk}{defun monitor-tested 0}
(defun monitor-tested (&optional delete)
 "return a list of functions with non-zero counts, optionally deleting them"
 (let (result)
 (declare (special *monitor-table*))
  (maphash 
   #'(lambda (key value)
      (when (and (monitor-data-monitorp value) 
                 (> (monitor-data-count value) 0))
       (when delete (monitor-delete key))
       (push key result)))
    *monitor-table*)
 (sort result #'string-lessp)))

\end{chunk}

\defun{monitor-write}{Write out a list of symbols or structures to a file}
\begin{chunk}{defun monitor-write 0}
(defun monitor-write (items file)
 "write out a list of symbols or structures to a file"
 (with-open-file (out file :direction :output)
  (dolist (item items)
    (if (symbolp item)
     (format out "~s~%" item)
     (format out "~s~50t~s~100t~s~%"
       (monitor-data-sourcefile item)
       (monitor-data-name item)
       (monitor-data-count item))))))

\end{chunk}

\defun{monitor-checkpoint}{Save the *monitor-table* in loadable form}
\uses{monitor-checkpoint}{*monitor-table*}
\uses{monitor-checkpoint}{*print-package*}
\begin{chunk}{defun monitor-checkpoint 0}
(defun monitor-checkpoint (file)
 "save the *monitor-table* in loadable form"
 (let ((*print-package* t))
  (declare (special *print-package* *monitor-table*))
  (with-open-file (out file :direction :output)
   (format out "~&~%(IN-PACKAGE \"BOOT\")~%~%")
   (format out "(monitor-inittable)~%")
   (dolist (data (monitor-results))
    (format out "(monitor-add '~s ~s)~%"
     (monitor-data-name data)
     (monitor-data-sourcefile data))
    (format out "(setf (gethash '~s *monitor-table*) 
                  (make-monitor-data :name '~s :count ~s :monitorp ~s
                                     :sourcefile ~s))~%"
     (monitor-data-name data)
     (monitor-data-name data)
     (monitor-data-count data)
     (monitor-data-monitorp data)
     (monitor-data-sourcefile data))))))

\end{chunk}

\defun{monitor-restore}{restore a checkpointed file}
\begin{chunk}{defun monitor-restore 0}
(defun monitor-restore (file)
 "restore a checkpointed file"
 (load file))

\end{chunk}

\defun{monitor-help}{Printing help documentation}
\begin{chunk}{defun monitor-help 0}
(defun monitor-help ()
 (format t "~%
;;; MONITOR                                                                
;;;                                                                        
;;; This file contains a set of function for monitoring the execution      
;;; of the functions in a file. It constructs a hash table that contains   
;;; the function name as the key and monitor-data structures as the value  
;;;                                                                        
;;; The technique is to use a :cond parameter on trace to call the         
;;; monitor-incr function to incr the count every time a function is called
;;;                                                                        
;;; *monitor-table*                                HASH TABLE              
;;;    is the monitor table containing the hash entries                    
;;; *monitor-nrlibs*                               LIST of STRING
;;;    list of nrlib filenames that are monitored
;;; *monitor-domains*                              LIST of STRING
;;;    list of domains to monitor-report (default is all exposed domains)
;;; monitor-data                                   STRUCTURE               
;;;    is the defstruct name of records in the table                       
;;;    name is the first field and is the name of the monitored function   
;;;    count contains a count of times the function was called             
;;;    monitorp is a flag that skips counting if nil, counts otherwise     
;;;    sourcefile is the name of the file that contains the source code    
;;;                                                                        
;;;  ***** SETUP, SHUTDOWN ****                                            
;;;                                                                        
;;; monitor-inittable ()                           FUNCTION                
;;;    creates the hashtable and sets *monitor-table*                      
;;;    note that it is called every time this file is loaded               
;;; monitor-end ()                                 FUNCTION                
;;;    unhooks all of the trace hooks                                      
;;;                                                                        
;;;  ***** TRACE, UNTRACE *****                                            
;;;                                                                        
;;; monitor-add (name &optional sourcefile)        FUNCTION                
;;;    sets up the trace and adds the function to the table                
;;; monitor-delete (fn)                            FUNCTION                
;;;    untraces a function and removes it from the table                   
;;; monitor-enable (&optional fn)                  FUNCTION                
;;;    starts tracing for all (or optionally one) functions that           
;;;    are in the table                                                    
;;; monitor-disable (&optional fn)                 FUNCTION                
;;;    stops tracing for all (or optionally one) functions that            
;;;    are in the table                                                    
;;;                                                                        
;;; ***** COUNTING, RECORDING  *****                                       
;;;                                                                        
;;; monitor-reset (&optional fn)                   FUNCTION                
;;;    reset the table count for the table (or optionally, for a function) 
;;; monitor-incr (fn)                              FUNCTION                
;;;    increments the count information for a function                     
;;;    it is called by trace to increment the count                        
;;; monitor-decr (fn)                              FUNCTION                
;;;    decrements the count information for a function                     
;;; monitor-info (fn)                              FUNCTION                
;;;    returns the monitor-data structure for a function                   
;;;                                                                        
;;; ***** FILE IO *****                                                    
;;;                                                                        
;;; monitor-write (items file)                     FUNCTION                
;;;    writes a list of symbols or structures to a file                    
;;; monitor-file (file)                            FUNCTION                
;;;    will read a file, scan for defuns, monitor each defun               
;;;    NOTE: monitor-file assumes that the file has been loaded            
;;;                                                                        
;;; ***** RESULTS *****                                                    
;;;                                                                        
;;; monitor-results ()                             FUNCTION                
;;;    returns a list of the monitor-data structures                       
;;; monitor-untested ()                            FUNCTION                
;;;    returns a list of files that have zero counts                       
;;; monitor-tested (&optional delete)              FUNCTION                
;;;    returns a list of files that have nonzero counts                    
;;;    optionally calling monitor-delete on those functions
;;;
;;; ***** CHECKPOINT/RESTORE *****
;;;
;;; monitor-checkpoint (file)                     FUNCTION
;;;    save the *monitor-table* in a loadable form
;;; monitor-restore (file)                        FUNCTION
;;;   restore a checkpointed file so that everything is monitored
;;;
;;; ***** ALGEBRA *****
;;;
;;; monitor-autoload ()                           FUNCTION
;;;   traces autoload of algebra to monitor corresponding source files
;;;   NOTE: this requires the /spad/int/algebra directory
;;; monitor-dirname (args)                        FUNCTION
;;;   expects a list of 1 libstream (loadvol's arglist) and monitors the source
;;;   this is a function called by monitor-autoload 
;;; monitor-nrlib (nrlib)                         FUNCTION
;;;   takes an nrlib name as a string (eg POLY) and returns a list of 
;;;   monitor-data structures from that source file
;;; monitor-report ()                             FUNCTION
;;;   generate a report of the monitored activity for domains in 
;;;   *monitor-domains*
;;; monitor-spadfile (name)                       FUNCTION
;;;   given a spad file, report all nrlibs it creates
;;;   this adds each nrlib name to *monitor-domains* but does not
;;;   trace the functions from those domains
;;; monitor-percent ()                            FUNCTION
;;;   ratio of (functions executed)/(functions traced)
;;; monitor-apropos (str)                         FUNCTION
;;;   given a string, find all monitored symbols containing the string
;;;   the search is case-insensitive. returns a list of monitor-data items
") nil)


\end{chunk}

\subsection{Monitoring algebra files}
\defun{monitor-dirname}{Monitoring algebra code.lsp files}
\uses{monitor-dirname}{*monitor-nrlibs*}
\begin{chunk}{defun monitor-dirname 0}
(defun monitor-dirname (args)
  "expects a list of 1 libstream (loadvol's arglist) and monitors the source"
 (let (name)
 (declare (special *monitor-nrlibs*))
  (setq name (libstream-dirname (car args)))
  (setq name (file-namestring name))
  (setq name (concatenate 'string "/spad/int/algebra/" name "/code.lsp"))
  (when (probe-file name)
   (push name *monitor-nrlibs*)
   (monitor-file name))))

\end{chunk}

\defun{monitor-autoload}{Monitor autoloaded files}
\begin{chunk}{defun monitor-autoload 0}
(defun monitor-autoload ()
 "traces autoload of algebra to monitor corresponding source files"
 (trace (vmlisp::loadvol 
          :entrycond nil
          :exitcond (progn (monitor-dirname system::arglist) nil))))

\end{chunk}

\defun{monitor-nrlib}{Monitor an nrlib}
\uses{monitor-nrlib}{*monitor-table*}
\begin{chunk}{defun monitor-nrlib 0}
(defun monitor-nrlib (nrlib)
 "takes an nrlib name as a string (eg POLY) and returns a list of 
  monitor-data structures from that source file"
 (let (result)
 (declare (special *monitor-table*))
  (maphash 
   #'(lambda (k v)
      (declare (ignore k))
      (when (string= nrlib 
             (pathname-name (car (last
                (pathname-directory (monitor-data-sourcefile v))))))
       (push v result)))
   *monitor-table*)
 result))

\end{chunk}

\defun{monitor-libname}{Given a monitor-data item, extract the nrlib name}
\begin{chunk}{defun monitor-libname 0}
(defun monitor-libname (item)
  "given a monitor-data item, extract the nrlib name"
  (pathname-name (car (last
   (pathname-directory (monitor-data-sourcefile item))))))

\end{chunk}

\defun{monitor-exposedp}{Is this an exposed algebra function?}
\begin{chunk}{defun monitor-exposedp 0}
(defun monitor-exposedp (fn)
 "exposed functions have more than 1 semicolon. given a symbol, count them"
   (> (count #\; (symbol-name fn)) 1))

\end{chunk}

\defun{monitor-readinterp}{Monitor exposed domains}
\tpdhere{note that the file interp.exposed no longer exists.}
The exposure information is now in this book.
This needs to work off the internal exposure list, not the file.

\catches{monitor-readinterp}{done}
\throws{monitor-readinterp}{done}
\uses{monitor-readinterp}{*monitor-domains*}
\begin{chunk}{defun monitor-readinterp 0}
(defun monitor-readinterp ()
  "read interp.exposed to initialize *monitor-domains* to exposed domains.
   this is the default action. adding or deleting domains from the list
   will change the report results"
  (let (skip expr name)
   (declare (special *monitor-domains*))
   (setq *monitor-domains* nil)
   (with-open-file (in "/spad/src/algebra/interp.exposed")
    (read-line in)
    (read-line in)
    (read-line in)
    (read-line in)
    (catch 'done
     (loop
      (setq expr (read-line in nil "done"))
      (when (string= expr "done") (throw 'done nil))
      (cond
       ((string= expr "basic") (setq skip nil))
       ((string= expr "categories") (setq skip t))
       ((string= expr "hidden") (setq skip t))
       ((string= expr "defaults") (setq skip nil)))
      (when (and (not skip) (> (length expr) 58))
       (setq name (subseq expr 58 (length expr)))
       (setq name (string-right-trim '(#\space) name))
       (when (> (length name) 0)
        (push name *monitor-domains*))))))))

\end{chunk}

\defun{monitor-report}{Generate a report of the monitored domains}
\calls{monitor-report}{monitor-readinterp}
\uses{monitor-report}{*monitor-domains*}
\begin{chunk}{defun monitor-report 0}
(defun monitor-report ()
 "generate a report of the monitored activity for domains in *monitor-domains*"
 (let (nrlibs nonzero total)
 (declare (special *monitor-domains*))
  (unless *monitor-domains* (monitor-readinterp))
  (setq nonzero 0)
  (setq total 0)
  (maphash 
   #'(lambda (k v)
      (declare (ignore k))
      (let (nextlib point)
       (when (> (monitor-data-count v) 0) (incf nonzero))
       (incf total)
       (setq nextlib (monitor-libname v))
       (setq point (member nextlib nrlibs :test #'string= :key #'car))
       (if point
         (setf (cdr (first point)) (cons v (cdr (first point))))
         (push (cons nextlib (list v)) nrlibs))))
   *monitor-table*)
  (format t "~d of ~d (~d percent) tested~%" nonzero total 
    (round (/ (* 100.0 nonzero) total)))
  (setq nrlibs (sort nrlibs #'string< :key #'car))
  (dolist (pair nrlibs)
   (let ((exposedcount 0) (testcount 0))
    (when (member (car pair) *monitor-domains* :test #'string=)
     (format t "for library ~s~%" (car pair))
     (dolist (item (sort (cdr pair)  #'> :key #'monitor-data-count))
      (when (monitor-exposedp (monitor-data-name item))
       (incf exposedcount)
       (when (> (monitor-data-count item) 0) (incf testcount))
       (format t "~5d ~s~%" 
         (monitor-data-count item) 
         (monitor-data-name item))))
      (if (= exposedcount testcount)
       (format t "~a has all exposed functions tested~%" (car pair))
       (format t "Daly bug:~a has untested exposed functions~%" (car pair))))))
 nil))

\end{chunk}

\defun{monitor-parse}{Parse an )abbrev expression for the domain name}
\begin{chunk}{defun monitor-parse 0}
(defun monitor-parse (expr)
  (let (point1 point2)
   (setq point1 (position #\space expr :test #'char=))
   (setq point1 (position #\space expr :start point1 :test-not #'char=))
   (setq point1 (position #\space expr :start point1 :test #'char=))
   (setq point1 (position #\space expr :start point1 :test-not #'char=))
   (setq point2 (position #\space expr :start point1 :test #'char=))
   (subseq expr point1 point2)))

\end{chunk}

\defun{monitor-spadfile}{Given a spad file, report all nrlibs it creates}
\catches{monitor-spadfile}{done}
\throws{monitor-spadfile}{done}
\calls{monitor-spadfile}{monitor-parse}
\uses{monitor-spadfile}{*monitor-domains*}
\begin{chunk}{defun monitor-spadfile 0}
(defun monitor-spadfile (name)
 "given a spad file, report all nrlibs it creates"
 (let (expr)
 (declare (special *monitor-domains*))
  (with-open-file (in name)
   (catch 'done
    (loop
     (setq expr (read-line in nil 'done))
     (when (eq expr 'done) (throw 'done nil))
     (when (and (> (length expr) 4) (string= (subseq expr 0 4) ")abb"))
      (setq *monitor-domains* 
       (adjoin (monitor-parse expr) *monitor-domains* :test #'string=))))))))

\end{chunk}

\defun{monitor-percent}{Print percent of functions tested}
\uses{monitor-percent}{*monitor-table*}
\begin{chunk}{defun monitor-percent 0}
(defun monitor-percent ()
 "Print percent of functions tested"
 (let (nonzero total)
 (declare (special *monitor-table*))
  (setq nonzero 0)
  (setq total 0)
  (maphash 
   #'(lambda (k v)
      (declare (ignore k))
      (when (> (monitor-data-count v) 0) (incf nonzero))
      (incf total))
   *monitor-table*)
   (format t "~d of ~d (~d percent) tested~%" nonzero total 
     (round (/ (* 100.0 nonzero) total)))))

\end{chunk}

\defun{monitor-apropos}{Find all monitored symbols containing the string}
\uses{monitor-apropos}{*monitor-table*}
\begin{chunk}{defun monitor-apropos 0}
(defun monitor-apropos (str)
  "given a string, find all monitored symbols containing the string
   the search is case-insensitive. returns a list of monitor-data items"
 (let (result)
  (maphash 
   #'(lambda (k v)
      (when
       (search (string-upcase str) 
               (string-upcase (symbol-name k)) 
               :test #'string=)
        (push v result)))
   *monitor-table*)
 result))

\end{chunk}

\chapter{HyperDoc}
Hyperdoc works by building up a page ``description'' which consists
of a list of items. Each item is itself a list whose first element is
a tag. The htMakePage1 routine walks the list of items,
dispatching on the tag (called itemType), to create the final page.

Pages are constructed with a latex-like syntax. The valid syntax
values are in the primitiveHtCommands list.

Each page is an 8 part list, of which the description is the last
item. See HTPage Layout for more details.

Pages can also be constructed by code. For example, the page found by
\begin{verbatim}
   Basic Commands -> Matrix
\end{verbatim}
is constructed by a call to bcReadMatrix.
This routine sets the page title htInitPage, 
sets up the EXIT button handler htpSetProperty, 
constructs a page descriptions which is passes to htMakePage, 
and then calls htShowPage 
to display the result.

\section{Hyperdoc macro handling and util.ht}

All of the macros used in hyperdoc are in this hash table.
User-defined macros are read from the file {\bf doc/util.ht}

\defdollar{htMacroTable}
\begin{chunk}{initvars}
(defvar |$htMacroTable| (make-hash-table :test #'equal))

\end{chunk}

These are the primitive hyperdoc commands. They are directly
implemented. The {\bf buildHtMacroTable} function adds these
to the \verb|$htMacroTable| at startup.

\defdollar{primitiveHtCommands}
\begin{chunk}{initvars}
(defvar |$primitiveHtCommands|
  '(("\\ContinueButton" . 1)
    ("\\andexample" . 1)
    ("\\autobutt" . 0)
    ("\\autobuttons" . 0)
    ("\\begin" . 1)
    ("\\beginscroll" . 0)
    ("\\bound" . 1)
    ("\\fbox" . 1)
    ("\\centerline" . 1)
    ("\\downlink" . 2)
    ("\\em" . 0)
    ("\\end" . 1)
    ("\\endscroll" . 0)
    ("\\example" . 1)
    ("\\free" . 1)
    ("\\graphpaste" . 1)
    ("\\helppage" . 1)
    ("\\htbmdir" . 0)
    ("\\htbmfile" . 1)
    ("\\indent" . 1)
    ("\\inputbitmap" . 1)
    ("\\inputstring" . 3)
    ("\\item" . 0)
    ("\\keyword" . 1)
    ("\\link" . 2)
    ("\\lispdownlink" . 2)
    ("\\lispmemolink" . 2)
    ("\\lispwindowlink" . 2)
    ("\\menudownlink" . 2)
    ("\\menuitemstyle" . 1)
    ("\\menulink" . 2)
    ("\\menulispdownlink" . 2)
    ("\\menulispmemolink" . 2)
    ("\\menulispwindowlink" . 2)
    ("\\menumemolink" . 2)
    ("\\menuwindowlink" . 2)
    ("\\newline" . 0)
    ("\\radioboxes" . 3)
    ("\\space" . 1)
    ("\\spadcommand" . 1)
    ("\\stringvalue" . 1)
    ("\\tab" . 1)
    ("\\table" . 1)
    ("\\vspace" . 1)
    ("\\windowlink" . 2)))

\end{chunk}

\defdollar{newPage}
\begin{chunk}{initvars}
(defvar |$newPage| nil "The new page being built")

\end{chunk}

\defun{buildHtMacroTable}{Build the table of hyperdoc macros}
Hash user-defined macros from {\bf doc/util.ht} into {\bf htMacroTable}.
Hash primitive hyperdoc macros into {\bf htMacroTable}.
\seebook{buildHtMacroTable}{util.ht}{7.1}
\calls{buildHtMacroTable}{getHtMacroItem}
\calls{buildHtMacroTable}{sayBrightly}
\calls{buildHtMacroTable}{concat}
\calls{buildHtMacroTable}{getenviron}
\calls{buildHtMacroTable}{hput}
\usesdollar{buildHtMacroTable}{htMacroTable}
\usesdollar{buildHtMacroTable}{primitiveHtCommands}
\begin{chunk}{defun buildHtMacroTable}
(defun |buildHtMacroTable| ()
 (let (fn)
  (declare (special |$htMacroTable| |$primitiveHtCommands|))
  (setq fn (concat (getenviron "AXIOM") "/doc/util.ht"))
  (cond 
   ((probe-file fn)
    (with-open-file (instream fn)
     (loop
       for line = (read-line instream nil :eof)
       until (eq line :eof)
       do
        (when 
         (multiple-value-bind (command numOfArgs) (|getHtMacroItem| line)
          (hput |$htMacroTable| command numOfArgs))))
     (dolist (pair |$primitiveHtCommands|)
      (hput |$htMacroTable| (car pair) (cdr pair)))))
   (t (|sayBrightly| "Warning: macro table not found")))
  |$htMacroTable|))

\end{chunk}

\defun{getHtMacroItem}{Get new command name and number of args}
This processes {\bf newcommand} lines read from {\bf doc/util.ht}
An example newcommand looks like
\begin{verbatim}
   \newcommand{\menulink}[2]        {\menudownlink{#1}{#2}}
\end{verbatim}
This function returns a pair whose CAR is the new command name
and whose CDR is the number of arguments. If there are zero arguments
the brackets and number will not appear.

However brackets can appear in the new command so we need to fix
the original code to handle this new case. We set up a wall
starting after the first closing brace.
\begin{verbatim}
   \newcommand{\beginmenu}          {\beginitems[\MenuDotBitmap]}
\end{verbatim}

\seebook{getHtMacroItem}{util.ht}{7.1}

\sig{getHtMacroItem}{String}{Values (String NonNegativeInteger)}
\begin{chunk}{defun getHtMacroItem}
(defun |getHtMacroItem| (line)
 (let (k command m i j wall digitString)
  (when (|stringPrefix?| "\\newcommand{" line)
    (setq k (position #\} line :start 11))
    (setq wall (position #\{ line :start k)) ; wall off the body of command
    (setq command (substring line 12 (- k 12)))
    (setq m (length line))
    (setq i (position #\[ line :start k))
    (if (and i (< i m) wall (< i wall))
     (progn                 ; brackets. parse number of args
      (setq j (position #\] line :start (+ i 1)))
      (setq digitString (substring line (+ i 1) (- (- j i) 1)))
      (when (every #'digitp digitString)
       (values command (parse-integer digitString))))
     (values command 0)))))  ; no brackets

\end{chunk}

We populate the htMacroTable at load time.
\begin{chunk}{postvars}
(eval-when (eval load)
 (|buildHtMacroTable|))

\end{chunk}

\defun{stringPrefix?}{Is the first string a prefix of the second?}
\begin{chunk}{defun stringPrefix? 0}
(defun |stringPrefix?| (pref str)
 (let (lp)
  (cond
   ((null (and (stringp pref) (stringp str))) nil)
   ((eql (setq lp (length pref)) 0) t)
   ((> lp (length str)) nil)
   (t (every #'char= pref str)))))

\end{chunk}

\chapter{HyperDoc Basic Command support}

\begin{center}
{\bf {\large{Basic Command}}}
\vskip 0.25cm
\includegraphics[scale=1.0]{ps/v5bcbasiccommands.eps}
\end{center}

This is the root page of the basic commands dialog.
The goal is to present examples of how to construct command lines
which demonstrate using Axiom to solve problems.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% HyperDoc -> Basic Commands -> Calculus
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Calculus}

\begin{center}
{\bf {\large{Calculus}}}
\vskip 0.25cm
\includegraphics[scale=1.0]{ps/v5bccalculus.eps}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% HyperDoc -> Basic Commands -> Calculus -> Differentiate
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defun{bcDifferentiate}{Calculus - Differentiate}
\calls{bcDifferentiate}{htInitPage}
\calls{bcDifferentiate}{htMakePage}
\calls{bcDifferentiate}{htMakeDoneButton}
\calls{bcDifferentiate}{htShowPage}
\usesdollar{bcDifferentiate}{EmptyMode}

\begin{center}
{\bf {\large{Calculus $\rightarrow$ Differentiate}}}
\vskip 0.25cm
\includegraphics[scale=1.0]{ps/v5bcdifferentiate.eps}
\end{center}

Pressing the {\bf Continue} button will call the function
{\bf bcDifferentiateGen} due to this line:
\begin{verbatim}
   (|htMakeDoneButton| "Continue" '|bcDifferentiateGen|)
\end{verbatim}

\begin{chunk}{defun bcDifferentiate}
(defun |bcDifferentiate| ()
 (declare (special |$EmptyMode|))
 (|htInitPage| '|Differentiate Basic Command| nil)
 (|htMakePage|
  '((|domainConditions| (|isDomain| EM |$EmptyMode|)
        (|isDomain| S (|String|)) (|isDomain| SY (|Symbol|)))
    (|text| . "\\newline ")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| . "Enter the {\\em function} you want to differentiate:")
    (|text| . "\\newline\\tab{2} ")
    (|bcStrings| (55 "sin(x*y)" |diffand| EM))
    (|text| . "\\blankline") (|text| . "\\newline ")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| .
"\\newline List the {\\em variables} you want to differentiate with respect to?")
    (|text| . "\\newline\\tab{2} ")
    (|bcStrings| (55 "x y" |variables| S . |quoteString|))
    (|text| . "\\blankline") (|text| . "\\newline ")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| .
"\\newline List the number of {\\em times} you want to differentiate with respect to each variable (leave blank if once for each)")
    (|text| . "\\newline\\tab{2} ")
    (|bcStrings| (55 "1 2" |times| S . |quoteString|))))
 (|htMakeDoneButton| "Continue" '|bcDifferentiateGen|)
 (|htShowPage|))

\end{chunk}

Pressing the {\bf Continue} calls {\tt bcDifferentiateGen}

\defun{bcDifferentiateGen}{bcDifferentiateGen}
\calls{bcDifferentiateGen}{htpLabelInputString}
\calls{bcDifferentiateGen}{bcString2WordList}
\calls{bcDifferentiateGen}{bcwords2liststring}
\calls{bcDifferentiateGen}{length}
\calls{bcDifferentiateGen}{bcError}
\calls{bcDifferentiateGen}{concat}
\calls{bcDifferentiateGen}{bcGen}
\begin{chunk}{defun bcDifferentiateGen}
(defun |bcDifferentiateGen| (htPage)
 (let (mand varlist indexList varpart indexpart lastPart)
  (setq mand (|htpLabelInputString| htPage '|diffand|))
  (setq varlist
    (|bcString2WordList| (|htpLabelInputString| htPage '|variables|)))
  (setq indexList
    (|bcString2WordList| (|htpLabelInputString| htPage '|times|)))
  (setq varpart
    (if (> (|#| varlist) 1)
      (|bcwords2liststring| varlist)
      (car varlist)))
  (setq indexpart
   (cond
     ((null indexList) nil)
     ((null (cdr indexList)) (car indexList))
     ((= (|#| indexList) (|#| varlist)) (|bcwords2liststring| indexList))
     (t (|bcError|
"You must say how many times you want to differentiate with respect to each variable---or leave that entry blank"))))
  (setq lastPart (if indexpart (concat "," indexpart ")") ")"))
  (|bcGen| (concat "differentiate(" mand "," varpart lastPart))))

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% HyperDoc -> Basic Commands -> Calculus -> Indefinite Integral
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defun{bcIndefiniteIntegrate}{Calculus - Do an Indefinite Integral}
\calls{bcIndefiniteIntegrate}{htInitPage}
\calls{bcIndefiniteIntegrate}{htMakePage}
\calls{bcIndefiniteIntegrate}{htShowPage}
\usesdollar{bcIndefiniteIntegrate}{EmptyMode}

\begin{center}
{\bf {\large{Calculus $\rightarrow$ Indefinite Integral}}}
\vskip 0.25cm
\includegraphics[scale=1.0]{ps/v5bcindefiniteintegrate.eps}
\end{center}

Pressing the {\bf Continue} button will call the function
{\bf bcIndefiniteIntegrateGen} due to this line:
\begin{verbatim}
  (|doneButton| "Continue" |bcIndefiniteIntegrateGen|)))
\end{verbatim}
\begin{chunk}{defun bcIndefiniteIntegrate}
(defun |bcIndefiniteIntegrate| ()
 (declare (special |$EmptyMode|))
  (|htInitPage| '|Indefinite Integration Basic Command| nil)
  (|htMakePage|
    '((|domainConditions| (|isDomain| EM |$EmptyMode|)
          (|isDomain| S (|String|)) (|isDomain| SY (|Symbol|)))
      (|text| . "\\newline ")
      (|text| . "\\menuitemstyle{}\\tab{2}")
      (|text| . "Enter the {\\em function} you would like to integrate:")
      (|text| . "\\newline\\tab{2} ")
      (|bcStrings| (45 "1/(x**2 + 6)" |integrand| EM))
      (|text| . "\\blankline") (|text| . "\\newline ")
      (|text| . "\\menuitemstyle{}\\tab{2}")
      (|text| . "Enter the {\\em variable of integration}:")
      (|text| . "\\tab{37}") (|bcStrings| (10 |x| |symbol| SY))
      (|doneButton| "Continue" |bcIndefiniteIntegrateGen|)))
  (|htShowPage|))

\end{chunk}

\defun{bcIndefiniteIntegrateGen}{bcIndefiniteIntegrateGen}
\calls{bcIndefiniteIntegrateGen}{htpLabelInputString}
\calls{bcIndefiniteIntegrateGen}{concat}
\calls{bcIndefiniteIntegrateGen}{bcGen}
\begin{chunk}{defun bcIndefiniteIntegrateGen}
(defun |bcIndefiniteIntegrateGen| (htPage)
 (let (integrand var)
  (setq integrand (|htpLabelInputString| htPage '|integrand|))
  (setq var (|htpLabelInputString| htPage '|symbol|))
  (|bcGen| (concat "integrate(" integrand "," var ")"))))

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% HyperDoc -> Basic Commands -> Calculus -> Definite Integral
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defun{bcDefiniteIntegrate}{Calculus - Do a Definite Integral}
\calls{bcDefiniteIntegrate}{htInitPage}
\calls{bcDefiniteIntegrate}{htMakePage}
\calls{bcDefiniteIntegrate}{htShowPage}
\usesdollar{bcDefiniteIntegrate}{EmptyMode}

\begin{center}
{\bf {\large{Calculus $\rightarrow$ Definite Integral}}}
\vskip 0.25cm
\includegraphics[scale=1.0]{ps/v5bcdefiniteintegrate.eps}
\end{center}

Pressing the {\bf Continue} button will call the function
{\bf bcDefiniteIntegrateGen} due to this line:
\begin{verbatim}
  (|doneButton| "Continue" |bcDefiniteIntegrateGen|)
\end{verbatim}
\begin{chunk}{defun bcDefiniteIntegrate}
(defun |bcDefiniteIntegrate| ()
 (declare (special |$EmptyMode|))
 (|htInitPage| '|Definite Integration Basic Command| NIL)
 (|htMakePage|
  '((|domainConditions| (|isDomain| EM |$EmptyMode|)
        (|isDomain| S (|String|)) (|isDomain| SY (|Symbol|)))
    (|text| . "\\newline ")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| . "Enter the {\\em function} you would like to integrate:")
    (|text| . "\\newline\\tab{2} ")
    (|bcStrings| (45 "1/(x**2 + 6)" |integrand| EM))
    (|text| . "\\blankline") (|text| . "\\newline ")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| . "Enter the {\\em variable of integration}:")
    (|text| . "\\tab{37}") (|bcStrings| (10 |x| |symbol| SY))
    (|text| . "\\blankline") (|text| . "\\newline ")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| . "\\newline Enter {\\em lower limit}:")
    (|radioButtons| |fromButton|
      ("" "Minus infinity" |minusInfinity|)
      (""
         ((|text| . "A finite point:\\tab{15}")
          (|bcStrings| (10 0 |from| EM . |bcOptional|)))
         |fromPoint|))
    (|text| . "\\blankline") (|text| . "\\newline ")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| . "\\indent{2}\\newline Enter {\\em upper limit}:")
    (|radioButtons| |toButton|
        ("" "Plus infinity" |plusInfinity|)
        (""
         ((|text| "A finite point:\\tab{15}")
          (|bcStrings| (10 |y| |to| EM . |bcOptional|)))
         |toPoint|))
     (|doneButton| "Continue" |bcDefiniteIntegrateGen|)))
 (|htShowPage|))

\end{chunk}

\defun{bcDefiniteIntegrateGen}{bcDefiniteIntegrateGen}
\calls{bcDefiniteIntegrateGen}{htpLabelInputString}
\calls{bcDefiniteIntegrateGen}{htpButtonValue}
\calls{bcDefiniteIntegrateGen}{concat}
\calls{bcDefiniteIntegrateGen}{bcGen}
\begin{chunk}{defun bcDefiniteIntegrateGen}
(defun |bcDefiniteIntegrateGen| (htPage)
 (let (integrand var lowerLimit upperLimit varpart)
  (setq integrand (|htpLabelInputString| htPage '|integrand|))
  (setq var (|htpLabelInputString| htPage '|symbol|))
  (setq lowerLimit
   (if (eq (|htpButtonValue| htPage '|fromButton|) '|fromPoint|)
    (|htpLabelInputString| htPage '|from|)
    "%minusInfinity"))
  (setq upperLimit
   (if (eq (|htpButtonValue| htPage '|toButton|) '|toPoint|)
    (|htpLabelInputString| htPage '|to|)
    "%plusInfinity"))
  (setq varpart (concat var " = " lowerLimit ".." upperLimit))
  (|bcGen| (concat "integrate(" integrand "," varpart ")"))))

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% HyperDoc -> Basic Commands -> Calculus -> Limit
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defun{bcLimit}{Calculus - Find a limit}
\calls{bcLimit}{htInitPage}
\calls{bcLimit}{htMakePage}
\calls{bcLimit}{htShowPage}
\usesdollar{bcLimit}{EmptyMode}

\begin{center}
{\bf {\large{Calculus $\rightarrow$ Limit}}}
\vskip 0.25cm
\includegraphics[scale=0.75]{ps/v5bclimit.eps}
\end{center}

\begin{chunk}{defun bcLimit}
(defun |bcLimit| ()
 (declare (special |$EmptyMode|))
 (|htInitPage| "Limit Basic Command" NIL)
 (|htMakePage|
  '((|domainConditions| (|isDomain| EM |$EmptyMode|)
        (|isDomain| S (|String|)) (|isDomain| SY (|Symbol|)))
    (|text| . "What kind of limit do you want to compute? ")
    (|text| . "\\blankline ") 
    (|text| . "\\beginmenu")
    (|text| . "\\item ")
    (|bcLinks| ("\\menuitemstyle{A real limit?}" "" |bcRealLimit| |real|))
    (|text| . "\\indentrel{17}\\tab{0}")
    (|text| .
"The limit as the variable approaches a {\\em real} value along the real axis")
    (|text| . "\\indentrel{-17}") (|text| . "\\item ")
    (|text| . "\\blankline ")
    (|bcLinks|
      ("\\menuitemstyle{A complex limit?}" "" |bcComplexLimit| |complex|))
    (|text| . "\\indentrel{17}\\tab{0}")
    (|text| .
"The limit as the variable approaches a {\\em complex} value along any path in the complex plane")
    (|text| . "\\indentrel{-17}") 
    (|text| . "\\endmenu")))
 (|htShowPage|))

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% HyperDoc -> Basic Commands -> Calculus -> Summation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defun{bcSum}{Calculus - Do a summation}
\calls{bcSum}{htInitPage}
\calls{bcSum}{htMakePage}
\calls{bcSum}{htShowPage}
\usesdollar{bcSum}{EmptyMode}

\begin{center}
{\bf {\large{Calculus $\rightarrow$ Summation}}}
\vskip 0.25cm
\includegraphics[scale=1.0]{ps/v5bcsum.eps}
\end{center}

Pressing the {\bf Continue} button will call the function
{\bf bcSumGen} due to this line:
\begin{verbatim}
   (|doneButton| "Continue" |bcSumGen|)
\end{verbatim}
\begin{chunk}{defun bcSum}
(defun |bcSum| ()
 (declare (special |$EmptyMode|))
 (|htInitPage| '|Sum Basic Command| NIL)
 (|htMakePage|
   '((|domainConditions| (|isDomain| EM |$EmptyMode|)
         (|isDomain| S (|String|)) (|isDomain| SY (|Symbol|)))
     (|text| . "\\newline ")
     (|text| . "\\menuitemstyle{}\\tab{2}")
     (|text| . "Enter the {\\em function} you would like to sum:")
     (|text| . "\\newline\\tab{2} ")
     (|bcStrings| (44 "i**3" |summand| EM))
     (|text| . "\\blankline ") (|text| . "\\newline ")
     (|text| . "\\menuitemstyle{}\\tab{2}")
     (|text| . "Enter the {\\em summation index}:")
     (|text| . "\\tab{36}") (|bcStrings| (10 |i| |index| SY))
     (|text| . "\\blankline ") (|text| . "\\newline ")
     (|text| . "\\menuitemstyle{}\\tab{2}")
     (|text| . "Enter the limits of the sum:")
     (|text| . "\\newline\\tab{10}{\\em From:}")
     (|bcStrings| (10 1 |first| S))
     (|text| . "\\tab{32}{\\em To:}") (|text| . "\\tab{36}")
     (|bcStrings| (10 |n| |last| S))
     (|doneButton| "Continue" |bcSumGen|)))
 (|htShowPage|))

\end{chunk}

\defun{bcSumGen}{bcSumGen}
\calls{bcSumGen}{htpLabelInputString}
\calls{bcSumGen}{concat}
\calls{bcSumGen}{bcGen}
\begin{chunk}{defun bcSumGen}
(defun |bcSumGen| (htPage)
 (let (mand index car last)
  (setq mand  (|htpLabelInputString| htPage '|summand|))
  (setq index (|htpLabelInputString| htPage '|index|))
  (setq car   (|htpLabelInputString| htPage '|first|))
  (setq last  (|htpLabelInputString| htPage '|last|))
  (|bcGen| (concat "sum(" mand "," index " = " car ".." last ")"))))

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% HyperDoc -> Basic Commands -> Matrix
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Matrix}

%\begin{center}
%{\bf {\large{Calculus}}}
%\vskip 0.25cm
%\includegraphics[scale=1.0]{ps/v5bccalculus.eps}
%\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% HyperDoc -> Basic Commands -> Matrix
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defun{bcMatrix}{Basic Commands - Matrix}

\begin{center}
{\bf {\large{Matrix}}}
\vskip 0.25cm
\includegraphics[scale=1.0]{ps/v5bccalculus.eps}
\end{center}

\calls{bcMatrix}{bcReadMatrix}
\begin{chunk}{defun bcMatrix}
(defun |bcMatrix| () (|bcReadMatrix| nil))

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% HyperDoc -> Basic Commands -> Draw
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Draw}

%\begin{center}
%{\bf {\large{Calculus}}}
%\vskip 0.25cm
%\includegraphics[scale=1.0]{ps/v5bccalculus.eps}
%\end{center}

\defun{bcDraw}{Basic Commands - Draw}
\calls{bcDraw}{htInitPage}
\calls{bcDraw}{bcHt}
\calls{bcDraw}{htShowPage}

\begin{center}
{\bf {\large{Draw Basic Command}}}
\vskip 0.25cm
\includegraphics[scale=1.0]{ps/v5bcdraw.eps}
\end{center}

\begin{chunk}{defun bcDraw}
(defun |bcDraw| ()
 (|htInitPage| "Draw Basic Command" NIL)
 (|bcHt| "What would you like to draw?")
 (|bcHt| "\\newline\\centerline{{\\em Two Dimensional Plots}}\\newline")
 (|bcHt| "\\lispdownlink{A function of one variable}{(|bcDraw2Dfun|)}")
 (|bcHt| "\\space{2}y = f(x)\\newline")
 (|bcHt| "\\lispdownlink{A parametrically defined curve}{(|bcDraw2Dpar|)}")
 (|bcHt| "\\space{2}(x(t), y(t))\\newline")
 (|bcHt| 
  "\\lispdownlink{A solution to a polynomial equation}{(|bcDraw2DSolve|)}")
 (|bcHt| "\\space{2} p(x,y) = 0\\newline")
 (|bcHt| "\\vspace{1}\\newline ")
 (|bcHt| "\\centerline{{\\em Three Dimensional Surfaces}}\\newline\\newline")
 (|bcHt| "\\lispdownlink{A function of two variables}{(|bcDraw3Dfun|)}")
 (|bcHt| "\\space{2} z = f(x,y)\\newline")
 (|bcHt| "\\lispdownlink{A parametrically defined tube}{(|bcDraw3Dpar|)}")
 (|bcHt| "\\space{2}(x(t), y(t), z(t))\\newline")
 (|bcHt| "\\lispdownlink{A parameterically defined surface}{(|bcDraw3Dpar1|)}")
 (|bcHt| "\\space{2}(x(u,v), y(u,v), z(u,v))\\newline")
 (|htShowPage|))

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% HyperDoc -> Basic Commands -> Draw -> Function of one variable
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defun{bcDraw2Dfun}{Draw - Function of one variable}
\calls{bcDraw2Dfun}{htInitPage}
\calls{bcDraw2Dfun}{htMakePage}
\calls{bcDraw2Dfun}{htShowPage}
\usesdollar{bcDraw2Dfun}{EmptyMode}

\begin{center}
{\bf {\large{Draw Basic Command by Function}}}
\vskip 0.25cm
\includegraphics[scale=1.0]{ps/v5bcdraw2dfun.eps}
\end{center}

Pressing the {\bf Continue} button will call the function
{\bf bcDraw2DfunGen} due to this line:
\begin{verbatim}
   (|doneButton| "Continue" |bcDraw2DfunGen|)
\end{verbatim}
\begin{chunk}{defun bcDraw2Dfun}
(defun |bcDraw2Dfun| ()
 (declare (special |$EmptyMode|))
 (|htInitPage| "Draw Basic Command" NIL)
 (|htMakePage|
  '((|domainConditions| (|isDomain| EM |$EmptyMode|)
         (|isDomain| F (|Float|)) (|isDomain| SY (|Symbol|)))
     (|text| "\\centerline{Drawing {\\em y = f(x)}}\\newline "
        "\\centerline{where {\\em y} is the dependent variable and}\\newline "
"\\centerline{where {\\em x} is the independent variable}\\vspace{1}\\newline "
"\\menuitemstyle{}\\tab{2}What {\\em function} f would you like to draw?\\newline\\tab{2}")
     (|bcStrings| (55 "x*cos(x)" |function| EM))
     (|text| .
"\\vspace{1}\\newline\\menuitemstyle{}\\tab{2}Enter {\\em dependent} variable:")
     (|bcStrings| (6 |y| |dependent| SY))
     (|text| . "\\newline\\vspace{1}\\newline ")
     (|text| . 
"\\menuitemstyle{}\\tab{2}Enter {\\em independent} variable and {\\em range}:\\newline\\tab{2} ")
     (|text| . "{\\em Variable:}") (|bcStrings| (6 |x| |ind| SY))
     (|text| . "ranges {\\em from:}")
     (|bcStrings| (9 0 |from1| F)) (|text| . "{\\em to:}")
     (|bcStrings| (9 30 |to1| F))
     (|text| "\\indent{0}\\vspace{1}\\newline\\menuitemstyle{}\\tab{2} "
             "Optionally enter a {\\em title} for your curve:")
     (|bcStrings| (15 "y = x*cos(x)" |title| S))
     (|text| . "\\indent{0}")
     (|doneButton| "Continue" |bcDraw2DfunGen|) (|text| . "{}")))
 (|htShowPage|))

\end{chunk}

\defun{bcDraw2DfunGen}{bcDraw2DfunGen}
\calls{bcDraw2DfunGen}{htpLabelInputString}
\calls{bcDraw2DfunGen}{concat}
\calls{bcDraw2DfunGen}{bcFinish}
\calls{bcDraw2DfunGen}{bcDrawIt2}
\begin{chunk}{defun bcDraw2DfunGen}
(defun |bcDraw2DfunGen| (htPage)
 (let (fun dep ind from1 to1 title titlePart)
  (setq fun   (|htpLabelInputString| htPage '|function|))
  (setq dep   (|htpLabelInputString| htPage '|dependent|))
  (setq ind   (|htpLabelInputString| htPage '|ind|))
  (setq from1 (|htpLabelInputString| htPage '|from1|))
  (setq to1   (|htpLabelInputString| htPage '|to1|))
  (setq title (|htpLabelInputString| htPage '|title|))
  (cond
   ((not (string-equal title ""))
     (setq titlePart (concat "{}" "title ==\"" title "\""))
     (|bcFinish| "draw" fun (|bcDrawIt2| ind from1 to1) titlePart))
   (t
     (|bcFinish| "draw" fun (|bcDrawIt2| ind from1 to1))))))

\end{chunk}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% HyperDoc -> Basic Commands -> Draw -> Parametrically defined curve
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defun{bcDraw2Dpar}{Draw - Parametrically defined curve}
\calls{bcDraw2Dpar}{htInitPage}
\calls{bcDraw2Dpar}{htMakePage}
\calls{bcDraw2Dpar}{htShowPage}
\usesdollar{bcDraw2Dpar}{EmptyMode}

\begin{center}
{\bf {\large{Draw Basic Command by Parameters}}}
\vskip 0.25cm
\includegraphics[scale=1.0]{ps/v5bcdraw2dpar.eps}
\end{center}

Pressing the {\bf Continue} button will call the function
{\bf bcDraw2DparGen} due to this line:
\begin{verbatim}
   (|doneButton| "Continue" |bcDraw2DparGen|)
\end{verbatim}
\begin{chunk}{defun bcDraw2Dpar}
(defun |bcDraw2Dpar| ()
 (declare (special |$EmptyMode|))
 (|htInitPage| "Draw Basic Command" NIL)
 (|htMakePage|
  '((|domainConditions| (|isDomain| EM |$EmptyMode|)
        (|isDomain| F (|Float|)) (|isDomain| SY (|Symbol|)))
    (|text| "\\centerline{Drawing a parametrically defined curve:}\\newline "
            "\\centerline{{\\em ( f1(t), f2(t) )}}\\newline "
            "\\centerline{in terms of two functions {\\em f1} and {\\em f2}}"
       "\\centerline{and an independent variable {\\em t}}\\vspace{1}\\newline"
            "\\menuitemstyle{}\\tab{2}Enter the two {\\em functions:}")
    (|text| . "\\newline\\tab{2}{\\em Function 1:}")
    (|bcStrings| (44 "-9*sin(4*t/5)" |function1| EM))
    (|text| . "\\newline\\tab{2}{\\em Function 2:}")
    (|bcStrings| (44 "8*sin(t)" |function2| EM))
    (|text| . 
"\\vspace{1}\\newline\\menuitemstyle{}\\tab{2}Enter {\\em independent} variable and range:\\newline\\tab{2} ")
    (|text| . "{\\em Variable:}") (|bcStrings| (6 |t| |ind| SY))
    (|text| . "ranges {\\em from:}")
    (|bcStrings| (9 "-5*\\%pi" |from1| F))
    (|text| . "{\\em to:}") (|bcStrings| (9 "5*\\%pi" |to1| F))
    (|text| "\\vspace{1}\\newline\\menuitemstyle{}\\tab{2}"
            "Optionally enter a {\\em title} for your curve:")
    (|bcStrings| (15 "Lissajous" |title| S))
    (|text| . "\\indent{0}")
    (|doneButton| "Continue" |bcDraw2DparGen|)))
 (|htShowPage|))

\end{chunk}

\defun{bcDraw2DparGen}{bcDraw2DparGen}
\calls{bcDraw2DparGen}{htpLabelInputString}
\calls{bcDraw2DparGen}{concat}
\calls{bcDraw2DparGen}{bcFinish}
\calls{bcDraw2DparGen}{bcDrawIt2}
\begin{chunk}{defun bcDraw2DparGen}
(defun |bcDraw2DparGen| (htPage)
 (let (fun1 fun2 ind from1 to1 title curvePart titlePart)
  (setq fun1  (|htpLabelInputString| htPage '|function1|))
  (setq fun2  (|htpLabelInputString| htPage '|function2|))
  (setq ind   (|htpLabelInputString| htPage '|ind|))
  (setq from1 (|htpLabelInputString| htPage '|from1|))
  (setq to1   (|htpLabelInputString| htPage '|to1|))
  (setq title (|htpLabelInputString| htPage '|title|))
  (setq curvePart (concat "curve(" "{}" fun1 ",{}" fun2 ")"))
  (cond
   ((not (string-equal title ""))
     (setq titlePart (concat "{}" "title ==\"" title "\""))
     (|bcFinish| "draw" curvePart (|bcDrawIt2| ind from1 to1) titlePart))
    (t
     (|bcFinish| "draw" curvePart (|bcDrawIt2| ind from1 to1))))))

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% HyperDoc -> Basic Commands -> Draw -> Solution to a polynomial equation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defun{bcDraw2DSolve}{Draw - Solution to a polynomial equation}
\calls{bcDraw2DSolve}{htInitPage}
\calls{bcDraw2DSolve}{htMakePage}
\calls{bcDraw2DSolve}{htMakeDoneButton}
\calls{bcDraw2DSolve}{htShowPage}
\usesdollar{bcDraw2DSolve}{EmptyMode}

\begin{center}
{\bf {\large{Draw Basic Command by Equation Solution}}}
\vskip 0.25cm
\includegraphics[scale=1.0]{ps/v5bcdraw2dsolve.eps}
\end{center}

Pressing the {\bf Continue} button will call the function
{\bf bcDraw2DSolveGen} due to this line:
\begin{verbatim}
   (|htMakeDoneButton| "Continue" '|bcDraw2DSolveGen|)
\end{verbatim}
\begin{chunk}{defun bcDraw2DSolve}
(defun |bcDraw2DSolve| ()
 (declare (special |$EmptyMode|))
 (|htInitPage| "Draw Basic Command" nil)
 (|htMakePage|
  '((|domainConditions| (|isDomain| EM |$EmptyMode|)
        (|isDomain| F (|Float|)) (|isDomain| SY (|Symbol|)))
    (|text| "\\centerline{Plotting the solution to {\\em p(x,y) = 0}, where} "
"\\centerline{{\\em p} is a polynomial in two variables {\\em x} and {\\em y}}"
"\\vspace{1}\\newline\\menuitemstyle{}\\tab{2}Enter the {\\em polynomial} p:"
            "\\newline\\tab{2}")
    (|bcStrings| (40 "y**2+7*x*y-(x**3+16*x)" |function| EM))
    (|text| .
    "\\vspace{1}\\newline\\menuitemstyle{}\\tab{2}Enter the {\\em variables}:")
    (|text| . "\\newline\\tab{2}{\\em Variable 1:} ")
    (|bcStrings| (4 |x| |independent1| SY))
    (|text| . "ranges {\\em from:}")
    (|bcStrings| (9 -15 |from1| F)) (|text| . "{\\em to:}")
    (|bcStrings| (9 10 |to1| F))
    (|text| . "\\newline\\tab{2}{\\em Variable 2:} ")
    (|bcStrings| (4 |y| |independent2| SY))
    (|text| . "ranges {\\em from:}")
    (|bcStrings| (9 -10 |from2| F)) (|text| . "{\\em to:}")
    (|bcStrings| (9 50 |to2| F))
    (|text| "\\indent{0}\\vspace{1}\\newline\\menuitemstyle{}\\tab{2} "
            "Optionally enter a {\\em title} for your curve:")
    (|bcStrings| (15 "" |title| S)) (|text| . "\\indent{0}")))
 (|htMakeDoneButton| "Continue" '|bcDraw2DSolveGen|)
 (|htShowPage|))

\end{chunk}

\defun{bcDraw2DSolveGen}{bcDraw2DSolveGen}
\calls{bcDraw2DSolveGen}{htpLabelInputString}
\calls{bcDraw2DSolveGen}{concat}
\calls{bcDraw2DSolveGen}{bcFinish}
\begin{chunk}{defun bcDraw2DSolveGen}
(defun |bcDraw2DSolveGen| (htPage)
 (let (fun ind1 from1 to1 ind2 from2 to2 title clipPart titlePart)
  (setq fun   (|htpLabelInputString| htPage '|function|))
  (setq ind1  (|htpLabelInputString| htPage '|independent1|))
  (setq from1 (|htpLabelInputString| htPage '|from1|))
  (setq to1   (|htpLabelInputString| htPage '|to1|))
  (setq ind2  (|htpLabelInputString| htPage '|independent2|))
  (setq from2 (|htpLabelInputString| htPage '|from2|))
  (setq to2   (|htpLabelInputString| htPage '|to2|))
  (setq title (|htpLabelInputString| htPage '|title|))
  (setq clipPart (concat "{}" "range==[{}"
                     from1 ".." to1 '|,{}|
                     from2 ".." to2 "]"))
  (cond
   ((not (string-equal title ""))
    (setq titlePart (concat "{}" "title ==\"" title "\""))
    (|bcFinish| "draw" (concat fun " = 0 ") ind1 ind2 clipPart titlePart))
   (t
     (|bcFinish| "draw" (concat fun " = 0 ") ind1 ind2 clipPart)))))

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% HyperDoc -> Basic Commands -> Draw -> Function of two variables
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defun{bcDraw3Dfun}{Draw - Function of two variables}
\calls{bcDraw3Dfun}{htInitPage}
\calls{bcDraw3Dfun}{htMakePage}
\calls{bcDraw3Dfun}{htShowPage}
\usesdollar{bcDraw3Dfun}{EmptyMode}

\begin{center}
{\bf {\large{Draw Basic Command by 3D function}}}
\vskip 0.25cm
\includegraphics[scale=1.0]{ps/v5bcdraw3dfun.eps}
\end{center}

Pressing the {\bf Continue} button will call the function
{\bf bcDraw3DfunGen} due to this line:
\begin{verbatim}
    (|doneButton| "Continue" |bcDraw3DfunGen|)
\end{verbatim}
\begin{chunk}{defun bcDraw3Dfun}
(defun |bcDraw3Dfun| ()
 (declare (special |$EmptyMode|))
 (|htInitPage| "Three Dimensional Draw Basic Command" nil)
 (|htMakePage|
  '((|domainConditions| (|isDomain| EM |$EmptyMode|)
        (|isDomain| F (|Float|)) (|isDomain| SY (|Symbol|)))
    (|text| "\\centerline{Drawing {\\em z = f(x,y)}}\\newline "
        "\\centerline{where {\\em z} is the dependent variable and}\\newline "
"\\centerline{where {\\em x, y} are the independent variables}\\vspace{1}\\newline\\menuitemstyle{}\\tab{2} "
        "What {\\em function} f which you like to draw?\\newline\\tab{2}")
    (|bcStrings| (55 "exp(cos(x-y)-sin(x*y))-2" |function| EM))
    (|text| . 
       "\\newline\\menuitemstyle{}\\tab{2}Enter {\\em dependent} variable:")
    (|bcStrings| (6 |z| |dependent| SY))
    (|text| "\\vspace{1}\\newline\\menuitemstyle{}\\tab{2}"
            "Enter {\\em independent} variables and ranges:\\newline\\tab{2} "
            "{\\em Variable:}")
    (|bcStrings| (6 |x| |independent1| SY))
    (|text| . "ranges {\\em from:}")
    (|bcStrings| (9 -5 |from1| F)) (|text| . "{\\em to:}")
    (|bcStrings| (9 5 |to1| F))
    (|text| . "\\newline\\tab{2}{\\em Variable:}")
    (|bcStrings| (6 |y| |independent2| SY))
    (|text| . "ranges {\\em from:}")
    (|bcStrings| (9 -5 |from2| F)) (|text| . "{\\em to:}")
    (|bcStrings| (9 5 |to2| F))
    (|text| "\\indent{0}\\vspace{1}\\newline\\menuitemstyle{}\\tab{2} "
            "Optionally enter a {\\em title} for your surface:")
    (|bcStrings| (15 "" |title| S)) (|text| . "\\indent{0}")
    (|doneButton| "Continue" |bcDraw3DfunGen|)))
 (|htShowPage|))

\end{chunk}

\defun{bcDraw3DfunGen}{bcDraw3DfunGen}
\calls{bcDraw3DfunGen}{htpLabelInputString}
\calls{bcDraw3DfunGen}{concat}
\calls{bcDraw3DfunGen}{bcFinish}
\calls{bcDraw3DfunGen}{bcDrawIt2}
\begin{chunk}{defun bcDraw3DfunGen}
(defun |bcDraw3DfunGen| (htPage)
 (let (fun dep ind1 from1 to1 ind2 from2 to2 title titlePart)
  (setq fun   (|htpLabelInputString| htPage '|function|))
  (setq dep   (|htpLabelInputString| htPage '|dependent|))
  (setq ind1  (|htpLabelInputString| htPage '|independent1|))
  (setq from1 (|htpLabelInputString| htPage '|from1|))
  (setq to1   (|htpLabelInputString| htPage '|to1|))
  (setq ind2  (|htpLabelInputString| htPage '|independent2|))
  (setq from2 (|htpLabelInputString| htPage '|from2|))
  (setq to2   (|htpLabelInputString| htPage '|to2|))
  (setq title (|htpLabelInputString| htPage '|title|))
  (cond
    ((not (string-equal title ""))
      (setq titlePart (concat "{}" "title ==\"" title "\""))
      (|bcFinish| "draw" fun
         (|bcDrawIt2| ind1 from1 to1)
         (|bcDrawIt2| ind2 from2 to2) titlePart))
    (t
      (|bcFinish| "draw" fun
         (|bcDrawIt2| ind1 from1 to1)
         (|bcDrawIt2| ind2 from2 to2))))))

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% HyperDoc -> Basic Commands -> Draw -> Parametrically defined tube
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defun{bcDraw3Dpar}{Draw - Parametrically defined tube}
\calls{bcDraw3Dpar}{htInitPage}
\calls{bcDraw3Dpar}{htMakePage}
\calls{bcDraw3Dpar}{htShowPage}
\usesdollar{bcDraw3Dpar}{EmptyMode}

\begin{center}
{\bf {\large{Draw Basic Command by 3D parameterized tube}}}
\vskip 0.25cm
\includegraphics[scale=1.0]{ps/v5bcdraw3dpar.eps}
\end{center}

Pressing the {\bf Continue} button will call the function
{\bf bcDraw3DparGen} due to this line:
\begin{verbatim}
    (|doneButton| "Continue" |bcDraw3DparGen|)
\end{verbatim}
\begin{chunk}{defun bcDraw3Dpar}
(defun |bcDraw3Dpar| ()
 (declare (special |$EmptyMode|))
 (|htInitPage| "Draw Basic Command" NIL)
 (|htMakePage|
  '((|domainConditions| (|isDomain| EM |$EmptyMode|)
        (|isDomain| F (|Float|)) (|isDomain| SY (|Symbol|)))
    (|text| "\\centerline{Drawing a parametrically defined curve:"
            "{\\em ( f1(t), f2(t), f3(t) )}}\\newline "
"\\centerline{in terms of three functions {\\em f1}, {\\em f2}, and {\\em f3}}\\newline "
"\\centerline{and an independent variable {\\em t}}\\vspace{1}\\newline\\menuitemstyle{}\\tab{2} "
            "Enter the three {\\em functions} of the independent variable:")
    (|text| . "\\newline\\tab{2}{\\em Function f1:}")
    (|bcStrings| (42 "1.3*cos(2*t)*cos(4*t) + sin(4*t)*cos(t)" |function1| EM))
    (|text| . "\\newline\\tab{2}{\\em Function f2:}")
    (|bcStrings| (42 "1.3*sin(2*t)*cos(4*t) - sin(4*t)*sin(t)" |function2| EM))
    (|text| . "\\newline\\tab{2}{\\em Function f3:}")
    (|bcStrings| (42 "2.5*cos(4*t)" |function3| EM))
    (|text| . 
"\\vspace{1}\\newline\\menuitemstyle{}\\tab{2}Enter {\\em independent} variable and range:\\newline\\tab{2} ")
    (|text| . "{\\em Variable:}") (|bcStrings| (6 |t| |ind| SY))
    (|text| . "ranges {\\em from:}")
    (|bcStrings| (9 0 |from1| F)) (|text| "{\\em to:}")
    (|bcStrings| (9 "4*\\%pi" |to1| F))
    (|text| "\\indent{0}\\vspace{1}\\newline\\menuitemstyle{}\\tab{2} "
            "Optionally enter a {\\em title} for your surface:")
    (|bcStrings| (15 "knot" |title| S)) (|text| . "\\indent{0}")
    (|doneButton| "Continue" |bcDraw3DparGen|)))
 (|htShowPage|))

\end{chunk}

\defun{bcDraw3DparGen}{bcDraw3DparGen}
\calls{bcDraw3DparGen}{htpLabelInputString}
\calls{bcDraw3DparGen}{concat}
\calls{bcDraw3DparGen}{bcFinish}
\calls{bcDraw3DparGen}{bcDrawIt2}
\begin{chunk}{defun bcDraw3DparGen}
(defun |bcDraw3DparGen| (htPage)
 (let (fun1 fun2 fun3 ind from1 to1 title curvePart tubePart titlePart)
  (setq fun1  (|htpLabelInputString| htPage '|function1|))
  (setq fun2  (|htpLabelInputString| htPage '|function2|))
  (setq fun3  (|htpLabelInputString| htPage '|function3|))
  (setq ind   (|htpLabelInputString| htPage '|ind|))
  (setq from1 (|htpLabelInputString| htPage '|from1|))
  (setq to1   (|htpLabelInputString| htPage '|to1|))
  (setq title (|htpLabelInputString| htPage '|title|))
  (setq curvePart (concat "curve(" "{}" fun1 ",{}" fun2 ",{}" fun3 ")"))
  (setq tubePart "{}tubeRadius==.25,{}tubePoints==16")
  (cond
    ((not (string-equal title ""))
      (setq titlePart (concat "{}" "title ==\"" title "\""))
      (|bcFinish| "draw" curvePart
         (|bcDrawIt2| ind from1 to1) tubePart titlePart))
    (t
      (|bcFinish| "draw" curvePart
         (|bcDrawIt2| ind from1 to1) tubePart)))))

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% HyperDoc -> Basic Commands -> Draw -> Parametrically defined surface
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defun{bcDraw3Dpar1}{Draw - Parametrically defined surface}
\calls{bcDraw3Dpar1}{htInitPage}
\calls{bcDraw3Dpar1}{htMakePage}
\calls{bcDraw3Dpar1}{htMakeDoneButton}
\calls{bcDraw3Dpar1}{htShowPage}
\usesdollar{bcDraw3Dpar1}{EmptyMode}

\begin{center}
{\bf {\large{Draw Basic Command by 3D parameterized function}}}
\vskip 0.25cm
\includegraphics[scale=1.0]{ps/v5bcdraw3dpar1.eps}
\end{center}

Pressing the {\bf Continue} button will call the function
{\bf bcDraw3Dpar1Gen} due to this line:
\begin{verbatim}
    (|htMakeDoneButton| "Continue" '|bcDraw3Dpar1Gen|)
\end{verbatim}
\begin{chunk}{defun bcDraw3Dpar1}
(defun |bcDraw3Dpar1| ()
 (declare (special |$EmptyMode|))
 (|htInitPage| "Draw Basic Command" NIL)
 (|htMakePage|
  '((|domainConditions| (|isDomain| EM |$EmptyMode|)
        (|isDomain| F (|Float|)) (|isDomain| SY (|Symbol|)))
    (|text| "\\centerline{Drawing a parametrically defined surface:}\\newline "
            "\\centerline{{\\em ( f1(u,v), f2(u,v), f3(u,v) )}}\\newline "
"\\centerline{in terms of three functions {\\em f1}, {\\em f2}, and {\\em f3}}\\newline "
"\\centerline{and two independent variables {\\em u} and {\\em v}}\\vspace{1}\\newline\\menuitemstyle{}\\tab{2}"
            "Enter the three {\\em functions} of the independent variables:")
    (|text| . "\\newline\\tab{2}")
    (|text| . "{\\em Function f1:}")
    (|bcStrings| (43 "u*sin(v)" |function1| EM))
    (|text| . "\\newline\\tab{2}")
    (|text| . "{\\em Function f2:}")
    (|bcStrings| (43 "v*cos(u)" |function2| EM))
    (|text| . "\\newline\\tab{2}")
    (|text| . "{\\em Function f3:}")
    (|bcStrings| (43 "u*cos(v)" |function3| EM))
    (|text| .
"\\newline\\menuitemstyle{}\\tab{2}Enter independent {\\em variables} and ranges:")
    (|text| . "\\newline\\tab{2}")
    (|text| . "{\\em Variable 1:}")
    (|bcStrings| (5 |u| |ind1| SY))
    (|text| . "ranges {\\em from:}")
    (|bcStrings| (9 "-\\%pi" |from1| F)) (|text| . "{\\em to:}")
    (|bcStrings| (9 "\\%pi" |to1| F))
    (|text| . "\\newline\\tab{2}")
    (|text| . "{\\em Variable 2:}")
    (|bcStrings| (5 |v| |ind2| SY))
    (|text| . "ranges {\\em from:}")
    (|bcStrings| (9 "-\\%pi/2" |from2| F))
    (|text| . "{\\em to:}") (|bcStrings| (9 "\\%pi/2" |to2| F))
    (|text| "\\indent{0}\\newline\\menuitemstyle{}\\tab{2} "
            "Optionally enter a {\\em title} for your surface:")
    (|bcStrings| (15 "surface" |title| S))
    (|text| . "\\indent{0}")))
 (|htMakeDoneButton| "Continue" '|bcDraw3Dpar1Gen|)
 (|htShowPage|))

\end{chunk}

\defun{bcDraw3Dpar1Gen}{bcDraw3Dpar1Gen}
\calls{bcDraw3Dpar1Gen}{htpLabelInputString}
\calls{bcDraw3Dpar1Gen}{bcDrawIt2}
\calls{bcDraw3Dpar1Gen}{concat}
\calls{bcDraw3Dpar1Gen}{bcFinish}
\begin{chunk}{defun bcDraw3Dpar1Gen}
(defun |bcDraw3Dpar1Gen| (htPage)
 (let (fun1 fun2 fun3 ind1 from1 to1 ind2 from2 to2
       title r1 r2 surfacePart titlePart)
   (setq fun1  (|htpLabelInputString| htPage '|function1|))
   (setq fun2  (|htpLabelInputString| htPage '|function2|))
   (setq fun3  (|htpLabelInputString| htPage '|function3|))
   (setq ind1  (|htpLabelInputString| htPage '|ind1|))
   (setq from1 (|htpLabelInputString| htPage '|from1|))
   (setq to1   (|htpLabelInputString| htPage '|to1|))
   (setq ind2  (|htpLabelInputString| htPage '|ind2|))
   (setq from2 (|htpLabelInputString| htPage '|from2|))
   (setq to2   (|htpLabelInputString| htPage '|to2|))
   (setq title (|htpLabelInputString| htPage '|title|))
   (setq r1 (|bcDrawIt2| ind1 from1 to1))
   (setq r2 (|bcDrawIt2| ind2 from2 to2))
   (setq surfacePart (concat "surface(" "{}" fun1 ",{}" fun2 ",{}" fun3 ")"))
   (cond
     ((not (string= title ""))
       (setq titlePart (concat "{}" "title ==\"" title "\""))
       (|bcFinish| "draw" surfacePart r1 r2 titlePart))
     (t (|bcFinish| "draw" surfacePart r1 r2)))))

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% HyperDoc -> Basic Commands -> Series
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Series}

%\begin{center}
%{\bf {\large{Calculus}}}
%\vskip 0.25cm
%\includegraphics[scale=1.0]{ps/v5bccalculus.eps}
%\end{center}

\defun{bcSeries}{Basic Commands - Series}
\calls{bcSeries}{htInitPage}
\calls{bcSeries}{htMakePage}
\calls{bcSeries}{htShowPage}
\usesdollar{bcSeries}{EmptyMode}


\begin{center}
{\bf {\large{Matrix Basic Command}}}
\vskip 0.25cm
\includegraphics[scale=1.0]{ps/v5bcseries.eps}
\end{center}

\begin{chunk}{defun bcSeries}
(defun |bcSeries| ()
 (declare (special |$EmptyMode|))
 (|htInitPage| "Series Basic Command" nil)
 (|htMakePage|
  '((|domainConditions| (|isDomain| EM |$EmptyMode|)
        (|isDomain| S (|String|)) (|isDomain| SY (|Symbol|)))
    (|text| . "Create a series by: ") (|text| . "\\beginmenu")
    (|text| . "\\item ")
    (|bcLinks| ("\\menuitemstyle{Expansion}" "" |bcSeriesExpansion| nil))
    (|text| . "\\tab{11}Expand a function in a series around a point")
    (|text| . "\\item ")
    (|bcLinks| ("\\menuitemstyle{Formula}" "" |bcSeriesByFormula| nil))
    (|text| . "\\tab{11}Give a formula for the {\\em i}'th coefficient")
    (|text| . "\\endmenu")))
 (|htShowPage|))

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% HyperDoc -> Basic Commands -> Series -> Expansion
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defun{bcSeriesExpansion}{Series - Expansion}
\calls{bcSeriesExpansion}{htInitPage}
\calls{bcSeriesExpansion}{htMakePage}
\calls{bcSeriesExpansion}{htMakeDoneButton}
\calls{bcSeriesExpansion}{htShowPage}
\usesdollar{bcSeriesExpansion}{EmptyMode}

\begin{center}
{\bf {\large{Series Basic Command expand around a point}}}
\vskip 0.25cm
\includegraphics[scale=1.0]{ps/v5bcseriesexpansion.eps}
\end{center}

Pressing the {\bf Continue} button will call the function
{\bf bcSeriesExpansionGen} due to this line:
\begin{verbatim}
    (|htMakeDoneButton| "Continue" '|bcSeriesExpansionGen|)
\end{verbatim}
\begin{chunk}{defun bcSeriesExpansion}
(defun |bcSeriesExpansion| (a b)
 (declare (ignore a b))
 (declare (special |$EmptyMode|))
 (|htInitPage| "Series Expansion Basic Command" nil)
 (|htMakePage|
  '((|domainConditions| (|isDomain| EM |$EmptyMode|)
        (|isDomain| EEM (|Expression| |$EmptyMode|))
        (|isDomain| S (|String|)) (|isDomain| SY (|Symbol|)))
    (|text| . "\\newline ")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| . "Enter the {\\em function} you want to expand in a power series")
    (|text| . "\\newline\\tab{2} ")
    (|bcStrings| (55 "log(cot(x))" |function| EM))
    (|text| . "\\blankline ")
    (|text| . "\\newline ")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| . "Enter the {\\em power series variable}")
    (|text| . "\\tab{49}")
    (|bcStrings| (8 |x| |variable| SY))
    (|text| . "\\blankline ")
    (|text| . "\\newline ")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| . "Enter the {\\em point} about which you want to expand")
    (|text| . "\\tab{49}")
    (|bcStrings| (8 "\\%pi/2" |point| EM))))
 (|htMakeDoneButton| "Continue" '|bcSeriesExpansionGen|)
 (|htShowPage|))

\end{chunk}

\defun{bcSeriesExpansionGen}{bcSeriesExpansionGen}
\calls{bcSeriesExpansionGen}{htpLabelInputString}
\calls{bcSeriesExpansionGen}{concat}
\calls{bcSeriesExpansionGen}{bcFinish}
\begin{chunk}{defun bcSeriesExpansionGen}
(defun |bcSeriesExpansionGen| (htPage)
 (let (fun var point terms)
  (setq fun (|htpLabelInputString| htPage '|function|))
  (setq var (|htpLabelInputString| htPage '|variable|))
  (setq point (|htpLabelInputString| htPage '|point|))
  (setq terms (|htpLabelInputString| htPage '|numberOfTerms|))
  (|bcFinish| "series" fun (concat var " = " point))))

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% HyperDoc -> Basic Commands -> Series -> Formula
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defun{bcSeriesByFormula}{Series - Formula}
\calls{bcSeriesByFormula}{htInitPage}
\calls{bcSeriesByFormula}{htMakePage}
\calls{bcSeriesByFormula}{htShowPage}

\begin{center}
{\bf {\large{Series Basic Command series by formula}}}
\vskip 0.25cm
\includegraphics[scale=0.75]{ps/v5bcseriesbyformula.eps}
\end{center}

\begin{chunk}{defun bcSeriesByFormula}
(defun |bcSeriesByFormula| (a b)
 (declare (ignore a b))
 (|htInitPage| "Power Series Basic Command" NIL)
 (|htMakePage|
  '((|text| . "Select the kind of power series you want to create:")
    (|text| . "\\beginmenu") (|text| . "\\item ")
    (|bcLinks|
      ("\\menuitemstyle{Taylor Series}" "" |bcTaylorSeries| |taylor|))
    (|text| . 
"\\newline Series where the exponent ranges over the integers from a {\\em non-negative integer} value to plus infinity by an arbitrary {\\em positive integer} step size")
    (|text| . "\\item ")
    (|bcLinks|
      ("\\menuitemstyle{Laurent Series}" "" |bcLaurentSeries| |laurent|))
    (|text| .
"\\newline Series where the exponent ranges from an arbitrary {\\em integer} value to plus infinity by an arbitrary {\\em positive integer} step size")
    (|text| . "\\item ")
    (|bcLinks|
      ("\\menuitemstyle{Puiseux Series}" "" |bcPuiseuxSeries| |puiseux|))
    (|text| .
"\\newline Series where the exponent ranges from an arbitrary {\\em rational value} to plus infinity by an arbitrary {\\em positive rational number} step size")
    (|text| . "\\endmenu")))
 (|htShowPage|))

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% HyperDoc -> Basic Commands -> Series -> Formula -> Taylor Series
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defun{bcTaylorSeries}{Series - Formula - Taylor Series}
\calls{bcTaylorSeries}{htInitPage}
\calls{bcTaylorSeries}{htMakePage}
\calls{bcTaylorSeries}{htShowPage}
\usesdollar{bcTaylorSeries}{EmptyMode}

\begin{center}
{\bf {\large{Taylor Series Basic Command}}}
\vskip 0.25cm
\includegraphics[scale=1.0]{ps/v5bctaylorseries.eps}
\end{center}

Pressing the {\bf Continue} button will call the function
{\bf bcTaylorSeriesGen} due to this line:
\begin{verbatim}
   (|doneButton| "Continue" |bcTaylorSeriesGen|)
\end{verbatim}
\begin{chunk}{defun bcTaylorSeries}
(defun |bcTaylorSeries| (a b)
 (declare (ignore a b))
 (declare (special |$EmptyMode|))
 (|htInitPage| "Taylor Series Basic Command" NIL)
 (|htMakePage|
  '((|domainConditions| (|isDomain| EM |$EmptyMode|)
        (|isDomain| EEM (|Expression| |$EmptyMode|))
        (|isDomain| S (|String|)) (|isDomain| SY (|Symbol|)))
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| . "Enter the formula for the general coefficient of the series")
    (|text| . "\\newline\\tab{2} ")
    (|bcStrings| (55 "1/factorial(i)" |formula| EM))
    (|text| . "\\blankline ")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| . "Enter the {\\em index variable} for your formula")
    (|text| . "\\tab{49}") (|bcStrings| (8 |i| |index| SY))
    (|text| . "\\newline ")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| . "Enter the {\\em power series variable}")
    (|text| . "\\tab{49}") (|bcStrings| (8 |x| |variable| SY))
    (|text| . "\\newline ")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| . "Enter the {\\em point} about which you want to expand")
    (|text| . "\\tab{49}") (|bcStrings| (8 0 |point| EM))
    (|text| . "\\blankline ")
    (|text| .
"For Taylor Series, the exponent of the power series variable ranges  from an {\\em initial value}, an arbitrary non-negative integer, to plus infinity; the {\\em step size} is any positive integer.")
    (|text| . "\\blankline ") (|text| . "\\newline ")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| . "Enter the {\\em initial value} of the index (an integer)")
    (|text| . "\\tab{49}") (|bcStrings| (8 "0" |min| I))
    (|text| . "\\newline ")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| . "Enter the {\\em step size} (a positive integer)")
    (|text| . "\\tab{49}") (|bcStrings| (8 "1" |step| PI))
    (|doneButton| "Continue" |bcTaylorSeriesGen|)))
 (|htShowPage|))

\end{chunk}

\defun{bcTaylorSeriesGen}{bcTaylorSeriesGen}
\calls{bcTaylorSeriesGen}{bcSeriesGen}
\begin{chunk}{defun bcTaylorSeriesGen}
(defun |bcTaylorSeriesGen| (htPage)
 (|bcSeriesGen| htPage))

\end{chunk}

\defun{bcSeriesGen}{bcSeriesGen}
\calls{bcSeriesGen}{htpLabelInputString}
\calls{bcSeriesGen}{concat}
\calls{bcSeriesGen}{bcFinish}
\begin{chunk}{defun bcSeriesGen}
(defun |bcSeriesGen| (htPage)
 (let (step min formula index var point varPart minPart)
  (setq step (|htpLabelInputString| htPage '|step|))
  (setq min (|htpLabelInputString| htPage '|min|))
  (setq formula (|htpLabelInputString| htPage '|formula|))
  (setq index (|htpLabelInputString| htPage '|index|))
  (setq var (|htpLabelInputString| htPage '|variable|))
  (setq point (|htpLabelInputString| htPage '|point|))
  (setq varPart (concat var " = " point))
  (setq minPart (concat min ".."))
  (|bcFinish| "series" (concat index " +-> " formula) varPart minPart step)))

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% HyperDoc -> Basic Commands -> Series -> Formula -> Laurent Series
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defun{bcLaurentSeries}{Series - Formula - Laurent Series}
\calls{bcLaurentSeries}{htInitPage}
\calls{bcLaurentSeries}{htMakePage}
\calls{bcLaurentSeries}{htShowPage}
\usesdollar{bcLaurentSeries}{EmptyMode}

\begin{center}
{\bf {\large{Laurent Series Basic Command}}}
\vskip 0.25cm
\includegraphics[scale=0.8]{ps/v5bclaurentseries.eps}
\end{center}

Pressing the {\bf Continue} button will call the function
{\bf bcLaurentSeriesGen} due to this line:
\begin{verbatim}
   (|doneButton| "Continue" |bcLaurentSeriesGen|)
\end{verbatim}
\begin{chunk}{defun bcLaurentSeries}
(defun |bcLaurentSeries| (a b)
 (declare (special |$EmptyMode|) (ignore a b))
 (|htInitPage| "Laurent Series Basic Command" NIL)
 (|htMakePage|
  '((|domainConditions| (|isDomain| EM |$EmptyMode|)
        (|isDomain| EEM (|Expression| |$EmptyMode|))
        (|isDomain| S (|String|)) (|isDomain| I (|Integer|))
        (|isDomain| PI (|PositiveInteger|))
        (|isDomain| SY (|Symbol|)))
    (|text| . "\\newline ")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| . "Enter the formula for the general coefficient of the series")
    (|text| . "\\newline\\tab{2} ")
    (|bcStrings| (55 "(-1)**(n - 1)/(n + 2)" |formula| EM))
    (|text| . "\\vspace{1}\\newline ")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| . "Enter the {\\em index variable} for your formula")
    (|text| . "\\tab{49}") (|bcStrings| (8 |n| |index| SY))
    (|text| . "\\newline ")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| . "Enter the {\\em power series variable}")
    (|text| . "\\tab{49}") (|bcStrings| (8 |x| |variable| SY))
    (|text| . "\\newline ")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| . "Enter the {\\em point} about which you want to expand")
    (|text| . "\\tab{49}") 
    (|bcStrings| (8 0 |point| F))
    (|text| . "\\blankline")
    (|text| . 
"\\newline For Laurent Series, the exponent of the power series variable ranges from an {\\em initial value}, an arbitrary integer value, to plus infinity; the {\\em step size} is any positive integer.")
    (|text| . "\\blankline")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| . "Enter the {\\em initial value} of the index (an integer)")
    (|text| . "\\tab{49}") (|bcStrings| (8 "-1" |min| I))
    (|text| . "\\newline ")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| . "Enter the {\\em step size} (a positive integer)")
    (|text| . "\\tab{49}") (|bcStrings| (8 "1" |step| PI))
    (|doneButton| "Continue" |bcLaurentSeriesGen|)))
 (|htShowPage|))

\end{chunk}

\defun{bcLaurentSeriesGen}{bcLaurentSeriesGen}
\calls{bcLaurentSeriesGen}{bcSeriesGen}
\begin{chunk}{defun bcLaurentSeriesGen}
(defun |bcLaurentSeriesGen| (htPage)
 (|bcSeriesGen| htPage))

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% HyperDoc -> Basic Commands -> Series -> Formula -> Puiseux Series
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defun{bcPuiseuxSeries}{Series - Formula - Puiseux Series}
\calls{bcPuiseuxSeries}{htInitPage}
\calls{bcPuiseuxSeries}{htMakePage}
\calls{bcPuiseuxSeries}{htShowPage}
\usesdollar{bcPuiseuxSeries}{EmptyMode}

\begin{center}
{\bf {\large{Puiseux Series Basic Command}}}
\vskip 0.25cm
\includegraphics[scale=0.75]{ps/v5bcpuiseuxseries.eps}
\end{center}

Pressing the {\bf Continue} button will call the function
{\bf bcPuiseuxSeriesGen} due to this line:
\begin{verbatim}
   (|doneButton| "Continue" |bcPuiseuxSeriesGen|)
\end{verbatim}
\begin{chunk}{defun bcPuiseuxSeries}
(defun |bcPuiseuxSeries| (a b)
 (declare (special |$EmptyMode|) (ignore a b))
 (|htInitPage| "Puiseux Series Basic Command" nil)
 (|htMakePage|
  '((|domainConditions| (|isDomain| EM |$EmptyMode|)
        (|isDomain| EEM (|Expression| |$EmptyMode|))
        (|isDomain| S (|String|)) (|isDomain| I (|Integer|))
        (|isDomain| PI (|PositiveInteger|))
        (|isDOmain| RN (|Fraction| (|Integer|)))
        (|isDomain| SY (|Symbol|)))
    (|text| . "\\newline ")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| . 
      "Enter the {\\em formula} for the general coefficient of the series")
    (|text| . "\\newline\\tab{2} ")
    (|bcStrings| (55 "(-1)**((3*n - 4)/6)/factorial(n - 1/3)" |formula| EM))
    (|text| . "\\vspace{1}\\newline ")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| . "Enter the {\\em index variable} for your formula")
    (|text| . "\\tab{49}") (|bcStrings| (8 |n| |index| SY))
    (|text| . "\\newline ")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| . "Enter the {\\em power series variable}")
    (|text| . "\\tab{49}") (|bcStrings| (8 |x| |variable| SY))
    (|text| . "\\newline ")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| . "Enter the {\\em point} about which you want to expand")
    (|text| . "\\tab{49}") (|bcStrings| (8 0 |point| F))
    (|text| . "\\blankline ")
    (|text| .
"For Puiseux Series, the exponent of the power series variable ranges from an {\\em initial value}, an arbitary rational number, to plus infinity; the {\\em step size} is an any positive rational number.")
    (|text| . "\\blankline ") (|text| . "\\newline ")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| . "Enter the {\\em initial value} of index (a rational number)")
    (|text| . "\\tab{51}") (|bcStrings| (6 "4/3" |min| RN))
    (|text| . "\\newline ")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| . "Enter the {\\em step size} (a positive rational number)")
    (|text| . "\\tab{51}") (|bcStrings| (6 "2" |step| RN))
    (|doneButton| "Continue" |bcPuiseuxSeriesGen|)))
 (|htShowPage|))

\end{chunk}

\defun{bcPuiseuxSeriesGen}{bcPuiseuxSeriesGen}
\calls{bcPuiseuxSeriesGen}{bcSeriesGen}
\begin{chunk}{defun bcPuiseuxSeriesGen}
(defun |bcPuiseuxSeriesGen| (htPage)
 (|bcSeriesGen| htPage))

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% HyperDoc -> Basic Commands -> Solve
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defun{bcSolve}{Solve Basic Command}
\calls{bcSolve}{htInitPage}
\calls{bcSolve}{htMakePage}
\calls{bcSolve}{htShowPage}
\usesdollar{bcSolve}{EmptyMode}

\begin{center}
{\bf {\large{Solve Basic Command}}}
\vskip 0.25cm
\includegraphics[scale=1.0]{ps/v5bcsolve.eps}
\end{center}

\begin{chunk}{defun bcSolve}
(defun |bcSolve| ()
 (|htInitPage| "Solve Basic Command" nil)
 (|htMakePage|
  '((|text| . "What do you want to solve? ")
    (|text| . "\\beginmenu") (|text| . "\\item ")
    (|bcLinks|
      ("\\menuitemstyle{A System Of Linear Equations}" ""
         |bcLinearSolve| |linear|))
    (|text| . "\\item ")
    (|bcLinks|
      ("\\menuitemstyle{A System of Polynomial Equations}" ""
         |bcSystemSolve| |polynomial|))
    (|text| . "\\item ")
    (|bcLinks|
      ("\\menuitemstyle{A Single Polynomial Equation}" ""
         |bcSolveSingle| |onePolynomial|))
     (|text| . "\\endmenu")))
 (|htShowPage|))

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% HyperDoc -> Basic Commands -> Solve -> System of Linear Equations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defun{bcLinearSolve}{Solve - System of Linear Equations}
\calls{bcLinearSolve}{htInitPage}
\calls{bcLinearSolve}{htMakePage}
\calls{bcLinearSolve}{htShowPage}
\usesdollar{bcLinearSolve}{EmptyMode}

\begin{center}
{\bf {\large{Linear Solve Basic Command}}}
\vskip 0.25cm
\includegraphics[scale=1.0]{ps/v5bclinearsolve.eps}
\end{center}

\begin{chunk}{defun bcLinearSolve}
(defun |bcLinearSolve| (p nn)
 (declare (ignore p nn))
 (|htInitPage| "Basic Solve Command" NIL)
 (|htMakePage|
  '((|text| . "How do you want to enter the equations?")
    (|text| . "\\beginmenu") 
    (|text| . "\\item ")
    (|text| . "\\newline ")
    (|bcLinks|
       ("\\menuitemstyle{Directly as equations}" ""
          |bcLinearSolveEqns| |equations|))
    (|text| . "\\item ") 
    (|text| . "\\newline ")
    (|bcLinks|
       ("\\menuitemstyle{In matrix form}" ""
          |bcLinearSolveMatrix| |matrix|))
    (|text| . "\\indentrel{16}\\tab{0}")
    (|text| .
" \\spad{AX = B}, where \\spad{A} is a matrix of coefficients and \\spad{B} is a vector")
    (|text| . "\\indentrel{-16}\\item ") 
    (|text| . "\\endmenu")))
 (|htShowPage|))

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Solve -> System of Linear Equations -> Directly as equations}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defun{bcLinearSolveEqns}{System of Linear Equations - Directly as equations}
\calls{bcLinearSolveEqns}{htInitPage}
\calls{bcLinearSolveEqns}{htMakePage}
\calls{bcLinearSolveEqns}{htMakeDoneButton}
\calls{bcLinearSolveEqns}{htShowPage}
\usesdollar{bcLinearSolveEqns}{EmptyMode}

\begin{center}
{\bf {\large{Linear Solve Equations Basic Command}}}
\vskip 0.25cm
\includegraphics[scale=1.0]{ps/v5bclinearsolveeqns.eps}
\end{center}

Pressing the {\bf Continue} button will call the function
{\bf bcLinearSolveEqns1} due to this line:
\begin{verbatim}
  (|htMakeDoneButton| "Continue" '|bcLinearSolveEqns1|)
\end{verbatim}
\begin{chunk}{defun bcLinearSolveEqns}
(defun |bcLinearSolveEqns| (htPage p)
 (declare (ignore htPage p))
  (|htInitPage| "Basic Solve Command" nil)
  (|htMakePage|
    '((|domainConditions| (|isDomain| PI (|PositiveInteger|)))
      (|inputStrings|
        ("Enter the {\\em number} of equations:" "" 5 2
           |numberOfEquations| PI))))
  (|htMakeDoneButton| "Continue" '|bcLinearSolveEqns1|)
  (|htShowPage|))

\end{chunk}

\defun{bcLinearSolveEqns1}{bcLinearSolveEqns1}
\calls{bcLinearSolveEqns1}{htpSetProperty}
\calls{bcLinearSolveEqns1}{bcInputEquations}
\begin{chunk}{defun bcLinearSolveEqns1}
(defun |bcLinearSolveEqns1| (htPage)
 (|htpSetProperty| htPage '|systemType| '|linear|)
 (|htpSetProperty| htPage '|exitFunction| '|bcLinearSolveEqnsGen|)
 (|bcInputEquations| htPage '|exact|))

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Solve -> System of Linear Equations -> In matrix form
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defun{bcLinearSolveMatrix}{System of Linear Equations - In matrix form}
\calls{bcLinearSolveMatrix}{bcReadMatrix}
This routine is a trampoline. It calls {\bf bcReadMatrix} passing the
name of a call-back routine {\bf bcLinearSolveMatrix1} to be called
after the matrix has been read.
\begin{chunk}{defun bcLinearSolveMatrix}
(defun |bcLinearSolveMatrix| (htPage junk)
 (declare (ignore htPage junk))
 (|bcReadMatrix| '|bcLinearSolveMatrix1|))

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Solve -> System of Linear Equations -> In matrix form direct
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defun{bcReadMatrix}{System of Linear Equations - In matrix form direct}
\calls{bcReadMatrix}{htInitPage}
\calls{bcReadMatrix}{htpSetProperty}
\calls{bcReadMatrix}{htMakePage}
\calls{bcReadMatrix}{htShowPage}

\begin{center}
{\bf {\large{Matrix Basic Command}}}
\vskip 0.25cm
\includegraphics[scale=1.0]{ps/v5bcreadmatrix.eps}
\end{center}

This routine is called from several places to enter a matrix.
The argument {\bf bcReadMatrix} is the name of a function to call
when the matrix has been entered. This value is set as an {\bf exitFunction}
in the page's association table.
\begin{chunk}{defun bcReadMatrix}
(defun |bcReadMatrix| (exitFunctionOrNil)
 (let (page)
  (setq page (|htInitPage| "Matrix Basic Command" nil))
  (|htpSetProperty| page '|exitFunction| exitFunctionOrNil)
  (|htMakePage|
    '((|domainConditions| (|isDomain| PI (|PositiveInteger|)))
      (|text| . "Enter the size of the matrix:")
      (|inputStrings|
                  ("Number of {\\em rows}:\\space{3}" "" 5 2 |rows| PI)
                  ("Number of {\\em columns}: " "" 5 2 |cols| PI))
      (|text| . "\\blankline ")
      (|text| . "How would you like to enter the matrix?")
      (|text| . "\\beginmenu")
      (|text| . "\\item ")
      (|bcLinks|
                  ("\\menuitemstyle{By entering individual entries}" ""
                   |bcInputExplicitMatrix| |explicit|))
      (|text| . "\\item ")
      (|bcLinks|
                  ("\\menuitemstyle{By formula}" ""
                   |bcInputMatrixByFormula| |formula|))
      (|text| . "\\endmenu")))
  (|htShowPage|)))

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Solve -> System of Linear Equations -> In matrix form -> individual
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defun{bcInputExplicitMatrix}{Solve System of Linear Equations Individual}
\calls{bcInputExplicitMatrix}{objValUnwrap}
\calls{bcInputExplicitMatrix}{htpLabelSpadValue}
\calls{bcInputExplicitMatrix}{htpLabelInputString}
\calls{bcInputExplicitMatrix}{parse-integer}
\calls{bcInputExplicitMatrix}{length}
\calls{bcInputExplicitMatrix}{nreverse0}
\calls{bcInputExplicitMatrix}{concat}
\calls{bcInputExplicitMatrix}{htInitPage}
\calls{bcInputExplicitMatrix}{htpPropertyList}
\calls{bcInputExplicitMatrix}{bcHt}
\calls{bcInputExplicitMatrix}{htMakePage}
\calls{bcInputExplicitMatrix}{htMakeDoneButton}
\calls{bcInputExplicitMatrix}{htpSetProperty}
\calls{bcInputExplicitMatrix}{htShowPage}
\usesdollar{bcInputExplicitMatrix}{EmptyMode}
\usesdollar{bcInputExplicitMatrix}{bcParseOnly}

\begin{center}
{\bf {\large{Input Explicit Matrix}}}
\vskip 0.25cm
\includegraphics[scale=1.0]{ps/v5bcinputexplicitmatrix.eps}
\end{center}

Pressing the {\bf Continue} button will call the function
{\bf bcGenExplicitMatrix} due to this line:
\begin{verbatim}
  (|htMakeDoneButton| "Continue" '|bcGenExplicitMatrix|)
\end{verbatim}
\begin{chunk}{defun bcInputExplicitMatrix}
(defun |bcInputExplicitMatrix| (htPage junk)
 (declare (ignore junk))
 (let (nrows ncols cond wrows wcols rowpart colpart prefix k name 
       labelList page t1 t2)
  (declare (special |$EmptyMode| |$bcParseOnly|))
  (setq nrows
    (if (null |$bcParseOnly|)
      (|objValUnwrap| (|htpLabelSpadValue| htPage '|rows|))
      (parse-integer  (|htpLabelInputString| htPage '|rows|))))
  (setq ncols
    (if (null |$bcParseOnly|)
       (|objValUnwrap| (|htpLabelSpadValue| htPage '|cols|))
       (parse-integer  (|htpLabelInputString| htPage '|cols|))))
  (setq k 0)
  (setq wrows (|#| (princ-to-string nrows)))
  (setq wcols (|#| (princ-to-string ncols)))
  (setq labelList
    (do ((i 1 (1+ i))) ((> i nrows) t1)
      (setq t2 nil)
      (setq t1
       (append t1
         (do ((j 1 (1+ j))) ((> j ncols) (nreverse0 t2))
          (setq t2
           (cons
            (progn
             (setq rowpart (concat "{\\em Row" (|htStringPad| i wrows)))
             (setq colpart (concat ", Column" (|htStringPad| j wcols) 
                                    ":}\\space{2}"))
             (setq prefix (concat rowpart colpart))
             (setq name (intern (princ-to-string (setq k (1+ k)))))
             (list prefix "" 30 0 name 'P))
            t2)))))))
  (setq labelList
   (list
     (list '|domainConditions| 
           '(|isDomain| P (|Polynomial| |$EmptyMode|))
            cond)
      (cons '|inputStrings| labelList)))
  (setq page (|htInitPage| "Solve Basic Command" (|htpPropertyList| htPage)))
  (|bcHt| "Enter the entries of the matrix:")
  (|htMakePage| labelList)
  (|htMakeDoneButton| "Continue" '|bcGenExplicitMatrix|)
  (|htpSetProperty| page '|nrows| nrows)
  (|htpSetProperty| page '|ncols| ncols)
  (|htShowPage|)))

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Solve -> System of Linear Equations -> In matrix form -> formula
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defun{Solve - bcInputMatrixByFormula}
{System of Linear Equations In matrix form by formula}
\calls{bcInputMatrixByFormula}{htInitPage}
\calls{bcInputMatrixByFormula}{htMakePage}
\calls{bcInputMatrixByFormula}{htMakeDoneButton}
\calls{bcInputMatrixByFormula}{objValUnwrap}
\calls{bcInputMatrixByFormula}{htpLabelSpadValue}
\calls{bcInputMatrixByFormula}{parse-integer}
\calls{bcInputMatrixByFormula}{htpLabelInputString}
\calls{bcInputMatrixByFormula}{htpSetProperty}
\calls{bcInputMatrixByFormula}{htShowPage}
\usesdollar{bcInputMatrixByFormula}{bcParseOnly}

\begin{center}
{\bf {\large{Input Matrix By Formula}}}
\vskip 0.5cm
\includegraphics[scale=1.0]{ps/v5bcinputmatrixbyformula.eps}
\end{center}

Pressing the {\bf Continue} button will call the function
{\bf bcInputMatrixByFormulaGen} due to this line:
\begin{verbatim}
  (|htMakeDoneButton| "Continue" '|bcInputMatrixByFormulaGen|)
\end{verbatim}
\begin{chunk}{defun bcInputMatrixByFormula}
(defun |bcInputMatrixByFormula| (htPage junk)
 (declare (ignore junk))
 (let (page nrows ncols)
  (declare (special |$bcParseOnly|))
  (setq page (|htInitPage| "Basic Matrix Command" (|htpPropertyList| htPage)))
  (|htMakePage|
    '((|domainConditions| (|isDomain| S (|Symbol|))
                  (|isDomain| FE (|Expression| (|Integer|))))
      (|text| . "\\menuitemstyle{}\\tab{2}")
      (|text| . "Enter the {\\em row variable}: ")
      (|text| . "\\tab{36}") (|bcStrings| (6 |i| |rowVar| S))
      (|text| . "\\blankline ") (|text| . "\\newline ")
      (|text| . "\\menuitemstyle{}\\tab{2}")
      (|text| . "Enter the {\\em column variable}: ")
      (|text| . "\\tab{36}") (|bcStrings| (6 |j| |colVar| S))
      (|text| . "\\blankline ") (|text| . "\\newline ")
      (|text| . "\\menuitemstyle{}\\tab{2}")
      (|text| . "Enter the general {\\em formula} for the entries:")
      (|text| . "\\newline\\tab{2} ")
      (|bcStrings| (40 "1/(x - i - j - 1)" |formula| FE))))
  (|htMakeDoneButton| "Continue" '|bcInputMatrixByFormulaGen|)
  (setq nrows
    (if (null |$bcParseOnly|)
      (|objValUnwrap| (|htpLabelSpadValue| htPage '|rows|))
      (parse-integer  (|htpLabelInputString| htPage '|rows|))))
  (setq ncols
    (if (null |$bcParseOnly|)
      (|objValUnwrap| (|htpLabelSpadValue| htPage '|cols|))
      (parse-integer  (|htpLabelInputString| htPage '|cols|))))
  (|htpSetProperty| page '|nrows| nrows)
  (|htpSetProperty| page '|ncols| ncols)
  (|htShowPage|)))

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% HyperDoc -> Basic Commands -> Solve -> Polynomial Equations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defun{bcSystemSolve}{Solve - System of Polynomial Equations}
\calls{bcSystemSolve}{htInitPage}
\calls{bcSystemSolve}{htMakePage}
\calls{bcSystemSolve}{htMakeDoneButton}
\calls{bcSystemSolve}{htShowPage}

\begin{center}
{\bf {\large{Solve Directly As Equations}}}
\vskip 0.25cm
\includegraphics[scale=1.0]{ps/v5bcsystemsolve.eps}
\end{center}

Pressing the {\bf Continue} button will call the function
{\bf bcSystemSolveEqns1} due to this line:
\begin{verbatim}
   (|htMakeDoneButton| "Continue" '|bcSystemSolveEqns1|)
\end{verbatim}
\begin{chunk}{defun bcSystemSolve}
(defun |bcSystemSolve| (htPage p)
 (declare (ignore htPage p))
 (|htInitPage| "Basic Solve Command" NIL)
 (|htMakePage|
   '((|domainConditions| (|isDomain| PI (|PositiveInteger|)))
     (|inputStrings|
       ("Enter the {\\em number} of equations:" "" 5 2
          |numberOfEquations| PI))))
 (|htMakeDoneButton| "Continue" '|bcSystemSolveEqns1|)
 (|htShowPage|))

\end{chunk}

\defun{bcSystemSolveEqns1}{bcSystemSolveEqns1}
\calls{bcSystemSolveEqns1}{htpSetProperty}
\calls{bcSystemSolveEqns1}{bcInputEquations}
\begin{chunk}{defun bcSystemSolveEqns1}
(defun |bcSystemSolveEqns1| (htPage)
 (|htpSetProperty| htPage '|systemType| '|polynomial|)
 (|htpSetProperty| htPage '|exitFunction| '|bcInputSolveInfo|)
 (|bcInputEquations| htPage '|exact|))

\end{chunk}

\defun{bcInputSolveInfo}{bcInputSolveInfo}
\calls{bcInputSolveInfo}{htInitPage}
\calls{bcInputSolveInfo}{htpPropertyList}
\calls{bcInputSolveInfo}{htpSetProperty}
\calls{bcInputSolveInfo}{htpInputAreaList}
\calls{bcInputSolveInfo}{htMakePage}
\calls{bcInputSolveInfo}{htShowPage}
\begin{chunk}{defun bcInputSolveInfo}
(defun |bcInputSolveInfo| (htPage)
 (let (page)
  (setq page (|htInitPage| "Solve Basic Command" (|htpPropertyList| htPage)))
  (|htpSetProperty| page '|numberOfEquations|
     (|htpProperty| htPage '|numberOfEquations|))
  (|htpSetProperty| page '|inputArea| (|htpInputAreaAlist| htPage))
  (|htMakePage|
    '((|domainConditions| (|isDomain| PI (|PositiveInteger|)))
      (|text| . "What would you like?")
      (|text| . "\\beginmenu") (|text| . "\\item ")
      (|bcLinks|
        ("\\menuitemstyle{Exact Solutions}" "" |bcSolveEquations| |exact|))
      (|text| . "\\indentrel{18}\\tab{0} ")
      (|text| .
     "Solutions expressed in terms of {\\em roots} of irreducible polynomials")
      (|text| . "\\indentrel{-18}")
      (|text| . "\\item ")
      (|bcLinks|
        ("\\menuitemstyle{Numeric Solutions}" ""
           |bcSolveEquationsNumerically| |numeric|))
      (|text| . "\\indentrel{18}\\tab{0} ")
      (|text| .
  "Solutions expressed in terms of approximate real or complex {\\em numbers}")
      (|text| . "\\indentrel{-18}")
      (|text| . "\\item ")
      (|bcLinks|
        ("\\menuitemstyle{Radical Solutions}" "" |bcSolveEquations| |radical|))
      (|text| . "\\indentrel{18}\\tab{0} ")
      (|text| .
          "Solutions expressed in terms of {\\em radicals} if it is possible")
      (|text| . "\\indentrel{-18}")
      (|text| . "\\endmenu")))
  (|htShowPage|)))

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% HyperDoc -> Basic Commands -> Solve -> Single Polynomial Equation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defun{bcSolveSingle}{Solve - Single Polynomial Equation}
\calls{bcSolveSingle}{htpSetProperty}
\calls{bcSolveSingle}{bcInputEquations}
\begin{chunk}{defun bcSolveSingle}
(defun |bcSolveSingle| (htPage p)
 (declare (ignore p))
 (|htpSetProperty| htPage '|systemType| '|onePolynomial|)
 (|htpSetProperty| htPage '|exitFunction| '|bcInputSolveInfo|)
 (|bcInputEquations| htPage '|exact|))

\end{chunk}

\chapter{HyperDoc Reference}
\section{Book}
\section{Topics}
\subsection{Numbers}
{\bf Numbers - Integers}
{\bf Numbers - Fractions}
{\bf Numbers - Machine Floats}
{\bf Numbers - Real Numbers}
{\bf Numbers - Complex Numbers}
{\bf Numbers - Finite Fields}
  {\bf Finite Fields - Modular Arithmetic and Prime Fields}
  {\bf Finite Fields - Extensions of Finite Fields}
    {\bf Extensions - Finite Field}
    {\bf Extensions - FinitFieldCyclicGroup}
    {\bf Extensions - FinitFieldNormalBasis}
    {\bf Extensions - FinitFieldExtension}
    {\bf Extensions - FinitFieldExtensionByPolynomial}
    {\bf Extensions - FinitFieldCyclicGroupExtension}
    {\bf Extensions - FinitFieldCyclicGroupExtensionByPolynomial}
    {\bf Extensions - FinitFieldNormalBasisExtension}
    {\bf Extensions - FinitFieldNormalBasisExtensionByPolynomial}
  {\bf Finite Fields - Irreducible Modulus Polynomial Representations}
  {\bf Finite Fields - Cyclic Group Representations}
  {\bf Finite Fields - Normal Basis Representations}
  {\bf Finite Fields - Conversion Operations for Finite Fields}
  {\bf Finite Fields - Utility Operations for Finite Fields}
{\bf Numbers - Numeric Functions}
{\bf Numbers - Cardinal Numbers}
{\bf Numbers - Machine-size Integers}
{\bf Numbers - Roman Numerals}
{\bf Numbers - Continued Fractions}
{\bf Numbers - Partial Fractions}
{\bf Numbers - Quaternions}
{\bf Numbers - Octonions}
{\bf Numbers - Repeating Decimals}
{\bf Numbers - Repeating Binary Expansions}
{\bf Numbers - Repeating Hexadecimal Expansions}
{\bf Numbers - Expansions in other Bases}
\subsection{Polynomials}
{\bf Polynomials - Basic Functions}
{\bf Polynomials - Substitutions}
{\bf Polynomials - Factorization}
{\bf Polynomials - GCDs and Friends}
{\bf Polynomials - Roots}
{\bf Polynomials - Specific Types}
\subsection{Functions}
{\bf Functions - Rational Functions}
{\bf Functions - Algebraic Equations}
{\bf Functions - Elementary Functions}
{\bf Functions - Special Functions}
{\bf Functions - Unknown Functions}
{\bf Functions - Simplification}
{\bf Functions - Pattern Matching}
{\bf Functions - Operator Algebra}
\subsection{Solving Equations}
{\bf Solving Equations - Systems of Linear Equations}
{\bf Solving Equations - Single Polynomial Equation}
{\bf Solving Equations - Systems of Polynomial Equations}
{\bf Solving Equations - Differential Equations}
\subsection{Calculus}
{\bf Calculus - Limits}
{\bf Calculus - Derivatives}
{\bf Calculus - Integrals}
{\bf Calculus - More Integrals}
{\bf Calculus - Laplace}
{\bf Calculus - Series}
{\bf Calculus - Differential Equations}
\subsection{Linear Algebra}
{\bf Linear Algebra - Introduction}
{\bf Linear Algebra - Creating Matrices}
{\bf Linear Algebra - Operations on Matrices}
{\bf Linear Algebra - Eigenvalues and Eigenvectors}
{\bf Linear Algebra - Example: Determinant of a Hilbert Matrix}
{\bf Linear Algebra - Computing the Permanent}
{\bf Linear Algebra - Working with Vectors}
{\bf Linear Algebra - Working with Square Matrices}
{\bf Linear Algebra - Working with One-Dimensional Arrays}
{\bf Linear Algebra - Working with Two-Dimensional Arrays}
{\bf Linear Algebra - Conversion (Polynomials of Matrices)}
\subsection{Graphics}
{\bf Graphics - Examples}
  {\bf Examples - Assorted Examples}
  {\bf Examples - Three Dimensional Graphics}
  {\bf Examples - Functions of One Variable}
  {\bf Examples - Parametric Curves}
  {\bf Examples - Polar Coordinates}
  {\bf Examples - Implicit Curves}
  {\bf Examples - Lists of Points}
{\bf Graphics - 2D Graphics}
{\bf Graphics - 3D Graphics}
{\bf Graphics - Viewports}
\subsection{Algebra}
{\bf Algebra - Number Theory}
  {\bf Number Theory - Galois Groups}
  {\bf Number Theory - Number Theory Functions}
{\bf Algebra - Group Theory}
  {\bf Group Theory - Info on Group Theory}
  {\bf Group Theory - Info on Representation Theory}
  {\bf Group Theory - Representations of A6}
\section{Language}
\section{Examples}
\section{Commands}
\section{Glossary}
\section{Hyperdoc}
\section{Search}

\chapter{HyperDoc Topics}
\chapter{HyperDoc Browse}
\chapter{HyperDoc Examples}
\chapter{HyperDoc Settings}
\chapter{HyperDoc About}
\chapter{HyperDoc What's New}

\chapter{HyperDoc Support Functions}
\section{Handling page creation and deletion}
\defdollar{activePageList}
\begin{chunk}{initvars}
(defvar |$activePageList| nil) 

\end{chunk}

\defun{htpMakeEmptyPage}{htpMakeEmptyPage}
\usesdollar{htpMakeEmptyPage}{activePageList}
\begin{chunk}{defun htpMakeEmptyPage 0}
(defun |htpMakeEmptyPage| (&rest args)
  (let (name val (propList (car args)) (options (cdr args)))
  (declare (special |$activePageList|))
   (setq name (or (car options) (gentemp)))
   (setq |$activePageList| (cons name |$activePageList|))
   (set name (setq val (vector name nil nil nil nil nil propList nil)))
   val))

\end{chunk}

\defun{htpDestroyPage}{htpDestroyPage}
\calls{htpDestroyPage}{member}
\usesdollar{htpDestroyPage}{activePageList}
\begin{chunk}{defun htpDestroyPage}
(defun |htpDestroyPage| (pageName)
 (declare (special |$activePageList|))
 (when (|member| pageName |$activePageList|)
   (set pageName nil)
   (setq |$activePageList| (delete pageName |$activePageList|))))

\end{chunk}

\section{Handling Axiom command execution}

%\begin{center}
%{\bf {\large{Basic Command}}}
%\vskip 0.25cm
%\includegraphics[scale=1.0]{ps/v5bcbasiccommands.eps}
%\end{center}

The {\tt bcGen} function is called with a string which will be passed
to the Axiom command line. For example, the path 
\begin{verbatim}
  Calculus -> Differentiate -> -> Continue -> Do it
\end{verbatim}
will generate the Axiom command line
\begin{verbatim}
  differentiate(sin(x*y),[x,y],[1,2])
\end{verbatim}

\defun{bcGen}{Basic Command result page}
\calls{bcGen}{concat}
\calls{bcGen}{htInitPage}
\calls{bcGen}{htMakePage}
\calls{bcGen}{htShowPage}
\sig{bcGen}{Command}{nil}
\begin{chunk}{defun bcGen}
(defun |bcGen| (command)
 (let (string)
  (|htInitPage| "Basic Command" nil)
  (setq string
    (if (< (length command) 50)
       (concat "{\\centerline{\\tt " command " }}")
       (concat "{\\tt " command " }")))
  (|htMakePage|
    (list 
     '(|text| 
   "{Here is the Axiom command you could have issued to compute this result:}" 
        "\\vspace{2}\\newline ")
       (cons '|text| string) ))
  (|htMakeDoitButton| "Do It" command)
  (|htShowPage|)))

\end{chunk}

The {\tt htMakeDoitButton} displays the Axiom command to be executed
on a page. Pushing the {\bf "Do it"} invokes {\tt doDoitButton}

\defun{htMakeDoitButton}{htMakeDoitButton}
\sig{doDoitButton}{String,Command}{nil}
\begin{chunk}{defun htMakeDoitButton}
(defun |htMakeDoitButton| (label command)
 (declare (special |$curPage|))
  (cond
   ((equal label "Do It")
    (|bcHt| 
"\\newline\\vspace{1}\\centerline{\\lispcommand{\\DoItBitmap}{(|doDoitButton| "))
    (t
     (|bcHt| 
      (list "\\newline\\vspace{1}\\centerline{\\lispcommand{\\box{" label
         "}}{(|doDoitButton| "))))
  (|bcHt| (|htpName| |$curPage|))
  (|bcHt| (list " \"" (|htEscapeString| command) "\""))
  (|bcHt| ")}}")
  (|bcHt| "\\vspace{2}{Select \\  \\UpButton{} \\  to go back one page.}")
  (|bcHt| 
    "\\newline{Select \\  \\ExitButton{QuitPage} \\  to remove this window.}"))

\end{chunk}

The {\tt doDoitButton} invokes {\tt executeInterpreterCommand}.
Why this intermediate function exists is unclear.

\defun{doDoitButton}{Execute a command from Hyperdoc}
\sig{doDoitButton}{Command}{nil}
\begin{chunk}{defun doDoitButton}
(defun |doDoitButton| (htPage command)
 (declare (ignore htPage))
 (|executeInterpreterCommand| command))

\end{chunk}

The {\tt doDoitButton} function passes a valid Axiom {\tt Command}
(see Volume 13\cite{Book13} for the definition of the ``Command'' type).
This calls the Axiom command line to execute the command.

\defun{executeInterpreterCommand}{Execute a string in the interpreter}
\sig{executeInterpreterCommand}{Command}{nil}
\begin{chunk}{defun executeInterpreterCommand}
(defun |executeInterpreterCommand| (command)
  (princ command)
  (terpri)
  (|setCurrentLine| command)
  (catch 'spad_reader (|parseAndInterpret| command))
  (princ (mkprompt))
  (finish-output))

\end{chunk}

\section{Functions creating pages}
Most of the functions create a new page with a call to the function
{\tt htMakePage}. This function takes an association list which has
several possible keys.
\begin{itemize}
\item {\bf domainConditions} with tests such as (isDomain S (String))
constraining the domains. The possible tests are
\begin{itemize}
\item {\bf isDomain}
\end{itemize}
\item {\bf text} which takes a string argument which may contain latex-like
format strings.
\begin{itemize}
\item a plain string
\item {\bf beginmenu}
\item {\bf blankline}
\item {\bf centerline}
\item {\bf em} with an argument to be emphasized
\item {\bf indent} sets the column 
\item {\bf indentrel} does a relative indent by a positive or negative amount
\item {\bf inputStrings}
\item {\bf item} occurs between a beginmenu and endmenu text 
\item {\bf lispdownlink} takes a string and a function to call
\item {\bf lisplinks}
\item {\bf menuitemstyle} takes a set of characters as an argument
\item {\bf newline}
\item {\bf space} with a numeric argument of the number of spaces
\item {\bf tab} with a numeric argument indicating the tab column
\item {\bf vspace} with the number of blank lines needed
\end{itemize}
\item {\bf bcStrings} which takes a list. The first element is the width
of the input box, the second is the default contents, the third is the
name of the variable to hold the contents, and the fourth is the domains
allowed as input (see {\bf domainConditions above}).
\item {\bf bcLinks} which takes a list containing strings and function calls.
It will link to another page by calling the page generation function for
that page.
\item {\bf doneButton} which takes 2 arguments, a label and a function to call.
\item {\bf radioButtons} takes a button name and set of lists, each one
creating a new radio button
\item {\bf inputStrings}
\item {\bf bcHt}
\end{itemize}

The {\tt htMakeDoneButton} will put a button on the page with the given
title and a function to call when pressed.

\defun{bcInputMatrixByFormulaGen}{Basic Command Matrix by Formula generate}
\calls{bcInputMatrixByFormulaGen}{htpProperty}
\calls{bcInputMatrixByFormulaGen}{htpLabelInputString}
\calls{bcInputMatrixByFormulaGen}{bcGen}
\calls{bcInputMatrixByFormulaGen}{concat}
\begin{chunk}{defun bcInputMatrixByFormulaGen}
(defun |bcInputMatrixByFormulaGen| (htPage)
 (let (fun formula rowVar colVar nrows ncols)
  (cond
   ((setq fun (|htpProperty| htPage '|exitFunction|))
     (funcall fun htPage))
   (t
     (setq formula (|htpLabelInputString| htPage '|formula|))
     (setq rowVar (|htpLabelInputString| htPage '|rowVar|))
     (setq colVar (|htpLabelInputString| htPage '|colVar|))
     (setq nrows (|htpProperty| htPage '|nrows|))
     (setq ncols (|htpProperty| htPage '|ncols|))
     (|bcGen| (concat "matrix([[" formula
                           " for " colVar
                           " in 1.." (princ-to-string ncols)
                           "] for " rowVar
                           " in 1.." (princ-to-string nrows)
                           "])"))))))

\end{chunk}

\defun{bcGenExplicitMatrix}{Basic Command generate explicit matrix}
\calls{bcGenExplicitMatrix}{htpSetProperty}
\calls{bcGenExplicitMatrix}{htpInputAreaAlist}
\calls{bcGenExplicitMatrix}{htpProperty}
\calls{bcGenExplicitMatrix}{bcGen}
\calls{bcGenExplicitMatrix}{bcMatrixGen}
\begin{chunk}{defun bcGenExplicitMatrix}
(defun |bcGenExplicitMatrix| (htPage)
 (let (fun)
  (|htpSetProperty| htPage '|matrix| (|htpInputAreaAlist| htPage))
  (if (setq fun (|htpProperty| htPage '|exitFunction|))
    (funcall fun htPage)
    (|bcGen| (|bcMatrixGen| htPage)))))

\end{chunk}

\defun{bcMatrixGen}{Basic Command generate matrix}
\calls{bcMatrixGen}{htpProperty}
\calls{bcMatrixGen}{lassoc}
\calls{bcMatrixGen}{concat}
\calls{bcMatrixGen}{bcwords2liststring}
\calls{bcMatrixGen}{systemError}
\begin{chunk}{defun bcMatrixGen}
(defun |bcMatrixGen| (htPage)
 (let (nrows ncols formula rowVar colVar mat k matform matstring)
  (setq nrows (|htpProperty| htPage '|nrows|))
  (setq ncols (|htpProperty| htPage '|ncols|))
  (setq mat (|htpProperty| htPage '|matrix|))
  (cond
    ((setq formula (lassoc '|formula| mat))
      (setq formula (elt formula 0))
      (setq rowVar (elt (lassoc '|rowVar| mat) 0))
      (setq colVar (elt (lassoc '|colVar| mat) 0))
      (concat "matrix([[" formula
                         " for " colVar
                         " in 1.." (princ-to-string ncols)
                         "] for " rowVar
                         " in 1.." (princ-to-string nrows)
                         "])"))
    ((setq mat (|htpProperty| htPage '|matrix|))
      (setq mat (reverse mat))
      (setq k (- 1))
      (setq matform
       (loop for i from 0 to (1- nrows)
         collect (loop for j from 0 to (1- ncols)
                   collect (elt (elt mat (incf k)) 1))))
      (setq matstring
       (|bcwords2liststring|
        (loop for t1 in matform collect (|bcwords2liststring| t1))))
      (concat "matrix(" matstring ")"))
    (t (|systemError| nil)))))

\end{chunk}

;--Hypertex commands other than solve and matrix

\defun{bcDrawIt2}{Basic Command iteration}
\calls{bcDrawIt2}{bcMatrixGen}
\begin{chunk}{defun bcDrawIt2}
(defun |bcDrawIt2| (ind a b)
 (concat "{}" ind "=" a "{}.." b "{}"))

\end{chunk}

\defun{bcProduct}{Sum Basic Command}
\calls{bcProduct}{htInitPage}
\calls{bcProduct}{htMakePage}
\calls{bcProduct}{htShowPage}
\usesdollar{bcProduct}{EmptyMode}
%TPDHERE see buglist todo 331
%\begin{minipage}{\textwidth}
% \makebox[\textwidth]
%  {\includegraphics[scale=0.75]{ps/v5bcproduct.eps}}
%\end{minipage}
%Pressing the {\bf Continue} button will call the function
%{\bf bcProductGen} due to this line:
%\begin{verbatim}
%   (|doneButton| "Continue" |bcProductGen|)
%\end{verbatim}
\begin{chunk}{defun bcProduct}
(defun |bcProduct| ()
 (declare (special |$EmptyMode|))
 (|htInitPage| "Product Basic Command" NIL)
 (|htMakePage|
  '((|domainConditions| (|isDomain| EM |$EmptyMode|)
        (|isDomain| S (|String|)) (|isDomain| SY (|Symbol|)))
    (|text| . 
       "Enter the {\\em function} you would like to compute the product of:")
    (|inputStrings| ("" "" 45 "i**2" |mand| EM))
    (|text| . "\\vspace{1}\\newline")
    (|inputStrings|
        ("Enter the {\\em index of the product}:" "" 5 |i| |index| SY))
        (|text| . "\\vspace{1}\\newline Enter the limits of the index:")
        (|inputStrings|
           ("\\newline{\\em From:}" "" 10 "1" |first| EM)
           ("{\\em To:}\\space{2}" "" 10 "n" |last| EM))
    (|doneButton| "Continue" |bcProductGen|)))
 (|htShowPage|))

\end{chunk}

\defun{bcProductGen}{bcProductGen}
\calls{bcProductGen}{htpLabelInputString}
\calls{bcProductGen}{concat}
\calls{bcProductGen}{bcGen}
\begin{chunk}{defun bcProductGen}
(defun |bcProductGen| (htPage)
 (let (mand index car last)
  (setq mand  (|htpLabelInputString| htPage '|mand|))
  (setq index (|htpLabelInputString| htPage '|index|))
  (setq car   (|htpLabelInputString| htPage '|first|))
  (setq last  (|htpLabelInputString| htPage '|last|))
  (|bcGen| (concat "product(" mand "," index "," car "," last ")"))))

\end{chunk}

\defun{bcReadMatrix}{Read Matrix}
\calls{bcReadMatrix}{htInitPage}
\calls{bcReadMatrix}{htpSetProperty}
\calls{bcReadMatrix}{htMakePage}
\calls{bcReadMatrix}{htShowPage}

;--Hypertex commands other than solve and matrix

\defun{bcSeriesByFormulaGen}{bcSeriesByFormulaGen}
\calls{bcSeriesByFormulaGen}{bcNotReady}
\begin{chunk}{defun bcSeriesByFormulaGen}
(defun |bcSeriesByFormulaGen| (htPage) 
 (declare (ignore htPage))
 (|bcNotReady|))

\end{chunk}

\defun{bcRealLimit}{Real Limit Basic Command}
\calls{bcRealLimit}{htInitPage}
\calls{bcRealLimit}{htMakePage}
\calls{bcRealLimit}{htShowPage}
\usesdollar{bcRealLimit}{EmptyMode}

\begin{center}
{\bf {\large{Real Limit Basic Command}}}
\vskip 0.25cm
\includegraphics[scale=1.0]{ps/v5bcreallimit.eps}
\end{center}

Pressing the {\bf Continue} button will call the function
{\bf bcRealLimitGen} due to this line:
\begin{verbatim}
   (|doneButton| "Continue" |bcRealLimitGen|)
\end{verbatim}
\begin{chunk}{defun bcRealLimit}
(defun |bcRealLimit| (a b)
 (declare (special |$EmptyMode|) (ignore a b))
 (|htInitPage| "Real Limit Basic Command" NIL)
 (|htMakePage|
   '((|domainConditions| (|isDomain| EM |$EmptyMode|)
        (|isDomain| S (|String|)) (|isDomain| F (|Float|))
        (|isDomain| SY (|Symbol|)))
    (|text| . "\\newline ")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| . "Enter the {\\em function} you want to compute the limit of:")
    (|text| . "\\newline\\tab{2} ")
    (|bcStrings| (45 "x*sin(1/x)" |expression| EM))
    (|text| . "\\blankline") (|text| . "\\newline ")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| . "Enter the name of the {\\em variable}: ")
    (|text| . "\\tab{41}") 
    (|bcStrings| (6 |x| |variable| SY))
    (|text| . "\\blankline") (|text| . "\\newline ")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| . "Compute the limit at")
    (|radioButtons| |location|
      ("A finite point:"
         ((|text| . "\\tab{33}") (|bcStrings| (6 0 |point| F))) |finitePoint|)
      ("Plus infinity" "" |plusInfinity|)
      ("Minus infinity" "" |minusInfinity|))
    (|doneButton| "Continue" |bcRealLimitGen|)))
 (|htShowPage|))

\end{chunk}

\defun{bcRealLimitGen}{Real Limit Basic Command options}
\calls{bcRealLimitGen}{htpButtonValue}
\calls{bcRealLimitGen}{htpLabelInputString}
\calls{bcRealLimitGen}{bcFinish}
\calls{bcRealLimitGen}{htInitPage}
\calls{bcRealLimitGen}{htMakePage}
\calls{bcRealLimitGen}{htpSetProperty}
\calls{bcRealLimitGen}{htShowPage}

\begin{center}
{\bf {\large{Real Limit Basic Command options}}}
\vskip 0.25cm
\includegraphics[scale=1.0]{ps/v5bcreallimitgen.eps}
\end{center}

\begin{chunk}{defun bcRealLimitGen}
(defun |bcRealLimitGen| (htPage)
 (let (|p| |fun| |var| |loc| |page|)
  (cond
   ((not (eq (setq |p| (|htpButtonValue| htPage '|location|)) '|finitePoint|))
     (setq |fun| (|htpLabelInputString| htPage '|expression|))
     (setq |var| (|htpLabelInputString| htPage '|variable|))
     (setq |loc| 
       (if (eq |p| '|plusInfinity|) "%plusInfinity" "%minusInfinity"))
     (|bcFinish| "limit" |fun| (concat |var| " = " |loc|)))
   (t
     (setq |page| (|htInitPage| "Real Limit Basic Command" nil))
     (|htMakePage|
       '((|text| . "Compute the limit")
         (|lispLinks|
          ("\\menuitemstyle{From both directions}" "" |bcRealLimitGen1| |both|)
          ("\\menuitemstyle{From the right}" "" |bcRealLimitGen1| |right|)
          ("\\menuitemstyle{From the left}" "" |bcRealLimitGen1| |left|))))
     (|htpSetProperty| |page| '|fun|
        (|htpLabelInputString| htPage '|expression|))
     (|htpSetProperty| |page| '|var|
        (|htpLabelInputString| htPage '|variable|))
     (|htpSetProperty| |page| '|loc|
        (|htpLabelInputString| htPage '|point|))
     (|htShowPage|)))))

\end{chunk}

\defun{bcRealLimitGen1}{bcRealLimitGen1}
\calls{bcRealLimitGen1}{htpProperty}
\calls{bcRealLimitGen1}{concat}
\calls{bcRealLimitGen1}{bcFinish}
\begin{chunk}{defun bcRealLimitGen1}
(defun |bcRealLimitGen1| (htPage key)
 (let (direction fun var loc varPart)
  (setq direction
   (cond
    ((eq key '|right|) "\"right\"")
    ((eq key '|left|) "\"left\"")
    (t nil)))
  (setq fun (|htpProperty| htPage '|fun|))
  (setq var (|htpProperty| htPage '|var|))
  (setq loc (|htpProperty| htPage '|loc|))
  (setq varPart (concat var " = " loc))
  (|bcFinish| "limit" fun varPart direction)))

\end{chunk}

\defun{bcComplexLimit}{Complex Limit Basic Command}
\calls{bcComplexLimit}{htInitPage}
\calls{bcComplexLimit}{htMakePage}
\calls{bcComplexLimit}{htShowPage}
\usesdollar{bcComplexLimit}{EmptyMode}

\begin{center}
{\bf {\large{Complex Limit Basic Command}}}
\vskip 0.25cm
\includegraphics[scale=1.0]{ps/v5bccomplexlimit.eps}
\end{center}

Pressing the {\bf Continue} button will call the function
{\bf bcComplexLimitGen} due to this line:
\begin{verbatim}
    (|doneButton| "Continue" |bcComplexLimitGen|)
\end{verbatim}
\begin{chunk}{defun bcComplexLimit}
(defun |bcComplexLimit| (a b)
 (declare (special |$EmptyMode|) (ignore a b))
 (|htInitPage| "Complex Limit Basic Command" nil)
 (|htMakePage|
  '((|domainConditions| (|isDomain| EM |$EmptyMode|)
        (|isDomain| S (|String|)) (|isDomain| F (|Float|))
        (|isDomain| SY (|Symbol|)))
    (|text| . "\\newline ")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| . "Enter the {\\em function} you want to compute the limit of:")
    (|text| . "\\newline\\tab{2} ")
    (|bcStrings| (40 "sin(a*x)/tan(b*x)" |expression| EM))
    (|text| . "\\blankline ") (|text| . "\\newline ")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| . "Enter the name of the {\\em variable}: ")
    (|text| . "\\tab{37}") (|bcStrings| (5 |x| |variable| SY))
    (|text| . "\\blankline ") (|text| . "\\newline ")
    (|text| . "\\menuitemstyle{}\\tab{2}")
    (|text| . "Compute the limit at")
    (|radioButtons| |location|
      ("A finite point:"
         ((|text| . "\\newline\\space{0}Real part:\\space{3}")
          (|bcStrings| (20 0 |real| F))
          (|text| . "\\newline Complex part:")
          (|bcStrings| (20 0 |complex| F)))
         |finitePoint|)
      ("Complex infinity" "" |complexInfinity|))
    (|doneButton| "Continue" |bcComplexLimitGen|)))
 (|htShowPage|))

\end{chunk}

\defun{bcComplexLimitGen}{bcComplexLimitGen}
\calls{bcComplexLimitGen}{htpLabelInputString}
\calls{bcComplexLimitGen}{htpButtonValue}
\calls{bcComplexLimitGen}{concat}
\calls{bcComplexLimitGen}{bcFinish}
\begin{chunk}{defun bcComplexLimitGen}
(defun |bcComplexLimitGen| (htPage)
 (let (fun var p real comp complexPart loc varPart)
  (setq fun (|htpLabelInputString| htPage '|expression|))
  (setq var (|htpLabelInputString| htPage '|variable|))
  (setq loc
   (cond
    ((eq (setq p (|htpButtonValue| htPage '|location|)) '|finitePoint|)
      (setq real (|htpLabelInputString| htPage '|real|))
      (setq comp (|htpLabelInputString| htPage '|complex|))
      (setq complexPart
        (cond
          ((string= comp "0") "")
          ((string= comp "1") "%i")
          (t (concat comp "*%i"))))
      (cond
       ((string= real "0") (if (string= complexPart "") '|0| complexPart))
       ((string= complexPart "") real)
       (t (concat real " + " complexPart))))
    (t "%infinity")))
  (setq varPart (concat var " = " loc))
  (|bcFinish| "complexLimit" fun varPart)))

\end{chunk}

\defdollar{systemType}
\begin{chunk}{initvars}
(setq |$systemType| nil) 

\end{chunk}

\defdollar{numberOfEquations}
\begin{chunk}{initvars}
(defvar |$numberOfEquations| 0) 

\end{chunk}

\defdollar{solutionMethod}
\begin{chunk}{initvars}
(defvar |$solutionMethod| nil) 

\end{chunk}

\defun{bcInputEquations}{bcInputEquations}
\calls{bcInputEquations}{concat}
\calls{bcInputEquations}{bcMakeLinearEquations}
\calls{bcInputEquations}{bcMakeEquations}
\calls{bcInputEquations}{htProperty}
\calls{bcInputEquations}{parse-integer}
\calls{bcInputEquations}{objValUnwrap}
\calls{bcInputEquations}{htInitPage}
\calls{bcInputEquations}{htpPropertyList}
\calls{bcInputEquations}{htpSetProperty}
\calls{bcInputEquations}{htSay}
\calls{bcInputEquations}{htMakePage}
\calls{bcInputEquations}{bcHt}
\calls{bcInputEquations}{bcMakeUnknowns}
\calls{bcInputEquations}{htMakeDoneButton}
\calls{bcInputEquations}{htShowPage}
\usesdollar{bcInputEquations}{EmptyMode}
\usesdollar{bcInputEquations}{bcParseOnly}
\begin{chunk}{defun bcInputEquations}
(defun |bcInputEquations| (htPage solutionMethod)
(labels (
 (f (i n linearp)
  (let (spacer prefix lnam rnam var)
   (setq spacer (cond ((> i 99) 0) ((> i 9) 1) (t 2)))
   (setq prefix
       (concat "\\newline\\tab{2}{\\em Equation " (princ-to-string i) ":}"))
   (setq prefix (concat prefix "\\space{" (princ-to-string spacer) "}"))
   (setq lnam (intern (concat "l" (princ-to-string i))))
   (setq rnam (intern (concat "r" (princ-to-string i))))
   (setq var (if linearp
                  (|bcMakeLinearEquations| i n)
                  (|bcMakeEquations| i n)))
   (cons 
     (cons '|text| prefix)
     (list (list '|bcStrings| (list 30 var lnam 'p))
          '(|text| . " = ")
           (list '|bcStrings| (list 5 '|0| rnam 'p)))))))
 (let (numEqs linearPred labelList equationPart page)
 (declare (special |$EmptyMode| |$bcParseOnly|))
  (setq numEqs
   (cond
    ((eq (|htpProperty| htPage '|systemType|) '|onePolynomial|) 1)
    (|$bcParseOnly| 
      (parse-integer (|htpLabelInputString| htPage '|numberOfEquations|)))
     (t
      (|objValUnwrap| (|htpLabelSpadValue| htPage '|numberOfEquations|)))))
  (setq linearPred (eq (|htpProperty| htPage '|systemType|) '|linear|))
  (setq labelList
   (cond
     ((eql numEqs 1)
      '((|bcStrings| (42 "x^2+1" l1 p)) (|text| . " = ")
         (|bcStrings| (6 0 r1 P))))
     (t
      (loop for i from 1 to numEqs 
       append (f i numEqs linearPred)))))
  (setq equationPart
   (cons '(|domainConditions|
             (|isDomain| P (|Polynomial| |$EmptyMode|))
             (|isDomain| S (|String|))
             (|isDomain| PI (|PositiveInteger|)))
          labelList))
  (setq page (|htInitPage| "Solve Basic Command" (|htpPropertyList| htPage)))
  (|htpSetProperty| page '|numberOfEquations| numEqs)
  (|htpSetProperty| page '|solutionMethod| solutionMethod)
  (|htSay| "\\newline\\menuitemstyle{}\\tab{2}")
  (|htSay| (if (eql numEqs 1)
                "Enter the {\\em Equation}:"
                "Enter the {\\em Equations}:"))
  (|htSay| "\\newline\\tab{2}")
  (|htMakePage| equationPart)
  (|bcHt| "\\blankline ")
  (|htSay| "\\newline\\menuitemstyle{}\\tab{2}")
  (|htMakePage|
    (if (eql numEqs 1)
     '((|text| . "Enter the {\\em unknown} (leave blank if implied): ")
       (|text| . "\\tab{48}")
       (|bcStrings| (6 "x" unknowns S . |quoteString|)))
     (list
      '(|text| . "Enter the unknowns (leave blank if implied):")
      '(|text| . "\\tab{44}")
       (list '|bcStrings| 
                  (list 10 (|bcMakeUnknowns| numEqs) '|unknowns| 'p)))))
  (|htMakeDoneButton| "Continue" '|bcInputEquationsEnd|)
  (|htShowPage|))))

\end{chunk}

\defun{bcCreateVariableString}{Create a variable string}
\begin{chunk}{defun bcCreateVariableString}
(defun |bcCreateVariableString| (i)
  (format nil "x~a" i))

\end{chunk}

\defun{bcMakeUnknowns}{bcMakeUnknowns}
\begin{chunk}{defun bcMakeUnknowns}
(defun |bcMakeUnknowns| (number)
 (format nil "~{~A~^~}" 
   (loop for i from 1 to number collect (format nil "x~a " i))))

\end{chunk}

\defun{bcMakeEquations}{bcMakeEquations}
\calls{bcMakeEquations}{concat}
\calls{bcMakeEquations}{bcCreateVariableString}
\calls{bcMakeEquations}{nreverse0}
\begin{chunk}{defun bcMakeEquations}
(defun |bcMakeEquations| (i number)
 (if (eql number 1)
   (concat (|bcCreateVariableString| 1) '|^2+1|))
   (progn
     (|bcCreateVariableString| i)
     (concat 
      (concat (apply 'concat
       (let (t1)
        (do ((j 1 (1+ j))) ((> j number) (nreverse0 t1))
         (setq t1 (cons (concat (|bcCreateVariableString| j) '+) t1)))))
       '|1|)
      (concat '-2* (concat (|bcCreateVariableString| i) '|^2|)))))

\end{chunk}


\defun{bcMakeLinearEquations}{bcMakeLinearEquations}
\calls{bcMakeLinearEquations}{bcCreateVariableString}
\calls{bcMakeLinearEquations}{concat}
\calls{bcMakeLinearEquations}{nreverse0}
\begin{chunk}{defun bcMakeLinearEquations}
(defun |bcMakeLinearEquations| (i number)
 (cond
  ((eql number 1) (|bcCreateVariableString| 1))
  ((eql number 2)
    (cond
     ((eql i 1)
      (concat (|bcCreateVariableString| 1)
               (concat '+ (|bcCreateVariableString| 2))))
     (t
      (concat (|bcCreateVariableString| 1)
               (concat '- (|bcCreateVariableString| 2))))))
  (t
   (concat
    (concat 
     (apply 'concat
      (let (t1)
       (do ((j 1 (1+ j))) ((> j number) (nreverse0 t1))
        (setq t1 (cons (concat (|bcCreateVariableString| j) '+) t1)))))
     '|1|)
    (concat '-2* (|bcCreateVariableString| i))))))

\end{chunk}

\defun{bcInputEquationsEnd}{bcInputEquationsEnd}
If {\bf exitFunction} is set, call it.
\calls{bcInputEquationsEnd}{systemError}
\begin{chunk}{defun bcInputEquationsEnd}
(defun |bcInputEquationsEnd| (htPage)
 (let (fun)
  (if (setq fun (|htpProperty| htPage '|exitFunction|))
    (funcall fun htPage)
    (|systemError| nil))))

\end{chunk}

\defun{bcSolveEquationsNumerically}{bcSolveEquationsNumerically}
\calls{bcSolveEquationsNumerically}{htInitPage}
\calls{bcSolveEquationsNumerically}{htMakePage}
\calls{bcSolveEquationsNumerically}{htMakeDoneButton}
\calls{bcSolveEquationsNumerically}{htShowPage}
\calls{bcSolveEquationsNumerically}{htpPropertyList}
\begin{chunk}{defun bcSolveEquationsNumerically}
(defun |bcSolveEquationsNumerically| (htPage p)
 (declare (ignore p))
  (|htInitPage| "Solve Basic Command" (|htpPropertyList| htPage))
  (|htMakePage|
   '((|text| . "What would you like?")
     (|radioButtons| |choice|
       ("Real roots expressed as rational numbers" "" |rr|)
       ("Real roots expressed as floats" "" |rf|)
       ("Complex roots expressed as rational numbers" "" |cr|)
       ("Complex roots expressed as floats" "" |cf|))
     (|text| . "\\vspace{1}\\newline")
     (|inputStrings| ("Enter the number of desired {\\em digits} of accuracy"
                   "" 5 20 |acc| PI))))
  (|htMakeDoneButton| "Continue" '|bcSolveNumerically1|)
  (|htShowPage|))

\end{chunk}

\defun{bcSolveNumerically1}{bcSolveNumerically1}
\calls{bcSolveNumerically1}{bcSolveEquations}
\begin{chunk}{defun bcSolveNumerically1}
(defun |bcSolveNumerically1| (htPage)
  (|bcSolveEquations| htPage '|numeric|))

\end{chunk}

\defun{bcSolveEquations}{bcSolveEquations}
\calls{bcSolveEquations}{htpLabelInputString}
\calls{bcSolveEquations}{htpButtonValue}
\calls{bcSolveEquations}{member}
\calls{bcSolveEquations}{concat}
\calls{bcSolveEquations}{htpProperty}
\calls{bcSolveEquations}{bcString2WordList}
\calls{bcSolveEquations}{bcwords2liststring}
\calls{bcSolveEquations}{bcGenEquations}
\calls{bcSolveEquations}{bcFinish}
\begin{chunk}{defun bcSolveEquations}
(defun |bcSolveEquations| (htPage solutionMethod)
 (let (digits kind accString alist varpart r varlist varString eqnString name)
  (when (eq solutionMethod '|numeric|)
    (setq digits (|htpLabelInputString| htPage '|acc|))
    (setq kind   (|htpButtonValue| htPage '|choice|))
    (setq accString
     (if (|member| kind '(|rf| |cf|))
       (concat "1.e-" digits)
       (concat "1/10**" digits))))
  (setq alist   (|htpProperty| htPage '|inputArea|))
  (setq varpart (cadar alist))
  (setq r       (cdr alist))
  (setq varlist (|bcString2WordList| varpart))
  (setq varString
   (if (cdr varlist)
     (|bcwords2liststring| varlist)
     (car varlist)))
  (setq eqnString (|bcGenEquations| r))
  (cond
   ((eq solutionMethod '|numeric|)
     (setq name (if (|member| kind '(|rf| |rr|)) "solve" "complexSolve"))
     (|bcFinish| name eqnString accString))
   (t
     (setq name (if (eq solutionMethod '|radical|) "radicalSolve" "solve"))
     (|bcFinish| name eqnString varString accString)))))

\end{chunk}

\defun{bcLinearSolveMatrix1}{Linear Solve Basic Command options}
\calls{bcLinearSolveMatrix1}{htInitPage}
\calls{bcLinearSolveMatrix1}{htMakePage}
\calls{bcLinearSolveMatrix1}{htShowPage}
\usesdollar{bcLinearSolveMatrix1}{EmptyMode}

\begin{center}
{\bf {\large{Linear Solve Basic Command options}}}
\vskip 0.25cm
\includegraphics[scale=1.0]{ps/v5bclinearsolvematrix1.eps}
\end{center}

\begin{chunk}{defun bcLinearSolveMatrix1}
(defun |bcLinearSolveMatrix1| (htPage)
 (let (page)
  (setq page 
    (|htInitPage| "Linear Solve Basic Command" (|htpPropertyList| htPage)))
  (|htpSetProperty| page '|matrix| (|bcLinearExtractMatrix| htPage))
  (|htMakePage|
   '((|text| . "The right side vector B is:")
     (|lispLinks|
       ("Zero:" "the system is homogeneous" |bcLinearSolveMatrixHomo| |homo|)
       ("Not zero:" "the system is not homogeneous"
                  |bcLinearSolveMatrixInhomo| |nothomo|))))
  (|htShowPage|)))

\end{chunk}

\defun{bcLinearExtractMatrix}{bcLinearExtractMatrix}
\calls{bcLinearExtractMatrix}{htpInputAreaAlist}
\begin{chunk}{defun bcLinearExtractMatrix}
(defun |bcLinearExtractMatrix| (htPage)
  (reverse (|htpInputAreaAlist| htPage)))

\end{chunk}

\defun{bcLinearSolveMatrixInhomo}{Linear Solve Basic Command Inhomogeneous}
\calls{bcLinearSolveMatrixInhomo}{concat}
\calls{bcLinearSolveMatrixInhomo}{htpProperty}
\calls{bcLinearSolveMatrixInhomo}{htInitPage}
\calls{bcLinearSolveMatrixInhomo}{htpPropertyList}
\calls{bcLinearSolveMatrixInhomo}{htpSetProperty}
\calls{bcLinearSolveMatrixInhomo}{htMakePage}
\calls{bcLinearSolveMatrixInhomo}{htShowPage}
\usesdollar{bcLinearSolveMatrixInhomo}{EmptyMode}

\begin{center}
{\bf {\large{Linear Solve Basic Command Inhomogeneous}}}
\vskip 0.25cm
\includegraphics[scale=1.0]{ps/v5bclinearsolvematrixinhomo.eps}
\end{center}

\begin{chunk}{defun bcLinearSolveMatrixInhomo}
(defun |bcLinearSolveMatrixInhomo| (htPage junk)
 (declare (ignore junk))
 (labels (
  (f (i)
   (let (spacer prefix name)
    (setq spacer (cond ((> i 99) 0) ((> i 9) 1) (t 2)))
    (setq prefix (concat "{\\em Coefficient " (princ-to-string i) ":}"))
    (unless (eql spacer 0)
       (setq prefix (concat prefix "\\space{" (princ-to-string spacer) "}")))
    (setq name (intern (concat "c" (princ-to-string i))))
    (list prefix '|| 30 0  name 'p ))))
 (let (nrows ncols labelList page)
 (declare (special |$EmptyMode|))
   (setq nrows (|htpProperty| htPage '|nrows|))
   (setq ncols (|htpProperty| htPage '|ncols|))
   (setq labelList (loop for i from 1 to ncols collect (f i)))
   (setq page
     (|htInitPage| "Linear Solve Basic Command" (|htpPropertyList| htPage)))
   (|htpSetProperty| page '|matrix| (|htpProperty| htPage '|matrix|))
   (|htpSetProperty| page '|nrows| nrows)
   (|htpSetProperty| page '|ncols| ncols)
   (|htMakePage|
     (list
       '(|domainConditions| (|isDomain| P (|Polynomial| |$EmptyMode|)))
       '(|text| . "Enter the right side vector B:")
       (cons 
         (cons '|inputStrings| labelList)
         (list
           '(|text| . "\\vspace{1}\\newline Do you want:")
           '(|lispLinks|
              ("All the solutions?" "" |bcLinearSolveMatrixInhomoGen| |all|)
              ("A particular solution?" ""
                 |bcLinearSolveMatrixInhomoGen| |particular|))
             ))))
   (|htShowPage|))))

\end{chunk}

\defun{bcLinearSolveMatrixInhomoGen}{bcLinearSolveMatrixInhomoGen}
\calls{bcLinearSolveMatrixInhomoGen}{bcLinearMatrixGen}
\begin{chunk}{defun bcLinearSolveMatrixInhomoGen}
(defun |bcLinearSolveMatrixInhomoGen| (htPage key)
  (|bcLinearMatrixGen| htPage key))

\end{chunk}

\defun{bcLinearSolveMatrixHomo}{bcLinearSolveMatrixHomo}
\calls{bcLinearSolveMatrixHomo}{bcLinearMatrixGen}
\begin{chunk}{defun bcLinearSolveMatrixHomo}
(defun |bcLinearSolveMatrixHomo| (htPage key)
 (declare (ignore key))
 (|bcLinearMatrixGen| htPage '|homo|))

\end{chunk}

\defun{bcLinearMatrixGen}{bcLinearMatrixGen}
\calls{bcLinearMatrixGen}{bcMatrixGen}
\calls{bcLinearMatrixGen}{bcFinish}
\calls{bcLinearMatrixGen}{htpInputAreaAlist}
\calls{bcLinearMatrixGen}{bcVectorGen}
\calls{bcLinearMatrixGen}{bcMkFunction}
\calls{bcLinearMatrixGen}{bcGen}
\calls{bcLinearMatrixGen}{concat}
\begin{chunk}{defun bcLinearMatrixGen}
(defun |bcLinearMatrixGen| (htPage key)
 (let (matform vector vecform form)
  (setq matform (|bcMatrixGen| htPage))
   (cond
    ((eq key '|homo|)
      (|bcFinish| "nullSpace" matform))
    (t
     (setq vector
      (loop for x in (reverse (|htpInputAreaAlist| htpage))
        collect (elt x 1)))
     (setq vecform (|bcVectorGen| vector))
     (setq form (|bcMkFunction| "solve" matform (cons vecform nil)))
     (|bcGen| (if (eq key '|particular|) 
                (concat form ".particular")
                form))))))

\end{chunk}

\defun{linearFinalRequest}{linearFinalRequest}
\calls{linearFinalRequest}{sayBrightly}
\calls{linearFinalRequest}{bcQueryInteger}
\calls{linearFinalRequest}{explainLinear}
\begin{chunk}{defun linearFinalRequest}
(defun |linearFinalRequest| (nhh mat vect)
 (declare (ignore mat vect))
 (let (tt)
  (|sayBrightly| "Do you want more information on the meaning of the output")
  (|sayBrightly| "   (1) no ")
  (|sayBrightly| "   (2) yes ")
  (setq tt (|bcQueryInteger| 1 2 t))
  (cond
   ((eql tt 1) (|sayBrightly| "Bye Bye"))
   ((eql tt 2) (|explainLinear| nhh)))))

\end{chunk}

\defun{explainLinear}{explainLinear}
\calls{explainLinear}{systemError}
\begin{chunk}{defun explainLinear}
(defun |explainLinear| (flag)
 (cond
  ((eq flag '|notHomogeneous|)
     '("solve returns a particular solution and a basis for"
       "the vector space of solutions for the homogeneous part."
       "The particular solution is \"failed\" if one cannot be found."))
  ((eq flag '|homogeneous|)
     '("solve returns a basis for"
       "the vector space of solutions for the homogeneous part"))
  (t (|systemError| nil))))

\end{chunk}

\defun{finalExactRequest}{finalExactRequest}
\calls{finalExactRequest}{bcQueryInteger}
\calls{finalExactRequest}{sayBrightly}
\calls{finalExactRequest}{moreExactSolution}
\calls{finalExactRequest}{explainExact}
\begin{chunk}{defun finalExactRequest}
(defun |finalExactRequest| (equations unknowns)
 (let (tt)
  (|sayBrightly| "Do you like:")
  (|sayBrightly| "   (1) the solutions how they are displayed")
  (|sayBrightly| "   (2) to get ????")
  (|sayBrightly| "   (3) more information on the meaning of the output")
  (setq tt (|bcQueryInteger| 1 3 t))
  (cond
    ((eql tt 1) (|sayBrightly| "Bye Bye"))
    ((eql tt 2) (|moreExactSolution| equations unknowns))
    ((eql tt 3) (|explainExact| equations unknowns)))))

\end{chunk}

\defun{bcLinearSolveEqnsGen}{bcLinearSolveEqnsGen}
\calls{bcLinearSolveEqnsGen}{htpInputAreaAlist}
\calls{bcLinearSolveEqnsGen}{htpLabelInputString}
\calls{bcLinearSolveEqnsGen}{bcString2WordList}
\calls{bcLinearSolveEqnsGen}{bcwords2liststring}
\calls{bcLinearSolveEqnsGen}{bcGenEquations}
\calls{bcLinearSolveEqnsGen}{bcFinish}
\begin{chunk}{defun bcLinearSolveEqnsGen}
(defun |bcLinearSolveEqnsGen| (htPage)
 (let (vars varlist varString alist eqnString)
  (setq alist (|htpInputAreaAlist| htPage))
  (when (setq vars (|htpLabelInputString| htPage '|unknowns|))
    (setq varlist (|bcString2WordList| vars))
    (setq varString
      (if (cdr varlist) (|bcwords2liststring| varlist) (car varlist)))
    (setq alist (cdr alist)))
  (setq eqnString (|bcGenEquations| alist))
  (|bcFinish| "solve" eqnString varString)))

\end{chunk}

\defun{bcGenEquations}{bcGenEquations}
\calls{bcGenEquations}{concat}
\calls{bcGenEquations}{bcwords2liststring}
\begin{chunk}{defun bcGenEquations}
(defun |bcGenEquations| (alist)
 (let (right left y eqnlist)
  (setq y alist)
  (loop while y do
    (setq right (elt (car y) 1))
    (setq y (cdr y))
    (setq left (elt (car y) 1))
    (setq y (cdr y))
    (setq eqnlist (cons (concat left " = " right) eqnlist)))
  (if (cdr eqnlist)
    (|bcwords2liststring| eqnlist)
    (car eqnlist))))

\end{chunk}

\defun{bcFinish}{Output the final formula}
\begin{chunk}{defun bcFinish}
(defun |bcFinish| (&rest t1)
  (|bcGen| (|bcMkFunction| (car t1) (cadr t1) (cddr t1))))

\end{chunk}

\defun{bcMkFunction}{convert arguments into function call syntax}
Convert verb|(bcMkFunction "test" "arg1" '("arg2" "arg3"))|
to \verb|"test(arg1,arg2,arg3)"|
\begin{chunk}{defun bcMkFunction}
(defun |bcMkFunction| (name arg args)
 (let (str)
  (setq str
   (let ((result ""))
    (concatenate 'string arg
     (dolist (i args result)
      (when i
       (setq result (concatenate 'string result
                     (concatenate 'string "," i))))))))
  (concatenate 'string name "(" str ")")))

\end{chunk}

\defun{bcString2HyString2}{bcString2HyString2}
\begin{chunk}{defun bcString2HyString2}
(defun |bcString2HyString2| (s)
 (if (and (stringp s) (char= (elt s 0) #\"))
   (concatenate 'string "\\\"" s "\\\"")
   s))

\end{chunk}

\defun{bcString2HyString}{bcString2HyString}
%TPDHERE eliminate this. see buglist todo 334
\begin{chunk}{defun bcString2HyString}
(defun |bcString2HyString| (s) s)

\end{chunk}

\defun{bcFindString}{find a character position in a string}
%TPDHERE eliminate this. see buglist todo 333
\begin{chunk}{defun bcFindString}
(defun |bcFindString| (s i n char)
 (position char s :start i :end n))

\end{chunk}

\defun{bcGen}{Basic Command result page -- NAG version}
\calls{bcGen}{concat}
\calls{bcGen}{htInitPage}
\calls{bcGen}{htMakePage}
\calls{bcGen}{htShowPage}
Except for the banner the {\tt bcGen} and {\tt linkGen} functions are 
identical. We no longer care so we just call {\tt bcGen}. 
\begin{chunk}{defun linkGen}
(defun |linkGen| (command)
 (|bcGen| command))

\end{chunk}

\defun{bcOptional}{bcOptional}
\begin{chunk}{defun bcOptional}
(defun |bcOptional| (s)
 (if (string-equal s "") "2" s))

\end{chunk}

\defun{bcvspace}{create a vertical space on a page}
\calls{bcvspace}{bcHt}
\begin{chunk}{defun bcvspace}
(defun |bcvspace| ()
 (|bcHt| "\\vspace{1}\\newline "))

\end{chunk}

\defun{bcString2WordList}{break a string into words}
\begin{chunk}{defun bcString2WordList}
(defun |bcString2WordList| (string)
  (loop for i = 0 then (1+ j) 
        as j = (position #\space string :start i) 
        collect (subseq string i j) 
        while j))

\end{chunk}

\defun{bcwords2liststring}{format words into a string}
\calls{bcwords2liststring}{concat}
\begin{chunk}{defun bcwords2liststring}
(defun |bcwords2liststring| (words)
 (format nil "[~{~A~^, ~}]" words))

\end{chunk}

\defun{bcVectorGen}{format a vector}
\calls{bcVectorGen}{bcwords2liststring}
\begin{chunk}{defun bcVectorGen}
(defun |bcVectorGen| (vec)
 (|bcwords2liststring| vec))

\end{chunk}

\defun{bcError}{format an error message}
\calls{bcError}{sayBrightlyNT}
\calls{bcError}{sayBrightly}
\begin{chunk}{defun bcError}
(defun |bcError| (string)
  (|sayBrightlyNT| "NOTE: ")
  (|sayBrightly| string))

\end{chunk}

\defun{bcDrawIt}{format intervals}
\calls{bcDrawIt}{concat}
\begin{chunk}{defun bcDrawIt}
(defun |bcDrawIt| (ind a b)
  (concat ind "=" a ".." b))

\end{chunk}

\defun{bcNotReady}{Basic Command page not ready}
\calls{bcNotReady}{htInitPage}
\calls{bcNotReady}{htMakePage}
\calls{bcNotReady}{htShowPage}
\begin{chunk}{defun bcNotReady}
(defun |bcNotReady| (htPage)
 (declare (ignore htPage))
 (|htInitPage| "Basic Command" NIL)
 (|htMakePage|
  '((|text| . "{\\centerline{\\em This facility will soon be available}}")))
 (|htShowPage|))

\end{chunk}

\defun{htStringPad}{pad a string with blanks}
\calls{htStringPad}{concat}
\begin{chunk}{defun htStringPad}
(defun |htStringPad| (n w)
 (let (s ws)
  (setq s (princ-to-string n))
  (setq ws (|#| s))
  (concat "\\space{" (princ-to-string (1+ (- w ws))) "}" s)))

\end{chunk}

\defun{stringList2String}{construct a name string}
Given \verb|("one" "two" "three")| generate \verb|"(one,two,three)"|
\begin{chunk}{defun stringList2String}
(defun |stringList2String| (x)
 (let (str)
 (cond
  ((null x) "()")
  (t
    (setq str
     (let ((result ""))
      (concatenate 'string (car x)
       (dolist (i (cdr x) result)
        (setq result (concatenate 'string result
                       (concatenate 'string "," i)))))))
    (concatenate 'string "(" str ")")))))

\end{chunk}

\defun{htMkName}{construct a name string}
\calls{htMkName}{concat}
\begin{chunk}{defun htMkName}
(defun |htMkName| (s n)
 (concat s (princ-to-string n)))

\end{chunk}

;;; ht-util merge

\defdollar{bcParseOnly}
\begin{chunk}{initvars}
(defvar |$bcParseOnly| t)

\end{chunk}

\defdollar{htLineList}
\begin{chunk}{initvars}
(defvar |$htLineList| nil) 

\end{chunk}

\defdollar{curpage}
\begin{chunk}{initvars}
(defvar |$curPage| nil) 

\end{chunk}

\subsection{HTPage Layout}
\label{HTPage Layout}
This is a list with the fields
\begin{enumerate}
\item name
\item Domain Conditions
\item Domain Variable Alist
\item Domain Pvar Subst List
\item Radio Button Alist
\item Input Area Alist
\item Property List 
\item Description
\end{enumerate}

\defun{htpName}{htpName}
\begin{chunk}{defun htpName}
(defun |htpName| (htPage) (elt htPage 0)) 

\end{chunk}

\defun{htpSetName}{htpSetName}
\begin{chunk}{defun htpSetName}
(defun |htpSetName| (htPage val) (setf (elt htPage 0) val)) 

\end{chunk}

\defun{htpDomainConditions}{htpDomainConditions}
\begin{chunk}{defun htpDomainConditions}
(defun |htpDomainConditions| (htPage) (elt htPage 1)) 

\end{chunk}

\defun{htpSetDomainConditions}{htpSetDomainConditions}
\begin{chunk}{defun htpSetDomainConditions}
(defun |htpSetDomainConditions| (htPage val)
  (setf (elt htPage 1) val))

\end{chunk}

\defun{htpDomainVariableAlist}{htpDomainVariableAlist}
\begin{chunk}{defun htpDomainVariableAlist}
(defun |htpDomainVariableAlist| (htPage) (elt htPage 2)) 

\end{chunk}

\defun{htpSetDomainVariableAlist}{htpSetDomainVariableAlist}
\begin{chunk}{defun htpSetDomainVariableAlist}
(defun |htpSetDomainVariableAlist| (htPage val)
  (setf (elt htPage 2) val))

\end{chunk}

\defun{htpDomainPvarSubstList}{htpDomainPvarSubstList}
\begin{chunk}{defun htpDomainPvarSubstList}
(defun |htpDomainPvarSubstList| (htPage) (elt htPage 3)) 

\end{chunk}

\defun{htpSetDomainPvarSubstList}{htpSetDomainPvarSubstList}
\begin{chunk}{defun htpSetDomainPvarSubstList}
(defun |htpSetDomainPvarSubstList| (htPage val)
  (setf (elt htPage 3) val))

\end{chunk}

\defun{htpRadioButtonAlist}{htpRadioButtonAlist}
\begin{chunk}{defun htpRadioButtonAlist}
(defun |htpRadioButtonAlist| (htPage) (elt htPage 4)) 

\end{chunk}

\defun{htpButtonValue}{htpButtonValue}
\begin{chunk}{defun htpButtonValue}
(defun |htpButtonValue| (htPage groupName)
  (prog ()
    (return
      (SEQ (DO ((G166092
                    (LASSOC groupName
                            (|htpRadioButtonAlist| htPage))
                    (CDR G166092))
                (|buttonName| nil))
               ((OR (ATOM G166092)
                    (progn (setq |buttonName| (car G166092)) nil))
                NIL)
             (SEQ (EXIT (COND
                          ((BOOT-EQUAL
                               (|stripSpaces|
                                   (|htpLabelInputString| htPage
                                    |buttonName|))
                               "t")
                           (EXIT (RETURN |buttonName|)))))))))))

\end{chunk}

\defun{htpSetRadioButtonAlist}{htpSetRadioButtonAlist}
\begin{chunk}{defun htpSetRadioButtonAlist}
(defun |htpSetRadioButtonAlist| (htPage val)
  (setf (elt htPage 4) val))

\end{chunk}

\defun{htpInputAreaAlist}{htpInputAreaAlist}
\begin{chunk}{defun htpInputAreaAlist}
(defun |htpInputAreaAlist| (htPage)
 (elt htPage 5))

\end{chunk}

\defun{htpSetInputAreaAlist}{htpSetInputAreaAlist}
\begin{chunk}{defun htpSetInputAreaAlist}
(defun |htpSetInputAreaAlist| (htPage val)
  (setf (elt htPage 5) val))

\end{chunk}

\defun{htpAddInputAreaProp}{htpAddInputAreaProp}
\begin{chunk}{defun htpAddInputAreaProp}
(defun |htpAddInputAreaProp| (htPage label prop)
  (setf (elt htPage 5)
    (cons 
      (cons label (cons nil (cons nil (cons nil prop))))
      (elt htPage 5))))

\end{chunk}

\defun{htpPropertyList}{htpPropertyList}
\begin{chunk}{defun htpPropertyList}
(defun |htpPropertyList| (htPage)
 (elt htPage 6))

\end{chunk}

\defun{htpProperty}{htpProperty}
\begin{chunk}{defun htpProperty}
(defun |htpProperty| (htPage propName)
  (lassoc propName (elt htPage 6)))
\end{chunk}

\defun{htpSetProperty}{htpSetProperty}
\begin{chunk}{defun htpSetProperty}
(defun |htpSetProperty| (htPage propName val)
 (let (pair)
  (setq pair (|assoc| propName (elt htPage 6)))
  (cond
   (pair (rplacd pair val))
   (t (setf (elt htPage 6) (cons (cons propName val) (elt htPage 6)))))))

\end{chunk}

\defun{htpLabelInputString}{htpLabelInputString}
\begin{chunk}{defun htpLabelInputString}
(defun |htpLabelInputString| (htPage label)
 (let (props s)
  (setq props (lassoc label (|htpInputAreaAlist| htPage)))
  (when (and props (stringp (setq s (elt props 0))))
    (if (equal s "") s (|trimString| s)))))

\end{chunk}

\defun{htpLabelFilteredInputString}{htpLabelFilteredInputString}
\begin{chunk}{defun htpLabelFilteredInputString}
(defun |htpLabelFilteredInputString| (htPage label)
 (let (props)
  (setq props (lassoc label (|htpInputAreaAlist| htPage)))
  (when props
    (cond
     ((and (> (|#| props) 5) (elt props 6))
       (funcall (symbol-function (elt props 6)) (elt props 0)))
     (t (|replacePercentByDollar| (elt props 0)))))))

\end{chunk}

\defun{replacePercentByDollar,fn}{replacePercentByDollar,fn}
\begin{chunk}{defun replacePercentByDollar,fn}
(defun |replacePercentByDollar,fn| (s i n)
 (let (m)
  (cond
   ((> i n) "")
   ((> (setq m (|charPosition| #\% s i)) n) (substring s i nil))
   (t (concat (substring s i (- m i)) "$"
       (|replacePercentByDollar,fn| s (1+ m) n))))))

\end{chunk}

\defun{replacePercentByDollar}{replacePercentByDollar}
\begin{chunk}{defun replacePercentByDollar}
(defun |replacePercentByDollar| (s)
 (|replacePercentByDollar,fn| s 0 (maxindex s)))

\end{chunk}

\defun{htpSetLabelInputString}{htpSetLabelInputString}
\begin{chunk}{defun htpSetLabelInputString}
(defun |htpSetLabelInputString| (htPage label val)
 (let (props)
  (setq props (lassoc label (|htpInputAreaAlist| htPage)))
  (when props (setf (elt props 0) (princ-to-string val)))))

\end{chunk}

\defun{htpLabelSpadValue}{htpLabelSpadValue}
\begin{chunk}{defun htpLabelSpadValue}
(defun |htpLabelSpadValue| (htPage label)
 (let (props)
  (setq props (lassoc label (|htpInputAreaAlist| htPage)))
  (when props (elt props 1))))

\end{chunk}

\defun{htpSetLabelSpadValue}{htpSetLabelSpadValue}
\begin{chunk}{defun htpSetLabelSpadValue}
(defun |htpSetLabelSpadValue| (htPage label val)
 (let (props)
  (setq props (lassoc label (|htpInputAreaAlist| htPage)))
  (when props (setf (elt props 1) val))))

\end{chunk}

\defun{htpLabelErrorMsg}{htpLabelErrorMsg}
\begin{chunk}{defun htpLabelErrorMsg}
(defun |htpLabelErrorMsg| (htPage label)
 (let (props)
  (setq props (lassoc label (|htpInputAreaAlist| htPage)))
  (when props (elt props 2))))

\end{chunk}

\defun{htpSetLabelErrorMsg}{htpSetLabelErrorMsg}
\begin{chunk}{defun htpSetLabelErrorMsg}
(defun |htpSetLabelErrorMsg| (htPage label val)
 (let (props)
  (setq props (lassoc label (|htpInputAreaAlist| htPage)))
  (when props (setf (elt props 2) val))))

\end{chunk}

\defun{htpLabelType}{htpLabelType}
\begin{chunk}{defun htpLabelType}
(defun |htpLabelType| (htPage label)
 (let (props)
  (setq props (lassoc label (|htpInputAreaAlist| htPage)))
  (when props (elt props 3))))

\end{chunk}

\defun{htpLabelDefault}{htpLabelDefault}
\begin{chunk}{defun htpLabelDefault}
(defun |htpLabelDefault| (htPage label)
 (let (msg props)
  (cond
   ((setq msg (|htpLabelInputString| htPage label))
      (cond
       ((equal msg "t") 1)
       ((equal msg "nil") 0)
       (t msg)))
   (t
    (setq props (lassoc label (|htpInputAreaAlist| htPage)))
    (when props (elt props 4))))))

\end{chunk}

\defun{htpLabelSpadType}{htpLabelSpadType}
\begin{chunk}{defun htpLabelSpadType}
(defun |htpLabelSpadType| (htPage label)
 (let (props)
  (setq props (lassoc label (|htpInputAreaAlist| htPage)))
  (when props (elt props 5))))

\end{chunk}

\defun{htpLabelFilter}{htpLabelFilter}
\begin{chunk}{defun htpLabelFilter}
(defun |htpLabelFilter| (htPage label)
 (let (props)
  (setq props (lassoc label (|htpInputAreaAlist| htPage)))
  (when props (elt props 6))))

\end{chunk}

\defun{htpPageDescription}{htpPageDescription}
\begin{chunk}{defun htpPageDescription}
(defun |htpPageDescription| (htPage)
 (elt htPage 7)) 

\end{chunk}

\defun{htpSetPageDescription}{htpSetPageDescription}
\begin{chunk}{defun htpSetPageDescription}
(defun |htpSetPageDescription| (htPage pageDescription)
  (setf (elt htPage 7) pageDescription))

\end{chunk}

\defun{htpAddToPageDescription}{htpAddToPageDescription}
\begin{chunk}{defun htpAddToPageDescription 0}
(defun |htpAddToPageDescription| (htPage pageDescrip)
 (let (newDescript)
  (setq newDescript
   (if (stringp pageDescrip)
    (cons pageDescrip (elt htPage 7))
    (nconc (nreverse (copy-list pageDescrip)) (elt htPage 7))))
  (setf (elt htPage 7) newDescript)))
  
\end{chunk}

\defun{iht}{issue a single hypertex line or group of lines}
\calls{iht}{mapStringize}
\calls{iht}{basicStringize}
\usesdollar{iht}{htLineList}
\usesdollar{iht}{newPage}
\begin{chunk}{defun iht}
(defun |iht| (line)
  (declare (special |$htLineList| |$newPage|))
  (cond
    (|$newPage| nil)
    ((consp line)
     (setq |$htLineList|
       (nconc (nreverse (|mapStringize| (copy-list line))) |$htLineList|)))
    (t
     (setq |$htLineList| (cons (|basicStringize| line) |$htLineList|)))))

\end{chunk}

\defun{bcHt}{bcHt}
\calls{bcHt}{htpAddToPageDescription}
\calls{bcHt}{mapStringize}
\calls{bcHt}{basicStringize}
\usesdollar{bcHt}{newPage}
\usesdollar{bcHt}{htLineList}
\usesdollar{bcHt}{curPage}
\begin{chunk}{defun bcHt}
(defun |bcHt| (line)
 (let (text)
  (declare (special |$newPage| |$htLineList| |$curPage|))
   (cond
     (|$newPage|
      (setq text
       (cond
        ((consp line) (list (cons '|text| line)))
        ((stringp line) line)
        (t (list (cons '|text| (list line))))))
      (|htpAddToPageDescription| |$curPage| text))
     ((consp line)
       (setq |$htLineList|
        (nconc (nreverse (|mapStringize| (copy-list line))) |$htLineList|)))
     (t
      (setq |$htLineList| (cons (|basicStringize| line) |$htLineList|))))))

\end{chunk}

\defun{htSay}{htSay}
\calls{htSay}{bcHt}
\begin{chunk}{defun htSay}
(defun |htSay| (&rest args)
  (|bcHt| (car args))
  (loop for y in (cdr args) do (|bcHt| y)))

\end{chunk}

\defun{bcIssueHt}{bcIssueHt}
\begin{chunk}{defun bcIssueHt}
(defun |bcIssueHt| (line)
  (cond ((consp line) (|htMakePage1| line)) (t (|iht| line))))

\end{chunk}

\defun{mapStringize}{mapStringize}
\calls{mapStringize}{basicStringize}
\calls{mapStringize}{mapStringize}
\begin{chunk}{defun mapStringize}
(defun |mapStringize| (z)
  (cond
    ((atom z) z)
    (t (rplaca z (|basicStringize| (car z)))
       (rplacd z (|mapStringize| (cdr z))) z)))

\end{chunk}

\defun{basicStringize}{basicStringize}
\begin{chunk}{defun basicStringize 0}
(defun |basicStringize| (s)
  (cond
    ((stringp s)
     (cond
       ((equal s "\\$") "\\%")
       ((equal s "{\\em $}") "{\\em \\%}")
       (t s)))
    ((eq s '$) "\\%")
    (t (princ-to-string s))))

\end{chunk}

\defun{stringize}{stringize}
\begin{chunk}{defun stringize 0}
(defun |stringize| (s)
  (if (stringp s) s (princ-to-string s)))

\end{chunk}

\defun{htInitPage}{htInitPage}
This function creates a page with the given title. For example,
a call might be:
\begin{verbatim}
   (|htInitePage| |Differentiate Basic Command| nil)
\end{verbatim}
which creates a blank page with the given title.

\calls{htInitPage}{htInitPageNoScroll}
\calls{htInitPage}{htSayStandard}
\usesdollar{htInitPage}{curPage}
\begin{chunk}{defun htInitPage}
(defun |htInitPage| (title propList)
 (declare (special |$curPage|))
  (|htInitPageNoScroll| propList title)
  (|htSayStandard| "\\beginscroll ")
  |$curPage|)

\end{chunk}

\defun{htInitPageNoScroll}{htInitPageNoScroll}
\calls{htInitPageNoScroll}{htpMakeEmptyPage}
\calls{htInitPageNoScroll}{htpName}
\calls{htInitPageNoScroll}{htSayStandard}
\calls{htInitPageNoScroll}{htSay}
\usesdollar{htInitPageNoScroll}{atLeastOneUnexposed}
\usesdollar{htInitPageNoScroll}{curPage}
\usesdollar{htInitPageNoScroll}{newPage}
\usesdollar{htInitPageNoScroll}{htLineList}
\begin{chunk}{defun htInitPageNoScroll}
(defun |htInitPageNoScroll| (&rest args)
 (let (title (propList (car args)) (options (cdr args)))
 (declare (special |$atLeastOneUnexposed| |$curPage| |$newPage| |$htLineList|))
  ; reset every time a new page is initialized
  (setq |$atLeastOneUnexposed| nil)
  (setq title (car options))
  (setq |$curPage| (|htpMakeEmptyPage| propList))
  (setq |$newPage| t)
  (setq |$htLineList| nil)
  (when title 
    (|htSayStandard| (list "\\begin{page}{" (|htpName| |$curPage|) "}{" ))
    (|htSay| title)
    (|htSayStandard| "} "))
  |$curPage|))

\end{chunk}

\defun{htSayStandard}{htSayStandard}
\calls{htSayStandard}{htSayBind}
\begin{chunk}{defun htSayStandard 0}
(defun |htSayStandard| (&rest args)
 (|htSayBind| (car args) (cdr args)))

\end{chunk}

\defun{htSayBind}{htSayBind}
\calls{htSayBind}{bcHt}
\begin{chunk}{defun htSayBind}
(defun |htSayBind| (x options)
 (|bcHt| x)
 (loop for y in options do (|bcHt| y)))

\end{chunk}

\defun{htAddHeading}{htAddHeading}
\begin{chunk}{defun htAddHeading}
(defun |htAddHeading| (title)
 (declare (special |$curPage|))
 (|htNewPage| title)
 |$curPage|)

\end{chunk}

\defun{htShowPage}{htShowPage}
\begin{chunk}{defun htShowPage}
(defun |htShowPage| ()
  (|htSayStandard| "\\endscroll")
  (|htShowPageNoScroll|))

\end{chunk}

\defun{htShowPageNoScroll}{show the page which has been computed}
Until this point in page processing the page has been represented
by a list of pages elements in reverse order. This function reverses 
the list so they appear in page display order.
\begin{chunk}{defun htShowPageNoScroll}
(defun |htShowPageNoScroll| ()
 (let (line)
 (declare (special |$htLineList| |$curPage| |$newPage|))
   (|htSayStandard| "\\autobuttons")
   (|htpSetPageDescription| |$curPage|
     (nreverse (|htpPageDescription| |$curPage|)))
   (setq |$newPage| nil)
   (setq |$htLineList| nil)
   (|htMakePage| (|htpPageDescription| |$curPage|))
   (setq line (apply #'concat (nreverse |$htLineList|)))
   (|issueHT| line)
   (|endHTPage|)))

\end{chunk}

\defun{htMakePage}{make a page given the description in itemList}
\begin{chunk}{defun htMakePage}
(defun |htMakePage| (itemList)
  (declare (special |$curPage| |$newPage|))
  (progn
    (cond
      (|$newPage| (|htpAddToPageDescription| |$curPage| itemList)))
    (|htMakePage1| itemList)))

\end{chunk}

\defun{htMakePage1}{htMakePage1}
Make a page given the description in itemList
\begin{chunk}{defun htMakePage1}
(defun |htMakePage1| (itemList)
 (let (itemType items)
  (loop for u in itemList do
   (setq itemType '|text|)
   (setq items
    (cond
     ((stringp u) u)
     ((atom u) (princ-to-string u))
     ((stringp (car u)) u)
     ((and (consp u) (eq (car u) '|text|)) (cdr u))
     (t 
      (setq itemType (car u)) ; look up the tag for the next description
      (cdr u))))
   (cond
    ((eq itemType '|text|) (|iht| items))
    ((eq itemType '|lispLinks|) (|htLispLinks| items))
    ((eq itemType '|lispmemoLinks|) (|htLispMemoLinks| items))
    ((eq itemType '|bcLinks|) (|htBcLinks| items))
    ((eq itemType '|bcLinksNS|) (|htBcLinks| items t))
    ((eq itemType '|bcLispLinks|) (|htBcLispLinks| items))
    ((eq itemType '|radioButtons|) (|htRadioButtons| items))
    ((eq itemType '|bcRadioButtons|) (|htBcRadioButtons| items))
    ((eq itemType '|inputStrings|) (|htInputStrings| items))
    ((eq itemType '|domainConditions|) (|htProcessDomainConditions| items))
    ((eq itemType '|bcStrings|) (|htProcessBcStrings| items))
    ((eq itemType '|toggleButtons|) (|htProcessToggleButtons| items))
    ((eq itemType '|bcButtons|) (|htProcessBcButtons| items))
    ((eq itemType '|doneButton|) (|htProcessDoneButton| items))
    ((eq itemType '|doitButton|) (|htProcessDoitButton| items))
    (t (|systemError| (list "unknown itemType" itemType)))))))

\end{chunk}

\defun{htMakeErrorPage}{htMakeErrorPage}
\begin{chunk}{defun htMakeErrorPage}
(defun |htMakeErrorPage| (htPage)
  (prog (line)
  (declare (special |$curPage| |$htLineList| |$newPage|))
    (return
      (progn
        (setq |$newPage| nil)
        (setq |$htLineList| nil)
        (setq |$curPage| htPage)
        (|htMakePage| (|htpPageDescription| htPage))
        (setq line (apply #'CONCAT (NREVERSE |$htLineList|)))
        (|issueHT| line)
        (|endHTPage|)))))

\end{chunk}

\defun{htQuote}{htQuote}
\begin{chunk}{defun htQuote}
(defun |htQuote| (s)
  (|iht| "\"")
  (|iht| s)
  (|iht| "\""))

\end{chunk}

\defun{htProcessToggleButtons}{htProcessToggleButtons}
\begin{chunk}{defun htProcessToggleButtons}
(defun |htProcessToggleButtons| (buttons)
  (prog (message info defaultValue buttonName)
  (declare (special |$curPage|))
    (return
      (SEQ (progn
             (|iht| "\\newline\\indent{5}\\beginitems ")
             (DO ((G166302 buttons (CDR G166302))
                  (G166286 nil))
                 ((OR (ATOM G166302)
                      (progn (setq G166286 (car G166302)) nil)
                      (progn
                        (progn
                          (setq message (car G166286))
                          (setq info (CADR G166286))
                          (setq defaultValue (CADDR G166286))
                          (setq buttonName (CADDDR G166286))
                          G166286)
                        nil))
                  nil)
               (SEQ (EXIT (progn
                            (cond
                              ((NULL (LASSOC buttonName
                                      (|htpInputAreaAlist| |$curPage|)))
                               (|setUpDefault| buttonName
                                   (cons '|button|
                                    (cons defaultValue nil)))))
                            (|iht| (cons
                                      "\\item{\\em\\inputbox["
                                    (cons
                                     (|htpLabelDefault| |$curPage|
                                      buttonName)
                                     (cons "]{"
                                      (cons buttonName
                                       (cons
                           "}{\\htbmfile{pick}}{\\htbmfile{unpick}}\\space{}"
                                        nil))))))
                            (|bcIssueHt| message)
                            (|iht| "\\space{}}")
                            (|bcIssueHt| info)))))
             (|iht| "\\enditems\\indent{0} "))))))

\end{chunk}

\defun{htProcessBcButtons}{htProcessBcButtons}
\begin{chunk}{defun htProcessBcButtons}
(defun |htProcessBcButtons| (buttons)
  (prog (defaultValue buttonName k)
  (declare (special |$curPage|))
    (return
      (SEQ (DO ((G166328 buttons (CDR G166328)) (G166317 nil))
               ((OR (ATOM G166328)
                    (progn (setq G166317 (car G166328)) nil)
                    (progn
                      (progn
                        (setq defaultValue (car G166317))
                        (setq buttonName (CADR G166317))
                        G166317)
                      nil))
                nil)
             (SEQ (EXIT (progn
                          (cond
                            ((NULL (LASSOC buttonName
                                    (|htpInputAreaAlist| |$curPage|)))
                             (|setUpDefault| buttonName
                                 (cons '|button|
                                       (cons defaultValue nil)))))
                          (setq k
                                   (|htpLabelDefault| |$curPage|
                                    buttonName))
                          (cond
                            ((EQL k 0)
                             (|iht| (cons "\\off{"
                                     (cons buttonName
                                      (cons "}" nil)))))
                            ((EQL k 1)
                             (|iht| (cons "\\on{"
                                     (cons buttonName
                                      (cons "}" nil)))))
                            (t
                             (|iht| (cons "\\inputbox["
                                     (cons
                                      (|htpLabelDefault| |$curPage|
                                       buttonName)
                                      (cons "]{"
                                       (cons buttonName
                                        (cons
                                     "}{\\htbmfile{pick}}{\\htbmfile{unpick}}"
                                         nil))))))))))))))))

\end{chunk}

\defun{htProcessBcStrings}{htProcessBcStrings}
\begin{chunk}{defun htProcessBcStrings}
(defun |htProcessBcStrings| (strings)
  (PROG (numChars default stringName spadType filter mess2)
  (declare (special |$curPage|))
    (return
      (SEQ (DO ((g2 strings (CDR g2)) (G166343 nil))
               ((or (atom g2)
                    (progn (setq G166343 (CAR g2)) nil)
                    (progn
                      (progn
                        (setq numChars (car G166343))
                        (setq default (cadr G166343))
                        (setq stringName (caddr G166343))
                        (setq spadType (cadddr G166343))
                        (setq filter (cddddr G166343))
                        G166343)
                      nil))
                nil)
             (SEQ (EXIT (progn
                          (setq mess2 "")
                          (cond
                            ((null (LASSOC stringName
                                    (|htpInputAreaAlist| |$curPage|)))
                             (|setUpDefault| stringName
                                 (cons '|string|
                                       (cons default
                                        (cons spadType
                                         (cons filter nil)))))))
                          (cond
                            ((|htpLabelErrorMsg| |$curPage|
                                 stringName)
                             (|iht| (cons
                                     "\\centerline{{\\em "
                                     (cons
                                      (|htpLabelErrorMsg| |$curPage|
                                       stringName)
                                      (cons "}}" nil))))
                             (setq mess2
                                      (concat mess2 (|bcSadFaces|)))
                             (|htpSetLabelErrorMsg| |$curPage|
                                 stringName nil)))
                          (|iht| (cons "\\inputstring{"
                                       (cons stringName
                                        (cons "}{"
                                         (cons numChars
                                          (cons "}{"
                                           (cons
                                            (|htpLabelDefault|
                                             |$curPage| stringName)
                                            (cons "} "
                                             (cons mess2 nil)))))))))))))))))

\end{chunk}

\defun{bcSadFaces}{bcSadFaces}
\begin{chunk}{defun bcSadFaces}
(defun |bcSadFaces| ()
        "\\space{1}{\\em\\htbitmap{error}\\htbitmap{error}\\htbitmap{error}}")

\end{chunk}

\defun{htLispLinks}{htLispLinks}
\begin{chunk}{defun htLispLinks}
(defun |htLispLinks| (&REST G166422 &AUX option links)
  (setq links (car G166422))
  (setq option (cdr G166422))
  (prog (t1 options indent message info func value call)
    (return
      (SEQ (progn
             (setq t1 (|beforeAfter| '|options| links))
             (setq links (car t1))
             (setq options (cadr t1))
             (setq indent (or (LASSOC '|indent| options) 5))
             (|iht| "\\newline\\indent{")
             (|iht| (|stringize| indent))
             (|iht| "}\\beginitems")
             (DO ((G166403 links (CDR G166403)) (G166387 nil))
                 ((or (atom G166403)
                      (progn (setq G166387 (car G166403)) nil)
                      (progn
                        (progn
                          (setq message (car G166387))
                          (setq info (cadr G166387))
                          (setq func (caddr G166387))
                          (setq value (cdddr G166387))
                          G166387)
                        nil))
                  nil)
               (SEQ (EXIT (progn
                            (|iht| "\\item[")
                            (setq call
                                     (cond
                                       ((IFCAR option)
                                        "\\lispmemolink")
                                       (t
                                        "\\lispdownlink")))
                            (|htMakeButton| call message
                                (|mkCurryFun| func value))
                            (|iht| (cons "]\\space{}" nil))
                            (|bcIssueHt| info)))))
             (|iht| "\\enditems\\indent{0} "))))))

\end{chunk}

\defun{htLispMemoLinks}{htLispMemoLinks}
\begin{chunk}{defun htLispMemoLinks}
(defun |htLispMemoLinks| (links) (|htLispLinks| links t))

\end{chunk}

\defun{htBcLinks}{htBcLinks}
\begin{chunk}{defun htBcLinks}
(defun |htBcLinks| (&rest a1)
 (let (skipStateInfo? t1 message info func value options links)
   (setq links (car a1))
   (setq options (cdr a1))
   (setq skipStateInfo? (ifcar options))
   (setq t1 (|beforeAfter| '|options| links))
   (setq links (car t1))
   (setq options (cadr t1))
   (do ((g1 links (CDR g1)) (g2 nil))
        ((or (atom g1)
             (progn (setq g2 (car g1)) nil)
             (progn
               (progn
                 (setq message (car g2))
                 (setq info (cadr g2))
                 (setq func (caddr g2))
                 (setq value (cdddr g2))
                 g2)
                nil))
            nil)
       (|htMakeButton| "\\lispdownlink" message
          (|mkCurryFun| func value)  skipStateInfo?)
       (|bcIssueHt| info))))

\end{chunk}

\defun{htBcLispLinks}{htBcLispLinks}
\begin{chunk}{defun htBcLispLinks}
(defun |htBcLispLinks| (links)
  (prog (t1 options message info func value)
    (return
      (SEQ (progn
             (setq t1 (|beforeAfter| '|options| links))
             (setq links (car t1))
             (setq options (cadr t1))
             (DO ((G166487 links (cdr G166487)) (G166474 nil))
                 ((or (atom G166487)
                      (progn (setq G166474 (car G166487)) nil)
                      (progn
                        (progn
                          (setq message (car G166474))
                          (setq info (cadr G166474))
                          (setq func (caddr G166474))
                          (setq value (cdddr G166474))
                          G166474)
                        nil))
                  nil)
               (SEQ (EXIT (progn
                            (|htMakeButton| "\\lisplink"
                                message
                                (|mkCurryFun| func value))
                            (|bcIssueHt| info))))))))))

\end{chunk}

\defun{beforeAfter}{beforeAfter}
\begin{chunk}{defun beforeAfter}
(defun |beforeAfter| (x u)
  (prog (y r)
    (return
      (SEQ (cons (prog (G166514)
                   (setq G166514 nil)
                   (return
                     (DO ((G166504 u (CDR G166504)))
                         ((or (atom G166504)
                              (progn
                                (progn
                                  (setq y (car G166504))
                                  (setq r (cdr G166504))
                                  G166504)
                                nil)
                              (null (NEQUAL x y)))
                          (NREVERSE0 G166514))
                       (SEQ (EXIT (setq G166514 (cons y G166514)))))))
                 (cons r nil))))))

\end{chunk}

\defun{mkCurryFun}{mkCurryFun}
\begin{chunk}{defun mkCurryFun}
(defun |mkCurryFun| (fun val)
  (prog (name code)
    (return
      (progn
        (setq name (gentemp))
        (setq code
                 (cons 'defun
                       (cons name
                             (cons '(arg)
                                   (cons
                                    (cons 'apply
                                     (cons (mkq fun)
                                      (cons
                                       (cons 'cons
                                        (cons 'arg
                                         (cons (mkq val) nil)))
                                       nil)))
                                    nil)))))
        (eval code)
        name))))

\end{chunk}

\defun{htRadioButtons}{htRadioButtons}
\begin{chunk}{defun htRadioButtons}
(defun |htRadioButtons| (G166546)
  (prog (groupName buttons boxesName message info buttonName defaultValue)
  (declare (special |$curPage|))
    (return
      (SEQ (progn
             (setq groupName (car G166546))
             (setq buttons (cdr G166546))
             (|htpSetRadioButtonAlist| |$curPage|
                 (cons (cons groupName (|buttonNames| buttons))
                       (|htpRadioButtonAlist| |$curPage|)))
             (setq boxesName (gentemp))
             (|iht| (cons "\\newline\\indent{5}\\radioboxes{"
                     (cons boxesName
                      (cons
                        "}{\\htbmfile{pick}}{\\htbmfile{unpick}}\\beginitems "
                                      nil))))
             (setq defaultValue "1")
             (DO ((G166568 buttons (cdr G166568))
                  (G166540 nil))
                 ((or (atom G166568)
                      (progn (setq G166540 (car G166568)) nil)
                      (progn
                        (progn
                          (setq message (car G166540))
                          (setq info (cadr G166540))
                          (setq buttonName (caddr G166540))
                          G166540)
                        nil))
                  nil)
               (SEQ (EXIT (progn
                            (cond
                              ((null (LASSOC buttonName
                                      (|htpInputAreaAlist| |$curPage|)))
                               (|setUpDefault| buttonName
                                   (cons '|button|
                                    (cons defaultValue nil)))
                               (setq defaultValue
                                        "0")))
                            (|iht| (cons "\\item{\\em\\radiobox["
                                    (cons
                                     (|htpLabelDefault| |$curPage|
                                      buttonName)
                                     (cons "]{"
                                      (cons buttonName
                                       (cons "}{"
                                        (cons boxesName
                                         (cons
                                          "}\\space{}"
                                          nil))))))))
                            (|bcIssueHt| message)
                            (|iht| "\\space{}}")
                            (|bcIssueHt| info)))))
             (|iht| "\\enditems\\indent{0} "))))))

\end{chunk}

\defun{htBcRadioButtons}{htBcRadioButtons}
\begin{chunk}{defun htBcRadioButtons}
(defun |htBcRadioButtons| (G166594)
  (prog (groupName buttons boxesName message info buttonName defaultValue)
  (declare (special |$curPage|))
    (return
      (SEQ (progn
             (setq groupName (car G166594))
             (setq buttons (cdr G166594))
             (|htpSetRadioButtonAlist| |$curPage|
                 (cons (cons groupName (|buttonNames| buttons))
                       (|htpRadioButtonAlist| |$curPage|)))
             (setq boxesName (gentemp))
             (|iht| (cons "\\radioboxes{"
                     (cons boxesName
                      (cons "}{\\htbmfile{pick}}{\\htbmfile{unpick}} "
                                      nil))))
             (setq defaultValue "1")
             (DO ((G166616 buttons (cdr G166616))
                  (G166588 nil))
                 ((or (atom G166616)
                      (progn (setq G166588 (car G166616)) nil)
                      (progn
                        (progn
                          (setq message (car G166588))
                          (setq info (cadr G166588))
                          (setq buttonName (caddr G166588))
                          G166588)
                        nil))
                  nil)
               (SEQ (EXIT (progn
                            (cond
                              ((null (LASSOC buttonName
                                      (|htpInputAreaAlist| |$curPage|)))
                               (|setUpDefault| buttonName
                                   (cons '|button|
                                    (cons defaultValue nil)))
                               (setq defaultValue
                                        "0")))
                            (|iht| (cons
                                    "{\\em\\radiobox["
                                    (cons
                                     (|htpLabelDefault| |$curPage|
                                      buttonName)
                                     (cons "]{"
                                      (cons buttonName
                                       (cons "}{"
                                        (cons boxesName
                                         (cons "}" nil))))))))
                            (|bcIssueHt| message)
                            (|iht| "\\space{}}")
                            (|bcIssueHt| info))))))))))

\end{chunk}

\defun{setUpDefault}{setUpDefault}
\begin{chunk}{defun setUpDefault}
(defun |setUpDefault| (name props)
  (declare (special |$curPage|))
  (|htpAddInputAreaProp| |$curPage| name props))

\end{chunk}

\defun{buttonNames}{buttonNames}
\begin{chunk}{defun buttonNames}
(defun |buttonNames| (buttons)
  (prog (buttonName)
    (return
      (SEQ (prog (G166645)
             (setq G166645 nil)
             (return
               (DO ((G166651 buttons (cdr G166651))
                    (G166637 nil))
                   ((or (atom G166651)
                        (progn (setq G166637 (car G166651)) nil)
                        (progn
                          (progn
                            (setq buttonName (caddr G166637))
                            G166637)
                          nil))
                    (NREVERSE0 G166645))
                 (SEQ (EXIT (setq G166645
                                  (cons buttonName G166645)))))))))))

\end{chunk}

\defun{htInputStrings}{htInputStrings}
\begin{chunk}{defun htInputStrings}
(defun |htInputStrings| (strings)
  (prog (mess1 numChars default stringName spadType filter mess2)
  (declare (special |$curPage|))
    (return
      (SEQ (progn
             (|iht| "\\newline\\indent{5}\\beginitems ")
             (DO ((G166685 strings (cdr G166685))
                  (G166665 nil))
                 ((or (atom G166685)
                      (progn (setq G166665 (car G166685)) nil)
                      (progn
                        (progn
                          (setq mess1 (car G166665))
                          (setq mess2 (cadr G166665))
                          (setq numChars (caddr G166665))
                          (setq default (cadddr G166665))
                          (setq stringName
                                   (car (cddddr G166665)))
                          (setq spadType
                                   (cadr (cddddr G166665)))
                          (setq filter (cddr (cddddr G166665)))
                          G166665)
                        nil))
                  nil)
               (SEQ (EXIT (progn
                            (cond
                              ((null (LASSOC stringName
                                      (|htpInputAreaAlist| |$curPage|)))
                               (|setUpDefault| stringName
                                   (cons '|string|
                                    (cons default
                                     (cons spadType
                                      (cons filter nil)))))))
                            (cond
                              ((|htpLabelErrorMsg| |$curPage|
                                   stringName)
                               (|iht| (cons "\\centerline{{\\em "
                                       (cons
                                        (|htpLabelErrorMsg| |$curPage|
                                         stringName)
                                        (cons "}}" nil))))
                               (setq mess2
                                        (CONCAT mess2 (|bcSadFaces|)))
                               (|htpSetLabelErrorMsg| |$curPage|
                                   stringName nil)))
                            (|iht| "\\item ")
                            (|bcIssueHt| mess1)
                            (|iht| (cons "\\inputstring{"
                                    (cons stringName
                                     (cons "}{"
                                      (cons numChars
                                       (cons "}{"
                                        (cons
                                         (|htpLabelDefault| |$curPage|
                                          stringName)
                                         (cons "} " nil))))))))
                            (|bcIssueHt| mess2)))))
             (|iht| "\\enditems\\indent{0}\\newline "))))))

\end{chunk}

\defun{htProcessDomainConditions}{htProcessDomainConditions}
\begin{chunk}{defun htProcessDomainConditions}
(defun |htProcessDomainConditions| (condList)
 (declare (special |$curPage|))
  (|htpSetDomainConditions| |$curPage| (|renamePatternVariables| condList))
  (|htpSetDomainVariableAlist| |$curPage| (|computeDomainVariableAlist|)))

\end{chunk}

\defun{renamePatternVariables}{renamePatternVariables}
\begin{chunk}{defun renamePatternVariables}
(defun |renamePatternVariables| (condList)
  (declare (special |$curPage| |$PatternVariableList|))
  (progn
    (|htpSetDomainPvarSubstList| |$curPage|
        (|renamePatternVariables1| condList nil
            |$PatternVariableList|))
    (|substFromAlist| condList (|htpDomainPvarSubstList| |$curPage|))))

\end{chunk}

\defun{renamePatternVariables1}{renamePatternVariables1}
\begin{chunk}{defun renamePatternVariables1}
(defun |renamePatternVariables1| (condList substList patVars)
  (prog (restConds pattern t2 pv t3 cond nsubst)
  (declare (special |$EmptyMode|))
    (return
      (cond
        ((null condList) substList)
        (t (setq cond (car condList))
         (setq restConds (cdr condList))
         (cond
           ((or (and (consp cond) (eq (qcar cond) '|isDomain|)
                     (progn
                       (setq t2 (qcdr cond))
                       (and (consp t2)
                            (progn
                              (setq pv (qcar t2))
                              (setq t3 (qcdr t2))
                              (and (consp t3)
                                   (eq (qcdr t3) nil)
                                   (progn
                                     (setq pattern
                                      (qcar t3))
                                     t))))))
                (and (consp cond) (eq (qcar cond) '|ofCategory|)
                     (progn
                       (setq t2 (qcdr cond))
                       (and (consp t2)
                            (progn
                              (setq pv (qcar t2))
                              (setq t3 (qcdr t2))
                              (and (consp t3)
                                   (eq (qcdr t3) nil)
                                   (progn
                                     (setq pattern
                                      (qcar t3))
                                     t))))))
                (and (consp cond) (eq (qcar cond) '|Satisfies|)
                     (progn
                       (setq t2 (qcdr cond))
                       (and (consp t2)
                            (progn
                              (setq pv (qcar t2))
                              (setq t3 (qcdr t2))
                              (and (consp t3)
                                   (eq (qcdr t3) nil)
                                   (progn
                                     (setq cond (qcar t3))
                                     t)))))))
            (cond
              ((equal pv |$EmptyMode|)
               (setq nsubst substList))
              (t
               (setq nsubst
                        (cons (cons pv (car patVars)) substList))))
            (|renamePatternVariables1| restConds nsubst
                (cdr patVars)))
           (t substList)))))))

\end{chunk}

\defun{substFromAlist}{substFromAlist}
\begin{chunk}{defun substFromAlist}
(defun |substFromAlist| (z substAlist)
  (prog (pvar replace)
    (return
      (SEQ (progn
             (DO ((G166792 substAlist (cdr G166792))
                  (G166783 nil))
                 ((or (atom G166792)
                      (progn (setq G166783 (car G166792)) nil)
                      (progn
                        (progn
                          (setq pvar (car G166783))
                          (setq replace (cdr G166783))
                          G166783)
                        nil))
                  nil)
               (SEQ (EXIT (setq z (subst replace pvar z :test #'equal)))))
             z)))))

\end{chunk}

\defun{computeDomainVariableAlist}{computeDomainVariableAlist}
\begin{chunk}{defun computeDomainVariableAlist}
(defun |computeDomainVariableAlist| ()
  (prog (pvar)
  (declare (special |$curPage|))
    (return
      (SEQ (prog (G166813)
             (setq G166813 nil)
             (return
               (DO ((G166819 (|htpDomainPvarSubstList| |$curPage|)
                        (cdr G166819))
                    (G166805 NIL))
                   ((or (atom G166819)
                        (progn (setq G166805 (car G166819)) nil)
                        (progn
                          (progn
                            (setq pvar (cdr G166805))
                            G166805)
                          NIL))
                    (NREVERSE0 G166813))
                 (SEQ (EXIT (setq G166813
                                  (cons (cons pvar
                                         (|pvarCondList| pvar))
                                        G166813)))))))))))

\end{chunk}

\defun{pvarCondList}{pvarCondList}
\begin{chunk}{defun pvarCondList}
(defun |pvarCondList| (pvar)
  (declare (special |$curPage|))
  (NREVERSE
      (|pvarCondList1| (cons pvar nil) nil
          (|htpDomainConditions| |$curPage|))))

\end{chunk}

\defun{pvarCondList1}{pvarCondList1}
\begin{chunk}{defun pvarCondList1}
(defun |pvarCondList1| (pvarList activeConds condList)
  (prog (cond restConds t2 pv t3 pattern)
    (return
      (cond
        ((null condList) activeConds)
        (t (setq cond (car condList))
         (setq restConds (cdr condList))
         (cond
           ((and (consp cond)
                 (progn
                   (setq t2 (qcdr cond))
                   (and (consp t2)
                        (progn
                          (setq pv (qcar t2))
                          (setq t3 (qcdr t2))
                          (and (consp t3)
                               (eq (qcdr t3) nil)
                               (progn
                                 (setq pattern (qcar t3))
                                 t)))))
                 (|member| pv pvarList))
            (|pvarCondList1|
                (NCONC pvarList (|pvarsOfPattern| pattern))
                (cons cond activeConds) restConds))
           (t (|pvarCondList1| pvarList activeConds restConds))))))))

\end{chunk}

\defun{pvarsOfPattern}{pvarsOfPattern}
\begin{chunk}{defun pvarsOfPattern}
(defun |pvarsOfPattern| (pattern)
  (prog ()
  (declare (special |$PatternVariableList|))
    (return
      (SEQ (cond
             ((null (listp pattern)) nil)
             (t
              (prog (G166869)
                (setq G166869 nil)
                (return
                  (DO ((G166875 (cdr pattern) (cdr G166875))
                       (pvar nil))
                      ((or (atom G166875)
                           (progn (setq pvar (car G166875)) nil))
                       (NREVERSE0 G166869))
                    (SEQ (EXIT (cond
                                 ((|member| pvar
                                      |$PatternVariableList|)
                                  (setq G166869
                                        (cons pvar G166869)))))))))))))))

\end{chunk}

\defun{htMakeTemplates,substLabel}{htMakeTemplates,substLabel}
\begin{chunk}{defun htMakeTemplates,substLabel}
(defun |htMakeTemplates,substLabel| (i template)
  (SEQ (if (consp template)
           (EXIT (intern (CONCAT (car template) (princ-to-string i)
                                 (cdr template)))))
       (EXIT template)))

\end{chunk}

\defun{htMakeTemplates}{htMakeTemplates}
\begin{chunk}{defun htMakeTemplates}
(defun |htMakeTemplates| (templateList numLabels)
  (prog ()
    (return
      (SEQ (progn
             (setq templateList
                      (prog (G166895)
                        (setq G166895 nil)
                        (return
                          (DO ((G166900 templateList
                                   (CDR G166900))
                               (template nil))
                              ((or (atom G166900)
                                   (progn
                                     (setq template (car G166900))
                                     nil))
                               (NREVERSE0 G166895))
                            (SEQ (EXIT (setq G166895
                                        (cons
                                         (|templateParts| template)
                                         G166895))))))))
             (prog (G166910)
               (setq G166910 nil)
               (return
                 (DO ((i 1 (1+ i)))
                     ((qsgreaterp i numLabels)
                      (NREVERSE0 G166910))
                   (SEQ (EXIT (setq G166910
                                    (cons
                                     (prog (G166922)
                                       (setq G166922 nil)
                                       (return
                                         (DO
                                          ((G166927 templateList
                                            (CDR G166927))
                                           (template nil))
                                          ((or (atom G166927)
                                            (progn
                                              (setq template
                                               (car G166927))
                                              nil))
                                           (NREVERSE0 G166922))
                                           (SEQ
                                            (EXIT
                                             (setq G166922
                                              (cons
                                               (|htMakeTemplates,substLabel|
                                                i template)
                                               G166922)))))))
                                     G166910))))))))))))

\end{chunk}

\defun{templateParts}{templateParts}
\begin{chunk}{defun templateParts}
(defun |templateParts| (template)
  (prog (i)
    (return
      (cond
        ((null (stringp template)) template)
        (t (setq i (SEARCH "%l" template))
         (cond
           ((null i) template)
           (t
            (cons (SUBSEQ template 0 i)
                  (SUBSEQ template (+ i 2))))))))))

\end{chunk}

\defun{htMakeDoneButton}{htMakeDoneButton}
\begin{chunk}{defun htMakeDoneButton}
(defun |htMakeDoneButton| (message func)
  (progn
    (|bcHt| "\\newline\\vspace{1}\\centerline{")
    (cond
      ((equal message "Continue")
       (|bchtMakeButton| "\\lispdownlink"
           '|\\ContinueBitmap| func))
      (t
       (|bchtMakeButton| "\\lispdownlink"
           (CONCAT "\\box{" message "}")
           func)))
    (|bcHt| "} ")))

\end{chunk}

\defun{htProcessDoneButton}{htProcessDoneButton}
\begin{chunk}{defun htProcessDoneButton}
(defun |htProcessDoneButton| (arg)
 (let (label func)
  (setq label (car arg))
  (setq func (cadr arg))
  (|iht| "\\newline\\vspace{1}\\centerline{")
  (cond
   ((equal label "Continue")
     (|htMakeButton| "\\lispdownlink" '|\\ContinueBitmap| func))
   ((equal label "Push to enter names")
     (|htMakeButton| "\\lispdownlink" "\\ControlBitmap{clicktoset}" func))
   (t
     (|htMakeButton| "\\lispdownlink" (concat "\\box{" label "}") func)))
  (|iht| "} ")))

\end{chunk}

\defun{htMakeButton}{htMakeButton}
\begin{chunk}{defun htMakeButton}
(defun |htMakeButton| (&rest arg)
 (let (options func message htCommand)
  (setq htCommand (car arg))
  (setq message (cadr arg))
  (setq func (caddr arg))
  (setq options (cdddr arg))
  (prog (skipStateInfo? id type)
  (declare (special |$curPage|))
    (return
      (SEQ (progn
             (setq skipStateInfo? (ifcar options))
             (|iht| (cons htCommand (cons "{" nil)))
             (|bcIssueHt| message)
             (cond
               (skipStateInfo?
                   (|iht| (cons "}{(|htDoneButton| '|"
                                (cons func
                                      (cons "| "
                                       (cons (|htpName| |$curPage|)
                                        (cons ")}" nil)))))))
               (t
                (|iht| (cons "}{(|htDoneButton| '|"
                             (cons func
                                   (cons "| (progn " nil))))
                (DO ((G166977 (|htpInputAreaAlist| |$curPage|)
                         (CDR G166977))
                     (G166965 nil))
                    ((OR (ATOM G166977)
                         (progn (setq G166965 (car G166977)) nil)
                         (progn
                           (progn
                             (setq id (car G166965))
                             (setq type (car (cddddr G166965)))
                             G166965)
                           nil))
                     nil)
                  (SEQ (EXIT (progn
                               (|iht| (cons "(|htpSetLabelInputString| "
                                       (cons (|htpName| |$curPage|)
                                        (cons "'|"
                                         (cons id
                                          (cons "| " nil))))))
                               (cond
                                 ((eq type '|string|)
                                  (|iht| (cons "\"\\stringvalue{"
                                          (cons id
                                           (cons "}\""
                                            nil)))))
                                 (t
                                  (|iht| (cons
                                          "\"\\boxvalue{"
                                          (cons id
                                           (cons "}\""
                                            nil))))))
                               (|iht| ") ")))))
                (|iht| (cons (|htpName| |$curPage|)
                             (cons "))}" nil)))))))))))

\end{chunk}

\defun{bchtMakeButton}{bchtMakeButton}
\begin{chunk}{defun bchtMakeButton}
(defun |bchtMakeButton| (htCommand message func)
  (prog (id type)
  (declare (special |$curPage|))
    (return
      (SEQ (progn
             (|bcHt| (cons htCommand
                           (cons "{"
                                 (cons message
                                       (cons "}{(|htDoneButton| '|"
                                        (cons func
                                         (cons "| (progn "
                                          nil)))))))
             (DO ((G167004 (|htpInputAreaAlist| |$curPage|)
                      (cdr G167004))
                  (G166992 nil))
                 ((or (atom G167004)
                      (progn (setq G166992 (car G167004)) nil)
                      (progn
                        (progn
                          (setq id (car G166992))
                          (setq type (car (cddddr G166992)))
                          G166992)
                        nil))
                  nil)
               (SEQ (EXIT (progn
                            (|bcHt| (cons "(|htpSetLabelInputString| "
                                     (cons (|htpName| |$curPage|)
                                      (cons "'|"
                                       (cons id
                                        (cons "| " nil))))))
                            (cond
                              ((eq type '|string|)
                               (|bcHt| (cons
                                        "\"\\stringvalue{"
                                        (cons id
                                         (cons "}\"" nil)))))
                              (t
                               (|bcHt| (cons
                                        "\"\\boxvalue{"
                                        (cons id
                                         (cons "}\"" nil))))))
                            (|bcHt| ") ")))))
             (|bcHt| (cons (|htpName| |$curPage|)
                           (cons "))} " nil))))))))

\end{chunk}

\defun{htProcessDoitButton}{htProcessDoitButton}
\begin{chunk}{defun htProcessDoitButton}
(defun |htProcessDoitButton| (arg)
 (let (label command func fun)
  (setq label (car arg))
  (setq command (cadr arg))
  (setq func (caddr arg))
  (setq fun (|mkCurryFun| func (cons command nil)))
  (|iht| "\\newline\\vspace{1}\\centerline{")
  (|htMakeButton| "\\lispcommand" (concat "\\box{" label "}") fun)
  (|iht| "} ")
  (|iht| "\\vspace{2}{Select \\  \\UpButton{} \\  to go back one page.}")
  (|iht| 
   "\\newline{Select \\  \\ExitButton{QuitPage} \\  to remove this window.}")))

\end{chunk}

\defun{htDoneButton}{htDoneButton}
\begin{chunk}{defun htDoneButton}
(defun |htDoneButton| (func htPage)
  (cond
    ((|typeCheckInputAreas| htPage) (|htMakeErrorPage| htPage))
    ((null (fboundp func))
     (|systemError| (cons "unknown function" (cons func nil))))
    (t (funcall (symbol-function func) htPage))))

\end{chunk}

\defun{typeCheckInputAreas}{typeCheckInputAreas}
\begin{chunk}{defun typeCheckInputAreas}
(defun |typeCheckInputAreas| (htPage)
 (prog (inputAlist stringName t2 t3 t4 t5 t6 t7 spadType t8 filter
        condList string val errorCondition)
  (declare (special |$bcParseOnly|))
    (return
      (SEQ (progn
             (setq inputAlist nil)
             (setq errorCondition nil)
             (DO ((G167160 (|htpInputAreaAlist| htPage)
                      (cdr G167160))
                  (entry nil))
                 ((or (atom G167160)
                      (progn (setq entry (car G167160)) nil))
                  nil)
               (SEQ (EXIT (cond
                            ((and (consp entry)
                                  (progn
                                    (setq stringName
                                     (QCAR entry))
                                    (setq t2 (QCDR entry))
                                    (and (consp t2)
                                     (progn
                                       (setq t3
                                        (QCDR t2))
                                       (and (consp t3)
                                        (progn
                                          (setq t4
                                           (QCDR t3))
                                          (and (consp t4)
                                           (progn
                                             (setq t5
                                              (QCDR t4))
                                             (and (consp t5)
                                              (eq (QCAR t5)
                                               '|string|)
                                              (progn
                                                (setq t6
                                                 (QCDR t5))
                                                (and (consp t6)
                                                 (progn
                                                   (setq t7
                                                    (QCDR t6))
                                                   (and
                                                    (consp t7)
                                                    (progn
                                                      (setq
                                                       spadType
                                                       (QCAR t7))
                                                      (setq
                                                       t8
                                                       (QCDR t7))
                                                      (and
                                                       (consp
                                                        t8)
                                                       (eq
                                                        (QCDR
                                                         t8)
                                                        nil)
                                                       (progn
                                                         (setq
                                                          filter
                                                          (QCAR
                                                           t8))
                                                         t))))))))))))))))
                             (progn
                               (setq condList
                                        (LASSOC
                                         (LASSOC spadType
                                          (|htpDomainPvarSubstList|
                                           htPage))
                                         (|htpDomainVariableAlist|
                                          htPage)))
                               (setq string
                                        (|htpLabelFilteredInputString|
                                         htPage stringName))
                               (cond
                                 (|$bcParseOnly|
                                     (cond
                                       ((null
                                         (|ncParseFromString| string))
                                        (|htpSetLabelErrorMsg| htPage
                                         "Syntax Error"
                                         "Syntax Error"))
                                       (t nil)))
                                 (t
                                  (setq val
                                           (|checkCondition|
                                            (|htpLabelInputString|
                                             htPage stringName)
                                            string condList))
                                  (cond
                                    ((stringp val)
                                     (setq errorCondition t)
                                     (|htpSetLabelErrorMsg| htPage
                                      stringName val))
                                    (t
                                     (|htpSetLabelSpadValue| htPage
                                      stringName val)))))))))))
             errorCondition)))))

\end{chunk}

\defun{checkCondition}{checkCondition}
\begin{chunk}{defun checkCondition}
(defun |checkCondition| (s1 string condList)
  (prog (pred t2 t3 pvar t4 pattern val type data newType)
    (return
      (cond
        ((and (consp condList) (eq (QCDR condList) nil)
              (progn
                (setq t2 (qcar condList))
                (and (consp t2)
                     (eq (QCAR t2) '|Satisfies|)
                     (progn
                       (setq t3 (QCDR t2))
                       (and (consp t3)
                            (progn
                              (setq pvar (QCAR t3))
                              (setq t4 (QCDR t3))
                              (AND (consp t4)
                                   (eq (QCDR t4) nil)
                                   (progn
                                     (setq pred (QCAR t4))
                                     t))))))))
         (setq val (funcall pred string))
         (cond
           ((stringp val) val)
           (t (cons '(|String|) (|wrap| s1)))))
        ((null (and (consp condList) (eq (qcdr condList) nil)
                    (progn
                      (setq t2 (qcar condList))
                      (and (consp t2)
                           (eq (qcar t2) '|isDomain|)
                           (progn
                             (setq t3 (QCDR t2))
                             (and (consp t3)
                                  (progn
                                    (setq pvar (QCAR t3))
                                    (setq t4
                                     (QCDR t3))
                                    (and (consp t4)
                                     (eq (QCDR t4) nil)
                                     (progn
                                       (setq pattern
                                        (QCAR t4))
                                       t)))))))))
         (|systemError|
             "currently invalid domain condition"))
        ((equal pattern '(|String|))
         (cons '(|String|) (|wrap| s1)))
        (t (setq val (|parseAndEval| string))
         (cond
           ((stringp val)
            (cond
              ((equal val "Syntax Error ")
               "Error: Syntax Error ")
              (t (|condErrorMsg| pattern))))
           (t (setq type (car val))
            (setq data (cdr val))
            (setq newType
                     (catch 'spad_reader
                       (|resolveTM| type pattern)))
            (cond
              ((null newType) (|condErrorMsg| pattern))
              (t (|coerceInt| val newType))))))))))

\end{chunk}

\defun{condErrorMsg}{condErrorMsg}
\begin{chunk}{defun condErrorMsg}
(defun |condErrorMsg| (type)
  (prog (typeString)
    (return
      (progn
        (setq typeString (|form2String| type))
        (cond
          ((consp typeString)
           (setq typeString
                    (apply #'CONCAT typeString))))
        (CONCAT "Error: Could not make your input into a "
                typeString)))))

\end{chunk}

\defun{parseAndEval}{parseAndEval}
\begin{chunk}{defun parseAndEval}
(defun |parseAndEval| (string)
  (prog (|$InteractiveMode| $boot $spad |$e| |$QuietCommand|)
    (declare (special |$InteractiveMode| $boot $spad |$e|
                      |$QuietCommand|))
    (return
      (progn
        (setq |$InteractiveMode| t)
        (setq $boot nil)
        (setq $spad t)
        (setq |$e| |$InteractiveFrame|)
        (setq |$QuietCommand| t)
        (|parseAndEval1| string)))))

\end{chunk}

\defun{parseAndEval1}{parseAndEval1}
\begin{chunk}{defun parseAndEval1}
(defun |parseAndEval1| (string)
 (let (v syntaxError pform val)
  (setq syntaxError nil)
  (setq pform
   (progn
    (setq v
     (|applyWithOutputToString| '|ncParseFromString| (cons string nil)))
    (cond
     ((car v) (car v))
     (t (setq syntaxError t) (cdr v)))))
  (cond
   (syntaxError "Syntax Error ")
   (pform 
    (setq val
     (|applyWithOutputToString| '|processInteractive|
      (cons pform (list nil))))
    (cond
     ((car val) (car val))
     (t "Type Analysis Error")))
   (t nil))))

\end{chunk}

\defun{oldParseString}{oldParseString}
\begin{chunk}{defun oldParseString}
(defun |oldParseString| (string)
  (prog (tree)
    (return
      (progn
        (setq tree
                 (|applyWithOutputToString| '|string2SpadTree|
                     (cons string nil)))
        (cond
          ((car tree)
           (|parseTransform| (postTransform (car tree))))
          (t (cdr tree)))))))

\end{chunk}

\defun{makeSpadCommand}{makeSpadCommand}
\begin{chunk}{defun makeSpadCommand}
(defun |makeSpadCommand| (&rest a1)
 (let (opForm lastArg argList z)
  (setq z a1)
  (setq opForm (concat (car z) "("))
  (setq lastArg (|last| z))
  (setq z (cdr z))
  (setq argList nil)
  (do ((g1 z (cdr g1)) (arg nil))
       ((or (atom g1) 
            (progn (setq arg (car g1)) nil)
            (null (nequal arg lastArg)))
             nil)
    (setq argList (cons (concat arg ", ") argList)))
    (setq argList (nreverse (cons lastArg argList)))
    (concat opForm (apply #'concat argList) ")")))

\end{chunk}

\defun{htMakeInputList}{htMakeInputList}
\begin{chunk}{defun htMakeInputList}
(defun |htMakeInputList| (stringList)
  (prog (lastArg argList)
    (return
      (SEQ (progn
             (setq lastArg (|last| stringList))
             (setq argList nil)
             (DO ((G167328 stringList (cdr G167328)) (arg nil))
                 ((or (atom G167328)
                      (progn (setq arg (car G167328)) nil)
                      (null (NEQUAL arg lastArg)))
                  nil)
               (SEQ (EXIT (setq argList
                                   (cons
                                    (CONCAT arg ", ")
                                    argList)))))
             (setq argList (NREVERSE (cons lastArg argList)))
             (|bracketString| (apply #'CONCAT argList)))))))

\end{chunk}

\defun{bracketString}{bracketString}
\begin{chunk}{defun bracketString}
(defun |bracketString| (string)
  (CONCAT "[" string "]"))

\end{chunk}

\defun{quoteString}{quoteString}
\begin{chunk}{defun quoteString}
(defun |quoteString| (string)
  (concat "\"" string "\""))

\end{chunk}

\defdollar{funnyQuote}
\begin{chunk}{initvars}
(defvar |$funnyQuote| #\Rubout) 

\end{chunk}

\defdollar{funnyBacks}
\begin{chunk}{initvars}
(defvar |$funnyBacks| #\\200) 

\end{chunk}

\defun{htEscapeString}{htEscapeString}
\begin{chunk}{defun htEscapeString}
(defun |htEscapeString| (str)
 (declare (special |$funnyBacks| |$funnyQuote|))
  (setq str (substitute |$funnyQuote| #\" str))
  (substitute |$funnyBacks| #\\ str))

\end{chunk}

\defun{htsv}{htsv}
\begin{chunk}{defun htsv}
(defun |htsv| ()
 (|startHTPage| 50)
 (|htSetVars|))

\end{chunk}

\defun{htSetVars}{htSetVars}
\begin{chunk}{defun htSetVars}
(defun |htSetVars| ()
 (declare (special |$setOptions| |$lastTree| |$path|))
  (setq |$path| nil)
  (setq |$lastTree| nil)
  (when (nequal 0 (lastatom |$setOptions|)) (|htMarkTree| |$setOptions| 0))
  (|htShowSetTree| |$setOptions|))

\end{chunk}

\defun{htShowSetTree}{htShowSetTree}
\begin{chunk}{defun htShowSetTree}
(defun |htShowSetTree| (setTree)
  (prog (page okList maxWidth1 maxWidth2 tabset1 tabset2 label links)
  (declare (special |$path|))
    (return
      (SEQ (progn
             (setq |$path|
                      (TAKE (- (LASTATOM setTree))
                            |$path|))
             (setq page (|htInitPage| (|mkSetTitle|) nil))
             (|htpSetProperty| page '|setTree| setTree)
             (setq links nil)
             (setq maxWidth1 (setq maxWidth2 0))
             (SEQ (DO ((G167379 setTree (cdr G167379))
                       (setData nil))
                      ((or (atom G167379)
                           (progn
                             (setq setData (car G167379))
                             nil))
                       nil)
                    (SEQ (EXIT (cond
                                 ((|satisfiesUserLevel|
                                      (elt setData 2))
                                  (EXIT (progn
                                          (setq okList
                                           (cons setData okList))
                                          (setq maxWidth1
                                           (max
                                            (|#|
                                             (PNAME (elt setData 0)))
                                            maxWidth1))
                                          (setq maxWidth2
                                           (max
                                            (|htShowCount|
                                             (PRINC-TO-STRING
                                              (elt setData 1)))
                                            maxWidth2)))))))))
                  (setq maxWidth1 (max 9 maxWidth1))
                  (setq maxWidth2 (max 41 maxWidth2))
                  (setq tabset1 (PRINC-TO-STRING maxWidth1))
                  (setq tabset2
                           (PRINC-TO-STRING
                               (-
                                   (+ maxWidth2 maxWidth1) 1)))
                  (|htSay| "\\tab{2}\\newline Variable\\tab{"
                           (PRINC-TO-STRING
                               (+ maxWidth1
                                     (quotient maxWidth2 3)))
                           "}Description\\tab{"
                           (PRINC-TO-STRING
                               (+ (+ maxWidth2 maxWidth1) 2))
                           "}Value\\newline\\beginitems ")
                  (DO ((G167392 (reverse okList) (CDR G167392))
                       (setData nil))
                      ((or (atom G167392)
                           (progn
                             (setq setData (car G167392))
                             nil))
                       nil)
                    (SEQ (EXIT (progn
                                 (|htSay| "\\item")
                                 (setq label
                                          (CONCAT "\\menuitemstyle{"
                                           (elt setData 0)
                                           "}"))
                                 (setq links
                                          (cons label
                                           (cons
                                            (cons
                                             (cons '|text|
                                              (cons
                                               "\\tab{"
                                               (cons tabset1
                                                (cons "}"
                                                 (cons
                                                  (elt setData 1)
                                                  (cons "\\tab{"
                                                   (cons tabset2
                                                    (cons "}{\\em "
                                                     (cons
                                                      (|htShowSetTreeValue|
                                                       setData)
                                                      (cons
                                                       "}"
                                                       nil))))))))))
                                             nil)
                                            (cons '|htShowSetPage|
                                             (cons (elt setData 0)
                                              nil)))))
                                 (|htMakePage|
                                     (cons
                                      (cons '|bcLispLinks|
                                       (cons links
                                        (cons '|options|
                                         (cons '(|indent| . 0) nil))))
                                      nil))))))
                  (|htSay| "\\enditems") (|htShowPage|)))))))

\end{chunk}

\defun{htShowCount}{htShowCount}
\begin{chunk}{defun htShowCount}
(defun |htShowCount| (s)
  (prog (m i count)
    (return
      (SEQ (progn
             (setq m (|#| s))
             (cond
               ((> 8 m) (- m 1))
               (t (setq i 0) (setq count 0)
                (DO () ((NULL (> (- m 7) i)) nil)
                  (SEQ (EXIT (cond
                               ((and (equal (elt s i) #\{)
                                     (equal (elt s (1+ i)) #\\)
                                     (equal (elt s (+ i 2)) #\e)
                                     (equal (elt s (+ i 3)) #\m))
                                (setq i (+ i 6)))
                               (t (setq i (1+ i))
                                (setq count (1+ count)))))))
                (+ count (- m i)))))))))

\end{chunk}

\defun{htShowSetTreeValue}{htShowSetTreeValue}
\begin{chunk}{defun htShowSetTreeValue}
(defun |htShowSetTreeValue| (setData)
 (let (st)
  (setq st (elt setData 3))
  (cond
   ((eq st 'function)
     (|object2String| (funcall (elt setData 4) '|%display%|)))
   ((eq st 'integer)
     (|object2String| (|eval| (elt setData 4))))
   ((eq st 'string)
     (|object2String| (|eval| (elt setData 4))))
   ((eq st 'literals)
     (|object2String| (|translateTrueFalse2YesNo| (|eval| (elt setData 4)))))
   ((eq st 'tree) "...")
   (t (|systemError|)))))

\end{chunk}

\defun{mkSetTitle}{mkSetTitle}
\begin{chunk}{defun mkSetTitle}
(defun |mkSetTitle| ()
 (declare (special |$path|))
 (concat "Command {\\em )set " (|listOfStrings2String| |$path|) "}"))

\end{chunk}

\defun{listOfStrings2String}{listOfStrings2String}
\begin{chunk}{defun listOfStrings2String}
(defun |listOfStrings2String| (u)
 (cond
  ((null u) "")
  (t (concat (|listOfStrings2String| (cdr u)) " " (|stringize| (car u))))))

\end{chunk}

\defun{htShowSetPage}{htShowSetPage}
\begin{chunk}{defun htShowSetPage}
(defun |htShowSetPage| (htPage branch)
 (let (setTree setData st)
 (declare (special |$path|))
  (setq setTree (|htpProperty| htPage '|setTree|))
  (setq |$path| (cons branch (take (- (lastatom setTree)) |$path|)))
  (setq setData (|assoc| branch setTree))
  (cond
    ((null setData) (|systemError| "No Set Data"))
    (t (setq st (elt setData 3))
       (cond
         ((eq st 'function) (|htShowFunctionPage| htPage setData))
         ((eq st 'integer)  (|htShowIntegerPage| htPage setData))
         ((eq st 'literals) (|htShowLiteralsPage| htPage setData))
         ((eq st 'tree)     (|htShowSetTree| (elt setData 5)))
         ((eq st 'string)   (|htSetNotAvailable| htPage ")set compiler"))
         (t                 (|systemError| "Unknown data type")))))))

\end{chunk}

\defun{htShowLiteralsPage}{htShowLiteralsPage}
\begin{chunk}{defun htShowLiteralsPage}
(defun |htShowLiteralsPage| (htPage setData)
  (|htSetLiterals| htPage (elt setData 0) (elt setData 1)
      (elt setData 4) (elt setData 5) '|htSetLiteral|))

\end{chunk}

\defun{htSetLiterals}{htSetLiterals}
\begin{chunk}{defun htSetLiterals}
(defun |htSetLiterals| (htPage name message variable values functionToCall)
  (prog (page links)
    (return
      (SEQ (progn
             (setq page
                      (|htInitPage| "Set Command"
                          (|htpPropertyList| htPage)))
             (|htpSetProperty| page '|variable| variable)
             (|bcHt| (cons "\\centerline{Set {\\em "
                           (cons name
                                 (cons "}}\\newline" nil))))
             (|bcHt| (cons "{\\em Description: } "
                           (cons message
                                 (cons "\\newline\\vspace{1} "
                                       nil))))
             (|bcHt| "Select one of the following: \\newline\\tab{3} ")
             (setq links
                      (prog (g2)
                        (setq g2 nil)
                        (return
                          (DO ((G167465 values (cdr G167465))
                               (opt nil))
                              ((or (atom G167465)
                                   (progn
                                     (setq opt (car G167465))
                                     nil))
                               (NREVERSE0 g2))
                            (SEQ (EXIT (setq g2
                                        (cons
                                         (cons
                                          (CONCAT ""
                                           (PRINC-TO-STRING opt))
                                          (cons "\\newline\\tab{3}"
                                           (cons functionToCall
                                            (cons opt nil))))
                                         g2))))))))
             (|htMakePage| (cons (cons '|bcLispLinks| links) nil))
             (|bcHt| 
              (cons 
              '|\\indent{0}\\newline\\vspace{1} The current setting is: {\\em |
                           (cons (|translateTrueFalse2YesNo|
                                     (eval variable))
                                 (cons "} " nil))))
             (|htShowPage|))))))

\end{chunk}

\defun{htSetLiteral}{htSetLiteral}
\begin{chunk}{defun htSetLiteral}
(defun |htSetLiteral| (htPage val)
  (|htInitPage| "Set Command" nil)
  (set (|htpProperty| htPage '|variable|) (|translateYesNo2TrueFalse| val))
  (|htKill| htPage val))

\end{chunk}

\defun{htShowIntegerPage}{htShowIntegerPage}
\begin{chunk}{defun htShowIntegerPage}
(defun |htShowIntegerPage| (htPage setData)
  (prog (page message t1)
  (declare (special |$htFinal| |$htInitial|))
    (return
      (progn
        (setq page
                 (|htInitPage| (|mkSetTitle|)
                     (|htpPropertyList| htPage)))
        (|htpSetProperty| page '|variable| (elt setData 4))
        (|bcHt| (list "\\centerline{Set {\\em " (elt setData 0) "}}\\newline"))
        (setq message (elt setData 1))
        (|bcHt| (list "{\\em Description: } " message "\\newline\\vspace{1} "))
        (setq t1 (elt setData 5))
        (setq |$htInitial| (car t1))
        (setq |$htFinal| (cadr t1))
        (cond
          ((equal |$htFinal| (+ |$htInitial| 1))
           (|bcHt| "Enter the integer {\\em ")
           (|bcHt| (|stringize| |$htInitial|))
           (|bcHt| "} or {\\em ")
           (|bcHt| (|stringize| |$htFinal|))
           (|bcHt| "}:"))
          ((null |$htFinal|)
           (|bcHt| "Enter an integer greater than {\\em ")
           (|bcHt| (|stringize| (- |$htInitial| 1)))
           (|bcHt| "}:"))
          (t (|bcHt| "Enter an integer between {\\em ")
           (|bcHt| (|stringize| |$htInitial|))
           (|bcHt| "} and {\\em ")
           (|bcHt| (|stringize| |$htFinal|))
           (|bcHt| "}:")))
        (|htMakePage|
            (cons '(|domainConditions| (|Satisfies| S chkRange))
                  (cons (cons '|bcStrings|
                     (list (list 5 (|eval| (elt setData 4)) '|value|  'S)))
                        nil)))
        (|htSetvarDoneButton| "Select to Set Value" '|htSetInteger|)
        (|htShowPage|)))))

\end{chunk}

\defun{htSetInteger}{htSetInteger}
\begin{chunk}{defun htSetInteger}
(defun |htSetInteger| (htPage)
  (prog (val)
    (return
      (progn
        (|htInitPage| (|mkSetTitle|) nil)
        (setq val
                 (|chkRange| (|htpLabelInputString| htPage '|value|)))
        (cond
          ((null (integerp val))
           (|errorPage| htPage
               (cons "Value Error"
                     (cons nil
                           (cons "\\vspace{3}\\centerline{{\\em "
                                 (cons val
                                       (cons
 "}}\\vspace{2}\\newline\\centerline{Click on \\UpBitmap{} to re-enter value}"
                                        nil)))))))
          (t (set (|htpProperty| htPage '|variable|) val)
           (|htKill| htPage val)))))))

\end{chunk}

\defun{htShowFunctionPage}{htShowFunctionPage}
\begin{chunk}{defun htShowFunctionPage}
(defun |htShowFunctionPage| (htPage setData)
  (prog (fn)
    (return
      (cond
        ((setq fn (elt setData 6)) (funcall fn htPage))
        (t (|htpSetProperty| htPage '|setData| setData)
         (|htpSetProperty| htPage '|parts| (elt setData 5))
         (|htShowFunctionPageContinued| htPage))))))

\end{chunk}

\defun{htShowFunctionPageContinued}{htShowFunctionPageContinued}
\begin{chunk}{defun htShowFunctionPageContinued}
(defun |htShowFunctionPageContinued| (htPage)
  (prog (parts setData phrase kind variable checker
         initValue restParts page currentValue)
    (return
      (progn
        (setq parts (|htpProperty| htPage '|parts|))
        (setq setData (|htpProperty| htPage '|setData|))
        (setq phrase (caar parts))
        (setq kind (cadar parts))
        (setq variable (caddar parts))
        (setq checker (car (cdddar parts)))
        (setq initValue (cadr (cdddar parts)))
        (setq restParts (cdr parts))
        (|htpSetProperty| htPage '|variable| variable)
        (|htpSetProperty| htPage '|checker| checker)
        (|htpSetProperty| htPage '|parts| restParts)
        (cond
          ((eq kind 'literals)
           (|htSetLiterals| htPage (elt setData 0) phrase
               variable checker '|htFunctionSetLiteral|))
          (t
           (setq page
                    (|htInitPage| (|mkSetTitle|)
                        (|htpPropertyList| htPage)))
           (|bcHt| (cons "\\centerline{Set {\\em "
                         (cons (elt setData 0)
                               (cons "}}\\newline" nil))))
           (|bcHt| (cons "{\\em Description: } "
                         (cons (elt setData 1)
                               (cons "\\newline\\vspace{1} "
                                     nil))))
           (setq currentValue (eval variable))
           (|htMakePage|
               (cons (cons '|domainConditions|
                           (cons (cons '|Satisfies|
                                       (cons 'S (cons checker nil)))
                                 nil))
                     (cons (cons '|text| phrase)
                           (cons (cons '|inputStrings|
                                       (cons
                                        (cons ""
                                         (cons ""
                                          (cons 60
                                           (cons currentValue
                                            (cons '|value|
                                             (cons 'S nil))))))
                                        nil))
                                 nil))))
           (|htSetvarDoneButton| "Select To Set Value" '|htSetFunCommand|)
           (|htShowPage|)))))))

\end{chunk}

\defun{htSetvarDoneButton}{htSetvarDoneButton}
\begin{chunk}{defun htSetvarDoneButton}
(defun |htSetvarDoneButton| (message func)
  (progn
    (|bcHt| "\\newline\\vspace{1}\\centerline{")
    (cond
      ((OR (equal message "Select to Set Value")
           (equal message "Select to Set Values"))
       (|bchtMakeButton| "\\lisplink"
           "\\ControlBitmap{clicktoset}" func))
      (t
       (|bchtMakeButton| "\\lisplink"
           (CONCAT "\\fbox{" message "}")
           func)))
    (|bcHt| "} ")))

\end{chunk}

\defun{htFunctionSetLiteral}{htFunctionSetLiteral}
\begin{chunk}{defun htFunctionSetLiteral}
(defun |htFunctionSetLiteral| (htPage val)
  (progn
    (|htInitPage| "Set Command" nil)
    (set (|htpProperty| htPage '|variable|)
         (|translateYesNo2TrueFalse| val))
    (|htSetFunCommandContinue| htPage val)))

\end{chunk}

\defun{htSetFunCommand}{htSetFunCommand}
\begin{chunk}{defun htSetFunCommand}
(defun |htSetFunCommand| (htPage)
 (let (variable checker value)
  (setq variable (|htpProperty| htPage '|variable|))
  (setq checker (|htpProperty| htPage '|checker|))
  (setq value (|htCheck| checker (|htpLabelInputString| htPage '|value|)))
  (set variable value)
  (|htSetFunCommandContinue| htPage value)))

\end{chunk}

\defun{htSetFunCommandContinue}{htSetFunCommandContinue}
\begin{chunk}{defun htSetFunCommandContinue}
(defun |htSetFunCommandContinue| (htPage value)
 (let (parts continue)
  (setq parts (|htpProperty| htPage '|parts|))
  (setq continue
   (cond
    ((null parts) nil)
    ((and (consp parts)
          (consp (qcar parts)) (eq (qcaar parts) '|break|)
          (consp (qcdar parts)) (eq (qcddar parts) nil))
       (|eval| (qcadar parts)))
    (t t)))
  (cond
   (continue 
    (|htpSetProperty| htPage '|parts| (qcdr parts))
      (|htShowFunctionPageContinued| htPage))
   (t (|htKill| htPage value)))))

\end{chunk}

\defun{htKill}{htKill}
\begin{chunk}{defun htKill}
(defun |htKill| (htPage value)
  (declare (ignore htPage))
  (prog (string)
  (declare (special |$path|))
    (return
      (progn
        (|htInitPage| "System Command" nil)
        (setq string
                 (CONCAT "{\\em )set "
                          (|listOfStrings2String|
                              (cons value |$path|))
                          "}"))
        (|htMakePage|
     (cons '(|text| "{Here is the AXIOM system command you could have issued:}"
                           "\\vspace{2}\\newline\\centerline{\\tt")
                  (cons (cons '|text| string) nil)))
        (|htMakePage| '((|text| . "}\\vspace{1}\\newline\\rm")))
        (|htSay| "\\vspace{2}{Select \\  \\UpButton{} \\  to go back.}")
        (|htSay| "\\newline{Select \\  \\ExitButton{QuitPage} \\  to remove this window.}")
        (|htProcessDoitButton|
            (cons "Press to Remove Page"
                  (cons "" (cons '|htDoNothing| nil))))
        (|htShowPage|)))))

\end{chunk}

\defun{htSetNotAvailable}{htSetNotAvailable}
\begin{chunk}{defun htSetNotAvailable}
(defun |htSetNotAvailable| (htPage whatToType)
 (let (page string)
  (setq page
    (|htInitPage| "Unavailable Set Command" (|htpPropertyList| htPage)))
    (|htInitPage| "Unavailable System Command" nil)
    (setq string (concat "{\\em " whatToType "}"))
    (|htMakePage|
            (cons '(|text| "\\vspace{1}\\newline"
 "{Sorry, but this system command is not available through HyperDoc. Please directly issue this command in an AXIOM window for more information:}"
                           "\\vspace{2}\\newline\\centerline{\\tt")
                  (cons (cons '|text| string) nil)))
    (|htMakePage| '((|text| . "}\\vspace{1}\\newline")))
    (|htProcessDoitButton| (list "Press to Remove Page" "" '|htDoNothing| ))
    (|htShowPage|)))

\end{chunk}

\defun{htDoNothing}{htDoNothing}
\begin{chunk}{defun htDoNothing}
(defun |htDoNothing| (htPage command)
 (declare (ignore htPage command))
 nil) 

\end{chunk}

\defun{htCheck}{htCheck}
\begin{chunk}{defun htCheck}
(defun |htCheck| (checker value)
  (cond
    ((consp checker) (|htCheckList| checker (|parseWord| value)))
    (t (funcall checker value))))

\end{chunk}

\defun{parseWord}{parseWord}
\begin{chunk}{defun parseWord}
(defun |parseWord| (x)
  (prog ()
    (return
      (SEQ (cond
             ((stringp x)
              (cond
                ((prog (G167588)
                   (setq G167588 t)
                   (return
                     (DO ((G167594 nil (null G167588))
                          (G167595 (maxindex x))
                          (i 0 (1+ i)))
                         ((OR G167594 (QSGREATERP i G167595))
                          G167588)
                       (SEQ (EXIT (setq G167588
                                        (AND G167588
                                         (digitp (elt x i)))))))))
                 (parse-integer x))
                (t (intern x))))
             (t x))))))

\end{chunk}

\defun{htCheckList}{htCheckList}
\begin{chunk}{defun htCheckList}
(defun |htCheckList| (checker value)
  (prog (n t2 m)
    (return
      (progn
        (cond
          ((|member| value '(|y| |ye| |yes| Y YE YES))
           (setq value '|yes|)))
        (cond
          ((|member| value '(|n| |no| N NO)) (setq value '|no|)))
        (cond
          ((and (consp checker)
                (progn
                  (setq n (qcar checker))
                  (setq t2 (qcdr checker))
                  (and (consp t2) (eq (QCDR t2) nil)
                       (progn (setq m (QCAR t2)) t)))
                (integerp n))
           (cond
             ((eql m (1+ n))
              (cond ((|member| value checker) value) (t n)))
             ((null m)
              (cond
                ((and (integerp value) (>= value n)) value)
                (t n)))
             ((integerp m)
              (cond
                ((and (integerp value) (>= value n)
                      (<= value m))
                 value)
                (t n)))))
          ((|member| value checker) value)
          (t (car checker)))))))

\end{chunk}

\defun{translateYesNoToTrueFalse}{translateYesNoToTrueFalse}
\begin{chunk}{defun translateYesNoToTrueFalse}
(defun |translateYesNoToTrueFalse| (x)
  (cond
    ((eq x '|yes|) t)
    ((eq x '|no|) nil)
    (t x)))

\end{chunk}

\defun{chkNameList}{chkNameList}
\begin{chunk}{defun chkNameList}
(defun |chkNameList| (x)
  (prog (u parsedNames)
    (return
      (SEQ (progn
             (setq u (|bcString2ListWords| x))
             (setq parsedNames
                      (prog (G167635)
                        (setq G167635 nil)
                        (return
                          (DO ((G167640 u (CDR G167640))
                               (x nil))
                              ((or (atom G167640)
                                   (progn
                                     (setq x (car G167640))
                                     nil))
                               (NREVERSE0 G167635))
                            (SEQ (EXIT (setq G167635
                                        (cons (|ncParseFromString| x)
                                         G167635))))))))
             (cond
               ((prog (G167646)
                  (setq G167646 t)
                  (return
                    (DO ((G167652 nil (NULL G167646))
                         (G167653 parsedNames (CDR G167653))
                         (x nil))
                        ((OR G167652 (ATOM G167653)
                             (progn (setq x (car G167653)) nil))
                         G167646)
                      (SEQ (EXIT (setq G167646
                                       (AND G167646 (identp x))))))))
                parsedNames)
               (t
                "Please enter a list of identifiers separated by blanks")))))))

\end{chunk}

\defun{chkPosInteger}{chkPosInteger}
\begin{chunk}{defun chkPosInteger}
(defun |chkPosInteger| (s)
  (prog (u)
    (return
      (cond
        ((and (setq u (|parseOnly| s)) (integerp u) (> u 0))
         u)
        (t "Please enter a positive integer")))))

\end{chunk}

\defun{chkOutputFileName}{chkOutputFileName}
\begin{chunk}{defun chkOutputFileName}
(defun |chkOutputFileName| (s)
  (cond
    ((|member| (|bcString2WordList| s) '(CONSOLE |console|))
     '|console|)
    (t (|chkDirectory| s))))

\end{chunk}

\defun{chkDirectory}{chkDirectory}
\begin{chunk}{defun chkDirectory}
(defun |chkDirectory| (s) s) 

\end{chunk}

\defun{chkNonNegativeInteger}{chkNonNegativeInteger}
\begin{chunk}{defun chkNonNegativeInteger}
(defun |chkNonNegativeInteger| (s)
  (prog (u)
    (return
      (cond
        ((and (setq u (|ncParseFromString| s)) (integerp u)
              (>= u 0))
         u)
        (t "Please enter a non-negative integer")))))

\end{chunk}

\defun{chkRange}{chkRange}
\begin{chunk}{defun chkRange}
(defun |chkRange| (s)
  (prog (u)
  (declare (special |$htFinal| |$htInitial|))
    (return
      (cond
        ((and (setq u (|ncParseFromString| s)) (integerp u)
              (>= u |$htInitial|)
              (or (null |$htFinal|) (<= u |$htFinal|)))
         u)
        ((null |$htFinal|)
         (CONCAT "Please enter an integer greater than "
                  (|stringize| (- |$htInitial| 1))))
        (t
         (CONCAT "Please enter an integer between "
                  (|stringize| |$htInitial|) " and "
                  (|stringize| |$htFinal|)))))))

\end{chunk}

\defun{chkAllNonNegativeInteger}{chkAllNonNegativeInteger}
\begin{chunk}{defun chkAllNonNegativeInteger}
(defun |chkAllNonNegativeInteger| (s)
  (prog (u)
    (return
      (or (and (setq u (|ncParseFromString| s))
               (|member| u '(|a| |al| |all| A AL ALL)) 'ALL)
          (|chkNonNegativeInteger| s)
                        "Please enter {\\em all} or a non-negative integer"))))

\end{chunk}

\defun{htMakePathKey,fn}{htMakePathKey,fn}
\begin{chunk}{defun htMakePathKey,fn}
(defun |htMakePathKey,fn| (a b)
  (SEQ (if (null b) (EXIT a))
       (EXIT (|htMakePathKey,fn|
                 (CONCAT a "." (PNAME (car b)))
                 (cdr b)))))

\end{chunk}

\defun{htMakePathKey}{htMakePathKey}
\begin{chunk}{defun htMakePathKey}
(defun |htMakePathKey| (path)
  (cond
    ((null path) (|systemError| "path is not set"))
    (t
     (intern (|htMakePathKey,fn| (PNAME (car path)) (cdr path))))))

\end{chunk}

\defun{htMarkTree}{htMarkTree}
\begin{chunk}{defun htMarkTree}
(defun |htMarkTree| (tree n)
  (SEQ (progn
         (rplacd (last tree) n)
         (SEQ (DO ((G167706 tree (cdr G167706)) (branch nil))
                  ((OR (ATOM G167706)
                       (progn (setq branch (car G167706)) nil))
                   nil)
                (SEQ (EXIT (cond
                             ((eq (elt branch 3) 'tree)
                              (EXIT (|htMarkTree| (elt branch 5)
                                     (1+ n))))))))))))

\end{chunk}

\defun{htSetHistory}{htSetHistory}
\begin{chunk}{defun htSetHistory}
(defun |htSetHistory| (htPage)
 (let (msg data)
  (setq msg
 '|when the history facility is on (yes), results of computations are saved in memory|)
  (setq data
    (list '|history| msg '|history| 'literals '|$HiFiAccess| 
           '(|on| |off| |yes| |no|)))
  (|htShowLiteralsPage| htPage data)))

\end{chunk}

\defun{htSetOutputLibrary}{htSetOutputLibrary}
\begin{chunk}{defun htSetOutputLibrary}
(defun |htSetOutputLibrary| (htPage)
  (|htSetNotAvailable| htPage ")set compiler output"))

\end{chunk}

\defun{htSetInputLibrary}{htSetInputLibrary}
\begin{chunk}{defun htSetInputLibrary}
(defun |htSetInputLibrary| (htPage)
  (|htSetNotAvailable| htPage ")set compiler input"))

\end{chunk}

\defun{htSetExpose}{htSetExpose}
\begin{chunk}{defun htSetExpose}
(defun |htSetExpose| (htPage)
  (|htSetNotAvailable| htPage ")set expose"))

\end{chunk}

\defun{htSetOutputCharacters}{htSetOutputCharacters}
\begin{chunk}{defun htSetOutputCharacters}
(defun |htSetOutputCharacters| (htPage)
  (|htSetNotAvailable| htPage ")set output characters"))

\end{chunk}

\defun{htSetLinkerArgs}{htSetLinkerArgs}
\begin{chunk}{defun htSetLinkerArgs}
(defun |htSetLinkerArgs| (htPage)
  (|htSetNotAvailable| htPage ")set fortran calling linker"))

\end{chunk}

\defun{htSetCache}{htSetCache}
\begin{chunk}{defun htSetCache}
(defun |htSetCache| (&REST arg &AUX options htPage)
 (declare (special |$valueList| |$path|))
 (setq htPage (car arg))
 (setq options (cdr arg))
 (setq |$path| '(|functions| |cache|))
 (setq htPage (|htInitPage| (|mkSetTitle|) nil))
 (setq |$valueList| nil)
 (|htMakePage|
  '((|text| 
    "Use this system command to cause the AXIOM interpreter to `remember' "
    "past values of interpreter functions. "
    "To remember a past value of a function, the interpreter "
    "sets up a {\\em cache} for that function based on argument values. "
    "When a value is cached for a given argument value, its value is gotten "
    "from the cache and not recomputed. Caching can often save much "
    "computing time, particularly with recursive functions or functions that "
    "are expensive to compute and that are called repeatedly "
    "with the same argument." "\\vspace{1}\\newline ")
    (|domainConditions| (|Satisfies| S chkNameList))
    (|text| 
"Enter below a list of interpreter functions you would like specially cached. "
    "Use the name {\\em all} to give a default setting for all "
    "interpreter functions. " "\\vspace{1}\\newline "
    "Enter {\\em all} or a list of names (separate names by blanks):")
     (|inputStrings| ("" "" 60 "all" names S))
     (|doneButton| "Push to enter names" |htCacheAddChoice|)))
 (|htShowPage|))

\end{chunk}

\defun{htCacheAddChoice}{htCacheAddChoice}
\begin{chunk}{defun htCacheAddChoice}
(defun |htCacheAddChoice| (htPage)
  (prog (names page)
  (declare (special |$valueList|))
    (return
      (SEQ (progn
             (setq names
                      (|bcString2WordList|
                          (|htpLabelInputString| htPage '|names|)))
             (setq |$valueList|
                      (cons (|listOfStrings2String| names)
                            |$valueList|))
             (cond
               ((null names) (|htCacheAddQuery|))
               ((null (cdr names)) (|htCacheOne| names))
               (t (setq page (|htInitPage| (|mkSetTitle|) nil))
                (|htpSetProperty| page '|names| names)
                (|htMakePage|
                    '((|domainConditions|
                          (|Satisfies| ALLPI chkAllPositiveInteger))
                      (|text|
  "For each function, enter below a {\\em cache length}, a positive integer. "
  "This number tells how many past values will "
  "be cached. "
  "A cache length of {\\em 0} means the function won't be cached. "
  "To cache all past values, "
  "enter {\\em all}."
  "\\vspace{1}\\newline "
  "For each function name, enter {\\em all} or a positive integer:")))
                (DO ((i 1 (QSADD1 i))
                     (G167755 names (CDR G167755)) (name nil))
                    ((or (atom G167755)
                         (progn (setq name (car G167755)) nil))
                     nil)
                  (SEQ (EXIT (|htMakePage|
                                 (cons (cons '|inputStrings|
                                        (cons
                                         (cons
                                          (CONCAT "Function {\\em "
                                           name
                                           "} will cache")
                                          (cons "values"
                                           (cons 5
                                            (cons 10
                                             (cons
                                              (|htMakeLabel|
                                               "c" i)
                                              (cons 'ALLPI nil))))))
                                         nil))
                                       nil)))))
                (|htSetvarDoneButton| "Select to Set Values" '|htCacheSet|)
                (|htShowPage|))))))))

\end{chunk}

\defun{htMakeLabel}{htMakeLabel}
\begin{chunk}{defun htMakeLabel}
(defun |htMakeLabel| (prefix i)
  (intern (concat prefix (|stringize| i))))

\end{chunk}

\defun{htCacheSet}{htCacheSet}
\begin{chunk}{defun htCacheSet}
(defun |htCacheSet| (htPage)
  (prog (names num n name val)
  (declare (special |$cacheCount| |$cacheAlist|))
    (return
      (SEQ (progn
             (setq names (|htpProperty| htPage '|names|))
             (DO ((i 1 (QSADD1 i))
                  (G167785 names (CDR G167785)) (name nil))
                 ((or (atom G167785)
                      (progn (setq name (car G167785)) nil))
                  nil)
               (SEQ (EXIT (progn
                            (setq num
                                     (|chkAllNonNegativeInteger|
                                      (|htpLabelInputString| htPage
                                       (|htMakeLabel| "c"
                                        i))))
                            (setq |$cacheAlist|
                                     (ADDASSOC (intern name) num
                                      |$cacheAlist|))))))
             (cond
               ((setq n (LASSOC '|all| |$cacheAlist|))
                (setq |$cacheCount| n)
                (setq |$cacheAlist|
                         (|deleteAssoc| '|all| |$cacheAlist|))))
             (|htInitPage| "Cache Summary" nil)
             (|bcHt| "In general, interpreter functions ")
             (|bcHt| (cond
                       ((EQL |$cacheCount| 0)
                        '|will {\\em not} be cached.|)
                       (t (|bcHt| "cache ")
                        (|htAllOrNum| |$cacheCount|)
                        "} values.")))
             (|bcHt| "\\vspace{1}\\newline ")
             (cond
               (|$cacheAlist|
                   (DO ((G167801 |$cacheAlist| (cdr G167801))
                        (G167774 nil))
                       ((or (atom G167801)
                            (progn
                              (setq G167774 (car G167801))
                              nil)
                            (progn
                              (progn
                                (setq name (car G167774))
                                (setq val (CDR G167774))
                                G167774)
                              nil))
                        nil)
                     (SEQ (EXIT (cond
                                  ((NEQUAL val |$cacheCount|)
                                   (progn
                                     (|bcHt| "\\newline function {\\em ")
                                     (|bcHt| (|stringize| name))
                                     (|bcHt| "} will cache ")
                                     (|htAllOrNum| val)
                                     (|bcHt| "} values")))))))))
             (|htProcessDoitButton|
                 (cons "Press to Remove Page"
                       (cons "" (cons '|htDoNothing| nil))))
             (|htShowPage|))))))

\end{chunk}

\defun{htAllOrNum}{htAllOrNum}
\begin{chunk}{defun htAllOrNum}
(defun |htAllOrNum| (val)
  (|bcHt| (cond
            ((eq val '|all|) "{\\em all")
            ((eql val 0) "{\\em no")
            (t
             (CONCAT "the last {\\em "
                      (|stringize| val))))))

\end{chunk}

\defun{htCacheOne}{htCacheOne}
\begin{chunk}{defun htCacheOne}
(defun |htCacheOne| (names)
  (prog (page)
    (return
      (progn
        (setq page (|htInitPage| (|mkSetTitle|) nil))
        (|htpSetProperty| page '|names| names)
        (|htMakePage|
            '((|domainConditions|
                  (|Satisfies| ALLPI |chkAllPositiveInteger|))
              (|text| "Enter below a {\\em cache length}, a positive integer. "
                      "This number tells how many past values will "
                      "be cached. To cache all past values, "
                      "enter {\\em all}." "\\vspace{1}\\newline ")
              (|inputStrings|
                  ("Enter {\\em all} or a positive integer:" "" 5 10
                   |c1| ALLPI))))
        (|htSetvarDoneButton| "Select to Set Value"
            '|htCacheSet|)
        (|htShowPage|)))))

\end{chunk}

\defdollar{historyDisplayWidth}
\begin{chunk}{initvars}
(defvar |$historyDisplayWidth| 120) 

\end{chunk}

\defdollar{newline}
\begin{chunk}{initvars}
(defvar |$newline| #\Newline)

\end{chunk}

\defun{downlink}{downlink}
\begin{chunk}{defun downlink}
(defun |downlink| (page)
 (|htInitPage| "Bridge" nil)
 (|htSay| "\\replacepage{" page "}")
 (|htShowPage|))

\end{chunk}

\defun{dbNonEmptyPattern}{dbNonEmptyPattern}
\begin{chunk}{defun dbNonEmptyPattern}
(defun |dbNonEmptyPattern| (pattern)
  (cond
    ((null pattern) "*")
    (t (setq pattern (PRINC-TO-STRING pattern))
     (cond ((> (|#| pattern) 0) pattern) (t "*")))))

\end{chunk}

\defun{htSystemVariables,gn}{htSystemVariables,gn}
\begin{chunk}{defun htSystemVariables,gn}
(defun |htSystemVariables,gn| (t1 al)
 (let (class key options)
 (declare (special |$heading| |$levels|))
   (setq class (caddr t1))
   (setq key (cadddr t1))
   (setq options (cadr (cddddr t1)))
   (cond
    ((null (member class |$levels|)) al)
    ((or (or (eq key 'literals) (eq key 'integer))
         (eq key 'string))
      (cons (cons |$heading| t1) al))
    ((eq key 'tree)
      (|htSystemVariables,fn| options al nil))
    ((eq key 'function)
      (cons (cons |$heading| t1) al))
    (t (|systemError| key)))))

\end{chunk}

\defun{htSystemVariables,fn}{htSystemVariables,fn}
\begin{chunk}{defun htSystemVariables,fn}
(defun |htSystemVariables,fn| (t1 al firstTime)
  (declare (special |$heading|))
  (SEQ (if (atom t1) (EXIT al))
       (if firstTime (setq |$heading| (|opOf| (car t1))) nil)
       (EXIT (|htSystemVariables,fn| (cdr t1)
                 (|htSystemVariables,gn| (car t1) al) firstTime))))

\end{chunk}

\defun{htSystemVariables,displayOptions}{htSystemVariables,displayOptions}
\begin{chunk}{defun htSystemVariables,displayOptions}
(defun |htSystemVariables,displayOptions| (name class variable val options)
  (SEQ (if (eq class 'integer)
           (EXIT (SEQ (|htMakePage|
                          (cons (cons '|bcLispLinks|
                                      (cons
                                       (cons
                                        (cons
                                         (cons '|text|
                                          (cons (elt options 0)
                                           (cons "-"
                                            (cons
                                             (or (elt options 1)
                                              "")
                                             nil))))
                                         nil)
                                        (cons ""
                                         (cons
                                          '|htSetSystemVariableKind|
                                          (cons
                                           (cons variable
                                            (cons name
                                             (cons 'parse-integer nil)))
                                           nil))))
                                       nil))
                                nil))
                      (|htMakePage|
                          '((|domainConditions|
                                (|isDomain| INT (|Integer|)))))
                      (EXIT (|htMakePage|
       (list 
         (cons '|bcStrings| (list (list 5 (princ-to-string val) name 'int)))))))))
       (if (eq class 'string)
           (EXIT (|htSay| "{\\em " val
                          "}\\space{1}")))
       (EXIT (DO ((G167913 options (cdr G167913)) (x nil))
                 ((or (atom G167913)
                      (progn (setq x (car G167913)) nil))
                  nil)
               (SEQ (if (or (or (equal val x)
                                (and (eq val t)
                                     (eq x '|on|)))
                            (and (null val) (eq x '|off|)))
                        (EXIT (|htSay| "{\\em " x
                                       "}\\space{1}")))
                    (EXIT (|htMakePage|
                              (cons (cons '|bcLispLinks|
                                     (cons
                                      (cons x
                                       (cons " "
                                        (cons '|htSetSystemVariable|
                                         (cons
                                          (cons variable
                                           (cons x nil))
                                          nil))))
                                      nil))
                                    nil))))))))

\end{chunk}

\defun{htSystemVariables,functionTail}{htSystemVariables,functionTail}
\begin{chunk}{defun htSystemVariables,functionTail}
(defun |htSystemVariables,functionTail| (name class var valuesOrFunction)
  (prog (val)
    (return
      (SEQ (setq val (|eval| var))
           (if (atom valuesOrFunction)
               (EXIT (SEQ (|htMakePage|
                              '((|domainConditions|
                                    (|isDomain| STR (|String|)))))
                          (|htMakePage|
                              (cons (cons '|bcLinks|
                                     (cons
                                      (cons "reset"
                                       (cons ""
                                        (cons
                                         '|htSetSystemVariableKind|
                                         (cons
                                          (cons var
                                           (cons name (cons nil nil)))
                                          nil))))
                                      nil))
                                    nil))
                          (EXIT (|htMakePage|
                                    (cons
                                     (cons '|bcStrings|
                                      (cons
                                       (cons 30
                                        (cons (PRINC-TO-STRING val)
                                         (cons name
                                          (cons valuesOrFunction nil))))
                                       nil))
                                     nil))))))
           (EXIT (|htSystemVariables,displayOptions| name class
                     var val valuesOrFunction))))))

\end{chunk}

\defun{htSystemVariables}{htSystemVariables}
\begin{chunk}{defun htSystemVariables}
(defun |htSystemVariables| ()
  (prog (|$levels| |$heading| classlevel table heading name
         message key variable options func lastHeading
         t1 msg class var valuesOrFunction val)
    (DECLARE (SPECIAL |$levels| |$heading| |$setOptions| |$UserLevel|
                      |$fullScreenSysVars|))
    (return
      (SEQ (cond
             ((null |$fullScreenSysVars|) (|htSetVars|))
             (t (setq classlevel |$UserLevel|)
              (setq |$levels| '(|compiler| |development| |interpreter|))
              (setq |$heading| nil)
              (DO () ((NULL (NEQUAL classlevel (car |$levels|))) nil)
                (SEQ (EXIT (setq |$levels| (cdr |$levels|)))))
              (setq table
                       (NREVERSE
                           (|htSystemVariables,fn| |$setOptions| nil
                               t)))
              (|htInitPage| "System Variables" nil)
              (|htSay| "\\beginmenu")
              (setq lastHeading nil)
              (DO ((G167961 table (cdr G167961)) (G167879 nil))
                  ((or (atom G167961)
                       (progn (setq G167879 (car G167961)) nil)
                       (progn
                         (progn
                           (setq heading (car G167879))
                           (setq name (cadr G167879))
                           (setq message (caddr G167879))
                           (setq key (car (cddddr G167879)))
                           (setq variable (cadr (cddddr G167879)))
                           (setq options (caddr (cddddr G167879)))
                           (setq func (cadddr (cddddr G167879)))
                           G167879)
                         nil))
                   nil)
                (SEQ (EXIT (progn
                             (|htSay| "\\newline\\item ")
                             (cond
                               ((equal heading lastHeading)
                                (|htSay| "\\tab{8}"))
                               (t
                                (|htSay| heading
                                         "\\tab{8}")
                                (setq lastHeading heading)))
                             (|htSay| "{\\em " name
                                      '|}\\tab{22}| message)
                             (|htSay| "\\tab{80}")
                             (cond
                               ((eq key 'function)
                                (cond
                                  ((null options)
                                   (|htMakePage|
                                    (cons
                                     (cons '|bcLinks|
                                      (cons
                                       (cons "reset"
                                        (cons ""
                                         (cons func (cons nil nil))))
                                       nil))
                                     nil)))
                                  (t
                                   (setq t1 (car options))
                                   (setq msg (car t1))
                                   (setq class (cadr t1))
                                   (setq var (caddr t1))
                                   (setq valuesOrFunction (cadddr t1))
                                   (|htSystemVariables,functionTail|
                                    name class var valuesOrFunction)
                                   (DO
                                    ((G167971 (cdr options)
                                      (cdr G167971))
                                     (option nil))
                                    ((or (atom G167971)
                                      (progn
                                        (setq option (car G167971))
                                        nil))
                                     nil)
                                     (SEQ
                                      (EXIT
                                       (cond
                                         ((and (consp option)
                                           (eq (QCAR option)
                                            '|break|))
                                          '|skip|)
                                         (t
                                          (setq msg (car option))
                                          (setq class (cadr option))
                                          (setq var (caddr option))
                                          (setq valuesOrFunction 
                                            (cadddr option))
                                          (|htSay| "\\newline\\tab{22}"
                                           msg
                                           "\\tab{80}")
                                          (|htSystemVariables,functionTail|
                                           name class var
                                           valuesOrFunction)))))))))
                               (t (setq val (|eval| variable))
                                (|htSystemVariables,displayOptions|
                                    name key variable val options)))))))
              (|htSay| "\\endmenu") (|htShowPage|)))))))

\end{chunk}

\defun{htSetSystemVariableKind}{htSetSystemVariableKind}
\begin{chunk}{defun htSetSystemVariableKind}
(defun |htSetSystemVariableKind| (htPage arg)
 (let (variable name fun value)
  (setq variable (car arg))
  (setq name (cadr arg))
  (setq fun (caddr arg))
  (setq value (|htpLabelInputString| htPage name))
  (when (and (stringp value) fun) (setq value (funcall fun value)))
  (set variable value)
  (|htSystemVariables|)))

\end{chunk}

\defun{htSetSystemVariable}{htSetSystemVariable}
\begin{chunk}{defun htSetSystemVariable}
(defun |htSetSystemVariable| (htPage arg)
 (declare (ignore htPage))
 (let (name value)
   (setq name (car arg))
   (setq value (cadr arg))
   (setq value
    (cond
     ((eq value '|on|) t)
     ((eq value '|off|) nil)
     (t value)))
   (set name value)
   (|htSystemVariables|)))

\end{chunk}

\defun{htGloss}{htGloss}
\begin{chunk}{defun htGloss}
(defun |htGloss| (pattern)
  (|htGlossPage| nil
      (or (|dbNonEmptyPattern| pattern) "*") t))

\end{chunk}

\defun{htGlossPage}{htGlossPage}
\begin{chunk}{defun htGlossPage}
(defun |htGlossPage| (htPage pattern tryAgain?)
  (prog (|$wildCard| |$key| filter grepForm results defstream
         lines heading k tick)
    (declare (special |$wildCard| |$key| |$tick|))
    (return
      (SEQ (progn
             (setq |$wildCard| #\*)
             (cond
               ((equal pattern "*")
                (|downlink| '|GlossaryPage|))
               (t (setq filter (|pmTransFilter| pattern))
                (setq grepForm (|mkGrepPattern| filter '|none|))
                (setq |$key| '|none|)
                (setq results (|applyGrep| grepForm '|gloss|))
                (setq defstream
                         (make-instream
                             (CONCAT (getenviron "AXIOM")
                              "/algebra/glossdef.text")))
                (setq lines
                         (|gatherGlossLines| results defstream))
                (setq heading
                         (cond
                           ((equal pattern "")
                            "Glossary")
                           ((null lines)
                            (cons "No glossary items match {\\em "
                                  (cons pattern
                                        (cons "}" nil))))
                           (t
                            (cons "Glossary items matching {\\em "
                                  (cons pattern
                                        (cons "}" nil))))))
                (cond
                  ((null lines)
                   (cond
                     ((and tryAgain? (> (|#| pattern) 0))
                      (cond
                        ((equal
                             (elt pattern
                                  (setq k (MAXINDEX pattern)))
                             #\s)
                         (|htGlossPage| htPage
                             (SUBSTRING pattern 0 k) t))
                        ((upper-case-p (elt pattern 0))
                         (|htGlossPage| htPage (downcase pattern)
                             nil))
                        (t
                         (|errorPage| htPage
                             (cons "Sorry"
                                   (cons nil
                                    (cons
                                     (cons "\\centerline{"
                                      (append heading
                                       (cons "}" nil)))
                                     nil)))))))
                     (t
                      (|errorPage| htPage
                          (cons "Sorry"
                                (cons nil
                                      (cons
                                       (cons
                                        "\\centerline{"
                                        (append heading
                                         (cons "}" nil)))
                                       nil)))))))
                  (t (|htInitPageNoScroll| nil heading)
                   (|htSay| "\\beginscroll\\beginmenu")
                   (DO ((G168058 lines (cdr G168058))
                        (line nil))
                       ((or (atom G168058)
                            (progn (setq line (car G168058)) nil))
                        nil)
                     (SEQ (EXIT (progn
                                  (setq tick
                                           (|charPosition| |$tick|
                                            line 1))
                                  (|htSay|
                                 "\\item{\\em \\menuitemstyle{}}\\tab{0}{\\em "
                                           (|escapeString|
                                            (SUBSTRING line 0 tick))
                                           "} "
                                           (SUBSTRING line
                                            (1+ tick) nil))))))
                   (|htSay| "\\endmenu ")
                   (|htSay| "\\endscroll\\newline ")
                   (|htMakePage|
                       (cons (cons '|bcLinks|
                                   (cons
                                    (cons "Search"
                                     (cons ""
                                      (cons '|htGlossSearch|
                                       (cons nil nil))))
                                    nil))
                             nil))
                   (|htSay| " for glossary entry matching ")
                   (|htMakePage|
                       (cons (cons '|bcStrings|
                                   (cons
                                    (cons 24
                                     (cons "*"
                                      (cons '|filter| (cons 'em nil))))
                                    nil))
                             nil))
                   (|htShowPageNoScroll|))))))))))

\end{chunk}

\defun{gatherGlossLines}{gatherGlossLines}
\begin{chunk}{defun gatherGlossLines}
(defun |gatherGlossLines| (results defstream)
  (prog (n keyAndTick byteAddress line k pointer def x
         j nextPointer xtralines acc)
  (declare (special |$tick|))
    (return
      (SEQ (progn
             (setq acc nil)
             (DO ((G168098 results (cdr G168098))
                  (keyline nil))
                 ((or (atom G168098)
                      (progn (setq keyline (car G168098)) nil))
                  nil)
               (SEQ (EXIT (progn
                            (setq n
                                     (|charPosition| |$tick| keyline
                                      0))
                            (setq keyAndTick
                                     (SUBSTRING keyline 0
                                      (1+ n)))
                            (setq byteAddress
                                     (|string2Integer|
                                      (SUBSTRING keyline (1+ n)
                                       nil)))
                            (file-position defstream byteAddress)
                            (setq line (readline defstream))
                            (setq k
                                     (|charPosition| |$tick| line 1))
                            (setq pointer
                                     (SUBSTRING line 0 k))
                            (setq def
                                     (SUBSTRING line (1+ k)
                                      nil))
                            (setq xtralines nil)
                            (DO ()
                                ((null (and (null (eofp defstream))
                                        (setq x
                                         (readline defstream))
                                        (setq j
                                         (|charPosition| |$tick| x 1))
                                        (setq nextPointer
                                         (SUBSTRING x 0 j))
                                        (equal nextPointer
                                         pointer)))
                                 nil)
                              (SEQ (EXIT
                                    (setq xtralines
                                     (cons
                                      (SUBSTRING x (1+ j) nil)
                                      xtralines)))))
                            (setq acc
                                     (cons
                                      (CONCAT keyAndTick def
                                       (prog (G168110)
                                         (setq G168110 "")
                                         (return
                                           (DO
                                            ((G168115
                                              (NREVERSE xtralines)
                                              (CDR G168115))
                                             (G168081 nil))
                                            ((OR (ATOM G168115)
                                              (progn
                                                (setq G168081
                                                 (car G168115))
                                                nil))
                                             G168110)
                                             (SEQ
                                              (EXIT
                                               (setq G168110
                                                (CONCAT G168110
                                                 G168081))))))))
                                      acc))))))
             (reverse acc))))))

\end{chunk}

\defun{htGlossSearch}{htGlossSearch}
\begin{chunk}{defun htGlossSearch}
(defun |htGlossSearch| (htPage junk)
  (declare (ignore junk))
  (|htGloss| (|htpLabelInputString| htPage '|filter|)))

\end{chunk}

\defun{htGreekSearch}{htGreekSearch}
\begin{chunk}{defun htGreekSearch}
(defun |htGreekSearch| (filter)
  (prog (ss s names matches nonmatches)
    (return
      (SEQ (progn
             (setq ss (|dbNonEmptyPattern| filter))
             (setq s (|pmTransFilter| ss))
             (cond
               ((and (consp s) (eq (QCAR s) '|error|))
                (|bcErrorPage| s))
               ((null s)
                (|errorPage| nil
                    (cons (cons "Missing search string"
                                nil)
                          (cons nil
                                (cons
       "\\vspace{2}\\centerline{To select one of the greek letters:}\\newline "
                                      (cons
 "\\centerline{{\\em first} enter a search key into the input area}\\newline "
                                       (cons
 "\\centerline{{\\em then } move the mouse cursor to the work {\\em search} and click}"
                                        nil)))))))
               (t (setq filter (|patternCheck| s))
                (setq names
                         '(|alpha| |beta| |gamma| |delta| |epsilon|
                                   |zeta| |eta| |theta| |iota| |kappa|
                                   |lambda| |mu| |nu| |pi|))
                (DO ((G168149 names (CDR G168149)) (x nil))
                    ((or (atom G168149)
                         (progn (setq x (car G168149)) nil))
                     nil)
                  (cond
                               ((|superMatch?| filter (PNAME x))
                                (setq matches
                                         (cons x matches)))
                               (t
                                (setq nonmatches
                                         (cons x nonmatches)))))
                (setq matches (nreverse matches))
                (setq nonmatches (nreverse nonmatches))
                (|htInitPage| "Greek Names" nil)
                (cond
                  ((null matches)
                   (|htInitPage|
                       (cons  "Greek names matching search string {\\em "
                             (cons ss (cons "}" nil)))
                       nil)
 (|htSay| '|\\vspace{2}\\centerline{Sorry, but no greek letters match your search string}\\centerline{{\\em |
                            ss
                         '|}}\\centerline{Click on the up-arrow to try again}|)
                   (|htShowPage|))
                  (t
                   (|htInitPage|
                       (cons  "Greek letters matching search string {\\em "
                             (cons ss (cons "}" nil)))
                       nil)
                   (cond
                     (nonmatches
                         (|htSay|
                "The greek letters that {\\em match} your search string {\\em "
                                  ss "}:"))
                     (t
                      (|htSay| "Your search string {\\em "
                               ss
                               '|} matches all of the greek letters:|)))
                   (|htSay| "{\\em \\table{")
                   (DO ((G168158 matches (CDR G168158))
                        (x nil))
                       ((or (atom G168158)
                            (progn (setq x (car G168158)) nil))
                        nil)
                     (SEQ (EXIT (|htSay| "{" x
                                         "}"))))
                   (|htSay| "}}\\vspace{1}")
                   (cond
                     (nonmatches
                         (|htSay|   
"The greek letters that {\\em do not match} your search string:{\\em \\table{")
                         (DO ((G168167 nonmatches (CDR G168167))
                              (x nil))
                             ((or (atom G168167)
                                  (progn
                                    (setq x (car G168167))
                                    nil))
                              nil)
                           (SEQ (EXIT (|htSay| "{" x
                                       "}"))))
                         (|htSay| "}}")))
                   (|htShowPage|))))))))))

\end{chunk}

\defun{htTextSearch}{htTextSearch}
\begin{chunk}{defun htTextSearch}
(defun |htTextSearch| (filter)
  (prog (s lines matches nonmatches)
    (return
      (SEQ (progn
             (setq s
                      (|pmTransFilter| (|dbNonEmptyPattern| filter)))
             (cond
               ((and (consp s) (eq (QCAR s) '|error|))
                (|bcErrorPage| s))
               ((null s)
                (|errorPage| nil
                    (cons (cons "Missing search string"
                                nil)
                          (cons nil
                                (cons
       "\\vspace{2}\\centerline{To select one of the lines of text:}\\newline "
                                      (cons
  "\\centerline{{\\em first} enter a search key into the input area}\\newline "
                                       (cons
  "\\centerline{{\\em then } move the mouse cursor to the work {\\em search} and click}"
                                        nil)))))))
               (t (setq filter s)
                (setq lines
                         (cons
             "{{\\em Fruit flies} *like* a {\\em banana and califlower ears.}}"
                               (cons
                               "{{\\em Sneak Sears Silas with Savings Snatch}}"
                                     nil)))
                (DO ((G168191 lines (cdr G168191)) (x nil))
                    ((or (atom G168191)
                         (progn (setq x (car G168191)) nil))
                     nil)
                  (SEQ (EXIT (cond
                               ((|superMatch?| filter x)
                                (setq matches
                                         (cons x matches)))
                               (t
                                (setq nonmatches
                                         (cons x nonmatches)))))))
                (setq matches (NREVERSE matches))
                (setq nonmatches (NREVERSE nonmatches))
                (|htInitPage| "Text Matches" nil)
                (cond
                  ((null matches)
                   (|htInitPage|
                       (cons "Lines matching search string {\\em "
                             (cons s (cons "}" nil)))
                       nil)
                   (|htSay| 
'|\\vspace{2}\\centerline{Sorry, but no lines match your search string}\\centerline{{\\em |
                            s
                         '|}}\\centerline{Click on the up-arrow to try again}|)
                   (|htShowPage|))
                  (t
                   (|htInitPage|
                       (cons "Lines matching search string {\\em "
                             (cons s (cons "}" nil)))
                       nil)
                   (cond
                     (nonmatches
                         (|htSay| "The lines that {\\em match} your search string {\\em "
                                  s "}:"))
                     (t
                      (|htSay| "Your search string {\\em "
                               s '|} matches both lines:|)))
                   (|htSay| "{\\em \\table{")
                   (DO ((G168200 matches (CDR G168200))
                        (x nil))
                       ((or (atom G168200)
                            (progn (setq x (car G168200)) nil))
                        nil)
                     (SEQ (EXIT (|htSay| "{" x
                                         "}"))))
                   (|htSay| "}}\\vspace{1}")
                   (cond
                     (nonmatches
                         (|htSay|
       "The line that {\\em does not match} your search string:{\\em \\table{")
                         (DO ((G168209 nonmatches (cdr G168209))
                              (x nil))
                             ((or (atom G168209)
                                  (progn
                                    (setq x (car G168209))
                                    nil))
                              nil)
                           (SEQ (EXIT (|htSay| "{" x
                                       "}"))))
                         (|htSay| "}}")))
                   (|htShowPage|))))))))))

\end{chunk}

\defun{htTutorialSearch}{htTutorialSearch}
\begin{chunk}{defun htTutorialSearch}
(defun |htTutorialSearch| (pattern)
  (prog (s source target lines t1 name title)
    (return
      (SEQ (progn
             (setq s
                      (or (|dbNonEmptyPattern| pattern)
                          (return
                            (|errorPage| nil
                                (cons "Empty search key"
                                      (cons nil
                                       (cons
 "\\vspace{3}\\centerline{You must enter some search string"
                                        nil)))))))
             (setq s (|mkUnixPattern| s))
             (setq source "$AXIOM/doc/hypertex/pages/ht.db")
             (setq target "/tmp/temp.text.$SPADNUM")
             (OBEY (CONCAT "$AXIOM/lib/hthits"
                            " \"" s "\" "
                            source " > " target))
             (setq lines (|dbReadLines| '|temp|))
             (|htInitPageNoScroll| nil
                 (cons "Tutorial Pages mentioning {\\em "
                       (cons pattern (cons "}" nil))))
             (|htSay| "\\beginscroll\\table{")
             (DO ((G168241 lines (cdr G168241)) (line nil))
                 ((or (atom G168241)
                      (progn (setq line (car G168241)) nil))
                  nil)
               (SEQ (EXIT (progn
                            (setq t1 (|dbParts| line 3 0))
                            (setq name (car t1))
                            (setq title (cadr t1))
                            (|htSay| (cons "{\\downlink{"
                                      (cons title
                                       (cons "}{"
                                        (cons name
                                         (cons "}}" nil))))))))))
             (|htSay| "}")
             (|htShowPage|))))))

\end{chunk}

\defun{mkUnixPattern}{mkUnixPattern}
\begin{chunk}{defun mkUnixPattern}
(defun |mkUnixPattern| (s)
  (prog (starPositions k u)
  (declare (special |$wild|))
    (return
      (SEQ (progn
             (setq u (|mkUpDownPattern| s))
             (setq starPositions
                      (reverse (prog (G168264)
                                 (setq G168264 nil)
                                 (return
                                   (DO
                                    ((G168270
                                      (+ (- 1)
                                       (MAXINDEX u)))
                                     (i 1 (QSADD1 i)))
                                    ((QSGREATERP i G168270)
                                     (NREVERSE0 G168264))
                                     (SEQ
                                      (EXIT
                                       (cond
                                         ((equal (elt u i)
                                           |$wild|)
                                          (setq G168264
                                           (cons i G168264)))))))))))
             (DO ((G168277 starPositions (cdr G168277))
                  (i nil))
                 ((or (atom G168277)
                      (progn (setq i (car G168277)) nil))
                  nil)
               (SEQ (EXIT (setq u
                                   (CONCAT (SUBSTRING u 0 i)
                                    ".*"
                                    (SUBSTRING u (1+ i) nil))))))
             (cond
               ((NEQUAL (elt u 0) |$wild|)
                (setq u (CONCAT "[^a-zA-Z]" u)))
               (t (setq u (SUBSTRING u 1 nil))))
             (cond
               ((NEQUAL (elt u (setq k (MAXINDEX u))) |$wild|)
                (setq u (CONCAT u "[^a-zA-Z]")))
               (t (setq u (SUBSTRING u 0 k))))
             u)))))

\end{chunk}

\chapter{Browser Support Code}
\section{Pages Initiated from HyperDoc Pages}

\subsection{Search routines}

\defun{dKind}{dKind}
\begin{chunk}{defun dbKind 0}
(defun |dbKind| (line)
 (elt line 0))

\end{chunk}

\defun{checkFilter}{checkFilter}
\calls{checkFilter}{trimString}
\begin{chunk}{defun checkFilter}
(defun |checkFilter| (filter)
  (setq filter (princ-to-string filter))
  (if (string= filter "") 
   "*"
   (|trimString| filter)))

\end{chunk}

;concatWithBlanks r ==
;  r is [head,:tail] =>
;    tail => CONCAT(head,'" ",concatWithBlanks tail)
;    head
;  '""

\defun{concatWithBlanks}{Concatenate words with blanks}
\begin{chunk}{defun concatWithBlanks 0}
(defun |concatWithBlanks| (r)
 (if (consp r)
  (format nil "~{~a~^ ~}" r)
  ""))

\end{chunk}

\defun{conLowerCaseConTran}{Make constructor names lowercase}
\calls{conLowerCaseConTran}{hget}
\calls{conLowerCaseConTran}{ifcar}
\calls{conLowerCaseConTran}{conLowerCaseConTran}
\usesdollar{conLowerCaseConTran}{lowerCaseConTb}
\begin{chunk}{defun conLowerCaseConTran}
(defun |conLowerCaseConTran| (x)
 (declare (special |$lowerCaseConTb|))
 (cond
  ((identp x) (or (ifcar (hget |$lowerCaseConTb| x)) x))
  ((atom x) x)
  (t (loop for y in x collect (|conLowerCaseConTran| y)))))

\end{chunk}

\defun{string2Constructor}{string2Constructor}
\calls{string2Constructor}{downcase}
\calls{string2Constructor}{hget}
\calls{string2Constructor}{ifcar}
\usesdollar{string2Constructor}{lowerCaseConTb}
\begin{chunk}{defun string2Constructor}
(defun |string2Constructor| (x)
 (declare (special |$lowerCaseConTb|))
 (cond
  ((null (stringp x)) x)
  (t (or (ifcar (hget |$lowerCaseConTb| (intern (downcase x)))) x))))

\end{chunk}

\defvar{dbDelimiters}
\begin{chunk}{initvars}
(defvar |$dbDelimiters| (list #\space #\( #\) ))

\end{chunk}

\defun{dbString2Words}{String to words respecting delimiters}
This breaks a string into words respecting delimiters, so if
\begin{verbatim}
  $dbDelimiters = ( #\space #\( #\) )
\end{verbatim}
then
\begin{verbatim}
  (|dbString2Words| "now is (the) time")
  Value = ("now" "is" #\( "the" #\) "time")
\end{verbatim}
\calls{dbString2Words}{dbWordFrom}
\begin{chunk}{defun dbString2Words}
(defun |dbString2Words| (z)
  (loop
   with i = 0
   with pair = nil
   do (setq pair (|dbWordFrom| z i))
   while (and (consp pair) (= (length pair) 2)) ; dbWordFrom(l,i) is [w,i]]
   do (setq i (second pair))
   collect (first pair)))

\end{chunk}

\defun{dbWordFrom}{Next word respecting delimiters}
This returns the next word or the next delimiter. So given
\begin{verbatim}
     $dbDelimiters = ( #\space #\( #\) )
     (|dbWordFrom| "now is (the) time")

     (|dbWordFrom| b 0)   Value = ("now" 3)
     (|dbWordFrom| b 3)   Value = ("is" 6)
     (|dbWordFrom| b 6)   Value = (#\( 8)
     (|dbWordFrom| b 8)   Value = ("the" 11)
     (|dbWordFrom| b 11)  Value = (#\) 12)
     (|dbWordFrom| b 12)  Value = ("time" 17)
     (|dbWordFrom| b 17)  Value = NIL
\end{verbatim}
\calls{dbWordFrom}{maxindex}
\calls{dbWordFrom}{member}
\calls{dbWordFrom}{concat}
\usesdollar{dbWordFrom}{dbDelimiters}
\begin{chunk}{defun dbWordFrom}
(defun |dbWordFrom| (z i)
 (let (maxIndex c ch buf k g1)
 (declare (special |$dbDelimiters|))
  (setq maxIndex (maxindex z))
  (loop while (and (>= maxIndex i) (char= (elt z i) #\space)) do (incf i))
  (if (and (>= maxIndex i) (|member| (elt z i) |$dbDelimiters|))
    (list (elt z i) (+ i 1))
    (progn
     (setq k 
      (do ((g2 nil g1) (j i (+ j 1)))
           ((or g2 (> j maxIndex)) g1)
        (unless (|member| (elt z j) |$dbDelimiters|) (setq g1 (or g1 j)))))
     (when k
      (setq buf "")
      (do ()
          ((null (and (<= k maxIndex)
                      (null (|member| (setq c (elt z k)) |$dbDelimiters|))))
                  nil)
       (setq ch (if (char= c #\_) (elt z (setq k (+ 1 k))) c))
       (setq buf (concat buf ch))
       (setq k (+ k 1)))
      (list buf k))))))

\end{chunk}

This creates a page for any cat, dom, package, default package
\begin{verbatim}
constructors Cname\#\E\sig \args   \abb \comments (C is C, D, P, X)
\end{verbatim}
There are 8 parts of an htPage:
\begin{enumerate}
\item kind
\item name
\item nargs
\item xflag
\item sig
\item args
\item abbrev
\item comments
\end{enumerate}

\calls{kPage}{dbXParts}
\calls{kPage}{mkConform}
\calls{kPage}{opOf}
\calls{kPage}{capitalize}
\calls{kPage}{ncParseFromString}
\calls{kPage}{dbSourceFile}
\calls{kPage}{dbConformGenUnder}
\calls{kPage}{concat}
\calls{kPage}{isExposedConstructor}
\calls{kPage}{htInitPageNoScroll}
\calls{kPage}{htAddHeading}
\calls{kPage}{htSayStandard}
\calls{kPage}{htpSetProperty}
\calls{kPage}{dbShowConsDoc1}
\calls{kPage}{addParameterTemplates}
\calls{kPage}{htSay}
\calls{kPage}{htSayStandard}
\calls{kPage}{kPageContextMenu}
\calls{kPage}{htShowPageNoScroll}
\usesdollar{kPage}{atLeastOneUnexposed}
\usesdollar{kPage}{conformsAreDomains}
\begin{chunk}{defun kPage}
(defun |kPage| (&rest a1)
 (let (parts name nargs sig args form isFile kind 
       conform conname capitalKind signature sourceFileName constrings 
       emString heading page options line)
  (declare (special |$conformsAreDomains| |$atLeastOneUnexposed|))
   (setq line (car a1))
   (setq options (cdr a1))
   ; constructors Cname\#\E\sig \args   \abb \comments (C is C, D, P, X)
   (setq parts (|dbXParts| line 7 1))
   (setq kind (first parts))
   (setq name (second parts))
   (setq nargs (third parts))
   (setq sig (fifth parts))
   (setq args (sixth parts))
   (setq form (ifcar options))
   (setq isFile (null kind))
   (setq kind (or kind "package"))
   (rplaca parts kind)
   (setq conform (|mkConform| kind name args))
   (setq conname (|opOf| conform))
   (setq capitalKind (|capitalize| kind))
   (setq signature (|ncParseFromString| sig))
   (setq sourceFileName (|dbSourceFile| (intern name)))
   (setq constrings
     (if (ifcdr form)
      (|dbConformGenUnder| form)
      (list (concat name args))))
   (setq emString (cons "{\\sf " (append constrings (list "}"))))
   (setq heading (cons capitalKind (cons " " emString)))
   (unless (|isExposedConstructor| conname)
     (setq heading (cons "Unexposed " heading)))
   (setq page (|htInitPageNoScroll| NIL))
   (|htAddHeading| heading)
   (|htSayStandard| '|\\beginscroll |)
   (|htpSetProperty| page '|isFile| t)
   (|htpSetProperty| page '|parts| parts)
   (|htpSetProperty| page '|heading| heading)
   (|htpSetProperty| page '|kind| kind)
   (|htpSetProperty| page '|conform| conform)
   (|htpSetProperty| page '|signature| signature)
   ; what follows is stuff from kiPage with domain = nil
   (setq |$conformsAreDomains| nil)
   (|dbShowConsDoc1| page conform nil)
   (when (and (nequal kind '|category|) (> nargs 0))
     (|addParameterTemplates| page conform))
   (when |$atLeastOneUnexposed|
     (|htSay| "\\newline{}{\\em *} = unexposed"))
   (|htSayStandard| '|\\endscroll |)
   (|kPageContextMenu| page)
   (|htShowPageNoScroll|)))

\end{chunk}

\defun{cSearch}{Hyperdoc category search}
\calls{cSearch}{constructorSearch}
\begin{chunk}{defun cSearch}
(defun |cSearch| (filter)
  (|constructorSearch| (|checkFilter| filter) '|c| "category"))

\end{chunk}

\defun{pSearch}{Hyperdoc default domain search}
\calls{pSearch}{constructorSearch}
\begin{chunk}{defun xSearch}
(defun |xSearch| (filter)
  (|constructorSearch| (|checkFilter| filter) '|x| "default package"))

\end{chunk}

\defun{dSearch}{Hyperdoc domain search}
\calls{dSearch}{constructorSearch}
\begin{chunk}{defun dSearch}
(defun |dSearch| (filter)
  (|constructorSearch| (|checkFilter| filter) '|d| "domain"))

\end{chunk}

\defun{pSearch}{Hyperdoc package search}
\calls{pSearch}{constructorSearch}
\begin{chunk}{defun pSearch}
(defun |pSearch| (filter)
  (|constructorSearch| (|checkFilter| filter) '|p| "package"))

\end{chunk}

\defun{kSearch}{Hyperdoc constructor search}
\calls{kSearch}{constructorSearch}
\begin{chunk}{defun kSearch}
(defun |kSearch| (filter)
  (|constructorSearch| (|checkFilter| filter) '|k| "constructor"))

\end{chunk}

\defun{ySearch}{Hyperdoc default constructor search}
\calls{ySearch}{constructorSearch}
\begin{chunk}{defun ySearch}
(defun |ySearch| (filter)
  (|constructorSearch| (|checkFilter| filter) '|y| "constructor"))

\end{chunk}

\defun{dbRead}{Read libdb.text at file-position n}
\begin{chunk}{defun dbRead 0}
(defun |dbRead| (n)
  (with-open-file 
     (instream (concat (getenviron "AXIOM") "/algebra/libdb.text"))
   (file-position instream n)
   (read-line instream)))

\end{chunk}

\defun{libdbTrim}{String trim with newlines removed}
\begin{chunk}{defun libdbTrim 0}
(defun |libdbTrim| (s)
  (string-trim '(#\space #\tab #\newline) (substitute #\space #\newline s)))

\end{chunk}

\defun{constructorSearch}{Hyperdoc common constructor search}
\calls{constructorSearch}{dbKind}
\calls{constructorSearch}{conSpecialString?}
\calls{constructorSearch}{conPage}
\calls{constructorSearch}{lassoc}
\calls{constructorSearch}{downcase}
\calls{constructorSearch}{downlink}
\calls{constructorSearch}{kPage}
\calls{constructorSearch}{htInitPage}
\calls{constructorSearch}{htpSetProperty}
\calls{constructorSearch}{dbName}
\calls{constructorSearch}{htQuery}
\calls{constructorSearch}{htShowPage}
\calls{constructorSearch}{grepSearchQuery}
\calls{constructorSearch}{constructorSearchGrep}
\usesdollar{constructorSearch}{lowerCaseConTb}
\begin{chunk}{defun constructorSearch}
(defun |constructorSearch| (filter key kind)
 (let (parse pageName name u line newkind page message)
 (declare (special |$lowerCaseConTb|))
  (cond
   ((null filter) nil)
   ((setq parse (|conSpecialString?| filter)) (|conPage| parse))
   ((setq pageName
     (lassoc (downcase filter)
       '(("union" . |DomainUnion|)
         ("record" . |DomainRecord|)
         ("mapping" . |DomainMapping|)
         ("enumeration" . |DomainEnumeration|))))
         (|downlink| pageName))
   (t
    (setq name (if (stringp filter) (intern filter) filter))
    (when (setq u (hget |$lowerCaseConTb| name))
      (setq filter (princ-to-string (car u))))
    (cond
      ((setq line (|conPageFastPath| (downcase filter)))
        (setq newkind
         (case (|dbKind| line)
          (#\p "package")
          (#\d "domain")
          (#\c "category")))
        (cond
         ((or (equal kind "constructor") (equal kind newkind))
           (|kPage| line))
         (t
           (setq page (|htInitPage| "Query Page" nil))
           (|htpSetProperty| page '|line| line)
           (setq message
             (list "{\\em " (|dbName| line) "} is not a {\\em " kind 
                   "} but a {\\em " newkind 
                   "}. Would you like to view it?\\vspace{1}" ))
           (|htQuery| message '|grepConstructorSearch| 't)
           (|htShowPage|))))
      ((equal filter "*")
        (|grepSearchQuery| kind
          (list filter key kind '|constructorSearchGrep| )))
      (t (|constructorSearchGrep| filter key kind)))))))

\end{chunk}

\defun{conSpecialString?}{conSpecialString?}
\calls{conSpecialString?}{ifcar}
\calls{conSpecialString?}{string2Words}
\calls{conSpecialString?}{ncParseFromString}
\calls{conSpecialString?}{member}
\calls{conSpecialString?}{conLowerCaseConTran}
\calls{conSpecialString?}{contained}
\calls{conSpecialString?}{kisValidType}
\calls{conSpecialString?}{concat}
\calls{conSpecialString?}{dbString2Words}
\calls{conSpecialString?}{string2Constructor}
\calls{conSpecialString?}{conSpecialString?}
\begin{chunk}{defun conSpecialString?}
(defun |conSpecialString?| (&REST a1 &AUX options filter)
 (let (secondTime t1 words parse form u)
  (setq filter (car a1))
  (setq options (cdr a1))
  (setq secondtime (ifcar options))
  (setq t1 (|string2Words| filter))
  (setq parse
   (cond
    ((and (consp t1) (not (qcdr t1))) ; t1 is [s]
      (setq words (|ncParseFromString| (qcar t1))))
    ((every #'(lambda (x) (null (|member| x '("and" "or" "not")))) words)
      (|ncParseFromString| filter))))
  (cond
   ((null parse) nil)
   (t
    (setq form (|conLowerCaseConTran| parse))
    (cond
     ((or (member (ifcar form) '(|and| |or| |not|)) (contained '* form)) nil)
     ((equal filter "Mapping") nil)
     ((setq u (|kisValidType| form)) u)
     (secondTime nil)
     (t
      (setq u
       (reduce #'concat
        (loop for x in (|dbString2Words| filter) 
              collect (|string2Constructor| x))))
      (|conSpecialString?| u t)))))))

\end{chunk}

\subsection{Page construction}
\defun{conPage}{conPage}
\calls{conPage}{form2HtString}
\calls{conPage}{downcase}
\calls{conPage}{lassq}
\calls{conPage}{downlink}
\calls{conPage}{conPageFastPath}
\calls{conPage}{kPage}
\calls{conPage}{ySearch}
\usesdollar{conPage}{conArgstrings}
\begin{chunk}{defun conPage}
(defun |conPage| (a &rest b)
 (let (|$conArgstrings| form da pageName line)
 (declare (special |$conArgstrings|))
  ; the next 4 lines allow e.g. MATRIX INT ==> Matrix Integer (see kPage)
  (setq form (if (atom a) (cons a b) a))
  (setq |$conArgstrings| (loop for x in (ifcdr a) collect (|form2HtString| x)))
  (cond ((null (atom a)) (setq a (car a))))
  (setq da (downcase a))
  (cond
    ((setq pageName
      (lassq da
        '((|type| . |CategoryType|)
          (|union| . |DomainUnion|)
          (|record| . |DomainRecord|)
          (|mapping| . |DomainMapping|)
          (|enumeration| . |DomainEnumeration|))))
       (|downlink| pageName))
    ((setq line (|conPageFastPath| da)) ; lower case name of cons?
      (|kPage| line form))
    ((setq line (|conPageFastPath| (upcase a))) ; upper case an abbrev?
      (|kPage| line form))
    (t (|ySearch| a))))) ; slow search (include default packages)

\end{chunk}

\defun{conPageFastPath}{gets line quickly for constructor name or abbreviation}
\calls{conPageFastPath}{length}
\calls{conPageFastPath}{charPosition}
\calls{conPageFastPath}{lassq}
\calls{conPageFastPath}{dbRead}
\calls{conPageFastPath}{conPageConEntry}
\usesdollar{conPageFastPath}{lowerCaseConTb}
\begin{chunk}{defun conPageFastPath}
(defun |conPageFastPath| (x)
 (let (s name entry lineNumber)
 (declare (special |$lowerCaseConTb|))
  (setq s (princ-to-string x))
  (unless (> (|#| s) (|charPosition| #\* s 0)) ; quit if name has * in it
    (setq name (cond ((stringp x) (intern x)) (t x)))
    (setq entry (hget |$lowerCaseConTb| name))
    (when entry
      ;'dbLineNumbers property is set by function dbAugmentConstructorDataTable
      (if (setq lineNumber (lassq '|dbLineNumber| (cddr entry)))
        (|dbRead| lineNumber)
        (|conPageConEntry| (car entry)))))))

\end{chunk}

\defun{conPageConEntry}{conPageConEntry}
\seebook{conPageConEntry}{buildLIbdbConEntry}{9}
\usesdollar{conPageConEntry}{conname}
\usesdollar{conPageConEntry}{conform}
\usesdollar{conPageConEntry}{exposed?}
\usesdollar{conPageConEntry}{doc}
\usesdollar{conPageConEntry}{kind}
\begin{chunk}{defun conPageConEntry}
(defun |conPageConEntry| (entry)
 (let (|$conname| |$conform| |$exposed?| |$doc| |$kind|)
 (declare (special |$conname| |$conform| |$exposed?| |$doc| |$kind|))
  (setq |$conname| nil)
  (setq |$conform| nil)
  (setq |$exposed?| nil)
  (setq |$doc| nil)
  (setq |$kind| nil)
  (|buildLibdbConEntry| entry)))

\end{chunk}

\defun{kdPageInfo}{kdPageInfo}
\calls{kdPageInfo}{htSay}
\calls{kdPageInfo}{nequal}
\calls{kdPageInfo}{bcHt}
\calls{kdPageInfo}{htSayStandard}
\calls{kdPageInfo}{kPageArgs}
\calls{kdPageInfo}{length}
\calls{kdPageInfo}{extractFileNameFromPath}
\calls{kdPageInfo}{subseq}
\calls{kdPageInfo}{getdatabase}
\calls{kdPageInfo}{htSay}
\calls{kdPageInfo}{htMakePage}
\begin{chunk}{defun kdPageInfo}
(defun |kdPageInfo| (name abbrev nargs conform signature file?)
 (let (sourceFileName filename)
  (|htSay| '|{\\sf | name "}")
  (when (nequal abbrev name) (|bcHt| (list '| has abbreviation | abbrev)))
  (when file? (|bcHt| (list " is a source file.")))
  (cond
    ((eql nargs 0)
      (when (nequal abbrev name) (|bcHt| ".")))
    (t
     (when (nequal abbrev name) (|bcHt| " and"))
     (|bcHt| 
      (if (eql nargs 1)
        " takes one argument:"
        (list '| takes | (princ-to-string nargs) '| arguments:|)))))
  (|htSayStandard| "\\indentrel{2}")
  (when (> nargs 0) (|kPageArgs| conform signature))
  (|htSayStandard| "\\indentrel{-2}")
  (when (char= (elt name (1- (|#| name))) #\&)
    (setq name (subseq name 0 (1- (|#| name)))))
  (setq sourceFileName (getdatabase (intern name) 'sourcefile))
  (setq filename (|extractFileNameFromPath| sourceFileName))
  (when (nequal filename "")
    (|htSayStandard| "\\newline{}")
    (|htSay| "The source code for the constructor is found in "))
  (|htMakePage|
    (list (list '|text| "\\unixcommand{" filename "}{\\$AXIOM/lib/SPADEDIT " 
                sourceFileName " " name "}")))
  (when (nequal nargs 0) (|htSay| "."))))

\end{chunk}

\defun{kArgPage}{kArgPage}
\calls{kArgPage}{htpProperty}
\calls{kArgPage}{getConstructorModemap}
\calls{kArgPage}{position}
\calls{kArgPage}{sublisFormal}
\calls{kArgPage}{mkDomTypeForm}
\calls{kArgPage}{domainDescendantsOf}
\calls{kArgPage}{htpSetProperty}
\calls{kArgPage}{dbShowCons}
\begin{chunk}{defun kArgPage}
(defun |kArgPage| (htPage arg)
 (let (conform op args domname source n typeForm domTypeForm descendants rank)
  (setq conform (|htpProperty| htPage '|conform|))
  (setq op (car conform))
  (setq args (cdr conform))
  (setq domname (|htpProperty| htPage '|domname|))
  (setq source (cddar (|getConstructorModemap| op)))
  (setq n (|position| arg args))
  (setq typeForm (|sublisFormal| args (elt source n)))
  (setq domTypeForm (|mkDomTypeForm| typeForm conform domname))
  (setq descendants (|domainDescendantsOf| typeForm domTypeForm))
  (|htpSetProperty| htPage '|cAlist| descendants)
  (setq rank
    (unless (> n 4) (elt '(|First| |Second| |Third| |Fourth| |Fifth|) n)))
  (|htpSetProperty| htPage '|rank| rank)
  (|htpSetProperty| htPage '|thing| "argument")
  (|dbShowCons| htPage '|names|)))

\end{chunk}

\defun{mkDomTypeForm}{mkDomTypeForm}
\calls{mkDomTypeForm}{sublislis}
\calls{mkDomTypeForm}{mkDomTypeForm}
\calls{mkDomTypeForm}{hasIndent}
\begin{chunk}{defun mkDomTypeForm}
(defun |mkDomTypeForm| (typeForm conform domname)
 (cond
   (domname (sublislis (cdr domname) (cdr conform) typeForm))
   ((and (consp typeForm) (eq (qcar typeForm) '|Join|))
     (cons '|Join|
      (loop for t1 in (qcdr typeForm) collect
        (|mkDomTypeForm| t1 conform domname))))
   ((null (|hasIdent| typeForm)) typeForm)))

\end{chunk}

\defun{domainDescendantsOf}{domainDescendantsOf}
\calls{domainDescendantsOf}{systemError}
\calls{domainDescendantsOf}{simpHasPred}
\calls{domainDescendantsOf}{quickAnd}
\calls{domainDescendantsOf}{domainsOf}
\calls{domainDescendantsOf}{ifcdr}
\calls{domainDescendantsOf}{qcar}
\calls{domainDescendantsOf}{qcdr}
\calls{domainDescendantsOf}{assoc}
\calls{domainDescendantsOf}{listSort}
\calls{domainDescendantsOf}{function}
\calls{domainDescendantsOf}{delete}
\begin{chunk}{defun domainDescendantsOf}
(defun |domainDescendantsOf| (conform domform)
 (labels (
  (catScreen (r alist)
   (let (t1 item pred pred1 npred)
    (dolist (x r)
     (unless (and (consp x) (member (qcar x) '(attribute signature)))
       (|systemError| x))
     (setq alist
      (dolist (anitem alist (nreverse0 t1))
        (setq item (car anitem))
        (setq pred (cdr anitem))
        (when (and
                (setq pred1 (|simpHasPred| (list '|has| item x)))
                (setq npred (|quickAnd| pred1 pred)))
              (setq t1 (cons (cons item npred) t1))))))
    alist))
  ; keep only those domains that appear in ALL parts of Join
  (jfn (arg domlist)
   (let (y r item pred u keepList alist)
    (setq y (car arg))
    (setq r (cdr arg))
    (setq alist (|domainsOf| y (ifcar domlist)))
    (dolist (x r)
      (setq domlist (ifcdr domlist))
      (when (and (consp x) (eq (qcar x) 'category) (consp (qcdr x)))
        (setq alist (catScreen (cddr x) alist)))
      (setq keepList nil)
      (dolist (dom (|domainsOf| x (ifcar domlist)))
        (setq item (car dom))
        (setq pred (cdr dom))
        (when (setq u (|assoc| item alist))
          (setq keepList 
           (cons (cons item (|quickAnd| (cdr u) pred)) keepList))))
      (setq alist keepList))
    (dolist (pair alist)
      (rplacd pair (|simpHasPred| (cdr pair))))
    (|listSort| #'glesseqp alist))))
  (if (consp conform)
    (cond
      ((eq (qcar conform) '|Join|)
        (jfn
          (|delete| '(|Type| object) (qcdr conform))
          (|delete| '(|Type| object) (ifcdr domform))))
      ((eq (qcar conform) 'category) nil)
      (t (|domainsOf| conform domform)))
    (|domainsOf| conform domform))))

\end{chunk}

\section{Branches of Constructor Page}

\defun{kiPage}{kiPage}
\calls{kiPage}{htpProperty}
\calls{kiPage}{mkConform}
\calls{kiPage}{kDomainName}
\calls{kiPage}{errorPage}
\calls{kiPage}{capitalize}
\calls{kiPage}{htInitPage}
\calls{kiPage}{htCopyProplist}
\calls{kiPage}{dbShowConsDoc1}
\calls{kiPage}{htShowPage}
\usesdollar{kiPage}{conformsAreDomains}
\begin{chunk}{defun kiPage}
(defun |kiPage| (htPage junk)
 (declare (ignore junk))
 (let (lt1 kind name nargs args conform domname heading page)
  (declare (special |$conformsAreDomains|))
   (setq lt1 (|htpProperty| htPage '|parts|))
   (setq kind (first lt1))
   (setq name (second lt1))
   (setq nargs (third lt1))
   (setq args (sixth lt1))
   (setq conform (|mkConform| kind name args))
   (setq domname (|kDomainName| htPage kind name nargs))
   (cond
     ((and (consp domname) (eq (qcar domname) '|error|))
           (|errorPage| htPage domname))
     (t
      (setq heading
        (list "Description of " (|capitalize| kind) " {\\sf " name args "}"))
      (setq page (|htInitPage| heading (|htCopyProplist| htPage)))
      (setq |$conformsAreDomains| domname)
      (|dbShowConsDoc1| htPage conform nil)
      (|htShowPage|)))))

\end{chunk}

\defun{kePage}{kePage}
\calls{kePage}{htpProperty}
\calls{kePage}{concat}
\calls{kePage}{kDomainName}
\calls{kePage}{errorPage}
\calls{kePage}{htpSetProperty}
\calls{kePage}{mkConform}
\calls{kePage}{opOf}
\calls{kePage}{capitalize}
\calls{kePage}{form2HtString}
\calls{kePage}{sublisFormal}
\calls{kePage}{ifcdr}
\calls{kePage}{getConstructorExports}
\calls{kePage}{simpHasPred}
\calls{kePage}{pluralSay}
\calls{kePage}{length}
\calls{kePage}{htInitPage}
\calls{kePage}{htCopyProplist}
\calls{kePage}{htSayStandard}
\calls{kePage}{htpSetProperty}
\calls{kePage}{htMakePage}
\calls{kePage}{menuButton}
\calls{kePage}{htSay}
\calls{kePage}{bcConPredTable}
\calls{kePage}{htBigSkip}
\calls{kePage}{kePageDisplay}
\calls{kePage}{kePageOpAlist}
\calls{kePage}{htSowPage}
\usesdollar{kePage}{confomrsAreDomains}
\begin{chunk}{defun kePage}
(defun |kePage| (htPage junk)
 (declare (ignore junk))
 (let (|$conformsAreDomains| lt1 kind name nargs args constring domname
        conform conname heading data conlist attrlist oplist prefix page)
  (declare (special |$conformsAreDomains|))
   (setq lt1 (|htpProperty| htPage '|parts|))
   (setq kind (first lt1))
   (setq name (second lt1))
   (setq nargs (third lt1))
   (setq args (sixth lt1))
   (setq constring (concat name args))
   (setq domname (|kDomainName| htPage kind name nargs))
   (cond
    ((and (consp domname) (eq (qcar domname) '|error|))
      (|errorPage| htPage domname))
    (t 
      (|htpSetProperty| htPage '|domname| domname)
      (setq |$conformsAreDomains| domname)
      (setq conform (|mkConform| kind name args))
      (setq conname (|opOf| conform))
      (setq heading
       (list (|capitalize| kind) " {\\sf "
           (if domname (|form2HtString| domname nil t) constring) "}" ))
      (setq data
        (|sublisFormal|
          (or (ifcdr domname) (cdr conform))
          (|getConstructorExports| (or domname conform) t)))
      (setq conlist (car data))
      (setq attrlist (cadr data))
      (setq oplist (cddr data))
      (when domname
       (dolist (x conlist)  (rplac (cdr x)  (|simpHasPred| (cdr x))))
       (dolist (x attrlist) (rplac (cddr x) (|simpHasPred| (cddr x))))
       (dolist (x oplist)   (rplac (cddr x) (|simpHasPred| (cddr x)))))
      (setq prefix
       (|pluralSay| (+ (+ (|#| conlist) (|#| attrlist)) (|#| oplist))
                    "Export" "Exports"))
      (setq page
       (|htInitPage| (append prefix (cons " of " heading))
                     (|htCopyProplist| htPage)))
      (|htSayStandard| "\\beginmenu ")
      (|htpSetProperty| page '|data| data)
      (when conlist
        (|htMakePage|
          (list
           (list '|bcLinks|
            (list (|menuButton|) "" '|dbShowCons1| conlist '|names|))))
        (|htSayStandard| "\\tab{2}")
        (|htSay| "All attributes and operations from:")
        (|bcConPredTable| conlist (|opOf| conform) (cdr conform)))
      (when attrlist
        (when conlist (|htBigSkip|))
        (|kePageDisplay| page "attribute" (|kePageOpAlist| attrlist)))
      (when oplist
        (when (or conlist attrlist) (|htBigSkip|))
        (|kePageDisplay| page "operation" (|kePageOpAlist| oplist)))
      (|htSayStandard| " \\endmenu ")
      (|htShowPage|)))))

\end{chunk}

\defun{kePageOpAlist}{kePageOpAlist}
\calls{kePageOpAlist}{lassoc}
\calls{kePageOpAlist}{insertAlist}
\calls{kePageOpAlist}{zeroOneConvert}
\begin{chunk}{defun kePageOpAlist}
(defun |kePageOpAlist| (oplist)
 (let (op sig pred u opAlist)
  (dolist (item oplist)
    (setq op (car item))
    (setq sig (cadr item))
    (setq pred (cddr item))
    (setq u (lassoc op opAlist))
    (setq opAlist
     (|insertAlist| (|zeroOneConvert| op)
                    (cons (list sig pred) u)
                    opAlist)))
   opAlist))

\end{chunk}

\defun{kePageDisplay}{kePageDisplay}
\calls{kePageDisplay}{length}
\calls{kePageDisplay}{htpSetProperty}
\calls{kePageDisplay}{htMakePage}
\calls{kePageDisplay}{menuButton}
\calls{kePageDisplay}{htSayStandard}
\calls{kePageDisplay}{htSay}
\calls{kePageDisplay}{pluralize}
\calls{kePageDisplay}{dbGatherData}
\calls{kePageDisplay}{dbSowOpItems}
\begin{chunk}{defun kePageDisplay}
(defun |kePageDisplay| (htPage which opAlist)
 (let (count total expandProperty data)
  (setq count (|#| opAlist))
  (cond
   ((eql count 0) nil)
   (t
    (setq total
     (apply #'+ (loop for entry in opAlist collect (|#| (cdr entry)))))
    (if (string= which "operation")
      (|htpSetProperty| htPage '|opAlist| opAlist)
      (|htpSetProperty| htPage '|attrAlist| opAlist))
    (setq expandProperty
     (if (string= which "operation") 
       '|expandOperations|
       '|expandAttributes|))
    (|htpSetProperty| htPage expandProperty '|lists|)
    (|htMakePage|
     (list
      (list '|bcLinks| (list (|menuButton|) "" '|dbShowOps| which '|names|))))
    (|htSayStandard| "\\tab{2}")
    (unless (= count total)
      (if (eql count 1)
       (|htSay| "1 name for ")
       (|htSay| (princ-to-string count) " names for ")))
    (if (> total 1)
      (|htSay| (princ-to-string total) " " (|pluralize| which) 
               " are explicitly exported:")
      (|htSay| "1 " which " is explicitly exported:"))
    (setq data (|dbGatherData| htPage opAlist which '|names|))
    (|dbShowOpItems| which data nil)))))

\end{chunk}

\defun{ksPage}{ksPage}
\calls{ksPage}{htpProperty}
\calls{ksPage}{kDomainName}
\calls{ksPage}{errorPage}
\calls{ksPage}{form2HtString}
\calls{ksPage}{htpSetProperty}
\calls{ksPage}{htInitPageNoScroll}
\calls{ksPage}{htCopyProplist}
\calls{ksPage}{htSay}
\calls{ksPage}{htSayStandard}
\calls{ksPage}{dbSearchOrder}
\calls{ksPage}{dbShowCons}
\begin{chunk}{defun ksPage}
(defun |ksPage| (htPage junk)
 (declare (ignore junk))
 (let (lt1 kind name nargs domname heading domain conform page u)
  (setq lt1 (|htpProperty| htPage '|parts|))
  (setq kind (first lt1))
  (setq name (second lt1))
  (setq nargs (third lt1))
  (setq domname (|kDomainName| htPage kind name nargs))
  (cond
   ((and (consp domname) (eq (qcar domname) '|error|))
     (|errorPage| htPage domname))
   (t
     (setq heading
      (if (null domname)
        (|htpProperty| htPage '|heading|)
        (list "{\\sf " (|form2HtString| domname nil t) "}")))
     (when domname
       (|htpSetProperty| htPage '|domname| domname)
       (|htpSetProperty| htPage '|heading| heading))
     (setq domain (unless (string= kind "category") (eval domname)))
     (setq conform (|htpProperty| htPage '|conform|))
     (setq page
      (|htInitPageNoScroll| (|htCopyProplist| htPage)
        (cons "Search order for " heading)))
     (|htSay| (concat 
       "When an operation is not defined by the domain, the following "
       "domains are searched in order for a \"default definition"))
     (|htSayStandard| "\\beginscroll ")
     (setq u (|dbSearchOrder| conform domname domain))
     (|htpSetProperty| htPage '|cAlist| u)
     (|htpSetProperty| htPage '|thing| "constructor")
     (|dbShowCons| htPage '|names|)))))

\end{chunk}

\defun{dbSearchOrder}{dbSearchOrder}
\calls{dbSearchOrder}{opOf}
\calls{dbSearchOrder}{dbInfovec}
\calls{dbSearchOrder}{getdatabase}
\calls{dbSearchOrder}{simpCatPredicate}
\calls{dbSearchOrder}{sublislis}
\calls{dbSearchOrder}{kTestPred}
\calls{dbSearchOrder}{devaluate}
\calls{dbSearchOrder}{kFormatSlotDomain}
\calls{dbSearchOrder}{dbSubConform}
\calls{dbSearchOrder}{dbAddChain}
\usesdollar{dbSearchOrder}{domain}
\usesdollar{dbSearchOrder}{infovec}
\usesdollar{dbSearchOrder}{predvec}
\begin{chunk}{defun dbSearchOrder}
(defun |dbSearchOrder| (conform domname |$domain|)
 (declare (special |$domain|))
 (let (|$infovec| name u catpredvec catinfo catvec p pred pak catform res 
       catforms t1)
  (declare (special |$infovec| |$predvec|))
  (setq conform (or domname conform))
  (setq name (|opOf| conform))
  (setq |$infovec| (|dbInfovec| name))
  (when |$infovec|
    (setq u (elt |$infovec| 3))
    (setq |$predvec| 
     (if |$domain| (elt |$domain| 3) (getdatabase name 'predicates)))
  (setq catpredvec (car u))
  (setq catinfo (cadr u))
  (setq catvec (caddr u))
  (setq catforms
   (dotimes (i (maxindex catvec) (nreverse0 t1))
     (cond
      ((progn
         (setq pred
          (|simpCatPredicate|
           (progn
            (setq p
             (sublislis (cdr conform) |$FormalMapVariableList|
                        (|kTestPred| (elt catpredvec i))))
            (if |$domain| (eval p) p))))
         (when (and domname (contained '$ pred))
           (setq pred (subst domname '$ pred :test #'equal)))
         (and (setq pak (elt catinfo i)) pred))
       (setq t1
        (cons
         (cons
          (cond
           ((and pak (null (identp pak)))
             (|devaluate| pak))
           (t
             (setq catform (|kFormatSlotDomain| (elt catvec i)))
             (setq res (|dbSubConform| (cdr conform)
                                       (cons pak (cons '$ (cdr catform)))))
             (when domname (setq res (subst domname '$ res :test #'equal)))
             res))
           pred)
         t1))))))
  (append (|dbAddChain| conform) catforms))))

\end{chunk}

\defun{kcPage}{kcPage}
\calls{kcPage}{htpProperty}
\calls{kcPage}{kDomainName}
\calls{kcPage}{qcar}
\calls{kcPage}{errorPage}
\calls{kcPage}{opOf}
\calls{kcPage}{form2HtString}
\calls{kcPage}{htInitPage}
\calls{kcPage}{htCopyProplist}
\calls{kcPage}{htpSetProperty}
\calls{kcPage}{dbpHasDefaultCategory?}
\calls{kcPage}{htSay}
\calls{kcPage}{brCon}
\calls{kcPage}{htSayStandard}
\calls{kcPage}{htBeginMenu}
\calls{kcPage}{htMakePage}
\calls{kcPage}{satBreak}
\calls{kcPage}{nequal}
\calls{kcPage}{hget}
\calls{kcPage}{hasNewInfoAlist}
\calls{kcPage}{htEndMenu}
\calls{kcPage}{htShowPage}
\usesdollar{kcPage}{defaultPackageNamesHT}
\begin{chunk}{defun kcPage}
(defun |kcPage| (htPage junk)
 (declare (ignore junk))
 (let (lt1 kind name nargs xpart domname conform conname heading page message)
  (declare (special |$defaultPackageNamesHT|))
  (setq lt1 (|htpProperty| htPage '|parts|))
  (setq kind (first lt1))
  (setq name (second lt1))
  (setq nargs (third lt1))
  (setq xpart (fourth lt1))
  (setq domname (|kDomainName| htPage kind name nargs))
  (cond
   ((and (consp domname) (eq (qcar domname) '|error|))
     (|errorPage| htPage domname))
   (t 
     (setq conform (|htpProperty| htPage '|conform|))
     (setq conname (|opOf| conform))
     (setq heading
      (if (null domname)
        (|htpProperty| htPage '|heading|)
        (list "{\\sf " (|form2HtString| domname nil t) "}")))
     (setq page
      (|htInitPage| (cons "Cross Reference for " heading)
                    (|htCopyProplist| htPage)))
     (when domname
       (|htpSetProperty| htPage '|domname| domname)
       (|htpSetProperty| htPage '|heading| heading))
     (when (and (string= kind "category")
                (|dbpHasDefaultCategory?| xpart))
       (|htSay| "This category has default package ")
       (|bcCon| (concat name #\&) ""))
     (|htSayStandard| "\\newline") 
     (|htBeginMenu| 3)
     (|htSayStandard| "\\item ")
     (setq message
      (if (string= kind "category")
        (list "Categories it directly extends")
        (list "Categories the "
         (if (string= kind "default package") "package" kind)
          " belongs to by assertion")))
     (|htMakePage|
      (list
       (list '|bcLinks|
             (list "\\menuitemstyle{Parents}"
             (list (list '|text| "\\tab{12}" message)) '|kcpPage| nil))))
     (|satBreak|)
     (setq message
      (if (string= kind "category")
       (list "All categories it is an extension of")
       (list "All categories the " kind " belongs to")))
     (|htMakePage|
      (list
       (list '|bcLinks|
        (list "\\menuitemstyle{Ancestors}"
         (list (list '|text| "\\tab{12}" message)) '|kcaPage| nil))))
     (when (string= kind "category") 
       (|satBreak|)
       (|htMakePage|
        (list
         (list '|bcLinks|
          (list "\\menuitemstyle{Children}"
           (list (list '|text| "\\tab{12}" 
                        "Categories which directly extend this category"))))))
       (|satBreak|)
       (|htMakePage|
        (list
         (list '|bcLinks|
          (list "\\menuitemstyle{Descendants}"
           (list (list '|text| "\\tab{12}" 
                       "All categories which extend this category")))))))
     (|satBreak|)
     (setq message "Constructors mentioning this as an argument type")
     (|htMakePage|
       (list
        (list '|bcLinks|
         (list "\\menuitemstyle{Dependents}"
          (list (list '|text| "\\tab{12}" message)) '|kcdePage| nil))))
     (when (nequal kind "category")
      (|satBreak|)
      (|htMakePage|
       (list
        (list '|bcLinks|
         (list "\\menuitemstyle{Lineage}"
               "\\tab{12}Constructor hierarchy used for operation lookup"
               '|ksPage| nil)))))
      (when (string= kind "category")
       (|satBreak|)
       (|htMakePage|
        (list
         (list '|bcLinks|
          (list "\\menuitemstyle{Domains}"
           (list (list '|text| "\\tab{12}" 
                       "All domains which are of this category"))
            '|kcdoPage| nil)))))
      (unless (string= kind "category")
       (|satBreak|)
       (|htMakePage|
        (list
         (list '|bcLinks|
          (list "\\menuitemstyle{Clients}" "\\tab{12}Constructors"
                '|kcuPage| nil))))
        (if (hget |$defaultPackageNamesHT| conname)
         (|htSay| " which {\\em may use} this default package")
         (|htSay| " which {\\em use} this " kind)))
     (when (or (nequal kind "category") (|dbpHasDefaultCategory?| xpart))
      (|satBreak|)
      (setq message
       (if (string= kind "category")
         (list "Constructors {\\em used by} its default package")
         (list "Constructors {\\em used by} the " kind)))
      (|htMakePage|
       (list
        (list '|bcLinks|
         (list "\\menuitemstyle{Benefactors}"
          (list (list '|text| "\\tab{12}" message) '|kcnPage| nil))))))
     (when (|hasNewInfoAlist| conname)
      (|satBreak|)
      (setq message (list "Cross reference for capsule implementation"))
      (|htMakePage|
       (list
        (list '|bcLinks|
         (list "\\menuitemstyle{CapsuleInfo}"
          (list (list '|text| "\\tab{12}" message)) '|kciPage| nil)))))
     (|htEndMenu| 3) 
     (|htShowPage|)))))

\end{chunk}

\defun{kcpPage}{kcpPage}
\calls{kcpPage}{htpProperty}
\calls{kcpPage}{kDomainName}
\calls{kcpPage}{errorPage}
\calls{kcpPage}{qcar}
\calls{kcpPage}{form2HtString}
\calls{kcpPage}{htpSetProperty}
\calls{kcpPage}{opOf}
\calls{kcpPage}{htInitPage}
\calls{kcpPage}{htCopyProplist}
\calls{kcpPage}{parentsOf}
\calls{kcpPage}{sublislis}
\calls{kcpPage}{dbShowCons}
\begin{chunk}{defun kcpPage}
(defun |kcpPage| (htPage junk)
 (declare (ignore junk))
 (let (lt1 kind name nargs domname heading conform conname page parents choice)
  (setq lt1 (|htpProperty| htPage '|parts|))
  (setq kind (first lt1))
  (setq name (second lt1))
  (setq nargs (third lt1))
  (setq domname (|kDomainName| htPage kind name nargs))
  (cond
   ((and (consp domname) (eq (qcar domname) '|error|))
     (|errorPage| htPage domname))
   (t
    (setq heading
     (if (null domname)
       (|htpProperty| htPage '|heading|)
       (list "{\\sf " (|form2HtString| domname nil t) "}")))
    (when domname
      (|htpSetProperty| htPage '|domname| domname)
      (|htpSetProperty| htPage '|heading| heading))
    (setq conform (|htpProperty| htPage '|conform|))
    (setq conname (|opOf| conform))
    (setq page
      (|htInitPage| (cons "Parents of " heading) (|htCopyProplist| htPage)))
    (setq parents (|parentsOf| conname))
    (when domname
     (setq parents (sublislis (cdr domname) (cdr conform) parents)))
    (|htpSetProperty| htPage '|cAlist| parents)
    (|htpSetProperty| htPage '|thing| "parent")
    (setq choice (if domname '|parameters| '|names|))
    (|dbShowCons| htPage choice)))))

\end{chunk}

\defun{reduceAlistForDomain}{reduceAlistForDomain}
\calls{reduceAlistForDomain}{sublislis}
\calls{reduceAlistForDomain}{simpHasPred}
\calls{reduceAlistForDomain}{nreverse0}
\begin{chunk}{defun reduceAlistForDomain}
(defun |reduceAlistForDomain| (alist domform conform)
 (let (pred result)
  (setq alist (sublislis (cdr domform) (cdr conform) alist))
  (dolist (pair alist)
   (rplacd pair (|simpHasPred| (cdr pair) domform)))
  (dolist (pair alist (nreverse0 result))
   (setq pred (cdr pair))
   (when pred (setq result (cons pair result))))))

\end{chunk}

\defun{kcaPage}{kcaPage}
\calls{kcaPage}{kcaPage1}
\calls{kcaPage}{ancestorsOf}
\begin{chunk}{defun kcaPage}
(defun |kcaPage| (htPage junk)
 (declare (ignore junk))
 (|kcaPage1| htPage "category" " an "
      "ancestor" #'|ancestorsOf| nil))

\end{chunk}

\defun{kcdPage}{kcdPage}
\calls{kcdPage}{kcaPage1}
\calls{kcdPage}{descendantsOf}
\begin{chunk}{defun kcdPage}
(defun |kcdPage| (htPage junk)
  (declare (ignore junk))
  (|kcaPage1| htPage "category" " a "
      "descendant" #'|descendantsOf| t))

\end{chunk}

\defun{kcdoPage}{kcdoPage}
\calls{kcdoPage}{kcdoPage}
\calls{kcdoPage}{domainsOf}
\begin{chunk}{defun kcdoPage}
(defun |kcdoPage| (htPage junk)
  (declare (ignore junk))
  (|kcaPage1| htPage "domain" " a "
      "descendant" #'|domainsOf| nil))

\end{chunk}

\defun{kcaPage1}{kcaPage1}
\calls{kcaPage1}{htpProperty}
\calls{kcaPage1}{kDomainName}
\calls{kcaPage1}{errorPage}
\calls{kcaPage1}{form2HtString}
\calls{kcaPage1}{htpSetProperty}
\calls{kcaPage1}{opOf}
\calls{kcaPage1}{augmentHasArgs}
\calls{kcaPage1}{listSort}
\calls{kcaPage1}{function}
\calls{kcaPage1}{dbShowCons}
\begin{chunk}{defun kcaPage1}
(defun |kcaPage1| (htPage kind article whichever fn isCatDescendants?)
 (declare (ignore article))
 (let (lt1 name nargs domname heading conform conname ancestors choice)
  (setq lt1 (|htpProperty| htPage '|parts|))
  (setq kind (first lt1))
  (setq name (second lt1))
  (setq nargs (third lt1))
  (setq domname (|kDomainName| htPage kind name nargs))
  (cond
   ((and (consp domname) (eq (qcar domname) '|error|))
     (|errorPage| htPage domname))
   (t
     (setq heading
      (if (null domname) 
        (|htpProperty| htPage '|heading|)
        (list "{\\sf " (|form2HtString| domname nil t) "}")))
     (when (and domname (null isCatDescendants?))
       (|htpSetProperty| htPage '|domname| domname)
       (|htpSetProperty| htPage '|heading| heading))
     (setq conform (|htpProperty| htPage '|conform|))
     (setq conname (|opOf| conform))
     (setq ancestors (FUNCALL fn conform domname))
     (unless (string= whichever "ancestor")
       (setq ancestors (|augmentHasArgs| ancestors conform)))
     (setq ancestors (|listSort| #'glesseqp ancestors))
     (|htpSetProperty| htPage '|cAlist| ancestors)
     (|htpSetProperty| htPage '|thing| whichever)
     (setq choice '|names|)
     (|dbShowCons| htPage choice)))))

\end{chunk}

\defun{kccPage}{kccPage}
\calls{kccPage}{htpProperty}
\calls{kccPage}{kDomainName}
\calls{kccPage}{qcar}
\calls{kccPage}{errorPage}
\calls{kccPage}{form2HtString}
\calls{kccPage}{htpSetProperty}
\calls{kccPage}{opOf}
\calls{kccPage}{htInitPage}
\calls{kccPage}{htCopyProplist}
\calls{kccPage}{augmentHasArgs}
\calls{kccPage}{childrenOf}
\calls{kccPage}{reduceAlistForDomain}
\calls{kccPage}{dbShowCons}
\begin{chunk}{defun kccPage}
(defun |kccPage| (htPage junk)
 (declare (ignore junk))
 (let (lt1 kind name nargs domname heading conform conname page children)
  (setq lt1 (|htpProperty| htPage '|parts|))
  (setq kind (first lt1))
  (setq name (second lt1))
  (setq nargs (third lt1))
  (setq domname (|kDomainName| htPage kind name nargs))
  (cond
   ((and (consp domname) (eq (qcar domname) '|error|))
     (|errorPage| htPage domname))
   (t
     (setq heading
      (if (null domname)
        (|htpProperty| htPage '|heading|)
        (list "{\\sf " (|form2HtString| domname nil t) "}")))
     (when domname
      (|htpSetProperty| htPage '|domname| domname)
      (|htpSetProperty| htPage '|heading| heading))
     (setq conform (|htpProperty| htPage '|conform|))
     (setq conname (|opOf| conform))
     (setq page
       (|htInitPage| (cons "Children of " heading) (|htCopyProplist| htPage)))
     (setq children (|augmentHasArgs| (|childrenOf| conform) conform))
     (when domname
      (setq children (|reduceAlistForDomain| children domname conform)))
     (|htpSetProperty| htPage '|cAlist| children)
     (|htpSetProperty| htPage '|thing| "child")
     (|dbShowCons| htPage '|names|)))))

\end{chunk}

\defun{augmentHasArgs}{augmentHasArgs}
\calls{augmentHasArgs}{opOf}
\calls{augmentHasArgs}{length}
\calls{augmentHasArgs}{nreverse0}
\calls{augmentHasArgs}{extractHasArgs}
\calls{augmentHasArgs}{getConstructorForm}
\begin{chunk}{defun augmentHasArgs}
(defun |augmentHasArgs| (alist conform)
 (let (conname args n name p result pred)
  (setq conname (|opOf| conform))
  (setq args (ifcdr conform))
  (cond 
   (args
    (setq n (|#| args))
    (dolist (item alist (nreverse0 result))
     (setq name (car item))
     (setq p (cdr item))
     (setq pred
      (if (consp (|extractHasArgs| p))
       p
       (|quickAnd| p
        (cons '|hasArgs| 
         (take n (ifcdr (|getConstructorForm| (|opOf| name))))))))
     (setq result (cons (cons name pred) result))))
  (t alist))))

\end{chunk}

\defun{kcdePage}{kcdePage}
\calls{kcdePage}{htpProperty}
\calls{kcdePage}{concat}
\calls{kcdePage}{nequal}
\calls{kcdePage}{ncParseFromString}
\calls{kcdePage}{opOf}
\calls{kcdePage}{getDependentsOfConstructor}
\calls{kcdePage}{getConstructorForm}
\calls{kcdePage}{htpSetProperty}
\calls{kcdePage}{dbShowCons}
\begin{chunk}{defun kcdePage}
(defun |kcdePage| (htPage junk)
 (declare (ignore junk))
 (let (lt1 kind name args conname constring conform pakname domlist cAlist)
  (setq lt1 (|htpProperty| htPage '|parts|))
  (setq kind (first lt1))
  (setq name (second lt1))
  (setq args (sixth lt1))
  (setq conname (intern name))
  (setq constring (concat name args))
  (setq conform
   (if (nequal kind "default package")
    (|ncParseFromString| constring)
    (cons (intern name) (cdr (|ncParseFromString| (concat #\d args))))))
  (setq pakname (|opOf| conform))
  (setq domlist (|getDependentsOfConstructor| pakname))
  (setq cAlist
    (loop for x in domList collect (cons (|getConstructorForm| x) t)))
  (|htpSetProperty| htPage '|cAlist| cAlist)
  (|htpSetProperty| htPage '|thing| "dependent")
  (|dbShowCons| htPage '|names|)))

\end{chunk}

\defun{getDependentsOfConstructor}{getDependentsOfConstructor}
\calls{getDependentsOfConstructor}{readLibPathFast}
\calls{getDependentsOfConstructor}{pathname}
\calls{getDependentsOfConstructor}{rread}
\calls{getDependentsOfConstructor}{rshut}
\begin{chunk}{defun getDependentsOfConstructor}
(defun |getDependentsOfConstructor| (con)
 (let (stream val)
  (setq stream 
   (|readLibPathFast| (|pathname| (list  '|dependents| 'database '|a|))))
  (setq val (|rread| con stream nil))
  (rshut stream)
  val))

\end{chunk}

\defun{kcuPage}{kcuPage}
\calls{kcuPage}{htpProperty}
\calls{kcuPage}{concat}
\calls{kcuPage}{nequal}
\calls{kcuPage}{ncParseFromString}
\calls{kcuPage}{opOf}
\calls{kcuPage}{getUsersOfConstructor}
\calls{kcuPage}{getConstructorForm}
\calls{kcuPage}{htpSetProperty}
\calls{kcuPage}{dbShowCons}
\begin{chunk}{defun kcuPage}
(defun |kcuPage| (htPage junk)
 (declare (ignore junk))
 (let (lt1 kind name args constring conform pakname domlist cAlist)
   (setq lt1 (|htpProperty| htPage '|parts|))
   (setq kind (first lt1))
   (setq name (second lt1))
   (setq args (sixth lt1))
   (setq constring (concat name args))
   (setq conform
    (if (nequal kind "default package")
      (|ncParseFromString| constring)
      (cons (intern name)
            (cdr (|ncParseFromString| (concat #\d args))))))
   (setq pakname
    (if (string= kind "category")
      (intern (concat name #\&))
      (|opOf| conform)))
   (setq domlist (|getUsersOfConstructor| pakname))
   (setq cAlist
    (loop for x in domlist collect (cons (|getConstructorForm| x) t)))
   (|htpSetProperty| htPage '|cAlist| cAlist)
   (|htpSetProperty| htPage '|thing| "user")
   (|dbShowCons| htPage '|names|)))

\end{chunk}

\defun{getUsersOfConstructor}{getUsersOfConstructor}
\calls{getUsersOfConstructor}{readLibPathFast}
\calls{getUsersOfConstructor}{pathname}
\calls{getUsersOfConstructor}{rread}
\calls{getUsersOfConstructor}{rshut}
\begin{chunk}{defun getUsersOfConstructor}
(defun |getUsersOfConstructor| (con)
 (let (stream val)
  (setq stream (|readLibPathFast| (|pathname| (list '|users| 'database '|a|))))
  (setq val (|rread| con stream nil))
  (rshut stream)
  val))

\end{chunk}

\defun{kcnPage}{kcnPage}
\calls{kcnPage}{kDomainName}
\calls{kcnPage}{qcar}
\calls{kcnPage}{errorPage}
\calls{kcnPage}{htpProperty}
\calls{kcnPage}{form2HtString}
\calls{kcnPage}{htpSetProperty}
\calls{kcnPage}{concat}
\calls{kcnPage}{pname}
\calls{kcnPage}{opOf}
\calls{kcnPage}{getImports}
\calls{kcnPage}{sublislis}
\calls{kcnPage}{dbShowCons}
\begin{chunk}{defun kcnPage}
(defun |kcnPage| (htPage junk)
 (declare (ignore junk))
 (let (lt1 kind name nargs domname heading conform pakname domlist cAlist
       conname)
  (setq lt1 (|htpProperty| htPage '|parts|))
  (setq kind (first lt1))
  (setq name (second lt1))
  (setq conname (intern name))
  (setq nargs (third lt1))
  (setq domname (|kDomainName| htPage kind name nargs))
  (cond
    ((and (consp domname) (eq (qcar domname) '|error|))
      (|errorPage| htPage domname))
    (t
     (setq heading
      (if (null domname)
       (|htpProperty| htPage '|heading|)
       (list "{\\sf " (|form2HtString| domname nil t) "}")))
     (if domname
       (|htpSetProperty| htPage '|domname| domname)
       (|htpSetProperty| htPage '|heading| heading))
     (setq conform (|htpProperty| htPage '|conform|))
     (setq pakname
      (if (string= kind "category")
        (intern (concat (pname conname) #\&))
        (|opOf| conform)))
     (setq domlist (|getImports| pakname))
     (when domname
      (setq domlist
       (sublislis (cons domname (cdr domname))
                  (cons '$ (cdr conform)) domlist)))
     (setq cAlist (loop for x in domList collect (cons x t)))
     (|htpSetProperty| htPage '|cAlist| cAlist)
     (|htpSetProperty| htPage '|thing| "benefactor")
     (|dbShowCons| htPage '|names|)))))

\end{chunk}

\defun{koPageInputAreaUnchanged?}{koPageInputAreaUnchanged?}
\calls{koPageInputAreaUnchanged?}{htpLabelInputString}
\calls{koPageInputAreaUnchanged?}{concat}
\calls{koPageInputAreaUnchanged?}{htpProperty}
\begin{chunk}{defun koPageInputAreaUnchanged?}
(defun |koPageInputAreaUnchanged?| (htPage nargs)
 (equal
  (loop for i from 1 to nargs 
   collect
   (|htpLabelInputString| htPage (intern (concat "*" (princ-to-string i)))))
  (|htpProperty| htPage '|inputAreaList|)))

\end{chunk}

\defun{kDomainName}{kDomainName}
\calls{kDomainName}{htpSetProperty}
\calls{kDomainName}{htpLabelInputString}
\calls{kDomainName}{getdatabase}
\calls{kDomainName}{kArgumentCheck}
\calls{kDomainName}{concat}
\calls{kDomainName}{unabbrev}
\calls{kDomainName}{mkConform}
\calls{kDomainName}{kisValidType}
\calls{kDomainName}{dbMkEvalable}
\catches{kDomainName}{spad-reader}
\usesdollar{kDomainName}{PatternVariableList}
\begin{chunk}{defun kDomainName}
(defun |kDomainName| (htPage kind name nargs)
 (let (inputAreaList conname args n argTailPart argString typeForm 
       evaluatedTypeForm)
  (|htpSetProperty| htPage '|domname| nil)
  (setq inputAreaList
   (loop for i from 1 to nargs for var in |$PatternVariableList| 
    collect (|htpLabelInputString| htPage var)))
  (|htpSetProperty| htPage '|inputAreaList| inputAreaList)
  (setq conname (intern name))
  (setq args
   (loop for x in inputAreaList 
         for domain? in (cdr (getdatabase conname 'cosig))
    collect (or (|kArgumentCheck| domain? x) nil)))
  (when (some #'identity (loop for x in args collect (null x)))
    (cond
     ((> (setq n (apply #'+ (loop for x in args collect (if x 1 0)))) 0)
      (list '|error| nil "\\centerline{You gave values for only {\\em "
            n " } of the {\\em " (|#| args) "}}"
            "\\centerline{parameters of {\\sf " name
            "}}\\vspace{1}\\centerline{Please enter either {\\em all} or "
            "{\\em none} of the type parameters}")
       nil)
     (t
      (setq argString
       (cond
        ((null args) "()")
        (t
          (setq argTailPart
           (apply #'concat
            (loop for x in (ifcdr args) collect (concat (cons "," x)))))
          (apply #'concat (list "(" (car args) argTailPart ")")))))
      (setq typeForm
       (or (catch 'spad_reader (|unabbrev| (|mkConform| kind name argString)))
           (list '|error| '|invalidType| (concat name argString))))
      (if (null (setq evaluatedTypeForm (|kisValidType| typeForm)))
       (list  '|error| '|invalidType| (concat name argString))
       (|dbMkEvalable| evaluatedTypeForm)))))))

\end{chunk}

\defun{kArgumentCheck}{kArgumentCheck}
\calls{kArgumentCheck}{conSpecialString?}
\calls{kArgumentCheck}{opOf}
\calls{kArgumentCheck}{form2String}
\begin{chunk}{defun kArgumentCheck}
(defun |kArgumentCheck| (domain? s)
 (let (form)
  (cond
   ((string= s "") nil)
   ((and domain? (setq form (|conSpecialString?| s)))
    (if (null (ifcdr form))
      (list (princ-to-string (|opOf| form)))
      (|form2String| form)))
   (t (list s)))))

\end{chunk}

\defun{dbMkEvalable}{dbMkEvalable}
\calls{dbMkEvalable}{getdatabase}
\calls{dbMkEvalable}{mkEvalable}
\begin{chunk}{defun dbMkEvalable}
(defun |dbMkEvalable| (form)
 (let (op kind)
  (setq op (car form))
  (setq kind (getdatabase op 'constructorkind))
  (if (eq kind '|category|) 
   form
   (|mkEvalable| form))))

\end{chunk}

\defun{topLevelInterpEval}{topLevelInterpEval}
\calls{topLevelInterpEval}{processInteractive}
\usesdollar{topLevelInterpEval}{ProcessInteractiveValue}
\usesdollar{topLevelInterpEval}{noEvalTypeMsg}
\begin{chunk}{defun topLevelInterpEval}
(defun |topLevelInterpEval| (x)
 (let (|$ProcessInteractiveValue| |$noEvalTypeMsg|)
 (declare (special |$ProcessInteractiveValue| |$noEvalTypeMsg|))
  (setq |$ProcessInteractiveValue| t)
  (setq |$noEvalTypeMsg| t)
  (|processInteractive| x nil)))

\end{chunk}

\defun{kisValidType}{kisValidType}
\calls{kisValidType}{processInteractive}
\calls{kisValidType}{member}
\calls{kisValidType}{kCheckArgumentNumbers}
\usesdollar{kisValidType}{ProcessInteractiveValue}
\usesdollar{kisValidType}{noEvalTypeMsg}
\catches{kisValidType}{spad-reader}
\begin{chunk}{defun kisValidType}
(defun |kisValidType| (typeForm)
 (let (|$ProcessInteractiveValue| |$noEvalTypeMsg| it1)
 (declare (special |$ProcessInteractiveValue| |$noEvalTypeMsg|))
  (setq |$ProcessInteractiveValue| t)
  (setq |$noEvalTypeMsg| t)
  (setq it1 (catch 'spad_reader (|processInteractive| typeForm nil)))
  (when  (and (consp it1) (consp (qcar it1)))
     (|member| (caar it1) '(domain |SubDomain|)))
  (and (|kCheckArgumentNumbers| (qcdr it1)) (qcdr it1))))

\end{chunk}

\defun{kCheckArgumentNumbers}{kCheckArgumentNumbers}
\calls{kCheckArgumentNumbers}{getdatabase}
\calls{kCheckArgumentNumbers}{kCheckArgumentNumber}
\begin{chunk}{defun kCheckArgumentNumbers}
(defun |kCheckArgumentNumbers| (tt)
 (let (conname args cosig)
  (setq conname (car tt))
  (setq args (cdr tt))
  (setq cosig (ifcdr (getdatabase conname 'cosig)))
  (every #'identity 
   (loop for domain? in cosig for x in args 
    collect (if domain? (|kCheckArgumentNumbers| x) t)))))

\end{chunk}

\defun{parseNoMacroFromString}{parseNoMacroFromString}
\calls{parseNoMacroFromString}{next}
\calls{parseNoMacroFromString}{function}
\calls{parseNoMacroFromString}{ncloopParse}
\calls{parseNoMacroFromString}{lineoftoks}
\calls{parseNoMacroFromString}{incString}
\calls{parseNoMacroFromString}{StreamNull}
\calls{parseNoMacroFromString}{pf2Sex}
\begin{chunk}{defun parseNoMacroFromString}
(defun |parseNoMacroFromString| (s)
 (setq s
  (|next| #'|ncloopParse|
   (|next| #'|lineoftoks|
    (|incString| s))))
 (if (|StreamNull| s) 
  nil
  (|pf2Sex| (cadar s))))

\end{chunk}

\defun{mkConform}{mkConform}
\calls{mkConform}{nequal}
\calls{mkConform}{parseNoMacroFromString}
\calls{mkConform}{sayBrightlyNT}
\calls{mkConform}{pp}
\calls{mkConform}{systemError}
\calls{mkConform}{ncParseFromString}
\calls{mkConform}{concat}
\begin{chunk}{defun mkConform}
(defun |mkConform| (kind name argString)
 (let (form parse)
  (cond
   ((nequal kind "default package")
    (setq form (concat name argString))
    (setq parse (|parseNoMacroFromString| form))
    (cond
     ((null parse)
       (|sayBrightlyNT| "Won't parse: ")
       (|pp| form)
       (|systemError| "Keywords in argument list?"))
     ((atom parse) (cons parse nil))
     (t parse)))
   (t
    (cons (intern name) (cdr (|ncParseFromString| (concat #\d argString))))))))

\end{chunk}

\section{Operation Page for a Domain Form from Scratch}

\defun{conOpPage}{conOpPage}
\calls{conOpPage}{dbCompositeWithMap}
\calls{conOpPage}{htpProperty}
\calls{conOpPage}{conOpPage1}
\calls{conOpPage}{dbExtractUnderlyingDomain}
\begin{chunk}{defun conOpPage}
(defun |conOpPage| (htPage conform)
 (declare (ignore conform))
 (let (updown domname)
  (setq updown (|dbCompositeWithMap| htPage))
  (cond
   ((string= updown "DOWN")
     (setq domname (|htpProperty| htPage '|domname|))
     (|conOpPage1| (|dbExtractUnderlyingDomain| domname)
                   (list (cons '|updomain| domname))))
   (t 
     (setq domname (|htpProperty| htPage '|updomain|))
      (|conOpPage1| domname nil)))))

\end{chunk}

\defun{conOpPage1}{conOpPage1}
\calls{conOpPage1}{ifcar}
\calls{conOpPage1}{opOf}
\calls{conOpPage1}{dbSpecialOperations}
\calls{conOpPage1}{conPageFastPath}
\calls{conOpPage1}{dbXParts}
\calls{conOpPage1}{concat}
\calls{conOpPage1}{mkConform}
\calls{conOpPage1}{captialize}
\calls{conOpPage1}{ncParseFromString}
\calls{conOpPage1}{dbSourceFile}
\calls{conOpPage1}{isExposedConstructor}
\calls{conOpPage1}{htInitPage}
\calls{conOpPage1}{htpSetProperty}
\calls{conOpPage1}{lassoc}
\calls{conOpPage1}{ifcdr}
\calls{conOpPage1}{koPage}
\usesdollar{conOpPage1}{Primitives}
\begin{chunk}{defun conOpPage1}
(defun |conOpPage1| (&rest arg)
 (let (bindingsAlist conname domname line parts name sig args isFile kind 
       constring capitalKind signature sourceFileName emString heading page
       selectedOperation options conform)
  (declare (special |$Primitives|))
  (setq conform (car arg))
  (setq options (cdr arg))
  (setq bindingsAlist (ifcar options))
  (setq conname (|opOf| conform))
  (cond
   ((member conname |$Primitives|) (|dbSpecialOperations| conname))
   (t
    (setq domname (unless (atom conform) conform))
    (setq line (|conPageFastPath| conname))
    (setq parts (|dbXParts| line 7 1))
    (setq kind (first parts))
    (setq name (second parts))
    (setq sig (fifth parts))
    (setq args (sixth parts))
    (setq isFile (null kind))
    (setq kind (or kind "package"))
    (rplaca parts kind)
    (setq constring (concat name args))
    (setq conform (|mkConform| kind name args))
    (setq capitalKind (|capitalize| kind))
    (setq signature (|ncParseFromString| sig))
    (setq sourceFileName (|dbSourceFile| (intern name)))
    (setq emString (list "{\\sf " constring "}"))
    (setq heading (cons capitalKind (cons " " emString)))
    (unless (|isExposedConstructor| conname)
      (setq heading (cons "Unexposed " heading)))
    (setq page (|htInitPage| heading nil))
    (|htpSetProperty| page '|isFile| t)
    (|htpSetProperty| page '|fromConOpPage1| t)
    (|htpSetProperty| page '|parts| parts)
    (|htpSetProperty| page '|heading| heading)
    (|htpSetProperty| page '|kind| kind)
    (|htpSetProperty| page '|domname| domname)
    (|htpSetProperty| page '|conform| conform)
    (|htpSetProperty| page '|signature| signature)
    (when 
     (setq selectedOperation (lassoc '|selectedOperation| (ifcdr options)))
      (|htpSetProperty| page '|selectedOperation| selectedOperation))
    (loop for item in bindingsAlist
     collect (|htpSetProperty| page (car item) (cdr item)))
    (|koPage| page "operation")))))

\end{chunk}

\defun{dbCompositeWithMap}{dbCompositeWithMap}
\calls{dbCompositeWithMap}{htpProperty}
\calls{dbCompositeWithMap}{dbExtractUnderlyingDomain}
\begin{chunk}{defun dbCompositeWithMap}
(defun |dbCompositeWithMap| (htPage)
 (let (domain opAlist)
 (cond
  ((|htpProperty| htPage '|updomain|) "UP")
  (t
   (setq domain (|htpProperty| htPage '|domname|))
   (cond
    ((null domain) nil)
    (t
     (setq opAlist (|htpProperty| htPage '|opAlist|))
     (when 
       (|dbExtractUnderlyingDomain| (|htpProperty| htPage '|domname|))
       "DOWN")))))))

\end{chunk}

\defun{dbExtractUnderlyingDomain}{dbExtractUnderlyingDomain}
\calls{dbExtractUnderlyingDomain}{isValidType}
\begin{chunk}{defun dbExtractUnderlyingDomain}
(defun |dbExtractUnderlyingDomain| (domain)
 (some #'identity 
  (loop for x in (ifcdr domain) when (|isValidType| x) collect x)))

\end{chunk}

\section{Operation Page from Main Page}

\defun{koPage}{koPage}
\calls{koPage}{htpProperty}
\calls{koPage}{concat}
\calls{koPage}{koPageInputAreaUnchanged?}
\calls{koPage}{kDomainName}
\calls{koPage}{errorPage}
\calls{koPage}{form2HtString}
\calls{koPage}{capitalize}
\calls{koPage}{htpSetProperty}
\calls{koPage}{koPageAux}
\begin{chunk}{defun koPage}
(defun |koPage| (htPage which)
 (let (lt1 kind name nargs args constring conname u IT1 domname headingString 
       heading)
  (setq lt1 (|htpProperty| htPage '|parts|))
  (setq kind (first lt1))
  (setq name (second lt1))
  (setq nargs (third lt1))
  (setq args (sixth lt1))
  (setq constring (concat name args))
  (setq conname (intern name))
  (setq IT1 (setq u (|htpProperty| htPage '|domname|)))
  (setq domname
   (cond
    ((and (consp IT1) (equal (qcar IT1) conname)
      (or (eq (|htpProperty| htPage '|fromConOpPage1|) t)
          (|koPageInputAreaUnchanged?| htPage nargs)))
       u)
    (t (|kDomainName| htPage kind name nargs))))
  (cond
   ((and (consp domname) (eq (qcar domname) '|error|))
    (|errorPage| htPage domname))
   (t 
    (|htpSetProperty| htPage '|domname| domname)
    (setq headingString (if domname (|form2HtString| domname nil t) constring))
    (setq heading (list (|capitalize| kind) " {\\sf " headingString "}" ))
    (|htpSetProperty| htPage '|which| which)
    (|htpSetProperty| htPage '|heading| heading)
    (|koPageAux| htPage which domname heading)))))

\end{chunk}

\defun{koPageFromKKPage}{koPageFromKKPage}
\calls{koPageFromKKPage}{koPageAux}
\calls{koPageFromKKPage}{htpProperty}
\begin{chunk}{defun koPageFromKKPage}
(defun |koPageFromKKPage| (htPage ao)
  (|koPageAux| htPage ao (|htpProperty| htPage '|domname|)
      (|htpProperty| htPage '|heading|)))

\end{chunk}

\defun{koPageAux}{koPageAux}
\calls{koPageAux}{htpSetProperty}
\calls{koPageAux}{koAttrs}
\calls{koPageAux}{koOps}
\calls{koPageAux}{assoc}
\calls{koPageAux}{systemError}
\calls{koPageAux}{dbShowOperationsFromConform}
\begin{chunk}{defun koPageAux}
(defun |koPageAux| (htPage which domname heading)
 (let (conform selectedOperation opAlist)
  (|htpSetProperty| htPage '|which| which)
  (setq domname (|htpProperty| htPage '|domname|))
  (setq conform (|htpProperty| htPage '|conform|))
  (setq heading (|htpProperty| htPage '|heading|))
  (setq opAlist
   (cond
    ((string= which "attribute") (|koAttrs| conform domname))
    ((string= which "general operation") (|koOps| conform domname t))
    (t (|koOps| conform domname))))
  (cond
   ((setq selectedOperation (|htpProperty| htPage '|selectedOperation|))
    (setq opAlist
     (list (or (|assoc| selectedOperation opAlist) (|systemError|))))))
  (|dbShowOperationsFromConform| htPage which opAlist)))

\end{chunk}

\defun{koPageAux1}{koPageAux1}
\calls{koPageAux1}{htpProperty}
\calls{koPageAux1}{dbShowOperationsFromConform}
\begin{chunk}{defun koPageAux1}
(defun |koPageAux1| (htPage opAlist)
 (let (which)
  (setq which (|htpProperty| htPage '|which|))
  (|dbShowOperationsFromConform| htPage which opAlist)))

\end{chunk}

\defun{koaPageFilterByName}{koaPageFilterByName}
\calls{koaPageFilterByName}{htpLabelInputString}
\calls{koaPageFilterByName}{koaPageFilterByCategory}
\calls{koaPageFilterByName}{pmTransFilter}
\calls{koaPageFilterByName}{htpProperty}
\calls{koaPageFilterByName}{dbGetInputString}
\calls{koaPageFilterByName}{superMatch?}
\calls{koaPageFilterByName}{downcase}
\calls{koaPageFilterByName}{htpSetProperty}
\begin{chunk}{defun koaPageFilterByName}
(defun |koaPageFilterByName| (htPage functionToCall)
 (let (filter which opAlist)
  (cond
   ((string= (|htpLabelInputString| htPage '|filter|) "")
    (|koaPageFilterByCategory| htPage functionToCall))
   (t
    (setq filter (|pmTransFilter| (|dbGetInputString| htPage)))
    (setq which (|htpProperty| htPage '|which|))
    (setq opAlist
     (loop for x in (|htpProperty| htPage '|opAlist|)
           when (|superMatch?| filter (downcase (princ-to-string (car x))))
           collect x))
    (|htpSetProperty| htPage '|opAlist| opAlist)
    (funcall functionToCall htPage nil)))))

\end{chunk}

\section{Get Constructor Documentation}

\defun{dbConstructorDoc,hn}{dbConstructorDoc,hn}
\calls{dbConstructorDoc,hn}{length}
\calls{dbConstructorDoc,hn}{sublislis}
\usesdollar{dbConstructorDoc,hn}{FormalMapVariableList}
\usesdollar{dbConstructorDoc,hn}{sig}
\usesdollar{dbConstructorDoc,hn}{args}
\begin{chunk}{defun dbConstructorDoc,hn}
(defun |dbConstructorDoc,hn| (sig)
 (declare (special |$sig| |$args|))
 (and (equal (|#| |$sig|) (|#| sig))
      (equal |$sig| (sublislis |$args| |$FormalMapVariableList| sig))))

\end{chunk}

\defun{dbConstructorDoc,gn}{dbConstructorDoc,gn}
\calls{dbConstructorDoc,gn}{dbConstructorDoc,hn}
\usesdollar{dbConstructorDoc,gn}{op}
\begin{chunk}{defun dbConstructorDoc,gn}
(defun |dbConstructorDoc,gn| (arg)
 (let (op alist)
 (declare (special |$op|))
  (setq op (car arg))
  (setq alist (cdr arg))
  (and |$op| 
   (some #'identity 
    (loop for item in alist when (|dbConstructorDoc,hn| (car item))
     collect (or (cdr item) '("")))))))

\end{chunk}

\defun{dbConstructorDoc,fn}{dbConstructorDoc,fn}
\calls{dbConstructorDoc,fn}{dbConstructorDoc,gn}
\calls{dbConstructorDoc,fn}{getdatabase}
\usesdollar{dbConstructorDoc,fn}{args}
\begin{chunk}{defun dbConstructorDoc,fn}
(defun |dbConstructorDoc,fn| (conform)
 (declare (special |$args|))
  (let (conname docs)
   (setq conname (car conform))
   (setq |$args| (cdr conform))
   (loop for y in (getdatabase conname 'documentation) 
    collect (|dbConstructorDoc,gn| y))))
\end{chunk}

\defun{dbConstructorDoc}{dbConstructorDoc}
\calls{dbConstructorDoc}{dbConstructorDoc,fn}
\usesdollar{dbConstructorDoc}{sig}
\usesdollar{dbConstructorDoc}{op}
\begin{chunk}{defun dbConstructorDoc}
(defun |dbConstructorDoc| (conform |$op| |$sig|)
  (declare (special |$op| |$sig|))
  (|dbConstructorDoc,fn| conform))

\end{chunk}

\defun{dbDocTable}{dbDocTable}
\calls{dbDocTable}{hget}
\calls{dbDocTable}{make-hashtable}
\calls{dbDocTable}{originsInOrder}
\calls{dbDocTable}{dbAddDocTable}
\usesdollar{dbDocTable}{docTable}
\usesdollar{dbDocTable}{docTableHash}
\begin{chunk}{defun dbDocTable}
(defun |dbDocTable| (conform)
 (let (|$docTable| table)
 (declare (special |$docTable| |$docTableHash|))
  (cond
   ((setq table (hget |$docTableHash| conform))
    table)
   (t
    (setq |$docTable| (make-hashtable 'id))
    (loop for x in (|originsInOrder| conform) do (|dbAddDocTable| x))
    (|dbAddDocTable| conform)
    (hput |$docTableHash| conform |$docTable|)
    |$docTable|))))

\end{chunk}

\defun{originsInOrder}{originsInOrder}
\calls{originsInOrder}{getdatabase}
\calls{originsInOrder}{assocleft}
\calls{originsInOrder}{ancestorsOf}
\calls{originsInOrder}{parentsOf}
\calls{originsInOrder}{originsInOrder}
\calls{originsInOrder}{insert}
\begin{chunk}{defun originsInOrder}
(defun |originsInOrder| (conform)
 (let (con argl acc)
  (setq con (car conform))
  (setq argl (cdr conform))
  (cond
   ((eq (getdatabase con 'constructorkind) '|category|)
     (assocleft (|ancestorsOf| conform nil)))
   (t 
     (setq acc (assocleft (|parentsOf| con)))
     (loop for x in acc do
       (loop for y in (|originsInOrder| x) do
        (setq acc (|insert| y acc))))
     acc))))

\end{chunk}

\defun{dbAddDocTable}{dbAddDocTable}
\calls{dbAddDocTable}{opOf}
\calls{dbAddDocTable}{getConstructorForm}
\calls{dbAddDocTable}{sublislis}
\calls{dbAddDocTable}{getdatabase}
\calls{dbAddDocTable}{hput}
\calls{dbAddDocTable}{hget}
\usesdollar{dbAddDocTable}{docTable}
\begin{chunk}{defun dbAddDocTable}
(defun |dbAddDocTable| (conform)
 (let (conname storedArgs op alist op1 sig doc tmp)
 (declare (special |$docTable|))
  (setq conname (|opOf| conform))
  (setq storedArgs (cdr (|getConstructorForm| conname)))
  (setq tmp (sublislis (cons '$ (cdr conform)) (cons '% storedArgs)
                       (getdatabase (|opOf| conform) 'documentation)))
  (loop for item in tmp do
   (setq op (car item))
   (setq alist (cdr item))
   (setq op1
    (cond
     ((eq op '(|Zero|)) 0)
     ((eq op '(|One|)) 1)
     (t op)))
   (loop for item1 in alist do
    (setq sig (first item1))
    (setq doc (second item1))
    (hput |$docTable| op1 (cons (cons conform alist)
                                (hget |$docTable| op1)))))))

\end{chunk}

\defun{dbGetDocTable,hn}{dbGetDocTable,hn}
\calls{dbGetDocTable,hn}{sublislis}
\calls{dbGetDocTable,hn}{qcdr}
\calls{dbGetDocTable,hn}{qcar}
\usesdollar{dbGetDocTable,hn}{which}
\usesdollar{dbGetDocTable,hn}{conform}
\usesdollar{dbGetDocTable,hn}{sig}
\usesdollar{dbGetDocTable,hn}{FormalMapVariableList}
\begin{chunk}{defun dbGetDocTable,hn}
(defun |dbGetDocTable,hn| (arg)
 (let (sig doc alteredSig pred)
 (declare (special |$which| |$conform| |$sig| |$FormalMapVariableList|))
  (setq sig (car arg))
  (setq doc (cdr arg))
  (if (string= |$which| "attribute")
   (and (consp sig) (eq (qcar sig) '|attribute|) (equal (qcdr sig) |$sig|)
        doc)
   (progn
    (setq pred 
     (and 
      (eql (|#| |$sig|) (|#| sig))
      (setq alteredSig 
       (sublislis (ifcdr |$conform|) |$FormalMapVariableList| sig))
      (equal alteredSig |$sig|)))
    (when (and pred doc
           (and (consp doc) (eq (qcar doc) '|constant|)) (qcdr doc) doc)
      '(""))))))

\end{chunk}

\defun{dbGetDocTable,gn}{dbGetDocTable,gn}
\calls{dbGetDocTable,gn}{lastatom}
\calls{dbGetDocTable,gn}{dbGetDocTable,hn}
\usesdollar{dbGetDocTable,gn}{conform}
\begin{chunk}{defun dbGetDocTable,gn}
(defun |dbGetDocTable,gn| (u)
 (let (code p comments)
 (declare (special |$conform|))
  (setq |$conform| (car u))
  (when (atom |$conform|) (setq |$conform| (list |$conform|)))
  (setq code (lastatom u))
  (setq comments
   (some #'identity
    (loop for entry in (cdr u) 
          when (setq p (|dbGetDocTable,hn| entry))
          collect p)))
  (when comments (cons |$conform| (cons (car comments) code)))))

\end{chunk}

\defun{dbGetDocTable}{dbGetDocTable}
\calls{dbGetDocTable}{string2Integer}
\calls{dbGetDocTable}{dbConstructorDoc}
\calls{dbGetDocTable}{qcdr}
\calls{dbGetDocTable}{hget}
\calls{dbGetDocTable}{dbGetDocTable,gn}
\usesdollar{dbGetDocTable}{sig}
\usesdollar{dbGetDocTable}{which}
\usesdollar{dbGetDocTable}{conform}
\usesdollar{dbGetDocTable}{op}
\begin{chunk}{defun dbGetDocTable}
(defun |dbGetDocTable| (op |$sig| docTable |$which| aux)
 (declare (special |$sig| |$which|))
 (let (doc origin s)
 (declare (special |$conform| |$op|))
  (when (and (null (integerp op)) (digitp (elt (setq s (princ-to-string op)) 0)))
   (setq op (|string2Integer| s)))
  (cond
   ((and (consp aux) (consp (qcar aux)))
     (setq doc (|dbConstructorDoc| (car aux) |$op| |$sig|))
     (setq origin (if (qcdr aux) (cons '|ifp| aux) (car aux)))
     (cons origin doc))
   (t
    (some #'identity 
     (loop for x in (hget docTable op) 
      collect (|dbGetDocTable,gn| x)))))))

\end{chunk}

\defun{kTestPred}{kTestPred}
\calls{kTestPred}{testBitVector}
\calls{kTestPred}{simpHasPred}
\usesdollar{kTestPred}{predvec}
\usesdollar{kTestPred}{domain}
\begin{chunk}{defun kTestPred}
(defun |kTestPred| (n)
 (declare (special |$predvec| |$domain|))
 (cond
   ((eql n 0) t)
   (|$domain| (|testBitVector| |$predvec| n))
   (t (|simpHasPred| (elt |$predvec| (1- n))))))

\end{chunk}

\defun{dbAddChainDomain}{dbAddChainDomain}
\calls{dbAddChainDomain}{dbInfovec}
\calls{dbAddChainDomain}{dbSubConform}
\calls{dbAddChainDomain}{kFormatSlotDomain}
\calls{dbAddChainDomain}{devaluate}
\usesdollar{dbAddChainDomain}{infovec}
\begin{chunk}{defun dbAddChainDomain}
(defun |dbAddChainDomain| (conform)
 (let (name args template form)
 (declare (special |$infovec|))
  (setq name (car conform))
  (setq args (cdr conform))
  (setq |$infovec| (|dbInfovec| name))
  (when |$infovec|
   (setq template (elt |$infovec| 0))
   (when (setq form (elt template 5))
    (|dbSubConform| args (|kFormatSlotDomain| (|devaluate| form)))))))

\end{chunk}

\defun{dbSubConform}{dbSubConform}
\calls{dbSubConform}{position}
\calls{dbSubConform}{dbSubConform}
\usesdollar{dbSubConform}{FormalMapVariableList}
\begin{chunk}{defun dbSubConform}
(defun |dbSubConform| (args u)
 (let (n y)
 (declare (special |$FormalMapVariableList|))
  (cond
   ((atom u)
     (if (>= (setq n (|position| u |$FormalMapVariableList|)) 0)
       (elt args n)
       u))
   ((and (consp u) (eq (car u) '|local|) (consp (cdr u)) (eq (cddr u) nil))
     (setq y (cadr u))
     (|dbSubConform| args y))
   (t
    (loop for x in u collect (|dbSubConform| args x))))))

\end{chunk}

\defun{dbAddChain}{dbAddChain}
\calls{dbAddChain}{dbAddChainDomain}
\calls{dbAddChain}{dbAddChain}
\begin{chunk}{defun dbAddChain}
(defun |dbAddChain| (conform)
 (let (u)
  (when (setq u (|dbAddChainDomain| conform))
   (unless (atom u)
    (cons (cons u t) (|dbAddChain| u))))))

\end{chunk}

\section{Constructor Page Menu}

\defun{dbShowCons}{dbShowCons}
\calls{dbShowCons}{htpProperty}
\calls{dbShowCons}{pmTransFilter}
\calls{dbShowCons}{ifcar}
\calls{dbShowCons}{dbGetInputString}
\calls{dbShowCons}{bcErrorPage}
\calls{dbShowCons}{constructor?}
\calls{dbShowCons}{superMatch?}
\calls{dbShowCons}{downcase}
\calls{dbShowCons}{emptySearchPage}
\calls{dbShowCons}{htInitPageNoScroll}
\calls{dbShowCons}{htCopyProplist}
\calls{dbShowCons}{htpSetProperty}
\calls{dbShowCons}{dbShowCons}
\calls{dbShowCons}{member}
\calls{dbShowCons}{dbShowCons1}
\usesdollar{dbShowCons}{exposedOnlyIfTrue}
\begin{chunk}{defun dbShowCons}
(defun |dbShowCons| (&rest args)
 (let (cAlist filter abbrev? conname subject u options key htPage)
  (declare (special |$exposedOnlyIfTrue|))
  (setq htPage (first args))
  (setq key (second args))
  (setq options (cddr args))
  (setq cAlist (|htpProperty| htPage '|cAlist|))
  (cond
   ((eq key '|filter|)
     (setq filter
      (|pmTransFilter| (or (ifcar options) (|dbGetInputString| htPage))))
     (cond
      ((and (consp filter) (eq (car filter) '|error|))
        (|bcErrorPage| filter))
      (t
        (setq abbrev? (eq (|htpProperty| htPage '|exclusion|) '|abbrs|))
        (setq u
         (loop for x in cAlist
           when (progn
                 (setq conname (caar x))
                 (setq subject (if abbrev? (|constructor?| conname) conname))
                 (|superMatch?| filter (downcase (princ-to-string subject))))
           collect x))
        (cond
         ((null u)
           (|emptySearchPage| "constructor" filter))
         (t
           (setq htPage (|htInitPageNoScroll| (|htCopyProplist| htPage)))
           (|htpSetProperty| htPage '|cAlist| u)
           (|dbShowCons| htPage (|htpProperty| htPage '|exclusion|)))))))
   (t
    (when (member key '(|exposureOn| |exposureOff|))
      (setq |$exposedOnlyIfTrue| (eq key '|exposureOn|))
      (setq key (|htpProperty| htPage '|exclusion|)))
    (|dbShowCons1| htPage cAlist key)))))

\end{chunk}

\defun{conPageChoose}{conPageChoose}
\calls{conPageChoose}{getConstructorForm}
\calls{conPageChoose}{dbShowCons1}
\begin{chunk}{defun conPageChoose}
(defun |conPageChoose| (conname)
 (let (cAlist)
  (setq cAlist (list (cons (|getConstructorForm| conname) t)))
  (|dbShowCons1| nil cAlist '|names|)))

\end{chunk}

\defun{dbShowCons1}{dbShowCons1}
\calls{dbShowCons1}{remdup}
\calls{dbShowCons1}{isExposedConstructor}
\calls{dbShowCons1}{opOf}
\calls{dbShowCons1}{conPage}
\calls{dbShowCons1}{htpProperty}
\calls{dbShowCons1}{union}
\calls{dbShowCons1}{dbConstructorKind}
\calls{dbShowCons1}{htCopyProplist}
\calls{dbShowCons1}{htInitPageNoScroll}
\calls{dbShowCons1}{dbConsHeading}
\calls{dbShowCons1}{htSayStandard}
\calls{dbShowCons1}{htpSetProperty}
\calls{dbShowCons1}{bcNameConTable}
\calls{dbShowCons1}{bcAbbTable}
\calls{dbShowCons1}{getCDTEntry}
\calls{dbShowCons1}{getdatabase}
\calls{dbShowCons1}{bcUnixTable}
\calls{dbShowCons1}{listSort}
\calls{dbShowCons1}{function}
\calls{dbShowCons1}{qlesseqp}
\calls{dbShowCons1}{dbShowConsDoc}
\calls{dbShowCons1}{isExposedConstructor}
\calls{dbShowCons1}{dbShowConditions}
\calls{dbShowCons1}{bcConTable}
\calls{dbShowCons1}{assocleft}
\calls{dbShowCons1}{dbShowConsKinds}
\calls{dbShowCons1}{dbConsExposureMessage}
\calls{dbShowCons1}{dbPresentCons}
\calls{dbShowCons1}{htShowPageNoScroll}
\usesdollar{dbShowCons1}{conformsAreDomains}
\usesdollar{dbShowCons1}{exposedOnlyIfTrue}
\begin{chunk}{defun dbShowCons1}
(defun |dbShowCons1| (htPage cAlist key)
 (let (|$conformsAreDomains| conlist kinds kind proplist page u flist result)
 (declare (special |$conformsAreDomains| |$exposedOnlyIfTrue|))
  (setq conlist
   (remdup
    (dolist (x cAlist result)
     (push 
      (if |$exposedOnlyIfTrue|
       (|isExposedConstructor| (|opOf| (car x)))
       (car x))
      result))))
  (cond
   ((and (consp conlist) (eq (qcdr conlist) nil))
    (|conPage|
     (if (and htPage (|htpProperty| htPage '|domname|))
      (car conlist)
      (|opOf| (car conlist)))))
   (t
    (setq conlist (loop for x in conlist collect (|opOf| x)))
    (setq kinds
     (apply #'|union|
      (loop for x in conlist collect (|dbConstructorKind| x))))
    (setq kind
     (if (and (consp kinds) (eq (qcdr kinds) nil))
      (qcar kinds)
      '|constructor|))
    (setq proplist (when htPage (|htCopyProplist| htPage)))
    (setq page
     (|htInitPageNoScroll| proplist
      (|dbConsHeading| htPage conlist key kind)))
    (if (setq u (|htpProperty| page '|specialMessage|))
     (apply (car u) (cdr u)))
    (|htSayStandard| "\\beginscroll ")
    (|htpSetProperty| page '|cAlist| cAlist)
    (setq |$conformsAreDomains| (|htpProperty| page '|domname|))
    (cond
     ((eq key '|names|) (|bcNameConTable| conlist))
     ((eq key '|abbrs|)
      (|bcAbbTable|
       (loop for con in conlist collect (|getCDTEntry| con t))))
     ((eq key '|files|)
      (setq flist
       (loop for con in conlist collect (getdatabase con 'sourcefile)))
      (|bcUnixTable|
       (|listSort| #'glesseqp (remdup flist))))
     ((eq key '|documentation|) (|dbShowConsDoc| page conlist))
     (t
      (when |$exposedOnlyIfTrue|
       (setq cAlist
        (loop for x in cAlist
         when (|isExposedConstructor| (|opOf| (car x)))
         collect x)))
      (cond
       ((eq key '|conditions|) (|dbShowConditions| page cAlist kind))
       ((eq key '|parameters|)
         (|bcConTable| (remdup (assocleft cAlist))))
       ((eq key '|kinds|) (|dbShowConsKinds| cAlist)))))
    (|dbConsExposureMessage|)
    (|htSayStandard| '|\\endscroll |)
    (|dbPresentCons| page kind key)
    (|htShowPageNoScroll|)))))

\end{chunk}

\defun{dbConsExposureMessage}{dbConsExposureMessage}
\calls{dbConsExposureMessage}{htSay}
\usesdollar{dbConsExposureMessage}{atLeastOneUnexposed}
\begin{chunk}{defun dbConsExposureMessage}
(defun |dbConsExposureMessage| ()
 (declare (special |$atLeastOneUnexposed|))
  (when |$atLeastOneUnexposed|
   (|htSay| "\\newline{}-------------\\newline{}{\\em *} = unexposed")))

\end{chunk}

\defun{dbShowConsKindsFilter}{dbShowConsKindsFilter}
\calls{dbShowConsKindsFilter}{htpSetProperty}
\calls{dbShowConsKindsFilter}{dbShowCons}
\calls{dbShowConsKindsFilter}{htpProperty}
\begin{chunk}{defun dbShowConsKindsFilter}
(defun |dbShowConsKindsFilter| (htPage args)
 (|htpSetProperty| htPage '|cAlist| (second args))
 (|dbShowCons| htPage (|htpProperty| htPage '|exclusion|)))

\end{chunk}

\defun{dbShowConsDoc}{dbShowConsDoc}
\calls{dbShowConsDoc}{systemError}
\calls{dbShowConsDoc}{dbShowConsDoc1}
\calls{dbShowConsDoc}{getConstructorForm}
\calls{dbShowConsDoc}{opOf}
\calls{dbShowConsDoc}{htpProperty}
\calls{dbShowConsDoc}{remdup}
\begin{chunk}{defun dbShowConsDoc}
(defun |dbShowConsDoc| (htPage conlist)
 (labels (
  (fn (cAlist x)
   (let ((index 0))
    (loop while (not (equal (caaar cAlist) x))
       do (setq index (1+ index))
          (setq cAlist (cdr cAlist))
          (unless cAlist (|systemError|)))
    index)))
 (let (cAlist)
  (cond
   ((null (cdr conlist))
     (|dbShowConsDoc1| htPage 
      (|getConstructorForm| (|opOf| (car conlist))) nil))
   (t 
     (setq cAlist (|htpProperty| htPage '|cAlist|))
     (loop for x in (remdup conlist) do
      (|dbShowConsDoc1| htPage 
       (|getConstructorForm| x) (fn cAlist x))))))))

\end{chunk}

\defun{dbShowConsDoc1}{dbShowConsDoc1}
\calls{dbShowConsDoc1}{member}
\calls{dbShowConsDoc1}{htpProperty}
\calls{dbShowConsDoc1}{getl}
\calls{dbShowConsDoc1}{displayDomainOp}
\calls{dbShowConsDoc1}{isExposedConstructor}
\calls{dbShowConsDoc1}{getConstructorDocumentation}
\calls{dbShowConsDoc1}{getConstructorSignature}
\calls{dbShowConsDoc1}{getdatabase}
\calls{dbShowConsDoc1}{sublislis}
\calls{dbShowConsDoc1}{sublisFormal}
\calls{dbShowConsDoc1}{displayDomainOp}
\usesdollar{dbShowConsDoc1}{TriangleVariableList}
\usesdollar{dbShowConsDoc1}{Primitives}
\begin{chunk}{defun dbShowConsDoc1}
(defun |dbShowConsDoc1| (htPage conform indexOrNil)
 (let (conargs conname lt1 exposeFlag doc signature sig)
 (declare (special |$TriangleVariableList| |$Primitives|))
  (setq conname (car conform))
  (setq conargs (cdr conform))
  (cond
   ((member conname |$Primitives|)
    (setq conname (|htpProperty| htPage '|conname|))
    (setq lt1 (getl conname '|documentation|))
    (cond ((eq (caar lt1) '|constructor|) (caar lt1)))
    (cond ((eq (caadar lt1) 'nil) (caadar lt1)))
    (setq doc (car (cdadar lt1)))
    (setq sig '((category domain) (|SetCategory|) (|SetCategory|)))
    (|displayDomainOp| htPage "constructor"
       conform conname sig t doc indexOrNil '|dbSelectCon| nil nil))
   (t 
    (setq exposeFlag (|isExposedConstructor| conname))
    (setq doc (list (|getConstructorDocumentation| conname)))
    (setq signature (|getConstructorSignature| conname))
    (setq sig
     (if (eq (getdatabase conname 'constructorkind) '|category|)
        (sublislis conargs |$TriangleVariableList| signature)
        (|sublisFormal| conargs signature)))
    (|displayDomainOp| htPage "constructor" conform conname sig t doc 
      indexOrNil '|dbSelectCon| (null exposeFlag) nil)))))

\end{chunk}

\defun{getConstructorDocumentation}{getConstructorDocumentation}
\calls{getConstructorDocumentation}{lassoc}
\calls{getConstructorDocumentation}{getdatabase}
\calls{getConstructorDocumentation}{qcar}
\calls{getConstructorDocumentation}{qcaar}
\calls{getConstructorDocumentation}{qcdar}
\calls{getConstructorDocumentation}{qcadar}
\begin{chunk}{defun getConstructorDocumentation}
(defun |getConstructorDocumentation| (conname)
 (let (IT1)
  (setq IT1 (lassoc '|constructor| (getdatabase conname 'documentation)))
  (or 
   (and (consp IT1) (consp (qcar IT1)) (null (qcaar IT1)) (consp (qcdar IT1)) 
        (qcadar IT1))
   "")))

\end{chunk}

\defun{dbSelectCon}{dbSelectCon}
\calls{dbSelectCon}{conPage}
\calls{dbSelectCon}{opOf}
\calls{dbSelectCon}{htpProperty}
\begin{chunk}{defun dbSelectCon}
(defun |dbSelectCon| (htPage which index)
 (declare (ignore which))
 (|conPage| (|opOf| (car (elt (|htpProperty| htPage '|cAlist|) index)))))

\end{chunk}

\defun{dbShowConditions}{dbShowConditions}
\calls{dbShowConditions}{htpProperty}
\calls{dbShowConditions}{opOf}
\calls{dbShowConditions}{splitConTable}
\calls{dbShowConditions}{pluralize}
\calls{dbShowConditions}{length}
\calls{dbShowConditions}{dbSayItems}
\calls{dbShowConditions}{bcConPredTable}
\calls{dbShowConditions}{htSayHrule}
\begin{chunk}{defun dbShowConditions}
(defun |dbShowConditions| (htPage cAlist kind)
 (let (conform conname article whichever lt1 consNoPred consPred singular 
       plural)
  (setq conform (|htpProperty| htPage '|conform|))
  (setq conname (|opOf| conform))
  (setq article (|htpProperty| htPage '|article|))
  (setq whichever (|htpProperty| htPage '|whichever|))
  (setq lt1 (|splitConTable| cAlist))
  (setq consNoPred (car lt1))
  (setq consPred (cdr lt1))
  (setq singular (list kind " is"))
  (setq plural (list (|pluralize| (princ-to-string kind)) " are"))
  (|dbSayItems| (|#| consNoPred) singular plural " unconditional")
  (|bcConPredTable| consNoPred conname)
  (|htSayHrule|)
  (|dbSayItems| (|#| consPred) singular plural " conditional")
  (|bcConPredTable| consPred conname)))

\end{chunk}

\defun{dbConsHeading}{dbConsHeading}
\calls{dbConsHeading}{htpProperty}
\calls{dbConsHeading}{length}
\calls{dbConsHeading}{remdup}
\calls{dbConsHeading}{form2HtString}
\calls{dbConsHeading}{capitalize}
\calls{dbConsHeading}{pluralize}
\calls{dbConsHeading}{member}
\calls{dbConsHeading}{nequal}
\usesdollar{dbConsHeading}{exposedOnlyIfTrue}
\begin{chunk}{defun dbConsHeading}
(defun |dbConsHeading| (htPage conlist view kind)
 (let (thing place count rank modifier exposureWord firstWord prefix 
       placepart connective heading)
(declare (special |$exposedOnlyIfTrue|))
 (setq thing (or (and htPage (|htpProperty| htPage '|thing|)) "constructor"))
 (setq place
  (when htPage
   (or (|htpProperty| htPage '|domname|) (|htpProperty| htPage '|conform|))))
 (setq count (|#| (remdup conlist)))
 (cond
  ((string= thing "benefactor")
    (list (princ-to-string count) " Constructors Used by " 
          (|form2HtString| place nil t) ))
  (t
   (setq modifier
    (cond
     ((string= thing "argument")
       (setq rank (and htPage (|htpProperty| htPage '|rank|)))
       (list " Possible " rank " "))
     ((eq kind '|constructor|)
       (list " "))
     (t
       (cons " " (|capitalize| (princ-to-string kind)) " "))))
   (setq exposureWord (when |$exposedOnlyIfTrue| '(" Exposed ")))
   (setq prefix
    (cond
     ((eql count 1)
      (cons (princ-to-string count)
       (append modifier (list (|capitalize| thing)))))
     (t
      (setq firstWord (if (eql count 0) "No "(princ-to-string count)))
      (cons firstWord
       (append exposureWord
        (append modifier
         (list (|capitalize| (|pluralize| thing)))))))))
   (setq placepart
    (when place (list " of {\\em " (|form2HtString| place nil t) '})))
   (setq heading (append prefix placepart))
   (setq connective
    (if (|member| view '(|abbrs| |files| |kinds|)) " as " " with "))
   (cond
    ((and (nequal count 0)
          (|member| view '(|abbrs| |files| |parameters| |conditions|)))
     (setq heading
      (append heading
       (list " viewed" connective "{\\em " (princ-to-string view) "}")))))
   heading))))

\end{chunk}

\defun{dbShowConstructorLines}{dbShowConstructorLines}
\calls{dbShowConstructorLines}{getConstructorForm}
\calls{dbShowConstructorLines}{intern}
\calls{dbShowConstructorLines}{dbName}
\calls{dbShowConstructorLines}{dbShowCons1}
\calls{dbShowConstructorLines}{listSort}
\calls{dbShowConstructorLines}{function}
\calls{dbShowConstructorLines}{glesseqp}
\begin{chunk}{defun dbShowConstructorLines}
(defun |dbShowConstructorLines| (lines)
 (let (cAlist)
  (setq cAlist
   (loop for line in lines
    collect (cons (|getConstructorForm| (|intern| (|dbName| line))) t)))
  (|dbShowCons1| nil (|listSort| #'glesseqp cAlist) '|names|)))

\end{chunk}

\defun{bcUnixTable}{bcUnixTable}
\calls{bcUnixTable}{htSay}
\calls{bcUnixTable}{htBeginTable}
\calls{bcUnixTable}{namestring}
\calls{bcUnixTable}{findfile}
\calls{bcUnixTable}{htMakePage}
\calls{bcUnixTable}{htEndTable}
\uses{bcUnixTable}{firstTime}
\begin{chunk}{defun bcUnixTable}
(defun |bcUnixTable| (u)
 (declare (special firstTime))
 (let (filename)
  (|htSay| "\\newline")
  (|htBeginTable|)
  (setq firstTime t)
  (loop for x in u do
    (|htSay| "{")
    (setq filename (namestring ($findfile (princ-to-string x) "SPAD")))
    (|htMakePage|
     (list
       (list '|text| "\\unixcommand{" (pathname-name (string x))
             "}{$AXIOM/lib/SPADEDIT " filename "} ")))
    (|htSay| "}"))
  (|htEndTable|)))

\end{chunk}

\subsection{Special Code for Union, Mapping, and Record}

\defun{dbSpecialDescription}{dbSpecialDescription}
\calls{dbSpecialDescription}{getConstructorForm}
\calls{dbSpecialDescription}{form2HtString}
\calls{dbSpecialDescription}{htInitPage}
\calls{dbSpecialDescription}{htpSetProperty}
\calls{dbSpecialDescription}{dbShowConsDoc1}
\calls{dbSpecialDescription}{htShowPage}
\usesdollar{dbSpecialDescription}{conformsAreDomains}
\begin{chunk}{defun dbSpecialDescription}
(defun |dbSpecialDescription| (conname)
 (let (conform heading page)
 (declare (special |$conformsAreDomains|))
  (setq conform (|getConstructorForm| conname))
  (setq heading
    (list "Description of Domain {\\sf " (|form2HtString| conform) "}"))
  (setq page (|htInitPage| heading nil))
  (|htpSetProperty| page '|conname| conname)
  (setq |$conformsAreDomains| nil)
  (|dbShowConsDoc1| page conform nil)
  (|htShowPage|)))

\end{chunk}

\defun{dbSpecialOperations}{dbSpecialOperations}
\calls{dbSpecialOperations}{htInitPage}
\calls{dbSpecialOperations}{getConstructorForm}
\calls{dbSpecialOperations}{dbSpecialExpandIfNecessary}
\calls{dbSpecialOperations}{getl}
\calls{dbSpecialOperations}{form2HtString}
\calls{dbSpecialOperations}{htpSetProperty}
\calls{dbSpecialOperations}{dbShowOp1}
\begin{chunk}{defun dbSpecialOperations}
(defun |dbSpecialOperations| (conname)
 (let (page conform opAlist fromHeading)
  (setq page (|htInitPage| nil nil))
  (setq conform (|getConstructorForm| conname))
  (setq opAlist
   (|dbSpecialExpandIfNecessary| conform
    (cdr (getl conname '|documentation|))))
  (setq fromHeading (list " from domain {\\sf " (|form2HtString| conform) "}"))
  (|htpSetProperty| page '|fromHeading| fromHeading)
  (|htpSetProperty| page '|conform| conform)
  (|htpSetProperty| page '|opAlist| opAlist)
  (|htpSetProperty| page '|noUsage| t)
  (|htpSetProperty| page '|condition?| '|no|)
  (|dbShowOp1| page opAlist "operation" '|names|)))

\end{chunk}

\defun{dbSpecialExports}{dbSpecialExports}
\calls{dbSpecialExports}{getConstructorForm}
\calls{dbSpecialExports}{htInitPage}
\calls{dbSpecialExports}{form2HtString}
\calls{dbSpecialExports}{dbSpecialExpandIfNecessary}
\calls{dbSpecialExports}{getl}
\calls{dbSpecialExports}{kePageDisplay}
\calls{dbSpecialExports}{htShowPage}
\begin{chunk}{defun dbSpecialExports}
(defun |dbSpecialExports| (conname)
 (let (conform page opAlist)
  (setq conform (|getConstructorForm| conname))
  (setq page
   (|htInitPage| (list "Exports of {\\sf " (|form2HtString| conform) "}") nil))
  (setq opAlist
   (|dbSpecialExpandIfNecessary| conform 
    (cdr (getl conname '|documentation|))))
  (|kePageDisplay| page "operation" opAlist)
  (|htShowPage|)))

\end{chunk}

\defun{dbSpecialExpandIfNecessary}{dbSpecialExpandIfNecessary}
\calls{dbSpecialExpandIfNecessary}{qcar}
\calls{dbSpecialExpandIfNecessary}{qcdar}
\calls{dbSpecialExpandIfNecessary}{qcadar}
\calls{dbSpecialExpandIfNecessary}{qcdr}
\begin{chunk}{defun dbSpecialExpandIfNecessary}
(defun |dbSpecialExpandIfNecessary| (conform opAlist)
 (if (and (consp opAlist) (consp (qcar opAlist)) (consp (qcdar opAlist))
          (consp (qcadar opAlist)) (cdr (qcdr (qcadar opAlist))))
    opAlist
    (dolist (item opAlist)
     (dolist (pair (cdr item))
      (rplacd pair (list t conform t (second pair))))))
  opAlist)

\end{chunk}

\begin{chunk}{initvars}
(defvar message1 (concatenate 'string
 "{\\sf Record(a:A,b:B)} is used to create the class of pairs of objects "
 "made up of a value of type {\\em A} selected by the symbol {\\em a} and "
 "a value of type {\\em B} selected by the symbol {\\em b}. "
 "In general, the {\\sf Record} constructor can take any number of arguments "
 "and thus can be used to create aggregates of heterogeneous components of "
 "arbitrary size selectable by name. "
 "{\\sf Record} is a primitive domain of Axiom which cannot be "
 "defined in the Axiom language."))

\end{chunk}

\begin{chunk}{postvars}
(eval-when (eval load)
(put '|Record| '|documentation|
 (subst message1 'message
  `((|constructor| (nil message))
    (= (((|Boolean|) $ $)
 "\\spad{r = s} tests for equality of two records \\spad{r} and \\spad{s}"))
    (|coerce| (((|OutputForm|) $)
 "\\spad{coerce(r)} returns an representation of \\spad{r} as an output form")
    (($ (|List| (|Any|)))
   ,(concatenate 'string
"\\spad{coerce(u)}, where \\spad{u} is the list \\spad{[x,y]} for \\spad{x} "
"of type \\spad{A} and \\spad{y} of type \\spad{B}, returns the record "
"\\spad{[a:x,b:y]}")))
    (|elt| ((A $ "a")
  ,(concatenate 'string
    "\\spad{r . a} returns the value stored in record \\spad{r} under "
    "selector \\spad{a}."))
    ((B $ "b")
  ,(concatenate 'string 
"\\spad{r . b} returns the value stored in record \\spad{r} "
   "under selector \\spad{b}.")))
    (|setelt| ((A $ "a" A)
  ,(concatenate 'string 
"\\spad{r . a := x} destructively replaces the value stored in "
"record \\spad{r} under selector \\spad{a} by the value of \\spad{x}. "
"Error: if \\spad{r} has not been previously assigned a value."))
    ((B $ "b" B)
  ,(concatenate 'string 
"\\spad{r . b := y} destructively replaces the value stored in "
"record \\spad{r} under selector \\spad{b} by the value of \\spad{y}. "
"Error: if \\spad{r} has not been previously assigned a value."))))
 :test #'equal)))

\end{chunk}

\begin{chunk}{initvars}
(defvar message2 (concatenate 'string
"{\\sf Union(A,B)} denotes the class of objects which are which are either "
"members of domain {\\em A} or of domain {\\em B}. The {\\sf Union} "
"constructor can take any number of arguments. "
"For an alternate form of {\\sf Union} with \"tags\", see "
"\\downlink{Union(a:A,b:B)}{DomainUnion}. {\\sf Union} is a primitive "
"domain of Axiom which cannot be defined in the Axiom language."))

\end{chunk}

\begin{chunk}{postvars}
(eval-when (eval load)
(put '|UntaggedUnion| '|documentation|
 (subst message2 'message
  `((|constructor| (nil message))
    (= (((|Boolean|) $ $)
  ,(concatenate 'string 
"\\spad{u = v} tests if two objects of the union are equal, "
"that is, u and v are hold objects of same branch which are equal.")))
    (|case| (((|Boolean|) $ "A")
  ,(concatenate 'string 
"\\spad{u case A} tests if \\spad{u} is of the type \\spad{A} "
"branch of the union."))
    (((|Boolean|) $ "B")
  ,(concatenate 'string 
"\\spad{u case B} tests if \\spad{u} is of the \\spad{B} branch "
"of the union.")))
    (|coerce| ((A $)
  ,(concatenate 'string 
"\\spad{coerce(u)} returns \\spad{x} of type \\spad{A} if "
"\\spad{x} is of the \\spad{A} branch of the union. "
"Error: if \\spad{u} is of the \\spad{B} branch of the union."))
    ((B $)
  ,(concatenate 'string 
"\\spad{coerce(u)} returns \\spad{x} of type \\spad{B} if "
"\\spad{x} is of the \\spad{B} branch of the union. "
"Error: if \\spad{u} is of the \\spad{A} branch of the union."))
    (($ A)
  ,(concatenate 'string 
"\\spad{coerce(x)}, where \\spad{x} has type \\spad{A}, "
"returns \\spad{x} as a union type."))
    (($ B)
  ,(concatenate 'string 
"\\spad{coerce(y)}, where \\spad{y} has type \\spad{B}, "
"returns \\spad{y} as a union type."))))
 :test #'equal)))

\end{chunk}

\begin{chunk}{initvars}
(defvar message3 (concatenate 'string
 "{\\sf Union(a:A,b:B)} denotes the class of objects which are either "
"members of domain {\\em A} or of domain {\\em B}. "
"The symbols {\\em a} and {\\em b} are called \"tags\" and are used to "
"identify the two \"branches\" of the union. "
"The {\\sf Union} constructor can take any number of arguments and has an "
"alternate form without {\\em tags} "
"(see \\downlink{Union(A,B)}{UntaggedUnion}). "
"This tagged {\\sf Union} type is necessary, for example, to disambiguate "
"two branches of a union where {\\em A} and {\\em B} denote the same type. "
"{\\sf Union} is a primitive domain of Axiom which cannot be "
"defined in the Axiom language."))

\end{chunk}

\begin{chunk}{postvars}
(eval-when (eval load)
(put '|Union| '|documentation|
 (subst message3 'message
  `((|constructor| (NIL MESSAGE))
     (= (((|Boolean|) $ $)
  ,(concatenate 'string 
"\\spad{u = v} tests if two objects of the union are equal, that "
"is, \\spad{u} and \\spad{v} are objects of same branch which are equal.")))
    (|case| (((|Boolean|) $ "A")
   "\\spad{u case a} tests if \\spad{u} is of branch \\spad{a} of the union.")
    (((|Boolean|) $ "B")
  "\\spad{u case b} tests if \\spad{u} is of branch \\spad{b} of the union."))
    (|coerce| ((A $)
  ,(concatenate 'string 
"\\spad{coerce(u)} returns \\spad{x} of type \\spad{A} if "
"\\spad{x} is of branch \\spad{a} of the union. "
"Error: if \\spad{u} is of branch \\spad{b} of the union."))
    ((B $)
  ,(concatenate 'string 
"\\spad{coerce(u)} returns \\spad{x} of type \\spad{B} if "
"\\spad{x} is of branch \\spad{b} branch of the union. "
"Error: if \\spad{u} is of the \\spad{a} branch of the union."))
    (($ A)
  ,(concatenate 'string 
"\\spad{coerce(x)}, where \\spad{x} has type \\spad{A}, returns "
"\\spad{x} as a union type."))
    (($ B)
  ,(concatenate 'string 
"\\spad{coerce(y)}, where \\spad{y} has type \\spad{B}, returns "
"\\spad{y} as a union type."))))
 :test #'equal)))

\end{chunk}

\begin{chunk}{initvars}
(defvar message4 (concatenate 'string
"{\\sf Mapping(T,S,...)} denotes the class of objects which are mappings from "
"a source domain ({\\em S,...}) into a target domain {\\em T}. The "
"{\\sf Mapping} constructor can take any number of arguments."
" All but the first argument is regarded as part of a source tuple for the "
"mapping. For example, {\\sf Mapping(T,A,B)} denotes the class of mappings "
"from {\\em (A,B)} into {\\em T}. "
"{\\sf Mapping} is a primitive domain of Axiom which cannot be defined in "
"the Axiom language."))

\end{chunk}

\begin{chunk}{postvars}
(eval-when (eval load)
(put '|Mapping| '|documentation|
 (subst message4 'message
  '((|constructor| (NIL MESSAGE))
    (= (((|Boolean|) $ $)
   "\\spad{u = v} tests if mapping objects are equal.")))
 :test #'equal)))

\end{chunk}

\begin{chunk}{initvars}
(defvar message5 (concatenate 'string
"{\\em Enumeration(a1, a2 ,..., aN)} creates an object which is exactly one "
"of the N symbols {\\em a1}, {\\em a2}, ..., or {\\em aN}, N > 0. "
" The {\\em Enumeration} can constructor can take any number of symbols as "
"arguments."))

\end{chunk}

\begin{chunk}{postvars}
(eval-when (eval load)
(put '|Enumeration| '|documentation|
 (subst message5 'message
  `((|constructor| (nil message))
    (= (((|Boolean|) $ $)
  ,(concatenate 'string 
"\\spad{e = f} tests for equality of two enumerations \\spad{e} "
"and \\spad{f}")))
   (^= (((|Boolean|) $ $)
  ,(concatenate 'string 
"\\spad{e ^= f} tests that two enumerations \\spad{e} and "
"\\spad{f} are not equal")))
   (|coerce| (((|OutputForm|) $)
  ,(concatenate 'string 
"\\spad{coerce(e)} returns a representation of enumeration "
"\\spad{r} as an output form"))
   (($ (|Symbol|))
  ,(concatenate 'string 
"\\spad{coerce(s)} converts a symbol \\spad{s} into an "
"enumeration which has \\spad{s} as a member symbol"))))
 :test #'equal)))

\end{chunk}

\defun{lefts}{lefts}
\calls{lefts}{hkeys}
\uses{lefts}{hascategory-hash}
\begin{chunk}{defun lefts}
(defun |lefts| (u)
 (let (keys)
  (setq keys (hkeys *hascategory-hash*))
  (loop for x in keys when (equal (cdr x) u) collect x)))

\end{chunk}

\subsection{Build Library Database (libdb.text,...)}

\defun{dbMkForm}{dbMkForm}
\begin{chunk}{defun dbMkForm}
(defun |dbMkForm| (x)
 (or (and (atom x) (cons x nil)) x))

\end{chunk}

\defun{libConstructorSig}{libConstructorSig}
\calls{libConstructorSig}{getdatabase}
\calls{libConstructorSig}{take}
\calls{libConstructorSig}{length}
\calls{libConstructorSig}{sublislis}
\calls{libConstructorSig}{form2LispString}
\calls{libConstructorSig}{ncParseFromString}
\calls{libConstructorSig}{sayBrightly}
\usesdollar{libConstructorSig}{TriangleVariableList}
\begin{chunk}{defun libConstructorSig}
(defun |libConstructorSig| (arg)
 (labels (
  (fn (x)
   (cond
    ((atom x) x)
    ((and (consp x) (eq (qcar x) '|Join|) (consp (qcdr x)))
      (list '|Join| (fn (qcadr x)) '|etc|))
    ((and (consp x) (eq (qcar x) 'category))
     '|etc|)
    (t
     (loop for y in x collect (fn y)))))
  (g (x u i)
   "does x appear in any but i-th element of u?"
   (some #'identity
    (loop for y in u for j from 1
     when (not (= i j))
     collect (contained x y)))))
 (let (conname argl formals keys sig sigpart)
 (declare (special |$TriangleVariableList|))
  (setq conname (car arg))
  (setq argl (cdr arg))
  (setq sig (cdar (getdatabase conname 'constructormodemap)))
  (setq formals (take (|#| argl) |$FormalMapVariableList|))
  (setq sig (sublislis formals |$TriangleVariableList| sig))
  (setq keys
   (loop for f in formals for i from 1
    collect (g f sig i)))
  (setq sig
   (fn (sublislis argl |$FormalMapVariableList| sig)))
  (setq sig (cons (car sig)
   (loop for a in argl for s in (cdr sig) for k in keys
    collect (if k (list #\: a s) s))))
  (setq sigpart (|form2LispString| (cons '|Mapping| sig)))
  (unless (|ncParseFromString| sigpart)
    (|sayBrightly| (list "Won't parse: " sigpart)))
  sigpart)))

\end{chunk}

\chapter{Utility functions}
\section{Utility functions}

\defun{delasc}{Delete an alist pair given the key}
\begin{chunk}{defun delasc 0}
(defun delasc (key alist)
 (remove key alist :key #'car))

\end{chunk}

\defun{readline}{readline}
\begin{chunk}{defun readline}
(defun readline (t1)
 (if t1
  (|read-line| t1)
  (|read-line| *STANDARD-INPUT*)))

\end{chunk}

\defun{isWrapped}{isWrapped}
This was proven by ACL2 to accept any input and return either T or NIL.
Note that ACL2 does not support FLOATP.
\begin{chunk}{defun isWrapped 0 ACL2}
(defun isWrapped (x)
  (or (and (consp x) (eq (car x) 'wrapped)) 
      (acl2-numberp x)
      (stringp x)))

;==>
;(OR (EQUAL (ISWRAPPED X) T) (EQUAL (ISWRAPPED X) NIL))

\end{chunk}

\sig{isWrapped}{t}{(or t nil)}
\begin{chunk}{defun isWrapped :proven}
(defun |isWrapped| (x)
  (or (and (consp x) (eq (qcar x) 'wrapped)) 
      (numberp x)
      (floatp x) 
      (stringp x)))

\end{chunk}

\chapter{The Proofs}
\begin{chunk}{acl2}
\getchunk{defun isWrapped 0 ACL2}
\end{chunk}

\chapter{The Interpreter}
\begin{chunk}{Interpreter}
(setq *print-array* nil)
(setq *print-circle* nil)
(setq *print-pretty* nil)

(in-package "BOOT")
\getchunk{initvars}

;;; level 0 macros

\getchunk{defmacro bit-to-truth 0}
\getchunk{defmacro bvec-elt 0}
\getchunk{defmacro cdancols 0}
\getchunk{defmacro cdanrows 0}
\getchunk{defmacro cdaref2 0}
\getchunk{defmacro cdelt 0}
\getchunk{defmacro cdlen 0}
\getchunk{defmacro cdsetaref2 0}
\getchunk{defmacro cdsetelt 0}
\getchunk{defmacro dancols 0}
\getchunk{defmacro danrows 0}
\getchunk{defmacro daref2 0}
\getchunk{defmacro delt 0}
\getchunk{defmacro DFAcos 0}
\getchunk{defmacro DFAcosh 0}
\getchunk{defmacro DFAdd 0}
\getchunk{defmacro DFAsin 0}
\getchunk{defmacro DFAsinh 0}
\getchunk{defmacro DFAtan 0}
\getchunk{defmacro DFAtan2 0}
\getchunk{defmacro DFAtanh 0}
\getchunk{defmacro DFCos 0}
\getchunk{defmacro DFCosh 0}
\getchunk{defmacro DFDivide 0}
\getchunk{defmacro DFEql 0}
\getchunk{defmacro DFExp 0}
\getchunk{defmacro DFExpt 0}
\getchunk{defmacro DFIntegerDivide 0}
\getchunk{defmacro DFIntegerExpt 0}
\getchunk{defmacro DFIntegerMultiply 0}
\getchunk{defmacro DFLessThan 0}
\getchunk{defmacro DFLog 0}
\getchunk{defmacro DFLogE 0}
\getchunk{defmacro DFMax 0}
\getchunk{defmacro DFMin 0}
\getchunk{defmacro DFMinusp 0}
\getchunk{defmacro DFMultiply 0}
\getchunk{defmacro DFSin 0}
\getchunk{defmacro DFSinh 0}
\getchunk{defmacro DFSqrt 0}
\getchunk{defmacro DFSubtract 0}
\getchunk{defmacro DFTan 0}
\getchunk{defmacro DFTanh 0}
\getchunk{defmacro DFUnaryMinus 0}
\getchunk{defmacro DFZerop 0}
\getchunk{defmacro dlen 0}
\getchunk{defmacro dsetaref2 0}
\getchunk{defmacro dsetelt 0}
\getchunk{defmacro idChar? 0}
\getchunk{defmacro identp 0}
\getchunk{defmacro FloatError 0}
\getchunk{defmacro fracpart 0}
\getchunk{defmacro frameExposureData 0}
\getchunk{defmacro frameHiFiAccess 0}
\getchunk{defmacro frameHistListAct 0}
\getchunk{defmacro frameHistList 0}
\getchunk{defmacro frameHistListLen 0}
\getchunk{defmacro frameHistoryTable 0}
\getchunk{defmacro frameHistRecord 0}
\getchunk{defmacro frameInteractive 0}
\getchunk{defmacro frameIOIndex 0}
\getchunk{defmacro frameName 0}
\getchunk{defmacro frameNames 0}
\getchunk{defmacro getMsgArgL 0}
\getchunk{defmacro getMsgKey 0}
\getchunk{defmacro getMsgPosTagOb 0}
\getchunk{defmacro getMsgPrefix 0}
\getchunk{defmacro getMsgPrefix? 0}
\getchunk{defmacro getMsgTag 0}
\getchunk{defmacro getMsgTag? 0}
\getchunk{defmacro getMsgText 0}
\getchunk{defmacro hashCode? 0}
\getchunk{defmacro line-clear 0}
\getchunk{defmacro make-cdouble-matrix 0}
\getchunk{defmacro make-cdouble-vector 0}
\getchunk{defmacro make-double-matrix 0}
\getchunk{defmacro make-double-matrix1 0}
\getchunk{defmacro make-double-vector 0}
\getchunk{defmacro make-double-vector1 0}
\getchunk{defmacro qcsize 0}
\getchunk{defmacro qsabsval 0}
\getchunk{defmacro qsadd1 0}
\getchunk{defmacro qsdifference 0}
\getchunk{defmacro qsgreaterp 0}
\getchunk{defmacro qslessp 0}
\getchunk{defmacro qsmax 0}
\getchunk{defmacro qsmin 0}
\getchunk{defmacro qsminus 0}
\getchunk{defmacro qsoddp 0}
\getchunk{defmacro qsplus 0}
\getchunk{defmacro qssub1 0}
\getchunk{defmacro qstimes 0}
\getchunk{defmacro qszerop 0}
\getchunk{defmacro setMsgPrefix 0}
\getchunk{defmacro setMsgText 0}
\getchunk{defmacro spadConstant 0}

;;; above level 0 macros

\getchunk{defmacro ancolsU8}
\getchunk{defmacro ancolsU16}
\getchunk{defmacro ancolsU32}
\getchunk{defmacro anrowsU8}
\getchunk{defmacro anrowsU16}
\getchunk{defmacro anrowsU32}
\getchunk{defmacro aref2U8}
\getchunk{defmacro aref2U16}
\getchunk{defmacro aref2U32}
\getchunk{defmacro assq}
\getchunk{defmacro bvec-setelt}
\getchunk{defmacro bvec-size}
\getchunk{defmacro eltU8}
\getchunk{defmacro eltU16}
\getchunk{defmacro eltU32}
\getchunk{defmacro funfind}
\getchunk{defmacro hget}
\getchunk{defmacro leader?}
\getchunk{defmacro line?}
\getchunk{defmacro makeMatrixU8}
\getchunk{defmacro makeMatrix1U8}
\getchunk{defmacro makeMatrixU16}
\getchunk{defmacro makeMatrix1U16}
\getchunk{defmacro makeMatrixU32}
\getchunk{defmacro makeMatrix1U32}
\getchunk{defmacro mkObj}
\getchunk{defmacro mkObjCode}
\getchunk{defmacro mkObjWrap}
\getchunk{defmacro objCodeVal}
\getchunk{defmacro objCodeMode}
\getchunk{defmacro objMode}
\getchunk{defmacro objSetMode}
\getchunk{defmacro objSetVal}
\getchunk{defmacro objVal}
\getchunk{defmacro objValUnwrap}
\getchunk{defmacro qsDot26432}
\getchunk{defmacro qsDot2Mod6432}
\getchunk{defmacro qsMod6432}
\getchunk{defmacro qsMulAdd6432}
\getchunk{defmacro qsMulAddMod6432}
\getchunk{defmacro qsMul6432}
\getchunk{defmacro qsMulMod32}
\getchunk{defmacro qvlenU8}
\getchunk{defmacro qvlenU16}
\getchunk{defmacro qvlenU32}
\getchunk{defmacro Rest}
\getchunk{defmacro startsId?}
\getchunk{defmacro setAref2U8}
\getchunk{defmacro setAref2U16}
\getchunk{defmacro setAref2U32}
\getchunk{defmacro seteltU8}
\getchunk{defmacro seteltU16}
\getchunk{defmacro seteltU32}
\getchunk{defmacro toScreen?}
\getchunk{defmacro trapNumericErrors}
\getchunk{defmacro truth-to-bit}
\getchunk{defmacro while}
\getchunk{defmacro whileWithResult}

;;; layer 0 (all common lisp)

\getchunk{defun acot 0}
\getchunk{defun acoth 0}
\getchunk{defun acsc 0}
\getchunk{defun acsch 0}
\getchunk{defun asec 0}
\getchunk{defun asech 0}
\getchunk{defun axiomVersion 0}

\getchunk{defun basicStringize 0}
\getchunk{defun BesselasymptA 0}
\getchunk{defun BesselasymptB 0}
\getchunk{defun BesselIBackRecur 0}
\getchunk{defun BooleanEquality 0}
\getchunk{defun bvec-and 0}
\getchunk{defun bvec-concat 0}
\getchunk{defun bvec-copy 0}
\getchunk{defun bvec-equal 0}
\getchunk{defun bvec-greater 0}
\getchunk{defun bvec-make-full 0}
\getchunk{defun bvec-nand 0}
\getchunk{defun bvec-nor 0}
\getchunk{defun bvec-not 0}
\getchunk{defun bvec-or 0}
\getchunk{defun bvec-xor 0}

\getchunk{defun cgammaAdjust 0}
\getchunk{defun cgammaBernsum 0}
\getchunk{defun cgammaG 0}
\getchunk{defun cgammat 0}
\getchunk{defun chebf01coefmake 0}
\getchunk{defun chebstarevalarr 0}
\getchunk{defun cleanupLine 0}
\getchunk{defun clearMacroTable 0}
\getchunk{defun concat 0}
\getchunk{defun concatWithBlanks 0}
\getchunk{defun cot 0}
\getchunk{defun cotdiffeval 0}
\getchunk{defun coth 0}
\getchunk{defun createCurrentInterpreterFrame 0}
\getchunk{defun credits 0}
\getchunk{defun csc 0}
\getchunk{defun csch 0}
\getchunk{defun c-to-s 0}

\getchunk{defun dbKind 0}
\getchunk{defun dbRead 0}
\getchunk{defun delasc 0}
\getchunk{defun Delay 0}
\getchunk{defun desiredMsg 0}
\getchunk{defun DirToString 0}
\getchunk{defun displayFrameNames 0}
\getchunk{defun divide2 0}
\getchunk{defun dqAppend 0}
\getchunk{defun dqToList 0}
\getchunk{defun dqUnit 0}

\getchunk{defun embed2 0}
\getchunk{defun emptyInterpreterFrame 0}
\getchunk{defun endedp 0}
\getchunk{defun evalSharpOne 0}

\getchunk{defun fin 0}
\getchunk{defun findFrameInRing 0}
\getchunk{defun flatten 0}
\getchunk{defun flattenOperationAlist 0}
\getchunk{defun fnameExists? 0}
\getchunk{defun fnameName 0}
\getchunk{defun fnameReadable? 0}
\getchunk{defun fnameType 0}
\getchunk{defun frameNames 0}
\getchunk{defun From 0}
\getchunk{defun FromTo 0}

\getchunk{defun get-a-line 0}
\getchunk{defun get-current-directory 0}
\getchunk{defun getenviron 0}
\getchunk{defun getl 0}
\getchunk{defun getLinePos 0}
\getchunk{defun getLineText 0}
\getchunk{defun getMsgKey? 0}
\getchunk{defun getParserMacroNames 0}
\getchunk{defun getPreStL 0}
\getchunk{defun getspoolname 0}

\getchunk{defun hasCorrectTarget 0}
\getchunk{defun hasOptArgs? 0}
\getchunk{defun horner 0}
\getchunk{defun htpAddToPageDescription 0}
\getchunk{defun htpMakeEmptyPage 0}
\getchunk{defun htSayStandard 0}

\getchunk{defun ignorep 0}
\getchunk{defun incActive? 0}
\getchunk{defun incCommand? 0}
\getchunk{defun incDrop 0}
\getchunk{defun incHandleMessage 0}
\getchunk{defun inclmsgConsole 0}
\getchunk{defun inclmsgFinSkipped 0}
\getchunk{defun inclmsgPrematureEOF 0}
\getchunk{defun inclmsgCmdBug 0}
\getchunk{defun inclmsgIfBug 0}
\getchunk{defun incPrefix? 0}
\getchunk{defun initial-substring 0}
\getchunk{defun init-memory-config 0}
\getchunk{defun insertPos 0}
\getchunk{defun integer-decode-float-denominator 0}
\getchunk{defun integer-decode-float-exponent 0}
\getchunk{defun integer-decode-float-sign 0}
\getchunk{defun integer-decode-float-numerator 0}
\getchunk{defun intloopPrefix? 0}
\getchunk{defun isIntegerString 0}
\getchunk{defun isWrapped :proven} 

\getchunk{defun keyword 0}
\getchunk{defun keyword? 0}

\getchunk{defun lastcount 0}
\getchunk{defun lfcomment 0}
\getchunk{defun lferror 0}
\getchunk{defun lffloat 0}
\getchunk{defun lfid 0}
\getchunk{defun lfinteger 0}
\getchunk{defun lfnegcomment 0}
\getchunk{defun lfrinteger 0}
\getchunk{defun lfspaces 0}
\getchunk{defun lfstring 0}
\getchunk{defun libdbTrim 0}
\getchunk{defun limitedPrint1 0}
\getchunk{defun line-advance-char 0}
\getchunk{defun line-at-end-p 0}
\getchunk{defun line-current-segment 0}
\getchunk{defun line-new-line 0}
\getchunk{defun line-next-char 0}
\getchunk{defun line-past-end-p 0}
\getchunk{defun line-print 0}
\getchunk{defun lnCreate 0}
\getchunk{defun lnExtraBlanks 0}
\getchunk{defun lnFileName? 0}
\getchunk{defun lnGlobalNum 0}
\getchunk{defun lnImmediate? 0}
\getchunk{defun lnLocalNum 0}
\getchunk{defun lnPlaceOfOrigin 0}
\getchunk{defun lnSetGlobalNum 0}
\getchunk{defun lnString 0}
\getchunk{defun logH 0}
\getchunk{defun logS 0}

\getchunk{defun mac0Define 0}
\getchunk{defun mac0InfiniteExpansion,name 0}
\getchunk{defun make-absolute-filename 0}
\getchunk{defun makeByteWordVec2 0}
\getchunk{defun makeInitialModemapFrame 0}
\getchunk{defun manexp 0}
\getchunk{defun markUnique 0}
\getchunk{defun member 0}
\getchunk{defun mkObjFn 0}
\getchunk{defun monitor-add 0}
\getchunk{defun monitor-apropos 0}
\getchunk{defun monitor-autoload 0}
\getchunk{defun monitor-checkpoint 0}
\getchunk{defun monitor-decr 0}
\getchunk{defun monitor-delete 0}
\getchunk{defun monitor-dirname 0}
\getchunk{defun monitor-disable 0}
\getchunk{defun monitor-enable 0}
\getchunk{defun monitor-end 0}
\getchunk{defun monitor-exposedp 0}
\getchunk{defun monitor-file 0}
\getchunk{defun monitor-help 0}
\getchunk{defun monitor-incr 0}
\getchunk{defun monitor-info 0}
\getchunk{defun monitor-inittable 0}
\getchunk{defun monitor-libname 0}
\getchunk{defun monitor-nrlib 0}
\getchunk{defun monitor-parse 0}
\getchunk{defun monitor-percent 0}
\getchunk{defun monitor-readinterp 0}
\getchunk{defun monitor-report 0}
\getchunk{defun monitor-reset 0}
\getchunk{defun monitor-restore 0}
\getchunk{defun monitor-results 0}
\getchunk{defun monitor-spadfile 0}
\getchunk{defun monitor-tested 0}
\getchunk{defun monitor-untested 0}
\getchunk{defun monitor-write 0}

\getchunk{defun ncError 0}
\getchunk{defun ncloopEscaped 0}
\getchunk{defun ncloopPrefix? 0}
\getchunk{defun ncloopPrintLines 0}
\getchunk{defun next-line 0}
\getchunk{defun nonBlank 0}
\getchunk{defun npAnyNo 0}
\getchunk{defun npboot 0}
\getchunk{defun npEqPeek 0}
\getchunk{defun nplisp 0}
\getchunk{defun npPop1 0}
\getchunk{defun npPop2 0}
\getchunk{defun npPop3 0}
\getchunk{defun npPush 0}

\getchunk{defun objEnv 0}
\getchunk{defun objModeFn 0}
\getchunk{defun objValFn 0}
\getchunk{defun opTran 0}

\getchunk{defun pfAndLeft 0}
\getchunk{defun pfAndRight 0}
\getchunk{defun pfAppend 0}
\getchunk{defun pfApplicationArg 0}
\getchunk{defun pfApplicationOp 0}
\getchunk{defun pfAssignLhsItems 0}
\getchunk{defun pf0AssignLhsItems 0}
\getchunk{defun pfAssignRhs 0}
\getchunk{defun pfBreakFrom 0}
\getchunk{defun pfCoercetoExpr 0}
\getchunk{defun pfCoercetoType 0}
\getchunk{defun pfCollectBody 0}
\getchunk{defun pfCollectIterators 0}
\getchunk{defun pfDefinitionLhsItems 0}
\getchunk{defun pfDefinitionRhs 0}
\getchunk{defun pfDoBody 0}
\getchunk{defun pfExitCond 0}
\getchunk{defun pfExitExpr 0}
\getchunk{defun pfFirst 0}
\getchunk{defun pfFreeItems 0}
\getchunk{defun pfForinLhs 0}
\getchunk{defun pfForinWhole 0}
\getchunk{defun pfFromdomDomain 0}
\getchunk{defun pfFromdomWhat 0}
\getchunk{defun pfIfCond 0}
\getchunk{defun pfIfElse 0}
\getchunk{defun pfIfThen 0}
\getchunk{defun pfLambdaArgs 0}
\getchunk{defun pfLambdaBody 0}
\getchunk{defun pfLambdaRets 0}
\getchunk{defun pfLiteral? 0}
\getchunk{defun pfLocalItems 0}
\getchunk{defun pfLoopIterators 0}
\getchunk{defun pfMacroLhs 0}
\getchunk{defun pfMacroRhs 0}
\getchunk{defun pfMLambdaArgs 0}
\getchunk{defun pfMLambdaBody 0}
\getchunk{defun pfNotArg 0}
\getchunk{defun pfNovalueExpr 0}
\getchunk{defun pfOrLeft 0}
\getchunk{defun pfOrRight 0}
\getchunk{defun pfParts 0}
\getchunk{defun pfPile 0}
\getchunk{defun pfPretendExpr 0}
\getchunk{defun pfPretendType 0}
\getchunk{defun pfRestrictExpr 0}
\getchunk{defun pfRestrictType 0}
\getchunk{defun pfReturnExpr 0}
\getchunk{defun pfRuleLhsItems 0}
\getchunk{defun pfRuleRhs 0}
\getchunk{defun pfSecond 0}
\getchunk{defun pfSequenceArgs 0}
\getchunk{defun pfSuchthatCond 0}
\getchunk{defun pfTaggedExpr 0}
\getchunk{defun pfTaggedTag 0}
\getchunk{defun pfTree 0}
\getchunk{defun pfTypedId 0}
\getchunk{defun pfTypedType 0}
\getchunk{defun pfTupleParts 0}
\getchunk{defun pfWhereContext 0}
\getchunk{defun pfWhereExpr 0}
\getchunk{defun pfWhileCond 0}
\getchunk{defun placep 0}
\getchunk{defun pmDontQuote? 0}
\getchunk{defun pname 0}
\getchunk{defun poCharPosn 0}
\getchunk{defun poGetLineObject 0}
\getchunk{defun poNopos? 0}
\getchunk{defun poNoPosition 0}
\getchunk{defun poNoPosition? 0}
\getchunk{defun printAsTeX 0}
\getchunk{defun PsiAsymptoticOrder 0}
\getchunk{defun PsiEps 0}
\getchunk{defun PsiIntpart 0}

\getchunk{defun qenum 0}
\getchunk{defun qeset 0}
\getchunk{defun qsquotient 0}
\getchunk{defun qsremainder 0}
\getchunk{defun quotient2 0}

\getchunk{defun random 0}
\getchunk{defun rdigit? 0}
\getchunk{defun reclaim 0}
\getchunk{defun remainder2 0}
\getchunk{defun remLine 0}
\getchunk{defun removeOption 0}
\getchunk{defun rep 0}
\getchunk{defun resetStackLimits 0}
\getchunk{defun resultp 0}

\getchunk{defun sameUnionBranch 0}
\getchunk{defun satisfiesUserLevel 0}
\getchunk{defun scanCloser? 0}
\getchunk{defun sec 0}
\getchunk{defun sech 0}
\getchunk{defun setCurrentLine 0}
\getchunk{defun set-restart-hook 0}
\getchunk{defun showMsgPos? 0}
\getchunk{defun smallEnoughCount 0}
\getchunk{defun startsComment? 0}
\getchunk{defun storeblanks 0}
\getchunk{defun s-to-c 0}
\getchunk{defun StreamNull 0}
\getchunk{defun stringize 0}
\getchunk{defun stringPrefix? 0}
\getchunk{defun stripLisp 0}
\getchunk{defun stripSpaces 0}
\getchunk{defun substring 0}

\getchunk{defun theid 0}
\getchunk{defun thefname 0}
\getchunk{defun theorigin 0}
\getchunk{defun tokPart 0}
\getchunk{defun To 0}
\getchunk{defun Top? 0}
\getchunk{defun trademark 0}

\getchunk{defun /untrace-reduce 0}

\getchunk{defun vec2list 0}
\getchunk{defun vmread 0}

\getchunk{defun zeroOneTran 0}

;;; above level 0

\getchunk{defun abbQuery}
\getchunk{defun abbreviations}
\getchunk{defun abbreviationsSpad2Cmd}
\getchunk{defun absolutelyCanCoerceByCheating}
\getchunk{defun addBinding}
\getchunk{defun addBindingInteractive}
\getchunk{defun addInputLibrary}
\getchunk{defun addNewInterpreterFrame}
\getchunk{defun addoperations}
\getchunk{defun addTraceItem}
\getchunk{defun Advance-Char}
\getchunk{defun algCoerceInteractive}
\getchunk{defun algEqual}
\getchunk{defun allConstructors}
\getchunk{defun allOperations}
\getchunk{defun alqlGetOrigin}
\getchunk{defun alqlGetParams}
\getchunk{defun alqlGetKindString}
\getchunk{defun alreadyOpened?}
\getchunk{defun apropos}
\getchunk{defun assertCond}
\getchunk{defun augmentHasArgs}
\getchunk{defun augmentTraceNames}

\getchunk{defun basicLookup}
\getchunk{defun basicLookupCheckDefaults}
\getchunk{defun bcComplexLimit}
\getchunk{defun bcComplexLimitGen}
\getchunk{defun bcCreateVariableString}
\getchunk{defun bcDefiniteIntegrate}
\getchunk{defun bcDefiniteIntegrateGen}
\getchunk{defun bcDifferentiate}
\getchunk{defun bcDifferentiateGen}
\getchunk{defun bcDraw}
\getchunk{defun bcDrawIt}
\getchunk{defun bcDrawIt2}
\getchunk{defun bcDraw2Dfun}
\getchunk{defun bcDraw2DfunGen}
\getchunk{defun bcDraw2Dpar}
\getchunk{defun bcDraw2DparGen}
\getchunk{defun bcDraw2DSolve}
\getchunk{defun bcDraw2DSolveGen}
\getchunk{defun bcDraw3Dfun}
\getchunk{defun bcDraw3DfunGen}
\getchunk{defun bcDraw3Dpar}
\getchunk{defun bcDraw3DparGen}
\getchunk{defun bcDraw3Dpar1}
\getchunk{defun bcDraw3Dpar1Gen}
\getchunk{defun bcError}
\getchunk{defun bcFindString}
\getchunk{defun bcFinish}
\getchunk{defun bcGen}
\getchunk{defun bcGenEquations}
\getchunk{defun bcGenExplicitMatrix}
\getchunk{defun bcHt}
\getchunk{defun bchtMakeButton}
\getchunk{defun bcIndefiniteIntegrate}
\getchunk{defun bcIndefiniteIntegrateGen}
\getchunk{defun bcInputEquations}
\getchunk{defun bcInputEquationsEnd}
\getchunk{defun bcInputExplicitMatrix}
\getchunk{defun bcInputMatrixByFormula}
\getchunk{defun bcInputMatrixByFormulaGen}
\getchunk{defun bcInputSolveInfo}
\getchunk{defun bcIssueHt}
\getchunk{defun bcLaurentSeries}
\getchunk{defun bcLaurentSeriesGen}
\getchunk{defun bcLimit}
\getchunk{defun bcLinearExtractMatrix}
\getchunk{defun bcLinearMatrixGen}
\getchunk{defun bcLinearSolve}
\getchunk{defun bcLinearSolveEqns}
\getchunk{defun bcLinearSolveEqns1}
\getchunk{defun bcLinearSolveEqnsGen}
\getchunk{defun bcLinearSolveMatrix}
\getchunk{defun bcLinearSolveMatrix1}
\getchunk{defun bcLinearSolveMatrixHomo}
\getchunk{defun bcLinearSolveMatrixInhomo}
\getchunk{defun bcLinearSolveMatrixInhomoGen}
\getchunk{defun bcMatrix}
\getchunk{defun bcMatrixGen}
\getchunk{defun bcMakeEquations}
\getchunk{defun bcMakeLinearEquations}
\getchunk{defun bcMakeUnknowns}
\getchunk{defun bcMkFunction}
\getchunk{defun bcNotReady}
\getchunk{defun bcOptional}
\getchunk{defun bcProduct}
\getchunk{defun bcProductGen}
\getchunk{defun bcPuiseuxSeries}
\getchunk{defun bcPuiseuxSeriesGen}
\getchunk{defun bcReadMatrix}
\getchunk{defun bcRealLimit}
\getchunk{defun bcRealLimitGen}
\getchunk{defun bcRealLimitGen1}
\getchunk{defun bcSadFaces}
\getchunk{defun bcSeries}
\getchunk{defun bcSeriesByFormula}
\getchunk{defun bcSeriesByFormulaGen}
\getchunk{defun bcSeriesExpansion}
\getchunk{defun bcSeriesExpansionGen}
\getchunk{defun bcSeriesGen}
\getchunk{defun bcSolve}
\getchunk{defun bcSolveEquations}
\getchunk{defun bcSolveEquationsNumerically}
\getchunk{defun bcSolveNumerically1}
\getchunk{defun bcSolveSingle}
\getchunk{defun bcString2HyString}
\getchunk{defun bcString2HyString2}
\getchunk{defun bcString2WordList}
\getchunk{defun bcSystemSolveEqns1}
\getchunk{defun bcSum}
\getchunk{defun bcSumGen}
\getchunk{defun bcSystemSolve}
\getchunk{defun bcTaylorSeries}
\getchunk{defun bcTaylorSeriesGen}
\getchunk{defun bcUnixTable}
\getchunk{defun bcVectorGen}
\getchunk{defun bcvspace}
\getchunk{defun bcwords2liststring}
\getchunk{defun beforeAfter}
\getchunk{defun BesselI}
\getchunk{defun besselIback}
\getchunk{defun besselIcheb}
\getchunk{defun BesselJ}
\getchunk{defun BesselJAsympt}
\getchunk{defun BesselJAsymptOrder}
\getchunk{defun BesselJRecur}
\getchunk{defun bpitrace}
\getchunk{defun bracketString}
\getchunk{defun break}
\getchunk{defun breaklet}
\getchunk{defun brightprint}
\getchunk{defun brightprint-0}
\getchunk{defun browse}
\getchunk{defun browseopen}
\getchunk{defun buildHtMacroTable}
\getchunk{defun buttonNames}

\getchunk{defun canFuncall?}
\getchunk{defun categoryopen}
\getchunk{defun catchCoerceFailure}
\getchunk{defun cbesseli}
\getchunk{defun cbesselj}
\getchunk{defun cgamma}
\getchunk{defun cgammaImpl}
\getchunk{defun changeHistListLen}
\getchunk{defun changeToNamedInterpreterFrame}
\getchunk{defun charDigitVal}
\getchunk{defun chebf01}
\getchunk{defun checkCondition}
\getchunk{defun checkFilter}
\getchunk{defun chkAllNonNegativeInteger}
\getchunk{defun chkDirectory}
\getchunk{defun chkNameList}
\getchunk{defun chkNonNegativeInteger}
\getchunk{defun chkOutputFileName}
\getchunk{defun chkPosInteger}
\getchunk{defun chkRange}
\getchunk{defun chyper0f1}
\getchunk{defun cleanline}
\getchunk{defun clear}
\getchunk{defun clearCmdAll}
\getchunk{defun clearCmdCompletely}
\getchunk{defun clearCmdExcept}
\getchunk{defun clearCmdParts}
\getchunk{defun clearCmdSortedCaches}
\getchunk{defun clearFrame}
\getchunk{defun clearParserMacro}
\getchunk{defun clearSpad2Cmd}
\getchunk{defun clngamma}
\getchunk{defun clngammacase1}
\getchunk{defun clngammacase2}
\getchunk{defun clngammacase3}
\getchunk{defun clngammacase23}
\getchunk{defun clngammaImpl}
\getchunk{defun close}
\getchunk{defun closeInterpreterFrame}
\getchunk{defun cmpnote}
\getchunk{defun coerceBranch2Union}
\getchunk{defun coerceByFunction}
\getchunk{defun coerceByTable}
\getchunk{defun coerceCommuteTest}
\getchunk{defun coerceConvertMmSelection}
\getchunk{defun coerceImmediateSubDomain}
\getchunk{defun coerceInt}
\getchunk{defun coerceInt0}
\getchunk{defun coerceInt1}
\getchunk{defun coerceIntX}
\getchunk{defun coerceIntAlgebraicConstant}
\getchunk{defun coerceIntByMap}
\getchunk{defun coerceIntByMapInner}
\getchunk{defun coerceIntCommute}
\getchunk{defun coerceInteractive}
\getchunk{defun coerceIntFromUnion}
\getchunk{defun coerceIntPermute}
\getchunk{defun coerceIntSpecial}
\getchunk{defun coerceIntTableOrFunction}
\getchunk{defun coerceIntTest}
\getchunk{defun coerceIntTower}
\getchunk{defun coerceInt2Union}
\getchunk{defun coerceOrRetract}
\getchunk{defun coerceOrThrowFailure}
\getchunk{defun coerceRetract}
\getchunk{defun coerceSpadArgs2E}
\getchunk{defun coerceSpadFunValue2E}
\getchunk{defun coerceSubDomain}
\getchunk{defun coerceTraceArgs2E}
\getchunk{defun coerceTraceFunValue2E}
\getchunk{defun coerceUnion2Branch}
\getchunk{defun coercionFailure}
\getchunk{defun commandAmbiguityError}
\getchunk{defun commandError}
\getchunk{defun commandErrorIfAmbiguous}
\getchunk{defun commandErrorMessage}
\getchunk{defun commandsForUserLevel}
\getchunk{defun commandUserLevelError}
\getchunk{defun compareposns}
\getchunk{defun compareTypeLists}
\getchunk{defun compileBoot}
\getchunk{defun compiledLookup}
\getchunk{defun compiledLookupCheck}
\getchunk{defun computeDomainVariableAlist}
\getchunk{defun computeTTTranspositions}
\getchunk{defun condErrorMsg}
\getchunk{defun conLowerCaseConTran}
\getchunk{defun conOpPage}
\getchunk{defun conOpPage1}
\getchunk{defun conPage}
\getchunk{defun conPageChoose}
\getchunk{defun conPageConEntry}
\getchunk{defun conPageFastPath}
\getchunk{defun conSpecialString?}
\getchunk{defun constoken}
\getchunk{defun constructorSearch}
\getchunk{defun constructSubst}
\getchunk{defun containsVars}
\getchunk{defun containsVars1}
\getchunk{defun copyright}
\getchunk{defun countCache}
\getchunk{defun cpsi}
\getchunk{defun cPsiImpl}
\getchunk{defun cSearch}
\getchunk{defun c-to-r}

\getchunk{defun DaaseName}
\getchunk{defun dbAddChain}
\getchunk{defun dbAddChainDomain}
\getchunk{defun dbAddDocTable}
\getchunk{defun dbCompositeWithMap}
\getchunk{defun dbConsExposureMessage}
\getchunk{defun dbConsHeading}
\getchunk{defun dbConstructorDoc}
\getchunk{defun dbConstructorDoc,fn}
\getchunk{defun dbConstructorDoc,hn}
\getchunk{defun dbConstructorDoc,gn}
\getchunk{defun dbDocTable}
\getchunk{defun dbExtractUnderlyingDomain}
\getchunk{defun dbGetDocTable}
\getchunk{defun dbGetDocTable,gn}
\getchunk{defun dbGetDocTable,hn}
\getchunk{defun dbMkEvalable}
\getchunk{defun dbMkForm}
\getchunk{defun dbNonEmptyPattern}
\getchunk{defun dbSearchOrder}
\getchunk{defun dbSelectCon}
\getchunk{defun dbShowConditions}
\getchunk{defun dbShowCons}
\getchunk{defun dbShowCons1}
\getchunk{defun dbShowConsDoc}
\getchunk{defun dbShowConsDoc1}
\getchunk{defun dbShowConsKindsFilter}
\getchunk{defun dbShowConstructorLines}
\getchunk{defun dbSpecialDescription}
\getchunk{defun dbSpecialExpandIfNecessary}
\getchunk{defun dbSpecialExports}
\getchunk{defun dbSpecialOperations}
\getchunk{defun dbString2Words}
\getchunk{defun dbSubConform}
\getchunk{defun dbWordFrom}
\getchunk{defun decideHowMuch}
\getchunk{defun decomposeTypeIntoTower}
\getchunk{defun defaultTargetFE}
\getchunk{defun defiostream}
\getchunk{defun deldatabase}
\getchunk{defun deleteFile}
\getchunk{defun describe}
\getchunk{defun describeFortPersistence}
\getchunk{defun describeInputLibraryArgs}
\getchunk{defun describeOutputLibraryArgs}
\getchunk{defun describeSetFortDir}
\getchunk{defun describeSetFortTmpDir}
\getchunk{defun describeSetFunctionsCache}
\getchunk{defun describeSetLinkerArgs}
\getchunk{defun describeSetNagHost}
\getchunk{defun describeSetOutputAlgebra}
\getchunk{defun describeSetOutputFormula}
\getchunk{defun describeSetOutputFortran}
\getchunk{defun describeSetOutputHtml}
\getchunk{defun describeSetOutputMathml}
\getchunk{defun describeSetOutputOpenMath}
\getchunk{defun describeSetOutputTex}
\getchunk{defun describeSetStreamsCalculate}
\getchunk{defun describeSpad2Cmd}
\getchunk{defun dewritify}
\getchunk{defun dewritify,dewritifyInner}
\getchunk{defun diffAlist}
\getchunk{defun digit?}
\getchunk{defun digitp}
\getchunk{defun disableHist}
\getchunk{defun display}
\getchunk{defun displayCondition}
\getchunk{defun displayExposedConstructors}
\getchunk{defun displayExposedGroups}
\getchunk{defun displayHiddenConstructors}
\getchunk{defun displayMacro}
\getchunk{defun displayMacros}
\getchunk{defun displayMode}
\getchunk{defun displayModemap}
\getchunk{defun displayOperations}
\getchunk{defun displayOperationsFromLisplib}
\getchunk{defun displayParserMacro}
\getchunk{defun displayProperties}
\getchunk{defun displayProperties,sayFunctionDeps}
\getchunk{defun displaySetOptionInformation}
\getchunk{defun displaySetVariableSettings}
\getchunk{defun displaySpad2Cmd}
\getchunk{defun displayType}
\getchunk{defun displayValue}
\getchunk{defun displayWorkspaceNames}
\getchunk{defun doDoitButton}
\getchunk{defun domainDescendantsOf}
\getchunk{defun domainToGenvar}
\getchunk{defun domArg}
\getchunk{defun domArg2}
\getchunk{defun doSystemCommand}
\getchunk{defun downcase}
\getchunk{defun downlink}
\getchunk{defun dqConcat}
\getchunk{defun dropInputLibrary}
\getchunk{defun dSearch}
\getchunk{defun dumbTokenize}

\getchunk{defun edit}
\getchunk{defun editFile}
\getchunk{defun editSpad2Cmd}
\getchunk{defun Else?}
\getchunk{defun Elseif?}
\getchunk{defun embededFunction}
\getchunk{defun enPile}
\getchunk{defun eofp}
\getchunk{defun eqpileTree}
\getchunk{defun erMsgCompare}
\getchunk{defun erMsgSep}
\getchunk{defun erMsgSort}
\getchunk{defun evalCategory}
\getchunk{defun evalDomain}
\getchunk{defun evaluateSignature}
\getchunk{defun evaluateType}
\getchunk{defun evaluateType1}
\getchunk{defun executeInterpreterCommand}
\getchunk{defun ExecuteInterpSystemCommand}
\getchunk{defun executeQuietCommand}
\getchunk{defun explainLinear}

\getchunk{defun fetchOutput}
\getchunk{defun fillerSpaces}
\getchunk{defun filterAndFormatConstructors}
\getchunk{defun filterListOfStrings}
\getchunk{defun filterListOfStringsWithFn}
\getchunk{defun finalExactRequest}
\getchunk{defun findnexttest}
\getchunk{defun firstTokPosn}
\getchunk{defun fixObjectForPrinting}
\getchunk{defun flatBvList}
\getchunk{defun float2Sex}
\getchunk{defun fnameDirectory}
\getchunk{defun fnameMake}
\getchunk{defun fnameNew}
\getchunk{defun fnameWritable?}
\getchunk{defun frame}
\getchunk{defun frameEnvironment}
\getchunk{defun frameSpad2Cmd}
\getchunk{defun funfind,LAM}

\getchunk{defun gammaRatapprox}
\getchunk{defun gammaRatkernel}
\getchunk{defun gammaStirling}
\getchunk{defun gatherGlossLines}
\getchunk{defun genDomainTraceName}
\getchunk{defun gensymInt}
\getchunk{defun getAliasIfTracedMapParameter}
\getchunk{defun getAndEvalConstructorArgument}
\getchunk{defun getAndSay}
\getchunk{defun getBpiNameIfTracedMap}
\getchunk{defun getBrowseDatabase}
\getchunk{defun getConstantFromDomain}
\getchunk{defun getConstructorDocumentation}
\getchunk{defun getdatabase}
\getchunk{defun getDependentsOfConstructor}
\getchunk{defun getDirectoryList}
\getchunk{defun getFirstWord}
\getchunk{defun getHtMacroItem}
\getchunk{defun getMapSig}
\getchunk{defun getMapSubNames}
\getchunk{defun getMsgCatAttr}
\getchunk{defun getMsgFTTag?}
\getchunk{defun getMsgInfoFromKey}
\getchunk{defun getMsgPos}
\getchunk{defun getMsgPos2}
\getchunk{defun getMsgToWhere}
\getchunk{defun getOperationAlistFromLisplib}
\getchunk{defun getOplistForConstructorForm}
\getchunk{defun getOplistWithUniqueSignatures}
\getchunk{defun getOption}
\getchunk{defun getPosStL}
\getchunk{defun getPreviousMapSubNames}
\getchunk{defun getProplist}
\getchunk{defun getRefvU8}
\getchunk{defun getRefvU16}
\getchunk{defun getRefvU32}
\getchunk{defun getStFromMsg}
\getchunk{defun getSubDomainPredicate}
\getchunk{defun getSystemCommandLine}
\getchunk{defun getTraceOption}
\getchunk{defun getTraceOption,hn}
\getchunk{defun getTraceOptions}
\getchunk{defun getUsersOfConstructor}
\getchunk{defun getWorkspaceNames}

\getchunk{defun handleNoParseCommands}
\getchunk{defun handleParsedSystemCommands}
\getchunk{defun handleTokensizeSystemCommands}
\getchunk{defun hasAtt}
\getchunk{defun hasAttSig}
\getchunk{defun hasCatExpression}
\getchunk{defun hasCate}
\getchunk{defun hasCateSpecial}
\getchunk{defun hasCateSpecialNew}
\getchunk{defun hasCate1}
\getchunk{defun hasCaty}
\getchunk{defun hasCaty1}
\getchunk{defun hashable}
\getchunk{defun hasOption}
\getchunk{defun hasPair}
\getchunk{defun hasSharpVar}
\getchunk{defun hasSig}
\getchunk{defun hasSigAnd}
\getchunk{defun hasSigOr}
\getchunk{defun help}
\getchunk{defun helpSpad2Cmd}
\getchunk{defun histFileErase}
\getchunk{defun histFileName}
\getchunk{defun histInputFileName}
\getchunk{defun history}
\getchunk{defun historySpad2Cmd}
\getchunk{defun hkeys}
\getchunk{defun hput}
\getchunk{defun htAddHeading}
\getchunk{defun htAllOrNum}
\getchunk{defun htBcLinks}
\getchunk{defun htBcLispLinks}
\getchunk{defun htBcRadioButtons}
\getchunk{defun htCacheAddChoice}
\getchunk{defun htCacheOne}
\getchunk{defun htCacheSet}
\getchunk{defun htCheckList}
\getchunk{defun htCheck}
\getchunk{defun htDoneButton}
\getchunk{defun htDoNothing}
\getchunk{defun htEscapeString}
\getchunk{defun htFunctionSetLiteral}
\getchunk{defun htGlossPage}
\getchunk{defun htGlossSearch}
\getchunk{defun htGloss}
\getchunk{defun htGreekSearch}
\getchunk{defun htInitPage}
\getchunk{defun htInitPageNoScroll}
\getchunk{defun htInputStrings}
\getchunk{defun htKill}
\getchunk{defun htLispLinks}
\getchunk{defun htLispMemoLinks}
\getchunk{defun htMakeButton}
\getchunk{defun htMakeDoitButton}
\getchunk{defun htMakeDoneButton}
\getchunk{defun htMakeErrorPage}
\getchunk{defun htMakeInputList}
\getchunk{defun htMakeLabel}
\getchunk{defun htMakePage}
\getchunk{defun htMakePage1}
\getchunk{defun htMakePathKey,fn}
\getchunk{defun htMakePathKey}
\getchunk{defun htMakeTemplates,substLabel}
\getchunk{defun htMakeTemplates}
\getchunk{defun htMarkTree}
\getchunk{defun htMkName}
\getchunk{defun htpAddInputAreaProp}
\getchunk{defun htpButtonValue}
\getchunk{defun htpDestroyPage}
\getchunk{defun htpDomainConditions}
\getchunk{defun htpDomainPvarSubstList}
\getchunk{defun htpDomainVariableAlist}
\getchunk{defun htpInputAreaAlist}
\getchunk{defun htpLabelDefault}
\getchunk{defun htpLabelErrorMsg}
\getchunk{defun htpLabelFilteredInputString}
\getchunk{defun htpLabelFilter}
\getchunk{defun htpLabelInputString}
\getchunk{defun htpLabelSpadType}
\getchunk{defun htpLabelSpadValue}
\getchunk{defun htpLabelType}
\getchunk{defun htpName}
\getchunk{defun htpPageDescription}
\getchunk{defun htpRadioButtonAlist}
\getchunk{defun htpProperty}
\getchunk{defun htpPropertyList}
\getchunk{defun htProcessBcButtons}
\getchunk{defun htProcessBcStrings}
\getchunk{defun htProcessDoitButton}
\getchunk{defun htProcessDomainConditions}
\getchunk{defun htProcessDoneButton}
\getchunk{defun htProcessToggleButtons}
\getchunk{defun htpSetDomainConditions}
\getchunk{defun htpSetDomainPvarSubstList}
\getchunk{defun htpSetDomainVariableAlist}
\getchunk{defun htpSetInputAreaAlist}
\getchunk{defun htpSetLabelErrorMsg}
\getchunk{defun htpSetLabelInputString}
\getchunk{defun htpSetLabelSpadValue}
\getchunk{defun htpSetName}
\getchunk{defun htpSetPageDescription}
\getchunk{defun htpSetProperty}
\getchunk{defun htpSetRadioButtonAlist}
\getchunk{defun htQuote}
\getchunk{defun htRadioButtons}
\getchunk{defun htSay}
\getchunk{defun htSayBind}
\getchunk{defun htSetCache}
\getchunk{defun htSetExpose}
\getchunk{defun htSetFunCommandContinue}
\getchunk{defun htSetFunCommand}
\getchunk{defun htSetHistory}
\getchunk{defun htSetInputLibrary}
\getchunk{defun htSetInteger}
\getchunk{defun htSetLinkerArgs}
\getchunk{defun htSetLiterals}
\getchunk{defun htSetLiteral}
\getchunk{defun htSetNotAvailable}
\getchunk{defun htSetOutputCharacters}
\getchunk{defun htSetOutputLibrary}
\getchunk{defun htSetSystemVariableKind}
\getchunk{defun htSetSystemVariable}
\getchunk{defun htSetVars}
\getchunk{defun htSetvarDoneButton}
\getchunk{defun htShowCount}
\getchunk{defun htShowFunctionPageContinued}
\getchunk{defun htShowFunctionPage}
\getchunk{defun htShowIntegerPage}
\getchunk{defun htShowLiteralsPage}
\getchunk{defun htShowPage}
\getchunk{defun htShowPageNoScroll}
\getchunk{defun htShowSetPage}
\getchunk{defun htShowSetTreeValue}
\getchunk{defun htShowSetTree}
\getchunk{defun htStringPad}
\getchunk{defun htsv}
\getchunk{defun htSystemVariables,displayOptions}
\getchunk{defun htSystemVariables,fn}
\getchunk{defun htSystemVariables,functionTail}
\getchunk{defun htSystemVariables,gn}
\getchunk{defun htSystemVariables}
\getchunk{defun htTextSearch}
\getchunk{defun htTutorialSearch}

\getchunk{defun If?}
\getchunk{defun ifCond}
\getchunk{defun iht}
\getchunk{defun importFromFrame}
\getchunk{defun incAppend}
\getchunk{defun incAppend1}
\getchunk{defun incBiteOff}
\getchunk{defun incClassify}
\getchunk{defun incCommandTail}
\getchunk{defun incConsoleInput}
\getchunk{defun incFileInput}
\getchunk{defun incFileName}
\getchunk{defun incIgen}
\getchunk{defun incIgen1}
\getchunk{defun inclFname}
\getchunk{defun incLine}
\getchunk{defun incLine1}
\getchunk{defun inclmsgCannotRead}
\getchunk{defun inclmsgFileCycle}
\getchunk{defun inclmsgPrematureFin}
\getchunk{defun incLude}
\getchunk{defun incLude1}
\getchunk{defun inclmsgConActive}
\getchunk{defun inclmsgConStill}
\getchunk{defun inclmsgIfSyntax}
\getchunk{defun inclmsgNoSuchFile}
\getchunk{defun inclmsgSay}
\getchunk{defun incNConsoles}
\getchunk{defun incRenumber}
\getchunk{defun incRenumberItem}
\getchunk{defun incRenumberLine}
\getchunk{defun incRgen}
\getchunk{defun incRgen1}
\getchunk{defun incStream}
\getchunk{defun incString}
\getchunk{defun incZip}
\getchunk{defun incZip1}
\getchunk{defun init-boot/spad-reader}
\getchunk{defun initHist}
\getchunk{defun initHistList}
\getchunk{defun initial-getdatabase}
\getchunk{defun initializeInterpreterFrameRing}
\getchunk{defun initializeSetVariables}
\getchunk{defun initImPr}
\getchunk{defun initroot}
\getchunk{defun initToWhere}
\getchunk{defun insertAlist}
\getchunk{defun insertpile}
\getchunk{defun InterpExecuteSpadSystemCommand}
\getchunk{defun interpFunctionDepAlists}
\getchunk{defun interpopen}
\getchunk{defun interpret}
\getchunk{defun interpret1}
\getchunk{defun interpret2}
\getchunk{defun interpretTopLevel}
\getchunk{defun intInterpretPform}
\getchunk{defun intloop}
\getchunk{defun intloopEchoParse}
\getchunk{defun intloopInclude}
\getchunk{defun intloopInclude0}
\getchunk{defun intnplisp}
\getchunk{defun intloopProcess}
\getchunk{defun intloopProcessString}
\getchunk{defun intloopReadConsole}
\getchunk{defun intloopSpadProcess}
\getchunk{defun intloopSpadProcess,interp}
\getchunk{defun intProcessSynonyms}
\getchunk{defun ioclear}
\getchunk{defun iostat}
\getchunk{defun isDomainOrPackage}
\getchunk{defun isDomainValuedVariable}
\getchunk{defun isEqualOrSubDomain}
\getchunk{defun isExposedConstructor}
\getchunk{defun isGenvar}
\getchunk{defun isInterpOnlyMap}
\getchunk{defun isListOfIdentifiers}
\getchunk{defun isListOfIdentifiersOrStrings}
\getchunk{defun isPartialMode}
\getchunk{defun isPatternVar}
\getchunk{defun isSharpVar}
\getchunk{defun isSharpVarWithNum}
\getchunk{defun isSubForRedundantMapName}
\getchunk{defun isSystemDirectory}
\getchunk{defun isTaggedUnion}
\getchunk{defun isUncompiledMap}

\getchunk{defun justifyMyType}

\getchunk{defun kArgPage}
\getchunk{defun kArgumentCheck}
\getchunk{defun kcaPage}
\getchunk{defun kcaPage1}
\getchunk{defun kccPage}
\getchunk{defun kcdePage}
\getchunk{defun kcdPage}
\getchunk{defun kcdoPage}
\getchunk{defun kCheckArgumentNumbers}
\getchunk{defun kcnPage}
\getchunk{defun kcPage}
\getchunk{defun kcpPage}
\getchunk{defun kDomainName}
\getchunk{defun kdPageInfo}
\getchunk{defun KeepPart?}
\getchunk{defun kePage}
\getchunk{defun kePageDisplay}
\getchunk{defun kePageOpAlist}
\getchunk{defun kiPage}
\getchunk{defun kisValidType}
\getchunk{defun koaPageFilterByName}
\getchunk{defun koPage}
\getchunk{defun koPageAux}
\getchunk{defun koPageAux1}
\getchunk{defun koPageFromKKPage}
\getchunk{defun koPageInputAreaUnchanged?}
\getchunk{defun ksPage}
\getchunk{defun kcuPage}
\getchunk{defun kPage}
\getchunk{defun kSearch}
\getchunk{defun kTestPred}

\getchunk{defun lassocSub}
\getchunk{defun lastTokPosn}
\getchunk{defun leaveScratchpad}
\getchunk{defun lefts}
\getchunk{defun letPrint}
\getchunk{defun letPrint2}
\getchunk{defun letPrint3}
\getchunk{defun lfkey}
\getchunk{defun libConstructorSig}
\getchunk{defun library}
\getchunk{defun license}
\getchunk{defun linearFinalRequest}
\getchunk{defun lineoftoks}
\getchunk{defun linkGen}
\getchunk{defun listConstructorAbbreviations}
\getchunk{defun listDecideHowMuch}
\getchunk{defun listOfStrings2String}
\getchunk{defun listOutputter}
\getchunk{defun lncgamma}
\getchunk{defun lnFileName}
\getchunk{defun load}
\getchunk{defun loadFunctor}
\getchunk{defun loadLib}
\getchunk{defun loadLibNoUpdate}
\getchunk{defun localdatabase}
\getchunk{defun localnrlib}
\getchunk{defun lookupInDomainVector}
\getchunk{defun loopIters2Sex}
\getchunk{defun lotsof}
\getchunk{defun lnrgamma}
\getchunk{defun lnrgammaRatapprox}
\getchunk{defun ltrace}

\getchunk{defun macApplication}
\getchunk{defun macExpand}
\getchunk{defun macId}
\getchunk{defun macLambda}
\getchunk{defun macLambda,mac}
\getchunk{defun macLambdaParameterHandling}
\getchunk{defun macMacro}
\getchunk{defun macSubstituteId}
\getchunk{defun macSubstituteOuter}
\getchunk{defun macroExpanded}
\getchunk{defun macWhere}
\getchunk{defun macWhere,mac}
\getchunk{defun mac0ExpandBody}
\getchunk{defun mac0Get}
\getchunk{defun mac0GetName}
\getchunk{defun mac0InfiniteExpansion}
\getchunk{defun mac0MLambdaApply}
\getchunk{defun mac0SubstituteOuter}
\getchunk{defun make-appendstream}
\getchunk{defun make-databases}
\getchunk{defun makeFullNamestring}
\getchunk{defun makeHistFileName}
\getchunk{defun makeInputFilename}
\getchunk{defun make-instream}
\getchunk{defun makeLeaderMsg}
\getchunk{defun makeMsgFromLine}
\getchunk{defun makeOrdinal}
\getchunk{defun make-outstream}
\getchunk{defun makePathname}
\getchunk{defun makeSpadCommand}
\getchunk{defun makeStream}
\getchunk{defun mapLetPrint}
\getchunk{defun mapStringize}
\getchunk{defun mergePathnames}
\getchunk{defun messageprint}
\getchunk{defun messageprint-1}
\getchunk{defun messageprint-2}
\getchunk{defun mkConform}
\getchunk{defun mkCurryFun}
\getchunk{defun mkDomPvar}
\getchunk{defun mkDomTypeForm}
\getchunk{defun mkEvalable}
\getchunk{defun mkEvalableMapping}
\getchunk{defun mkEvalableRecord}
\getchunk{defun mkEvalableUnion}
\getchunk{defun mkLineList}
\getchunk{defun mkprompt}
\getchunk{defun mkSetTitle}
\getchunk{defun mkUnixPattern}
\getchunk{defun monitorEvalAfter}
\getchunk{defun monitorEvalBefore}
\getchunk{defun monitorEvalTran}
\getchunk{defun monitorEvalTran1}
\getchunk{defun monitorGetValue}
\getchunk{defun monitorPrint}
\getchunk{defun monitorPrintArg}
\getchunk{defun monitorPrintArgs}
\getchunk{defun monitorPrintRest}
\getchunk{defun monitorPrintValue}
\getchunk{defun monitorX}
\getchunk{defun monitorEnter}
\getchunk{defun monitorExit}
\getchunk{defun monitorXX}
\getchunk{defun msgCreate}
\getchunk{defun msgImPr?}
\getchunk{defun msgNoRep?}
\getchunk{defun msgOutputter}
\getchunk{defun msgText}
\getchunk{defun myWritable?}

\getchunk{defun namestring}
\getchunk{defun ncAlist}
\getchunk{defun ncBug}
\getchunk{defun ncConversationPhase}
\getchunk{defun ncConversationPhase,wrapup}
\getchunk{defun ncEltQ}
\getchunk{defun ncHardError}
\getchunk{defun ncIntLoop}
\getchunk{defun ncloopCommand}
\getchunk{defun ncloopDQlines}
\getchunk{defun ncloopIncFileName}
\getchunk{defun ncloopInclude}
\getchunk{defun ncloopInclude0}
\getchunk{defun ncloopInclude1}
\getchunk{defun ncloopParse}
\getchunk{defun ncParseFromString}
\getchunk{defun ncPutQ}
\getchunk{defun ncSoftError}
\getchunk{defun ncTag}
\getchunk{defun ncTopLevel}
\getchunk{defun newHelpSpad2Cmd}
\getchunk{defun next}
\getchunk{defun next1}
\getchunk{defun nextInterpreterFrame}
\getchunk{defun nextline}
\getchunk{defun next-lines-show}
\getchunk{defun npAdd}
\getchunk{defun npADD}
\getchunk{defun npAmpersand}
\getchunk{defun npAmpersandFrom}
\getchunk{defun npAndOr}
\getchunk{defun npAngleBared}
\getchunk{defun npApplication}
\getchunk{defun npApplication2}
\getchunk{defun npArith}
\getchunk{defun npAssign}
\getchunk{defun npAssignment}
\getchunk{defun npAssignVariable}
\getchunk{defun npAtom1}
\getchunk{defun npAtom2}
\getchunk{defun npBacksetElse}
\getchunk{defun npBackTrack}
\getchunk{defun npBDefinition}
\getchunk{defun npBPileDefinition}
\getchunk{defun npBraced}
\getchunk{defun npBracked}
\getchunk{defun npBracketed}
\getchunk{defun npBreak}
\getchunk{defun npBy}
\getchunk{defun npCategory}
\getchunk{defun npCategoryL}
\getchunk{defun npCoerceTo}
\getchunk{defun npColon}
\getchunk{defun npColonQuery}
\getchunk{defun npComma}
\getchunk{defun npCommaBackSet}
\getchunk{defun npCompMissing}
\getchunk{defun npConditional}
\getchunk{defun npConditionalStatement}
\getchunk{defun npConstTok}
\getchunk{defun npDDInfKey}
\getchunk{defun npDecl}
\getchunk{defun npDef}
\getchunk{defun npDefaultDecl}
\getchunk{defun npDefaultItem}
\getchunk{defun npDefaultItemlist}
\getchunk{defun npDefaultValue}
\getchunk{defun npDefinition}
\getchunk{defun npDefinitionItem}
\getchunk{defun npDefinitionlist}
\getchunk{defun npDefinitionOrStatement}
\getchunk{defun npDefn}
\getchunk{defun npDefTail}
\getchunk{defun npDiscrim}
\getchunk{defun npDisjand}
\getchunk{defun npDollar}
\getchunk{defun npDotted}
\getchunk{defun npElse}
\getchunk{defun npEncAp}
\getchunk{defun npEncl}
\getchunk{defun npEnclosed}
\getchunk{defun npEqKey}
\getchunk{defun npExit}
\getchunk{defun npExpress}
\getchunk{defun npExpress1}
\getchunk{defun npExport}
\getchunk{defun npFirstTok}
\getchunk{defun npFix}
\getchunk{defun npForIn}
\getchunk{defun npFree}
\getchunk{defun npFromdom}
\getchunk{defun npFromdom1}
\getchunk{defun npGives}
\getchunk{defun npId}
\getchunk{defun npImport}
\getchunk{defun npInfGeneric}
\getchunk{defun npInfixOp}
\getchunk{defun npInfixOperator}
\getchunk{defun npInfKey}
\getchunk{defun npInline}
\getchunk{defun npInterval}
\getchunk{defun npItem}
\getchunk{defun npItem1}
\getchunk{defun npIterate}
\getchunk{defun npIterator}
\getchunk{defun npIterators}
\getchunk{defun npLambda}
\getchunk{defun npLeftAssoc}
\getchunk{defun npLet}
\getchunk{defun npLetQualified}
\getchunk{defun npList}
\getchunk{defun npListAndRecover}
\getchunk{defun npListing}
\getchunk{defun npListofFun}
\getchunk{defun npLocal}
\getchunk{defun npLocalDecl}
\getchunk{defun npLocalItem}
\getchunk{defun npLocalItemlist}
\getchunk{defun npLogical}
\getchunk{defun npLoop}
\getchunk{defun npMacro}
\getchunk{defun npMatch}
\getchunk{defun npMdef}
\getchunk{defun npMDEF}
\getchunk{defun npMDEFinition}
\getchunk{defun npMissing}
\getchunk{defun npMissingMate}
\getchunk{defun npMoveTo}
\getchunk{defun npName}
\getchunk{defun npNext}
\getchunk{defun npNull}
\getchunk{defun npParened}
\getchunk{defun npParenthesize}
\getchunk{defun npParenthesized}
\getchunk{defun npParse}
\getchunk{defun npPDefinition}
\getchunk{defun npPileBracketed}
\getchunk{defun npPileDefinitionlist}
\getchunk{defun npPileExit}
\getchunk{defun npPower}
\getchunk{defun npPP}
\getchunk{defun npPPf}
\getchunk{defun npPPff}
\getchunk{defun npPPg}
\getchunk{defun npPrefixColon}
\getchunk{defun npPretend}
\getchunk{defun npPrimary}
\getchunk{defun npPrimary1}
\getchunk{defun npPrimary2}
\getchunk{defun npProcessSynonym}
\getchunk{defun npProduct}
\getchunk{defun npPushId}
\getchunk{defun npRelation}
\getchunk{defun npRemainder}
\getchunk{defun npQualDef}
\getchunk{defun npQualified}
\getchunk{defun npQualifiedDefinition}
\getchunk{defun npQualType}
\getchunk{defun npQualTypelist}
\getchunk{defun npQuiver}
\getchunk{defun npRecoverTrap}
\getchunk{defun npRestore}
\getchunk{defun npRestrict}
\getchunk{defun npReturn}
\getchunk{defun npRightAssoc}
\getchunk{defun npRule}
\getchunk{defun npSCategory}
\getchunk{defun npSDefaultItem}
\getchunk{defun npSegment}
\getchunk{defun npSelector}
\getchunk{defun npSemiBackSet}
\getchunk{defun npSemiListing}
\getchunk{defun npSigDecl}
\getchunk{defun npSigItem}
\getchunk{defun npSigItemlist}
\getchunk{defun npSignature}
\getchunk{defun npSignatureDefinee}
\getchunk{defun npSingleRule}
\getchunk{defun npSLocalItem}
\getchunk{defun npSQualTypelist}
\getchunk{defun npStatement}
\getchunk{defun npSuch}
\getchunk{defun npSuchThat}
\getchunk{defun npSum}
\getchunk{defun npsynonym}
\getchunk{defun npSymbolVariable}
\getchunk{defun npSynthetic}
\getchunk{defun npsystem}
\getchunk{defun npState}
\getchunk{defun npTagged}
\getchunk{defun npTerm}
\getchunk{defun npTrap}
\getchunk{defun npTrapForm}
\getchunk{defun npTuple}
\getchunk{defun npType}
\getchunk{defun npTypedForm}
\getchunk{defun npTypedForm1}
\getchunk{defun npTypeStyle}
\getchunk{defun npTypified}
\getchunk{defun npTyping}
\getchunk{defun npTypeVariable}
\getchunk{defun npTypeVariablelist}
\getchunk{defun npVariable}
\getchunk{defun npVariablelist}
\getchunk{defun npVariableName}
\getchunk{defun npVoid}
\getchunk{defun npWConditional}
\getchunk{defun npWhile}
\getchunk{defun npWith}
\getchunk{defun npZeroOrMore}
\getchunk{defun NRTevalDomain}

\getchunk{defun ofCategory}
\getchunk{defun oldCompLookup}
\getchunk{defun oldHistFileName}
\getchunk{defun oldParseString}
\getchunk{defun om-bindTCP}
\getchunk{defun om-closeConn}
\getchunk{defun om-closeDev}
\getchunk{defun om-connectTCP}
\getchunk{defun om-getApp}
\getchunk{defun om-getAtp}
\getchunk{defun om-getAttr}
\getchunk{defun om-getBind}
\getchunk{defun om-getBVar}
\getchunk{defun om-getConnInDev}
\getchunk{defun om-getConnOutDev}
\getchunk{defun om-getEndApp}
\getchunk{defun om-getEndAtp}
\getchunk{defun om-getEndAttr}
\getchunk{defun om-getEndBind}
\getchunk{defun om-getEndBVar}
\getchunk{defun om-getEndError}
\getchunk{defun om-getEndObject}
\getchunk{defun om-getError}
\getchunk{defun om-getFloat}
\getchunk{defun om-getInt}
\getchunk{defun om-getObject}
\getchunk{defun om-getString}
\getchunk{defun om-getSymbol}
\getchunk{defun om-getType}
\getchunk{defun om-getVar}
\getchunk{defun om-listCDs}
\getchunk{defun om-listSymbols}
\getchunk{defun om-makeConn}
\getchunk{defun om-openFileDev}
\getchunk{defun om-openStringDev}
\getchunk{defun om-putApp}
\getchunk{defun om-putAtp}
\getchunk{defun om-putAttr}
\getchunk{defun om-putBind}
\getchunk{defun om-putBVar}
\getchunk{defun om-putByteArray}
\getchunk{defun om-putEndApp}
\getchunk{defun om-putEndAtp}
\getchunk{defun om-putEndAttr}
\getchunk{defun om-putEndBind}
\getchunk{defun om-putEndBVar}
\getchunk{defun om-putEndError}
\getchunk{defun om-putEndObject}
\getchunk{defun om-putError}
\getchunk{defun om-putFloat}
\getchunk{defun om-putInt}
\getchunk{defun om-putObject}
\getchunk{defun om-putString}
\getchunk{defun om-putSymbol}
\getchunk{defun om-putVar}
\getchunk{defun om-Read}
\getchunk{defun om-setDevEncoding}
\getchunk{defun om-stringPtrToString}
\getchunk{defun om-stringToStringPtr}
\getchunk{defun om-supportsCD}
\getchunk{defun om-supportsSymbol}
\getchunk{defun openOutputLibrary}
\getchunk{defun openserver}
\getchunk{defun operationopen}
\getchunk{defun optionError}
\getchunk{defun /options}
\getchunk{defun optionUserLevelError}
\getchunk{defun orderBySlotNumber}
\getchunk{defun originsInOrder}

\getchunk{defun parseAndEval}
\getchunk{defun parseAndEval1}
\getchunk{defun parseAndInterpret}
\getchunk{defun parseFromString}
\getchunk{defun parseNoMacroFromString}
\getchunk{defun parseSystemCmd}
\getchunk{defun parseWord}
\getchunk{defun pathname}
\getchunk{defun pathnameDirectory}
\getchunk{defun pathnameName}
\getchunk{defun pathnameType}
\getchunk{defun pathnameTypeId}
\getchunk{defun patternVarsOf}
\getchunk{defun patternVarsOf1}
\getchunk{defun permuteToOrder}
\getchunk{defun pcounters}
\getchunk{defun pfAbSynOp}
\getchunk{defun pfAbSynOp?}
\getchunk{defun pfAdd}
\getchunk{defun pfAnd}
\getchunk{defun pfAnd?}
\getchunk{defun pfApplication}
\getchunk{defun pfApplication?}
\getchunk{defun pfApplication2Sex}
\getchunk{defun pfAssign}
\getchunk{defun pfAssign?}
\getchunk{defun pfAttribute}
\getchunk{defun pfBrace}
\getchunk{defun pfBraceBar}
\getchunk{defun pfBracket}
\getchunk{defun pfBracketBar}
\getchunk{defun pfBreak}
\getchunk{defun pfBreak?}
\getchunk{defun pfCharPosn}
\getchunk{defun pfCheckArg}
\getchunk{defun pfCheckMacroOut}
\getchunk{defun pfCheckId}
\getchunk{defun pfCheckItOut}
\getchunk{defun pfCoerceto}
\getchunk{defun pfCoerceto?}
\getchunk{defun pfCollect}
\getchunk{defun pfCollect?}
\getchunk{defun pfCollect1?}
\getchunk{defun pfCollectArgTran}
\getchunk{defun pfCollectVariable1}
\getchunk{defun pfCollect2Sex}
\getchunk{defun pfCopyWithPos}
\getchunk{defun pfDefinition}
\getchunk{defun pfDefinition?}
\getchunk{defun pfDefinition2Sex}
\getchunk{defun pfDo}
\getchunk{defun pfDo?}
\getchunk{defun pfDocument}
\getchunk{defun pfEnSequence}
\getchunk{defun pfExit}
\getchunk{defun pfExit?}
\getchunk{defun pfExport}
\getchunk{defun pfExpression}
\getchunk{defun pfFileName}
\getchunk{defun pfFix}
\getchunk{defun pfFlattenApp}
\getchunk{defun pfFree}
\getchunk{defun pfFree?}
\getchunk{defun pfForin}
\getchunk{defun pfForin?}
\getchunk{defun pfFromDom}
\getchunk{defun pfFromdom}
\getchunk{defun pfFromdom?}
\getchunk{defun pfGlobalLinePosn}
\getchunk{defun pfHide}
\getchunk{defun pfId}
\getchunk{defun pfId?}
\getchunk{defun pfIdPos}
\getchunk{defun pfIdSymbol}
\getchunk{defun pfIf}
\getchunk{defun pfIf?}
\getchunk{defun pfIfThenOnly}
\getchunk{defun pfImport}
\getchunk{defun pfInline}
\getchunk{defun pfInfApplication}
\getchunk{defun pfIterate}
\getchunk{defun pfIterate?}
\getchunk{defun pfLam}
\getchunk{defun pfLambda}
\getchunk{defun pfLambdaTran}
\getchunk{defun pfLambda?}
\getchunk{defun pfLambda2Sex}
\getchunk{defun pfLeaf}
\getchunk{defun pfLeaf?}
\getchunk{defun pfLeafPosition}
\getchunk{defun pfLeafToken}
\getchunk{defun pfLhsRule2Sex}
\getchunk{defun pfLinePosn}
\getchunk{defun pfListOf}
\getchunk{defun pfLiteralClass}
\getchunk{defun pfLiteralString}
\getchunk{defun pfLiteral2Sex}
\getchunk{defun pfLocal}
\getchunk{defun pfLocal?}
\getchunk{defun pfLoop}
\getchunk{defun pfLoop1}
\getchunk{defun pfLoop?}
\getchunk{defun pfLp}
\getchunk{defun pfMacro}
\getchunk{defun pfMacro?}
\getchunk{defun pfMapParts}
\getchunk{defun pfMLambda}
\getchunk{defun pfMLambda?}
\getchunk{defun pfname}
\getchunk{defun pfNoPosition}
\getchunk{defun pfNoPosition?}
\getchunk{defun pfNot?}
\getchunk{defun pfNothing}
\getchunk{defun pfNothing?}
\getchunk{defun pfNovalue}
\getchunk{defun pfNovalue?}
\getchunk{defun pfOp2Sex}
\getchunk{defun pfOr}
\getchunk{defun pfOr?}
\getchunk{defun pfParen}
\getchunk{defun pfPretend}
\getchunk{defun pfPretend?}
\getchunk{defun pfPushBody}
\getchunk{defun pfPushMacroBody}
\getchunk{defun pfQualType}
\getchunk{defun pfRestrict}
\getchunk{defun pfRestrict?}
\getchunk{defun pfRetractTo}
\getchunk{defun pfReturn}
\getchunk{defun pfReturn?}
\getchunk{defun pfReturnNoName}
\getchunk{defun pfReturnTyped}
\getchunk{defun pfRhsRule2Sex}
\getchunk{defun pfRule}
\getchunk{defun pfRule?}
\getchunk{defun pfRule2Sex}
\getchunk{defun pfSequence}
\getchunk{defun pfSequence?}
\getchunk{defun pfSequenceToList}
\getchunk{defun pfSequence2Sex}
\getchunk{defun pfSequence2Sex0}
\getchunk{defun pfSexpr}
\getchunk{defun pfSexpr,strip}
\getchunk{defun pfSourcePosition}
\getchunk{defun pfSourceStok}
\getchunk{defun pfSpread}
\getchunk{defun pfSuch}
\getchunk{defun pfSuchthat}
\getchunk{defun pfSuchthat?}
\getchunk{defun pfSuchThat2Sex}
\getchunk{defun pfSymb}
\getchunk{defun pfSymbol}
\getchunk{defun pfSymbol?}
\getchunk{defun pfSymbolSymbol}
\getchunk{defun pfTagged}
\getchunk{defun pfTagged?}
\getchunk{defun pfTaggedToTyped}
\getchunk{defun pfTaggedToTyped1}
\getchunk{defun pfTransformArg}
\getchunk{defun pfTuple}
\getchunk{defun pfTupleListOf}
\getchunk{defun pfTweakIf}
\getchunk{defun pfTyped}
\getchunk{defun pfTyped?}
\getchunk{defun pfTyping}
\getchunk{defun pfTuple?}
\getchunk{defun pfUnSequence}
\getchunk{defun pfWDec}
\getchunk{defun pfWDeclare}
\getchunk{defun pfWhere}
\getchunk{defun pfWhere?}
\getchunk{defun pfWhile}
\getchunk{defun pfWhile?}
\getchunk{defun pfWith}
\getchunk{defun pfWrong}
\getchunk{defun pfWrong?}
\getchunk{defun pf0ApplicationArgs}
\getchunk{defun pf0DefinitionLhsItems}
\getchunk{defun pf0FlattenSyntacticTuple}
\getchunk{defun pf0ForinLhs}
\getchunk{defun pf0FreeItems}
\getchunk{defun pf0LambdaArgs}
\getchunk{defun pf0LocalItems}
\getchunk{defun pf0LoopIterators}
\getchunk{defun pf0MLambdaArgs}
\getchunk{defun pf0SequenceArgs}
\getchunk{defun pf0TupleParts}
\getchunk{defun pf0WhereContext}
\getchunk{defun pf2Sex}
\getchunk{defun pf2Sex1}
\getchunk{defun phMacro}
\getchunk{defun phParse}
\getchunk{defun phInterpret}
\getchunk{defun phIntReportMsgs}
\getchunk{defun phiRatapprox}
\getchunk{defun pileCforest}
\getchunk{defun pileColumn}
\getchunk{defun pileCtree}
\getchunk{defun pileForest}
\getchunk{defun pileForest1}
\getchunk{defun pileForests}
\getchunk{defun pilePlusComment}
\getchunk{defun pilePlusComments}
\getchunk{defun pileTree}
\getchunk{defun PiMinusLogSinPi}
\getchunk{defun poFileName}
\getchunk{defun poGlobalLinePosn}
\getchunk{defun poLinePosn}
\getchunk{defun poPosImmediate?}
\getchunk{defun porigin}
\getchunk{defun posend}
\getchunk{defun posPointers}
\getchunk{defun ppos}
\getchunk{defun pquit}
\getchunk{defun pquitSpad2Cmd}
\getchunk{defun previousInterpreterFrame}
\getchunk{defun printLabelledList}
\getchunk{defun printStatisticsSummary}
\getchunk{defun printStorage}
\getchunk{defun printSynonyms}
\getchunk{defun printTypeAndTime}
\getchunk{defun probeName}
\getchunk{defun processChPosesForOneLine}
\getchunk{defun processInteractive}
\getchunk{defun processInteractive1}
\getchunk{defun processKeyedError}
\getchunk{defun processMsgList}
\getchunk{defun protectedEVAL}
\getchunk{defun processSynonymLine}
\getchunk{defun processSynonymLine,removeKeyFromLine}
\getchunk{defun processSynonyms}
\getchunk{defun prTraceNames}
\getchunk{defun prTraceNames,fn}
\getchunk{defun pSearch}
\getchunk{defun PsiAsymptotic}
\getchunk{defun PsiBack}
\getchunk{defun PsiXotic}
\getchunk{defun pspacers}
\getchunk{defun ptimers}
\getchunk{defun put}
\getchunk{defun putFTText}
\getchunk{defun punctuation?}
\getchunk{defun putDatabaseStuff}
\getchunk{defun putHist}
\getchunk{defun pvarCondList1}
\getchunk{defun pvarCondList}
\getchunk{defun pvarPredTran}
\getchunk{defun pvarsOfPattern}

\getchunk{defun queryClients}
\getchunk{defun queueUpErrors}
\getchunk{defun quit}
\getchunk{defun quitSpad2Cmd}
\getchunk{defun quoteString}

\getchunk{defun rassocSub}
\getchunk{defun rbesseli}
\getchunk{defun rbesselj}
\getchunk{defun rdefinstream}
\getchunk{defun rdefoutstream}
\getchunk{defun read}
\getchunk{defun /read}
\getchunk{defun readHiFi}
\getchunk{defun readline}
\getchunk{defun readSpadProfileIfThere}
\getchunk{defun readSpad2Cmd}
\getchunk{defun reassembleTowerIntoType}
\getchunk{defun recordAndPrint}
\getchunk{defun recordFrame}
\getchunk{defun recordNewValue}
\getchunk{defun recordNewValue0}
\getchunk{defun recordOldValue}
\getchunk{defun recordOldValue0}
\getchunk{defun reduceAlistForDomain}
\getchunk{defun redundant}
\getchunk{defun regress command}
\getchunk{defun regress}
\getchunk{defun remFile}
\getchunk{defun remover}
\getchunk{defun removeTracedMapSigs}
\getchunk{defun removeUndoLines}
\getchunk{defun renamePatternVariables1}
\getchunk{defun renamePatternVariables}
\getchunk{defun replaceFile}
\getchunk{defun replacePercentByDollar,fn}
\getchunk{defun replacePercentByDollar}
\getchunk{defun replaceSharps}
\getchunk{defun reportAO}
\getchunk{defun reportinstantiations}
\getchunk{defun reportOperations}
\getchunk{defun reportOpsFromLisplib}
\getchunk{defun reportOpsFromLisplib0}
\getchunk{defun reportOpsFromLisplib1}
\getchunk{defun reportOpsFromUnitDirectly}
\getchunk{defun reportOpsFromUnitDirectly0}
\getchunk{defun reportOpsFromUnitDirectly1}
\getchunk{defun reportSpadTrace}
\getchunk{defun reportUndo}
\getchunk{defun reportWhatOptions}
\getchunk{defun reroot}
\getchunk{defun resetCounters}
\getchunk{defun resethashtables}
\getchunk{defun resetInCoreHist}
\getchunk{defun resetSpacers}
\getchunk{defun resetTimers}
\getchunk{defun resetWorkspaceVariables}
\getchunk{defun restart}
\getchunk{defun restart0}
\getchunk{defun restoreHistory}
\getchunk{defun retract}
\getchunk{defun retractByFunction}
\getchunk{defun retractUnderDomain}
\getchunk{defun retract2Specialization}
\getchunk{defun rgamma}
\getchunk{defun rgammaImpl}
\getchunk{defun rlngamma}
\getchunk{defun rpsi}
\getchunk{defun rPsiImpl}
\getchunk{defun rPsiW}
\getchunk{defun rread}
\getchunk{defun ruleLhsTran}
\getchunk{defun rulePredicateTran}
\getchunk{defun runspad}
\getchunk{defun rwrite}

\getchunk{defun safeWritify}
\getchunk{defun sameMsg?}
\getchunk{defun satisfiesRegularExpressions}
\getchunk{defun saveHistory}
\getchunk{defun saveMapSig}
\getchunk{defun savesystem}
\getchunk{defun saveDependentsHashTable}
\getchunk{defun saveUsersHashTable}
\getchunk{defun sayAllCacheCounts}
\getchunk{defun sayBrightly1}
\getchunk{defun sayCacheCount}
\getchunk{defun sayExample}
\getchunk{defun sayKeyedMsg}
\getchunk{defun sayKeyedMsgLocal}
\getchunk{defun sayMSG}
\getchunk{defun sayMSG2File}
\getchunk{defun sayShowWarning}
\getchunk{defun scanCheckRadix}
\getchunk{defun scanComment}
\getchunk{defun scanDictCons}
\getchunk{defun scanError}
\getchunk{defun scanEsc}
\getchunk{defun scanEscape}
\getchunk{defun scanExponent}
\getchunk{defun scanIgnoreLine}
\getchunk{defun scanInsert}
\getchunk{defun scanKeyTr}
\getchunk{defun scanNegComment}
\getchunk{defun scanNumber}
\getchunk{defun ScanOrPairVec}
\getchunk{defun ScanOrPairVec,ScanOrInner}
\getchunk{defun scanPossFloat}
\getchunk{defun scanPunct}
\getchunk{defun scanPunCons}
\getchunk{defun scanS}
\getchunk{defun scanSpace}
\getchunk{defun scanString}
\getchunk{defun scanKeyTableCons}
\getchunk{defun scanToken}
\getchunk{defun scanTransform}
\getchunk{defun scanW}
\getchunk{defun scanWord}
\getchunk{defun search}
\getchunk{defun searchCurrentEnv}
\getchunk{defun searchTailEnv}
\getchunk{defun segmentKeyedMsg}
\getchunk{defun selectOption}
\getchunk{defun selectOptionLC}
\getchunk{defun separatePiles}
\getchunk{defun serverReadLine}
\getchunk{defun set}
\getchunk{defun set1}
\getchunk{defun setdatabase}
\getchunk{defun setExpose}
\getchunk{defun setExposeAdd}
\getchunk{defun setExposeAddConstr}
\getchunk{defun setExposeAddGroup}
\getchunk{defun setExposeDrop}
\getchunk{defun setExposeDropConstr}
\getchunk{defun setExposeDropGroup}
\getchunk{defun setFortDir}
\getchunk{defun setFortPers}
\getchunk{defun setFortTmpDir}
\getchunk{defun setFunctionsCache}
\getchunk{defun setHistoryCore}
\getchunk{defun setInputLibrary}
\getchunk{defun setIOindex}
\getchunk{defun setLinkerArgs}
\getchunk{defun setMsgCatlessAttr}
\getchunk{defun setMsgForcedAttr}
\getchunk{defun setMsgForcedAttrList}
\getchunk{defun setMsgUnforcedAttr}
\getchunk{defun setMsgUnforcedAttrList}
\getchunk{defun setNagHost}
\getchunk{defun setOutputAlgebra}
\getchunk{defun setOutputCharacters}
\getchunk{defun setOutputFormula}
\getchunk{defun setOutputFortran}
\getchunk{defun setOutputLibrary}
\getchunk{defun setOutputHtml}
\getchunk{defun setOutputMathml}
\getchunk{defun setOutputOpenMath}
\getchunk{defun setOutputTex}
\getchunk{defun setStreamsCalculate}
\getchunk{defun setUpDefault}
\getchunk{defun shortenForPrinting}
\getchunk{defun show}
\getchunk{defun showdatabase}
\getchunk{defun showHistory}
\getchunk{defun showInOut}
\getchunk{defun showInput}
\getchunk{defun showSpad2Cmd}
\getchunk{defun shut}
\getchunk{defun size}
\getchunk{defun SkipEnd?}
\getchunk{defun SkipPart?}
\getchunk{defun Skipping?}
\getchunk{defun smallEnough}
\getchunk{defun spad}
\getchunk{defun spadClosure?}
\getchunk{defun spad-error-loc}
\getchunk{defun SpadInterpretStream}
\getchunk{defun spad-long-error}
\getchunk{defun spadReply}
\getchunk{defun spadrread}
\getchunk{defun spadrwrite}
\getchunk{defun spadrwrite0}
\getchunk{defun spad-save}
\getchunk{defun spad-short-error}
\getchunk{defun spadStartUpMsgs}
\getchunk{defun spad-syntax-error}
\getchunk{defun spadTrace}
\getchunk{defun spadTraceAlias}
\getchunk{defun spadTrace,g}
\getchunk{defun spadTrace,isTraceable}
\getchunk{defun spadUntrace}
\getchunk{defun spad2BootCoerce}
\getchunk{defun specialChar}
\getchunk{defun spleI}
\getchunk{defun spleI1}
\getchunk{defun split}
\getchunk{defun splitIntoOptionBlocks}
\getchunk{defun stackTraceOptionError}
\getchunk{defun startp}
\getchunk{defun startsNegComment?}
\getchunk{defun statisticsInitialization}
\getchunk{defun streamChop}
\getchunk{defun stringList2String}
\getchunk{defun stringMatches?}
\getchunk{defun string2Constructor}
\getchunk{defun StringToDir}
\getchunk{defun stripUnionTags}
\getchunk{defun strpos}
\getchunk{defun strposl}
\getchunk{defun stupidIsSpadFunction}
\getchunk{defun subMatch}
\getchunk{defun substFromAlist}
\getchunk{defun substringMatch}
\getchunk{defun subTypes}
\getchunk{defun summary}
\getchunk{defun syGeneralErrorHere}
\getchunk{defun syIgnoredFromTo}
\getchunk{defun synonym}
\getchunk{defun synonymsForUserLevel}
\getchunk{defun synonymSpad2Cmd}
\getchunk{defun sySpecificErrorAtToken}
\getchunk{defun sySpecificErrorHere}
\getchunk{defun systemCommand}

\getchunk{defun ?t}
\getchunk{defun tabbing}
\getchunk{defun templateParts}
\getchunk{defun tangle}
\getchunk{defun terminateSystemCommand}
\getchunk{defun tersyscommand}
\getchunk{defun testnumberp}
\getchunk{defun testpassed}
\getchunk{defun thisPosIsEqual}
\getchunk{defun thisPosIsLess}
\getchunk{defun throwEvalTypeMsg}
\getchunk{defun toFile?}
\getchunk{defun tokConstruct}
\getchunk{defun token-stack-show}
\getchunk{defun tokPosn}
\getchunk{defun tokTran}
\getchunk{defun tokType}
\getchunk{defun topLevelInterpEval}
\getchunk{defun trace}
\getchunk{defun trace1}
\getchunk{defun traceDomainConstructor}
\getchunk{defun traceDomainLocalOps}
\getchunk{defun tracelet}
\getchunk{defun traceOptionError}
\getchunk{defun /tracereply}
\getchunk{defun traceReply}
\getchunk{defun trace2}
\getchunk{defun trace3}
\getchunk{defun traceSpad2Cmd}
\getchunk{defun translateTrueFalse2YesNo}
\getchunk{defun translateYesNo2TrueFalse}
\getchunk{defun translateYesNoToTrueFalse}
\getchunk{defun transOnlyOption}
\getchunk{defun transTraceItem}
\getchunk{defun trunclist}
\getchunk{defun typeCheckInputAreas}

\getchunk{defun unAbbreviateKeyword}
\getchunk{defun undo}
\getchunk{defun undoChanges}
\getchunk{defun undoCount}
\getchunk{defun undoFromFile}
\getchunk{defun undoInCore}
\getchunk{defun undoLocalModemapHack}
\getchunk{defun undoSingleStep}
\getchunk{defun undoSteps}
\getchunk{defun unescapeStringsInForm}
\getchunk{defun unifyStruct}
\getchunk{defun unifyStructVar}
\getchunk{defun unparseInputForm}
\getchunk{defun untrace}
\getchunk{defun /untrace-0}
\getchunk{defun /untrace-1}
\getchunk{defun /untrace-2}
\getchunk{defun untraceDomainConstructor}
\getchunk{defun untraceDomainConstructor,keepTraced?}
\getchunk{defun untraceDomainLocalOps}
\getchunk{defun untraceMapSubNames}
\getchunk{defun unwritable?}
\getchunk{defun upcase}
\getchunk{defun updateCurrentInterpreterFrame}
\getchunk{defun updateDatabase}
\getchunk{defun updateFromCurrentInterpreterFrame}
\getchunk{defun updateHist}
\getchunk{defun updateInCoreHist}
\getchunk{defun updateSourceFiles}
\getchunk{defun userLevelErrorMessage}

\getchunk{defun validateOutputDirectory}
\getchunk{defun valueArgsEqual?}
\getchunk{defun var}
\getchunk{defun voidValue}

\getchunk{defun what}
\getchunk{defun whatCommands}
\getchunk{defun whatConstructors}
\getchunk{defun whatSpad2Cmd}
\getchunk{defun whatSpad2Cmd,fixpat}
\getchunk{defun whichCat}
\getchunk{defun with}
\getchunk{defun workfiles}
\getchunk{defun workfilesSpad2Cmd}
\getchunk{defun wrap}
\getchunk{defun write-browsedb}
\getchunk{defun write-categorydb}
\getchunk{defun writeHiFi}
\getchunk{defun writeHistModesAndValues}
\getchunk{defun writeInputLines}
\getchunk{defun write-interpdb}
\getchunk{defun write-operationdb}
\getchunk{defun write-warmdata}
\getchunk{defun writify}
\getchunk{defun writifyComplain}
\getchunk{defun writify,writifyInner}

\getchunk{defun xlCannotRead}
\getchunk{defun xlCmdBug}
\getchunk{defun xlConActive}
\getchunk{defun xlConsole}
\getchunk{defun xlConStill}
\getchunk{defun xlFileCycle}
\getchunk{defun xlIfBug}
\getchunk{defun xlIfSyntax}
\getchunk{defun xlMsg}
\getchunk{defun xlNoSuchFile}
\getchunk{defun xlOK}
\getchunk{defun xlOK1}
\getchunk{defun xlPrematureEOF}
\getchunk{defun xlPrematureFin}
\getchunk{defun xlSay}
\getchunk{defun xlSkip}
\getchunk{defun xlSkippingFin}
\getchunk{defun xSearch}

\getchunk{defun yesanswer}
\getchunk{defun ySearch}

\getchunk{postvars}

\end{chunk}
\chapter{The Global Variables}
\section{Star Global Variables}
\begin{tabular}{lll}
NAME                        & SET              & USE \\
*eof*                       & ncTopLevel       & \\
*features*                  &                  & restart \\
*package*                   &                  & restart \\
*standard-input*            &                  & ncIntLoop \\
*standard-output*           &                  & ncIntLoop \\
*top-level-hook*            & set-restart-hook & \\
\end{tabular}
\subsection{*eof*}
The \verb|*eof*| variable is set to NIL in ncTopLevel.
\subsection{*features*}
The \verb|*features*| variable from common lisp is tested for the presence
of the \verb|:unix| keyword. Apparently this controls the use of Saturn,
a previous Axiom frontend. The Saturn frontend was never released as
open source and so this test and the associated variables are probably
not used.

\subsection{*package*}
The \verb|*package*| variable, from common lisp, is set in restart
to the BOOT package where the intepreter lives.
\subsection{*standard-input*}
The \verb|*standard-input*| common lisp variable is used to set the 
curinstream variable in ncIntLoop. 

This variable is an argument to serverReadLine in
the intloopReadConsole function.

\subsection{*standard-output*}
The \verb|*standard-output*| common lisp variable is used to set the 
curoutstream variable in ncIntLoop.

\subsection{*top-level-hook*}
The \verb|*top-level-hook*| common lisp variable contains the name of
a function to invoke when an image is started. In our case it is
called restart. This is the entry point to the Axiom interpreter.

\section{Dollar Global Variables}
\begin{tabular}{lll}
NAME                         & SET                 & USE \\
\$boot                       & ncTopLevel          & \\
coerceFailure                &                     & runspad \\
curinstream                  & ncIntLoop           & \\
curoutstream                 & ncIntLoop           & \\
\$currentLine                & restart             & removeUndoLines \\
\$dalymode                   &                     & intloopReadConsole \\
\$displayStartMsgs           &                     & restart \\
\$e                          & ncTopLevel          & \\
\$erMsgToss                  & SpadInterpretStream & \\
                             & SpadInterpretStream & \\
\$frameRecord                & initvars            & \\
                             & clearFrame          & \\
                             & undoSteps           & undoSteps \\
                             & recordFrame         & recordFrame \\
\$HiFiAccess                 & initHist            & historySpad2Cmd \\
                             & historySpad2Cmd     & \\
                             &                     & setHistoryCore \\
\$HistList                   & initHist            & \\
\$HistListAct                & initHist            & \\
\$HistListLen                & initHistList        & \\
\$HistRecord                 & initHistList        & \\
\$historyDirectory           &                     & makeHistFileName \\
                             &                     & makeHistFileName \\
\$historyFileType            & initvars           & histInputFileName \\
\$InteractiveFrame           & restart             & ncTopLevel \\
                             & undo                & recordFrame \\
                             & undoSteps           & undoSteps \\
                             &                     & reportUndo \\
\$internalHistoryTable       & initvars            & \\
\$interpreterFrameName       & initializeInterpreterFrameRing & \\
\$interpreterFrameRing       & initializeInterpreterFrameRing & \\
\$intRestart                 &                     & intloop \\
\$intTopLevel                & intloop             & \\
\$IOindex                    & restart             & historySpad2Cmd \\
                             & removeUndoLines     & undoCount \\
\$genValue                   & bookvol5            & i-toplev \\
                             &                     & i-analy \\
                             &                     & i-syscmd \\
                             &                     & i-spec1 \\
                             &                     & i-spec2 \\
                             &                     & i-map \\
\$lastPos                    & SpadInterpretStream & \\
\$libQuiet                   & SpadInterpretStream & \\
\$msgDatabaseName            & reroot              * \\
\$ncMsgList                  & SpadInterpretStream & \\
\$newcompErrorCount          & SpadInterpretStream & \\
\$newspad                    & ncTopLevel          & \\
\$nopos                      &                     & SpadInterpretStream \\
\$okToExecuteMachineCode     & SpadInterpretStream & \\
\$oldHistoryFileName         & initvars            & oldHistFileName \\
\$options                    &                     & history \\
                             & historySpad2Cmd     & historySpad2Cmd \\
                             &                     & undo \\
\$previousBindings           & initvars            & \\
                             & clearFrame          & \\
                             & recordFrame         & recordFrame \\
\$PrintCompilerMessageIfTrue & spad                & \\
\$reportundo                 & initvars            & diffAlist \\
\$spad                       & ncTopLevel          & \\
\$SpadServer                 & restart             & \\
\$SpadServerName             & initvars            & restart \\
\$systemCommandFunction      & SpadInterpretStream & \\
top\_level                   &                     & runspad \\
\$quitTag                    &                     & runspad \\
\$useInternalHistoryTable    & initvars            & initHist \\
                             & setHistoryCore      & setHistoryCore \\
\end{tabular}

\subsection{\$boot}
The \verb|$boot| variable is set to NIL in ncTopLevel.

\subsection{coerceFailure}
The coerceFailure symbol is a catch tag used in runspad
to catch an exit from ncTopLevel.

\subsection{\$currentLine}
The \verb|$currentLine| line is set to NIL in restart.
It is used in removeUndoLines in the undo mechanism.

\subsection{\$displayStartMsgs}
The \verb|$displayStartMsgs| variable is used in restart but is not
set so this is likely a bug.

\subsection{\$erMsgToss}
The \verb|$erMsgToss| variable is set to NIL in SpadInterpretStream.

\subsection{\$frameRecord}
\verb|$frameRecord = [delta1, delta2,... ]| where
delta(i) contains changes in the ``backwards'' direction.
Each delta(i) has the form ((var . proplist)...) where
proplist denotes an ordinary proplist. For example, an entry
of the form ((x (value) (mode (Integer)))...) indicates that
to undo 1 step, x's value is cleared and its mode should be set
to (Integer).

A delta(i) of the form (systemCommand . delta) is a special
delta indicating changes due to system commands executed between
the last command and the current command. By recording these deltas
separately, it is possible to undo to either BEFORE or AFTER
the command. These special delta(i)s are given ONLY when a
a system command is given which alters the environment.

recordFrame('system) is called before a command is executed, and
recordFrame('normal) is called after (see processInteractive1).
If no changes are found for former, no special entry is given.

This is part of the undo mechanism.

\subsection{\$intRestart}
The \verb|$intRestart| variable is used in intloop but has no value.
This is probably a bug. While the variable's value is unchanged the
system will continually reenter the SpadInterpretStream function.

\subsection{\$intTopLevel}
The \verb|$intTopLevel| is a catch tag. Throwing to this tags which is
caught in the intloop will restart the SpadInterpretStream function.

\subsection{\$IOindex}
The \verb|$IOindex| index variable is set to 1 in restart.
This variable is used in the historySpad2Cmd function in the
history mechanism. It is set in the removeUndoLines function
in the undo mechanism.

This is used in the undo mechanism in function undoCount
to compute the number of undos. You can't undo more actions then
have already happened.

\subsection{\$lastPos}
The \verb|$lastPos| variable is set in SpadInterpretStream
to the value of the \verb|$nopos| variable.
Since \verb|$nopos| appears to have no value
this is likely a bug.

\subsection{\$libQuiet}
The \verb|$libQuiet| variable is set to the third argument of the
SpadInterpretStream function. This is passed from intloop
with the value of T. This variable appears to be intended to
control the printing of library loading messages which would need
to be suppressed if input was coming from a file.

\subsection{\$msgDatabaseName}
The \verb|$msgDatabaseName| is set to NIL in reroot.

\subsection{\$ncMsgList}
The \verb|$ncMsgList| is set to NIL in SpadInterpretStream.

\subsection{\$newcompErrorCount}
The \verb|$newcompErrorCount| is set to 0 in SpadInterpretStream.

\subsection{\$nopos}
The \verb|$nopos| variable is used in SpadInterpretStream but does
not appear to have a value and is likely a bug.

\subsection{\$oldHistoryFileName}
The \verb|$oldHistoryFileName| is set at load time by a call to 
initvars to a value of ``last''. 
It is part of the history mechanism. It is used in the function
oldHistFileName and restoreHistory.

\subsection{\$okToExecuteMachineCode}
The \verb|$okToExecuteMachineCode| is set to T in SpadInterpretStream.

\subsection{\$options}
The \verb|$options| variable is tested by the history function.
If it is NIL then output the message 
\begin{verbatim}
  You have not used the correct syntax for the history command.
  Issue )help history for more information.
\end{verbatim}

The \verb|$options| variable is tested in the historySpad2Cmd function.
It appears to record the options that were given to a spad command on
the input line. The function selectOptionLC appears to take a list
off options to scan.

This variable is not yet set and is probably a bug.

\subsection{\$previousBindings}
The \verb|$previousBindings| is a copy of the 
\verb|CAAR $InteractiveFrame|. This is used to
compute the delta(i)s stored in \verb|$frameRecord|.
This is part of the undo mechanism.

\subsection{\$reportundo}
The \verb|$reportundo| variable is used in diffAlist. It was not normally
bound but has been set to T in initvars. If the variable is set
to T then we call reportUndo.

It is part of the undo mechanism.

\subsection{\$spad}
The \verb|$spad| variable is set to T in ncTopLevel.

\subsection{\$SpadServer}
If an open server is not requested then this variable to T.
It has no value before this time (and is thus a bug).

\subsection{\$SpadServerName}
The \verb|$SpadServerName| is passed to the openServer function, if the
function exists. 

\subsection{\$systemCommandFunction}
The \verb|$systemCommandFunction| is set in SpadInterpretStream
to point to the function InterpExecuteSpadSystemCommand.

\subsection{top\_level}
The top\_level symbol is a catch tag used in runspad
to catch an exit from ncTopLevel.

\subsection{\$quitTag}
The \verb|$quitTag| is used as a variable in a catch block. 
It appears that it can be thrown somewhere below ncTopLevel.

\subsection{\$useInternalHistoryTable}
The \verb|$useInternalHistoryTable| variable is set at load time by a call to
initvars to a value of NIL. It is part of the history mechanism.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Bibliography}
We have made every effort to consult and reference primary
sources. (See \cite{Rekd14}).
\bibliographystyle{axiom}
\bibliography{axiom}

\newpage
\phantomsection
{\huge Signatures Index}
\addcontentsline{toc}{chapter}{Signatures Index}
\immediate\closeout\sigfile
\vskip 1cm
\input{signatures.sort}

\newpage
\phantomsection
\addcontentsline{toc}{chapter}{Figure Index}
\renewcommand{\indexname}{Figure Index}
\printindex[fig]

\newpage
\phantomsection
\addcontentsline{toc}{chapter}{Documentation Index}
\renewcommand{\indexname}{Documentation Index}
\printindex[doc]

\newpage
\phantomsection
\addcontentsline{toc}{chapter}{Code Index}
\renewcommand{\indexname}{Code Index}
\printindex[code]

\newpage
\phantomsection
\addcontentsline{toc}{chapter}{Error Index}
\renewcommand{\indexname}{Error Index}
\printindex[err]

\newpage
\phantomsection
\addcontentsline{toc}{chapter}{Category Index}
\renewcommand{\indexname}{Category Index}
\printindex[cat]

\newpage
\phantomsection
\addcontentsline{toc}{chapter}{Domain Index}
\renewcommand{\indexname}{Domain Index}
\printindex[dom]

\newpage
\phantomsection
\addcontentsline{toc}{chapter}{Package Index}
\renewcommand{\indexname}{Package Index}
\printindex[pkg]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}

%%%% -*- Mode: LaTeX; -*-
\documentclass[dvips]{book}

% We have a name on every volume, specificed here
\newcommand{\VolumeName}{Volume 15: The Sane Compiler}

% NOTE: The beautiful styling of bookvol15 is now moved to the shared bookheader.tex
% and is available to all books. -- Chun Tian (binghe), 30 gen 2024
\input{bookheader.tex}

% Now we want arabic numerals, not roman numerals from above
\pagenumbering{arabic}

% tutorial - learning oriented (how to cook)
% howto - goal-oriented (recipe)
% explanation - understanding oriented (culinary social history)
% reference - information oriented (encyclopedia)

%\chapter{A Short Description}
%\chapter{Getting Started} % beginer oriented
%\chapter{Tutorial}        % learning oriented
%\chapter{Explanation}     % understanding oriented
%\chapter{Full Examples}   % problem oriented
%\chapter{Reference}       % information oriented
%\chapter{Architecture}    % maintenance oriented
%\chapter{Getting Started}
%\chapter{Tutorial}
%\chapter{A Full Example}
%\chapter{Reference}
%\chapter{Architecture}

%the general problem
%the specific problem
%what you did (contributions, what research is about)
%take home ideas

% NOTE REWRITE LOOPS INTO FUNCTIONS

\chapter{Motivation}

In the logical traditional fallacy of ``appeal to authority'' I
present quotes from the literature.

\begin{quote}
{\bf What is the most important problem in your field and why aren't
you working on it?}\\
-- Richard Hamming \cite{Hamm95}
\end{quote}

\begin{quote}
{\bf Let us change our traditional attitude to the construction of
programs. Instead of imagining that our main task is to instruct a
computer what to do, let us concentrate rather on explaining to 
human beings what we want a computer to do.}\\
-- Donald Knuth \cite{Knut92}
\end{quote}

This literate program contains the actual source code for the new Sane
version of Axiom. One of the key goals is to support understanding and
long-term maintenance of this new version of Axiom. Key ideas as well
as their implementation in code details are discussed.

Computational Mathematics has had two distinct branches, the computer
algebra branch and the mathematical logic branch. There has been
little crossover between these two fields. Ideally we would have a
system where both were combined into a single system.

\begin{quote}
{\bf It is reasonable to hope that the relationship between
computation and mathematical logic will be as fruitful in the next
century as that between analysis and physics in the last. The
development of this relationship demands a concern for both
applications and for mathematical elegance.}\\
-- John McCarthy \cite{Mcca63}
\end{quote}

Axiom has developed in the Computer Algebra branch and, until now, has
ignored the mathematical logic branch. The time has come to converge
these branches.

This project has the goal of proving Axiom Sane (aka rational,
coherent, judicious, and sound). To do that we enhance Axiom with the
necessary logic structures (e.g. axioms, judgements, assumptions,
etc.) to support formal proofs of the algorithms.

Dijkstra is one of the fathers of a large part of the movement toward
formal proofs and program semantics.

\begin{quote}
{\bf The required techniques of effective reasoning are pretty formal,
but as long as programming is done by people that don't master them,
the software crisis will remain with us and will be considered an
incurable disease.}\\
-- Edsgar Dijkstra \cite{Dijk00}
\end{quote}

The missive of creating a world where formal proofs of programs is the
norm was given by Dijkstra. 

\begin{quote}
{\bf The programmer should not ask how applicable the techniques of
sound programming are, he should create a world in which they are
applicable. It is his only way of delivering a high-quality design.}\\
-- Edsgar Dijkstra \cite{Dijk00}
\end{quote}

The challenge we face, and the problem we attack, is constructing this
``world'' so that Axiom programmers can develop algorithms whose
implementations are high-quality, proven code.

\begin{quote}
{\bf ...a program is no more than half a conjecture. The other half of
a conjecture is the functional specification the program is supposed
to satisfy. The programmer's task is to present such complete
conjectures as proven theorems.}\\
-- Edsgar Dijkstra \cite{Dijk88a}
\end{quote}

There are, of course, "political problems" in the sense that
programmers outright reject the very notion of proving programs
correct. 

\begin{quote}
{\bf One reason for preferring symbol-manipulating, calculating
arguments is that their design is much better teachable than the
design of verbal/pictorial arguments. Large-scale introduction of
courses on such calculational methodology, however, would encounter
unsurmountable political problems.}\\
-- Edsgar Dijkstra \cite{Dijk00}
\end{quote}

The anti-proof arguments abound and are not novel. Dijkstra provides
hope (and working examples) that these can be overcome.

\begin{quote}
{\bf The first pleasant -- and very encouraging! -- experience was the
killing of the myth that formal proofs are of necessity long, tedious,
laborious, error-prone, and what-have-you. On the contrary, our proofs
turned out to be short and simple to check, carried out -- as they are
-- in straightforward manipulations from a modest repertoire.}\\
-- Dijkstra and Scholten \cite{Dijk90}
\end{quote}

There is a growing movement to formalize mathematics using computer
aided proofs. The Xena Project \cite{Xena19} argues that we need to
teach the next generation to develop verified algorithms. The thrust
is toward {\sl rigorous mathematics}, that is, mathematics 
{\sl that is guaranteed to be correct}.

\begin{quote}
{\bf The classical engineering disciplines all have their standard
mathematical techniques that are applied to the design of any
artifact, before it is deployed, to gain confidence about its safety,
suitability for some purpose, and so on. The engineers in a discipline
more or less agree on what are ``the rules'' to be followed in vetting
a design. Those rules are specified with a high degree of rigor, so
that it isn't a matter of opinion whether a design is safe. Why
doesn't software engineering have a corresponding agreed-upon
standard, whereby programmers convince themselves that their systems
are safe, secure, and correct? The concepts and tools may not quite be
ready yet for broad adoption, but they have been under development for
decades. }\\
-- Adam Chlipala \cite{Chli17}
\end{quote}

Axiom has many algorithms that have mathematical specifications, such
as the GCD. Proving that the implementation meets the specification
will make the code more reliable.

\begin{quote}
{\bf Proofs serve two main purposes. First, proofs provide a way to ensure
the reliability of mathematical claims, just as laboratory
verification provides a check in the other sciences. Second, the act
of finding a proof often yields, as a byproduct, new insights and
unexpected new data, just as does work in the laboratory.}\\
-- Jaffe and Quinn \cite{Jaff93} 
\end{quote}

There is the fundamental question of which logic to choose. It turns
out that this can be decided at the programmer's convenience if we
could separate the question of ``the logic'' from the ``machinery''
to implement the logic.

As a fellow computational mathematician, Andrej Bauer is reducing a
logic system to its fine-grain structure, separating the question of
the kernel (aka the nucleus) from the judgements that define the logic.

\begin{quote}
{\bf A Proof Assistant Wish List:
\begin{itemize}
\item small trusted kernel
\item user-definable dependent type theories
\item including user-definable judgemental equality
\item no commitment to an ambient type theory
\item support common proof-development techniques
\end{itemize}
}

-- Andrej Bauer \cite{Baue19a}
\end{quote}

We plan to develop the judgements, axioms, and other logic machinery
in a fully factored form so that it can be inherited. This allows the
definition of a commutative versus a noncommutative domain by simply
choosing different categories to inherit. Bauer's idea of separation
of the nucleus from the logic allows us to experiement with different
forms of reasoning in an integrated way. This achieves one of Milner's
goals.

\begin{quote}
{\bf [...] in any realistic work with the machine as a proof assistant
we expect to be working in a particular problem domain, or theory as
we shall call it [...] it should [...] allow us access to those
tactics that we have previously defined either of general use or
pertaining to the theory in question. Furthermore, almost every
interesting applied theory is founded upon more primitive theories
(called its ancestor theories), and while working in any theory we
expect to have access to all material pertaining to its ancestors.

An important function of the proof assistant is therefore to keep our
tower of theories properly organized, allowing us [...] to work in
any existing theory (not only those at the top of the tower) by
proving new theorems in them.}\\
-- Robin Milner \cite{Miln84}
\end{quote}

Axiom supports ``First Class Dynamic Types''. This allows code to
construct and query new types at run time.

Computational Mathematics has two nearly disjoint branches. 
One branch is proof systems, such as Coq, Agda, and Idris.
A second branch is computer algebra systems, such as Axiom,
Mathematica, and Maple.

There is a vast literature in each branch. However, the bibliographic
references are nearly disjoint.

There are attempts to prove various computer algebra algorithms in
proof systems. The dream is to have a full computer algebra system
developed in this manner. The key problem is that computer algebra
systems are very large, containing many thousands of algorithms.

There are almost no attempts to prove computer algebra systems
correct. One key problem is that most systems are not
well-founded. They are ad hoc, "it worked for me" development. Another
key problem is that most of the proof systems cannot handle fully
dependent type theory.

Axiom is unique among computer algebra systems as it has a scaffold
based on abstract algebra. Abstract algebra framework gives a solid
theoretical base that provides obvious places to provide algebraic
axioms.

Extending Axiom to provide these axioms means that they will be
inherited just as signatures are inherited. Proofs of algorithms can
refer to these axioms.

Axiom needs to be extended to include a specification language so that
the algorithms have exact specifications. We will be examining several
specification languages, starting with Z \cite{Wood20}.

Axiom also needs to be extended with a proof language so algorithms
can have associated proofs.

Due to the complexity of these requirements and their need to
interact, it is clear that Axiom's compiler and interpreter need to be
re-architected and re-implemented.

Because all of these goals are based on type theory we have decided to
use the Common Lisp Object System (CLOS). CLOS classes define new
types at the Lisp level, providing a base case for type inference.

Type analysis will require both compile-time typing 
and gradual typing \cite{Bake84}.

Hoare \cite{Hoar03} provided a call for a {\sl Grand Challenge} to
create a {\sl Verifying Compiler}. This effort falls along the lines
suggested but is only an instance in a small domain. On the other
hand, Axiom's focus on mathematical algorithms provides the best
chance for a successful instance of his challenge.

Homotopy Type Theory (HoTT)\cite{Acze13}\cite{Lica16}
applies to Axiom, defining paths between the
various categories.This is likely to instill discipline on
coercions. In the original Axiom systems, coercions were ad hoc
constructions. But such coercions in a Homotopy Type Theory fall
under the Univalence principle, defining coercions and their
inverses. There is, for example, a ``curry'' path between
$A\times B\rightarrow C$ and 
$A\rightarrow B\rightarrow C$. \cite{Lica16a}
This might be usefully applied
using generic code to perform the conversion. Exactly how to
incorporate this the Sane effort is still to be thought through.

Weber \cite{Webe05} gives a simple example of a family of types
arising in computer algebra whose coercion relations cannot be
captured by a finite set of first-order rewrite rules. If arbitrary
(first-order) terms are allowed in the rewrite rules, the general type
inference problem becomes undecidable.

\chapter{Why this effort won't succeed}

\section{The task to too large}

So what is the plan to achieve a research result?

There are 3 major restrictions (so far).

First the focus in on the GCD in NonNegativeInteger.
Volume 13 is basically a collection of published thoughts by various
authors on the GCD, a background literature search. Build a limited
system with essentially one user visible function (the NNI GCD) and
implement all of the ideas there. This demonstrates inheritance of
axioms, specification of functions, pre- and post-conditions, proof
integration, provisos, the new compiler, etc.

Second, make the SANE GCD work in the current Axiom system by
generating compatible code. This gives a stepping stone approach where
things can be grounded. Obviously none of the new proof ideas will be
expected to work in the current system but it ``gives a place to
stand''.

Third, develop a lattice of functions. The idea is to attack the
functions that depend on almost nothing, prove them correct, and use
them to prove functions that only depend on the prior layer. I did
this with the category structure when I first got the system since it
was necessary to bootstrap Axiom without a running system (something
that was not possible with the IBM/NAG version). That effort took
several months so I expect a function-lattice to take about the
same time.

This makes the research ``incremental'' so that a result can be
achieved in one lifetime. Like a PhD thesis, it is initially intended
as a small step forward but still be a valid instance of
``computational mathematics'', deeply combining proof and computer
algebra. 

\section{The weakness of program verification}

DeMillo, Lipton, and Perlis \cite{Demi79} identify what they believe
is the key weakness of program verification, that, to increase
confidence in the correctness of a program
\begin{quote}
{\bf ``... the device that verifiers use... is a long chain of formal,
deductive logic.'' Although mathemticians ``could in theory'' use the
same device to increase confidence in theorems ``in fact they
don't. What they use is a proof, a very different animal... in the
end, it is a social process that determines whether mathematicians
feel confident about a theorem -- and we believe that, because no
comparable social process can take place among program verifiers,
program verification is bound to fail''}\\
-- from Donald Mackenzie \cite{Mack01}
\end{quote}

Dijkstra \cite{Dijk78} wrote a reply to their paper.

There is a confusion here, I believe. DeMillo et al. think that the
effort to verify software ``is not what a mathematician does''. We can
agree with that. Dijkstra's point of view is that verification
increases the confidence in software's correctness. They both seem to
get at the heart of the matter, just different hearts. To this point,
we do not claim to be ``doing mathematics''. We claim to be doing
program verification.

On the subject of verification DeMillo et al. write
\begin{quote}
{\bf There is a fundamental logical objection to verification, an
objection on its own ground of formalistic rigor. Since the
requirement for a program is informal and the program is formal, there
must be a translation, and the translation itself must necessarily be
informal.}\\
-- DeMillo, Lipton, and Perlis \cite{Demi79}
\end{quote}

And Cnatwell said
\begin{quote}
{\bf Just because a program is ``proven correct'', you cannot be sure
that it will do what you intend.}\\
-- Brian Cantwell Smith \cite{Smit60}
\end{quote}

Smith  points out that correctness is with respect to a model, which
we can verify but correctness of the model with respect to the world
cannot be verified.

In the context of Axiom, however, the ``requirement for a program'' is
quite formal since we are working with algorithms to implement
mathematics with known, formal properties, such as the GCD.

DeMillo et al. also write
\begin{quote}
{\bf The formal demonstration that a program is consistent with its
specifications has value only if the specifications and the program
are independently derived.}\\
-- DeMillo, Lipton, and Perlis \cite{Demi79}
\end{quote}

While we could take issue with this statement in general, it is clear
that with Axiom's algorithms, their criteria for ``has value'' is met.

DeMillo et al. are also confused as to the mechanism of
verification. They seem to assume that verification cannot use the
results of prior verification. That is, they seem to assume that the
``GCD theorem'', shown by prior verification, needs to be fully
expanded and re-verified at the most primitive level every
time. That's a really odd view for a mathematician. Proof checkers
don't re-prove everything every time.

Fetzer writes
\begin{quote}
{\bf The notion of program verification appears to trade upon an
equivocation. Algorithms, as logical structures, are appropriate
subjects for deductive verification. Programs, as causal models of
those structures, are not. The success of program verification as a
generally applicable and completely reliable method for guaranteeing
program performance is not even a theoretical possibility.}\\
-- James H. Fetzer \cite{Fetz88}
\end{quote}

Hoare (quoted in Fetzer' paper writes)
\begin{quote}
{\bf I hold the opinion that the construction of computer programs is
a mathematical activity like the solution of differential equations,
that programs can be derived from their specifications through
mathematical insight, calculation, and proof, using algebraic laws as
simple and elegant as those of elementary arithmetic.}\\
-- C.A.R. Hoare \cite{Fetz88}
\end{quote}

Fetzer makes an interesting distinction between absolute verification
and relative verification.
\begin{quote}
{\bf With respect to deductions, the term {\sl verification} can be
used in two rather different senses. One of these occurs in pure
mathematics and in pure logic, in which theorems of mathematics and of
logic are subject to demonstration. These theorems characterize claims
that are always true as a function of the meanings assigned to the
specific symbols by means of which they are expressed. Theorem-schemata 
and theorems in this sense are subject to verification by deriving
them from no presmises at all (within systems of natural deduction) or
from primitive axioms (within axiomatic formal systems). The other
occurs in ordinary reasoning and in scientific contexts in general,
whenever {\sl conclusions} are shown to follow from specific sets of 
{\sl premises}, where there is no presumption that these conclusions
might be derived from no premises at all or that those premises should
be true as a function of their meaning. Thus, within a system of
natural deduction or an axiomatic formal system, the members of the
class of consequences that can be derived from no premises at all or
that follow from primitive axioms alone may be said to be
{\sl absolutely} verifiable. By contrast those members of the class of
consequences that can only be derived relative to specific sets of
premises whose truth is not absolutely verifiable, may be said to be
{\sl relatively} verifiable.}\\
-- James H. Fetzer \cite{Fetz88}
\end{quote}

Fetzer claims that programs are subject to relative rather than
absolute verification, in relations to rules and axioms in the form of
lawful and causal generalizations as premises -- empirical claims
whose truth can never be established with certainty. The very idea of
program verification trades upon an equivocation.

Fetzer does make an interestng distinction between algorithms and
programs. A program is an instance of instantiating an algorithm.
So the proof of the algorthm and the verification of a program that
implements that algorithm are two different tasks.

Ron Pressler has several blog posts about software
verification, making some excellent points. He postulates a theorem:
\begin{quote}
{\bf There does not exist a generally useful programming language
where every program is feasibly verifiable.}\\
-- Ron Pressler \cite{Pres19}
\end{quote}

On the other hand, Doron Zeilberger writes:
\begin{quote}
{\bf In this process, computer algebra, that great implementer of
high-school algebra, will play a central role. The king (abstract
math) is dead. Long live the King (Concrete Mathematics).}\\
-- Doron Zeilberger \cite{Zeil02}
\end{quote}

Maurer, in a letter to ACM in response to the DeMillo article,
makes an analogy to compilers
\begin{quote}
{\bf Originally, this was done by hand; people wrote out programs in
sequences of steps specified informally in English and then proceeded
to translate these into machine languages. Then compilers came along,
and started to do this job automatically. At first people were against
this ... Compilers did what had previously been a fascinating human
job in a machine-like, humorless manner. (They also produced overly
long object code, in much the same way that a [mechanized] verifier
produces overly long proofs.) Nobody is ever going to read the object
code produced by a compiler, either; one simply trusts the compiler
and goes about one's business. What we hope for in verifiers is that
we will at least be able to trust them to show program correctness.}\\
-- as quoted in \cite{Mack01}
\end{quote}

So there is a ``storm of misunderstanding'' between these various
viewpoints. We will try not to claim that this effort is ``doing
mathematics'', only that it is ``increasing the trust in the
algorithms so they can be used in interactive proof systems''.

Make no mistake, this is an enormous task. 

It requires a deep understanding of how Axiom implements first-order
dependent type theory. Dependent types are undecidable so there have
to be heuristics and some user-extensible mechanism for new
heuristics.

It requires a deep understanding of first-order dependent types. How
can we construct a new dependent type "on the fly" in the interpreter
that is type-correct and provable?

It requires a deep understanding of Type Theory. Which form of type
theory is used? How can it be factored into categories? How can we
show that all inherited paths form sound and complete types?

It requires a deep understanding of the Calculus of Construction with
induction. Coq and Lean \cite{Carn19a} implement this form of
logic. They are both at the leading edge of the field and still under
active development and debate.

It requires a deep understanding of Program Verification. Coq and Lean
do not (yet) have libraries that directly support program
semantics. Nor does the Spad language (yet) have well-defined
semantics. 

It requires proving algorithms that may never have been proven, may
not be correct, and may not terminate under all inputs. Further, many
of the algorithms have no specification.

It requires constructing a well-typed compiler and a well-typed
interpreter. The compiler needs to parse both the Spad language and
the new logical extensions.

It requires validation and verification of the well-typed-ness of the
compiler and interpreter, both of which are implemented in CLOS on top
of Common Lisp.

It requires constructing the whole tower on a trusted kernel of logic
which itself might sit on a trusted nucleus that can adapt to a range
of logics. This must be verified and validated ``to the metal''.

The question of what constitutes ``real proof'' is not quite as
settled as most would believe. MacKensie \cite{Mack01} published a
sociology study of the question and points out that there are 
various cohorts within the mathematics community that do not agree
that machine-based proofs are ``proofs''.

DeMillo et al. makes a reasonably valid point though
\begin{quote}
{\bf The lone fanatic might construct his own verification, but he
would never have any reason to read anyone else's, nor would anyone
else ever be willing to read his. No community could develop. Even the
most zealous verifier could be induced to read a verification only if
he thought he might be able to borrow or swipe something from
it. Nothing could force him to read someone else's verification once
he had grasped the point that no verification bears any necessary
connection to any other verification.}\\
-- DeMillo, Lipton, and Perlis \cite{Demi79}
\end{quote}

But since ``verification'' is the ``assembly language'' of the system
this is hardly a criticism. Proof systems will read the verification,
just like CPUs ``read the assembly language''.

The key ``transition paper'' from these arguments seems to be 
Martin-L\"of's ``Constructive Mathematics and Computer Programming''
paper \cite{Mart79}. To quote the abstract
\begin{quote}
{\bf If programming is understood not as the writing of instructions for
this or that computing machine but as the design of methods of
computation that it is the computer's duty to execute (a difference
that Dijkstra has referred to as the difference between computer
science and computing science), then it no longer seems possible to
distinguish the discipline of programming from constructive
mathematics. This explains why the intuitionistic theory of types,
which was originally developed as a symbolism for the precise
codification of constructive mathematics, may equally well be viewed
as a programming language. As such it provides a precise notation not
only, like other programming languages, for the programs themselves
but also for the tasks that the programs are supposed to
perform. Moreover, the inference rules of the theory of types, which
are again completely formal, appear as rules of correct program
synthesis. Thus the correctness of a program written in the theory of
types is proved formally at the same time as it is being synthesized.}\\
-- Per Martin-L\"of \cite{Mart79}
\end{quote}

Robert Harper uses it as the basis for his Computational Type Theory
Course \cite{Harp18}.

\section{Intellectual Complexity}

There is a considerable gap between writing a program and proving the
program correct. Languages like Coq, and even the terms withing Coq
such as ``inductive'', and ``constructor'' are not normally part of 
the programmer's world.

There is a very slow convergence of syntax in languages like ML and
Haskell but their emphasis is on type theory as a "checking" bit of
machinery rather than on type theory as a "proof" bit of machinery.

\subsection{Alturki and Moore \cite{Altu19}}

Consider a simple example of a Coq program proof.

We need to specify three things:
\begin{itemize}
\item {\bf L}, a formal model of the syntax and semantics of the
programming language
\item {\bf P}, a formal representation in model {\bf L}
\item {\bf S}, a specification of the property to be verified
\end{itemize}

\subsection{An example}

See the example code in the appendix \ref{Coq Example Code}.

Given a program
\begin{verbatim}
sum = 0;
while (!(n <= 0)) {
  sum = sum + n;
  n = n + -1;
}
\end{verbatim}
we need to have
\begin{itemize}
\item a formal model of the semantics of the language used
\item a precise specification of the program structure
\item a specification that this computes the sum of integers
from 1 to n.
\end{itemize}

\subsection{Specification of the example in Coq}

In Coq an arithmetic expression can be defined as:
\begin{verbatim}
Inductive AExp :=
  | var  : string -> AExp
  | con  : Z -> AExp
  | plus : AExp -> AExp -> AExp
\end{verbatim}
where variables use constructor {\bf var} applied to a string,
constants use constructor {\bf con} applied to an integer (Z
is the set of integers), and the {\bf plus} constructor takes
2 {\bf AExp} arguments and returns a {\bf AExp} result. 

Programs are defined as
\begin{verbatim}
Inductive Pgm :=
    pgm : list string -> Stmt -> Pgm.
\end{verbatim}

The summation program above become essentially an abstract
syntax tree
\begin{verbatim}
Definition sum_pgm N : Pgm :=
 pgm ["n"; "sum"]
(seq (assign "n" (con N))
(seq (assign "sum" (con 0))
     (while (not (le (var "n") (con 0)))
     (seq (assign "sum" (plus (var "sum") (var "n")))
          (assign "n" (plus (var "n") (con (-1)))))))).
\end{verbatim}

\subsection{Semantics of the example in Coq}

Note that we are using operational semantics here.

The semantics of arithmetic expressions is captured by a binary
transition relation on states, where a state is a pair
{\bf (AExp, Env)} consisting of an arithmetic expression
{\bf AExp} and the environment {\bf Env} in which {\bf AExp} is to be
evaluated. 

This binary transition relation can be defined in Coq as an
inductively defined proposition (of type Prop), {\bf step\_e}, that
tells us whether a given pair of states belongs to the relation.
\begin{verbatim}
Inductive step_e : (AExp * Env) -> (AExp * Env) -> Prop :=
  | step_var: forall v x env, get v env = Some x ->
      step_e (var v, env) (con x, env)
  | step_plus: forall x y env,
      step_e (plus (con x) (con y), env) (con (Z.add x y), env)
  | cong_plus_r: forall e1 e2 e2' env env',
      step_e (e2, env) (e2', env') ->
      step_e (plus e1 e2, env) (plus e1 e2', env')
  | cong_plus_l: forall e2 e1 e1' env env',
      step_e (e1, env) (e1', env') ->
      step_e (plus e1 e2, env) (plus e1' e2, env')
\end{verbatim}

The {\bf step\_var} states that the program variable {\bf var~v}
evaluates in one step to its value {\bf con~x} in the environment 
{\bf env} ({\bf x} is the integer value obtained from the function
application {\bf get~v~env}, the value to which {\bf v} is mapped in
the {\bf env}, and this holds for all program variables and
environments (recall that {\bf con} is the constructor for integer
constants). Another example is the {\bf step\_plus} case, which states
that any arithmetic expression of the form 
\begin{verbatim}
   plus (con x) (con y)
\end{verbatim}, in which the operands of addition have already been
evaluated to constant values, evaluates in one step to the value that
is the sum of the operands, regardless of the current environment 
({\bf Z.add} is the integer addition operation). Note how 
{\bf step\_plus}, {\bf cong\_plus\_r}, and {\bf cong\_plus\_1}
collectively specify call-by-value semantics of {\bf plus}.

\subsection{Testing execution}

Using the Coq definition of {\bf sum\_pgm} above, we can test that 
{\bf sum\_pgm~100} produces the expected result, 5050.
\begin{verbatim}
Lemma test_execution :
  clos_relf_trans_1n _ step_p
    (sum_pgm 100,[])
    (pgm nil skip, [("sum",5050);("n",0)]).
\end{verbatim}

An execution trace is constructed by the reflexive-transitive closure
of the {\bf step\_p} relation (see \ref{Coq Example Code}.), computed
by Coq's inductively defined proposition 
{\bf clos\_refl\_trans\_1n}. Note that the program in the final state
is the command {\bf skip}, requiring that the program be fully
executed. 

Completing the proof requires picking the right clause of the step
relation for each step of execution. 

\subsection{Specifying correctness goals}

We need to formalize the statement of the property we wish to verify as
a reachability property. Following the language independent approach
of program verification by coinduction \cite{Moor18}, 
we define a program property
as a reachability claim on program states of the form 
{\bf (Pgm~*~Env)}. In particular, using the coinductive proof machinery
(see \ref{Coq Example Code}), the main correctness property of 
{\bf sum} can be defined as the following inductive proposition
(recall that the quoted strings ``n'' and ``sum'' are the program
variables, while {\bf n} is a universally quantified logical name
denoting a symbolic value)
\begin{verbatim}
Inductive sum_spec : Spec (Pgm * Env) :=
 | sum_claim: forall n, 0 <= n ->
   sum_spec
     (pgm ["n"; "sum"]
       (seq (assign "n" (con n))
       (seq (assign "sum" (con 0))
            (while (not (le (var "n") (con 0)))
            (seq (assign "sum" (plus (var "sum") (var "n")))
                 (assign "n" (plus (var "n") (con (-1))))))))
     ,[])
     (fun cfg' => cfg' = (pgm [] skip, [("sum",((n + 1) * n)/2);("n",0)]))
\end{verbatim}

{\bf Spec} is the general type of (language independent) program
specifications (reachability claims), instantiated here with states
{\bf Spec~(Pgm~*~Env)}. The specification states that for all
non-negative values {\bf n}, the initial pair consisting of the
program {\bf sum} and the empty environment {\bf []} reaches a state
having the empty program {\bf skip} as its first component and an
environment in its second component that maps the program variables
``n'' to zero and ``sum'' to the value of the expression
{\bf ((n~+~1)~*~n)/2}.

Other properties, e.g. the loop invariant for {\bf sum}, may also need
to be defined in addition to the main correctness property. In Coq,
these properties on program states, or instantiated {\bf Spec}
propositions in the case when the coinductive program verification
approach described here is used. Coq tends to be more verbose
requiring having other, smaller, properties specified and proved
including correctness properties of environment manipulation
operations. 

\subsection{Verifying correctness}

In a language verification framework, deductive program verification
entails showing that a property {\bf S}, like the main correctness
property of {\bf sum}, follows logically from a given model {\bf L} of
the language and a model {\bf P} of the program, along with other
smaller intermediate properties that have already been show to hold in 
{\bf L} and {\bf P}.

Following the language-independent coinductive verification approach 
(see \cite{Moor18}, a program is shown to meet its specification by
(1) using the step relation defining the semantics of the language in
which the program is written as a symbolic execution engine, and (2)
using simple co-inductive reasoning on circular behaviors emanating
from recursive and iterative constructs in the language (such as
loops). The machinery specified in Coq allowing the reachability logic
proof strategy can be found in the appendix (see 
\ref{Coq Example Code}).

To prove correctness we need to specify and show the loop
invariant. For that, we introduce another constructor of the type 
{\bf sum\_spec}
\begin{verbatim}
 | sum_loop_claim : forall env n, get "n" env = Some n -> 0 <= n ->
                    forall s, get "sum" env = Some s ->
      sum_spec
         (pgm []
           (while (not (le (var "n") (con 0)))
             (seq (assign "sum" (plus (var "sum") (var "n")))
                  (assign "n" (plus (var "n") (con (-1))))))
         ,env)
      (fun cfg' => fst cfg' = pgm [] skip /\
         snd cfg' = set "n" 0 (set "sum" (s + ((n + 1) * n)/2) env)).
\end{verbatim}

Note that {\bf get $\times$ env} evaluates to the value to which $x$
is mapped in {\bf env} (if defined), while {\bf fst} and {\bf snd}
return respectively the first and second components of a state pair.

To verify that {\bf sum} meets its specification given by 
{\bf sum\_spec}, which is that the initial state of {\bf sum} either
diverges or terminates with the correct value for {\bf sum}, we
instantiate the general coinductive soundness theorem with the step
relation {\bf step\_p} defining the semantics, and show the following
statement: 
\begin{verbatim}
Lemma sum_ok : sound step_p sum_spec.
\end{verbatim}

{\bf sound} is a generic proposition on reachability claims. The proof
of this instantiation is based on a generalized co-induction theorem
that mechanizes the verification approach.

\chapter{Adding the axioms to Axiom}

This is work by Erik Poll and Simon Thompson \cite{Poll98} published
in 1998, providing one of the motivations behind the current effort.
There is another, later version \cite{Poll00} with significant
overlap. Also of interest in a paper on ``The Type System of Aldor''
\cite{Poll99a}.

\section{Abstract}

A number of combinations of theorem proving and computer algebra
systems have been proposed; in this paper we describe another, namely
a way to incorporate a logic in the computer algebra system Axiom. We
examine the type system of Aldor -- the Axiom Library Compiler -- and
show that with some modifications we can use the dependent types of
the system to model a logic, under the Curry-Howard isomorphism. We
give a number of example applications of the logic we construct.

\section{Introduction}

Symbolic mathematical -- or computer algebra -- systems, such as Axiom 
\cite{Book00}, Maple and Mathematica, are in everyday use by
scientists, engineers and indeed mathematicians, because they provide
a user with techniques of, say, integration which far exceed those of
the person themselves, and make routine many calculations which would
have been impossible some years ago. These systems are, moreover,
taught as standard tools within many university undergraduate
programmes and are used in support of both academic and commercial
research.

There are, however, drawbacks to the widespread use of automated
support of complex mathematical tasks, which has been widely noted:
Fateman \cite{Fate96a} gives the graphic example of systems which will
assume that $a\ne 0$ on the basis that $a=0$ has not been
established. This can have potentially disastrous consequences for the
naive user of the system or indeed, if it occurs within a
sufficiently complicated context, {\sl any} user.

Symbolic mathematics systems are also limited by their reliance on
algebraic techniques. As Martin \cite{Mart99} remarks, in performing
operations of analysis it might be a precondition that a function be
continuous; such a property cannot be guaranteed by a computer algebra
system alone.

All this makes the combination of computer algebra with theorem
proving a topic of considerable interest: the logical capabilities of
a theorem prover could be used to express the assumptions upon which
an answer rests, and in critical cases be used to establish the truth
of those assumptions.

The literature contains a number of different strategies proposed for
combining computer algebra and theorem proving; see, for instance, 
\cite{Buch96}, \cite{Calm96}, \cite{Baue98}. This paper examines
another proposal: that of using the type system of the Axiom
\cite{Book00} computer algebra system to represent a logic, and thus
to use the constructions of Axiom to handle the logic and represent
proofs and propositions, in the same way as is done in theorem provers
based on type theory such as Nuprl \cite{Cons85} or Coq \cite{COQR16}.

This paper particularly explores the recent Axiom Library Compiler,
Aldor \cite{Watt94a}, which is unusual among computer algebra systems
in being strongly typed, and moreover in having a very powerful type
system, including dependent types.

The implementation of dependent types in Aldor is without evaluation of
type expressions -- so each type expression is its own normal form --
and we show how this limits the expressivity of the dependent
types. We propose a modification of the Aldor system which allow the
types to represent the propositions of a constructive logic, under the
Curry-Howard correspondence. We argue that this integrates a logic
into the Aldor system, and thus permits a variety of logical
extensions to Aldor, including adding pre- and post-conditions to
function specifications, axiomatisations to categories of mathematical
objects as well as the ability to reason about the objects in Axiom.

The structure of the paper is as follows. Section \ref{poll2}
introduces Aldor, and more details of Aldor dependent types appear in
Section \ref{poll3}. We show how a logic can be defined in (a variant
of) the Aldor system in Section \ref{poll4} and Section \ref{poll5}
gives some example applications. We conclude with a discussion of
related and future work.

\section{An introduction to Aldor}
\label{poll2}

The Axiom Library Compiler, Aldor \cite{Watt94a} (previously known as
AXIOM-XL or $A^{\#}$), provides the user with a powerful,
general-purpose programming language in which to model the structures
of mathematics. This language is functionally based and provides
higher order-functions, generators (which bear a strong relationship
to list comprehensions) and other features of modern functional
languages like Standard ML \cite{Miln90} and Haskell \cite{Huda92}, 
as well as being strongly typed.

\subsection{The type system of Aldor}
\label{poll2.1}

Unusually among languages for computer algebra, but in keeping with
the functional school, Aldor is strongly typed, and each declaration
of a binding is accompanied by a declaration of the type of the value
bound, as in the example
\begin{verbatim}
a : Integer == 23;
\end{verbatim}

This contrasts with languages like Haskell in which types need not be
declared explicitly since they can be deduced by the
system\footnote{Most Haskell programmers would, however, tend to give
type declarations for their definitions, since they serve both as an
important check on the programmer's intention as well as providing
crucial documentation}. In Aldor types have to be declared explicitly
since the type system has a variety of complex features including the
following.

{\bf Overloading} A single identifier can be used to denote values of
different type, such as {\bf Int {\tt ->} Int} and {\bf Int {\tt ->}
Bool {\tt ->} Int}\footnote{Note that this is a much more powerful
overloading facility than that provided by Haskell type classes
\cite{Huda92} in which overloaded functions have to be of the same
arity.} Some support is provided for users to resolve overloading when
that proves to be necessary.

{\bf Coercions} Some `courtesy' coercions are provided by the system
automatically: these convert between multiple values 
({\sl \'a la} LISP), cross products and tuples. It is also possible to
make explicit conversions -- by means of the {\bf coerce} function --
from integers to floating point numbers and so forth.

{\bf Types as values} The type {\bf Type} is itself a type; it is by
this means that the system supports functions over types, such as
\begin{verbatim}
idType (ty : Type) : Type == ty;                             (1)
\end{verbatim}
and explicit polymorphism, as in 
\begin{verbatim}
id (ty : Type, x : ty) : ty == x;                            (2)
\end{verbatim}

This resembles the quantification in System F in which functions can
depend on type parameters, and in ${\tt F}^\omega$ where functions can
be defined from types to types. This is investigated further in
Section \ref{poll3.1}

{\bf Dependent types} Aldor permits functions to have dependent types,
in which the type of a function result depends upon the value of a
parameter. An example is the function
\begin{verbatim}
vectorSum : (n:Integer) -> Vector(n) -> Double
\end{verbatim}
in which the result of a function application, say
\begin{verbatim}
vectorSum(34)
\end{verbatim}
has the type {\bf Vector(34) {\tt ->} Double} because its argument has
the value 34. In a similar way, when the {\bf id} function of
definition (2) is applied, its result type is determined by the type
which is passed as its first argument.

We discuss this aspect of the language in more detail in Section
\ref{poll3}.

{\bf Variables} The system is not fully functional, containing as it
does variables which denote storage locations. The presence of
updatable variables inside expressions can cause side-effects which
make the elucidation of types considerably more difficult.

There is a separate question about the role of `mathematical'
variables in equations and the like, and the role that they play in
the type system of Axiom.

{\bf Categories and domains} These features which provide a form of
data abstraction are addressed in more detail in Section \ref{poll2.2}

The Aldor type system can thus be seen to be highly complex and we
shall indeed see that other features such as macros (see Section
\ref{poll2.2}) complicate the picture further; one of the aspects of
our work is to try to reach a more formal description of (substantial
parts of) the typing mechanism of Aldor.

\subsection{Categories and domains}
\label{poll2.2}

Axiom is designed to be a system in which to represent and manipulate
mathematical objects of various kinds, and support for this is given
by the Aldor type system. One can specify what it is to be a monoid,
say, by defining the Category\footnote{There is no relation between
Axiom's notion of category and the notion from category theory!}
called {\bf Monoid}, thus
\begin{verbatim}
Monoid: Category == BasicType with {                         (3)
  * : (%,%) -> %;
  1 : %; }
\end{verbatim}

This states that for a structure of a type '\%' to be a monoid it has
to supply two bindings; in other words a {\bf Category} describes a
signature. The first name in the signature is '*' and is a binary
operation over the type '\%'; the second is an element of '\%'.

In fact we have stated slightly more than this, as {\bf Monoid}
extends the category {\bf BasicType} which requires that the
underlying type carries an equality operation.
\begin{verbatim}
BasicType : Category == with {
  = : (%,%) -> Boolean; }
\end{verbatim}

We should observe that this {\bf Monoid} category does not impose any
constraints on bindings to '*' and '1': we shall revisit this example
in Section \ref{poll5.2} below.

Implementations of a category are abstract data types which are known
in Axiom as domains, and are defined as was the value {\bf a} above
\begin{verbatim}
IntegerAdditiveMonoid : Monoid == add {                      (4)
  Rep == Integer;
  import from Integer;

  (x:%) * (y:%) : % == per((rep x) + (rep y));
  1 : %             == per 0; }
\end{verbatim}

The category of the object being defined -- {\bf Monoid} -- is the
type of the domain we are defining, {\bf IntegerAdditiveMonoid}. The
definition identifies a representation type, {\bf Rep}, and also uses
the conversion functions {\bf rep} and {\bf per} which have the types
\begin{verbatim}
rep : % -> Rep                 per : Rep -> %
\end{verbatim}

In fact, {\bf Rep}, {\bf rep} and {\bf per} are implemented using the
macro mechanism of Aldor, and so are eliminated before type
checking. Another aspect of Aldor which we intend to explore are ways
in which the macro system can be eliminated in favour of a properly
type checked mechanism, and so in particular support the type
abstraction machinery introduced here.

We have seen already that one category can extend another; this can be
seen as a form of inheritance. Other operations are available on
categories, including a {\bf Join} operation which joins two
categories, thus allowing a form of multiple inheritance.

Categories provide a powerful abstraction mechanism which allows
functions to be written which depend on the bindings in a category,
and which can therefore be used over any domain which implements the
category; that is any abstract data type which implements the
signature in question. Categories resemble existential types 
\cite{Mitc88}\cite{Sant95}
but are implemented in a similar way to Haskell classes in that the
type of the operands in an application determine which implementation
of the operation is used.

One of the advantages of the Haskell type class mechanism is that it
is possible to declare a type as an {\bf instance} of different
classes at different points in a program. In the first version of
Axiom this was not allowed, so that an Axiom domain would have a
signature (this is category) fixed at the point of definition and
could not be extended to become an instance of a newly-defined
category; this is possible in Aldor, using a {\sl post-facto}
extension. Details of this and other features can be found in 
\cite{Watt94a}

Categories can also be parametric, and depend upon value or type
parameters. we shall see an example of this in Section \ref{poll3}1
below. We continue to explore the Aldor type system in the following
section where we look in more detail at the dependent types of the
system. 

\section{Dependent types}
\label{poll3}

The Aldor language contains dependent types, so that one can define
functions such as {\bf vectorSum} which defines a sum function for
vectors of arbitrary length, of type
\begin{verbatim}
vectorSum : (n:Integer) -> Vector(n) -> Double
\end{verbatim}
and a function {\bf append} to join two vectors together
\begin{verbatim}
append : (n:Integer,m:Integer,Vector(n),Vector(m)) -> Vector(n+m)
\end{verbatim}

Given vectors of length two and three, {\bf vec2} and {\bf vec3}, we
can join them thus
\begin{verbatim}
append(2,3,vec2,vec3) : Vector(2+3)
\end{verbatim}
and we would expect to be able to find the sum of this vector by
applying {\bf vectorSum 5}, thus
\begin{verbatim}
(vectorSum 5) append(2,3,vec2,vec3)
\end{verbatim}
but this will fail to type check, since the argument is of type
{\bf Vector(2+3)}, which is not equal to the expected type, namely
{\bf Vector(5)}. This is because no evaluation takes place in type
expressions in Aldor (nor indeed in the earlier version of Axiom).

In Section \ref{poll3.2} we discuss how the Aldor type mechanism can
be modified to acommodate a more liberal evaluation strategy within
the type checker. Before doing that we look at another example of the
problems caused by the failure of Aldor to evaluate type expressions.

\subsection{Types as values}
\label{poll3.1}

Another example is provided by trying to formalise the notion from
(mathematical) category theory \cite{Macl91}, namely that of a
functor. Specifically we are thinking of the types of the language as
forming a category, whose objects are the types themselves, and an
arrow from {\bf A} to {\bf B} is a function of type {\bf A{\tt ->}B}. What
is a functor from type to itself? It has two components
\begin{itemize}
\item a mapping {\bf F}, say, from {\bf Type} to {\bf Type}; that is
the object part of the functor; and
\item a mapping on functions which respects their types, so that the
image of an arrow {\bf a{\tt ->}a} is an arrow {\bf (F a){\tt ->}(F b)}.
\end{itemize}

(There are also some logical constraints on the behaviour of these
mappings; we cannot formalise these in Aldor.) How can this be
formalised in Aldor? We say
\begin{verbatim}
Functor (F ; Type -> Type) : Category == with {              (5)
  map : (a:Type) -> (b:Type) -> (a->b) -> (F a) -> (F b) };  
\end{verbatim}
and we can show that the {\bf List} functor, which builds the type
{\bf List(a)} from the type {\bf a}, is an instance of {\bf Functor}
thus: 
\begin{verbatim}
listFunctor : Functor(List) == add {                         (6)
  map (a:Type)(b:Type)(f:a->b)(x:List(a)) : List(b)
    == if x=nil then nil
                else cons ( f (first(x)),
                          (((map a) b) f) rest(x))
};
\end{verbatim}
which is the standard definition of {\bf map} over lists.

In a similar vein we can try to make {\bf idType} (as defined in
Section \ref{poll2.1} above) into an instance of {\bf Functor},
\begin{verbatim}
Ident : Functor(idType) == add {                             (7)
  map (a:Type)(b:Type)(f:a->b)(x:idType(a)) : idType(b)
    == f x
};
\end{verbatim}
but this will fail to be type correct since the types {\bf idType(a)}
and {\bf a} will not be identified as would be required for the
application of {\bf f} to {\bf x} to be well-typed.

Observe, however, that (6) does type check. This is because {\bf List}
is a constructor of types, that is the application of {\bf List(a)} is
already fully evaluated, and so there is no problem in identifying it
with other {\bf Type} expressions.

In the next section we examine possible modifications to the Aldor
type mechanism to accommodate evaluation within type expressions.

\subsection{Investigating the Aldor dependent type mechanism}
\label{poll3.2}

We are currently investigating ways in which the Aldor dependent type
mechanism can be modified to allow evaluation within type contexts as
well as within value contexts. A number of possibilities suggest
themselves. 
\begin{itemize}
\item The type system provides the {\bf pretend} conversion routine
which converts or (type) casts any type to any other type\footnote{
The {\bf pretend} function is used in the definition of
{\bf rep} and {\bf per} in the current version of Aldor; a more secure
mechanism would be preferable.}, so that one can rewrite (7) as follows
\begin{verbatim}
Ident : Functor(idType) == add {                             (8)
  map (a:Type)(b:Type)(f:a->b)(x:idType(a)) : idType(b)
    == (f (x pretend a) pretend idType(b))
};
\end{verbatim}

This achieves a result, but at some cost. Whenever we expect to need
some degree of evaluation, that has to be shadowed by a type cast;
these casts are also potentially completely unsafe.
\item Another possibility is to suggest that the system is modified to
include coercion functions which would provide conversion between type
pairs such as {\bf idType(a)} and {\bf a}. This suggestion could be
implemented but we envisage two difficulties with it.
\begin{itemize}
\item In all but the simplest of situations we will need to supply
uniformly-defined {\sl families} of coercions rather than single
coercions. This will substantially complicate an already complex
mechanism.
\item Coercions are currently not applied transitively: the effect of
this is to allow us to model single steps of evaluation but not to
take their transitive closure.
\end{itemize}
Putting these two facts together force us to conclude that effectively
mimicking the evaluation process as coercions is not a reasonable
solution to the problem at hand.
\end{itemize}

Instead of pursuing either of these solutions we are currently
investigating the possibility of performing some evaluation during
type checking. Clearly this can cause the type checker to diverge in
general, since in, for instance, an application of the form 
{\bf vectorSum(e)} an arbitrary expression {\bf e:Nat} will have to be
evaluated. We therefore intend to use current work on terminating
systems of recursion \cite{Mcal96} as well as restrictions on the
types of expression chosen for evaluation (as heuristics at least) to
guide the form of evaluation that is supported. 

\section{Logic within Aldor}
\label{poll4}

In this section we discuss the Curry-Howard isomorphism between
propositions and types, and show that it allows us to embed a logic
within the Aldor type system, if dependent types are implemented to
allow evaluation within type contexts.

\subsection{The Curry-Howard correspondence}
\label{poll4.1}

Under the Curry-Howard correspondence, logical propostions can be seen
as types, and proofs can be seen as members of these types. Accounts
of constructive type theories can be found in notes by Martin-Lof
\cite{Mart80} amongst others \cite{Nord90}\cite{Thom91}. Central to
this correspondence are dependent types, which allow the
representation of predicates and quantification. We can summarise the
correspondence in a table

\[
\begin{array}{ccc}
{\tt {\bf Programming}}         &                     & 
{\tt {\bf Logic}}\\
{\tt Type}                      &                     & 
{\tt Formula}\\
{\tt Program}                   &                     & 
{\tt Proof}\\
{\tt Product/record type}       & (...,...)           & 
{\tt Conjunction}\\
{\tt Sum/union\ type}           & \backslash/         & 
{\tt Disjunction}\\
{\tt Function\ Type}            & {\tt ->}            & 
{\tt Implication}\\
{\tt Dependent\ function\ type} & (x:A) {\tt ->} B(x) & 
{\tt Universal\ quantifier}\\
{\tt Dependent\ product\ type}  & (x:A,B(x))          & 
{\tt Existential\ quantifier}\\
{\tt Empty\ type}               & {\tt Exit}          & 
{\tt Contradictory\ proposition}\\
{\tt One\ element\ type}        & {\tt Triv}          & 
{\tt True\ proposition}\\
...                     &               & ...
\end{array}
\]

Predicates (that is dependent types) can be constructed in a number of
different ways. We look at the example of the `less than' predicate
over the natural numbers.
\begin{itemize}
\item A first approach is to give an explicit (primitive recursive)
definition of the type, which in Aldor might take the form
\begin{verbatim}
lessThan(n:Nat,m:Nat) : Type ==                              (9)
  if m=0 then Exit
         else (if n=0 then Triv
                      else lessThan(n-1,m-1));
\end{verbatim}
\item A second approach introduces them inductively as a
generalisation of the algebraic types which appear in Haskell and
SML. We might define the less than predicate `{\tt <}' of type 
{\bf Nat {\tt ->} Nat {\tt ->} Type} by saying that there are two constructors for
the type of the following signature
\begin{verbatim}
ZeroLess : (n:Nat)(0 < S n)
SuccLess : (m:Nat)(n:Nat)((m < n) -> (S m < S n))
\end{verbatim}
\end{itemize}

This approach leads to a powerful style of proof in which inductions
are performed over the form of proof objects, that is the elements of
types like {\bf (m {\tt <} n)}, rather than over (say) the natural numbers,
and such a method makes much more manageable a proof of the
transitivity of `{\tt <}' over {\bf Nat}, say. Inductive types have been
used extensively in the type theory community, see, for instance
\cite{Paul93}.

\subsection{A logic within Aldor}
\label{poll4.2}

We need to examine whether the outline given in Section \ref{poll4.1}
amounts to a proper embedding of a logic within Aldor. We shall see
that it places certain requirements on the definition and the system.

Most importantly for a definition of the form (9) to work properly as
a definition of a predicate we need an application like
{\bf lessThan(9,3)} to be reduced to {\bf Exit}, hence we need to have
evaluation of type expressions. This is a modification of Aldor which
we are currently investigating, as outlined in Section \ref{poll3}. In
the case of (9) the evaluation can be limited, since the scheme used
is recognisable as terminating by, for instance, the algorithm of
\cite{Mcal96}.

This restriction to terminating (well-founded) recursions is also
necessary for consistency of the logic. For the logic to be
consistent, we need to require that not all types are inhabited, which
is clearly related to the power of the recursion schemes allowed in
Aldor. One approach is to expect users to check this for themselves:
this has a long history, beginning with Hoare's axiomatisation of the
function in Pascal, but we would expect this to be supported with some
automated checking of termination, which ensures that partially or
totally undefined proofs are not permitted.

Consistency also depends on the strength of the type system itself; a
sufficiently powerful type system will be inconsistent as shown by
Girard's paradox \cite{Gira72}.

\section{Applications of an integrated logic}
\label{poll5}

If we identify a logic within Aldor, how can it be used? There are
various applications possible; we outline some here and for others one
can refer to the number of implementations of type theories which
already exist, including Nuprl \cite{Cons85} and Coq \cite{COQR16}.

\subsection{Pre- and Post-conditions}
\label{poll5.1}

A more expressive type system allows programmers to give more accurate
types to common functions, such as the function which indexes the
elements of a list
\begin{verbatim}
index : (l:List(t))(n:Nat)((n < length l) -> t)
\end{verbatim}

An application of {\bf index} has {\sl three} arguments: a list
{\bf l} and a natural number {\bf n} -- as for the standard index
function -- and a third argument which is of type 
{\bf (n {\tt <} length l)}, that is a {\sl proof} that {\bf n} is a
legitimate index for the list in question. This extra argument becomes
a {\bf proof obligation} which must be discharged when the function is
applied to elements {\bf l} and {\bf n}.

In a similar vein, it is possible to incorporate post-conditions into
types so that a sorting algorithm over lists might have the type
\begin{verbatim}
sort : ((l:List(t))(List(t),Sorted(l))
\end{verbatim}
and so return a sorted list together with a proof that the list is
Sorted. 

\subsection{Adding axioms to the categories of Axiom}
\label{poll5.2}

In definition (3) Section \ref{poll2.2} we give the category of
monoids, {\bf Monoid}, which introduces two operation symbols,
{\bf *} and {\bf 1}. A monoid consists not only of two operations, but
of operations with properties. We can ensure these properties hold by
extending the definition of the category to include three extra
components which are proofs that {\bf 1} is a left and right unit for
{\bf *} and that {\bf *} is associative, where we assume that 
`$\equiv$' is the identity predicate:


Monoid: Category == BasicType with \{\hspace{3.0cm} (10)\\
\hspace*{0.2cm}* : (\%,\%) {\tt ->} \%;\\
\hspace*{0.2cm}1 : \%;\\

\hspace*{0.2cm}leftUnit  : (g:\%) {\tt ->} (1*g $\equiv$ g);\\
\hspace*{0.2cm}rightUnit : (g:\%) {\tt ->} (g*1 $\equiv$ g);\\
\hspace*{0.2cm}assoc     : 
(g:\%,h:\%,j:\%) {\tt ->} ( g*(h*j) $\equiv$ (g*h)*j);\\
\}

The extension and join operations over categories will lift to become
operations of extension and join over the extended `logical'
categories such as (10).

\subsection{Different degrees of rigour}
\label{poll5.3}

One can interpret the obligations given in Sections \ref{poll5.1} and
\ref{poll5.2} with differing degrees of rigour. Using the 
{\bf pretend} function we can conjure up proofs of the logical requirements
of (10); even in this case they appear as important documentation of
requirements, and they are related to the lightweight formal methods
of \cite{Duns98}.

Alternatively we can build fully-fledged proofs as in the numerous
implementations of constructive type theories mentioned above, or we
can indeed adopt an intermediate position of proving properties seen
as `crucial' while asserting the validity of others.

\section{Conclusion}
\label{poll6}

We have proposed a new way to combine -- or rather, to integrate --
computer algebra and theorem proving. Our proposal is similar to 
\cite{Baue98} and \cite{Buch96} in that theorem proving capabilities
are incorporated in a computer algebra system. (In the classification
of possible combinations of computer algebra and theorem proving of
\cite{Calm96}, all these are instances of the ``subpackage'' approach.)
But the way in which we propose to do this is completely different; we
propose to exploit the expressiveness of the type system of Axiom,
using the Curry-Howard isomorphism that also provides the basis of
theorem provers based on type theory such as Nuprl \cite{Cons85} 
or Coq \cite{COQR16}. This provides a logic as part of the computer
algebra system. Also, having the same basis as existing provers such
as the ones mentioned above should make it easier to interface with
them. 

It is interesting to see a convergence of interests in type systems
from a number of points of view, namely
\begin{itemize}
\item computer algebra,
\item type theory and theorem provers based on type theory,
\item functional programming
\end{itemize}

For instance, there seem to be many similarities between structuring
mechanisms used in these different fields: \cite{Buch97a} argues for
functors in the sense of the programming language ML as the right tool
for structuring mathematical theories in Mathematica, and
\cite{Sant95} notes similarities between the type system of Axiom,
existential types \cite{Mitc88}, and Haskell classes
\cite{Wadl88}. More closely related to our proposal here it is
interesting to note that constructive type theorists have added
inductive types \cite{Paul93}, giving their systems a more functional
flavour, while functional programmers are showing an interest in
dependent types \cite{Augu98} and languages without non-termination
\cite{Turn95}. We see our work as part of the convergence, bringing
type-theoretic ideas together with computer algebra systems, and thus
providing a bridge between symbolic mathematics and theorem proving.

Our future work will involve investigating the type system of Aldor,
and integrating a logical approach to Aldor types; this is
complementary to recent work on formalising the Aldor system within
Coq \cite{Guil98}. We also expect to apply our work in a case study
with mathematical colleagues.

\chapter{Related Work}

This is a ``wide'' project that touches on many areas. Here we try to
collect and mention papers that we've read. A good overview of the
historical development is given in MacKenzi \cite{Mack01}.

Adams, et al ``Computer Algebra Meets Automated Theorem Proving''
\cite{Adam01}

Adams, et al. ``Automated Theorem Proving in Support of Computer
Algebra'' \cite{Adam99}

Muhammad Taimoor Khan ``Formal Specification and Verification of
Computer Algebra Software'' \cite{Khan14}

Paule, Peter ``Mathematics, Computer Science and Logic'' \cite{Paul13} 

\section{Type Theory}

\subsection{Harper \cite{Harp18}\cite{Harp18a}}

Types are Specifications of Behavior.

$A$ Type -- is a specification of behavior

$M \in A$ -- M is a program that has $A$ behavior

Both $M$ and $A$ are programs.

if(Nat,Bool)(M) is a type when M $\in$ Bool

if(17,true)(M) $\in$ if(Nat,Bool)(M)

type-indexed family of types aka dependent types

$f \in n:Nat \rightarrow Seq(n)$ is the same as
$(\Pi n : Nat.Seq(n))$

Critical Idea: Functionality. Families of types and families of
elements must respect {\sl equality} of indicies. The key question is,
``What is equality''.(eq Seq(2+2) is the ``same as'' Seq(4)). Also

Seq(if(17;18)(M)) is the ``same as'' if(Seq(17);Seq(18))(M)

if $M\doteq M^\prime \in A$ and $A\doteq A^\prime$ then
$M\doteq M^\prime \in A^\prime$ that is, if $M$ and $M^\prime$ satisfy
the specification $A$ and the specification $A$ and $A^\prime$ are
equivalent then $M$ and $M^\prime$ satisfy the specification 
$A^\prime$.

$A\Downarrow A_0$ where $A_0$ is always a final value.

$A\doteq A^\prime$ means if $A\Downarrow A_0$ and
$A^\prime\Downarrow A^\prime_0$ and 
$A_0\doteq_0 A^\prime_0$ are equal type values.

If $A$ is a type (meaning
$A\Downarrow A_0$ and $A_0\doteq_0 A_0$) then
$M\doteq M^\prime \in A$ means 
$M\Downarrow M_0$ and $M^\prime\Downarrow M_0^\prime$
and $M_0\doteq_0 M_0^\prime \in A_0$. That is, these are equal-values
in a type-value.

Functionality: $a:A >> B\doteq B^\prime$ means 
if $M\doteq M^\prime \in A$ then
$B[M/a]\doteq B^\prime[M^\prime/a]$

$a:A >> N\doteq N^\prime \in B$ means
if $M\doteq M^\prime \in A$ then
$N[M/a]\doteq N^\prime[M^\prime/a]\in B[M/a]$

\section{Other Compilers}

There are other ongoing efforts to create compilers along with an
association to proofs. 

\subsection{Hoare \cite{Hoar03}}
Tony Hoare makes a call for verifying compilers which is, as he calls
it, a ``Grand Challenge''.

\subsection{Pearce and Groves \cite{Pear15}}
Pearce and Groves created a language, called
Whiley, specifically designed to be easier to prove. 

They have a list of design decisions.
\begin{enumerate}
\item Functions are pure, whilst methods maybe impure
\item Compound data types have value (copy) semantics
\item Arithmetic is unbounded
\item All specifications are checkable at runtime
\item Type checking is separate from verification
\end{enumerate}

They introduce
keywords like {\tt requires} and {\tt ensures}. For example,
\index[doc]{requires!keyword}
\index[doc]{keyword!requires}
\index[doc]{ensures!keyword}
\index[doc]{keyword!ensures}
\begin{verbatim}
function decrement(int x) -> (int y)
// Parameter x must be greater than zero
requires x > 0
//Return must be greater or equal to zero
ensures y >= 0:
  return x - 1
\end{verbatim}

The associated verification conditions is
\[\forall x \in int.(x > 0 \Rightarrow x-1 \ge 0\]

Whiley supports loop invariants by decorating loops with a 
{\tt where} clause.
\index[doc]{where!keyword}
\index[doc]{keyword!where}
\begin{verbatim}
Function sum(int[] items) -> (int r)
// Every item in items is greater or equal to zero
requires all ( i in 0..|items| | items[i] >= 0
// Return must be greater or equal to zero
ensures r >= 0:
  int r = 0
  int i = 0
  while i < |items| where r >= 0 && i >= 0
    r = r + items[i]
    i = i + 1
  return r
\end{verbatim}

Whiley has an {\tt assert} and {\tt forall}
\index[doc]{assert!keyword}
\index[doc]{keyword!assert}
\index[doc]{forall!keyword}
\index[doc]{keyword!forall}
\begin{verbatim}
assert:
  forall(int x0, int x1):
    if:
      x0 < 0
      x1 == -x0
    then:
      x1 >= 0
\end{verbatim}

Whiley distinguishes pure code using the keyword {\tt function}
from impure code using the keyword {\tt method}.

\chapter{The Problem}
\section{A Brief History}

Axiom\cite{Daly17} is a computer algebra system. It was originally
developed at IBM Research based on a proposal by James
Griesmer\cite{Blai70a} in 1965, led to fruition by Richard
Jenks\cite{Dave84}. The project was called Scratchpad. A more complete
history is available in the online documentation.

Around this time the ideas of computational mathematics (CM) were ``in
the air''. There was the beginning of a branch of computer algebra
(CA) with developments, as descibed by Joel Moses \cite{Mose71}, like
SAINT and SIN. Anthony Hearn \cite{HEAR80} created REDUCE.

A second branch of computational mathematics was the development of
automated proof systems (PS). Early work in the area included the
idea, by Robinson \cite{Robi65}, ``resolution'', leading to
resolusion-based theorem proving. De Bruijn \cite{Brui68a} started
work on AUTOMATH.

Scratchpad grew out of the computer algebra branch of computational
mathematics. 

Though they are both areas of computational mathematics, issues such
as equality are treated differently. Davenport \cite{Dave02} addresses
the issue of equality and its several ambiguities.

Homotopy Type Theory \cite{Acze13} has the univalence axiom which
defines a form of equality based on paths. 

\section{Parallel Development}

\section{Project Goals}

Computational mathematics has had intense development efforts on both
branches. But the two branches had very little overlap. \cite{Daly18}.

Axiom was released as a free and open source project. One of the
obvious goals, based on the observation that Computer Algebra is a
sub-area of Computational Mathematics, would be to ``prove Axiom
correct''.

This goal languished for many years. There were other goals that
had higher priority. There were various attempts at discussion on the
mailing list but no action.

\section{Visiting Scholar}

Around 2014 I started reading papers in the proof systems area. This
was extremely difficult because, after so many years of independent
development, the proof community had developed a language and notation
that was opaque to the unskilled. The language of Judgments and Rules,
written in what appears to the outsider as classical greek, required a
great deal of education and training to read.

One major impediment was that all of the interesting research papers
were published in paywalled journals. A 4 page paper costs 40
dollars. I needed access to hundreds of papers. This made it nearly
impossible to do research without a University connection.

In 2015 I read a paper by Jeremy Avigad \cite{Avig12a}. Since he was
at Carnegie Mellon, where I had previously worked, I called him to
discuss his paper. It was clear we had the same mathematical ideas but
no common ground for reducing them to practice. We were from different
branches of computational mathematics.

Jeremy invited me to audit a class he was developing around the proof
system LEAN \cite{8}. While probably a frustrating experience for
Jeremy, I found the class enlightening. I finally had a glimpse of the
notation and thought process behind proof systems.

Fortunately, around the beginning of 2016, I started ``dropping onto
campus'' at Carnegie Mellon University. I sat at a hallway table in
the Computer Science department several days a week. I had hoped to
use the local network to access research papers but I needed to be an
active member of the University.

By chance, Frank Pfenning \cite{9} walked by my table on a way to a
meeting. He didn't have time to talk but said I should make an
appointment with this secretary.

I developed a ``beg cycle'' presentation about the parallel
development of computational algebra and proof systems, ending with a
request to have library access by any possible means. Frank arranged
for me to be a ``visiting scholar'', sponsored by Klaus Sutner
\cite{10}. 

Now, as a University person, I could access and read leading edge
research papers. It made all the difference.

Several professors at CMU allowed me to audit courses, including Karl
Crary \cite{11}, Frank Pfenning, Andre Platzer \cite{12}, and others. 

\section{Refining the Project Goals}

I spent a ``survey year'' reading papers in computational mathematics,
trying to understand the areas of overlap. Eventually it was clear
that the subjects were nearly disjoint. Following the bibliography of
proof system papers generated one pile. Doing the same in computer
algebra generated another pile. There was hardly a name that occurred
in both piles.

It also became clear that ``Proving Axiom Correct'' was the wrong view
of the problem. Axiom had no global specification and without that it
made no sense to talk about ``Correct''. 

By 2018 I refined Axiom's project goals. The new goal was to ``Prove
Axiom Sane''. Sane's thesaurus lists synonyms like ``rational'',
``coherent'', ``judicious'', and ``sound'', all words used by the
proof system researchers. 

``Proving Axiom Sane'', the crossover project goal of uniting computer
algebra and proof systems, was the theme originally presented to Frank
Pfenning. It was now refined into a talk given at the International
Conference on Mathematics Software \cite{10} in August of 2018.

\section{Reduction to Practice}

By late 2018 the project goal was more specific. The goal was now
limited to the proving the many Greatest Common Divisor (GCD)
implementations in Axiom correct. There are GCD algorithms for
non-negative integers and GCD algorithms for things like
polynomials. Clearly there was a specific specifications for these
instances. There is also a specification of the general GCD algorithm,
so the notion of correctness made sense.

But there was the question of automation. Axiom needed a language to
express the specifications. It needed a language to express the
semantics of the implementation of GCD. It needed axioms that
expressed the properties of statements in the specification, such as
the commutativity axiom. It needed to hierarchically ``gather'' axioms
that apply from the type hierarchy (called Categories in Axiom) as
well as axioms specific to the instance (called a Domain in Axiom).

Beyond the language, Axiom needed a way to create and manipulate the
associated proofs. It needed a means to access existing proof systems
to carry out the verification of the proof correctness. The compiler
needs access to a proof checker to validate the proof at compile time.

There was much to be done.

\section{Subgoal: A new implementation}

Axiom is a large (about 1.2 million line) system implemented in Common
Lisp. The code base grew ``by accretion'', originally from a MacLisp
\cite{11} base, ported to Lisp/VM \cite{Dave85}, and then ported to Common
Lisp \cite{Stee90}. Since it was born as a research project there was no
real effort to make it into a ``product'' until it was sold to The
Numerical Algorithms Group (NAG) \cite{IBMx91}.

The net result is that the original code base was not really a good
foundation for full computational mathematics. But Axiom has several
thousand working functions, many derived from PhD thesis work, that
could not practically be duplicated from scratch.

So the first step toward a Sane Axiom system would be to restructure
the compiler and interpreter ``from the ground up'' with the
requirement that it could execute the existing algorithms.

After much pondering, the design decision would be to use the Common
Lisp Object System (CLOS) \cite{15} as the new basis for Axiom.

One reason for this choice is that the base is still Common Lisp so it
would be possible to reuse existing pieces of code.

Another reason is the CLOS objects are considered ``types'' so they
could be used in the proof system style of type checking. This gives a
way to introduce type checking at the Lisp level, below the Axiom
Category and Domain abstraction. It also gives a firm basis for
reasoning about dependent types.

\chapter{An Inside-Out Approach}

The traditional approach to compiler development starts with a BNF
\cite{16} definition of the language syntax, followed by an
intermediate representation, and then one of several ``back end''
implementations of the runtime.

Instead, a new approach evolved. It would be possible to re-cast the
Axiom Category and Domain hierarchy as CLOS types. Furthermore, since
the CLOS types are automatically checked for precedence at compile
time, problems in inheritance are caught early.

CLOS classes can be hand-written. This means that the usual
intermediate compiler language could actually be read, constructed,
and modified by hand. 

Constructing Axiom in CLOS ``from the inside'' means that the surface
syntax of Axiom, called Spad (short for Scratchpad), could be created
later with the clear target of a working intermediate.

Since the intermediate CLOS code needed to support the surface
language it should be possible to automatically create the surface
language from the CLOS. That makes it clear that the surface language
was fully supported by the CLOS implementation.

It also means that the traditional parser could be developed later in
the project with a very clear target language that fully supports all
of the surface language features.

\section{NonNegativeInteger ancestors}

This is a large project. In order to limit the scope of the initial
problem we will focus on the GCD algorithm in NonNegativeInteger.

This implies that several other categories have to be handled. In
particular these are given by the {\tt getAncestors} function.
\begin{verbatim}
getAncestors 'NonNegativeInteger

   (1)
   {AbelianMonoid, AbelianSemiGroup, BasicType, CancellationAbelianMonoid,
    CoercibleTo, Monoid, OrderedAbelianMonoid, OrderedAbelianMonoidSup,
    OrderedAbelianSemiGroup, OrderedCancellationAbelianMonoid, OrderedSet,
    SemiGroup, SetCategory}
                                                            Type: Set(Symbol)
\end{verbatim}

If we call {\tt getAncestors} on each of the items in the list we can
find the inheritance order, which is
\begin{verbatim}
BasicType <- {}
CoercibleTo <- {}
SetCategory <- BasicType,CoercibleTo
OrderedSet <- BasicType,CoercibleTo,SetCategory
SemiGroup <- BasicType,CoercibleTo,SetCategory
Monoid <- BasicType,CoercibleTo,SetCategory,SemiGroup
AbelianSemiGroup <- BasicType,CoercibleTo,SetCategory
AbelianMonoid <- BasicType,CoercibleTo,SetCategory,AbelianSemiGroup
CancellationAbelianMonoid <- AbelianMonoid,AbelianSemiGroup,BasicType,CoercibleTo,SetCategory
OrderedAbelianSemiGroup <- AbelianSemiGroup,BasicType,CoercibleTo,OrderedSet,SetCategory
OrderedAbelianMonoid <- AbelianMonoid, AbelianSemiGroup, BasicType, CoercibleTo,
    OrderedAbelianSemiGroup, OrderedSet, SetCategory
OrderedCancellationAbelianMonoid <- AbelianMonoid, AbelianSemiGroup, BasicType, CancellationAbelianMonoid,
    CoercibleTo, OrderedAbelianMonoid, OrderedAbelianSemiGroup, OrderedSet,
    SetCategory
OrderedAbelianMonoidSup <- AbelianMonoid, AbelianSemiGroup, BasicType, CancellationAbelianMonoid,
    CoercibleTo, OrderedAbelianMonoid, OrderedAbelianSemiGroup,
    OrderedCancellationAbelianMonoid, OrderedSet, SetCategory
NonNegativeInteger <- AbelianMonoid, AbelianSemiGroup, BasicType, CancellationAbelianMonoid,
    CoercibleTo, Monoid, OrderedAbelianMonoid, OrderedAbelianMonoidSup,
    OrderedAbelianSemiGroup, OrderedCancellationAbelianMonoid, OrderedSet,
    SemiGroup, SetCategory}
\end{verbatim}

The sorted order above is not the actual order needed. Let us look at
each category in more detail.

\begin{itemize}
\item BasicType {\tt <-} \{\}
\item CoercibleTo {\tt <-} \{\}
\item SetCategory {\tt <-} BasicType, CoercibleTo
\item OrderedSet {\tt <-} SetCategory
\item SemiGroup {\tt <-} SetCategory
\item Monoid {\tt <-} SemiGroup
\item AbelianSemiGroup {\tt <-} SetCategory
\item AbelianMonoid {\tt <-} AbelianSemiGroup
\item CancellationAbelianMonoid {\tt <-} AbelianMonoid
\item OrderedAbelianSemiGroup {\tt <-} AbelianSemiGroup, OrderedSet
\item OrderedAbelianMonoid {\tt <-} AbelianMonoid, OrderedAbelianSemiGroup
\item OrderedCancellationAbelianMonoid {\tt <-} CancellationAbelianMonoid,
OrderedAbelianMonoid
\item OrderedAbelianMonoidSup {\tt <-} OrderedCancellationAbelianMonoid
\item NonNegativeInteger {\tt <-} Monoid, OrderedAbelianMonoidSup
\end{itemize}

\begin{center}
\begin{tikzpicture}[node distance=1.75cm]

\node[terminal]                   (BASTYPE) {BASTYPE};
\node[right of=BASTYPE,terminal]  (KOERCE)  {KOERCE};
\node[below of=KOERCE, terminal]  (SETCAT)  {SETCAT};
\node[below of=SETCAT, terminal]  (ABELSG)  {ABELSG};
\node[below of=ABELSG, terminal]  (ABELMON) {ABELMON};
\node[below of=ABELMON, terminal] (CABMON)  {CABMON};
\node[below of=CABMON, terminal]  (OCAMON)  {OCAMON};
\node[below of=OCAMON, terminal]  (OAMONS)  {OAMONS};
\node[below of=OAMONS, terminal]  (NNI)     {NNI};
\node[left of=ABELSG, terminal]   (ORDSET)  {ORDSET};
\node[right of=ABELSG, terminal]  (SGROUP)  {SGROUP};
\node[right of=NNI, terminal]     (MONOID)  {MONOID};
\node[left of=ABELMON, terminal]  (OASGP)   {OASGP};
\node[left of=CABMON, terminal]   (OAMON)   {OAMON};

\draw

(BASTYPE) edge (SETCAT)
(KOERCE)  edge (SETCAT)
(SETCAT)  edge (ORDSET)
(SETCAT)  edge (ABELSG)
(SETCAT)  edge (SGROUP)
(ABELSG)  edge (ABELMON)
(ABELMON) edge (CABMON)
(CABMON)  edge (OCAMON)
(OCAMON)  edge (OAMONS)
(OAMONS)  edge (NNI)
(SGROUP)  edge (MONOID)
(MONOID)  edge (NNI)
(ORDSET)  edge (OASGP)
(ABELSG)  edge (OASGP)
(OASGP)   edge (OAMON)
(ABELMON) edge (OAMON)
(OAMON)   edge (OCAMON);

\end{tikzpicture}
\end{center}
We need to parse each of these and create the internal data structures
that support NonNegativeInteger.

\subsection{BasicType}

\subsubsection{The original source code}
\begin{verbatim}
BasicType() : Category == SIG where

  SIG ==> with

    "=" : (%,%) -> Boolean
      ++ x=y tests if x and y are equal.

    "~=" : (%,%) -> Boolean   
      ++ x~=y tests if x and y are not equal.

   add

     _~_=(x:%,y:%) : Boolean == not(x=y)
\end{verbatim}

\subsubsection{The operations}
\begin{verbatim}
 BasicType is a category constructor
 Abbreviation for BasicType is BASTYPE 
 This constructor is exposed in this frame.
 Issue )edit bookvol10.2.pamphlet to see algebra source code for BASTYPE 

------------------------------- Operations --------------------------------
 ?=? : (%,%) -> Boolean                ?~=? : (%,%) -> Boolean

\end{verbatim}

\subsection{CoercibleTo}

\subsubsection{The original source code}
\begin{verbatim}
CoercibleTo(S) : Category == SIG where
  S : Type

  SIG ==> with

    coerce : % -> S
      ++ coerce(a) transforms a into an element of S.
\end{verbatim}

\subsubsection{The operations}
\begin{verbatim}
 CoercibleTo(S: Type) is a category constructor
 Abbreviation for CoercibleTo is KOERCE 
 This constructor is exposed in this frame.
 Issue )edit bookvol10.2.pamphlet to see algebra source code for KOERCE 

------------------------------- Operations --------------------------------
 coerce : % -> S                      

\end{verbatim}

\subsection{OutputForm}

\subsubsection{The original source code}
\begin{verbatim}
OutputForm() : SIG == CODE where

  SIG ==> SetCategory with

    print : $ -> Void
      ++ print(u) prints the form u.

    message : String -> $
      ++ message(s) creates an form with no string quotes
      ++ from string s.

    messagePrint : String -> Void
      ++ messagePrint(s) prints s without string quotes. Note:
      ++ \spad{messagePrint(s)} is equivalent to \spad{print message(s)}.

    --% Creation of atomic forms

    outputForm : Integer -> $
      ++ outputForm(n) creates an form for integer n.

    outputForm : Symbol  -> $
      ++ outputForm(s) creates an form for symbol s.

    outputForm : String  -> $
      ++ outputForm(s) creates an form for string s.

    outputForm : DoubleFloat  -> $
      ++ outputForm(sf) creates an form for small float sf.

    empty : () -> $
      ++ empty() creates an empty form.

        --% Sizings

    width : $ -> Integer
      ++ width(f) returns the width of form f (an integer).

    height : $ -> Integer
      ++ height(f) returns the height of form f (an integer).

    width : -> Integer
      ++ width() returns the width of the display area (an integer).

    height : -> Integer
      ++ height() returns the height of the display area (an integer).

    subHeight : $ -> Integer
      ++ subHeight(f) returns the height of form f below the base line.

    superHeight : $ -> Integer
      ++ superHeight(f) returns the height of form f above the base line.

         --% Space manipulations

    hspace : Integer -> $
      ++ hspace(n) creates white space of width n.
      
    vspace : Integer -> $
      ++ vspace(n) creates white space of height n.

    rspace : (Integer,Integer) -> $
      ++ rspace(n,m) creates rectangular white space, n wide by m high.

        --% Area adjustments

    left : ($,Integer) -> $
      ++ left(f,n) left-justifies form f within space of width n.

    right : ($,Integer) -> $
      ++ right(f,n) right-justifies form f within space of width n.

    center : ($,Integer) -> $
      ++ center(f,n) centers form f within space of width n.

    left : $ -> $
      ++ left(f) left-justifies form f in total space.

    right : $ -> $
      ++ right(f) right-justifies form f in total space.

    center : $ -> $
      ++ center(f) centers form f in total space.

        --% Area manipulations

    hconcat : ($,$) -> $
      ++ hconcat(f,g) horizontally concatenate forms f and g.

    vconcat : ($,$) -> $
      ++ vconcat(f,g) vertically concatenates forms f and g.

    hconcat : List $ -> $
      ++ hconcat(u) horizontally concatenates all forms in list u.

    vconcat : List $ -> $
      ++ vconcat(u) vertically concatenates all forms in list u.

        --% Application formers

    prefix : ($, List $) -> $
      ++ prefix(f,l) creates a form depicting the n-ary prefix
      ++ application of f to a tuple of arguments given by list l.

    infix : ($, List $) -> $
      ++ infix(f,l) creates a form depicting the n-ary application
      ++ of infix operation f to a tuple of arguments l.

    infix : ($, $, $) -> $
      ++ infix(op, a, b) creates a form which prints as: a op b.

    postfix : ($, $)    -> $
      ++ postfix(op, a)  creates a form which prints as: a op.

    infix? : $ -> Boolean
      ++ infix?(op) returns true if op is an infix operator,
      ++ and false otherwise.

    elt : ($, List $) -> $
      ++ elt(op,l) creates a form for application of op
      ++ to list of arguments l.

        --% Special forms

    string : $ -> $
      ++ string(f) creates f with string quotes.

    label : ($, $) -> $
      ++ label(n,f) gives form f an equation label n.

    box : $ -> $
      ++ box(f) encloses f in a box.

    matrix : List List $ -> $
      ++ matrix(llf) makes llf (a list of lists of forms) into
      ++ a form which displays as a matrix.

    zag : ($, $) -> $
      ++ zag(f,g) creates a form for the continued fraction form for f over g.

    root : $ -> $
      ++ root(f) creates a form for the square root of form f.

    root : ($, $) -> $
      ++ root(f,n) creates a form for the nth root of form f.

    over : ($, $) -> $
      ++ over(f,g) creates a form for the vertical fraction of f over g.

    slash : ($, $) -> $
      ++ slash(f,g) creates a form for the horizontal fraction of f over g.

    assign : ($, $) -> $
      ++ assign(f,g) creates a form for the assignment \spad{f := g}.

    rarrow : ($, $) -> $
      ++ rarrow(f,g) creates a form for the mapping \spad{f -> g}.

    differentiate : ($, NonNegativeInteger) -> $
      ++ differentiate(f,n) creates a form for the nth derivative of f,
      ++ for example, \spad{f'}, \spad{f''}, \spad{f'''},
      ++ "f super \spad{iv}".

    binomial : ($, $) -> $
      ++ binomial(n,m) creates a form for the binomial coefficient of n and m.

        --% Scripts

    sub : ($, $) -> $
      ++ sub(f,n) creates a form for f subscripted by n.

    super : ($, $) -> $
      ++ super(f,n) creates a form for f superscripted by n.

    presub : ($, $) -> $
      ++ presub(f,n) creates a form for f presubscripted by n.

    presuper : ($, $) -> $
      ++ presuper(f,n) creates a form for f presuperscripted by n.

    scripts : ($, List $) -> $
      ++ \spad{scripts(f, [sub, super, presuper, presub])}
      ++  creates a form for f with scripts on all 4 corners.

    supersub : ($, List $) -> $
      ++ supersub(a,[sub1,super1,sub2,super2,...])
      ++ creates a form with each subscript aligned
      ++ under each superscript.

        --% Diacritical marks

    quote : $ -> $
      ++ quote(f) creates the form f with a prefix quote.

    dot : $ -> $
      ++ dot(f) creates the form with a one dot overhead.

    dot : ($, NonNegativeInteger) -> $
      ++ dot(f,n) creates the form f with n dots overhead.

    prime : $ -> $
      ++ prime(f) creates the form f followed by a suffix prime (single quote).

    prime : ($, NonNegativeInteger) -> $
      ++ prime(f,n) creates the form f followed by n primes.

    overbar : $ -> $
      ++ overbar(f) creates the form f with an overbar.

    overlabel : ($, $) -> $
      ++ overlabel(x,f) creates the form f with "x overbar" over the top.

        --% Plexes

    sum : ($) -> $
      ++ sum(expr) creates the form prefixing expr by a capital sigma.

    sum : ($, $) -> $
      ++ sum(expr,lowerlimit) creates the form prefixing expr by
      ++ a capital sigma with a lowerlimit.

    sum : ($, $, $) -> $
      ++ sum(expr,lowerlimit,upperlimit) creates the form prefixing expr by
      ++ a capital sigma with both a lowerlimit and upperlimit.

    prod : ($) -> $
      ++ prod(expr) creates the form prefixing expr by a capital pi.

    prod : ($, $) -> $
      ++ prod(expr,lowerlimit) creates the form prefixing expr by
      ++ a capital pi with a lowerlimit.

    prod : ($, $, $) -> $
      ++ prod(expr,lowerlimit,upperlimit) creates the form prefixing expr by
      ++ a capital pi with both a lowerlimit and upperlimit.

    int : ($) -> $
      ++ int(expr) creates the form prefixing expr with an integral sign.

    int : ($, $) -> $
      ++ int(expr,lowerlimit) creates the form prefixing expr by an
      ++ integral sign with a lowerlimit.

    int : ($, $, $) -> $
      ++ int(expr,lowerlimit,upperlimit) creates the form prefixing expr by
      ++ an integral sign with both a lowerlimit and upperlimit.

        --% Matchfix forms

    brace : $ -> $
      ++ brace(f) creates the form enclosing f in braces (curly brackets).

    brace : List $ -> $
      ++ brace(lf) creates the form separating the elements of lf
      ++ by commas and encloses the result in curly brackets.

    bracket : $ -> $
      ++ bracket(f) creates the form enclosing f in square brackets.

    bracket : List $ -> $
      ++ bracket(lf) creates the form separating the elements of lf
      ++ by commas and encloses the result in square brackets.

    paren : $ -> $
      ++ paren(f) creates the form enclosing f in parentheses.

    paren : List $ -> $
      ++ paren(lf) creates the form separating the elements of lf
      ++ by commas and encloses the result in parentheses.

        --% Separators for aggregates

    pile : List $ -> $
      ++ pile(l) creates the form consisting of the elements of l which
      ++ displays as a pile, the elements begin on a new line and
      ++ are indented right to the same margin.

    commaSeparate : List $ -> $
      ++ commaSeparate(l) creates the form separating the elements of l
      ++ by commas.

    semicolonSeparate :  List $ -> $
      ++ semicolonSeparate(l) creates the form separating the elements of l
      ++ by semicolons.

    blankSeparate : List $ -> $
      ++ blankSeparate(l) creates the form separating the elements of l
      ++ by blanks.

        --% Specific applications

    "=" : ($, $) -> $
      ++ f = g creates the equivalent infix form.

    "^=" : ($, $) -> $
      ++ f ^= g creates the equivalent infix form.

    "<" : ($, $) -> $
      ++ f < g creates the equivalent infix form.

    ">" : ($, $) -> $
      ++ f > g creates the equivalent infix form.

    "<=" : ($, $) -> $
      ++ f <= g creates the equivalent infix form.

    ">=" : ($, $) -> $
      ++ f >= g creates the equivalent infix form.

    "+" : ($, $) -> $
      ++ f + g creates the equivalent infix form.

    "-" : ($, $) -> $
      ++ f - g creates the equivalent infix form.

    "-" : ($) -> $
      ++ - f creates the equivalent prefix form.

    "*" : ($, $) -> $
      ++ f * g creates the equivalent infix form.

    "/" : ($, $) -> $
      ++ f / g creates the equivalent infix form.

    "**" : ($, $) -> $
      ++ f ** g creates the equivalent infix form.

    "div" : ($, $) -> $
      ++ f div g creates the equivalent infix form.

    "rem" : ($, $) -> $
      ++ f rem g creates the equivalent infix form.

    "quo" : ($, $) -> $
      ++ f quo g creates the equivalent infix form.

    "exquo" : ($, $) -> $
      ++ exquo(f,g) creates the equivalent infix form.

    "and" : ($, $) -> $
      ++ f and g creates the equivalent infix form.

    "or" : ($, $) -> $
      ++ f or g creates the equivalent infix form.

    "not" : ($) -> $
      ++ not f creates the equivalent prefix form.

    SEGMENT : ($,$) -> $
      ++ SEGMENT(x,y) creates the infix form: \spad{x..y}.

    SEGMENT : ($) -> $
      ++ SEGMENT(x) creates the prefix form: \spad{x..}.

  CODE ==> add

        import NumberFormats

        -- Todo:
        --   program forms, greek letters
        --   infix, prefix, postfix, matchfix support in OUT BOOT
        --   labove rabove, corresponding overs.
        --   better super script, overmark, undermark
        --   bug in product, paren blankSeparate []
        --   uniformize integrals, products, etc as plexes.

        cons ==> CONS$Lisp

        car  ==> CAR$Lisp

        cdr  ==> CDR$Lisp

        Rep := List $

        a, b: $

        l: List $

        s: String

        e: Symbol

        n: Integer

        nn:NonNegativeInteger

        sform:    String  -> $

        eform:    Symbol  -> $

        iform:    Integer -> $

        print x              == mathprint(x)$Lisp

        message s            == (empty? s => empty(); s pretend $)

        messagePrint s       == print message s

        (a:$ = b:$):Boolean  == EQUAL(a, b)$Lisp

        (a:$ = b:$):$        == [sform "=",     a, b]

        coerce(a):OutputForm  == a pretend OutputForm

        outputForm n          == n pretend $

        outputForm e          == e pretend $

        outputForm(f:DoubleFloat) == f pretend $

        sform s               == s pretend $

        eform e               == e pretend $

        iform n               == n pretend $

        outputForm s ==
          sform concat(quote()$Character, concat(s, quote()$Character))

        width(a) == outformWidth(a)$Lisp

        height(a) == height(a)$Lisp

        subHeight(a) == subspan(a)$Lisp

        superHeight(a) == superspan(a)$Lisp

        height() == 20

        width() == 66

        center(a,w)   == hconcat(hspace((w - width(a)) quo 2),a)

        left(a,w)     == hconcat(a,hspace((w - width(a))))

        right(a,w)    == hconcat(hspace(w - width(a)),a)

        center(a)     == center(a,width())

        left(a)       == left(a,width())

        right(a)      == right(a,width())

        vspace(n) ==
          n = 0 => empty()
          vconcat(sform " ",vspace(n - 1))

        hspace(n) ==
          n = 0 => empty()
          sform(fillerSpaces(n)$Lisp)

        rspace(n, m) ==
          n = 0 or m = 0 => empty()
          vconcat(hspace n, rspace(n, m - 1))

        matrix ll ==
            lv:$ := [LIST2VEC$Lisp l for l in ll]
            CONS(eform MATRIX, LIST2VEC$Lisp lv)$Lisp

        pile l              == cons(eform SC, l)

        commaSeparate l     == cons(eform AGGLST,  l)

        semicolonSeparate l == cons(eform AGGSET,  l)

        blankSeparate l     ==
           c:=eform CONCATB
           l1:$:=[]
           for u in reverse l repeat
               if EQCAR(u,c)$Lisp
                  then l1:=[:cdr u,:l1]
                  else l1:=[u,:l1]
           cons(c, l1)

        brace a        == [eform BRACE,   a]

        brace l        == brace commaSeparate l

        bracket a      == [eform BRACKET, a]

        bracket l      == bracket commaSeparate l

        paren a        == [eform PAREN,   a]

        paren l        == paren commaSeparate l

        sub     (a,b)  == [eform SUB, a, b]

        super   (a, b) == [eform SUPERSUB,a,sform " ",b]

        presub(a,b) == [eform SUPERSUB,a,sform " ",sform " ",sform " ",b]

        presuper(a, b) == [eform SUPERSUB,a,sform " ",sform " ",b]

        scripts (a, l) ==
            null l => a
            null rest l => sub(a, first l)
            cons(eform SUPERSUB, cons(a, l))

        supersub(a, l) ==
            if odd?(#l) then l := append(l, [empty()])
            cons(eform ALTSUPERSUB, cons(a, l))

        hconcat(a,b)  == [eform CONCAT, a, b]

        hconcat l     == cons(eform CONCAT, l)

        vconcat(a,b)  == [eform VCONCAT, a, b]

        vconcat l     == cons(eform VCONCAT, l)

        a ^= b      == [sform "^=",    a, b]

        a < b       == [sform "<",     a, b]

        a > b       == [sform ">",     a, b]

        a <= b      == [sform "<=",    a, b]

        a >= b      == [sform ">=",    a, b]

        a + b       == [sform "+",     a, b]

        a - b       == [sform "-",     a, b]

        - a         == [sform "-",     a]

        a * b       == [sform "*",     a, b]

        a / b       == [sform "/",     a, b]

        a ** b      == [sform "**",    a, b]

        a div b     == [sform "div",   a, b]

        a rem b     == [sform "rem",   a, b]

        a quo b     == [sform "quo",   a, b]

        a exquo b   == [sform "exquo", a, b]

        a and b     == [sform "and",   a, b]

        a or b      == [sform "or",    a, b]

        not a       == [sform "not",   a]

        SEGMENT(a,b)== [eform SEGMENT, a, b]

        SEGMENT(a)  == [eform SEGMENT, a]

        binomial(a,b)==[eform BINOMIAL, a, b]

        empty() == [eform NOTHING]

        infix? a ==
            e:$ :=
                IDENTP$Lisp a => a
                STRINGP$Lisp a => INTERN$Lisp a
                return false
            if GET(e,QUOTE(INFIXOP$Lisp)$Lisp)$Lisp then true else false

        elt(a, l) ==
            cons(a, l)

        prefix(a,l)   ==
            not infix? a => cons(a, l)
            hconcat(a, paren commaSeparate l)

        infix(a, l) ==
            null l => empty()
            null rest l => first l
            infix? a => cons(a, l)
            hconcat [first l, a, infix(a, rest l)]

        infix(a,b,c)  ==
            infix? a => [a, b, c]
            hconcat [b, a, c]

        postfix(a, b) ==
            hconcat(b, a)

        string a   == [eform STRING,  a]

        quote  a   == [eform QUOTE,   a]

        overbar a  == [eform OVERBAR, a]

        dot a      == super(a, sform ".")

        prime a    == super(a, sform ",")

        dot(a,nn)   == (s := new(nn, char "."); super(a, sform s))

        prime(a,nn) == (s := new(nn, char ","); super(a, sform s))

        overlabel(a,b) == [eform OVERLABEL, a, b]

        box a      == [eform BOX,     a]

        zag(a,b)   == [eform ZAG,     a, b]

        root a     == [eform ROOT,    a]

        root(a,b)  == [eform ROOT,    a, b]

        over(a,b)  == [eform OVER,    a, b]

        slash(a,b) == [eform SLASH,   a, b]

        assign(a,b)== [eform LET,     a, b]

        label(a,b) == [eform EQUATNUM, a, b]

        rarrow(a,b)== [eform TAG, a, b]

        differentiate(a, nn)==
            zero? nn => a
            nn < 4 => prime(a, nn)
            r := FormatRoman(nn::PositiveInteger)
            s := lowerCase(r::String)
            super(a, paren sform s)

        sum(a)     == [eform SIGMA,  empty(), a]

        sum(a,b)   == [eform SIGMA,  b, a]

        sum(a,b,c) == [eform SIGMA2, b, c, a]

        prod(a)    == [eform PI,     empty(), a]

        prod(a,b)  == [eform PI,     b, a]

        prod(a,b,c)== [eform PI2,    b, c, a]

        int(a)     == [eform INTSIGN,empty(), empty(), a]

        int(a,b)   == [eform INTSIGN,b, empty(), a]

        int(a,b,c) == [eform INTSIGN,b, c, a]
\end{verbatim}

\subsubsection{The operations}
\begin{verbatim}
 OutputForm is a domain constructor
 Abbreviation for OutputForm is OUTFORM 
 This constructor is not exposed in this frame.
 Issue )edit bookvol10.3.pamphlet to see algebra source code for OUTFORM 

------------------------------- Operations --------------------------------
 ?*? : (%,%) -> %                      ?**? : (%,%) -> %
 ?+? : (%,%) -> %                      -? : % -> %
 ?-? : (%,%) -> %                      ?/? : (%,%) -> %
 ?<? : (%,%) -> %                      ?<=? : (%,%) -> %
 ?=? : (%,%) -> %                      ?=? : (%,%) -> Boolean
 ?>? : (%,%) -> %                      ?>=? : (%,%) -> %
 ?SEGMENT : % -> %                     ?..? : (%,%) -> %
 ?^=? : (%,%) -> %                     ?and? : (%,%) -> %
 assign : (%,%) -> %                   binomial : (%,%) -> %
 blankSeparate : List(%) -> %          box : % -> %
 brace : List(%) -> %                  brace : % -> %
 bracket : List(%) -> %                bracket : % -> %
 center : % -> %                       center : (%,Integer) -> %
 coerce : % -> OutputForm              commaSeparate : List(%) -> %
 ?div? : (%,%) -> %                    dot : (%,NonNegativeInteger) -> %
 dot : % -> %                          ?.? : (%,List(%)) -> %
 empty : () -> %                       exquo : (%,%) -> %
 hash : % -> SingleInteger             hconcat : List(%) -> %
 hconcat : (%,%) -> %                  height : () -> Integer
 height : % -> Integer                 hspace : Integer -> %
 infix : (%,%,%) -> %                  infix : (%,List(%)) -> %
 infix? : % -> Boolean                 int : (%,%,%) -> %
 int : (%,%) -> %                      int : % -> %
 label : (%,%) -> %                    latex : % -> String
 left : % -> %                         left : (%,Integer) -> %
 matrix : List(List(%)) -> %           message : String -> %
 messagePrint : String -> Void         not? : % -> %
 ?or? : (%,%) -> %                     outputForm : DoubleFloat -> %
 outputForm : String -> %              outputForm : Symbol -> %
 outputForm : Integer -> %             over : (%,%) -> %
 overbar : % -> %                      overlabel : (%,%) -> %
 paren : List(%) -> %                  paren : % -> %
 pile : List(%) -> %                   postfix : (%,%) -> %
 prefix : (%,List(%)) -> %             presub : (%,%) -> %
 presuper : (%,%) -> %                 prime : % -> %
 print : % -> Void                     prod : (%,%,%) -> %
 prod : (%,%) -> %                     prod : % -> %
 ?quo? : (%,%) -> %                    quote : % -> %
 rarrow : (%,%) -> %                   ?rem? : (%,%) -> %
 right : % -> %                        right : (%,Integer) -> %
 root : (%,%) -> %                     root : % -> %
 rspace : (Integer,Integer) -> %       scripts : (%,List(%)) -> %
 semicolonSeparate : List(%) -> %      slash : (%,%) -> %
 string : % -> %                       sub : (%,%) -> %
 subHeight : % -> Integer              sum : (%,%,%) -> %
 sum : (%,%) -> %                      sum : % -> %
 super : (%,%) -> %                    superHeight : % -> Integer
 supersub : (%,List(%)) -> %           vconcat : List(%) -> %
 vconcat : (%,%) -> %                  vspace : Integer -> %
 width : () -> Integer                 width : % -> Integer
 zag : (%,%) -> %                      ?~=? : (%,%) -> Boolean
 differentiate : (%,NonNegativeInteger) -> %
 prime : (%,NonNegativeInteger) -> %

\end{verbatim}

\subsection{SetCategory}
\subsubsection{The original source code}
\begin{verbatim}
SetCategory() : Category == SIG where

  SIG ==> Join(BasicType,CoercibleTo OutputForm) with

    hash : % -> SingleInteger  
      ++ hash(s) calculates a hash code for s.
  
    latex : % -> String       
      ++ latex(s) returns a LaTeX-printable output representation of s.

   add

      hash(s : %):  SingleInteger == SXHASH(s)$Lisp

      latex(s : %): String == "\mbox{\bf Unimplemented}"
\end{verbatim}

\subsubsection{The operations}
\begin{verbatim}
 SetCategory is a category constructor
 Abbreviation for SetCategory is SETCAT 
 This constructor is exposed in this frame.
 Issue )edit bookvol10.2.pamphlet to see algebra source code for SETCAT 

------------------------------- Operations --------------------------------
 ?=? : (%,%) -> Boolean                coerce : % -> OutputForm
 hash : % -> SingleInteger             latex : % -> String
 ?~=? : (%,%) -> Boolean              

\end{verbatim}

\subsection{SemiGroup}

\subsubsection{The original source code}
\begin{verbatim}
SemiGroup() : Category == SIG where

  SIG ==> SetCategory with

    "*" : (%,%) -> %                  
      ++ x*y returns the product of x and y.

    "**" : (%,PositiveInteger) -> %   
      ++ x**n returns the repeated product of x n times, exponentiation.

    "^" : (%,PositiveInteger) -> %    
      ++ x^n returns the repeated product of x n times, exponentiation.

   add

     import RepeatedSquaring(%)

     x:% ** n:PositiveInteger == expt(x,n)

     _^(x:%, n:PositiveInteger):% == x ** n
\end{verbatim}

\subsubsection{The operations}
\begin{verbatim}
 SemiGroup is a category constructor
 Abbreviation for SemiGroup is SGROUP 
 This constructor is exposed in this frame.
 Issue )edit bookvol10.2.pamphlet to see algebra source code for SGROUP 

------------------------------- Operations --------------------------------
 ?*? : (%,%) -> %                      ?**? : (%,PositiveInteger) -> %
 ?=? : (%,%) -> Boolean                ?^? : (%,PositiveInteger) -> %
 coerce : % -> OutputForm              hash : % -> SingleInteger
 latex : % -> String                   ?~=? : (%,%) -> Boolean

\end{verbatim}

\subsection{OrderedSet}

\subsubsection{The original source code}
\begin{verbatim}
OrderedSet() : Category == SIG where

  SIG ==> SetCategory with

    "<" : (%,%) -> Boolean
      ++ x < y is a strict total ordering on the elements of the set.

    ">" : (%, %) -> Boolean
      ++ x > y is a greater than test.

    ">=" : (%, %) -> Boolean
      ++ x >= y is a greater than or equal test.

    "<=" : (%, %) -> Boolean
      ++ x <= y is a less than or equal test.

    max : (%,%) -> %
      ++ max(x,y) returns the maximum of x and y relative to "<".

    min : (%,%) -> %
      ++ min(x,y) returns the minimum of x and y relative to "<".

   add

      x,y: %
  
      -- These really ought to become some sort of macro
  
      max(x,y) ==
        x > y => x
        y
  
      min(x,y) ==
        x > y => y
        x
  
      ((x: %) >  (y: %)) : Boolean == y < x
  
      ((x: %) >= (y: %)) : Boolean == not (x < y)
  
      ((x: %) <= (y: %)) : Boolean == not (y < x)
\end{verbatim}

\subsubsection{The operations}
\begin{verbatim}
 OrderedSet is a category constructor
 Abbreviation for OrderedSet is ORDSET 
 This constructor is exposed in this frame.
 Issue )edit bookvol10.2.pamphlet to see algebra source code for ORDSET 

------------------------------- Operations --------------------------------
 ?<? : (%,%) -> Boolean                ?<=? : (%,%) -> Boolean
 ?=? : (%,%) -> Boolean                ?>? : (%,%) -> Boolean
 ?>=? : (%,%) -> Boolean               coerce : % -> OutputForm
 hash : % -> SingleInteger             latex : % -> String
 max : (%,%) -> %                      min : (%,%) -> %
 ?~=? : (%,%) -> Boolean              

\end{verbatim}

\subsection{OrderedCancellationAbelianMonoid}

\subsubsection{The original source code}
\begin{verbatim}
OrderedCancellationAbelianMonoid() : Category == SIG where

  SIG ==> Join(OrderedAbelianMonoid, CancellationAbelianMonoid)
\end{verbatim}

\subsubsection{The operations}
\begin{verbatim}
 OrderedCancellationAbelianMonoid is a category constructor
 Abbreviation for OrderedCancellationAbelianMonoid is OCAMON 
 This constructor is exposed in this frame.
 Issue )edit bookvol10.2.pamphlet to see algebra source code for OCAMON 

------------------------------- Operations --------------------------------
 ?*? : (NonNegativeInteger,%) -> %     ?*? : (PositiveInteger,%) -> %
 ?+? : (%,%) -> %                      ?<? : (%,%) -> Boolean
 ?<=? : (%,%) -> Boolean               ?=? : (%,%) -> Boolean
 ?>? : (%,%) -> Boolean                ?>=? : (%,%) -> Boolean
 0 : () -> %                           coerce : % -> OutputForm
 hash : % -> SingleInteger             latex : % -> String
 max : (%,%) -> %                      min : (%,%) -> %
 sample : () -> %                      zero? : % -> Boolean
 ?~=? : (%,%) -> Boolean              
 subtractIfCan : (%,%) -> Union(%,"failed")

\end{verbatim}

\subsection{OrderedAbelianSemiGroup}

\subsubsection{The original source code}
\begin{verbatim}
OrderedAbelianSemiGroup() : Category == SIG where

  SIG ==> Join(OrderedSet, AbelianSemiGroup)
\end{verbatim}

\subsubsection{The operations}
\begin{verbatim}
 OrderedAbelianSemiGroup is a category constructor
 Abbreviation for OrderedAbelianSemiGroup is OASGP 
 This constructor is exposed in this frame.
 Issue )edit bookvol10.2.pamphlet to see algebra source code for OASGP 

------------------------------- Operations --------------------------------
 ?*? : (PositiveInteger,%) -> %        ?+? : (%,%) -> %
 ?<? : (%,%) -> Boolean                ?<=? : (%,%) -> Boolean
 ?=? : (%,%) -> Boolean                ?>? : (%,%) -> Boolean
 ?>=? : (%,%) -> Boolean               coerce : % -> OutputForm
 hash : % -> SingleInteger             latex : % -> String
 max : (%,%) -> %                      min : (%,%) -> %
 ?~=? : (%,%) -> Boolean              

\end{verbatim}

\subsection{OrderedAbelianMonoidSup}

\subsubsection{The original source code}
\begin{verbatim}
OrderedAbelianMonoidSup() : Category == SIG where

  SIG ==> OrderedCancellationAbelianMonoid with

    sup : (%,%) -> %
      ++ sup(x,y) returns the least element from which both
      ++ x and y can be subtracted.
\end{verbatim}

\subsubsection{The operations}
\begin{verbatim}
 OrderedAbelianMonoidSup is a category constructor
 Abbreviation for OrderedAbelianMonoidSup is OAMONS 
 This constructor is exposed in this frame.
 Issue )edit bookvol10.2.pamphlet to see algebra source code for OAMONS 

------------------------------- Operations --------------------------------
 ?*? : (NonNegativeInteger,%) -> %     ?*? : (PositiveInteger,%) -> %
 ?+? : (%,%) -> %                      ?<? : (%,%) -> Boolean
 ?<=? : (%,%) -> Boolean               ?=? : (%,%) -> Boolean
 ?>? : (%,%) -> Boolean                ?>=? : (%,%) -> Boolean
 0 : () -> %                           coerce : % -> OutputForm
 hash : % -> SingleInteger             latex : % -> String
 max : (%,%) -> %                      min : (%,%) -> %
 sample : () -> %                      sup : (%,%) -> %
 zero? : % -> Boolean                  ?~=? : (%,%) -> Boolean
 subtractIfCan : (%,%) -> Union(%,"failed")

\end{verbatim}

\subsection{OrderedAbelianMonoid}

\subsubsection{The original source code}
\begin{verbatim}
OrderedAbelianMonoid() : Category == SIG where

  SIG ==> Join(OrderedAbelianSemiGroup, AbelianMonoid)
\end{verbatim}

\subsubsection{The operations}
\begin{verbatim}
 OrderedAbelianMonoid is a category constructor
 Abbreviation for OrderedAbelianMonoid is OAMON 
 This constructor is exposed in this frame.
 Issue )edit bookvol10.2.pamphlet to see algebra source code for OAMON 

------------------------------- Operations --------------------------------
 ?*? : (NonNegativeInteger,%) -> %     ?*? : (PositiveInteger,%) -> %
 ?+? : (%,%) -> %                      ?<? : (%,%) -> Boolean
 ?<=? : (%,%) -> Boolean               ?=? : (%,%) -> Boolean
 ?>? : (%,%) -> Boolean                ?>=? : (%,%) -> Boolean
 0 : () -> %                           coerce : % -> OutputForm
 hash : % -> SingleInteger             latex : % -> String
 max : (%,%) -> %                      min : (%,%) -> %
 sample : () -> %                      zero? : % -> Boolean
 ?~=? : (%,%) -> Boolean              

\end{verbatim}

\subsection{Monoid}

\subsubsection{The original source code}
\begin{verbatim}
Monoid() : Category == SIG where

  SIG ==> SemiGroup with

    1 : constant ->  %
      ++ \axiom{1} is the multiplicative identity. 

    sample : constant -> %
      ++ sample yields a value of type %

    one? : % -> Boolean
      ++ one?(x) tests if x is equal to 1.

    "**" : (%,NonNegativeInteger) -> %
      ++ x**n returns the repeated product
      ++ of x n times, that is, exponentiation.

    "^" : (%,NonNegativeInteger) -> %   
      ++ x^n returns the repeated product
      ++ of x n times, that is, exponentiation.

    recip : % -> Union(%,"failed")
      ++ recip(x) tries to compute the multiplicative inverse for x
      ++ or "failed" if it cannot find the inverse (see unitsKnown).

   add

      import RepeatedSquaring(%)

      _^(x:%, n:NonNegativeInteger):% == x ** n

      one? x == x = 1

      sample() == 1

      recip x ==
        (x = 1) => x
        "failed"

      x:% ** n:NonNegativeInteger ==
         zero? n => 1
         expt(x,n pretend PositiveInteger)
\end{verbatim}

\subsubsection{The operations}
\begin{verbatim}
 Monoid is a category constructor
 Abbreviation for Monoid is MONOID 
 This constructor is exposed in this frame.
 Issue )edit bookvol10.2.pamphlet to see algebra source code for MONOID 

------------------------------- Operations --------------------------------
 ?*? : (%,%) -> %                      ?**? : (%,NonNegativeInteger) -> %
 ?**? : (%,PositiveInteger) -> %       ?=? : (%,%) -> Boolean
 1 : () -> %                           ?^? : (%,NonNegativeInteger) -> %
 ?^? : (%,PositiveInteger) -> %        coerce : % -> OutputForm
 hash : % -> SingleInteger             latex : % -> String
 one? : % -> Boolean                   recip : % -> Union(%,"failed")
 sample : () -> %                      ?~=? : (%,%) -> Boolean

\end{verbatim}

\subsection{CancellationAbelianMonoid}

\subsubsection{The original source code}
\begin{verbatim}
CancellationAbelianMonoid() : Category == SIG where

  SIG ==> AbelianMonoid with

    subtractIfCan : (%,%) -> Union(%,"failed")
      ++ subtractIfCan(x, y) returns an element z such that \spad{z+y=x}
      ++ or "failed" if no such element exists.
\end{verbatim}

\subsubsection{The operations}
\begin{verbatim}
 CancellationAbelianMonoid is a category constructor
 Abbreviation for CancellationAbelianMonoid is CABMON 
 This constructor is exposed in this frame.
 Issue )edit bookvol10.2.pamphlet to see algebra source code for CABMON 

------------------------------- Operations --------------------------------
 ?*? : (NonNegativeInteger,%) -> %     ?*? : (PositiveInteger,%) -> %
 ?+? : (%,%) -> %                      ?=? : (%,%) -> Boolean
 0 : () -> %                           coerce : % -> OutputForm
 hash : % -> SingleInteger             latex : % -> String
 sample : () -> %                      zero? : % -> Boolean
 ?~=? : (%,%) -> Boolean              
 subtractIfCan : (%,%) -> Union(%,"failed")

\end{verbatim}

\subsection{AbelianSemiGroup}

\subsubsection{The original source code}
\begin{verbatim}
AbelianSemiGroup() : Category == SIG where

  SIG ==> SetCategory with

    "+" : (%,%) -> %
      ++ x+y computes the sum of x and y.

    "*" : (PositiveInteger,%) -> %
      ++ n*x computes the left-multiplication of x by the positive 
      ++ integer n. This is equivalent to adding x to itself n times.

   add

     import RepeatedDoubling(%)

     if not (% has Ring) then

        n:PositiveInteger * x:% == double(n,x)
\end{verbatim}

\subsubsection{The operations}
\begin{verbatim}
 AbelianSemiGroup is a category constructor
 Abbreviation for AbelianSemiGroup is ABELSG 
 This constructor is exposed in this frame.
 Issue )edit bookvol10.2.pamphlet to see algebra source code for ABELSG 

------------------------------- Operations --------------------------------
 ?*? : (PositiveInteger,%) -> %        ?+? : (%,%) -> %
 ?=? : (%,%) -> Boolean                coerce : % -> OutputForm
 hash : % -> SingleInteger             latex : % -> String
 ?~=? : (%,%) -> Boolean              

\end{verbatim}

\subsection{AbelianMonoid}

\subsubsection{The original source code}
\begin{verbatim}
AbelianMonoid() : Category == SIG where

  SIG ==> AbelianSemiGroup with

    0 : constant -> % 
      ++ \spad{0} is the additive identity element.

    sample : constant -> %
      ++ sample yields a value of type %

    zero? : % -> Boolean
      ++ zero?(x) tests if x is equal to 0.

    "*" : (NonNegativeInteger,%) -> %
      ++ n * x is left-multiplication by a non negative integer

   add

      import RepeatedDoubling(%)

      zero? x == x = 0

      n:PositiveInteger * x:% == (n::NonNegativeInteger) * x

      sample() == 0

      if not (% has Ring) then

        n:NonNegativeInteger * x:% ==
          zero? n => 0
          double(n pretend PositiveInteger,x)
\end{verbatim}

\subsubsection{The operations}
\begin{verbatim}
)show AbelianMonoid
 AbelianMonoid is a category constructor
 Abbreviation for AbelianMonoid is ABELMON 
 This constructor is exposed in this frame.
 Issue )edit bookvol10.2.pamphlet to see algebra source code for ABELMON 

------------------------------- Operations --------------------------------
 ?*? : (NonNegativeInteger,%) -> %     ?*? : (PositiveInteger,%) -> %
 ?+? : (%,%) -> %                      ?=? : (%,%) -> Boolean
 0 : () -> %                           coerce : % -> OutputForm
 hash : % -> SingleInteger             latex : % -> String
 sample : () -> %                      zero? : % -> Boolean
 ?~=? : (%,%) -> Boolean              
\end{verbatim}

\section{Conventions}

Everything has two kinds of types. There are CLOS types, such as
those which handle the parsed input. There are SPAD types, such as
those that reference spad categories.

\subsection{The CLOS types}

The CLOS types have generic functions to handle many operations.
There are, in general, two generic functions for each CLOS type.

One is the {\bf print-object}
\index[doc]{print-object}
generic method. It outputs the CLOS object as top-level SPAD
syntax. The idea is that the output of the parser should mirror
the input to the parser but derived from the internal structures.
That provides a ``round-trip'' check on the parser correctness.

Each {\bf print-object} has calls to the {\bf format} function.
The command string for each format call references a global
variable. This allows any print-object to be modified at run time
to change the output syntax.

Each CLOS type has a make-closname function that creates an
instance with required and actual parameters.

A second generic function {\bf intern-object} 
\index[doc]{intern-object}
is available for all CLOS classes. It outputs an intermediate 
representation of the CLOS object for further processing. Like 
print-object generics, each {\bf format} function command string
references a global variable which can be modified at run time.
This allows the intern-object to be adjusted easily.

Extensive use is made of the common lisp {\bf labels}
\index[doc]{labels}
form to define single-use functions locally. This reduces the
namespace pollution and makes local function definitions able to
be inlined by the compiler. Many of these single-use functions
exist just to make the logic of the function easier to understand.
In particular, local predicates are used to name the thing being
checked.

\subsection{The SPAD types}

The SPAD types from the Axiom distribution are included here
as CLOS classes. These form a basic library of objects available
at the lisp level.

The design allows for the library to be modified, extended, or
replaced completely. All that is necessary about the SPAD
language should be independent of the categories, domains, and
packages available to the user.

Certain ``fundamental'' libraries need to ``exist before they
exist'' and are essentiall built in to the system. However, they
are built-in at the library level, not at the compiler level.
The compiler expects them to exist but does not hard code them.

One of the challenges of building a SPAD library in CLOS is that
CLOS checks the inheritance hierarchy. This has the advantage of
a consistancy check but it is at times painful to get right.

Spad types, called {\bf Union}, are logical 'sum types'.  
\index[doc]{Union}
\index[doc]{Sum Types}
\begin{quote}
The values of a sum type are typically grouped into several classes,
called {\sl variants}. A value of a variant type is usually created
with a quasi-functional entity called a {\sl constructor}. Each
variant has its own constructor, which takes a specified number or
arguments with specified types. The set of all possible values of a sum
type is the set-theoretic sum, i.e. the {\sl disjoint union}, of the
sets of all possible values of its variants. {\sl Enumerated types}
are a special case of sum types in which the constructors take no
arguments, as exactly one value is defined for each constructor.\\
-- Wikipedia \cite{Wiki19}
\end{quote}

Spad types, called {\bf Record}, are logical 'product types'.
\index[doc]{Record}
\index[doc]{Product Types}
\begin{quote}
The values of a product type typically contain several values, called
{\sl fields}, All values of that type have the same combination of
field types. The set of all possible values of a product type is the
set-theoretic product, i.e. the {\sl Cartesian product}, of the sets
of all possible values of its field types.\\
-- Wikipedia \cite{Wiki19}
\end{quote}

\section{AxiomClass}

AxiomClass fulfills the type theoretic idea of 'kind', which
is inclusive of all of the types.

Axiom has Categories, not the same as the categories of category
theory. The Categories are essentially types from type theory.

In Common Lisp the type hierarchy has a most general type 't'.
In CLOS we define a new type {\bf AxiomClass} to be the most general
\index[code]{AxiomClass!Category}
\index[code]{Category!AxiomClass}
type of our hierarchy. AxiomClass inherits methods from 't', such as
{\bf print-object}.

AxiomClass provides the base definition for slots that every Category,
Domain, and Package will have. Not all of them are in use for every
case but this provides a place to add new features that work for every
class.

AxiomClass provides {\bf print-object} for the classes. The general
case print-object will construct and print the source code that
corresponds to the defclass definition. So, as if by magic, we can
build the source code from the intermediate CLOS defclass.

This leads to the idea of building the compiler 'inside out'. Normally
one would define the language syntax, write a parser, construct an
intermediate abstract syntax tree (AST) that holds the result of the
parse, and then construct a back end to a target machine.

However, CLOS is human readable and constructable. So we have taken
the novel approach of writing the AST in CLOS and 'deriving' the
source code from the AST. Later construct a parser that will accept
the output of 'print-object', parse it, and reconstruct the CLOS
defclass.

This means that we have a 'round trip' test of the parser. Every
defclass prints its source representation. The parser must recreate
the defclass from the printed source.

Refer to the AxiomClass \ref{AxiomClass}
section for more detailed information.

\section{Categories}

We need to construct the Axiom Category (aka type) hierarchy in CLOS.
We will use the term 'type' to signify Axiom objects, since the
defclass definitions are valid Common Lisp types.

We can do this because CLOS support inheritance.

Axiom can print the list of ancestors for a given type. For example,
PolynomialCategory ancestors are:
\begin{verbatim}
getAncestors 'PolynomialCategory

   (3)
   {AbelianGroup, AbelianMonoid, AbelianMonoidRing, 
    AbelianSemiGroup, Algebra, BasicType, BiModule, 
    CancellationAbelianMonoid, CharacteristicNonZero,
    CharacteristicZero, CoercibleTo, CommutativeRing, 
    ConvertibleTo, EntireRing, Evalable, FiniteAbelianMonoidRing,
    FullyLinearlyExplicitRingOver, FullyRetractableTo, GcdDomain,
    InnerEvalable, IntegralDomain, LeftModule, LeftOreRing,
    LinearlyExplicitRingOver, Module, Monoid, OrderedSet,
    PartialDifferentialRing, PatternMatchable, 
    PolynomialFactorizationExplicit, RetractableTo, RightModule, 
    Ring, Rng, SemiGroup, SetCategory, UniqueFactorizationDomain}
                                                            Type: Set(Symbol)
\end{verbatim}

PolynomialCategory is quite high up in the type hierarchy (15 levels up,
actually) so most of these are already inherited. We provide a program
(called {\bf leaves}), that given the above list will compute the
types that are not inherited. For example, given the above Axiom
output,
\begin{verbatim}
(leaves '(|AbelianGroup| |AbelianMonoid| |AbelianMonoidRing| 
    |AbelianSemiGroup| |Algebra| |BasicType| |BiModule| 
    |CancellationAbelianMonoid| |CharacteristicNonZero|
    |CharacteristicZero| |CoercibleTo| |CommutativeRing| 
    |ConvertibleTo| |EntireRing| |Evalable| |FiniteAbelianMonoidRing|
    |FullyLinearlyExplicitRingOver| |FullyRetractableTo| |GcdDomain|
    |InnerEvalable| |IntegralDomain| |LeftModule| |LeftOreRing|
    |LinearlyExplicitRingOver| |Module| |Monoid| |OrderedSet|
    |PartialDifferentialRing| |PatternMatchable| 
    |PolynomialFactorizationExplicit| |RetractableTo| |RightModule| 
    |Ring| |Rng| |SemiGroup| |SetCategory| |UniqueFactorizationDomain|))

(|ConvertibleTo| |Evalable| |FiniteAbelianMonoidRing|
 |FullyLinearlyExplicitRingOver| |OrderedSet| |PartialDifferentialRing|
 |PatternMatchable| |PolynomialFactorizationExplicit|)
\end{verbatim}

The PolynomialCategory class only needs to inherit the types that are
listed by the leaves program.

CLOS computes the precendence of types in the hierarchy. This provides
assurance that the Axiom category hierarchy is, at least at a minimum,
reasonably constructed.

\section{Domains and Packages}

Domains add a representation (called a ``carrier'' in logic).

In addition to the axioms inherited from the category hierarchy,
domains add additional axioms to characterize the properties of
the representation. These additional axioms contribute to the
proof.

\chapter{A Specification Language}

\begin{quote}
{\bf If it compiles, it works {\sl as specified}.}\\
-- Vladislav Zavialov \cite{Zavi}
\end{quote}

\begin{quote}
{\bf Much of the essence of building a program is in fact the
debugging of the specification.}
-- Fred Brooks \cite{Warn16}
\end{quote}

\begin{quote}
{\bf Real programming languages are inevitably complex, and any
serious attempt to give a formal treatment of such a language and a
development framework based on it is an ambitious undertaking
bringing a host of problems that do not arise when considering toy
programming languages or when considering specification and formal
development in abstract terms. Our EML experience suggests that, at
least at the present time, tackling the problems of specification
and formal development in a real programming language at a fully
formal level is just too difficult}\\
-- Donald Sannella and Andrzej Tarlecki \cite{Sann99}
\end{quote}

We must distinguish the language used for specification (the 
{\sl what} from the language for implementation the {\sl how}.

Hoare \cite{Hoar04} creates a ``Unified Theories of Programming''
in which he shows that there are 3 kinds of specification, namely
\begin{enumerate}
\item {\bf Denotational}, relating a program to a specification of its
observable properties and behaviour
\item {\bf Algebraic}, providing equations and inequalities for
comparison, transformation and optimisation of designs and programs
\item {\bf Operational}, describing individual steps of a possible
mechanical implementation
\end{enumerate}

This paper presents simple theories of sequential non-deterministic
programming in each of these three styles; by deriving each
presentation from its predecessor in a cyclic fashion, mutual
consistency is assured.

Sannella, et al. \cite{Sann91,Sann99} develop a specification language
for Standard ML (SML) \cite{Miln90,Miln91}

Kahrs and Sannella \cite{Kahr98} designed EML to provde a
specification language for ML. They point out that they want a
formal connection between the language (P) and the specifications (S).
They write:
\begin{quote}
Given that aim, it is not possible to come up with a meaningful
specification language for P unless P has a formal semantics.
Without a formal semantics for P we are not certain what P-programs
are supposed to do, making it impossible to establish reliably any 
property of any P-program or to prove interesting relationships
between P-programs and S-specifications. Unfortuately, this
requirement rules out most present-day programming languages.
\end{quote}

The Axiom Sane effort is trying to design a specification language for
the mathematics implemented by Axiom, not a specification language for
Axiom's Spad language.

The notion of ``exceptions'' in mathematics is unclear.  Since Axiom
implements mathematical functions it is not much of a concern. 
Side-effects are also not much of a concern, at least for the
mathematical algorithms.

As such, the Sane effort is a ``domain specific specification'', 
not a ``language specific specification''. If there is a Spad
language construct used to implement a function, all one has to
show is that the language construct ``covers'' the use case in
the particular function.

They raise a series of question about a specification \cite{Sann99}
\begin{enumerate}
\item What is a specifiation?
\item What does a specification mean?
\item When does a program satisfy a specification?
\item When does a specification guarantee a property that it does not
state explicitly?
\item How does one prove this?
\item How are specifications structured?
\item How does the structure of a specification relate to the
structure of programs?
\item When does one specification correctly refine another
specification?
\item How does one prove correctness of refinement steps?
\item When do refinement steps compose?
\item What is the role of information hiding?
\end{enumerate}

The specification language is related to what we wish to prove. 
\cite{Kahr98}. Is it a
\begin{enumerate}
\item proof that a given program satisfies a given specification?
\item proof that one specification is a refinement of another?
\item proof that all programs satisfying a given specification will
satisfy a given property?
\end{enumerate}

John Hughes \cite{Hugh19} identifies several types of specification tests:
\begin{enumerate}
\item invariant properties
\item postconditions
\item metamorphic properties
\item inductive properties
\item model-based properties
\end{enumerate}

\subsection{The specification class}

\index[fig]{defclass!specification}
\index[fig]{specification defclass}
\begin{table}[H]
\begin{center}
\label{tab:specification}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Fieldname} & \textbf{initarg} & \textbf{initform} & \textbf{accessor}\\
\hline
precondition & :precondition & nil & spec-precondition\\
postcondition & :postcondition & nil & spec-postcondition\\
\hline
\end{tabular}
\caption{{\bf defclass specification}}
\end{center}
\end{table}

\index[code]{defclass!specification}
\index[code]{specification!defclass}
\begin{chunk}{defclass specification}
(defclass specification ()
  ((precondition  :initarg :precondition  :initform nil :accessor spec-precondition)
   (postcondition :initarg :postcondition :initform nil :accessor spec-postcondition)))

\end{chunk}

\chapter{GCD -- A Case Study}

The main activities of formal methods,
according to Hall \cite{Hall90}, are
\begin{itemize}
\item writing a formal specification
\item proving properties about the specification
\item constructing a program by mathematically manipulating the
specification
\item verifying a program by mathematical argument.
\end{itemize}

\section{Writing a formal specification}

Davenport \cite{Dave17a} says:

``$g$ is the greatest common divisor of $f_1$, $f_2$ [and more]'' is
actually two assertions:
\begin{itemize}
\item $g$ divides $f_1$, $f_2$ (implicitly over
$\mathbb{Z}[x_1,\ldots,x_n]$);
\item Any $h$ that also divides them divides $g$
\end{itemize}

Note that $g$ is not unique: $-g$ would do as well. CA systems enforce
uniqueness by making the leading coefficient positive, but this then
depends on the definition of ``leading''. If this matters, there's
going to be a tricky communication over the meaning of ``leading''.

\section{Proving properties about the specification}

\section{Constructing a program}

\section{Verifying a program by mathematical argument}

\chapter{Primitive Support tools}

\noindent
Due to type checking, these functions have to appear early in the file
but we do it by using the literate reference.

\chapter{Overview}

\begin{quote}
{\bf Data are just dumb programs}\\
-- Dan Friedman
\end{quote}

\begin{quote}
{\bf The classic hacker disdain for "bondage and discipline languages"
is short sighted -- the needs of large, long-lived multi-programmer
projects are just different than the quick work you do for yourself.}\\
-- John Carmack
\end{quote}

\begin{quote}
{\bf If you have a large enough codebase, any class of error that is
syntactically legal probably exists there.}\\
-- John Carmack
\end{quote}

\begin{quote}
{\bf Anything that isn't clear to your static analysis tool probably
isn't clear to your fellow programmers either.}\\
-- John Carmack
\end{quote}

\begin{quote}
{\bf A lot of the serious reported errors are due to modifications of
code long after it was written.}\\
-- John Carmack
\end{quote}

\begin{quote}
{\bf The first step is fully admitting that the code you write is
riddled with errors. That is a bitter pill to swallow for a lot
of people, but without it, most suggestions for change will be
viewed with irritation or outright hostility. You have to want
criticism of your code.}\\
-- John Carmack
\end{quote}

\noindent
The {\bf *Categories*} variable contains a list of all defined Categories.
\index[code]{*Category*}
\index[code]{defvar!*Categories*}
\index[code]{*Categories*!defvar}
\begin{chunk}{defvar categories}
(defvar *Categories* nil)

\end{chunk}

\noindent
The {\bf *Domains*} variable contains a list of all defined Domains.
\index[code]{defvar!*Domains*}
\index[code]{*Domains*!defvar}
\begin{chunk}{defvar domains}
(defvar *Domains* nil)

\end{chunk}

\noindent
The {\bf *Packages*} variable contains a list of all defined Packages.
\index[code]{defvar!*Packages*}
\index[code]{*Packages*!defvar}
\begin{chunk}{defvar packages}
(defvar *Packages* nil)

\end{chunk}

\index[code]{defvar!*indent*}
\index[code]{*indent*!defvar}
\begin{chunk}{defvar indent}
(defvar *indent* "    ")

\end{chunk}

There are times we need to know what the compiler phases
are doing. The {\tt *comptrace*} variable is a number that
specifies the amount and detail of output, zero being no
output; 100 being everything.
\index[code]{defvar!*comptrace*}
\index[code]{*comptrace*!defvar}
\begin{chunk}{defvar comptrace}
(defvar *comptrace* 100)

\end{chunk}

\section{Deconstructing the Compiler}

We have to know where to look for the input file.
This involves setting the {\tt *place*} variable.
\index[code]{*place*}
By default this is the current directory.

Call {\tt P} with the simple filename.
\index[code]{P}

Call {\tt make-sourcecode}
\index[code]{make-sourcecode}

Call {\tt sourcecode-tree}
\index[code]{sourcecode-tree}

Call {\tt pretty}
\index[code]{pretty}

\section{The Category Class}

\cite[p4]{Dosr11}
\cite{Daly17}

\begin{itemize}
\item {\bf marker} is a constant to know if something is a category,
a domain, or a package.
\item {\bf parents} is a list of the direct parents of this 
category.
\item {\bf CategoryForm} holds the canonical category form of the expression
whose evaluation produces the category object under consideration
\item {\bf ExportInfoList} holds a list of function signatures exported by the
category
\item {\bf AttributeList} holds a list of attributes and the conditions under
which they hold
\item {\bf CategoryMark} always contains the form (Category). It serves as a
runtime type checking tag
\item {\bf PrincipalAncestorList} is a list of principal ancestor category forms
\item {\bf ExtendedCategoryList} is a list of directly extended category forms
\item {\bf DomainInfoList} is a list of domains explicitly used in that category
\item {\bf UsedDomainList} holds the list of all domain forms mentioned in
the exported signatures
\end{itemize}

\subsection{The hasclause class}

\index[fig]{defclass!hasclause}
\index[fig]{hasclause defclass}
\begin{table}[H]
\begin{center}
\label{tab:hasclause}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Fieldname} & \textbf{initarg} & \textbf{initform} & \textbf{accessor}\\
\hline
whichtype & :whichtype & nil & hasclause-whichtype\\
condition & :condition & nil & hasclause-condition\\
siglist   & :siglist   & nil & hasclause-siglist\\
\hline
\end{tabular}
\caption{{\bf defclass hasclause}}
\end{center}
\end{table}

\index[code]{hasclause!defclass}
\index[code]{defclass!hasclause}
\begin{chunk}{defclass hasclause}
(defclass hasclause ()
  ((whichtype :initarg :whichtype :initform nil  :accessor hasclause-whichtype)
   (condition :initarg :condition :initform nil  :accessor hasclause-condition)
   (siglist   :initarg :siglist   :initform nil  :accessor hasclause-siglist)))

\end{chunk}

\index[code]{make-hasclause!defun}
\index[code]{defun!make-hasclause}
\sig{make-hasclause}{(type,condition,siglist)}{hasclause}
\begin{chunk}{defun make-hasclause}
(defun make-hasclause (type condition siglist)
  (make-instance 'hasclause :whichtype type :condition condition :siglist siglist))

\end{chunk}

\index[code]{print-object!defmethod!hasclause}
\index[code]{defmethod!print-object!hasclause}
\index[code]{hasclause!defmethod!print-object}
\begin{chunk}{defmethod print-object}
(defmethod print-object ((clause hasclause) stream)
  (let ((deeper (concatenate 'string "  " *indent*)))
    (format stream "if ~a has ~a then~%~a~a~%" 
      (hasclause-whichtype clause)
      (hasclause-condition clause)
      deeper
      (hasclause-siglist clause))))

\end{chunk}

\subsection{The haslist class}

\index[fig]{defclass!haslist}
\index[fig]{haslist defclass}
\begin{table}[H]
\begin{center}
\label{tab:haslist}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Fieldname} & \textbf{initarg} & \textbf{initform} & \textbf{accessor}\\
\hline
clauses & :clauses & nil & haslist-clauses\\
\hline
\end{tabular}
\caption{{\bf defclass haslist}}
\end{center}
\end{table}

\index[code]{haslist!defclass}
\index[code]{defclass!haslist}
\begin{chunk}{defclass haslist}
(defclass haslist ()
  ((clauses :initarg :clauses :initform nil :accessor haslist-clauses)))

\end{chunk}

\index[code]{make-haslist!defun}
\index[code]{defun!make-haslist}
\sig{make-haslist}{clauses}{hasclause}
\begin{chunk}{defun make-haslist}
(defun make-haslist (clauses)
  (make-instance 'haslist :clauses clauses))

\end{chunk}

\subsection{The AxiomClass class}

\index[fig]{defclass!AxiomClass}
\index[fig]{AxiomClass defclass}
\begin{table}[H]
\begin{center}
\label{tab:AxiomClass}
\begin{tabular}{|l|l|l|l|l|l|l|}
\hline
\textbf{Fieldname} & \textbf{initarg} & \textbf{initform} &
\textbf{accessor}  & \textbf{reader} & \textbf{allocation} &
\textbf{type}\\
\hline
marker   & :marker  & 'category & marker   &        &&\\
macros   & :macros  & nil       & macros   &        &&\\
comment  & :comment & nil       & comment  &        &&\\
argslist & :arg     & nil       & argslist &        &&\\
withlist & :with    & nil       & withlist &        &&\\
haslist  & :has     & nil       & haslist  &        &&\\
addlist  & :add     & nil       & addlist  &        &&\\
level    & :level   &           &          & level  &&\\
abbreviation & :abbreviation &  &          & abbreviation &&\\
name     &          & "AxiomClass" &       & name         & :class&\\
parents  & :parents & nil       & parents  &              && Tnulllist\\
\hline
\end{tabular}
\caption{{\bf defclass AxiomClass}}
\end{center}
\end{table}

The {\bf AxiomClass} is a place to hang Axiom-specific methods.
\label{AxiomClass}
\index[code]{defclass!AxiomClass}
\index[code]{AxiomClass!defclass}
\begin{chunk}{defclass AxiomClass}
(defclass |AxiomClass| ()
  ((marker       :initarg :marker  :initform 'category :accessor marker)
   (macros       :initarg :macros  :initform nil       :accessor macros)
   (comment      :initarg :comment :initform nil       :accessor comment)
   (argslist     :initarg :arg     :initform nil       :accessor argslist)
   (withlist     :initarg :with    :initform nil       :accessor withlist)
   (haslist      :initarg :has     :initform nil       :accessor haslist)
   (addlist      :initarg :add     :initform nil       :accessor addlist)
   (level        :initarg :level        :reader level)
   (abbreviation :initarg :abbreviation :reader abbreviation)
   (name :initform "AxiomClass"         :reader name :allocation :class)
   (parents :initarg :parents 
            :accessor parents 
            :initform nil
            :type Tnulllist
            :documentation "A list of direct parents")
))

\end{chunk}

\index[code]{print-object!AxiomClass}
\index[code]{AxiomClass!methods!print-object}

The print-oject method for AxiomClass re-creates the source level
language from the internal data structures. The output of print-object
should exactly mirror the input syntax. This allows ``round-trip'' 
assurance that the source code and its intermediate representation
match.

Format control strings are used to create output from the print-object
function. Because we may want to (dynamically?) change the output of
any AxiomClass object, we provide the control strings as global 
variables. 

\index[code]{print-object!defmethod!AxiomClass}
\index[code]{defmethod!print-object!AxiomClass}
\index[code]{AxiomClass!defmethod!print-object}
\begin{chunk}{defmethod print-object}
(defvar formatCategoryAbbrev "~&)abbrev category ~a ~a")
(defvar formatCategorySIG "~&~a(~{~a~^, ~}) : Category == SIG where~2%")
(defvar formatCategoryComment "~&~{~^++ ~a~%~}~%")

(defvar formatDomainAbbrev   "~&)abbrev domain ~a ~a")
(defvar formatDomainSIG      "~&~a(~{~a~^, ~}) : SIG == CODE where~2%")
(defvar formatDomainComment  "~&~{~^++ ~a~%~}~%")

(defvar formatPackageAbbrev  "~&)abbrev package ~a ~a")
(defvar formatPackageSIG     "~&~a(~{~a~^, ~}) : SIG == CODE where~2%")
(defvar formatPackageComment "~&~{~^++ ~a~%~}~%")

(defvar formatNoSuper        "  SIG ==> () ")
(defvar formatSuper          "  SIG ==> ~a ")
(defvar formatJoin           "  SIG ==> Join(~{~a~^,~%               ~}) ")

(defvar formatWith           "with ~%")
(defvar formatWithNil        "with nil~%")

(defvar formatSig            "    ~a~%")

(defvar formatHas            "~%~aif % has ~a then~%")
  
(defvar formatAdd            "  add ~%")

(defmethod print-object ((cat |AxiomClass|) stream)
  (let (has condition)
   (cond
     ((eq (marker cat) 'category)
       (format stream formatCategoryAbbrev (abbreviation cat) (name cat))
       (format stream formatCategoryComment (comment cat))
       (format stream formatCategorySIG (name cat) (argslist cat)))
     ((eq (marker cat) 'domain)
       (format stream formatDomainAbbrev (abbreviation cat) (name cat))
       (format stream formatDomainComment (comment cat))
       (format stream formatDomainSIG (name cat) (argslist cat)))
     ((eq (marker cat) 'package)
       (format stream formatPackageAbbrev (abbreviation cat) (name cat))
       (format stream formatPackageComment (comment cat))
       (format stream formatPackageSIG (name cat) (argslist cat))))
   (let ((adults (parents cat)))
     (cond
      ((null adults) (format stream formatNoSuper))
      ((= (length adults) 1) (format stream formatSuper (car adults)))
      (t (format stream formatJoin adults))))
   (if (withlist cat)
     (progn
       (format stream formatWith)
       (dolist (sig (withlist cat))
         (format stream formatSig sig)))
     (format stream formatWithNil))
   (if (setq has (car (haslist cat))) 
     (progn
       (setq condition (car (haslist-clauses has)))
       (format stream formatHas *indent* (hasclause-condition condition))
       (let ((*indent* (concatenate 'string *indent* "  ")))
         (dolist (sig (hasclause-siglist condition))
           (format stream formatSig sig)))))
   (when (addlist cat)
     (format stream formatAdd)
     (dolist (sig (addlist cat))
       (format stream "~%    ~a~%" sig)))))

\end{chunk}

\subsection{The WithClass class}

\index[fig]{defclass!WithClass}
\index[fig]{WithClass defclass}
\begin{table}[H]
\begin{center}
\label{tab:WithClass}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Fieldname} & \textbf{initarg} & \textbf{initform} & \textbf{accessor}\\
\hline
\end{tabular}
\caption{{\bf defclass WithClass}}
\end{center}
\end{table}

\index[code]{defclass!WithClass}
\index[code]{WithClass!defclass}
\begin{chunk}{defclass WithClass}
(defclass |WithClass| () ())

\end{chunk}

\subsection{The AddClass class}

\index[fig]{defclass!AddClass}
\index[fig]{AddClass defclass}
\begin{table}[H]
\begin{center}
\label{tab:AddClass}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Fieldname} & \textbf{initarg} & \textbf{initform} & \textbf{accessor}\\
\hline
\end{tabular}
\caption{{\bf defclass AddClass}}
\end{center}
\end{table}

\index[code]{defclass!AddClass}
\index[code]{AddClass!defclass}
\begin{chunk}{defclass AddClass}
(defclass |AddClass| () ())

\end{chunk}

\index[doc]{showSig}
The {\bf showSig} method will show a signature of a CategoryClass
object in abbreviated forms. So, for example,
\begin{verbatim}
   (showSig |PAdicIntegerCategory|) ==> PADICCT(EUCDOM,CHARZ)
\end{verbatim}
\index[code]{defgeneric!showSig}
\index[code]{showSig!defgeneric}
\begin{chunk}{defgeneric showSig}
(defgeneric showSig (name))

\end{chunk}

\index[code]{defmethod!showSig}
\index[code]{showSig!defmethod}
\begin{chunk}{defmethod showSig}
(defmethod showSig ((name |AxiomClass|))
  (let ((parents (parents name)) abbrevs)
   (dolist (him parents) (push (abbreviation (symbol-value him)) abbrevs))
   (format t "~a(~{~a~^,~})~%"  (abbreviation name) (nreverse abbrevs))))

\end{chunk}

\section{Helper Functions}

The {\bf defunt} macro allows specifying the type {\tt INT} in
an argument list. For example, these are all valid:
\begin{verbatim}
   (defunt one (p1 p2) ....)
   (defunt one ((int p1) p2) ...)
   (defunt one ((int p1) (int p2)) ...)
\end{verbatim}

\index[code]{defmacro!defunt}
\index[code]{defunt!defmacro}
\begin{chunk}{defmacro defunt}
(defmacro defunt (name (&rest args) &body body)
  "defun with optional type declarations"
  `(progn
     (declaim (ftype
               (function
                ,(let (declares)
                  (dolist (arg args)
                   (push
                    (if (listp arg)
                      (if (equalp (string (first arg)) "int")
                        'fixnum
                        (first arg))
                      t)
                     declares))
                   declares)
                 t) ,name))
     (defun ,name
       ,(loop for arg in args
          collect
            (if (listp arg)
                (second arg)
                arg))
       ,@body)))

\end{chunk}

We usually want lines without leading and trailig spaces. The 
common lisp idiom for this is very wordy so we make a macro.
\index[code]{defmacro!trim}
\index[code]{trim!defmacro}
\begin{chunk}{defmacro trim}
(defmacro trim (arg)
  `(string-trim '(#\space) ,arg))

\end{chunk}

Here we create the Axiom {\bf getAncestors} function. It walks the
tree of ancestors to collect the union of the set. 

This accepts the symbol for the class or the instance.
\sig{getAncestors}{symbol}{list(ancestors)}
\index[code]{defun!getAncestors}
\index[code]{getAncestors!defun}
\begin{chunk}{defun getAncestors}
(defun getAncestors (symbol)
  (labels (
    (theAncestors (name)
      ; look up the ancestors 
      (let (class)
        (cond
         ((and (symbolp name) (setq class (find-class name nil)))
           (parents (make-instance class)))
         (t
           (parents 
             (make-instance 
               (class-name (class-of (symbol-value name))))))))))
  (let (name todo result)
   (setq todo (theAncestors symbol))
   (loop while todo do
     (setq name (pop todo))
     (unless (member name result) (push name result))
     (setq todo (set-difference (union (theAncestors name) todo) result)))
  (sort result #'string<))))
  
\end{chunk}

The {\bf leaves}
\index[doc]{leaves}
needs to compute the most immediate ancestors (the leaves) of the 
type tree. We walk the tree collecting ancestors and remove duplicates.
\sig{leaves}{survive}{survive}
\index[code]{defun!leaves}
\index[code]{leaves!defun}
\begin{chunk}{defun leaves}
(defun leaves (survive)
  (let ((l survive))
    (dolist (thing l) (setq survive (set-difference survive (getAncestors thing))))
  survive))

\end{chunk}

We introduce the concept of a {\bf level}
\index[doc]{level}
to order classes based on how deep they are in the inheritance
hierarchy. Level 1 Categories only depend on {\bf CategoryClass}.
Level 2 Categories only depend on Level 1, etc.

We order the class inheritance list based on level.

Here we need to be able to know what level to assign to a Category.
Each level defines a variable, e.g. {\bf level1}, {\bf level2}, etc
that contains all of the Category instance symbols defined at that
level.

\index[code]{defmacro!ll}
\index[code]{ll!defmacro}
\begin{chunk}{defmacro ll}
(defmacro ll (name)
  `(cond
     ((member ',name level1) 'level1)
     ((member ',name level2) 'level2)
     ((member ',name level3) 'level3)
     ((member ',name level4) 'level4)
     ((member ',name level5) 'level5)
     ((member ',name level6) 'level6)
     ((member ',name level7) 'level7)
     ((member ',name level8) 'level8)
     ((member ',name level9) 'level9)
     ((member ',name level10) 'level10)
     ((member ',name level11) 'level11)
     ((member ',name level12) 'level12)
     ((member ',name level13) 'level13)
     ((member ',name level14) 'level14)
     ((member ',name level15) 'level15)
     ((member ',name level16) 'level16)
     ((member ',name level17) 'level17)
     ((member ',name level18) 'level18)
     ((member ',name level19) 'level19)
  ))

\end{chunk}

Here we create the Axiom {\bf getDomains} function. It finds all of the
domains that inherit this class. Given a domain it return an empty set.
\index[code]{defun!getDomains}
\index[code]{getDomains!defun}
\begin{chunk}{defun getDomains}
(defun getDomains ())

\end{chunk}

\subsection{Signatures and OperationAlist}
\index[doc]{Signatures}
\index[doc]{OperationAlist}

The {\bf OperationAlist} is a list of all of the operations that are available
for the domain. Note that if there are two operations with the same name then
they are combined into one operation but with different signatures.

\subsection{The signature class}

\index[fig]{defclass!signature}
\index[fig]{signature defclass}
\begin{table}[H]
\begin{center}
\label{tab:signature}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Fieldname} & \textbf{initarg} & \textbf{initform} & \textbf{accessor}\\
\hline
name      & :name      & ""  & signature-name\\
returns   & :returns   & nil & signature-returns\\
arguments & :arguments & nil & signature-arguments\\
comment   & :comment   & nil & signature-comment\\
examples  & :examples  & nil & signature-examples\\
infix?    & :infix     & nil & signature-infix\\
\hline
\end{tabular}
\caption{{\bf defclass signature}}
\end{center}
\end{table}

\index[code]{signature!defclass}
\index[code]{defclass!signature}
\begin{chunk}{defclass signature}
(defclass signature ()
  ((name      :initarg :name      :initform ""  :accessor signature-name)
   (returns   :initarg :returns   :initform nil :accessor signature-returns)
   (arguments :initarg :arguments :initform nil :accessor signature-arguments)
   (comment   :initarg :comment   :initform nil :accessor signature-comment)
   (examples  :initarg :examples  :initform nil :accessor signature-examples)
   (infix?    :initarg :infix     :initform nil :accessor signature-infix)))

\end{chunk}

\sig{make-signature}{(funcname return arglist comment examples infix?}{signature}
\index[code]{defun!make-signature}
\index[code]{make-signature!defun}
\begin{chunk}{defun make-signature}
(defun make-signature (funcname return arglist 
                       &optional (comment nil) (examples nil) (infix? nil))
  (make-instance 'signature :name funcname 
                            :returns return 
                            :arguments arglist 
                            :comment comment
                            :examples examples
                            :infix infix?))

\end{chunk}

\index[code]{print-object!defmethod!signature}
\index[code]{defmethod!print-object!signature}
\index[code]{signature!defmethod!print-object}
\begin{chunk}{defmethod print-object}
(defvar signatureFormatNull       "~&~a~a ")
(defvar signatureFormat1Arg       "~&~a~a : ~{~^~a~^,~} -> ~a")
(defvar signatureFormatArgs       "~&~a~a : (~{~^~a~^,~}) -> ~a")
(defvar signatureFormatListArg    "List(~{~a~^,~})")
(defvar signatureFormatArgsType   "~a(~{~a~^,~})")
(defvar signatureFormatUnion      "Union(~{~s~^,~})")
(defvar signatureFormatRecord     "Record(~{~a: ~a~^,~})")
(defvar signatureFormatReturnList "List(~{~a~^,~})")
(defvar signatureFormatReturnType "~a(~{~s~^,~})")
(defvar signatureFormatComment    "~&~a  ++ ~a")
(defvar signatureFormatExamples   "~&~a  ++X ~a")

(defmethod print-object ((sig signature) stream)
  (labels (
    (singletonList? (args)
      ; change singleton list into a single element
      (loop for arg in args 
        when (and (consp arg) (= (length arg) 1)) do (setq arg (car arg))
        collect arg))
    (argsList? (args) 
      ; Is the args type a List?
 (format t "argsList=~s~%" args)
      (let (result)
        (dolist (arg args (nreverse result))
          (if (and (consp arg) (eq (car arg) '|List|))
            (push (format nil signatureFormatListArg
                      (substitute 'K '|#1| (cdr arg)))
             result)
          (push arg result)))))
    (argsType? (args) 
      ; Is the args type a List?
 (format t "argsType=~s~%" args)
      (let (result)
        (dolist (arg args (nreverse result))
          (if (and (consp arg) (symbolp (car arg)))
            (push (format nil signatureFormatArgsType (car arg)
                      (substitute 'K '|#1| (cdr arg)))
             result)
          (push arg result)))))
    (union? (returns) 
      ; Is the return type a Union?
 (format t "union=~s~%" returns)
      (if (and (consp returns) (eq (car returns) '|Union|))
         (setq returns (format nil signatureFormatUnion
                         (cdr (substitute '% '$  returns))))
         returns))
    (record? (returns) 
      ; Is the return type a Record?
 (format t "record=~s~%" returns)
      (let (result)
        (if (and (consp returns) (eq (car returns) '|Record|))
          (format nil signatureFormatRecord 
            (dolist (field (cdr returns) (nreverse result))
              (setq field (substitute '% '$ field))
              (push (second field) result)
              (push (third field) result)))
          returns)))
    (returnList? (returns) 
      ; Is the return type a List?
 (format t "returnList=~s~%" returns)
      (if (and (consp returns) (eq (car returns) '|List|))
         (setq returns (format nil signatureFormatReturnList
                         (cdr 
                           (substitute 'K '|#1|
                             (substitute '% '$  returns)))))
         returns))
    (returnType? (returns) 
      ; Is the return type a Type?
 (format t "returnType=~s~%" returns)
      (if (and (consp returns) (symbolp (car returns)))
         (setq returns (format nil signatureFormatReturnType (car returns)
                         (cdr 
                           (substitute 'K '|#1|
                             (substitute '% '$  returns)))))
         returns))
    (singletonVar? (returns) 
      ; Is the return type a single temp variable?
 (format t "singleVar=~s~%" returns)
      (if (eq returns '|#1|)
        'K
        returns))
    (infix? (sig)
 (format t "infix ~s ~s~%" (signature-infix sig) (signature-name sig))
      (if (signature-infix sig)
        (format nil "\"~a\"" (signature-name sig))
        (signature-name sig)))
    (formatWithlist (name args returns sig)
      ; for each signature in the list, make it pretty
 (format t "formatWithList name=~s args=~s returns=~s sig=~s~%" name args returns sig)
      (cond
        ((and (null args) (null returns))
          (format stream signatureFormatNull *indent* name))
        ((= (length args) 1) 
          (format stream signatureFormat1Arg *indent* name args returns))
        (t
          (format stream signatureFormatArgs *indent* name args returns)))
      (dolist (comment (signature-comment sig))
        (format stream signatureFormatComment *indent* comment))
      (when (signature-examples sig) 
        (dolist (example (signature-examples sig))
          (format stream signatureFormatExamples *indent* example))))
  )
  (let ((args (signature-arguments sig)) (returns (signature-returns sig)) name)
   (format t "main=~s~%" args)
    (setq name (infix? sig))
    ; handle the arg list cleanup
    (setq args (singletonList? args))
    (setq args (argsType? args))
    (setq args (mapcar #'singletonVar? args))
    ; handle return type cleanup
    (when (and (consp returns) (= (length returns) 1)) (setq returns (car returns)))
    (setq returns (union? returns))
    (setq returns (record? returns))
    (setq returns (returnType? returns))
    (setq returns (singletonVar? returns))
    ; and format the Withlist
    (formatWithlist name args returns sig))))

\end{chunk}

\subsection{The amacro class}

\index[fig]{defclass!amacro}
\index[fig]{amacro defclass}
\begin{table}[H]
\begin{center}
\label{tab:amacro}
\begin{tabular}{|l|l|l|l|l|}
\hline
\textbf{Fieldname} & \textbf{initarg} & \textbf{initform} &
\textbf{accessor}  & \textbf{type}\\
\hline
name & :name & "" & amacro-name & symbol\\
body & :body & nil & amacro-body &\\
\hline
\end{tabular}
\caption{{\bf defclass amacro}}
\end{center}
\end{table}

\index[code]{amacro!defclass}
\index[code]{defclass!amacro}
\begin{chunk}{defclass amacro}
(defclass amacro ()
  ((name
     :initarg :name
     :initform ""
     :accessor amacro-name
     :type symbol)
   (body
     :initarg :body
     :initform nil
     :accessor amacro-body)))

\end{chunk}

\subsection{The operation class}

\index[fig]{defclass!operation}
\index[fig]{operation defclass}
\begin{table}[H]
\begin{center}
\label{tab:operation}
\begin{tabular}{|l|l|l|l|l|}
\hline
\textbf{Fieldname} & \textbf{initarg} & \textbf{initform} &
\textbf{accessor}  & \textbf{type}\\
\hline
name & :name & ""  & operation-name       & string\\
body & :body & nil & operation-signatures & list\\
\hline
\end{tabular}
\caption{{\bf defclass operation}}
\end{center}
\end{table}

\index[code]{operation!defclass}
\index[code]{defclass!operation}
\begin{chunk}{defclass operation}
(defclass operation ()
  ((name
     :initarg :name
     :initform ""
     :accessor operation-name
     :type string)
   (signatures
     :initarg :signatures
     :initform nil
     :accessor operation-signatures
     :type list)))

\end{chunk}

\index[code]{defvar!infixOperations}
\index[code]{infixOperations!defvar}
\begin{chunk}{defvar infixOperations}
(defvar *infixOperations* '("*" "**" "+" "<" "<=" "=" ">" ">=" "^"
                            "quo" "rem" "~=" "."))

\end{chunk}

\index[code]{print-object!defmethod!operation}
\index[code]{defmethod!print-object!operation}
\index[code]{operation!defmethod!print-object}
\begin{chunk}{defmethod print-object}
(defmethod print-object ((op operation) stream)
  (let ((name (operation-name op)) (sigs (operation-signatures op)))
    (cond
      ((eq name '|Zero|) (setq name "0"))
      ((eq name '|One|)  (setq name  "1"))
      ((eq name '|elt|)  (setq name  ".")))
    (dolist (sig sigs)
      (if (member name *infixOperations* :test #'string=)
        (format stream "?~a? : ~a~%" name sig)
        (format stream "~a : ~a~%" name sig)))))

\end{chunk}

\index[code]{defgeneric!operation-add}
\index[code]{operation-add!defgeneric}
\begin{chunk}{defgeneric operation-add}
(defgeneric operation-add (operation signature))

\end{chunk}

\index[code]{defmethod!operation-add}
\index[code]{operation-add!defmethod}
\begin{chunk}{defmethod operation-add}
(defmethod operation-add ((op operation) signature)
  (setf (operation-signatures op) (cons signature (operation-signatures op))))

\end{chunk}

\sig{make-operation}{name}{operation}
\index[code]{defun!make-operation}
\index[code]{make-operation!defun}
\begin{chunk}{defun make-operation}
(defun make-operation (name)
  (make-instance 'operation :name name))

\end{chunk}

From OperationAlist to Signatures
\begin{verbatim}
   (* (($ (|PositiveInteger|) $) NIL) (($ (|NonNegativeInteger|) $) NIL) (($ $ $) NIL))
                                        -> ?*? : (%,%) -> %
                                        -> ?*? : (NonNegativeInteger,%) -> %
                                        -> ?*? : (PositiveInteger,%) -> %
   (** (($ $ (|NonNegativeInteger|)) NIL) (($ $ (|PositiveInteger|)) NIL))
                                        -> ?**? : (%,PositiveInteger) -> %
                                        -> ?**? : (%,NonNegativeInteger) -> %
   (+ (($ $ $) NIL))                    -> ?+? : (%,%) -> %
   (< (((|Boolean|) $ $) NIL))          -> ?<? : (%,%) -> Boolean
   (<= (((|Boolean|) $ $) NIL))         -> ?<=? : (%,%) -> Boolean
   (= (((|Boolean|) $ $) NIL))          -> ?=? : (%,%) -> Boolean
   (> (((|Boolean|) $ $) NIL))          -> ?>? : (%,%) -> Boolean
   (>= (((|Boolean|) $ $) NIL))         -> ?>=? : (%,%) -> Boolean
   (|One| (($) NIL T CONST))            -> 1 : () -> %
   (|Zero| (($) NIL T CONST))           -> 0 : () -> %
   (^ (($ $ (|NonNegativeInteger|)) NIL) (($ $ (|PositiveInteger|)) NIL))
                                        -> ?^? : (%,PositiveInteger) -> %
                                        -> ?^? : (%,NonNegativeInteger) -> %
   (|coerce| (((|OutputForm|) $) NIL))  -> coerce : % -> OutputForm
   (|gcd| (($ $ $) 11))                 -> gcd : (%,%) -> %
   (|hash| (((|SingleInteger|) $) NIL)) -> hash : % -> SingleInteger
   (|latex| (((|String|) $) NIL))       -> latex : % -> String
   (|max| (($ $ $) NIL))                -> max : (%,%) -> %
   (|min| (($ $ $) NIL))                -> min : (%,%) -> %
   (|one?| (((|Boolean|) $) NIL))       -> one? : % -> Boolean
   (|qcoerce| (($ (|Integer|)) 8))      -> qcoerce : Integer -> %
   (|quo| (($ $ $) NIL))                -> ?quo? : (%,%) -> %
   (|random| (($ $) NIL))               -> random : % -> %
   (|recip| (((|Union| $ "failed") $) NIL))          
                                        -> recip : % -> Union(%,"failed")
   (|rem| (($ $ $) NIL))                -> ?rem? : (%,%) -> %
   (|sample| (($) NIL T CONST))         -> sample : () -> %
   (|shift| (($ $ (|Integer|)) 7))      -> shift : (%,Integer) -> %
   (|sup| (($ $ $) 6))                  -> sup : (%,%) -> %
   (|zero?| (((|Boolean|) $) NIL))      -> zero? : % -> Boolean
   (~= (((|Boolean|) $ $) NIL))         -> ?~=? : (%,%) -> Boolean
   (|divide| (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $) NIL))
                                        -> divide : (%,%) -> Record(quotient: %,remainder: %)
   (|exquo| (((|Union| $ "failed") $ $) NIL))
                                        -> exquo : (%,%) -> Union(%,"failed")
   (|subtractIfCan| (((|Union| $ "failed") $ $) 10))
                                        -> subtractIfCan : (%,%) -> Union(%,"failed")
\end{verbatim}

\sig{operationToSignature}{alistEntry}{signature}
\index[code]{defun!operationToSignature}
\index[code]{operationToSignature!defun}
\begin{chunk}{defun operationToSignature}
(defun operationToSignature (alistEntry) 
  (let (returnType args sig result)
    (setq result (make-operation (car alistEntry)))
    (dolist (item (cdr alistEntry))
      (setq sig (substitute '% '$ (car item)))
      (setq returnType (car sig))
      (setq args (cdr sig))
      (operation-add result (make-signature returnType args nil)))
    result))

\end{chunk}

As painful as it is, this code strives to reproduce the exact output
of the {\bf )show} command in Axiom.

Functions with the same name but multiple signatures, such as {\bf *},
are stored in a single operation instance. We have to break up the
multiple signatures into single signatures. We do this with the {\bf
  split} function.

Some signatures are in tabular format. Longer signatures are output
after the table.  There are special cases and we keep a list of these
in the {\bf *forceLongs* variable}. Sigh.

The tabular format has two columns, the second column is at character
position 40. The SBCL tabular output in format is broken so we had to
create the {\bf padTo38} function to add pad characters to signatures.

\index[code]{defvar!forcelongs}
\index[code]{forcelongs!defvar}
\begin{chunk}{defvar forcelongs}
(defvar *forceLongs* '("exquo"))

\end{chunk}

\sig{operations-show}{operationAlist}{values}
\index[code]{defun!operations-show}
\index[code]{operations-show!defun}
\begin{chunk}{defun operations-show}
(defun operations-show (operationAlist)
  (labels (
    ; split multiple signatures
    (split (string)
       (splitchar string #\newline))
    ; Axiom wants certain lines delayed for no reason
    (forceLong (sig)
      (let (opname)
        (setq opname (subseq sig 0 (1- (position #\: sig))))
        (member opname *forceLongs* :test #'string=)))
    ; Axiom wants a tabular display
    (padTo38 (string)
      (let ((excess (- 38 (length string)))
            (pad "                                     "))
        (concatenate 'string string (subseq pad 0 excess)))))
  (let (sigs longlines shortlines (column 0))
   (dolist (op operationAlist) 
     ; operationToSignature might return multiple signatures
     (setq sigs (format nil "~a" (operationToSignature op)))
     (setq sigs (split (subseq sigs 0 (1- (length sigs)))))
     ; classify the output by length
     (dolist (sig (nreverse sigs))
       (if (or (>= (length sig) 36) (forceLong sig))
         (push sig longlines)
         (push sig shortlines))))
    ; output the short lines
    (dolist (sig shortlines)
      (if (= column 0)
        (progn (format t " ~a" (padTo38 sig)) (setq column 1))
        (progn (format t "~a~%" sig) (setq column 0))))
   ; output the long lines
   (dolist (sig longlines)
     (format t "~& ~a~%" sig))
   (values))))

\end{chunk}


From Signatures to OperationAlist
\index[code]{defun!signatureToOperation}
\index[code]{signatureToOperation!defun}
\begin{chunk}{defun signatureToOperation}
(defun signatureToOperation (sig)
  (declare (ignore sig))
)
\end{chunk}

\chapter{The Parser}

The parser operates on the input stream step by step.

There are three possible approaches to the parser and these are left
``unchosen'' for the moment. There is the traditional Chomsky BNF
style, the Parsing Expression Grammar (PEG) \cite{Ford04}, and the
Pratt parser \cite{Prat73}.

PEG parsers reduce the ambiguity of choice, making parsing more
efficient. 

Pratt Parsers allow user modification of syntax. While this has not
been of interest to Axiom it has been used in the proof community.
Once proof technology is integrated and presented to users it will
probably be more important.

\section{ParserClass}

The {\bf *place*} 
\index[doc]{*place*} 
is the search path for the .spad files. These paths
are concatenated before the spad filenames.

\index[code]{defvar!*place*}
\index[code]{*place*!defvar}
\begin{chunk}{defvar place}
(defvar *place* "./") 
; "/research/20191011/src/algebra/")
; "axiom/src/algebra/")
; "/research/fricas/waldek/fricasNew/src/algebra/"

\end{chunk}

\index[fig]{defclass!ParserClass}
\index[fig]{ParserClass defclass}
\begin{table}[H]
\begin{center}
\label{tab:ParserClass}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Fieldname} & \textbf{initarg} & \textbf{initform} &
\textbf{accessor}\\
\hline
abbrev     & :abbrev     & nil & parser-abbrev\\
topcomment & :topcomment & nil & parser-topcomment\\
macros     & :macros     & nil & parser-macros\\
cdpsig     & :cdpsig     & nil & parser-cdpsig\\
with       & :with       & nil & parser-with\\
add        & :add        & nil & parser-add\\
\hline
\end{tabular}
\caption{{\bf defclass ParserClass}}
\end{center}
\end{table}

\index[code]{defclass!ParserClass}
\index[code]{ParserClass!defclass}
\begin{chunk}{defclass ParserClass}
(defclass ParserClass ()
  ((abbrev     :initarg :abbrev     :initform nil :accessor parser-abbrev)
   (topcomment :initarg :topcomment :initform nil :accessor parser-topcomment)
   (macros     :initarg :macros     :initform nil :accessor parser-macros)
   (cdpsig     :initarg :cdpsig     :initform nil :accessor parser-cdpsig)
   (with       :initarg :with       :initform nil :accessor parser-with)
   (add        :initarg :add        :initform nil :accessor parser-add)))

\end{chunk}

\index[code]{print-object!defmethod!ParserClass}
\index[code]{defmethod!print-object!ParserClass}
\index[code]{ParserClass!defmethod!print-object}
\begin{chunk}{defmethod print-object}
(defvar formatabbrev "~a")
(defvar formattopcomment "~a~%")
(defvar formatmacros "~a ==> ~a~%")
(defvar formatcdpsig "~a~%")

(defmethod print-object ((p ParserClass) stream)
  (format stream formatabbrev (parser-abbrev p))
  (format stream formattopcomment (parser-topcomment p))
  (format stream formatcdpsig (parser-cdpsig p)))

\end{chunk}

The {\bf theparse}
\index[doc]{theparse}
is a global variable holding the result of the parse.
It holds a {\bf ParserClass}
\index[doc]{ParserClass} 
object.

\index[code]{defvar!theparse}
\index[code]{theparse!defvar}
\begin{chunk}{defvar theparse}
(defvar theparse nil)

\end{chunk}

The {\bf make-Sourcecode} [p\pageref{lst:make-Sourcecode}]
\index[doc]{make-sourcecode!caller}
\index[all]{caller!make-sourcecode}
reads the file and constructs a 
{\bf sourcecode} [p\pageref{lst:sourcecode}] object.

The {bf make-Sourcecode} function constructs a {\bf sourcecode-pile}
field containing a ``useful'' version of the original source,
(e.g. the source stripped of $--$ comments and joining contiued lines)
so we can easily parse the result.

The {\bf Parse 1} 
\index[err]{Parse 1}
error occurs when the {\bf )abbrev} line is missing.
The {\bf )abbrev} line must occur before the code.

\sig{Parse}{filename}{(theparse,pile)}
\index[code]{defun!Parse}
\index[code]{Parse!defun}
\begin{chunk}{defun Parse}
; begin...for debugging
(defvar t1 nil "a copy of the source code for debugging")

(defun expandMacro (name) 
  (cdr (assoc name (parser-macros theparse))))

(defun P (filename)
 (setq t1 (make-sourcecode (concatenate 'string *place* filename ".spad")))
 (pretty (sourcecode-tree t1))
 (values))

(defun q (filename)
 (setq t1 (make-sourcecode 
             (concatenate 'string filename ".spad")))
 (pretty (sourcecode-tree t1))
 (values))

; end...for debugging

(defvar formatParse1 "Parse 1: ~%    In ~a~%    Missing )abbrev line~%")

(defun Parse (filename)
  (unwind-protect 
    (let (pile object alist iscat?)
      (setq t1 (make-Sourcecode (concatenate 'string *place* filename ".spad")))
      (setq pile (sourcecode-pile t1))
      (setq theparse (make-instance 'ParserClass))
      (multiple-value-setq (pile object) (FSM-abbrev pile)) 
      (unless object
        (error formatParse1 (concatenate 'string *place* filename ".spad")))
      (setf (parser-abbrev theparse) object) 
      (multiple-value-setq (pile object) (FSM-comment pile))
      (setf (parser-topcomment theparse) object)
      (multiple-value-setq (pile alist) (FSM-macros pile)) 
      (setf (parser-macros theparse) alist)
      (multiple-value-setq (pile object) (FSM-cdpsig pile theparse))
      (setf (parser-cdpsig theparse) object)
      (multiple-value-setq (pile iscat?) (FSM-isCategory? pile theparse))
      (if iscat?
        (multiple-value-setq (pile object) (FSM-catBody pile theparse))
        (multiple-value-setq (pile object) (FSM-dpBody pile theparse)))
      (multiple-value-setq (pile object) (FSM-variables pile theparse))
  (print (list 'pile0 (first pile)))
      (values theparse pile))
  (print (list 'gotit))))

\end{chunk}

\section{make-Sourcecode}

The {bf make-Sourcecode} function constructs a {\bf sourcecode}
instance containing the original source, the source stripped
of $--$ comments, joining contiued lines, and finally 
converted from pile form to tree form. 

The {\bf make-Sourcecode} function
\index[doc]{make-Sourcecode}
reads a spad file in as a list of strings. All minus comments
are deleted, using {\bf noComments}, from the initial $--$ to 
the end of the line.

The result is a {\bf sourcecode} instance contains the raw
contents of the file, the cleaned up version called a pile,
and a tree version, containing parens indicating depth.

Then, using {\bf oneline}, any line that has a trailing escape 
character (the underscore) gets merged with the following line.

The {\bf escaped?} predicate checks for the trailing underscore.
The {\bf oneline} process, when it finds a trailing underscore,
will join the lines(s) until a non-escaped line occurs.

The {\bf blankline?} predicate checks for a blank line. 
These are elimiated as part of the {\bf oneline} process.

A bit of clever optimization is possible if the {\bf oneline}
function processed the list of strings in reverse so the two
calls to nreverse could be removed. 

\sig{make-Sourcecode}{filename}{sourcecode}
\index[code]{defun!make-Sourcecode}
\index[code]{make-Sourcecode!defun}
\label{lst:make-Sourcecode}
\begin{chunk}{defun make-Sourcecode}

(defvar formatMakeSourcecode "make-Sourcecode: ERROR: File ~a does not exist")

; FILENAME -> SOURCECODE
(defun make-Sourcecode (filename)
  (labels (
    ; LINE -> BOOLEAN
    (blankline? (line)
      (string= "" (trim line)))
    ; LINE -> LINE
    (boot? (line)
      (when (>= (length line) 3)
        (string-equal ")bo" (subseq line 0 3))))
    ; LINE -> LINE
    (noComments (line)
      (subseq line 0 (search "--" line)))
    ; LINE -> BOOLEAN
    (escaped? (line)
      (let ((len (length line)))
        (and (> len 0) (char= #\_ (char line (1- len))))))
    ; LINELIST -> LINELIST
    (oneline (linelist)
      (let (gather result)
        (dolist (line linelist)
          (let ((underscored? (escaped? line)))
            (cond
              ; skip blank lines
              ((blankline? line))
              ; first time
              ((and (not gather) underscored?)
                (setq gather (string-right-trim '(#\_) line)))
              ; still more
              ((and gather underscored?)
                (setq gather 
                  (concatenate 'string gather " " (string-trim '(#\space #\_) line))))
              ; last one
              ((and gather (not underscored?))
                (push
                  (concatenate 'string gather " " (string-trim '(#\space #\_) line))
                 result)
                (setq gather nil))
              (t 
                (push line result)))))
      result))  )
  (let (rawcode listLine pile instance)
    (with-open-file (file filename :direction :input :if-does-not-exist nil)
      (if file
        (let ((done (gensym)))
          (do ((line (read-line file nil done) (read-line file nil done)))
              ((eq line done) (setq pile (nreverse (oneline (nreverse listLine)))))
              (push line rawcode)
              (unless (boot? line)
                (push (noComments line) listLine)))
           (setq instance
             (make-instance 'sourcecode :name filename 
                                        :rawcode (nreverse rawcode)
                                        :pile pile
                                        :tree (pile2tree pile)))
           (when (= *comptrace* 100) 
             (format t formatname (sourcecode-name instance))
             (format t formatrawcode (sourcecode-rawcode instance)))
           instance)
;  (format stream formatpile (sourcecode-pile source))
;  (pretty (sourcecode-tree source)))

     (error formatMakeSourcecode filename))))))

\end{chunk}

\section{sourcecode-pile}

The {\bf sourcecode} type contains 4 fields:
%\index[code]{sourcecode}
\begin{enumerate}
\item name -- the filename of the source file
\item rawcode -- the exact source text in the file
\item pile -- remove $--$ comments, continued lines
\item tree -- piled strings to a nested tree
\end{enumerate}

\subsection{The sourcecode class}

\index[fig]{defclass!sourcecode}
\index[fig]{sourcecode defclass}
\begin{table}[H]
\begin{center}
\label{tab:sourcecode}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Fieldname} & \textbf{initarg} & \textbf{initform} &
\textbf{accessor}\\
\hline
name    & :name    & nil & sourcecode-name\\
rawcode & :rawcode & nil & sourcecode-rawcode\\
pile    & :pile    & nil & sourcecode-pile\\
tree    & :tree    & nil & sourcecode-tree\\
\hline
\end{tabular}
\caption{{\bf defclass sourcecode}}
\end{center}
\end{table}

\index[code]{defclass!sourcecode}
\index[code]{sourcecode!defclass}
\label{lst:sourcecode}
\begin{chunk}{defclass sourcecode}
(defclass sourcecode ()
  ((name    :initarg :name    :initform nil :accessor sourcecode-name)
   (rawcode :initarg :rawcode :initform nil :accessor sourcecode-rawcode)
   (pile    :initarg :pile    :initform nil :accessor sourcecode-pile)
   (tree    :initarg :tree    :initform nil :accessor sourcecode-tree)))

\end{chunk}

\index[code]{print-object!defmethod!sourcecode}
\index[code]{defmethod!print-object!sourcecode}
\index[code]{sourcecode!defmethod!print-object}
\begin{chunk}{defmethod print-object}
(defvar formatname "name: ~a~%")
(defvar formatrawcode "rawcode: ~a~%")
(defvar formatpile "pile: ~a~%")

;(defmethod print-object ((source sourcecode) stream))
;  (format stream formatname (sourcecode-name source)))
;  (format stream formatrawcode (sourcecode-rawcode source))
;  (format stream formatpile (sourcecode-pile source))
;  (pretty (sourcecode-tree source)))

\end{chunk}

Spad is indentation sensitive so the rawcode semantics depends
on the indentation.

\section{FSM-abbrev}

\subsection{Recognize abbreviation command line}

An {\bf )abbrev} line consists of 4 tokens, for example,
\begin{verbatim}
   )abbrev domain BITS Bits
\end{verbatim}
where the domain is one of "category", "domain", or "package",
which can be of any case. The BITS field must be less than 8
characters and all uppercase, and the Bits field must be a
valid constructor name.

\subsection{The abbreviation class}

The {\bf abbreviation}
\index[code]{abbreviation!defclass}
\index[code]{defclass!abbreviation}
holds the result of parsing an )abbrev line.

The {\bf FSM-abbrev} 
\index[code]{FSM-abbrev!function}
\index[code]{function!FSM-abbrev}
function parses an )abbrev line.

\index[fig]{defclass!abbreviation}
\index[fig]{abbreviation defclass}
\begin{table}[H]
\begin{center}
\label{tab:abbreviation}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Fieldname} & \textbf{initarg} & \textbf{initform} &
\textbf{accessor}\\
\hline
class  & :class  & nil & abbreviation-class\\
abbrev & :abbrev & nil & abbreviation-abbrev\\
string & :string & ""  & abbreviation-string\\
name   & :name   & nil & abbreviation-name\\
\hline
\end{tabular}
\caption{{\bf defclass abbreviation}}
\end{center}
\end{table}

\index[code]{defclass!abbreviation}
\index[code]{abbreviation!defclass}
\begin{chunk}{defclass abbreviation}
(defclass abbreviation ()
  ((class  :initarg :class  :initform nil :accessor abbreviation-class)
   (abbrev :initarg :abbrev :initform nil :accessor abbreviation-abbrev)
   (string :initarg :string :initform ""  :accessor abbreviation-string)
   (name   :initarg :name   :initform nil :accessor abbreviation-name)))

\end{chunk}

\sig{make-instance}{(class,abbrev,string)}{abbreviation}
\index[code]{defun!make-abbreviation}
\index[code]{make-abbreviation!defun}
\begin{chunk}{defun make-abbreviation}
(defun make-abbreviation (class abbrev string)
  (make-instance 'abbreviation :class class :abbrev abbrev :string string
                               :name (intern string)))

\end{chunk}

\index[code]{print-object!defmethod!abbreviation}
\index[code]{defmethod!print-object!abbreviation}
\index[code]{abbreviation!defmethod!print-object}
\begin{chunk}{defmethod print-object}
(defvar formatAbbreviation ")abbrev ~a ~a ~a~%")

(defmethod print-object ((abb abbreviation) stream)
  (format stream formatAbbreviation
    (abbreviation-class abb) 
    (abbreviation-abbrev abb)
    (abbreviation-string abb)))

\end{chunk}

The {\bf FSM-abbrev}
\index[doc]{FSM-abbrev}
function handles the abbrev line which contains 4 symbols.

An UABBREV non-terminal consists of 1 to 8 CAP characters
where a CAP character is either an uppercase character or
a number.

\index[fig]{syntax!UABBREV}
\index[fig]{UABBREV syntax}
\begin{figure}[ht]
\centering
\begin{tikzpicture}[
        point/.style={coordinate},>=stealth',thick,draw=black!50,
        tip/.style={->,shorten >=0.007pt},every join/.style={rounded corners},
        hv path/.style={to path={-| (\tikztotarget)}},
        vh path/.style={to path={|- (\tikztotarget)}}, node distance=1cm,
        text height=1.5ex,text depth=.25ex % align text horizontally
    ]
    \matrix[column sep=4mm] {
        \node           (p1) [point]    {}; &
        \node[blue!100] (c1) [terminal] {{\sl uchar}};&
        \node[blue!100] (c2) [terminal] {{\sl uchar}};&
        \node[blue!100] (c3) [terminal] {{\sl uchar}};&
        \node[blue!100] (c4) [terminal] {{\sl uchar}};&
        \node[blue!100] (c5) [terminal] {{\sl uchar}};&
        \node[blue!100] (c6) [terminal] {{\sl uchar}};&
        \node[blue!100] (c7) [terminal] {{\sl uchar}};&
        \node[blue!100] (c8) [terminal] {{\sl uchar}};\\
    };

    { [start chain]
        \chainin (p1);
        \chainin (c1) [join=by tip];
        \chainin (c2) [join=by tip];
        \chainin (c3) [join=by tip];
        \chainin (c4) [join=by tip];
        \chainin (c5) [join=by tip];
        \chainin (c6) [join=by tip];
        \chainin (c7) [join=by tip];
        \chainin (c8) [join=by tip];
  }
\end{tikzpicture}
\begin{verbatim}
UABBREV ::= UCHAR 
          | UCHAR UCHAR 
          | UCHAR UCHAR UCHAR 
          | UCHAR UCHAR UCHAR UCHAR
          | UCHAR UCHAR UCHAR UCHAR UCHAR
          | UCHAR UCHAR UCHAR UCHAR UCHAR UCHAR 
          | UCHAR UCHAR UCHAR UCHAR UCHAR UCHAR UCHAR
          | UCHAR UCHAR UCHAR UCHAR UCHAR UCHAR UCHAR UCHAR
\end{verbatim}
\caption{UABBREV syntax}
\label{UABBREVsyntax}
\end{figure}

\index[fig]{syntax!ABBREV}
\index[fig]{ABBREV syntax}
\begin{figure}[H]
\centering
\begin{tikzpicture}[
        point/.style={coordinate},>=stealth',thick,draw=black!50,
        tip/.style={->,shorten >=0.007pt},every join/.style={rounded corners},
        hv path/.style={to path={-| (\tikztotarget)}},
        vh path/.style={to path={|- (\tikztotarget)}}, node distance=1cm,
        text height=1.5ex,text depth=.25ex % align text horizontally
    ]
    \matrix[column sep=4mm] {
        \node              (p1)   [point]       {}; &
        \node              (abb)  [terminal]    {)abbrev};&
        \node              (p2)   [point]       {}; &
        \node[above of=p2] (cat)  [terminal]    {category};
        \node[below of=p2] (pak)  [terminal]    {package};
        \node              (dom)  [terminal]    {domain};&
        \node              (p9)   [point]       {}; &
        \node              (abb1) [nonterminal] {{\sl uabbrev}};&
        \node[blue!100]    (cdp)  [nonterminal] {{\sl cdpname}};\\
    };

    { [start chain]
        \chainin (p1);
        \chainin (abb)   [join=by tip];
        \chainin (p2)    [join];
        { [start branch=cat]
        \chainin (cat)   [join=by {vh path,tip}];
        \chainin (p9)    [join=by {hv path,tip}];
        }
        { [start branch=pkg]
        \chainin (pak)   [join=with p2 by {vh path,tip}];
        \chainin (p9)    [join=by {hv path,tip}];
        }
        \chainin (dom)   [join];
        \chainin (p9)    [join];
        \chainin (abb1)  [join];
        \chainin (cdp)   [join];
  }
\end{tikzpicture}
\begin{verbatim}
ABBREV ::= ')abbrev' ['category' | 'domain' | 'package'] UABBREV CONSTRUCT
\end{verbatim}
\caption{ABBREV syntax}
\label{ABBREVsyntax}
\end{figure}

\sig{FSM-abbrev}{linelist}{(linelist,abbreviation)}
\index[code]{defun!FSM-abbrev}
\index[code]{FSM-abbrev!defun}
\begin{chunk}{defun FSM-abbrev}
(defun FSM-abbrev (linelist)
  (let ((split (splitchar (first linelist) #\space)) result)
    (when
      (fsm-and 
        (fsm-match ")abbrev")
        (fsm-or
          (fsm-match "category")
          (fsm-match "domain")
          (fsm-match "package"))
        (fsm-abbname)
        (fsm-word))
      (values
        (rest linelist)
        (make-abbreviation (third result) (second result) (first result))))))

\end{chunk}

\sig{FSM-symbol}{linelist}{(linelist,symboliation)}
\index[code]{defun!FSM-symbol}
\index[code]{FSM-symbol!defun}
\begin{chunk}{defun FSM-symbol}
(defun FSM-symbol (linelist)
  (let (result)
    (with-input-from-string (s (first linelist))
      (setf (readtable-case *readtable*) :preserve)
      (setq result (read s))
      (setf (readtable-case *readtable*) :upcase))
    (when result
      (setf (first linelist)
        (subseq (trim (first linelist)) (length (string result)))))
    (values linelist (symbolp result) result)))

\end{chunk}

\section{FSM-comment}

\subsection{Parse Comments}

The {\bf FSM-comment} function strips off the comments from linelist,
gathering them together. It returns 2 values, the first is a new
linelist without the comments. The second is a gather object
containing the comment lines.

\sig{FSM-comment}{linelist}{linelist,list(comments)}
\index[code]{defun!FSM-comment}
\index[code]{FSM-comment!defun}
\begin{chunk}{defun FSM-comment}
(defun FSM-comment (linelist)
  (let (comment result)
    (setq comment (make-instance 'gather))
    (values
      (FSM-gather linelist (FSM-startsWith "++") comment)
      comment)))

\end{chunk}

\section{FSM-macros}

The {\bf FSM-macros} 
\index[doc]{FSM-macros}
function scans the source code for macros. If one is found the
function creates a pair (name . definition) and puts it on 
an association list. The result is the program text minus the
macros and the association list of macros. So, for example, a
source code line that reads
\begin{verbatim}
  SIG ==> BitAggregate() with
\end{verbatim}
will become the pair
\begin{verbatim}
  (SIG . "  BitAggregate() with")
\end{verbatim}

A minor wrinkle is that the macro (e.g. SIG) has
a meaningful indentation. We need to compute the
indentation, clip out that many spaces, and later
add it into the first returned line. The actual pair
created looks like
\begin{verbatim}
  (SIG . "  BitAggregate() with")
\end{verbatim}

\sig{FSM-macros}{linelist}{(linelist,macroAlist)}
\index[code]{defun!FSM-macros}
\index[code]{FSM-macros!defun}
\begin{chunk}{defun FSM-macros}
(defun FSM-macros (linelist)
  (labels (
    ; is this a macro line?
    (hasMacros? (linelist)
     (loop for line in linelist
       when (search "==>" line) return t))
    (join (stringlist)
      (format nil "~{~a~^ ~}" stringlist))
    (makeAlist (gather)
      (let (alllines line name def indent spaces)
       ; get all the lines in the macro
       (setq alllines (gather-lines gather))
       ; remember the indent
       (setq indent (indent (first alllines)))
       (setq spaces (subseq (first alllines) 0 indent))
       ; hack out the macro name
       (setq line (splitchar (trim (pop alllines)) #\space))
       (setq name (intern (first line)))
       (setq def (cons (join (cddr line)) alllines))
       ; insert indent spaces in first macro line
       (setf (first def) (concatenate 'string spaces (first def)))
       (cons name def)))
  )
  (let (macro macroAlist)
    (loop while (hasMacros? linelist) do
      (multiple-value-setq (linelist macro) (FSM-extract1Macro linelist))
      (push (makeAlist macro) macroAlist)) 
    (values linelist macroAlist))))

\end{chunk}

Sometimes we just want to know what symbols are actually the
name of a macro. The {\bf FSM-macroNames} function 
\index[doc]{FSM-macroNames} 
returns a list of those names.

\sig{FSM-macroNames}{theparse}{list(macronames)}
\index[code]{defun!FSM-macroNames}
\index[code]{FSM-macroNames!defun}
\begin{chunk}{defun FSM-macroNames}
(defun FSM-macroNames (theparse)
  (mapcar #'(lambda (x) (car x)) (parser-macros theparse)))

\end{chunk}

\section{FSM-cdpsig}

\subsection{The CDPSigClass class}

\index[fig]{defclass!CDPSigClass}
\index[fig]{CDPSigClass defclass}
\begin{table}[H]
\begin{center}
\label{tab:CDPSigClass}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Fieldname} & \textbf{initarg} & \textbf{initform} &
\textbf{accessor}\\
\hline
cdpname  & :classname & nil & CDPSigClass-cdpname\\
argslist & :argslist  & nil & CDPSigClass-argslist\\
cdptag   & :cdptag    & nil & CDPSigClass-cdptag\\
\hline
\end{tabular}
\caption{{\bf defclass CDPSigClass}}
\end{center}
\end{table}

\index[code]{defclass!CDPSigClass}
\index[code]{CDPSigClass!defclass}
\begin{chunk}{defclass CDPSigClass}
(defclass CDPSigClass ()
  ((cdpname  :initarg :classname :initform nil :accessor CDPSigClass-cdpname)
   (argslist :initarg :argslist  :initform nil :accessor CDPSigClass-argslist)
   (cdptag   :initarg :cdptag    :initform nil :accessor CDPSigClass-cdptag)))

\end{chunk}

\index[code]{print-object!defmethod!CDPSigClass}
\index[code]{defmethod!print-object!CDPSigClass}
\index[code]{CDPSigClass!defmethod!print-object}
\begin{chunk}{defmethod print-object}
(defvar formatcat "~a~a : Category == ~%")
(defvar formatdp "~a~a : ~%")

(defmethod print-object ((cdp CDPSigClass) stream)
  (if (string-equal "category" (CDPSigClass-cdptag cdp))
    (format stream formatcat (CDPSigClass-cdpname cdp) (CDPSigClass-argslist cdp))
    (format stream formatdp  (CDPSigClass-cdpname cdp) (CDPSigClass-argslist cdp))))

\end{chunk}

The {\bf FSM-cdpsig} 
\index[doc]{FSM-cdpsig} 
function expects to be called to handle the
definition of a category, domain, or package. It constructs a
{\bf CDPSigClass} object to hold the name and argument list.
At this point, the argument list is essentially unparsed,
consisting of the top level string starting at the open parenthesis
and ending at the matching closed parenthesis. Further processing
will parse the contents of this list. This is necessary since the
variables could be macros in the body which we have not yet seen.

\sig{FSM-cdpsig}{(linelist,theparse)}{(linelist,CDPSigClass)}
\index[code]{defun!FSM-cdpsig}
\index[code]{FSM-cdpsig!defun}
\begin{chunk}{defun FSM-cdpsig}
(defun FSM-cdpsig (linelist theparse)
  (let ((split (splitchar (first linelist) #\space)) result cdpname argslist)
    (when (FSM-startsWith (first split))
      (setq result (make-instance 'CDPSigClass))
      (setf (CDPSigClass-cdptag result) (abbreviation-class (parser-abbrev theparse)))
      (setq cdpname (abbreviation-string (parser-abbrev theparse)))
      (setf (CDPSigClass-cdpname result) cdpname)
      (setq linelist (cons (subseq (pop linelist) (length cdpname)) linelist))
      (multiple-value-setq (linelist argslist) (FSM-gatherList linelist))
      (setf (CDPSigClass-argslist result) argslist)
      (values linelist result))))

\end{chunk}

\section{FSM-isCategory?}

\sig{FSM-isCategory?}{(linelist,theparse)}{(linelist,boolean)}
\index[code]{defun!FSM-isCategory?}
\index[code]{FSM-isCategory?!defun}
\begin{chunk}{defun FSM-isCategory?}
(defun FSM-isCategory? (linelist theparse)
  (let ((split (splitchar (first linelist) #\space)) result tmp)
     (FSM-match "")
     (FSM-match ":")
     (setq tmp (abbreviation-class (parser-abbrev theparse)))
     (if split
       (setq result (list (joinsplit split #\space) (rest linelist)))
       (setq result (rest linelist)))
     (if (and (string-equal tmp "category") (FSM-match tmp))
       (values result t)
       (values result nil))))

\end{chunk}


\section{FSM-catBody}

\sig{FSM-catBody}{(linelist,theparse)}{list(tokens)}
\index[code]{defun!FSM-catBody}
\index[code]{FSM-catBody!defun}
\begin{chunk}{defun FSM-catBody}
(defun FSM-catBody (linelist theparse) 
  (let ((split (splitchar (first linelist) #\space)) result)
    (setq result (FSM-match "=="))
    (values (cons (joinsplit split #\ ) (rest linelist)) result)))

\end{chunk}

\section{FSM-dpBody}

\sig{FSM-dpBody}{(linelist,theparse)}{nil}
\index[code]{defun!FSM-dpBody}
\index[code]{FSM-dpBody!defun}
\begin{chunk}{defun FSM-dpBody}
(defun FSM-dpBody (linelist theparse) 
  (let ((split (splitchar (first linelist) #\space)) result)
    (values (cons (joinsplit split #\ ) (rest linelist)) result)))

\end{chunk}

\section{FSM-variables}

\index[fig]{syntax!VAR}
\index[fig]{VAR syntax}
\begin{figure}[H]
\centering
\begin{tikzpicture}[
        point/.style={coordinate},>=stealth',thick,draw=black!50,
        tip/.style={->,shorten >=0.007pt},every join/.style={rounded corners},
        hv path/.style={to path={-| (\tikztotarget)}},
        vh path/.style={to path={|- (\tikztotarget)}}, node distance=1cm,
        text height=1.5ex,text depth=.25ex % align text horizontally
    ]
    \matrix[column sep=4mm] {
        \node           (p1)      [point]       {};               &
        \node           (abb)     [nonterminal] {{\sl symbol}};   &
        \node           (p2)      [point]       {};               &
        \node           (wspace1) [nonterminal] {' '};            &
        \node           (p3)      [point]       {};               &
        \node           (colon)   [terminal]    {':'};            &
        \node           (p4)      [point]       {};               &
        \node           (wspace2) [nonterminal] {' '};            &
        \node           (p5)      [point]       {};               &
        \node           (tspec)   [nonterminal] {{\sl typespec}}; &
        \node           (p6)      [point]       {};               &
        \node[blue!100] (end)     [terminal]    {{\sl accept}};   \\
    };

    { [start chain]
        \chainin (p1);
        \chainin (abb)     [join=by tip];
        \chainin (p2)      [join,join=with p3 by {skip loop=6mm,tip}];
        \chainin (wspace1) [join];
        \chainin (p3)      [join];
        \chainin (colon)   [join];
        \chainin (p4)      [join,join=with p5 by {skip loop=6mm,tip}];
        \chainin (wspace2) [join];
        \chainin (p5)      [join];
        \chainin (tspec)   [join];
        \chainin (p6)      [join,join=with p2 by {skip loop=-6mm,tip}];
        \chainin (end)     [join];
  }
\end{tikzpicture}
\begin{verbatim}
VAR ::= SYMBOL [ [WSPACE]* ':' [WSPACE]* TYPESPEC ]
\end{verbatim}
\caption{VAR syntax}
\label{VARsyntax}
\end{figure}

\sig{FSM-VAR}{linelist}{(linelist,var)}
\index[code]{defun!FSM-VAR}
\index[code]{FSM-VAR!defun}
\begin{chunk}{defun FSM-VAR}
(defun FSM-VAR (linelist)
  (let ((split (splitchar (first linelist) #\space)) result)
    (when
      (FSM-and 
        (setq varname (FSM-symbol))
        (FSM-optional
          (FSM-skipwspace)
          (FSM-colon)
          (FSM-skipwspace)
          (setq spec (FSM-typespec)))))
      (values
        linelist
        (make-FSM-VAR varname spec))))

\end{chunk}

\index[fig]{syntax!TYPESPEC}
\index[fig]{TYPESPEC syntax}
\begin{figure}[H]
\centering
\begin{tikzpicture}[
        point/.style={coordinate},>=stealth',thick,draw=black!50,
        tip/.style={->,shorten >=0.007pt},every join/.style={rounded corners},
        hv path/.style={to path={-| (\tikztotarget)}},
        vh path/.style={to path={|- (\tikztotarget)}}, node distance=0.3cm,
        text height=1.5ex,text depth=.25ex % align text horizontally
    ]
    \matrix[column sep=4mm] {
      \node (p1)   [point]       {}; &
      \node (cdp)  [nonterminal] {{\sl cpdname}}; &
      \node (cdp7) [point]       {}; &
      \node (cdp1) [terminal]    {'('}; &
      \node (cdpa) [point]       {}; &
      \node (cdp2) [nonterminal] {{\sl typespec}}; &
      \node (cdp8) [point]       {}; &
      \node (cdp3) [terminal]    {','}; &
      \node (cdp4) [nonterminal] {{\sl typespec}}; &
      \node (cdp9) [point]       {}; &
      \node (cdp5) [terminal]    {')'}; &
      \node (cdp6) [point]       {}; \\

      \node (mid0) [point] {}; 
      \node (mid1) [point] {}; 
      & & & & & & & & & & &
      \node[blue!100] (mid2) [terminal] {{\sl accept}}; \\

      \node (ap1)   [point]       {}; &
      \node (acdp)  [nonterminal] {{\sl join}}; &
      \node (acdpa) [point]       {}; &
      \node (acdp1) [terminal]    {'('}; &
      \node (acdpb) [point]       {}; &
      \node (acdp2) [nonterminal] {{\sl typespec}}; &
      \node (acdp8) [point]       {}; &
      \node (acdp3) [terminal]    {','}; &
      \node (acdp4) [nonterminal] {{\sl typespec}}; &
      \node (acdp9) [point]       {}; &
      \node (acdp5) [terminal]    {')'}; &
      \node (acdp6) [point]       {}; \\
    };

    { [start chain]
      \chainin              (mid0) [join];
      \chainin              (mid1) [join];
       { [start branch=cdp]
         \chainin           (cdp)   [join=by {vh path,tip}];
         \chainin           (cdp7)  [join];
         \chainin           (cdp1)  [join];
         \chainin           (cdpa)  [join];
         \chainin           (cdp2)  [join];
         \chainin           (cdp8)  [join,join=with cdp9 by {skip loop=-5mm,tip}];
         \chainin           (cdp3)  [join];
         \chainin           (cdp4)  [join];
         \chainin           (cdp9)  [join,join=with cdp8 by {skip loop=5mm,tip}];
         \chainin           (cdp9)  [join];
         \chainin           (cdp9)  [join,join=with cdpa by {skip loop=8mm,tip}];
         \chainin           (cdp5)  [join];
         \chainin           (cdp6)  [join,join=with cdp7 by {skip loop=10mm,tip}];
         \chainin           (mid2)  [join=by {hv path,tip}];
       }
       { [start branch=acdp]
         \chainin           (ap1)   [join=by {hv path,tip}];
         \chainin           (acdp)  [join];
         \chainin           (acdpa) [join];
         \chainin           (acdp1) [join];
         \chainin           (acdpb) [join];
         \chainin           (acdp2) [join];
         \chainin           (acdp8) [join,join=with acdp9 by {skip loop=-5mm,tip}];
         \chainin           (acdp3) [join];
         \chainin           (acdp4) [join];
         \chainin           (acdp9) [join,join=with acdp8 by {skip loop=5mm,tip}];
         \chainin           (acdp5) [join];
         \chainin           (mid2)  [join=by {hv path,tip}];
       }
      \chainin[blue!100] (mid2);
  }
\end{tikzpicture}
\begin{verbatim}
TYPESPEC ::= CDPNAME [ '(' [ TYPESPEC [ ',' TYPESPEC ]* ] ')']
           | JOIN '(' TYPESPEC [ ',' TYPESPEC ] ')'
\end{verbatim}
\caption{TYPESPEC syntax}
\label{TYPESPECsyntax}
\end{figure}

\subsection{The FSM-VAR class}

\index[fig]{defclass!FSM-VAR}
\index[fig]{FSM-VAR defclass}
\begin{table}[H]
\begin{center}
\label{tab:FSM-VAR}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Fieldname} & \textbf{initarg} & \textbf{accessor}\\
\hline
variable  & :variable  & FSM-VAR-variable\\
paramtype & :paramtype & FSM-VAR-paramtype\\
\hline
\end{tabular}
\caption{{\bf defclass FSM-VAR}}
\end{center}
\end{table}

\index[code]{defclass!FSM-VAR}
\index[code]{FSM-VAR!defclass}
\begin{chunk}{defclass FSM-VAR}
(defclass FSM-VAR ()
  ((variable   :initarg :variable  :accessor FSM-VAR-variable)
   (paramtype  :initarg :paramtype :accessor FSM-VAR-paramtype)))

\end{chunk}

\index[code]{print-object!defmethod!FSM-VAR}
\index[code]{defmethod!print-object!FSM-VAR}
\index[code]{FSM-VAR!defmethod!print-object}
\begin{chunk}{defmethod print-object}
(defmethod print-object ((param FSM-VAR) stream)
  (format stream "~a:~a"
    (FSM-VAR-variable param)
    (FSM-VAR-paramtype param)))

\end{chunk}

The {\bf FSM-variables} 
\index[doc]{FSM-variables}
function is called to ``clean up'' the
variables of a type definition. These are found in two places.
Either they are in the argument list where the variable name
is followed by a colon or they are in the body where the 
variable name is followed by a colon.

\sig{FSM-variables}{(linelist,theparse)}{nil}
\index[code]{defun!FSM-variables}
\index[code]{FSM!defun-variables}
\begin{chunk}{defun FSM-variables}
(defun FSM-variables (linelist theparse)
  (print (list 'fsm-variables 
    (fsm-gathervars (cdpsigclass-argslist (parser-cdpsig theparse)))))
  (values linelist nil))
\end{chunk}

\section{Parser support functions}

These two functions, {\bf splitchar}
\index[doc]{splitchar}
and {\bf joinsplit}
\index[doc]{joinsplit}
are essentiall inverses of each other. So
\begin{verbatim}
   (joinsplit (splitchar somestring #\space) #\space)
\end{verbatim}
should return the original string, without leading or
trailing spaces.

The {\bf splitchar} 
\index[doc]{splitchar}
function will take a {\bf string} and
break the string apart every place it sees the {\bf char}.

\sig{splitchar}{(string,char)}{list(token)}
\index[code]{defun!splitchar}
\index[code]{splitchar!defun}
\begin{chunk}{defun splitchar}
(defun splitchar (string char)
    (loop for i = 0 then (1+ j)
      as j = (position char string :start i :test #'char=)
      collect (subseq string i j)
      while j))

\end{chunk}

The {\bf joinsplit} function will that a list of strings,
called the {\bf split} and concatenate them, inserting the
{\bf char} character between the strings.

Note that this can be used to construct a comma-separated
list by
\begin{verbatim}
    (joinsplit somestring #\,)
\end{verbatim}

\sig{joinsplit}{(list(token),char)}{string}
\index[code]{defun!joinsplit}
\index[code]{joinsplit!defun}
\begin{chunk}{defun joinsplit}
(defun joinsplit (split char)
  (let ((charstr (string char)) result)
    (setq result
      (apply #'concatenate 'string
        (loop for word in split
          collect word collect charstr)))
   (subseq result 0 (1- (length result)))))

\end{chunk}

The {\bf explode}
\index[doc]{explode}
turns a string into characters.
\sig{explode}{string}{list char}
\index[code]{defun!explode}
\index[code]{explode!defun}
\begin{chunk}{defun explode}
(defun explode (string)
  (loop for c across string collect c))

\end{chunk}

\index[fig]{syntax!SYMBOL}
\index[fig]{SYMBOL syntax}
\begin{figure}[H]
\centering
\begin{tikzpicture}[
        point/.style={coordinate},>=stealth',thick,draw=black!50,
        tip/.style={->,shorten >=0.007pt},every join/.style={rounded corners},
        hv path/.style={to path={-| (\tikztotarget)}},
        vh path/.style={to path={|- (\tikztotarget)}},
        text height=1.5ex,text depth=.25ex % align text horizontally
    ]
    \matrix[column sep=4mm] {
        & & & & \node (letter) [terminal] {letter};  & & \\
        \node (p1)      [point]    {}; & 
        \node (letter1) [terminal] {letter}; &
        \node (p2)      [point]    {}; & 
        \node (p3)      [point]    {}; & 
        \node (p4)      [point]    {}; &
        \node (p5)      [point]    {}; &
        \node (p6)      [point]    {}; \\
        & & & & \node (digit) [terminal] {digit};  & & \\
    };

    { [start chain]
        \chainin (p1);
        \chainin (letter1)      [join];
        \chainin (p2)           [join];
        \chainin (p3)           [join];
        \chainin (p3)           [join=with letter by {hv path}];];
        \chainin (p3)           [join=with digit  by {hv path}];];
        \chainin (p4)           [join];
        { [start branch=letter]
          \chainin (letter)     [join=with p5 by {vh path}];
        }
        { [start branch=digit]
          \chainin (digit)      [join=with p5 by {vh path}];
        }
        \chainin (p5)           [join];
        \chainin (p6)           [join];
    }
\end{tikzpicture}
\begin{verbatim}
SYMBOL := letter [ letter | digit ]*
\end{verbatim}
\caption{SYMBOL syntax}
\label{SYMBOLsyntax}
\end{figure}

\index[fig]{syntax!UNSIGNED}
\index[fig]{UNSIGNED syntax}
\begin{figure}[H]
\centering
\begin{tikzpicture}[
        point/.style={coordinate},>=stealth',thick,draw=black!50,
        tip/.style={->,shorten >=0.007pt},every join/.style={rounded corners},
        hv path/.style={to path={-| (\tikztotarget)}},
        vh path/.style={to path={|- (\tikztotarget)}},
        text height=1.5ex,text depth=.25ex % align text horizontally
    ]
    \matrix[column sep=4mm] {
      \node (p1)     [point]    {};  &
      \node (p2)     [point]    {};  &
      \node (digit)  [terminal] {digit}; &
      \node (p3)     [point]    {};  &
      \node (p4)     [point]    {}; \\
    };

    { [start chain]
        \chainin (p1)     [join];
        \chainin (p2)     [join,join=with p3 by {skip loop=5mm,tip}];
        \chainin (digit)  [join];
        \chainin (p3)     [join];
        \chainin (p4)     [join];
    }
\end{tikzpicture}
\begin{verbatim}
UNSIGNED := digit [ digit ]*
\end{verbatim}
\caption{UNSIGNED syntax}
\label{UNSIGNEDsyntax}
\end{figure}

\index[fig]{syntax!FLOAT}
\index[fig]{FLOAT syntax}
\begin{figure}[H]
\centering
\begin{tikzpicture}[
        point/.style={coordinate},>=stealth',thick,draw=black!50,
        tip/.style={->,shorten >=0.007pt},every join/.style={rounded corners},
        hv path/.style={to path={-| (\tikztotarget)}},
        vh path/.style={to path={|- (\tikztotarget)}},
        text height=1.5ex,text depth=.25ex % align text horizontally
    ]
    \matrix[column sep=4mm] {
        % First row:
        & & & & & & &  & & & & \node (plus) [terminal] {+};\\
        % Second row:
        \node (p1)    [point]       {};         &
        \node (ui1)   [nonterminal] {unsigned}; &
        \node (p2)    [point]       {};         &
        \node (dot)   [terminal]    {.};        &
        \node (p3)    [point]       {};         &
        \node (digit) [nonterminal] {unsigned}; &
        \node (p4)    [point]       {};         &
        \node (p5)    [point]       {};         &
        \node (p6)    [point]       {};         &
        \node (e)     [terminal]    {E};        &
        \node (p7)    [point]       {};         &
        \node (p8)    [point]       {};         &
        \node (ui2)   [nonterminal] {unsigned}; &
        \node (p9)    [point]       {};         &
        \node (p10)   [point]       {};         \\
        % Third row:
        & & & & & & &  & & & & \node (minus)[terminal] {-};\\
    };

    { [start chain]
        \chainin (p1);
        \chainin (ui1)   [join=by tip];
        \chainin (p2)    [join];
        \chainin (dot)   [join=by tip];
        \chainin (p3)    [join];
        \chainin (digit) [join=by tip];
        \chainin (p4)    [join];
        { [start branch=digit loop]
        \chainin (p3) [join=by {skip loop=-6mm,tip}];
        }
        \chainin (p5)    [join,join=with p2 by {skip loop=6mm,tip}];
        \chainin (p6)    [join];
        \chainin (e)     [join=by tip];
        \chainin (p7)    [join];
        { [start branch=plus]
        \chainin (plus)  [join=by {vh path,tip}];
        \chainin (p8)    [join=by {hv path,tip}];
        }
        { [start branch=minus]
        \chainin (minus) [join=by {vh path,tip}];
        \chainin (p8)    [join=by {hv path,tip}];
        }
        \chainin (p8)    [join];
        \chainin (ui2)   [join=by tip];
        \chainin (p9)    [join,join=with p6 by {skip loop=-11mm,tip}];
        \chainin (p10)   [join=by tip];
  }
\end{tikzpicture}
\begin{verbatim}
FLOAT ::= 
\end{verbatim}
\caption{FLOAT syntax}
\label{FLOATsyntax}
\end{figure}

\index[fig]{syntax!IF}
\index[fig]{IF syntax}
\begin{figure}[H]
\centering
\begin{tikzpicture}[
        point/.style={coordinate},>=stealth',thick,draw=black!50,
        tip/.style={->,shorten >=0.007pt},every join/.style={rounded corners},
        hv path/.style={to path={-| (\tikztotarget)}},
        vh path/.style={to path={|- (\tikztotarget)}},
        text height=1.5ex,text depth=.25ex % align text horizontally
    ]
    \matrix[column sep=4mm] {
        \node (p1)       [point] {}; & 
        \node (if)       [terminal]    {if};    &
        \node (test)     [nonterminal] {test};  &
        \node (then)     [terminal]    {then};  &
        \node (trueblk)  [nonterminal] {block}; &
        \node (p5)       [point]       {};      &
        \node (else)     [terminal]    {else};  &
        \node (falseblk) [nonterminal] {block}; &
        \node (p7)       [point]       {};      &
        \node (p8)       [point]       {}; \\
    };

    { [start chain]
        \chainin (p1);
        \chainin (if)       [join];
        \chainin (test)     [join];
        \chainin (then)     [join];
        \chainin (trueblk)  [join];
        \chainin (p5)       [join];
        \chainin (else)     [join];
        \chainin (falseblk) [join];
        \chainin (p7)       [join,join=with p5 by {skip loop=5mm,tip}];
        \chainin (p8)       [join];
  }
\end{tikzpicture}
\begin{verbatim}
IF ::= if TEST then BLOCK [else BLOCK]
\end{verbatim}
\caption{IF syntax}
\label{IFsyntax}
\end{figure}

\index[fig]{syntax!FOR}
\index[fig]{FOR syntax}
\begin{figure}[H]
\centering
\begin{tikzpicture}[
        point/.style={coordinate},>=stealth',thick,draw=black!50,
        tip/.style={->,shorten >=0.007pt},every join/.style={rounded corners},
        hv path/.style={to path={-| (\tikztotarget)}},
        vh path/.style={to path={|- (\tikztotarget)}},
        text height=1.5ex,text depth=.25ex % align text horizontally
    ]
    \matrix[column sep=4mm] {
        \node (p1)   [point]       {};           & 
        \node (for)  [terminal]    {for};        &
        \node (var)  [terminal]    {variable.};  &
        \node (in)   [terminal]    {in};         &
        \node (expr) [nonterminal] {expression}; &
        \node (rep)  [terminal]    {repeat};     &
        \node (blk)  [nonterminal] {block};      \\
    };

    { [start chain]
        \chainin (p1);
        \chainin (for)  [join];
        \chainin (var)  [join];
        \chainin (in)   [join];
        \chainin (expr) [join];
        \chainin (rep)  [join];
        \chainin (blk)  [join];
  }
\end{tikzpicture}
\begin{verbatim}
FOR ::= for VARIABLE in EXPRESSION repeat BLOCK
\end{verbatim}
\caption{FOR syntax}
\label{FORsyntax}
\end{figure}

\section{The Compiler Function}

Given a {\bf theparse} structure, construct the corresponding
defclass.

\begin{verbatim}
(defclass |BitsType| (|BitAggregateType|)
  ((parents :initform '(|BitAggregate|))
   (name :initform "Bits")
   (marker :initform 'domain)
   (abbreviation :initform 'BITS)
   (comment :initform (list
     "Bits provides logical functions for Indexed Bits."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Bits|
  (progn
    (push '|Bits| *Domains*)
    (make-instance '|BitsType|)))

\end{verbatim}

The {\bf compileSpad} 
\index[doc]{compileSpad}
function takes the parser structure and compiles it
to executable code.
\sig{compileSpad}{theparse}{values}
\index[code]{defun!compileSpad}
\index[code]{compileSpad!defun}
\begin{chunk}{defun compileSpad}
(defun compileSpad (theparse)
  (let* ((abbrev (parser-abbrev theparse))
        (classname (intern (concatenate 'string (abbreviation-string abbrev) "Type"))))
    (print
     `(progn
        (defclass ,classname ()
          ((name         :initform ,(abbreviation-string abbrev))
           (marker       :initform ,(abbreviation-class abbrev))
           (abbreviation :initform ,(abbreviation-abbrev abbrev))
           (comment      :initform ,(parser-topcomment theparse))))
        (defvar ,(abbreviation-name abbrev)
          (progn
             (push ',(abbreviation-name abbrev) *Domains*)
             (make-instance ',classname)))))
   (values)))

\end{chunk}

\section{The Language}

\begin{verbatim}
FILENAME    ::= PATHNAME
RAWCODE     ::= List(STRING)
PILE        ::= List(STRING)
TREE        ::= Tree(STRING)
SOURCECODE  ::= FILENAME RAWCODE PILE TREE

UCHAR       ::= uppercase character

CONSTRUCT   ::= constructorname
\end{verbatim}



\begin{verbatim}
FILE        ::= ABBREV BODY
BODY        ::= CDPSIG MACROS WITH ADD
CDPSIG      ::= CDPNAME ['(' [ CDPARGS ] ')'] '==' 
MACROS      ::= MACNAME '==>' MACBODY
WITH        ::= [PARENTS] with SIGNATURES
ADD         ::= 

COLONTYPE   ::= name : TYPESPEC [',' COLONGTYPE]*
RECORD      ::= 'Record(' COLONTYPE* ')'
UNIONTAG    ::= TYPESPEC | STRING
UNION       ::= 'Union(' UNTIONTAG [',' UNIONTAG]+ ')'

INFIX       ::= + | - * | ** | mod | ^ | / | exquo
PREFIX      ::= + | -
SPECIALNAME ::= "*" | "**" | "^" | "/" | PREFIX | INFIX
SIGNAME     ::= SPECIALNAME | SYMBOL
FSMSIG      ::= INDENT SIGNAME [':' SIGINTYPE '->' SIGOUTTYPE] [SIGIFSEC]
\end{verbatim}

\section{Finite State Machine tools}

The Finite State Machine tools mimic the EBNF in the language
grammar. An example of its use is to recognize the abbreviation
line. The line looks like:
\begin{verbatim}
   )abbrev domain TIM Tim
\end{verbatim}

\noindent
The Finite State Machine code to recognize this and construct an
abbreviation instance would be:
\begin{verbatim}
(defun FSM-abbrev (linelist)
  (let ((split (splitchar (first linelist) #\space)) result)
    (when
      (fsm-and 
        (fsm-match ")abbrev")
        (fsm-or
          (fsm-match "category")
          (fsm-match "domain")
          (fsm-match "package"))
        (fsm-abbname)
        (fsm-word))
      (values
        (rest linelist)
        (make-abbreviation (third result) (second result) (first result))))))

\end{verbatim}

\noindent
Things to note about this code are that the variables {\bf split}
\index[code]{split!variable}
\index[code]{variable!split}
and {\bf result}
\index[code]{result!variable}
\index[code]{variable!result}
are expected to be in the environment of the macros. When this code
successfully recognizes the input line it constructs a class object to
hold the result.

\noindent
The {\bf FSM-OR} 
\index[code]{FSM-OR!defmacro}
\index[code]{defmacro!FSM-OR}
macro mimics the action of the choice vertical bar in
the grammar. It accepts a list of tests and returns if one of the
tests succeeds.
\index[code]{defmacro!FSM-OR}
\index[code]{FSM-OR!defmacro}
\begin{chunk}{defmacro FSM-OR}
(defmacro FSM-OR (&body FSM-tests)
  `(or ,@FSM-tests))

\end{chunk}

\noindent
The {\bf FSM-AND} 
\index[code]{FSM-AND!defmacro}
\index[code]{defmacro!FSM-AND}
macro mimics the action of a sequence of matches in the grammar. 
It accepts a list of tests and returns if all of the 
tests succeed.
\index[code]{defmacro!FSM-AND}
\index[code]{FSM-AND!defmacro}
\begin{chunk}{defmacro FSM-AND}
(defmacro FSM-AND (&body FSM-tests)
  `(and ,@FSM-tests))

\end{chunk}

\subsection{The gather class}

\index[fig]{defclass!gather}
\index[fig]{gather defclass}
\begin{table}[H]
\begin{center}
\label{tab:gather}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Fieldname} & \textbf{initarg} & \textbf{initform} &
\textbf{accessor}\\
\hline
lines & :lines & nil & gather-lines\\
\hline
\end{tabular}
\caption{{\bf defclass gather}}
\end{center}
\end{table}

\noindent
The {\bf gather} class holds the result of collecting several
\index[code]{defclass!gather}
\index[code]{gather!defclass}
associated lines.  It is filled by side-effect by {\bf FSM-gather}.
\index[code]{defclass!gather}
\index[code]{gather!defclass}
\begin{chunk}{defclass gather}
(defclass gather ()
  ((lines  :initarg :lines :initform nil :accessor gather-lines)))

\end{chunk}

\index[code]{print-object!defmethod!gather}
\index[code]{defmethod!print-object!gather}
\index[code]{gather!defmethod!print-object}
\begin{chunk}{defmethod print-object}
(defvar formatgather "~{~a~%~^~}")

(defmethod print-object ((g gather) stream) 
  (format stream formatgather (gather-lines g)))

\end{chunk}

\noindent
The {\bf FSM-gather} macro rips lines that pass the test
\index[code]{defmacro!FSM-gather}
\index[code]{FSM-gather!defmacro}
from the list of input strings.It expects 3 arguments
\begin{enumerate}
\item {\bf linelist} is a list of input strings from the raw
field of the sourcecode class object.
\item {\bf test} is a test to decide whether this line should
be gathered from the linelist. 
\item {\bf into} is an instance of the {\bf gather} class 
that will hold the lines that pass the test.
\end{enumerate}
Given a linelist that looks like:
\begin{verbatim}
  ("++ Author: Stephen M. Watt"
    "++ Description:"
    "++ \\spadtype{Bits} provides logical functions for Indexed Bits."
    "Bits() : SIG == CODE where"
    "  SIG ==> BitAggregate() with"
    "    bits : (NonNegativeInteger, Boolean) -> %"
    "      ++ bits(n,b) creates bits with n values of b"
    "  CODE ==> IndexedBits(1) add"
    "    bits(n,b)    == new(n,b)")
\end{verbatim}
and the call to gather comments, lines starting the "$++$":
\begin{verbatim}
(defun FSM-comment (linelist)
  (let (comment result)
    (setq comment (make-instance 'gather))
    (values
      (FSM-gather linelist (FSM-match "++") comment)
      comment)))
\end{verbatim}
when invoked with:
\begin{verbatim}
   (multiple-value-setq (t3 t4) (fsm-comment t2))
\end{verbatim}
we end up with t4 as a {\bf gather} instance containing the
lines that passed the {\bf FSM-match} test. For example,
\begin{verbatim}
The object is a STANDARD-OBJECT of type GATHER.
0. LINES:
 ("++ Author: Stephen M. Watt"
  "++ Description:"
  "++ \\spadtype{Bits} provides logical functions for Indexed Bits.")
\end{verbatim}
The t3 variable contains the new linelist without the matching lines:
\begin{verbatim}
   ("Bits() : SIG == CODE where"
    "  SIG ==> BitAggregate() with"
    "    bits : (NonNegativeInteger, Boolean) -> %"
    "      ++ bits(n,b) creates bits with n values of b"
    "  CODE ==> IndexedBits(1) add"
    "    bits(n,b)    == new(n,b)")
\end{verbatim}

\index[code]{defmacro!FSM-gather}
\index[code]{FSM-gather!defmacro}
\begin{chunk}{defmacro FSM-gather}
(defmacro FSM-gather (linelist test into)
  `(let ((split (splitchar (first ,linelist) #\space)))
     (loop while (and linelist ,test) do
       (setf (gather-lines ,into)
         (append (gather-lines ,into) (list (pop ,linelist)))) 
       (setq split (splitchar (first ,linelist) #\space)))
     ,linelist))

\end{chunk}

\noindent
NOTE: {\bf These macros assume two variables in the environment.}
\index[code]{split!variable}
\index[code]{variable!split}
\index[code]{result!variable}
\index[code]{variable!result}
\begin{enumerate}
\item {\bf split} that is a tokenized list of the input,
usually by calling the {\bf splitchar} function. Each element of the
list is a string.
\item {\bf result} is a variable used to collect matches in a list.
\end{enumerate}

\noindent
The {\bf FSM-startsWith}
\index[code]{defmacro!FSM-startsWith}
\index[code]{FSM-startsWith!defmacro}
occurs in cases where we want to check whether the prefix is a
word we expect, such as looking for the category name, for example,
\begin{verbatim}
   Bits() : Category
   FSM-match "Bits"   
\end{verbatim}

\index[code]{defmacro!FSM-startsWith}
\index[code]{FSM-startsWith!defmacro}
\begin{chunk}{defmacro FSM-startsWith}
(defmacro FSM-startsWith (word)
  `(let ((term (explode (first split))))
     (setq result t)
     (loop for c across ,word do
       (when (and result (char/= c (pop term)))
         (setq result nil)))
     (when result ,word)))

\end{chunk}

\noindent
The {\bf FSM-match}
\index[code]{FSM-match!defmacro}
\index[code]{defmacro!FSM-match}
matches a string with any case and, when successful, it adds the
matched word to the result and pops it off the split.

\index[code]{defmacro!FSM-match}
\index[code]{FSM-match!defmacro}
\begin{chunk}{defmacro FSM-match}
(defmacro FSM-match (word)
  `(when (string-equal (first split) ,word)
     (push (first split) result)
     (pop split)))

\end{chunk}

\noindent
The {\bf FSM-dword}
\index[code]{FSM-dword!defmacro}
\index[code]{defmacro!FSM-dword}
matches the lowercased word, then match. When successful, it adds the
matched word to the result and pops it off the split.

\index[code]{defmacro!FSM-dword}
\index[code]{FSM-dword!defmacro}
\begin{chunk}{defmacro FSM-dword}
(defmacro FSM-dword (word)
  `(when (string= (string-downcase ,word) (first split))
     (push (first split) result)
     (pop split)))

\end{chunk}

\noindent
The {\bf FSM-uword}
\index[code]{FSM-uword!defmacro}
\index[code]{defmacro!FSM-uword}
matches the uppercased word, then match. When successful, it adds the
matched word to the result and pops it off the split. 

\index[code]{defmacro!FSM-uword}
\index[code]{FSM-word!defmacro}
\begin{chunk}{defmacro FSM-uword}
(defmacro FSM-uword (word)
  `(when (string= (string-upcase ,word) (first split))
     (push (first split) result)
     (pop split)))

\end{chunk}

\noindent
The {\bf FSM-word}
\index[code]{FSM-word!defmacro}
\index[code]{defmacro!FSM-word}
simply return the next word. It always succeeds. It adds the word to
the result and pops it off the split.

\index[code]{defmacro!FSM-word}
\index[code]{FSM-word!defmacro}
\begin{chunk}{defmacro FSM-word}
(defmacro FSM-word ()
  '(progn
     (push (first split) result)
     (pop split)))

\end{chunk}

\noindent
The {\bf FSM-cdpname}
\index[doc]{FSM-cdpname}
checks to see if the next word in the split is a known class. 
For example,
\begin{verbatim}
  (FSM-cdpname *categories*)
\end{verbatim}
will check if the string at the top of the split is in the known list
of category names. (Note that it interns the string first). 
It adds the word to the result and pops it off the split.

\index[code]{defmacro!FSM-cdpname}
\index[code]{FSM-cdpname!defmacro}
\begin{chunk}{defmacro FSM-cdpname}
(defmacro FSM-cdpname (cdplist)
  `(when (member (intern (first split)) ,cdplist)
     (push (first split) result)
     (pop split)))

\end{chunk}

\noindent
Abbreviations of categories, domains, and packages must be 8 or less
characters and all uppercase.

\noindent
The {\bf FSM-abbname}
\index[code]{FSM-abbname!defmacro}
\index[code]{defmacro!FSM-abbname}
performs this check. When successful,
it adds the word to the result and pops it off the split.

\index[code]{defmacro!FSM-abbname}
\index[code]{FSM-abbname!defmacro}
\begin{chunk}{defmacro FSM-abbname}
(defmacro FSM-abbname ()
  `(let ((word (first split)))
     (when (and (<= (length word) 8)
                (loop with result 
                      for c across word 
                      while (setq result (or (digit-char-p c) (upper-case-p c)))
                      finally (return result)))
       (push (first split) result)
       (pop split))))

\end{chunk}

The
\index[doc]{FSM-gatherList}
function is called when an open-paren is detected as the next
character in the first line of the linelist. It will walk across the
linelist gathering all of the text between the open-paren and the
balancing closed-paren, even if there are newlines or other parens.
It works character by character. The {\bf result} variable is the
parenthesized object, including the delimiting parens. 

The {\bf depth} variable is used to handle embedded parens. Only a
closed paren at depth 0 is considered a match. The {\bf more} variable
causes the loop to exit when it becomes false. The {\bf instring}
variable is used to ignore parens embedded in strings. The {\bf str}
variable is the current string we are walking. The complication is
that there could be newlines between balancing parens so we have to
move to the next string in the linelist. The {\bf c} character is the
current character we are considering. There are several cases with
associated comments. The {\bf listlen} variable is a counter which
counts how much of the string we need to remove before returning. The
complication is that when we have multiple lines we have to also
consider the leading spaces in indents.

The {\bf FSM-gatherList 1} 
\index[err]{FSM-gatherList 1}
error occurs because the next character
whould have been an open parenthsis. The function expects to find
matching parentheses and it needs an initial parenthesis to start
the balance. This error usually means that the category, domain,
or package name needs an explicit argument list even it it takes
no arguments.

\sig{FSM-gatherList}{linelist}{(linelist,list(args)}
\index[code]{defun!FSM-gatherList}
\index[code]{FSM-gatherList!defun}
\begin{chunk}{defun FSM-gatherList}

(defvar formatGatherList1
  "FSM-gatherList 1: ~%    In ~a~%    Missing open parenthesis~%")

(defun FSM-gatherList (linelist)
  (let (result (depth 0) (more t) instring str c (listlen 0))
     (setq str (explode (first linelist)))
     (unless (char= (first str) #\()
       (error formatGatherList1 (first linelist)))
     (loop while more do
       (setq c (pop str))
       (cond
         ; hit a newline?
         ((null c)
           (pop linelist)
           (setq listlen (indent (first linelist)))
           (setq str (explode (trim (first linelist))))
           (push #\space str))
         ; end of string?
         ((and instring (char= c #\"))
           (setq instring nil)
           (incf listlen)
           (push c result))
         ; still in string?
         (instring
           (incf listlen)
           (push c result))
         ; start string?
         ((and (not instring) (char= c #\"))
           (setq instring t)
           (incf listlen)
           (push c result))
         ; start list?
         ((char= c #\()
           (incf depth)
           (incf listlen)
           (push #\( result))
         ; exit nested list?
         ((and (> depth 0) (char= c #\)))
           (decf depth)
           (when (= depth 0) (setq more nil))
           (incf listlen)
           (push #\) result))
         ; end list?
         ((and (= depth 0) (char= c #\)))
           (incf listlen)
           (push #\) result)
           (setq more nil))
         (t
           (incf listlen)
           (push c result))))
    (setq result (coerce (nreverse result) 'string))
    (setf (first linelist) (subseq (first linelist) listlen))
    (values linelist result)
))

\end{chunk}

The 
\index[doc]{FSM-gatherVars}
function expects a list of arguments to a function. It breaks up
the list based on the top-level commas, ignoring commas in strings and
in embedded arguments that are not top-level. It returns a list of 
strings, one per top level argument.

\sig{FSM-gatherVars}{argslist}{list(vars)}
\index[code]{defun!FSM-gatherVars}
\index[code]{FSM-gatherVars!defun}
\begin{chunk}{defun FSM-gatherVars}
;  ARGLIST -> LIST(ARGS)
(defun FSM-gatherVars (argslist)
  (let (result (depth 0) (more t) instring str c vars)
     (setq str (explode (trim argslist)))
     (pop str)
     (loop while more do
       (setq c (pop str))
       (cond
         ; hit a newline?
         ((null c)
  (print (list 'gv 0))
           (pop argslist)
           (if argslist
             (progn
               (setq str (explode (trim (first argslist))))
               (push #\space str))
             (progn
               (push (trim (coerce (nreverse result) 'string)) vars)
               (setq more nil))))
         ; found a top-level comma?
         ((and (= depth 0) (not instring) (char= c #\,)) 
  (print (list 'gv 1))
           (push (trim (coerce (nreverse result) 'string)) vars)
           (setq result nil))
         ; end of string?
         ((and instring (char= c #\"))
  (print (list 'gv 2))
           (setq instring nil)
           (push c result))
         ; still in string?
         (instring
  (print (list 'gv 3))
           (push c result))
         ; start string?
         ((and (not instring) (char= c #\"))
  (print (list 'gv 4))
           (setq instring t)
           (push c result))
         ; start list?
         ((char= c #\()
  (print (list 'gv 5))
           (incf depth)
           (push #\( result))
         ; exit nested list?
         ((and (> depth 0) (char= c #\)))
  (print (list 'gv 6))
           (decf depth)
           (push #\) result))
         ; end list?
         ((and (= depth 0) (not instring) (char= c #\)))
  (print (list 'gv 7 'result result))
           (when result (push (trim (coerce (nreverse result) 'string)) vars))
           (setq more nil))
         (t
  (print (list 'gv 8))
           (push c result))))
    (nreverse vars)
))

\end{chunk}

\section{Sourcecode Tree Utilities}

We process the original source code into a ``clean form'' that
has no $--$ comments, no blank lines, and no line continuations.
We call this the ``{bf pile}'' form of the code. This is just
a list of strings.

Next we convert the pile form into tree form using the indentation.
Elements at the same level of identation are grouped togehter.

The {\bf indent}
\index[doc]{indent}
function tells us how many spaces, aka the indentation, we have
at the beginning of the line.

\sig{indent}{line}{depth}
\index[code]{defun!indent}
\index[code]{indent!defun}
\begin{chunk}{defun indent}
(defun indent (line)
  (let ((depth 0))
    (loop for char across line do 
      (if (char= char #\space)
        (incf depth)
        (return)))
    depth))

\end{chunk}

Just for mnemonic purposes we create constructors and 
accessor functions. All we are really doing is creating
pairs, the car of which is the indentation and the cdr
is anything.

The {\bf birth} function 
\index[doc]{birth}
expects the indentation count and anything, and just conses
them together.
\begin{verbatim}
   DEPTH, ANY -> BIRTHFORM
\end{verbatim}

\index[code]{defmacro!birth}
\index[code]{birth!defmacro}
\begin{chunk}{defmacro birth}
(defmacro birth (depth name)
 `(cons ,depth ,name))

\end{chunk}

Naturally, if we have a cons, we need to disassemble it.
The {\bf depthof} function returns the indentation.
\index[doc]{depthof}
\begin{verbatim}
   BIRTHFORM -> DEPTH
\end{verbatim}

\index[code]{defmacro!depthof}
\index[code]{depthof!defmacro}
\begin{chunk}{defmacro depthof}
(defmacro depthof (node)
 `(car ,node))

\end{chunk}

And the {\bf nameof}
\index[doc]{nameof}
returns the thing we put in the cdr.
\begin{verbatim}
   BIRTHFORM -> ANY
\end{verbatim}

\index[code]{defmacro!nameof}
\index[code]{nameof!defmacro}
\begin{chunk}{defmacro nameof}
(defmacro nameof (node)
 `(cdr ,node))

\end{chunk}

Given a list of strings, each of which has a variable
number of leading blanks, we construct pairs where the
car is the indentation and the cdr is anything, usually
the source string. We call this rewrite the {\bf spawn}
\index[doc]{spawn}
of the tree. From this information we can compute things
like the depth of nesting.
\begin{verbatim}
   PILEFORM -> SPAWNFORM
\end{verbatim}

\sig{spawn}{tree}{list(indentedLines)}
\index[code]{defun!spawn}
\index[code]{spawn!defun}
\begin{chunk}{defun spawn}
(defun spawn (tree)
  (loop for node in tree
    collect (birth (indent node) node)))

\end{chunk}

The {\bf pile2tree} 
\index[code]{pile2tree}
function takes a {\bf sourcecode pile} which looks like:
\begin{verbatim}
(")abbrev domain BITS Bits"
 "++ Author: Stephen M. Watt" "++ Description:"
 "++ \\spadtype{Bits} provides logical functions for Indexed Bits."
 "Bits() : SIG == CODE where"
 "  SIG ==> BitAggregate() with"
 "    bits : (NonNegativeInteger, Boolean) -> %"
 "      ++ bits(n,b) creates bits with n values of b"
 "  CODE ==> IndexedBits(1) add"
 "    bits(n,b)    == new(n,b)")

\end{verbatim}

and inserts parentheses that group the code into a tree form,
called a {\bf sourcecode tree} looks like:
\begin{verbatim}
(")abbrev domain BITS Bits"
 "++ Author: Stephen M. Watt" "++ Description:"
 "++ \\spadtype{Bits} provides logical functions for Indexed Bits."
 "Bits() : SIG == CODE where"
 "  (SIG ==> BitAggregate() with"
 "    (bits : (NonNegativeInteger, Boolean) -> %"
 "      (++ bits(n,b) creates bits with n values of b"
 "      )))"
 "  (CODE ==> IndexedBits(1) add"
 "    (bits(n,b)    == new(n,b)"
 "    ))")

\end{verbatim}

The {\bf deep}
\index[doc]{deep}
function will walk a spawn-ed tree and return a reverse
sorted list of the indentations. We use this to walk the
spawn tree ``inside-out'', handling the most deeply nested
nodes first.

\sig{pile2tree}{pileform}{treeform}
\index[code]{defun!pile2tree}
\index[code]{pile2tree!defun}
\begin{chunk}{defun pile2tree}
(defun pile2tree (pile)
  (labels (
    ; INTEGER -> STRING of PARENS
    (closeparens (count)
      (let (result)
        (coerce (dotimes (i count result) (push #\) result)) 'string)))
    ; INTEGER -> STRING of SPACES
    (spaces (count)
      (let (result)
        (coerce (dotimes (i (* 2 count) result) (push #\space result))
	'string)))
    ; SPAWNFORM -> LIST DEPTH
    (deep (tree)
      (let (result)
        (loop for node in tree do
          (setq result (adjoin (depthof node) result)))
        (sort result #'>)))
    ; PILE -> PILE
    (redepth (pile)
     (let (deeplist thepile)
      (setq thepile (spawn pile))
      (setq deeplist (nreverse (deep thepile)))
      (loop for line in thepile do
        (setf (car line) (position (car line) deeplist)))
      thepile))
    ; PILE -> LIST STRING
    (extract (code)
      (loop for line in code 
        collect (cdr line)))
  )
  (let ((was 0) lastline closers)
    (let (stack)
      (loop for line in (redepth pile) do
        (setf (cdr line) (trim (cdr line)))
        (cond
          ((= (depthof line) was)
            (setf (cdr line) (concatenate 'string (spaces (car line)) " " (cdr line)))
            (push line stack))
          ((> (depthof line) was)
            (setf (cdr line) (concatenate 'string (spaces (car line)) "(" (cdr line)))
            (push line stack))
          ((< (depthof line) was)
            (setq closers (closeparens (car lastline)))
            (push (cons (car lastline) (concatenate 'string (spaces (car lastline)) closers)) stack)
            (setf (cdr line) (concatenate 'string (spaces (car line)) "(" (cdr line)))
            (push line stack))
          )
        (setq was (car line))
        (setq lastline line))
    (setq closers (closeparens (car lastline)))
    (push (cons (car lastline) (concatenate 'string (spaces (car lastline)) closers)) stack)
    (extract (nreverse stack))))))

\end{chunk}

The {\bf pretty} 
\index[doc]{pretty}
function takes a sourcecode-tree, or a sublist thereof, 
and prints it in a form we prefer.

\sig{pretty}{treeform}{values}
\index[code]{defun!pretty}
\index[code]{pretty!defun}
\begin{chunk}{defun pretty}
(defun pretty (tree)
  (cond
    ((stringp tree) (format t "~a~%" tree))
    ((consp tree)   (mapcar #'(lambda (tree) (pretty tree)) tree)))
  (values))

\end{chunk}

Spad code is indentation sensitive. This is called 'pile format'. We 
unpile the spad file, recording the indentation.

\begin{verbatim}
FILE        ::= ABBREV BODY
BODY        ::= CDPSIG MACROS WITH ADD
CDPSIG      ::= CDPNAME ['(' [ CDPARGS ] ')'] '==' 
MACROS      ::= MACNAME '==>' MACBODY
WITH        ::= [PARENTS] with SIGNATURES
ADD         ::= 

COLONTYPE   ::= name : TYPESPEC [',' COLONGTYPE]*
RECORD      ::= 'Record(' COLONTYPE* ')'
UNIONTAG    ::= TYPESPEC | STRING
UNION       ::= 'Union(' UNTIONTAG [',' UNIONTAG]+ ')'

INFIX       ::= + | - * | ** | mod | ^ | / | exquo
PREFIX      ::= + | -
SPECIALNAME ::= "*" | "**" | "^" | "/" | PREFIX | INFIX
SIGNAME     ::= SPECIALNAME | SYMBOL

FSMSIG      ::= INDENT SIGNAME [':' SIGINTYPE '->' SIGOUTTYPE] [SIGIFSEC]
\end{verbatim}

\index[fig]{syntax!FSMSIG}
\index[fig]{FSMSIG syntax}
\begin{figure}[H]
\centering
\begin{tikzpicture}

\node[state, initial]                 (q01) {$s_1$};
\node[state, accepting, right of=q01] (q02) {$s_2$};

\node[state, below of=q01, initial]   (q03) {$s_1$};
\node[state, right of=q03]            (q04) {$s_2$};
\node[state, right of=q04]            (q05) {$s_3$};
\node[state, accepting, right of=q05] (q06) {$s_4$};

\node[state, below of=q03, initial]   (q07) {$s_1$};
\node[state, right of=q07]            (q08) {$s_2$};
\node[state, right of=q08]            (q09) {$s_3$};
\node[state, right of=q09]            (q10) {$s_4$};
\node[state, accepting, right of=q10] (q11) {$s_5$};

\draw

(q01) edge[above] node{intype}   (q02)

(q03) edge[above] node{intype}   (q04)
(q04) edge[above] node{{\tt ->}} (q05)
(q05) edge[above] node{outtype}  (q06)

(q07) edge[above] node{intype}   (q08)
(q08) edge[above] node{{\tt ->}} (q09)
(q09) edge[above] node{outtype}  (q10)
(q10) edge[above] node{ifspec}   (q11);

\end{tikzpicture}
\begin{verbatim}
FSMSIG ::=
\end{verbatim}
\caption{FSMSIG syntax}
\label{FSMSIGsyntax}
\end{figure}

\index[fig]{syntax!LEAVE}
\index[fig]{LEAVE syntax}
\begin{figure}[ht]
\centering
TODO
\caption{LEAVE syntax}
\begin{verbatim}
LEAVE
\end{verbatim}
\label{LEAVEsyntax}
\end{figure}

\begin{verbatim}
  FUNCTIONSPEC ::= INTTYPE
                 | INTYPE -> OUTPUT
                 | INTYPE -> OUTPUT IFSPEC
\end{verbatim}

\begin{figure}[ht]
\centering
\begin{tikzpicture}

\node[state, initial] (q1) {$s_1$};
\node[state, right of=q1] (q2) {$s_2$};
\node[state, accepting, right of=q2] (q3) {$s_3$};
\node[state, below of=q2] (q4) {$s_4$};
\node[state, accepting, right of=q4] (q5) {$s_5$};

\draw
(q1) edge[loop above] node{indent} (q1)
(q1) edge[above] node{name} (q2)
(q2) edge[above] node{eol} (q3)
(q2) edge[left] node{:} (q4)
(q4) edge[above] node{funsig} (q5);

\end{tikzpicture}
\caption{SIGNATURE}
\label{SIGNATURE}
\end{figure}
\begin{verbatim}
  SIGNATURE ::= NAME EOF
              | NAME : FUNCTIONSPEC
\end{verbatim}

The Finite State Machine (FSM) walks across a spad signature
character by character. It constructs the syntactic pieces.

The inner loop drives forward character by character, calling
the {\bf classify} function to determine the next state. The
inner loop is a large case statement handling each classified
state. The inner loop is {\bf :accept} at the end of the file.

Both {\bf inttype}, the input type specification 
and {\bf outtype}, the output type specification may both be very
complex type specifications. They are recognized by a separate
finite state machine.

A signature may also have a conditional specification that
is handled by its own finite state machine.

The {\bf look} function just peeks at the next character.
The {\bf eat} function consumes it.

The {\bf next} function updates the {\bf nextstate} variable.

The {\bf here} function outputs debugging information.

\sig{FSMSIG}{debug}{values}
\index[code]{defun!FSMSIG}
\index[code]{FSMSIG!defun}
\begin{chunk}{defun FSMSIG}
(defun FSMSIG (&optional (debug nil))
  (let (nextstate prev char (eofsym (gensym))
        (indenting? t) (indent 0) 
        inword? word words)
    (labels (
      (classify (char)
        (unless (eq char #\space) (setq indenting? nil))
        (cond
         ((eq char eofsym)    (next :accept))
         ((eq char #\space)   (next :space))
         ((eq char #\:)       (next :colon))
         ((eq char #\$)       (next :dollar))
         ((eq char #\-)       (next :dash))
         ((eq char #\>)       (if (char= #\- prev) (next :arrow) (next :greater)))
         ((lower-case-p char) (next :lowercase))
         ((upper-case-p char) (next :uppercase))
      ))
      (look (in)
        (setq prev char)
        (setq char (peek-char nil in nil eofsym)))
      (eat (in)
        (setq prev char)
        (setq char (read-char in nil eofsym)))
      (next (newstate)
        (setq nextstate newstate))
      (endword () (print 'endword)
        (push (coerce (nreverse word) 'string) words)
        (setq inword? nil)
        (setq word nil))
      (here (&optional (keyword nil))
        (when debug 
          (if keyword
            (format t "~&~a ~a" char keyword)
            (format t "~&~a ~a" char nextstate))))
    )
  (let ()
    (with-open-file (spad "spad" :direction :input)
      (loop until (eq nextstate :accept) do
        (look spad)
        (case (classify char)
          (:space (here)
            (when indenting? (incf indent))
            (when inword? (endword))
            (eat spad))
         (:lowercase (here)
           (setq inword? t)
           (push char word)
           (eat spad))
         (:uppercase (here)
           (setq inword? t)
           (push char word)
           (eat spad))
         (:colon (here)
           (when inword? (endword))
           (eat spad))
         (:dollar (here)
           (push char word)
           (eat spad))
         (:dash (here)
           (push char word)
           (eat spad))
         (:arrow (here)
           (setq prev (pop word))
           (endword)
           (push prev word)
           (push char word)
           (endword)
           (eat spad))
         (:accept (here :accept)
           (endword))
         (t (here :fail) 
            (endword)
            (next :accept))
       )))
    (print (list 'indent indent
                 'words (nreverse words)))
    (values)
  ))))

\end{chunk}
            
\subsection{Gather Macros}

The {\bf FSM-extract1Macro} 
\index[doc]{FSM-extract1Macro} 
walks the linelist until it
finds a line containing the string ``$==>$'' which marks
the start of a macro. All lines (including the first) are
removed from the linelist and collected into a {\bf gather} 
\index[doc]{gather}
structure. The {\bf pre} variable contains the lines up to
the start of the macro. Ultimately, we return a new linelist
without the macro lines and a gather structure containing
the macro lines.

\sig{FSM-extract1Macro}{linelist}{(linelist,gather)}
\index[code]{defun!FSM-extract1Macro}
\index[code]{FSM-extract1Macro!defun}
\begin{chunk}{defun FSM-extract1Macro}
(defun FSM-extract1Macro (linelist)
  (let (pre gather indent)
    (setq pre
      (loop while (not (search "==>" (first linelist)))
            collect (pop linelist)))
    (setq gather (make-instance 'gather))
    (when (search "==>" (first linelist))
      (setq indent (indent (first linelist)))
      (setf (gather-lines gather) (list (pop linelist)))
      (FSM-gather linelist (> (indent (first linelist)) indent) gather))
    (values
      (append pre linelist)
      gather)))

\end{chunk}

\subsection{parseSignature}

\sig{parseSignature}{linelist}{values}
\index[code]{parseSignature!parser}
\index[code]{parser!parseSignature}
\begin{chunk}{defun parseSignature}
(defun parseSignature (linelist)
  (let (funcname return argslist comment colon arrow line control plusplus)
    (labels (
      (substring (line start &optional end)
        (trim (subseq line start end)))
      (nospad (line)
        (let (pos)
          (cond
            ((setq pos (search "spad{" line))
              (concatenate 'string 
                (subseq line 0 pos)
                (subseq line (+ 5 pos) (setq pos (search "}" line :start2 pos)))
                (subseq line (1+ pos))))
            ((setq pos (search "spadtype{" line))
              (concatenate 'string 
                (subseq line 0 pos)
                (subseq line (+ 9 pos) (setq pos (search "}" line :start2 pos)))
                (subseq line (1+ pos))))
           (t line))))
      (mangle (str)
        (cond
          ((string= str "()") str)
          ((string= str "%") str)
          (t (intern str))))
    )
    ; the first line is the signature
    (setq line     (first linelist))
    ; find the delimiters if they exist
    (setq colon    (search ":" line))
    (setq arrow    (search "->" line))
    ; parse out the pieces
    (setq funcname (intern (substring line 0 colon)))
    (setq argslist  (mangle (substring line (1+ colon) arrow)))
    (setq return   (mangle (substring line (+ 2 arrow))))
    ; collect the comment linelist
    (dolist (line (cdr linelist))
      (setq plusplus (search "++" line))
      (push (nospad (substring line (+ 2 plusplus))) comment))
    ; construct a format control string
    (setq control "(make-signature '|~a|"))
    (cond
       ((string= return "()")
         (setq control (concatenate 'string control " '~a ")))
       ((string= return "%")
         (setq control (concatenate 'string control " '(~a) ")))
       (t
         (setq control (concatenate 'string control " '(|~a|)"))))
    (cond
       ((string= argslist "()")
         (setq control (concatenate 'string control " '~a ")))
       ((string= argslist "%")
         (setq control (concatenate 'string control " '(~a) ")))
       (t
         (setq control (concatenate 'string control " '(|~a|)"))))
    (setq control (concatenate 'string control " '~s)~%"))
    (format t control funcname return argslist (nreverse comment))
    (values)))

\end{chunk}

\chapter{Common Lisp Types}
\begin{verbatim}
Class      Class Precedence List

array      array t
bit-vector bit-vector vector array sequence t
character  character t
complex    complex number t
cons       cons list sequence t
float      float number t
integer    integer rational number t
list       list sequence t
null       null symbol list sequence t
number     number t
ratio      ratio rational number t
rational   rational number t
sequence   sequence t
string     string vector array sequence t
symbol     symbol t
t          t
vector     vector array sequence t
\end{verbatim}

\chapter{EBNF}

\section{For show output}

\begin{verbatim}
PARAM ::= UPPERCASELETTER        

DOMAINSPEC ::= DOMAIN
             | DOMAIN(%)
             | DOMAIN(PARAM)
             | DOMAIN(DOMAIN[,DOMAIN]*)

HASSPEC ::= 'if' '$' 'has' CATEGORY
          | 'if' PARAM 'has' CATEGORY
          | 'if' DOMAINSPEC 'has' CATEGORY
          | 'if' PARAM 'has' DOMAINSPEC

ANDSPEC ::= HASSPEC 'and' HASSPEC

ORSPEC ::= HASSPEC
         | HASSPEC 'or' ANDSPEC
         | ANDSPEC 'or' HAPSPEC
         | ANDSPEC 'or' ANDSPEC
         | ORSPEC 'or' HASSPEC
         | ORSPEC 'or' ANDSPEC
         | ORSPEC 'or' ORSPEC

IFSPEC ::= HASSPEC
         | ANDSPEC
         | ORSPEC

FUNCSPEC ::= '(' PARAM '->' PARAM ')'

DPSPEC ::= '%'
         | PARAM
         | DOMAINSPEC
         | FUNCSPEC

TWOLIST ::= '(' DPSPEC ',' DPSPEC ')'

CONSTANT ::= '0'
           | '1'

PREFIX ::= '#?'
         | '-?'

INFIX ::= '?**?' 
        | '?*?'
        | '?-?'

UNIONSPEC ::= 'Union' '(' DPSPEC ',' '"failed"' ')'

KEYSPEC ::= Symbol ':' DOMAIN
          | Symbol ':' PARAM

RECORDSPEC ::= 'Record' '(' KEYSPEC [',' KEYSPEC]* ')'

CONSTANT ':' '()'    '->' '%'
CONSTANT ':' '()'    '->' '%' IFSPEC
PREFIX   ':' DPSPEC  '->' DPSPEC
PREFIX   ':' DPSPEC  '->' DPSPEC IFSPEC
INFIX    ':' TWOLIST '->' DPSPEC
INFIX    ':' TWOLIST '->' DPSPEC IFSPEC
INFIX    ':' TWOLIST '->' UNIONSPEC
'?..?' ':' '(' '%' ',' '%' ')' '->' '%'
'?..?' ':' '(' 'S' ',' 'S' ')' '->' '%'
'?.?'  ':' '(' '%' ',' DPSPEC ')' '->' DPSPEC
'?.count'  ':' '(' '%' ',' 'count' ')' '->' DPSPEC
'?.first  ':' '(' '%' ',' 'first' ')' '->' RECORDSPEC
'?.last  ':' '(' '%' ',' 'last' ')' '->' DPSPEC
'?.last  ':' '(' '%' ',' 'last' ')' '->' DP
'?.last  ':' '(' '%' ',' 'last' ')' '->' RECORDSPEC
'?.last  ':' '(' '%' ',' 'last' ')' '->' PARAM
'?.left  ':' '(' '%' ',' 'left' ')' '->' '%'
'?.rest  ':' '(' '%' ',' 'rest' ')' '->' '%'
'?.right  ':' '(' '%' ',' 'right' ')' '->' '%'
'?.sort  ':' '(' '%' ',' 'sort' ')' '->' '%'
'?.unique  ':' '(' '%' ',' 'unique' ')' '->' '%'
'?.value  ':' '(' '%' ',' 'value' ')' '->' RECORDSPEC
'?.value  ':' '(' '%' ',' 'value' ')' '->' PARAM
'?.value  ':' '(' '%' ',' 'value' ')' '->' DOMAINSPEC
\end{verbatim}

\chapter{The Compiler}

\chapter{Sane Interpreter}

\index[code]{defmacro!must}
\index[code]{must!defmacro}
\begin{chunk}{defmacro must}
(defmacro must (FSMname input)
  `(let (text)
     (if (setq text ,FSMname ,input)
       (progn (format t "ACCEPT ~a~%" text) t)
       (progn (format t "FAILED ~a~%" text) nil))))

\end{chunk}

\index[code]{defmacro!expect}
\index[code]{expect!defmacro}
\begin{chunk}{defmacro expect}
(defmacro expect (FSMname input)
  `(let (text)
     (if (setq text ,FSMname ,input)
       (format t "ACCEPT ~a~%" text)
       (format t "FAILED ~a~%" text))))

\end{chunk}

This is the top loop of the Sane interpreter.

It defines a function {\bf bye} which only exists for the lifetime of
the interpreter. When called from the Sane command line, {\bf bye}
returns the gensym. If that gensym is seen the Sane interpreter makes
the {\bf bye} unbound and exits. Note that we save any existing
definition of {\bf bye} and restore it when the interpreter exits.

\sig{sane}{nil}{nil}
\index[code]{defun!sane}
\index[code]{sane!defun}
\begin{chunk}{defun sane}
(defun sane ()
  (let (input result)
    (labels (
      (printType (thing)
        (typecase thing
         (string "String")
         (array "Array")
         (bit-vector "Bit-vector")
         (character "Character")
         (complex "Complex")
         (null "Null")
         (list "List")
         (cons "Cons")
         (float "Float")
         (integer "Integer")
         (rational "Rational")
         (number "Number")
         (ratio "Ratio")
         (sequence "Sequence")
         (t "t")
         (symbol "Symbol")
         (vector "Vector")))
      (localHelp ()
        ; define a help command
        (setq result "beyond it"))
    )
    (loop do 
      (format t "S> ") 
      (force-output) 
      (setq input (read))
      (cond
        ((eq input 'bye) (return))
        ((eq input 'help) (localHelp))
        (t (setq result (eval input))))
      (format t "  ~s~%       Type: ~a~%" result (printType result))
      (terpri)))))

\end{chunk}

\chapter{Axioms and Logic Rules}

\begin{quote}
{\bf Dieudonn\'e suggests that casual reasoning is a childhood disease
of mathematical areas.}\\
-- Arthur Jaffe and Frank Quinn \cite{Jaff93}
\end{quote}

\begin{quote}
{\bf What mathematicians are accomplishing is to advance human
understanding of mathematics.}\\
-- William P. Thurston \cite{Thur94}
\end{quote}

\begin{quote}
{\bf If you make the tools, you make the rules}\\
-- Andrew Dana Hudson \cite{Huds19}
\end{quote}

Collected here are some axioms that need to be distributed among the
various categories so that they can be inherited at the proper time.

There is an interesting design question.

Axiom already has a mechanism for inheriting signatures from
categories. That is, we can get a plus signature from, say, the
Integer category.

Suppose we follow the same pattern. Currently Axiom inherits certain
so-called ``attributes'', such as ApproximateAttribute, which implies
that the computation results are only approximate.

We could adapt the same mechanism to inherit the Transitive
property. In fact, if we follow the ``tiny theory'' approach of
Carette and Farmer where each property is in its own inheritable
category, then we can ``mix and match'' the axioms at will.

An axiom category would also export a function. This function would
essentially be a ``tactic'' used in a proof. It would modify the proof
step by applying the function to the step.

Theorems could have the same structure.

This allows theorems to be constructed at run time (since 
Axiom supports ``First Class Dynamic Types''.

In addition, this design can be "pushed down" into the Spad language
so that Spad statements (e.g. assignment) had proof-related
properties. A ramge such as [1..10] would provide explicit bounds in a
proof ``by language definition''. Defining the logical properties of
language statements in this way would make it easier to construct
proofs since the invariants would be partially constructed already.

The design merges the computer algebra inheritance structure with the
proof of algorithms structure, all under the same mechanism.

{\bf Reflexivity}

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$e=e$}
\end{prooftree}

{\bf Symmetry}

\begin{prooftree}
\AxiomC{$e_2=e_1$}
\UnaryInfC{$e_1=e_2$}
\end{prooftree}

{\bf Transitivity}

\begin{prooftree}
\AxiomC{$e_1=e_3$}
\AxiomC{$e_3=e_2$}
\BinaryInfC{$e_1=e_2$}
\end{prooftree}

{\bf Congruence}

\begin{prooftree}
\AxiomC{$f=f^\prime$}
\AxiomC{$e_1=e_1^\prime$}
\AxiomC{$\ldots$}
\AxiomC{$e_n=e_n^\prime$}
\QuaternaryInfC{$f(e_1,\ldots,e_n)=f^\prime(e_1^\prime,\ldots,e_n^\prime)$}
\end{prooftree}

For SemiRings we know that
\[\begin{array}{rcl}
(a+b)+c&=& a+(b+c)\\
0+a    &=& a\\
a+0    &=& a\\
a+b    &=& b+a\\
(a\times b)\times c&=&a\times(b\times c)\\
1\times a &=& a\\
a\times 1 &=& a\\
a\times(b+c) &=& (a\times b)+(a\times c)\\
(a+b)\times c &=& (a\times c)+(b\times c)\\
0\times a &=& 0\\
a\times 0 &=& 0\\
\end{array}\]

For Rng we have

An rng is a set $R$ with two binary operations $(+,-)$ such that
\begin{itemize}
\item $(R,+)$ is an abelian group
\item $(R,-)$ is a semigroup
\item Multiplication distributes over additin
\item $f(x+y) = f(x)+f(y)$
\item $f(x*y) = f(x)*f(y)$
\end{itemize}
An rng does not have an identity element.

{\bf Variable}

\begin{prooftree}
\AxiomC{$\langle x^{\tau},\sigma,\Gamma\rangle \to 
\langle \sigma (x^{\tau}),\sigma,\Gamma\rangle$}
\end{prooftree}

{\bf Call-Arguments}

\begin{prooftree}
\AxiomC{$\langle e_i,\sigma,\Gamma\rangle \to 
\langle e_i^\prime, \sigma^\prime, \Gamma\rangle$}
\UnaryInfC{$e_0 (v_1,\ldots,e_i,\ldots,e_n),\sigma,\Gamma\rangle\to
\langle e_0 (v_1,\ldots,e_i^\prime,\ldots,e_n),\sigma^\prime,\Gamma\rangle$}
\end{prooftree}
where the $x_i$ are parameters of $v_0$

{\bf Call-Operator}

\begin{prooftree}
\AxiomC{$\langle e_0,\sigma,\Gamma\rangle \to
\langle e_0,\sigma^\prime,\Gamma\rangle$}
\UnaryInfC{$\langle e_0 (v_1,\ldots,v_n),\sigma,\Gamma\rangle \to
\langle e_0^\prime (v_1,\ldots,v_n),\sigma^\prime,\Gamma\rangle$}
\end{prooftree}
where the $x_i$ are the parameters of $v_0$

{\bf Call}

\begin{prooftree}
\AxiomC{$\langle v_0^{\tau_0}(v_1^{\tau_1},\ldots,v_n^{\tau_n}),
\sigma,\Gamma\rangle
\to \langle v_0^{\tau_0}[v_1^{\tau_1}/x_1,\ldots,
v_n^{\tau_n}/x_n],\sigma,\Gamma\rangle$}
\end{prooftree}
where the $x_i$ are parameters of $v_0$

{\bf Qualified Expression}

\begin{prooftree}
\AxiomC{$\begin{array}{ccc}
& \langle \delta_1,\sigma,\Gamma_1\rangle \to
\langle\delta_1^\prime,\sigma,\Gamma_2\rangle 
& \langle\delta_2,\sigma,\Gamma_2\rangle \to
\langle\delta_2^\prime,\sigma,\Gamma_3\rangle\\
\cdots
& \langle\delta_n,\sigma,\Gamma_n\rangle \to
\langle\delta_n^\prime,\sigma,\Gamma_{n+1}\rangle
& \langle e,\sigma,\Gamma_{n+1}\rangle \to
\langle e^\prime,\sigma^\prime,\Gamma_{n+2}\rangle
\end{array}$}
\UnaryInfC{$\langle e {\rm\ where\ }\delta_1\cdots\delta_n,\sigma,\Gamma_1
\rangle \to \langle e^\prime,\sigma^\prime,\Gamma_{n+2}\rangle$}
\end{prooftree}

{\bf Sequence-Head}

\begin{prooftree}
\AxiomC{$\langle s_1,\sigma_1,\Gamma_1\rangle\to
\langle s_1^\prime,\sigma_2,\Gamma_2\rangle$}
\UnaryInfC{$\langle s_1;s_2,\sigma_1,\Gamma_1\rangle\to
\langle s_1^\prime;s_2,\sigma_2,\Gamma_2\rangle$}
\end{prooftree}

{\bf Sequence-Tail}

\begin{prooftree}
\AxiomC{$\langle v_1;s_2,\sigma,\Gamma\rangle\to
\langle s_2,\sigma,\Gamma\rangle$}
\end{prooftree}

{\bf If-True}

\begin{prooftree}
\AxiomC{$\langle s_1,\sigma,\Gamma\rangle\to
\langle s_1^\prime,\sigma^\prime,\Gamma^\prime\rangle$}
\UnaryInfC{$\langle {\rm\ if\ true\ then\ }s_1; s_2,\sigma,\Gamma\rangle\to
\langle s_1^\prime,\sigma^\prime,\Gamma^\prime\rangle$}
\end{prooftree}

{\bf If-False}

\begin{prooftree}
\AxiomC{$\langle s_2,\sigma,\Gamma\rangle\to
\langle s_2^\prime,\sigma^\prime,\Gamma^\prime\rangle$}
\UnaryInfC{$\langle {\rm\ if\ false\ then\ } s_1; s_2,\sigma,\Gamma\rangle\to
\langle s_2^\prime,\sigma^\prime,\Gamma^\prime\rangle$}
\end{prooftree}

{\bf Assignment-Left}

\begin{prooftree}
\AxiomC{$\langle e_1,\sigma_0,\Gamma\rangle \to
\langle e_1^\prime, \sigma_1, \Gamma\rangle$}
\UnaryInfC{$\langle e_1:=e_2,\sigma,\Gamma\rangle\to
\langle e_1^\prime:=e_2,\sigma_1,\Gamma\rangle$}
\end{prooftree}

{\bf Assignment-Right}

\begin{prooftree}
\AxiomC{$\langle e_2,\sigma,\Gamma\rangle \to
\langle e_2^\prime,\sigma^\prime,\Gamma\rangle$}
\UnaryInfC{$\langle l:=e_2,\sigma,\Gamma\rangle\to
\langle l:=e_2^\prime,\sigma^\prime,\Gamma\rangle$}
\end{prooftree}

{\bf Assignment}

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\langle l:=v^{\tau},\sigma,\Gamma\rangle\to
\langle v^{\tau},\sigma[v^{\tau}/l],\Gamma\rangle$}
\end{prooftree}

{\bf Immediate Definition}

\begin{prooftree}
\AxiomC{$\langle e,\sigma,\Gamma\rangle\to
\langle e^\prime,\sigma_1,\Gamma\rangle$}
\UnaryInfC{$\langle x:\tau:=e,\sigma,\Gamma\rangle\to
\langle x:\tau:=e^\prime,\sigma_1,\Gamma\rangle$}
\end{prooftree}

{\bf Immediate Definition}

\begin{prooftree}
\AxiomC{$\langle x:\tau:=v^{\tau},\sigma,\Gamma\rangle\to
\langle v^{\tau},\sigma,\Gamma,x^{\tau}==v^{\tau}\rangle$}
\end{prooftree}

\chapter{The Categories}

One of the primary concerns is {\bf Coherence} \cite{Bott19} of these
type definitions. Because we are using CLOS the system automatically
computes the coherence between types.

Axiom computes type resolution based on {\sl modemaps} but the
talk by Bottu and Mardirosian \cite{Bott19} does type resolution
by creating unique names instead. 

There are patterns in the following code. Violating these patterns
will generate obscure bugs so be careful. Lets assume a given class.

\begin{verbatim}
(defclass |GcdDomainType| (|LeftOreRingType| |IntegralDomainType|)
  ((parents :initform '(|LeftOreRing| |IntegralDomain|))
   (name :initform "GcdDomain")
   (level :initform 12)
   (abbreviation :initform 'GCDDOM)))

(defvar |GcdDomain|
  (progn
    (push '|GcdDomain| *Categories*)
    (make-instance '|GcdDomainType|)))

\end{verbatim}

Notice the following properties:

The classname {\bf GcdDomainType} is escaped so that it will 
retain its case no matter which lisp is used.

The classname {\bf GcdDomainType} ends with ``Type''.

The classes it depends on all end with ``Type''.

The parent attribute list is in the same order as the list
used for inheritance. Failure to do this will result in 
an incorrect ordering of lookups.

The parent attributes do NOT end in with ``Type'' as they
are instances. Putting ``Type'' in the name will result in
an obscure circular reference error at compile time.

The name is given at the class level. It must be provided
as it is used in printing the object.

The level attribute is read-only.

The {\bf GcdDomain} variable adds its name to the global
variable *Categories* so we maintain a current list.

We need to call make-instance at compile time in order
to force MOP::finalize-inheritance, otherwise the 
compiler will find some random reason to complain.


\section{Level 1}

This is a searchable list of all of the Categories in level 1.
\begin{chunk}{defvar level1}
(defvar level1
 '(|AdditiveValuationAttribute| |ApproximateAttribute|
   |ArbitraryExponentAttribute| |ArbitraryPrecisionAttribute|
   |ArcHyperbolicFunctionCategory| |ArcTrigonometricFunctionCategory|
   |AttributeRegistry| |BasicType| |CanonicalAttribute|
   |CanonicalClosedAttribute| |CanonicalUnitNormalAttribute| |CentralAttribute|
   |CoercibleTo| |CombinatorialFunctionCategory| |CommutativeStarAttribute|
   |ConvertibleTo| |ElementaryFunctionCategory| |Eltable|
   |FiniteAggregateAttribute| |HyperbolicFunctionCategory| |InnerEvalable|
   |JacobiIdentityAttribute| |LazyRepresentationAttribute| |LeftUnitaryAttribute|
   |ModularAlgebraicGcdOperations| |MultiplicativeValuationAttribute|
   |NoZeroDivisorsAttribute| |NotherianAttribute| |NullSquareAttribute|
   |OpenMath| |PartialTranscendentalFunctions| |PartiallyOrderedSetAttribute|
   |PrimitiveFunctionCategory| |RadicalCategory| |RetractableTo|
   |RightUnitaryAttribute| |ShallowlyMutableAttribute| |SpecialFunctionCategory|
   |TrigonometricFunctionCategory| |Type| |UnitsKnownAttribute|))

\end{chunk}

\subsection{AdditiveValuationAttribute}
\index[cat]{AdditiveValuationAttribute!Category}
\index[cat]{Category!AdditiveValuationAttribute}
\index[cat]{ATADDVA}
\begin{chunk}{defclass AdditiveValuationAttributeType}
(defclass |AdditiveValuationAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AdditiveValuationAttributeType")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATADDVA)
   (comment :initform (list
     "The class of all euclidean domains such that"
     "euclideanSize(a*b) = EuclideanSize(a)+euclideanSize(b)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AdditiveValuationAttribute|
  (progn
    (push '|AdditiveValuationAttribute| *Categories*)
    (make-instance '|AdditiveValuationAttributeType|)))

\end{chunk}

\subsection{ApproximateAttribute}
\index[cat]{ApproximateAttribute!Category}
\index[cat]{Category!ApproximateAttribute}
\index[cat]{ATAPPRO}
\begin{chunk}{defclass ApproximateAttributeType}
(defclass |ApproximateAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ApproximateAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATAPPRO)
   (comment :initform (list
     "An approximation to the real numbers."))))

(defvar |ApproximateAttribute|
  (progn
    (push '|ApproximateAttribute| *Categories*)
    (make-instance '|ApproximateAttributeType|)))

\end{chunk}

\subsection{ArbitraryExponentAttribute}
\index[cat]{ArbitraryExponentAttribute!Category}
\index[cat]{Category!ArbitraryExponentAttribute}
\index[cat]{ATARBEX}
\begin{chunk}{defclass ArbitraryExponentAttributeType}
(defclass |ArbitraryExponentAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ArbitraryExponentAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATARBEX)
   (comment :initform (list
     "Approximate numbers with arbitrarily large exponents"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ArbitraryExponentAttribute|
  (progn
    (push '|ArbitraryExponentAttribute| *Categories*)
    (make-instance '|ArbitraryExponentAttributeType|)))

\end{chunk}

\subsection{ArbitraryPrecisionAttribute}
\index[cat]{ArbitraryPrecisionAttribute!Category}
\index[cat]{Category!ArbitraryPrecisionAttribute}
\index[cat]{ATARBPR}
\begin{chunk}{defclass ArbitraryPrecisionAttributeType}
(defclass |ArbitraryPrecisionAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ArbitraryPrecisionAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATARBPR)
   (comment :initform (list
     "Approximate numbers for which the user can set the precision"
     "for subsequent calculations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ArbitraryPrecisionAttribute|
  (progn
    (push '|ArbitraryPrecisionAttribute| *Categories*)
    (make-instance '|ArbitraryPrecisionAttributeType|)))

\end{chunk}

\subsection{ArcHyperbolicFunctionCategory}
\index[cat]{ArcHyperbolicFunctionCategory!Category}
\index[cat]{Category!ArcHyperbolicFunctionCategory}
\index[cat]{AHYP}
\begin{chunk}{defclass ArcHyperbolicFunctionCategoryType}
(defclass |ArcHyperbolicFunctionCategoryType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ArcHyperbolicFunctionCategory")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'AHYP)
   (comment :initform (list
     "Category for the inverse hyperbolic trigonometric functions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list 
     (make-signature '|acosh| '(%) '(%)
       '("acosh(x) returns the hyperbolic arc-cosine of x."))
     (make-signature '|acoth| '(%) '(%)
       '("acoth(x) returns the hyperbolic arc-cotangent of x."))
     (make-signature '|acsch| '(%) '(%)
       '("acsch(x) returns the hyperbolic arc-cosecant of x."))
     (make-signature '|asech| '(%) '(%)
       '("asech(x) returns the hyperbolic arc-secant of x."))
     (make-signature '|asinh| '(%) '(%)
       '("asinh(x) returns the hyperbolic arc-sine of x."))
     (make-signature '|atanh| '(%) '(%)
       '("atanh(x) returns the hyperbolic arc-tangent of x."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ArcHyperbolicFunctionCategory|
  (progn
    (push '|ArcHyperbolicFunctionCategory| *Categories*)
    (make-instance '|ArcHyperbolicFunctionCategoryType|)))

\end{chunk}

\subsection{ArcTrigonometricFunctionCategory}
\index[cat]{ArcTrigonometricFunctionCategory!Category}
\index[cat]{Category!ArcTrigonometricFunctionCategory}
\index[cat]{ATRIG}
\begin{chunk}{defclass ArcTrigonometricFunctionCategoryType}
(defclass |ArcTrigonometricFunctionCategoryType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ArcTrigonometricFunctionCategory")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATRIG)
   (comment :initform (list
     "Category for the inverse trigonometric functions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list 
     (make-signature '|acos| '(%) '(%)
       '("acos(x) returns the arc-cosine of x. When evaluated"
         "into some subset of the complex numbers, one"
         "branch cut for acos lies along the negative real axis"
         "to the left of -1 (inclusive), continuous with the"
         "upper half plane, the other along the positive real axis to"
         "the right of 1 (inclusive), continuous with the lower half"
         "plane."))
     (make-signature '|acot| '(%) '(%)
       '("acot(x) returns the arc-cotangent of x."))
     (make-signature '|acsc| '(%) '(%)
       '("acsc(x) returns the arc-cosecant of x."))
     (make-signature '|asec| '(%) '(%)
       '("asec(x) returns the arc-secant of x."))
     (make-signature '|asin| '(%) '(%)
       '("asin(x) returns the arc-sine of x. When evaluated into some"
         "subset of the complex numbers, one branch cut for asin lies"
         "along the negative real axis to the left of -1 (inclusive),"
         "continuous with the upper half plane, the other along the"
         "positive real axis to the right of 1 (inclusive), continuous"
         "with the lower half plane."))
     (make-signature '|atan| '(%) '(%)
       '("atan(x) returns the arc-tangent of x. When evaluated into some"
         "subset of the complex numbers, one branch cut for atan lies"
         "along the positive imaginary axis above %i (exclusive),"
         "continuous with the left half plane, the other along the"
         "negative imaginary axis below -%i (exclusive) continuous"
         "with the right half plane. The domain does not contain %i and -%i"))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ArcTrigonometricFunctionCategory|
  (progn
    (push '|ArcTrigonometricFunctionCategory| *Categories*)
    (make-instance '|ArcTrigonometricFunctionCategoryType|)))

\end{chunk}

\subsection{AttributeRegistry}
\index[cat]{AttributeRegistry!Category}
\index[cat]{Category!AttributeRegistry}
\index[cat]{ATTREG}
\begin{chunk}{defclass AttributeRegistryType}
(defclass |AttributeRegistryType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AttributeRegistry")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATTREG)
   (comment :initform (list
     "This category exports the attributes in the AXIOM Library"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list 
     (make-signature '|finiteAggregate| () ()
       '("finiteAggregate is true if it is an aggregate with a"
         "finite number of elements."))
     (make-signature '|commutative("*")| () ()
       '("commutative(\"*\") is true if it has an operation"
         "\"*\": (D,D) -> D} which is commutative."))
     (make-signature '|shallowlyMutable| () ()
       '("shallowlyMutable is true if its values"
         "have immediate components that are updateable (mutable)."
         "Note that the properties of any component domain are"
         "irrevelant to the shallowlyMutable proper."))
     (make-signature '|unitsKnown| () ()
       '("unitsKnown is true if a monoid (a multiplicative semigroup"
         "with a 1) has unitsKnown means that"
         "the operation recip can only return \"failed\""
         "if its argument is not a unit."))
     (make-signature '|leftUnitary| () ()
       '("leftUnitary is true if 1 * x = x for all x."))
     (make-signature '|rightUnitary| () ()
       '("rightUnitary is true if x * 1 = x for all x."))
     (make-signature '|noZeroDivisors| () ()
       '("noZeroDivisors is true if x * y ~= 0 implies"
         "both x and y are non-zero."))
     (make-signature '|canonicalUnitNormal| () ()
       '("canonicalUnitNormal is true if we can choose a canonical"
         "representative for each class of associate elements, that is"
         "associates?(a,b) returns true if and only if"
         "unitCanonical(a) = unitCanonical(b)."))
     (make-signature '|canonicalsClosed| () ()
       '("canonicalsClosed is true if"
         "unitCanonical(a)*unitCanonical(b) = unitCanonical(a*b)."))
     (make-signature '|arbitraryPrecision| () ()
       '("arbitraryPrecision means the user can set the"
         "precision for subsequent calculations."))
     (make-signature '|partiallyOrderedSet| () ()
       '("partiallyOrderedSet is true if"
         "a set with < which is transitive,"
         "but not(a < b or a = b)"
         "does not necessarily imply b<a."))
     (make-signature '|central| () ()
       '("central is true if, given an algebra over a ring R,"
         "the image of R is the center of the algebra, For example,"
         "the set of members of the algebra which commute with all"
         "others is precisely the image of R in the algebra."))
     (make-signature '|noetherian| () ()
       '("noetherian is true if all of its ideals are"
         "finitely generated."))
     (make-signature '|additiveValuation| () ()
       '("additiveValuation implies"
         "euclideanSize(a*b)=euclideanSize(a)+euclideanSize(b)."))
     (make-signature '|multiplicativeValuation| () ()
       '("multiplicativeValuation implies"
         "euclideanSize(a*b)=euclideanSize(a)*euclideanSize(b)."))
     (make-signature '|NullSquare| () ()
       '("NullSquare means that [x,x] = 0 holds."
         "See LieAlgebra."))
     (make-signature '|JacobiIdentity| () ()
       '("JacobiIdentity means that"
         "[x,[y,z]]+[y,[z,x]]+[z,[x,y]] = 0 holds."
         "See LieAlgebra."))
     (make-signature '|canonical| () ()
       '("canonical is true if and only if distinct elements have"
         "distinct data structures. For example, a domain of mathematical"
         "objects  which has the canonical attribute means that two"
         "objects are mathematically equal if and only if their data"
         "structures are equal."))
     (make-signature '|approximate| () ()
       '("approximate means 'is an approximation to the"
         "real numbers'."))
     ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AttributeRegistry|
  (progn
    (push '|AttributeRegistry| *Categories*)
    (make-instance '|AttributeRegistryType|)))

\end{chunk}

\subsection{BasicType}
\index[cat]{BasicType!Category}
\index[cat]{Category!BasicType}
\index[cat]{BASTYPE}
\begin{chunk}{defclass BasicTypeType}
(defclass |BasicTypeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "BasicType")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'BASTYPE)
   (comment :initform (list
     "BasicType is the basic category for describing a collection"
     "of elements with = (equality)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|=| '(|Boolean|) '(% %)
       '("x=y tests if x and y are equal.") () t)
     (make-signature '|~=| '(|Boolean|) '(% %)
       '("x~=y tests if x and y are not equal.") () t)
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BasicType|
  (progn
    (push '|BasicType| *Categories*)
    (make-instance '|BasicTypeType|)))

\end{chunk}
\begin{verbatim}
(
 ?~=? : (%,%) -> Boolean
 (~= (((|Boolean|) $ $) 7))

 ?=? : (%,%) -> Boolean
 (= (((|Boolean|) $ $) 6)))
\end{verbatim}

\subsubsection{BASTYPE Source Code}
\begin{verbatim}
)abbrev category BASTYPE BasicType
--% BasicType
++ Description:
++ BasicType is the basic category for describing a collection
++ of elements with = (equality).

BasicType() : Category == SIG where

  SIG ==> with

    "=" : (%,%) -> Boolean
      ++ x=y tests if x and y are equal.

    "~=" : (%,%) -> Boolean   
      ++ x~=y tests if x and y are not equal.

   add

     _~_=(x:%,y:%) : Boolean == not(x=y)

\end{verbatim}

\subsubsection{BASTYPE Lisp Code (other)}
\begin{verbatim}
BasicType : Category == Type with
  =: (%,%) -> Boolean
  ~=: (%,%) -> Boolean

(def BasicType;AL nil)
(def BasicType;
  (lambda ()
    (bind ((g (Join (Type)
               (mkCategory domain
	         '(((= ((Boolean) $ $)) true)
		   ((~= ((Boolean) $ $)) true)
		   ((before? ((Boolean $ $)) true))
		 nil '((Boolean)) nil))))
          (store (tref g 0) '(BasicType))
	  g))))

(def BasicType
  (lambda ()
    (when ((not (eq BasicType;AL nil)) BasicType;AL)
          (t (store BasicType;AL (BasicType;))))))

\end{verbatim}

\subsubsection{BASTYPE.lsp}
\begin{verbatim}
(/VERSIONCHECK 2) 

(SETQ |BasicType;AL| (QUOTE NIL)) 

(DEFUN |BasicType| NIL
 (LET (#:G1588)
   (COND 
     (|BasicType;AL|) 
     (T (SETQ |BasicType;AL| (|BasicType;|)))))) 

(DEFUN |BasicType;| NIL
 (PROG (#0=#1=#:G1586)
   (RETURN
     (PROG1 
       (LETT #0#
         (|Join| 
           (|mkCategory| 
             (QUOTE |domain|) 
             (QUOTE (((= ((|Boolean|) $ $)) T)
                     ((~= ((|Boolean|) $ $)) T)))
             NIL
             (QUOTE ((|Boolean|))) NIL))
         |BasicType|)
       (SETELT #0# 0 (QUOTE (|BasicType|))))))) 

(SETF (GET (QUOTE |BasicType|) (QUOTE NILADIC)) T) 

\end{verbatim}

\subsubsection{BASTYPE index.kaf}
\begin{verbatim}
1057                
(SETQ |$CategoryFrame|
  (|put| 
    (QUOTE |BasicType|) 
    (QUOTE |isCategory|) 
    T 
    (|addModemap| 
      (QUOTE |BasicType|) 
      (QUOTE (|BasicType|)) 
      (QUOTE ((|Category|))) 
      T 
      (QUOTE |BasicType|) 
      |$CategoryFrame|)))
(SETF (GET (QUOTE |BasicType|) (QUOTE NILADIC)) T)
(|BasicType|)
|category|
(((|BasicType|) (|Category|)) (T |BasicType|))
(|Join| (CATEGORY |domain| (SIGNATURE = ((|Boolean|) $ $)) (SIGNATURE ~= ((|Boolean|) $ $))))
"/research/20190531/mnt/ubuntu/../../src/algebra/BASTYPE.spad"
((~= (*1 *2 *1 *1) (AND (|ofCategory| *1 (|BasicType|)) (|isDomain| *2 (|Boolean|))))
  (= (*1 *2 *1 *1) (AND (|ofCategory| *1 (|BasicType|)) (|isDomain| *2 (|Boolean|)))))
((~= (((|Boolean|) $ $) 7)) (= (((|Boolean|) $ $) 6)))
((|BASTYPE-;~=;2SB;1| ((|Boolean|) S S)))
BASTYPE
((|constructor| 
 (NIL "BasicType is the basic category for describing a collection of elements with = (equality)."))
 (~= (((|Boolean|) $ $) "\\spad{x~=y} tests if \\spad{x} and \\spad{y} are not equal."))
 (= (((|Boolean|) $ $) "\\spad{x=y} tests if \\spad{x} and \\spad{y} are equal.")))
(("slot1Info" 0 NIL)
 ("documentation" 0 770)
 ("ancestors" 0 NIL)
 ("parents" 0 NIL)
 ("abbreviation" 0 762)
 ("predicates" 0 NIL)
 ("attributes" 0 NIL)
 ("signaturesAndLocals" 0 720)
 ("superDomain" 0 NIL)
 ("operationAlist" 0 665)
 ("modemaps" 0 494)
 ("sourceFile" 0 431)
 ("constructorCategory" 0 337)
 ("constructorModemap" 0 290)
 ("constructorKind" 0 279)
 ("constructorForm" 0 265)
 ("NILADIC" 0 214)
 ("compilerInfo" 0 20))

\end{verbatim}

\subsubsection{BASICTYPE database struct}
\begin{verbatim}
)lisp (showdatabase '|BasicType|)
getdatabase call: BasicType            CONSTRUCTORKIND
CONSTRUCTORKIND: category
getdatabase call: BasicType            COSIG
COSIG: (NIL)
getdatabase call: BasicType            OPERATION
OPERATION: NIL
CONSTRUCTORMODEMAP: 
getdatabase call: BasicType            CONSTRUCTORMODEMAP
getdatabase miss: BasicType            CONSTRUCTORMODEMAP

(((|BasicType|) (|Category|)) (T |BasicType|))
CONSTRUCTORCATEGORY: 
getdatabase call: BasicType            CONSTRUCTORCATEGORY
getdatabase miss: BasicType            CONSTRUCTORCATEGORY

(|Join| (CATEGORY |domain| (SIGNATURE = ((|Boolean|) $ $))
            (SIGNATURE ~= ((|Boolean|) $ $))))
OPERATIONALIST: 
getdatabase call: BasicType            OPERATIONALIST
getdatabase miss: BasicType            OPERATIONALIST

((~= (((|Boolean|) $ $) 7)) (= (((|Boolean|) $ $) 6)))
MODEMAPS: 
getdatabase call: BasicType            MODEMAPS
getdatabase miss: BasicType            MODEMAPS

((~= (*1 *2 *1 *1)
     (AND (|ofCategory| *1 (|BasicType|)) (|isDomain| *2 (|Boolean|))))
 (= (*1 *2 *1 *1)
    (AND (|ofCategory| *1 (|BasicType|))
         (|isDomain| *2 (|Boolean|)))))
getdatabase call: BasicType            HASCATEGORY
HASCATEGORY: NIL
getdatabase call: BasicType            OBJECT
OBJECT: /mnt/c/Users/markb/EXE/axiom/mnt/ubuntu/algebra/BASTYPE.o
getdatabase call: BasicType            NILADIC
NILADIC: T
getdatabase call: BasicType            ABBREVIATION
ABBREVIATION: BASTYPE
getdatabase call: BasicType            CONSTRUCTOR?
CONSTRUCTOR?: T
getdatabase call: BasicType            CONSTRUCTOR
CONSTRUCTOR: NIL
getdatabase call: BasicType            DEFAULTDOMAIN
DEFAULTDOMAIN: NIL
getdatabase call: BasicType            ANCESTORS
ANCESTORS: NIL
getdatabase call: BasicType            SOURCEFILE
SOURCEFILE: bookvol10.2.pamphlet
getdatabase call: BasicType            CONSTRUCTORFORM
getdatabase miss: BasicType            CONSTRUCTORFORM
CONSTRUCTORFORM: (BasicType)
getdatabase call: BasicType            CONSTRUCTORARGS
getdatabase call: BasicType            CONSTRUCTORFORM
CONSTRUCTORARGS: NIL
getdatabase call: BasicType            ATTRIBUTES
getdatabase miss: BasicType            ATTRIBUTES
ATTRIBUTES: NIL
PREDICATES: 
getdatabase call: BasicType            PREDICATES
getdatabase miss: BasicType            PREDICATES

NILgetdatabase call: BasicType            DOCUMENTATION
getdatabase miss: BasicType            DOCUMENTATION
DOCUMENTATION: 
  ((constructor (NIL BasicType is the basic category for describing a collection of elements with = (equality).))
   (~= (((Boolean) $ $) \spad{x~=y} tests if \spad{x} and \spad{y} are not equal.))
   (= (((Boolean) $ $) \spad{x=y} tests if \spad{x} and \spad{y} are equal.)))
getdatabase call: BasicType            PARENTS
PARENTS: NIL
Value = NIL

\end{verbatim}

\subsubsection{BASTYPE-.lsp}
\begin{verbatim}

(/VERSIONCHECK 2) 

(DEFUN |BASTYPE-;~=;2SB;1| (|x| |y| $)
  (COND
    ((SPADCALL |x| |y| (QREFELT $ 8)) (QUOTE NIL))
    ((QUOTE T) (QUOTE T)))) 

(DEFUN |BasicType&| (|#1|) 
  (PROG (DV$1 |dv$| $ |pv$|)
    (RETURN 
      (PROGN 
        (LETT DV$1 (|devaluate| |#1|) . #0=(|BasicType&|)) 
        (LETT |dv$| (LIST (QUOTE |BasicType&|) DV$1) . #0#)
        (LETT $ (MAKE-ARRAY 10) . #0#)
        (QSETREFV $ 0 |dv$|)
        (QSETREFV $ 3 (LETT |pv$| (|buildPredVector| 0 0 NIL) . #0#))
        (|stuffDomainSlots| $) (QSETREFV $ 6 |#1|)
        $)))) 

(SETF 
  (GET (QUOTE |BasicType&|) (QUOTE |infovec|))
  (LIST
   (QUOTE #(NIL NIL NIL NIL NIL NIL (|local| |#1|) (|Boolean|) (0 . =) |BASTYPE-;~=;2SB;1|))
   (QUOTE #(~= 6))
   (QUOTE NIL)
   (CONS 
     (|makeByteWordVec2| 1 (QUOTE NIL))
     (CONS 
       (QUOTE #())
       (CONS (QUOTE #()) (|makeByteWordVec2| 9 (QUOTE (2 6 7 0 0 8 2 0 7 0 0 9))))))
   (QUOTE |lookupComplete|))) 

\end{verbatim}

\subsubsection{BASTYPE- index.kaf}
\begin{verbatim}
1540                
(|updateSlot1DataBase| (QUOTE (|BasicType&| (NIL (~= ((7 0 0) 9))))))

(SETF 
  (GET (QUOTE |BasicType&|) (QUOTE |infovec|))
  (LIST 
    (QUOTE #(NIL NIL NIL NIL NIL NIL (|local| |#1|) (|Boolean|) (0 . =) |BASTYPE-;~=;2SB;1|))
    (QUOTE #(~= 6))
    (QUOTE NIL)
    (CONS
      (|makeByteWordVec2| 1 (QUOTE NIL))
      (CONS
        (QUOTE #())
        (CONS
          (QUOTE #())
          (|makeByteWordVec2| 9 (QUOTE (2 6 7 0 0 8 2 0 7 0 0 9))))))
    (QUOTE |lookupComplete|)))

(SETQ |$CategoryFrame|
  (|put| 
    (QUOTE |BasicType&|) 
    (QUOTE |isFunctor|) 
    (QUOTE (((~= ((|Boolean|) $ $)) T (ELT $ 9))))
  (|addModemap|
    (QUOTE |BasicType&|)
    (QUOTE (|BasicType&| |#1|))
    (QUOTE ((CATEGORY |domain| (SIGNATURE ~= ((|Boolean|) |#1| |#1|))) (|BasicType|)))
    T
    (QUOTE |BasicType&|)
    (|put| 
      (QUOTE |BasicType&|) 
      (QUOTE |mode|) 
      (QUOTE (|Mapping| (CATEGORY |domain| (SIGNATURE ~= ((|Boolean|) |#1| |#1|))) (|BasicType|)))
      |$CategoryFrame|))))
  (|BasicType&| S)
  |domain|
  (((|BasicType&| |#1|) 
    (CATEGORY |domain| (SIGNATURE ~= ((|Boolean|) |#1| |#1|)))
    (|BasicType|))
   (T |BasicType&|))
  (CATEGORY |domain| (SIGNATURE ~= ((|Boolean|) |#1| |#1|)))
  "/research/20190531/mnt/ubuntu/../../src/algebra/BASTYPE.spad"
  ((~= (((|Boolean|) $ $) 9)))
  ((|BASTYPE-;~=;2SB;1| ((|Boolean|) S S)))
  BASTYPE-
  ((|constructor|
     (NIL "BasicType is the basic category for describing a collection of elements with = (equality)."))
   (~= (((|Boolean|) $ $) "\\spad{x~=y} tests if \\spad{x} and \\spad{y} are not equal."))
   (= (((|Boolean|) $ $) "\\spad{x=y} tests if \\spad{x} and \\spad{y} are equal.")))
  (|BasicType&| (NIL (~= ((7 0 0) 9))))
  (("slot1Info" 0 1502)
   ("documentation" 0 1215)
   ("ancestors" 0 NIL)
   ("parents" 0 NIL)
   ("abbreviation" 0 1206)
   ("predicates" 0 NIL)
   ("attributes" 0 NIL)
   ("signaturesAndLocals" 0 1164)
   ("superDomain" 0 NIL)
   ("operationAlist" 0 1135)
   ("modemaps" 0 NIL)
   ("sourceFile" 0 1072)
   ("constructorCategory" 0 1013)
   ("constructorModemap" 0 899)
   ("constructorKind" 0 890)
   ("constructorForm" 0 873)
   ("compilerInfo" 0 429)
   ("loadTimeStuff" 0 90)
   ("slot1DataBase" 0 20))

\end{verbatim}

\subsubsection{BASICTYPE database struct}
\begin{verbatim}
)lisp (showdatabase '|BasicType&|)
getdatabase call: BasicType&           CONSTRUCTORKIND
CONSTRUCTORKIND: domain
getdatabase call: BasicType&           COSIG
COSIG: (NIL T)
getdatabase call: BasicType&           OPERATION
OPERATION: NIL
CONSTRUCTORMODEMAP: 
getdatabase call: BasicType&           CONSTRUCTORMODEMAP
getdatabase miss: BasicType&           CONSTRUCTORMODEMAP

(((|BasicType&| |#1|)
  (CATEGORY |domain| (SIGNATURE ~= ((|Boolean|) |#1| |#1|)))
  (|BasicType|))
 (T |BasicType&|))
CONSTRUCTORCATEGORY: 
getdatabase call: BasicType&           CONSTRUCTORCATEGORY
getdatabase miss: BasicType&           CONSTRUCTORCATEGORY

(CATEGORY |domain| (SIGNATURE ~= ((|Boolean|) |#1| |#1|)))
OPERATIONALIST: 
getdatabase call: BasicType&           OPERATIONALIST
getdatabase miss: BasicType&           OPERATIONALIST

((~= (((|Boolean|) $ $) 9)))
MODEMAPS: 
getdatabase call: BasicType&           MODEMAPS
getdatabase miss: BasicType&           MODEMAPS

NILgetdatabase call: BasicType&           HASCATEGORY
HASCATEGORY: NIL
getdatabase call: BasicType&           OBJECT
OBJECT: /mnt/c/Users/markb/EXE/axiom/mnt/ubuntu/algebra/BASTYPE-.o
getdatabase call: BasicType&           NILADIC
NILADIC: NIL
getdatabase call: BasicType&           ABBREVIATION
ABBREVIATION: BASTYPE-
getdatabase call: BasicType&           CONSTRUCTOR?
CONSTRUCTOR?: T
getdatabase call: BasicType&           CONSTRUCTOR
CONSTRUCTOR: NIL
getdatabase call: BasicType&           DEFAULTDOMAIN
DEFAULTDOMAIN: NIL
getdatabase call: BasicType&           ANCESTORS
ANCESTORS: NIL
getdatabase call: BasicType&           SOURCEFILE
SOURCEFILE: NIL
getdatabase call: BasicType&           CONSTRUCTORFORM
getdatabase miss: BasicType&           CONSTRUCTORFORM
CONSTRUCTORFORM: (BasicType& S)
getdatabase call: BasicType&           CONSTRUCTORARGS
getdatabase call: BasicType&           CONSTRUCTORFORM
CONSTRUCTORARGS: (S)
getdatabase call: BasicType&           ATTRIBUTES
getdatabase miss: BasicType&           ATTRIBUTES
ATTRIBUTES: NIL
PREDICATES: 
getdatabase call: BasicType&           PREDICATES
getdatabase miss: BasicType&           PREDICATES

NILgetdatabase call: BasicType&           DOCUMENTATION
getdatabase miss: BasicType&           DOCUMENTATION
DOCUMENTATION: ((constructor (NIL BasicType is the basic category for describing a collection of elements with = (equality).)) (~= (((Boolean) $ $) \spad{x~=y} tests if \spad{x} and \spad{y} are not equal.)) (= (((Boolean) $ $) \spad{x=y} tests if \spad{x} and \spad{y} are equal.)))
getdatabase call: BasicType&           PARENTS
PARENTS: NIL
Value = NIL

\end{verbatim}

\subsection{CanonicalAttribute}
\index[cat]{CanonicalAttribute!Category}
\index[cat]{Category!CanonicalAttribute}
\index[cat]{ATCANON}
\begin{chunk}{defclass CanonicalAttributeType}
(defclass |CanonicalAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CanonicalAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATCANON)
   (comment :initform (list
     "The class of all domains which have canonical represenntation,"
     "that is, mathematically equal elements have the same data structure."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CanonicalAttribute|
  (progn
    (push '|CanonicalAttribute| *Categories*)
    (make-instance '|CanonicalAttributeType|)))

\end{chunk}

\subsection{CanonicalClosedAttribute}
\index[cat]{CanonicalClosedAttribute!Category}
\index[cat]{Category!CanonicalClosedAttribute}
\index[cat]{ATCANCL}
\begin{chunk}{defclass CanonicalClosedAttributeType}
(defclass |CanonicalClosedAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CanonicalClosedAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATCANCL)
   (comment :initform (list
     "The class of all integral domains such that"
     "unitCanonical(a)*unitCanonical(b) = unitCanonical(a*b)}"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CanonicalClosedAttribute|
  (progn
    (push '|CanonicalClosedAttribute| *Categories*)
    (make-instance '|CanonicalClosedAttributeType|)))

\end{chunk}

\subsection{CanonicalUnitNormalAttribute}
\index[cat]{CanonicalUnitNormalAttribute!Category}
\index[cat]{Category!CanonicalUnitNormalAttribute}
\index[cat]{ATCUNOR}
\begin{chunk}{defclass CanonicalUnitNormalAttributeType}
(defclass |CanonicalUnitNormalAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CanonicalUnitNormalAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATCUNOR)
   (comment :initform (list
     "The class of all integral domains such that we can choose a canonical"
     "representative for each class of associate elements. That is,"
     "associates?(a,b) returns true if and only if"
     "unitCanonical(a) = unitCanonical(b)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CanonicalUnitNormalAttribute|
  (progn
    (push '|CanonicalUnitNormalAttribute| *Categories*)
    (make-instance '|CanonicalUnitNormalAttributeType|)))

\end{chunk}

\subsection{CentralAttribute}
\index[cat]{CentralAttribute!Category}
\index[cat]{Category!CentralAttribute}
\index[cat]{ATCENRL}
\begin{chunk}{defclass CentralAttributeType}
(defclass |CentralAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CentralAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATCENRL)
   (comment :initform (list
     "Central is true if, given an algebra over a ring R, the image of R"
     "is the center of the algebra. For example, the set of members of the"
     "algebra which commute with all others is precisely the image of R"
     "in the algebra."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CentralAttribute|
  (progn
    (push '|CentralAttribute| *Categories*)
    (make-instance '|CentralAttributeType|)))

\end{chunk}

\subsection{CoercibleTo}
\index[cat]{CoercibleTo!Category}
\index[cat]{Category!CoercibleTo}
\index[cat]{KOERCE}
\begin{chunk}{defclass CoercibleToType}
(defclass |CoercibleToType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CoercibleTo")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'KOERCE)
   (comment :initform (list
     "A is coercible to B means any element of A can automatically be"
     "converted into an element of B by the interpreter."))
   (argslist :initform (list (make-instance 'FSM-VAR :variable 'S :paramtype '|Type|)))
   (macros :initform nil)
   (withlist :initform (list 
     (make-signature '|coerce| 'S '(%)
       '("coerce(a) transforms a into an element of S."))))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CoercibleTo|
  (progn
    (push '|CoercibleTo| *Categories*)
    (make-instance '|CoercibleToType|)))

\end{chunk}

\subsection{CombinatorialFunctionCategory}
\index[cat]{CombinatorialFunctionCategory!Category}
\index[cat]{Category!CombinatorialFunctionCategory}
\index[cat]{CFCAT}
\begin{chunk}{defclass CombinatorialFunctionCategoryType}
(defclass |CombinatorialFunctionCategoryType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CombinatorialFunctionCategory")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'CFCAT)
   (comment :initform (list
     "Category for the usual combinatorial functions;"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list 
     (make-signature '|binomial| '% '(% %)
       '("binomial(n,r) returns the \spad{(n,r)} binomial coefficient"
         "(often denoted in the literature by \spad{C(n,r)})."
         "Note that \spad{C(n,r) = n!/(r!(n-r)!)} where \spad{n >= r >= 0}.")
       '("[binomial(5,i) for i in 0..5]"))
     (make-signature '|factorial| '% '(%)
       '("factorial(n) computes the factorial of n"
         "(denoted in the literature by \spad{n!})"
         "Note that \spad{n! = n (n-1)! when n > 0}; also, \spad{0! = 1}."))
     (make-signature '|permutation| '% '(% %)
       '("permutation(n, m) returns the number of"
         "permutations of n objects taken m at a time."
         "Note that \spad{permutation(n,m) = n!/(n-m)!}."))))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CombinatorialFunctionCategory|
  (progn
    (push '|CombinatorialFunctionCategory| *Categories*)
    (make-instance '|CombinatorialFunctionCategoryType|)))

\end{chunk}

\subsection{CommutativeStarAttribute}
\index[cat]{CommutativeStarAttribute!Category}
\index[cat]{Category!CommutativeStarAttribute}
\index[cat]{ATCS}
\begin{chunk}{defclass CommutativeStarAttributeType}
(defclass |CommutativeStarAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CommutativeStarAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATCS)
   (comment :initform (list
     "The class of all commutative semigroups in multiplicative notation."
     "In other words domain D with '*': (D,D) -> D} which is"
     "commutative. Typically applied to rings."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CommutativeStarAttribute|
  (progn
    (push '|CommutativeStarAttribute| *Categories*)
    (make-instance '|CommutativeStarAttributeType|)))

\end{chunk}

\subsection{ConvertibleTo}
\index[cat]{ConvertibleTo!Category}
\index[cat]{Category!ConvertibleTo}
\index[cat]{KONVERT}
\begin{chunk}{defclass ConvertibleToType}
(defclass |ConvertibleToType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ConvertibleTo")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'KONVERT)
   (comment :initform (list
     "A is convertible to B means any element of A"
     "can be converted into an element of B,"
     "but not automatically by the interpreter."))
   (argslist :initform (list (make-instance 'FSM-VAR :variable 'S :paramtype '|Type|)))
   (macros :initform nil)
   (withlist :initform (list 
     (make-signature '|convert| 'S '(%) 
       '("convert(a) transforms a into an element of S."))))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ConvertibleTo|
  (progn
    (push '|ConvertibleTo| *Categories*)
    (make-instance '|ConvertibleToType|)))

\end{chunk}

\subsection{ElementaryFunctionCategory}
\index[cat]{ElementaryFunctionCategory!Category}
\index[cat]{Category!ElementaryFunctionCategory}
\index[cat]{ELEMFUN}
\begin{chunk}{defclass ElementaryFunctionCategoryType}
(defclass |ElementaryFunctionCategoryType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ElementaryFunctionCategory")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ELEMFUN)
   (comment :initform (list
     "Category for the elementary functions;"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list 
     (make-signature '|log| '% '(%)
       '("log(x) returns the natural logarithm of x. When evaluated"
        "into some subset of the complex numbers, the branch cut lies"
        "along the negative real axis, continuous with quadrant II. The"
        "domain does not contain the origin."))
     (make-signature '|exp| '% '(%)
       '("exp(x) returns %e to the power x."))
     (make-signature '|**| '% '(% %)
       '("x**y returns x to the power y.") () t)))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ElementaryFunctionCategory|
  (progn
    (push '|ElementaryFunctionCategory| *Categories*)
    (make-instance '|ElementaryFunctionCategoryType|)))

\end{chunk}

\subsection{Eltable}
\index[cat]{Eltable!Category}
\index[cat]{Category!Eltable}
\index[cat]{ELTAB}
\begin{chunk}{defclass EltableType}
(defclass |EltableType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "Eltable")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ELTAB)
   (comment :initform (list
     "An eltable over domains D and I is a structure which can be viewed"
     "as a function from D to I. Examples of eltable structures range from"
     "data structures, For example, those of type List, to algebraic"
     "structures like Polynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|elt| '(|Index|) '(% S)
       '("elt(u,i) (also written: u . i) returns the element of u indexed by i."
         "Error: if i is not an index of u."))))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Eltable|
  (progn
    (push '|Eltable| *Categories*)
    (make-instance '|EltableType|)))

\end{chunk}

\subsection{FiniteAggregateAttribute}
\index[cat]{FiniteAggregateAttribute!Category}
\index[cat]{Category!FiniteAggregateAttribute}
\index[cat]{ATFINAG}
\begin{chunk}{defclass FiniteAggregateAttributeType}
(defclass |FiniteAggregateAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FiniteAggregateAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATFINAG)
   (comment :initform (list
     "The class of all aggregates with a finite number of arguments"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteAggregateAttribute|
  (progn
    (push '|FiniteAggregateAttribute| *Categories*)
    (make-instance '|FiniteAggregateAttributeType|)))

\end{chunk}

\subsection{HyperbolicFunctionCategory}
\index[cat]{HyperbolicFunctionCategory!Category}
\index[cat]{Category!HyperbolicFunctionCategory}
\index[cat]{HYPCAT}
\begin{chunk}{defclass HyperbolicFunctionCategoryType}
(defclass |HyperbolicFunctionCategoryType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "HyperbolicFunctionCategory")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'HYPCAT)
   (comment :initform (list
     "Category for the hyperbolic trigonometric functions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|cosh| '(%) '(%)
       '("cosh(x) returns the hyperbolic cosine of x."))
     (make-signature '|coth| '(%) '(%)
       '("coth(x) returns the hyperbolic cotangent of x."))
     (make-signature '|csch| '(%) '(%)
       '("csch(x) returns the hyperbolic cosecant of x."))
     (make-signature '|sech| '(%) '(%)
       '("sech(x) returns the hyperbolic secant of x."))
     (make-signature '|sinh| '(%) '(%)
       '("sinh(x) returns the hyperbolic sine of x."))
     (make-signature '|tanh| '(%) '(%)
       '("tanh(x) returns the hyperbolic tangent of x."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |HyperbolicFunctionCategory|
  (progn
    (push '|HyperbolicFunctionCategory| *Categories*)
    (make-instance '|HyperbolicFunctionCategoryType|)))

\end{chunk}

\subsection{InnerEvalable}
\index[cat]{InnerEvalable!Category}
\index[cat]{Category!InnerEvalable}
\index[cat]{IEVALAB}
\begin{chunk}{defclass InnerEvalableType}
(defclass |InnerEvalableType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InnerEvalable")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'IEVALAB)
   (comment :initform (list
     "This category provides eval operations."
     "A domain may belong to this category if it is possible to make"
     "'evaluation' substitutions.  The difference between this"
     "and Evalable is that the operations in this category"
     "specify the substitution as a pair of arguments rather than as"
     "an equation."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|eval| '(%) '(% A B)
       '("eval(f, x, v) replaces x by v in f."))
     (make-signature '|eval| '(%) '(% (|List| A) (|List| B))
       '("eval(f, [x1,...,xn], [v1,...,vn]) replaces xi by vi in f."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerEvalable|
  (progn
    (push '|InnerEvalable| *Categories*)
    (make-instance '|InnerEvalableType|)))

\end{chunk}

\subsection{JacobiIdentityAttribute}
\index[cat]{JacobiIdentityAttribute!Category}
\index[cat]{Category!JacobiIdentityAttribute}
\index[cat]{ATJACID}
\begin{chunk}{defclass JacobiIdentityAttributeType}
(defclass |JacobiIdentityAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "JacobiIdentityAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATJACID)
   (comment :initform (list
     "JacobiIdentity means that [x,[y,z]]+[y,[z,x]]+[z,[x,y]] = 0 holds."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |JacobiIdentityAttribute|
  (progn
    (push '|JacobiIdentityAttribute| *Categories*)
    (make-instance '|JacobiIdentityAttributeType|)))

\end{chunk}

\subsection{LazyRepresentationAttribute}
\index[cat]{LazyRepresentationAttribute!Category}
\index[cat]{Category!LazyRepresentationAttribute}
\index[cat]{ATLR}
\begin{chunk}{defclass LazyRepresentationAttributeType}
(defclass |LazyRepresentationAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LazyRepresentationAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATLR)
   (comment :initform (list
     "The class of all domains which have a lazy representation"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LazyRepresentationAttribute|
  (progn
    (push '|LazyRepresentationAttribute| *Categories*)
    (make-instance '|LazyRepresentationAttributeType|)))

\end{chunk}

\subsection{LeftUnitaryAttribute}
\index[cat]{LeftUnitaryAttribute!Category}
\index[cat]{Category!LeftUnitaryAttribute}
\index[cat]{ATLUNIT}
\begin{chunk}{defclass LeftUnitaryAttributeType}
(defclass |LeftUnitaryAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LeftUnitaryAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATLUNIT)
   (comment :initform (list
     "LeftUnitary is true if 1 * x = x for all x."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LeftUnitaryAttribute|
  (progn
    (push '|LeftUnitaryAttribute| *Categories*)
    (make-instance '|LeftUnitaryAttributeType|)))

\end{chunk}

\subsection{ModularAlgebraicGcdOperations}
\index[cat]{ModularAlgebraicGcdOperations!Category}
\index[cat]{Category!ModularAlgebraicGcdOperations}
\index[cat]{MAGCDOC}
\begin{chunk}{defclass ModularAlgebraicGcdOperationsType}
(defclass |ModularAlgebraicGcdOperationsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ModularAlgebraicGcdOperations")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'MAGCDOC)
   (comment :initform (list
     "This category specifies operations needed by"
     "ModularAlgebraicGcd package.  Since we have multiple"
     "implementations we specify interface here and put"
     "implementations in separate packages.  Most operations"
     "are done using special purpose abstract representation."
     "Apropriate types are passesd as parametes: MPT is type"
     "of modular polynomials in one variable with coefficients"
     "in some algebraic extension.  MD is type of modulus."
     "Final results are converted to packed representation,"
     "with coefficients (from prime field) stored in one"
     "array and exponents (in main variable and in auxilary"
     "variables representing generators of algebrac extension)"
     "stored in parallel array."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|pseudoRem| 'MPT '(MPT MPT MD)
       '("pseudoRem(x, y, m) computes pseudoremainder of x by y"
         "modulo m."))
     (make-signature '|canonicalIfCan| '(|Union| MPT "failed") '(MPT MD)
       '("canonicalIfCan(x, m) tries to divide x by its leading"
         "coefficient modulo m."))
     (make-signature '|packModulus| '(|Union| MD "failed")
                                    '((|List| MP) (|List| |Symbol|) |Integer|)
       '("packModulus(lp, ls, p) converts lp, ls and prime p which"
         "together describe algebraic extension to packed"
         "representation."))
     (make-signature '|MPtoMPT| '(MPT) '(MP |Symbol| (|List| |Symbol|) MD)
       '("MPtoMPT(p, s, ls, m) coverts p to packed represntation."))
     (make-signature '|zero?| '(|Boolean|) '(MPT)
       '("zero?(x) checks if x is zero."))
     (make-signature '|degree| '(|Integer|) '(MPT)
       '("degree(x) gives degree of x."))
     (make-signature '|packExps| '(|SortedExponentVector|) '(|Integer| |Integer| MD)
       '("packExps(d, s, m) produces vector of exponents up"
         "to degree d.  s is size (degree) of algebraic extension."
         "Use together with repack1."))
     (make-signature '|repacke1| '(|Void|) '(MPT PA |Integer| MD)
       '("repack1(x, a, d, m) stores coefficients of x in a."
         "d is degree of x.  Corresponding exponents are given"
         "by packExps."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ModularAlgebraicGcdOperations|
  (progn
    (push '|ModularAlgebraicGcdOperations| *Categories*)
    (make-instance '|ModularAlgebraicGcdOperationsType|)))

\end{chunk}

\subsection{MultiplicativeValuationAttribute}
\index[cat]{MultiplicativeValuationAttribute!Category}
\index[cat]{Category!MultiplicativeValuationAttribute}
\index[cat]{ATMULVA}
\begin{chunk}{defclass MultiplicativeValuationAttributeType}
(defclass |MultiplicativeValuationAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MultiplicativeValuationAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATMULVA)
   (comment :initform (list
     "The class of all euclidean domains such that"
     "euclideanSize(a*b)=euclideanSize(a)*euclideanSize(b)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MultiplicativeValuationAttribute|
  (progn
    (push '|MultiplicativeValuationAttribute| *Categories*)
    (make-instance '|MultiplicativeValuationAttributeType|)))

\end{chunk}

\subsection{NoZeroDivisorsAttribute}
\index[cat]{NoZeroDivisorsAttribute!Category}
\index[cat]{Category!NoZeroDivisorsAttribute}
\index[cat]{ATNZDIV}
\begin{chunk}{defclass NoZeroDivisorsAttributeType}
(defclass |NoZeroDivisorsAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NoZeroDivisorsAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATNZDIV)
   (comment :initform (list
     "The class of all semirings such that x * y ~= 0 implies"
     "both x and y are non-zero."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NoZeroDivisorsAttribute|
  (progn
    (push '|NoZeroDivisorsAttribute| *Categories*)
    (make-instance '|NoZeroDivisorsAttributeType|)))

\end{chunk}

\subsection{NotherianAttribute}
\index[cat]{NotherianAttribute!Category}
\index[cat]{Category!NotherianAttribute}
\index[cat]{ATNOTHR}
\begin{chunk}{defclass NotherianAttributeType}
(defclass |NotherianAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NotherianAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATNOTHR)
   (comment :initform (list
     "Notherian is true if all of its ideals are finitely generated."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NotherianAttribute|
  (progn
    (push '|NotherianAttribute| *Categories*)
    (make-instance '|NotherianAttributeType|)))

\end{chunk}

\subsection{NullSquareAttribute}
\index[cat]{NullSquareAttribute!Category}
\index[cat]{Category!NullSquareAttribute}
\index[cat]{ATNULSQ}
\begin{chunk}{defclass NullSquareAttributeType}
(defclass |NullSquareAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NullSquareAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATNULSQ)
   (comment :initform (list
     "NullSquare means that [x,x] = 0 holds. See LieAlgebra."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NullSquareAttribute|
  (progn
    (push '|NullSquareAttribute| *Categories*)
    (make-instance '|NullSquareAttributeType|)))

\end{chunk}

\subsection{OpenMath}
\index[cat]{OpenMath!Category}
\index[cat]{Category!OpenMath}
\index[cat]{OM}
\begin{chunk}{defclass OpenMathType}
(defclass |OpenMathType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "OpenMath")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'OM)
   (comment :initform (list
     "OpenMath provides operations for exporting an object"
     "in OpenMath format."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|OMwrite| '(|String|) '(%)
       '("OMwrite(u) returns the OpenMath XML encoding of u as a"
         "complete OpenMath object."))
     (make-signature '|OMwrite| '(|String|) '(% |Boolean|)
       '("OMwrite(u, true) returns the OpenMath XML encoding of u"
         "as a complete OpenMath object; OMwrite(u, false) returns the"
         "OpenMath XML encoding of u as an OpenMath fragment."))
     (make-signature '|OMwrite| '(|Void|) '(|OpenMathDevice| %)
       '("OMwrite(dev, u) writes the OpenMath form of u to the"
         "OpenMath device dev as a complete OpenMath object."))
     (make-signature '|OMwrite| '(|Void|) '(|OpenMathDevice| % |Boolean|)
       '("OMwrite(dev, u, true) writes the OpenMath form of u to"
         "the OpenMath device dev as a complete OpenMath object;"
         "OMwrite(dev, u, false) writes the object as an OpenMath fragment."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OpenMath|
  (progn
    (push '|OpenMath| *Categories*)
    (make-instance '|OpenMathType|)))

\end{chunk}

\subsection{PartialTranscendentalFunctions}
\index[cat]{PartialTranscendentalFunctions!Category}
\index[cat]{Category!PartialTranscendentalFunctions}
\index[cat]{PTRANFN}
\begin{chunk}{defclass PartialTranscendentalFunctionsType}
(defclass |PartialTranscendentalFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PartialTranscendentalFunctions")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'PTRANFN)
   (comment :initform (list
     "A package which provides partial transcendental"
     "functions, for example, functions which return an answer or 'failed'"
     "This is the description of any package which provides partial"
     "functions on a domain belonging to TranscendentalFunctionCategory."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|nthRootIfCan| '(|Union| K "failed") '(K NNI)
       '("nthRootIfCan(z,n) returns the nth root of z if possible,"
         "and \"failed\" otherwise."))
     (make-signature '|expIfCan| '(|Union| K "failed") '(K)
       '("expIfCan(z) returns exp(z) if possible, and \"failed\" otherwise."))
     (make-signature '|logIfCan| '(|Union| K "failed") '(K)
       '("logIfCan(z) returns log(z) if possible, and \"failed\" otherwise."))
     (make-signature '|sinIfCan| '(|Union| K "failed") '(K)
       '("sinIfCan(z) returns sin(z) if possible, and \"failed\" otherwise."))
     (make-signature '|cosIfCan| '(|Union| K "failed") '(K)
       '("cosIfCan(z) returns cos(z) if possible, and \"failed\" otherwise."))
     (make-signature '|tanIfCan| '(|Union| K "failed") '(K)
       '("tanIfCan(z) returns tan(z) if possible, and \"failed\" otherwise."))
     (make-signature '|cotIfCan| '(|Union| K "failed") '(K)
       '("cotIfCan(z) returns cot(z) if possible, and \"failed\" otherwise."))
     (make-signature '|secIfCan| '(|Union| K "failed") '(K)
       '("secIfCan(z) returns sec(z) if possible, and \"failed\" otherwise."))
     (make-signature '|cscIfCan| '(|Union| K "failed") '(K)
       '("cscIfCan(z) returns csc(z) if possible, and \"failed\" otherwise."))
     (make-signature '|asinIfCan| '(|Union| K "failed") '(K)
       '("asinIfCan(z) returns asin(z) if possible, and \"failed\" otherwise."))
     (make-signature '|acosIfCan| '(|Union| K "failed") '(K)
       '("acosIfCan(z) returns acos(z) if possible, and \"failed\" otherwise."))
     (make-signature '|atanIfCan| '(|Union| K "failed") '(K)
       '("atanIfCan(z) returns atan(z) if possible, and \"failed\" otherwise."))
     (make-signature '|acotIfCan| '(|Union| K "failed") '(K)
       '("acotIfCan(z) returns acot(z) if possible, and \"failed\" otherwise."))
     (make-signature '|asecIfCan| '(|Union| K "failed") '(K)
       '("asecIfCan(z) returns asec(z) if possible, and \"failed\" otherwise."))
     (make-signature '|acscIfCan| '(|Union| K "failed") '(K)
       '("acscIfCan(z) returns acsc(z) if possible, and \"failed\" otherwise."))
     (make-signature '|sinhIfCan| '(|Union| K "failed") '(K)
       '("sinhIfCan(z) returns sinh(z) if possible, and \"failed\" otherwise."))
     (make-signature '|coshIfCan| '(|Union| K "failed") '(K)
       '("coshIfCan(z) returns cosh(z) if possible, and \"failed\" otherwise."))
     (make-signature '|tanhIfCan| '(|Union| K "failed") '(K)
       '("tanhIfCan(z) returns tanh(z) if possible, and \"failed\" otherwise."))
     (make-signature '|cothIfCan| '(|Union| K "failed") '(K)
       '("cothIfCan(z) returns coth(z) if possible, and \"failed\" otherwise."))
     (make-signature '|sechIfCan| '(|Union| K "failed") '(K)
       '("sechIfCan(z) returns sech(z) if possible, and \"failed\" otherwise."))
     (make-signature '|cschIfCan| '(|Union| K "failed") '(K)
       '("cschIfCan(z) returns csch(z) if possible, and \"failed\" otherwise."))
     (make-signature '|asinhIfCan| '(|Union| K "failed") '(K)
       '("asinhIfCan(z) returns asinh(z) if possible, and \"failed\" otherwise."))
     (make-signature '|acoshIfCan| '(|Union| K "failed") '(K)
       '("acoshIfCan(z) returns acosh(z) if possible, and \"failed\" otherwise."))
     (make-signature '|atanhIfCan| '(|Union| K "failed") '(K)
       '("atanhIfCan(z) returns atanh(z) if possible, and \"failed\" otherwise."))
     (make-signature '|acothIfCan| '(|Union| K "failed") '(K)
       '("acothIfCan(z) returns acoth(z) if possible, and \"failed\" otherwise."))
     (make-signature '|asechIfCan| '(|Union| K "failed") '(K)
       '("asechIfCan(z) returns asech(z) if possible, and \"failed\" otherwise."))
     (make-signature '|acschIfCan| '(|Union| K "failed") '(K)
       '("acschIfCan(z) returns acsch(z) if possible, and \"failed\" otherwise."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PartialTranscendentalFunctions|
  (progn
    (push '|PartialTranscendentalFunctions| *Categories*)
    (make-instance '|PartialTranscendentalFunctionsType|)))

\end{chunk}

\subsection{PartiallyOrderedSetAttribute}
\index[cat]{PartiallyOrderedSetAttribute!Category}
\index[cat]{Category!PartiallyOrderedSetAttribute}
\index[cat]{ATPOSET}
\begin{chunk}{defclass PartiallyOrderedSetAttributeType}
(defclass |PartiallyOrderedSetAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PartiallyOrderedSetAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATPOSET)
   (comment :initform (list
     "PartiallyOrderedSet is true if a set with < is transitive,"
     "but not(a <b or a = b). It does not imply b < a"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PartiallyOrderedSetAttribute|
  (progn
    (push '|PartiallyOrderedSetAttribute| *Categories*)
    (make-instance '|PartiallyOrderedSetAttributeType|)))

\end{chunk}

\subsection{PrimitiveFunctionCategory}
\index[cat]{PrimitiveFunctionCategory!Category}
\index[cat]{Category!PrimitiveFunctionCategory}
\index[cat]{PRIMCAT}
\begin{chunk}{defclass PrimitiveFunctionCategoryType}
(defclass |PrimitiveFunctionCategoryType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PrimitiveFunctionCategory")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'PRIMCAT)
   (comment :initform (list
     "Category for the functions defined by integrals"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|integral| '(%) '(% |Symbol|)
       '("integral(f, x) returns the formal integral of f dx."))
     (make-signature '|integral| '(%) '(% (|SegmentBinding| %))
       '("integral(f, x = a..b) returns the formal definite integral"
         "of f dx for x between a and b."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PrimitiveFunctionCategory|
  (progn
    (push '|PrimitiveFunctionCategory| *Categories*)
    (make-instance '|PrimitiveFunctionCategoryType|)))

\end{chunk}

\subsection{RadicalCategory}
\index[cat]{RadicalCategory!Category}
\index[cat]{Category!RadicalCategory}
\index[cat]{RADCAT}
\begin{chunk}{defclass RadicalCategoryType}
(defclass |RadicalCategoryType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RadicalCategory")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'RADCAT)
   (comment :initform (list
     "The RadicalCategory is a model for the rational numbers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|sqrt| '(%) '(%)
       '("sqrt(x) returns the square root of x. The branch cut lies along"
         "the negative real axis, continuous with quadrant II."))
     (make-signature '|nthRoot| '(%) '(% |Integer|)
       '("nthRoot(x,n) returns the nth root of x."))
     (make-signature '|**| '(%) '(% (|Fraction| |Integer|))
       '("x ** y is the rational exponentiation of x by the power y.") () t)
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RadicalCategory|
  (progn
    (push '|RadicalCategory| *Categories*)
    (make-instance '|RadicalCategoryType|)))

\end{chunk}

\subsection{RetractableTo}
\index[cat]{RetractableTo!Category}
\index[cat]{Category!RetractableTo}
\index[cat]{RETRACT}
\begin{chunk}{defclass RetractableToType}
(defclass |RetractableToType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RetractableTo")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'RETRACT)
   (comment :initform (list
     "A is retractable to B means that some elements if A can be converted"
     "into elements of B and any element of B can be converted into an"
     "element of A."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|coerce| '(%) '(S)
       '("coerce(a) transforms a into an element of %."))
     (make-signature '|retractIfCan| '(|Union| S "failed") '(%)
       '("retractIfCan(a) transforms a into an element of S if possible."
         "Returns \"failed\" if a cannot be made into an element of S."))
     (make-signature '|retract| '(S) '(%)
       '("retract(a) transforms a into an element of S if possible."
         "Error: if a cannot be made into an element of S."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RetractableTo|
  (progn
    (push '|RetractableTo| *Categories*)
    (make-instance '|RetractableToType|)))

\end{chunk}

\subsection{RightUnitaryAttribute}
\index[cat]{RightUnitaryAttribute!Category}
\index[cat]{Category!RightUnitaryAttribute}
\index[cat]{ATRUNIT}
\begin{chunk}{defclass RightUnitaryAttributeType}
(defclass |RightUnitaryAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RightUnitaryAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATRUNIT)
   (comment :initform (list
     "RightUnitary is true if x * 1 = x for all x."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RightUnitaryAttribute|
  (progn
    (push '|RightUnitaryAttribute| *Categories*)
    (make-instance '|RightUnitaryAttributeType|)))

\end{chunk}

\subsection{ShallowlyMutableAttribute}
\index[cat]{ShallowlyMutableAttribute!Category}
\index[cat]{Category!ShallowlyMutableAttribute}
\index[cat]{ATSHMUT}
\begin{chunk}{defclass ShallowlyMutableAttributeType}
(defclass |ShallowlyMutableAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ShallowlyMutableAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATSHMUT)
   (comment :initform (list
     "The class of all domains which have immediate components that"
     "are updateable in place (mutable). The properties of any component"
     "domain are irrevelant to the ShallowlyMutableAttribute."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ShallowlyMutableAttribute|
  (progn
    (push '|ShallowlyMutableAttribute| *Categories*)
    (make-instance '|ShallowlyMutableAttributeType|)))

\end{chunk}

\subsection{SpecialFunctionCategory}
\index[cat]{SpecialFunctionCategory!Category}
\index[cat]{Category!SpecialFunctionCategory}
\index[cat]{SPFCAT}
\begin{chunk}{defclass SpecialFunctionCategoryType}
(defclass |SpecialFunctionCategoryType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SpecialFunctionCategory")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'SPFCAT)
   (comment :initform (list
     "Category for the other special functions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|abs| '(%) '(%)
       '("abs(x) returns the absolute value of x."))
     (make-signature '|Gamma| '(%) '(%)
       '("Gamma(x) is the Euler Gamma function."))
     (make-signature '|Beta| '(%) '(% %)
       '("Beta(x,y) is Gamma(x) * Gamma(y)/Gamma(x+y)."))
     (make-signature '|digamma| '(%) '(%)
       '("digamma(x) is the logarithmic derivative of Gamma(x)"
         "(often written psi(x) in the literature)."))
     (make-signature '|polygamma| '(%) '(% %)
       '("polygamma(k,x) is the \spad{k-th} derivative of digamma(x),"
         "(often written psi(k,x) in the literature)."))
     (make-signature '|Gamma| '(%) '(% %)
       '("Gamma(a,x) is the incomplete Gamma function."))
     (make-signature '|besselJ| '(%) '(% %)
       '("besselJ(v,z) is the Bessel function of the first kind."))
     (make-signature '|besselY| '(%) '(% %)
       '("besselY(v,z) is the Bessel function of the second kind."))
     (make-signature '|besselI| '(%) '(% %)
       '("besselI(v,z) is the modified Bessel function of the first kind."))
     (make-signature '|besselK| '(%) '(% %)
       '("besselK(v,z) is the modified Bessel function of the second kind."))
     (make-signature '|airyAi| '(%) '(%)
       '("airyAi(x) is the Airy function Ai(x)."))
     (make-signature '|airyBi| '(%) '(%)
       '("airyBi(x) is the Airy function Bi(x)."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SpecialFunctionCategory|
  (progn
    (push '|SpecialFunctionCategory| *Categories*)
    (make-instance '|SpecialFunctionCategoryType|)))

\end{chunk}

\subsection{TrigonometricFunctionCategory}
\index[cat]{TrigonometricFunctionCategory!Category}
\index[cat]{Category!TrigonometricFunctionCategory}
\index[cat]{TRIGCAT}
\begin{chunk}{defclass TrigonometricFunctionCategoryType}
(defclass |TrigonometricFunctionCategoryType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TrigonometricFunctionCategory")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'TRIGCAT)
   (comment :initform (list
     "Category for the trigonometric functions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|cos| '(%) '(%)
       '("cos(x) returns the cosine of x."))
     (make-signature '|cot| '(%) '(%)
       '("cot(x) returns the cotangent of x."))
     (make-signature '|csc| '(%) '(%)
       '("csc(x) returns the cosecant of x."))
     (make-signature '|sec| '(%) '(%)
       '("sec(x) returns the secant of x."))
     (make-signature '|sin| '(%) '(%)
       '("sin(x) returns the sine of x."))
     (make-signature '|tan| '(%) '(%)
       '("tan(x) returns the tangent of x."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TrigonometricFunctionCategory|
  (progn
    (push '|TrigonometricFunctionCategory| *Categories*)
    (make-instance '|TrigonometricFunctionCategoryType|)))

\end{chunk}

\subsection{Type}
\index[cat]{Type!Category}
\index[cat]{Category!Type}
\index[cat]{TYPE}
\begin{chunk}{defclass TypeType}
(defclass |TypeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "Type")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'TYPE)
   (comment :initform (list
     "The fundamental Type."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Type|
  (progn
    (push '|Type| *Categories*)
    (make-instance '|TypeType|)))

\end{chunk}

\subsection{UnitsKnownAttribute}
\index[cat]{UnitsKnownAttribute!Category}
\index[cat]{Category!UnitsKnownAttribute}
\index[cat]{ATUNIKN}
\begin{chunk}{defclass UnitsKnownAttributeType}
(defclass |UnitsKnownAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UnitsKnownAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATUNIKN)
   (comment :initform (list
     "The class of all monoids (multiplicative semigroups with a 1)"
     "such that the operation recop can only return 'failed'"
     "if its argument is not a unit."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnitsKnownAttribute|
  (progn
    (push '|UnitsKnownAttribute| *Categories*)
    (make-instance '|UnitsKnownAttributeType|)))

\end{chunk}

\section{Level 2}

\begin{chunk}{defvar level2}
(defvar level2
 '(|Aggregate| |CombinatorialOpsCategory| |EltableAggregate| |Evalable|
   |FortranProgramCategory| |FullyRetractableTo| |Logic| |Patternable| 
   |PlottablePlaneCurveCategory| |PlottableSpaceCurveCategory| |RealConstant|
   |SegmentCategory| |SetCategory| |TranscendentalFunctionCategory|))

\end{chunk}

\subsection{Aggregate}
\index[cat]{Aggregate!Category}
\index[cat]{Category!Aggregate}
\index[cat]{AGG}
\begin{chunk}{defclass AggregateType}
(defclass |AggregateType| (|TypeType|)
  ((parents :initform '(|Type|))
   (name :initform "Aggregate")
   (marker :initform 'category)
   (level :initform 2)
   (abbreviation :initform 'AGG)
   (comment :initform (list
     "The notion of aggregate serves to model any data structure aggregate,"
     "designating any collection of objects, with heterogenous or homogeneous"
     "members, with a finite or infinite number of members, explicitly or"
     "implicitly represented. An aggregate can in principle represent"
     "everything from a string of characters to abstract sets such"
     "as 'the set of x satisfying relation r(x)'"
     "An attribute 'finiteAggregate' is used to assert that a domain"
     "has a finite number of elements."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|eq?| '(|Boolean|) '(% %)
       '("eq?(u,v) tests if u and v are same objects."))
     (make-signature '|copy| '(%) '(%)
       '("copy(u) returns a top-level (non-recursive) copy of u."
         "Note that for collections, copy(u) == [x for x in u]."))
     (make-signature '|empty| '(%) ()
       '("empty()$D creates an aggregate of type D with 0 elements."
         "Note that The $D can be dropped if understood by context,"
         "for example u: D := empty()."))
     (make-signature '|empty?| '(|Boolean|) '(%)
       '("empty?(u) tests if u has 0 elements."))
     (make-signature '|less?| '(|Boolean|) '(% |NonNegativeInteger|)
       '("less?(u,n) tests if u has less than n elements."))
     (make-signature '|more?| '(|Boolean|) '(% |NonNegativeInteger|)
       '("more?(u,n) tests if u has greater than n elements."))
     (make-signature '|size?| '(|Boolean|) '(% |NonNegativeInteger|)
       '("size?(u,n) tests if u has exactly n elements."))
     (make-signature '|sample| '(%) '(|constant|)
       '("sample yields a value of type %"))))
   (haslist :initform (list
     (make-haslist (list
       (make-hasclause '|%| '|finiteAggregate|
         (list
           (make-signature '|#| '(|NonNegativeInteger|) '(%)
             '("# u returns the number of items in u.") () t)))))))
   (addlist :initform nil)))

(defvar |Aggregate|
  (progn
    (push '|Aggregate| *Categories*)
    (make-instance '|AggregateType|)))

\end{chunk}

\subsection{CombinatorialOpsCategory}
\index[cat]{CombinatorialOpsCategory!Category}
\index[cat]{Category!CombinatorialOpsCategory}
\index[cat]{COMBOPC}
\begin{chunk}{defclass CombinatorialOpsCategoryType}
(defclass |CombinatorialOpsCategoryType| (|CombinatorialFunctionCategoryType|)
  ((parents :initform '(|CombinatorialFunctionCategory|))
   (name :initform "CombinatorialOpsCategory")
   (marker :initform 'category)
   (level :initform 2)
   (abbreviation :initform 'COMBOPC)
   (comment :initform (list
     "CombinatorialOpsCategory is the category obtaining by adjoining"
     "summations and products to the usual combinatorial operations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|factorials| '(%) '(%)
       '("factorials(f) rewrites the permutations and binomials in f"
         "in terms of factorials"))
     (make-signature '|factorials| '(%) '(% |Symbol|)
       '("factorials(f, x) rewrites the permutations and binomials in f"
         "involving x in terms of factorials"))
     (make-signature '|summation| '(%) '(% |Symbol|)
       '("summation(f(n), n) returns the formal sum S(n) which verifies"
         "S(n+1) - S(n) = f(n)"))
     (make-signature '|summation| '(%) '(% (|SegmentBinding| %))
       '("summation(f(n), n = a..b) returns f(a) + ... + f(b) as a"
         "formal sum"))
     (make-signature '|product| '(%) '(% |Symbol|)
       '("product(f(n), n) returns the formal product P(n) which verifies"
         "P(n+1)/P(n) = f(n)"))
     (make-signature '|product| '(%) '(% (|SegmentBinding| %))
       '("product(f(n), n = a..b) returns f(a) * ... * f(b) as a"
         "formal product"))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CombinatorialOpsCategory|
  (progn
    (push '|CombinatorialOpsCategory| *Categories*)
    (make-instance '|CombinatorialOpsCategoryType|)))

\end{chunk}

\subsection{EltableAggregate}
\index[cat]{EltableAggregate!Category}
\index[cat]{Category!EltableAggregate}
\index[cat]{ELTAGG}
\begin{chunk}{defclass EltableAggregateType}
(defclass |EltableAggregateType| (|EltableType|)
  ((parents :initform '(|Eltable|))
   (name :initform "EltableAggregate")
   (marker :initform 'category)
   (level :initform 2)
   (abbreviation :initform 'ELTAGG)
   (comment :initform (list
     "An eltable aggregate is one which can be viewed as a function."
     "For example, the list [1,7,4] can applied to 0,1, and 2 respectively"
     "will return the integers 1, 7, and 4; thus this list may be viewed as"
     "mapping 0 to 1, 1 to 7 and 2 to 4. In general, an aggregate"
     "can map members of a domain Dom to an image domain Im."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|elt| '(|Im|) '(% |Dom| |Im|)
       '("elt(u, x, y) applies u to x if x is in the domain of u,"
         "and returns y otherwise."
         "For example, if u is a polynomial in \axiom{x} over the rationals,"
         "elt(u,n,0) may define the coefficient of x"
         "to the power n, returning 0 when n is out of range."))
     (make-signature '|qelt| '(|Im|) '(% |Dom|)
       '("qelt(u, x) applies u to x without checking whether"
         "x is in the domain of u. If x is not"
         "in the domain of u a memory-access violation may occur."
         "If a check on whether x is in the domain of u"
         "is required, use the function elt."))
   ))
   (haslist :initform (list
     (make-haslist (list
       (make-hasclause '|%| '|shallowlyMutable|
         (list
           (make-signature '|setelt| '(|Im|) '(% |Dom| |Im|)
             '("setelt(u,x,y) sets the image of x to be y under u,"
               "assuming x is in the domain of u."
               "Error: if x is not in the domain of u."))
           (make-signature '|qsetelt_!| '(|Im|) '(% |Dom| |Im|)
             '("qsetelt!(u,x,y) sets the image of x to be y"
               "under u, without checking that x is in"
               "the domain of u."
               "If such a check is required use the function setelt."))))))))
   (addlist :initform nil)))

(defvar |EltableAggregate|
  (progn
    (push '|EltableAggregate| *Categories*)
    (make-instance '|EltableAggregateType|)))

\end{chunk}

\subsection{Evalable}
\index[cat]{Evalable!Category}
\index[cat]{Category!Evalable}
\index[cat]{EVALAB}
\begin{chunk}{defclass EvalableType}
(defclass |EvalableType| (|InnerEvalableType|)
  ((parents :initform '(|InnerEvalable|))
   (name :initform "Evalable")
   (marker :initform 'category)
   (level :initform 2)
   (abbreviation :initform 'EVALAB)
   (comment :initform (list
     "This category provides eval operations."
     "A domain may belong to this category if it is possible to make"
     "'evaluation' substitutions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|eval| '(%) '(% (|Equation| R))
       '("eval(f,x = v) replaces x by v in f."))
     (make-signature '|eval| '(%) '($ (List (Equation R)))
       '("eval(f, [x1 = v1,...,xn = vn]) replaces xi by vi in f."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Evalable|
  (progn
    (push '|Evalable| *Categories*)
    (make-instance '|EvalableType|)))

\end{chunk}

\subsection{FortranProgramCategory}
\index[cat]{FortranProgramCategory!Category}
\index[cat]{Category!FortranProgramCategory}
\index[cat]{FORTCAT}
\begin{chunk}{defclass FortranProgramCategoryType}
(defclass |FortranProgramCategoryType| (|TypeType| |CoercibleToType|)
  ((parents :initform '(|Type| |CoercibleTo|))
   (name :initform "FortranProgramCategory")
   (marker :initform 'category)
   (level :initform 2)
   (abbreviation :initform 'FORTCAT)
   (comment :initform (list
     "FortranProgramCategory provides various models of FORTRAN subprograms."
     "These can be transformed into actual FORTRAN code."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|outputAsFortran| '(|Void|) '(%)
       '("outputAsFortran(u) translates u into a legal FORTRAN subprogram."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FortranProgramCategory|
  (progn
    (push '|FortranProgramCategory| *Categories*)
    (make-instance '|FortranProgramCategoryType|)))

\end{chunk}

\subsection{FullyRetractableTo}
\index[cat]{FullyRetractableTo!Category}
\index[cat]{Category!FullyRetractableTo}
\index[cat]{FRETRCT}
\begin{chunk}{defclass FullyRetractableToType}
(defclass |FullyRetractableToType| (|RetractableToType|)
  ((parents :initform '(|RetractableTo|))
   (name :initform "FullyRetractableTo")
   (marker :initform 'category)
   (level :initform 2)
   (abbreviation :initform 'FRETRCT)
   (comment :initform (list
     "A is fully retractable to B means that A is retractable to B and"
     "if B is retractable to the integers or rational numbers then so is A."
     "In particular, what we are asserting is that there are no integers"
     "(rationals) in A which don't retract into B."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FullyRetractableTo|
  (progn
    (push '|FullyRetractableTo| *Categories*)
    (make-instance '|FullyRetractableToType|)))

\end{chunk}

\subsection{Logic}
\index[cat]{Logic!Category}
\index[cat]{Category!Logic}
\index[cat]{LOGIC}
\begin{chunk}{defclass LogicType}
(defclass |LogicType| (|BasicTypeType|)
  ((parents :initform '(|BasicType|))
   (name :initform "Logic")
   (marker :initform 'category)
   (level :initform 2)
   (abbreviation :initform 'LOGIC)
   (comment :initform (list
     "Logic provides the basic operations for lattices,"
     "for example, boolean algebra."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|-| '(%) '(%)
       '("~(x) returns the logical complement of x.") () t)
     (make-signature '|/\\| '(%) '(% %)
       '("/\\ returns the logical `meet', for example, `and'.") () t)
     (make-signature '|\\/| '(%) '(% %)
       '("\\/ returns the logical `join', for example, `or'.") () t)
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Logic|
  (progn
    (push '|Logic| *Categories*)
    (make-instance '|LogicType|)))

\end{chunk}

\subsection{Patternable}
\index[cat]{Patternable!Category}
\index[cat]{Category!Patternable}
\index[cat]{PATAB}
\begin{chunk}{defclass PatternableType}
(defclass |PatternableType| (|ConvertibleToType|)
  ((parents :initform '(|ConvertibleTo|))
   (name :initform "Patternable")
   (marker :initform 'category)
   (level :initform 2)
   (abbreviation :initform 'PATAB)
   (comment :initform (list
     "Category of sets that can be converted to useful patterns"
     "An object S is Patternable over an object R if S can"
     "lift the conversions from R into Pattern(Integer) and"
     "Pattern(Float) to itself"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Patternable|
  (progn
    (push '|Patternable| *Categories*)
    (make-instance '|PatternableType|)))

\end{chunk}

\subsection{PlottablePlaneCurveCategory}
\index[cat]{PlottablePlaneCurveCategory!Category}
\index[cat]{Category!PlottablePlaneCurveCategory}
\index[cat]{PPCURVE}
\begin{chunk}{defclass PlottablePlaneCurveCategoryType}
(defclass |PlottablePlaneCurveCategoryType| (|CoercibleToType|)
  ((parents :initform '(|CoercibleTo|))
   (name :initform "PlottablePlaneCurveCategory")
   (marker :initform 'category)
   (level :initform 2)
   (abbreviation :initform 'PPCURVE)
   (comment :initform (list
     "PlotablePlaneCurveCategory is the category of curves in the plane"
     "which may be plotted via the graphics facilities. Functions are"
     "provided for obtaining lists of lists of points, representing the"
     "branches of the curve, and for determining the ranges of the"
     "x-coordinates and y-coordinates of the points on the curve."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|listBranches| '(L L (POINT)) '(%)
       '("listBranches(c) returns a list of lists of points, representing the"
         "branches of the curve c."))
     (make-signature '|xRange| '((SEG SF)) '(%)
       '("xRange(c) returns the range of the x-coordinates of the points"
         "on the curve c."))
     (make-signature '|yRange| '((SEG SF)) '(%)
       '("yRange(c) returns the range of the y-coordinates of the points"
         "on the curve c."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PlottablePlaneCurveCategory|
  (progn
    (push '|PlottablePlaneCurveCategory| *Categories*)
    (make-instance '|PlottablePlaneCurveCategoryType|)))

\end{chunk}

\subsection{PlottableSpaceCurveCategory}
\index[cat]{PlottableSpaceCurveCategory!Category}
\index[cat]{Category!PlottableSpaceCurveCategory}
\index[cat]{PSCURVE}
\begin{chunk}{defclass PlottableSpaceCurveCategoryType}
(defclass |PlottableSpaceCurveCategoryType| (|CoercibleToType|)
  ((parents :initform '(|CoercibleTo|))
   (name :initform "PlottableSpaceCurveCategory")
   (marker :initform 'category)
   (level :initform 2)
   (abbreviation :initform 'PSCURVE)
   (comment :initform (list
     "PlottableSpaceCurveCategory is the category of curves in"
     "3-space which may be plotted via the graphics facilities.  Functions are"
     "provided for obtaining lists of lists of points, representing the"
     "branches of the curve, and for determining the ranges of the"
     "x-, y-, and z-coordinates of the points on the curve."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|listBranches| '(L L POINT) '(%)
       '("listBranches(c) returns a list of lists of points, representing the"
         "branches of the curve c."))
     (make-signature '|xRange| '((SEG SF)) '(%)
       '("xRange(c) returns the range of the x-coordinates of the points"
         "on the curve c."))
     (make-signature '|yRange| '((SEG SF)) '(%)
       '("yRange(c) returns the range of the y-coordinates of the points"
         "on the curve c."))
     (make-signature '|zRange| '((SEG SF)) '(%)
       '("zRange(c) returns the range of the z-coordinates of the points"
         "on the curve c."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PlottableSpaceCurveCategory|
  (progn
    (push '|PlottableSpaceCurveCategory| *Categories*)
    (make-instance '|PlottableSpaceCurveCategoryType|)))

\end{chunk}

\subsection{RealConstant}
\index[cat]{RealConstant!Category}
\index[cat]{Category!RealConstant}
\index[cat]{REAL}
\begin{chunk}{defclass RealConstantType}
(defclass |RealConstantType| (|ConvertibleToType|)
  ((parents :initform '(|ConvertibleTo|))
   (name :initform "RealConstant")
   (marker :initform 'category)
   (level :initform 2)
   (abbreviation :initform 'REAL)
   (comment :initform (list
     "The category of real numeric domains, that is, convertible to floats."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RealConstant|
  (progn
    (push '|RealConstant| *Categories*)
    (make-instance '|RealConstantType|)))

\end{chunk}

\subsection{SegmentCategory}
\index[cat]{SegmentCategory!Category}
\index[cat]{Category!SegmentCategory}
\index[cat]{SEGCAT}
\begin{chunk}{defclass SegmentCategoryType}
(defclass |SegmentCategoryType| (|TypeType|)
  ((parents :initform '(|Type|))
   (name :initform "SegmentCategory")
   (marker :initform 'category)
   (level :initform 2)
   (abbreviation :initform 'SEGCAT)
   (comment :initform (list
     "This category provides operations on ranges, or segments"
     "as they are called."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|SEGMENT| '(%) '(S S)
       '("l..h creates a segment with l and h as the endpoints."))
     (make-signature '|BY| '(%) '(% |Integer|)
       '("s by n creates a new segment in which only every"
         "n-th element is used."))
     (make-signature '|lo| '(S) '(%)
       '("lo(s) returns the first endpoint of s."
         "Note that lo(l..h) = l."))
     (make-signature '|hi| '(S) '(%)
       '("hi(s) returns the second endpoint of s."
         "Note that hi(l..h) = h."))
     (make-signature '|low| '(S) '(%)
       '("low(s) returns the first endpoint of s."
         "Note that low(l..h) = l."))
     (make-signature '|high| '(S) '(%)
       '("high(s) returns the second endpoint of s."
         "Note that high(l..h) = h."))
     (make-signature '|incr| '(|Integer|) '(%)
       '("incr(s) returns n, where s is a segment in which every"
         "n-th element is used."
         "Note that incr(l..h by n) = n."))
     (make-signature '|segment| '(%) '(S S)
       '("segment(i,j) is an alternate way to create the segment i..j."))
     (make-signature '|convert| '(%) '(S)
       '("convert(i) creates the segment i..i."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SegmentCategory|
  (progn
    (push '|SegmentCategory| *Categories*)
    (make-instance '|SegmentCategoryType|)))

\end{chunk}

\subsection{SetCategory}
\index[cat]{SetCategory!Category}
\index[cat]{Category!SetCategory}
\index[cat]{SETCAT}
\begin{chunk}{defclass SetCategoryType}
(defclass |SetCategoryType| (|BasicTypeType| |CoercibleToType|)
  ((parents :initform '(|BasicType| |CoercibleTo|))
   (name :initform "SetCategory")
   (marker :initform 'category)
   (level :initform 2)
   (abbreviation :initform 'SETCAT)
   (comment :initform (list
     "SetCategory is the basic category for describing a collection"
     "of elements with = (equality) and coerce to output form."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|hash| '(|SingleInteger|) '(%)
       '("hash(s) calculates a hash code for s."))
     (make-signature '|latex| '(|String|) '(%)
       '("latex(s) returns a LaTeX-printable output representation of s."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SetCategory|
  (progn
    (push '|SetCategory| *Categories*)
    (make-instance '|SetCategoryType|)))

\end{chunk}

\subsection{TranscendentalFunctionCategory}
\index[cat]{TranscendentalFunctionCategory!Category}
\index[cat]{Category!TranscendentalFunctionCategory}
\index[cat]{TRANFUN}
\begin{chunk}{defclass TranscendentalFunctionCategoryType}
(defclass |TranscendentalFunctionCategoryType| (|ArcHyperbolicFunctionCategoryType| 
                                                |ArcTrigonometricFunctionCategoryType|
                                                |ElementaryFunctionCategoryType| 
                                                |HyperbolicFunctionCategoryType|
                                                |TrigonometricFunctionCategoryType|)
  ((parents :initform '(|ArcHyperbolicFunctionCategory| 
                          |ArcTrigonometricFunctionCategory| 
                          |ElementaryFunctionCategory| 
                          |HyperbolicFunctionCategory| 
                          |TrigonometricFunctionCategory|))
   (name :initform "TranscendentalFunctionCategory")
   (marker :initform 'category)
   (level :initform 2)
   (abbreviation :initform 'TRANFUN)
   (comment :initform (list
     "Category for the transcendental elementary functions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|pi| '(%) ()
       '("pi() returns the constant pi."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TranscendentalFunctionCategory|
  (progn
    (push '|TranscendentalFunctionCategory| *Categories*)
    (make-instance '|TranscendentalFunctionCategoryType|)))

\end{chunk}

\section{Level 3}

\begin{chunk}{defvar level3}
(defvar level3
 '(|AbelianSemiGroup| |BlowUpMethodCategory| |Comparable| |FileCategory|
   |FileNameCategory| |Finite| |FortranFunctionCategory| |FortranMatrixCategory|
   |FortranMatrixFunctionCategory| |FortranVectorCategory|
   |FortranVectorFunctionCategory| |FullyEvalableOver| |GradedModule|
   |HomogeneousAggregate| |IndexedDirectProductCategory|
   |LiouvillianFunctionCategory| |Monad| |NumericalIntegrationCategory|
   |NumericalOptimizationCategory| |OrderedSet|
   |OrdinaryDifferentialEquationsSolverCategory|
   |PartialDifferentialEquationsSolverCategory| |PatternMatchable|
   |RealRootCharacterizationCategory| |SExpressionCategory|
   |SegmentExpansionCategory| |SemiGroup| |SetCategoryWithDegree| |StepThrough|
   |ThreeSpaceCategory|))

\end{chunk}

\subsection{AbelianSemiGroup}
\index[cat]{AbelianSemiGroup!Category}
\index[cat]{Category!AbelianSemiGroup}
\index[cat]{ABELSG}
\begin{chunk}{defclass AbelianSemiGroupType}
(defclass |AbelianSemiGroupType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "AbelianSemiGroup")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'ABELSG)
   (comment :initform (list
     "The class of all additive (commutative) semigroups, that is,"
     "a set with a commutative and associative operation +."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|+| '(%) '(% %)
       '("x+y computes the sum of x and y.") () t)
     (make-signature '|*| '(%) '(|PositiveInteger| %)
       '("n*x computes the left-multiplication of x by the positive"
         "integer n. This is equivalent to adding x to itself n times.")
       () t)
   )) 
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AbelianSemiGroup|
  (progn
    (push '|AbelianSemiGroup| *Categories*)
    (make-instance '|AbelianSemiGroupType|)))

\end{chunk}

\subsection{BlowUpMethodCategory}
\index[cat]{BlowUpMethodCategory!Category}
\index[cat]{Category!BlowUpMethodCategory}
\index[cat]{BLMETCT}
\begin{chunk}{defclass BlowUpMethodCategoryType}
(defclass |BlowUpMethodCategoryType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "BlowUpMethodCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'BLMETCT)
   (comment :initform nil)
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|coerce| '(%) '((|List| |Integer|)) ())
     (make-signature '|excepCoord| '(|Integer|) '(%) ())
     (make-signature '|chartCoord| '(|Integer|) '(%) ())
     (make-signature '|transCoord| '(|Integer|) '(%) ())
     (make-signature '|createHN| '(%) '(|Integer| |Integer| |Integer|
                                        |Integer| |Integer| |Boolean|
       (|Union| "left" "center" "right" "vertical" "horizontal")) ())
     (make-signature '|ramifMult| '(|Integer|) '(%) ())
     (make-signature '|infClsPt?| '(|Boolean|) '(%) ())
     (make-signature '|quotValuation| '(|Integer|) '(%) ())
     (make-signature '|type| '(%) '((|Union| "left" "center" "right"
                                             "vertical" "horizontal")) ())
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BlowUpMethodCategory|
  (progn
    (push '|BlowUpMethodCategory| *Categories*)
    (make-instance '|BlowUpMethodCategoryType|)))

\end{chunk}

\subsection{Comparable}
\index[cat]{Comparable!Category}
\index[cat]{Category!Comparable}
\index[cat]{COMPAR}
\begin{chunk}{defclass ComparableType}
(defclass |ComparableType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "Comparable")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'COMPAR)
   (comment :initform (list
     "The class of set equipped with possibly unnatural linear order"
     "(needed for technical reasons)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|smaller?| '(|Boolean|) '(% %)
       '("smaller?(x,y) is a strict local total ordering on the elements of the set"))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Comparable|
  (progn
    (push '|Comparable| *Categories*)
    (make-instance '|ComparableType|)))

\end{chunk}

\subsection{FileCategory}
\index[cat]{FileCategory!Category}
\index[cat]{Category!FileCategory}
\index[cat]{FILECAT}
\begin{chunk}{defclass FileCategoryType}
(defclass |FileCategoryType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "FileCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'FILECAT)
   (comment :initform (list
     "This category provides an interface to operate on files in the"
     "computer's file system.  The precise method of naming files"
     "is determined by the Name parameter.  The type of the contents"
     "of the file is determined by S."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|open| '(%) '(|Name|)
       '("open(s) returns the file s open for input."))
     (make-signature '|open| '(%) '(|Name| |IOMode|)
       '("open(s,mode) returns a file s open for operation in the"
         "indicated mode: \"input\" or \"output\"."))
     (make-signature '|reopen!| '(%) '(% |IOMode|)
       '("reopen!(f,mode) returns a file f reopened for operation in the"
         "indicated mode: \"input\" or \"output\"."
         "reopen!(f,\"input\") will reopen the file f for input."))
     (make-signature '|close!| '(%) '(%)
       '("close!(f) returns the file f closed to input and output."))
     (make-signature '|name| '(|Name|) '(%)
       '("name(f) returns the external name of the file f."))
     (make-signature '|iomode| '(|IOMode|) '(%)
       '("iomode(f) returns the status of the file f. The input/output"
         "status of f may be \"input\", \"output\" or \"closed\" mode."))
     (make-signature '|read!| '(S) '(%)
       '("read!(f) extracts a value from file f. The state of f is"
         "modified so a subsequent call to read! will return"
         "the next element."))
     (make-signature '|write!| '(S) '(% S)
       '("write!(f,s) puts the value s into the file f."
         "The state of f is modified so subsequents call to write!"
         "will append one after another."))
     (make-signature '|flush| '(|Void|) '(%)
       '("flush(f) makes sure that buffered data is written out."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FileCategory|
  (progn
    (push '|FileCategory| *Categories*)
    (make-instance '|FileCategoryType|)))

\end{chunk}

\subsection{FileNameCategory}
\index[cat]{FileNameCategory!Category}
\index[cat]{Category!FileNameCategory}
\index[cat]{FNCAT}
\begin{chunk}{defclass FileNameCategoryType}
(defclass |FileNameCategoryType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "FileNameCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'FNCAT)
   (comment :initform (list
     "This category provides an interface to names in the file system."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|coerce| '(|IOMode|) '(%)
       '("iomode(f) returns the status of the file f. The input/output"
         "status of f may be \"input\", \"output\" or \"closed\" mode."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FileNameCategory|
  (progn
    (push '|FileNameCategory| *Categories*)
    (make-instance '|FileNameCategoryType|)))

\end{chunk}

\subsection{Finite}
\index[cat]{Finite!Category}
\index[cat]{Category!Finite}
\index[cat]{FINITE}
\begin{chunk}{defclass FiniteType}
(defclass |FiniteType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "Finite")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'FINITE)
   (comment :initform (list
     "The category of domains composed of a finite set of elements."
     "We include the functions lookup and index" 
     "to give a bijection between the finite set and an initial"
     "segment of positive integers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|size| '(|NonNegativeInteger|) () 
       '("size() returns the number of elements in the set."))
     (make-signature '|index| '(%)  '(|PositiveInteger|)
       '("index(i) takes a positive integer i less than or equal"
         "to size() and"
         "returns the i-th element of the set."
         "This operation establishs a bijection"
         "between the elements of the finite set and 1..size()."))
     (make-signature '|lookup| '(|PositiveInteger|) '(%)
      '("lookup(x) returns a positive integer such that"
        "x = index lookup x."))
     (make-signature '|random| '(%)  '()
       '("random() returns a random element from the set."))
     (make-signature '|enumerate| '(|List %|) '()
       '("enumerate() returns a list of elements of the set")
       '("enumerate()$OrderedVariableList([p,q])"))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Finite|
  (progn
    (push '|Finite| *Categories*)
    (make-instance '|FiniteType|)))

\end{chunk}

\subsection{FortranFunctionCategory}
\index[cat]{FortranFunctionCategory!Category}
\index[cat]{Category!FortranFunctionCategory}
\index[cat]{FORTFN}
\begin{chunk}{defclass FortranFunctionCategoryType}
(defclass |FortranFunctionCategoryType| (|FortranProgramCategoryType|)
  ((parents :initform '(|FortranProgramCategory|))
   (name :initform "FortranFunctionCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'FORTFN)
   (comment :initform (list
     "FortranFunctionCategory is the category of arguments to"
     "NAG Library routines which return (sets of) function values."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|coerce| '(%) '((|List| |FortranCode|))
       '("coerce(e) takes an object from List FortranCode and"
         "uses it as the body of an ASP."))
     (make-signature '|coerce| '(%)  '(|FortranCode|)
       '("coerce(e) takes an object from FortranCode and"
         "uses it as the body of an ASP."))
     (make-signature '|coerce| '(%)
                     '(|Record(localSymbols:SymbolTable,code:List(FortranCode))|)
       '("coerce(e) takes the component of e from"
         "List FortranCode and uses it as the body of the ASP,"
         "making the declarations in the SymbolTable component."))
     (make-signature '|retract| '(%) '((|Expression| |Float|))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) '((|Expression| |Float|))
       '("retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retract| '(%)  '((|Expression| |Integer|)) 
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) '((|Expression| |Integer|))
       '("retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retract| '(%) '((|Polynomial| |Float|))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) '((|Polynomial| |Float|))
       '("retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retract| '(%) '((|Polynomial| |Integer|))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) '((|Polynomial| |Integer|))
       '("retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retract| '(%) '((|Fraction| (|Polynomial| |Float|)))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed"))
                                     '((|Fraction| (|Polynomial| |Float|)))
       '("retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retract| '(%) '((|Fraction| (|Polynomial| |Integer|)))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) 
                                     '((|Fraction| (|Polynomial| |Integer|)))
       '("retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))

   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FortranFunctionCategory|
  (progn
    (push '|FortranFunctionCategory| *Categories*)
    (make-instance '|FortranFunctionCategoryType|)))

\end{chunk}

\subsection{FortranMatrixCategory}
\index[cat]{FortranMatrixCategory!Category}
\index[cat]{Category!FortranMatrixCategory}
\index[cat]{FMC}
\begin{chunk}{defclass FortranMatrixCategoryType}
(defclass |FortranMatrixCategoryType| (|FortranProgramCategoryType|)
  ((parents :initform '(|FortranProgramCategory|))
   (name :initform "FortranMatrixCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'FMC)
   (comment :initform (list
     "FortranMatrixCategory provides support for"
     "producing Functions and Subroutines when the input to these"
     "is an AXIOM object of type Matrix or in domains"
     "involving FortranCode."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|coerce| '(%)  '((|Matrix| |MachineFloat|))
       '("coerce(v) produces an ASP which returns the value of v."))
     (make-signature '|coerce| '(%) '((|List| |FortranCode|))
       '("coerce(e) takes an object from List FortranCode and"
         "uses it as the body of an ASP."))
     (make-signature '|coerce| '(%) '(|FortranCode|)
       '("coerce(e) takes an object from List FortranCode and"
         "uses it as the body of an ASP."))
     (make-signature '|coerce| '(%) 
                     '((|Record| |localSymbols:SymbolTable| |code:List(FortranCode)|))
      '("coerce(e) takes the component of e from"
        "List FortranCode and uses it as the body of the ASP,"
        "making the declarations in the SymbolTable component."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FortranMatrixCategory|
  (progn
    (push '|FortranMatrixCategory| *Categories*)
    (make-instance '|FortranMatrixCategoryType|)))

\end{chunk}

\subsection{FortranMatrixFunctionCategory}
\index[cat]{FortranMatrixFunctionCategory!Category}
\index[cat]{Category!FortranMatrixFunctionCategory}
\index[cat]{FMFUN}
\begin{chunk}{defclass FortranMatrixFunctionCategoryType}
(defclass |FortranMatrixFunctionCategoryType| (|FortranProgramCategoryType|)
  ((parents :initform '(|FortranProgramCategory|))
   (name :initform "FortranMatrixFunctionCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'FMFUN)
   (comment :initform (list
     "FortranMatrixFunctionCategory provides support for"
     "producing Functions and Subroutines representing matrices of"
     "expressions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|coerce| '(%) '((|List| |FortranCode|))
       '("coerce(e) takes an object from List FortranCode and"
         "uses it as the body of an ASP."))
     (make-signature '|coerce| '(%) '(|FortranCode|)
       '("coerce(e) takes an object from FortranCode and"
         "uses it as the body of an ASP."))
     (make-signature '|coerce| '(%)
                     '((|Record| |localSymbols:SymbolTable| |code:List(FortranCode)|))
      '("coerce(e) takes the component of e from"
        "List FortranCode and uses it as the body of the ASP,"
        "making the declarations in the SymbolTable component."))
     (make-signature '|retract| '(%) '((|Matrix| |Expression| |Float|))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) 
                                     '((|Matrix| |Expression| |Float|))
       '("d retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retract| '(%) '((|Matrix| |Expression| |Integer|))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) 
                                     '((|Matrix| |Expression| |Integer|))
       '("retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retract| '(%) '((|Matrix| |Polynomial| |Float|))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) 
                                     '((|Matrix| |Polynomial| |Float|))
       '("retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retract| '(%) '((|Matrix| |Polynomial| |Integer|))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) 
                                     '((|Matrix| |Polynomial| |Integer|))
       '("retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retract| '(%) '((|Matrix| |Fraction| |Polynomial| |Float|))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) 
                                     '((|Matrix| |Fraction| |Polynomial| |Float|))
       '("retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retract| '(%) '((|Matrix| |Fraction| |Polynomial| |Integer|))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) 
                                     '((|Matrix| |Fraction| |Polynomial| |Integer|))
       '("retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FortranMatrixFunctionCategory|
  (progn
    (push '|FortranMatrixFunctionCategory| *Categories*)
    (make-instance '|FortranMatrixFunctionCategoryType|)))

\end{chunk}

\subsection{FortranVectorCategory}
\index[cat]{FortranVectorCategory!Category}
\index[cat]{Category!FortranVectorCategory}
\index[cat]{FVC}
\begin{chunk}{defclass FortranVectorCategoryType}
(defclass |FortranVectorCategoryType| (|FortranProgramCategoryType|)
  ((parents :initform '(|FortranProgramCategory|))
   (name :initform "FortranVectorCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'FVC)
   (comment :initform (list
     "FortranVectorCategory provides support for"
     "producing Functions and Subroutines when the input to these"
     "is an AXIOM object of type Vector or in domains"
     "involving FortranCode."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|coerce| '(%)  '((|Vector| |MachineFloat|))
       '("coerce(v) produces an ASP which returns the value of v."))
     (make-signature '|coerce| '(%) '((|List| |FortranCode|))
       '("coerce(e) takes an object from List FortranCode and"
         "uses it as the body of an ASP."))
     (make-signature '|coerce| '(%) '(|FortranCode|)
       '("coerce(e) takes an object from FortranCode and"
         "uses it as the body of an ASP."))
     (make-signature '|coerce| '(%) 
                     '((|Record| |localSymbols:SymbolTable| |code:List(FortranCode)|))
      '("coerce(e) takes the component of e from"
        "List FortranCode and uses it as the body of the ASP,"
        "making the declarations in the SymbolTable component."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FortranVectorCategory|
  (progn
    (push '|FortranVectorCategory| *Categories*)
    (make-instance '|FortranVectorCategoryType|)))

\end{chunk}

\subsection{FortranVectorFunctionCategory}
\index[cat]{FortranVectorFunctionCategory!Category}
\index[cat]{Category!FortranVectorFunctionCategory}
\index[cat]{FVFUN}
\begin{chunk}{defclass FortranVectorFunctionCategoryType}
(defclass |FortranVectorFunctionCategoryType| (|FortranProgramCategoryType|)
  ((parents :initform '(|FortranProgramCategory|))
   (name :initform "FortranVectorFunctionCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'FVFUN)
   (comment :initform (list
     "FortranVectorFunctionCategory is the catagory of arguments"
     "to NAG Library routines which return the values of vectors of functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|coerce| '(%) '((|List| |FortranCode|))
       '("coerce(e) takes an object from List FortranCode and"
         "uses it as the body of an ASP."))
     (make-signature '|coerce| '(%) '(|FortranCode|)
       '("coerce(e) takes an object from FortranCode and"
         "uses it as the body of an ASP."))
     (make-signature '|coerce| '(%)
                     '((|Record| |localSymbols:SymbolTable| |code:List(FortranCode)|))
      '("coerce(e) takes the component of e from"
        "List FortranCode and uses it as the body of the ASP,"
        "making the declarations in the SymbolTable component."))
     (make-signature '|retract| '(%) '((|Vector| |Expression| |Float|))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) 
                                     '((|Vector| |Expression| |Float|))
       '("d retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retract| '(%) '((|Vector| |Expression| |Integer|))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) 
                                     '((|Vector| |Expression| |Integer|))
       '("retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retract| '(%) '((|Vector| |Polynomial| |Float|))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) 
                                     '((|Vector| |Polynomial| |Float|))
       '("retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retract| '(%) '((|Vector| |Polynomial| |Integer|))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) 
                                     '((|Vector| |Polynomial| |Integer|))
       '("retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retract| '(%) '((|Vector| |Fraction| |Polynomial| |Float|))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) 
                                     '((|Vector| |Fraction| |Polynomial| |Float|))
       '("retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retract| '(%) '((|Vector| |Fraction| |Polynomial| |Integer|))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) 
                                     '((|Vector| |Fraction| |Polynomial| |Integer|))
       '("retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FortranVectorFunctionCategory|
  (progn
    (push '|FortranVectorFunctionCategory| *Categories*)
    (make-instance '|FortranVectorFunctionCategoryType|)))

\end{chunk}

\subsection{FullyEvalableOver}
\index[cat]{FullyEvalableOver!Category}
\index[cat]{Category!FullyEvalableOver}
\index[cat]{FEVALAB}
\begin{chunk}{defclass FullyEvalableOverType}
(defclass |FullyEvalableOverType| (|EltableType| |EvalableType|)
  ((parents :initform '(|Eltable| |Evalable|))
   (name :initform "FullyEvalableOver")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'FEVALAB)
   (comment :initform (list
     "This category provides a selection of evaluation operations"
     "depending on what the argument type R provides."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FullyEvalableOver|
  (progn
    (push '|FullyEvalableOver| *Categories*)
    (make-instance '|FullyEvalableOverType|)))

\end{chunk}

\subsection{GradedModule}
\index[cat]{GradedModule!Category}
\index[cat]{Category!GradedModule}
\index[cat]{GRMOD}
\begin{chunk}{defclass GradedModuleType}
(defclass |GradedModuleType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "GradedModule")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'GRMOD)
   (comment :initform (list
     "GradedModule(R,E) denotes 'E-graded R-module', that is, collection of"
     "R-modules indexed by an abelian monoid E."
     "An element g of G[s] for some specific s in E"
     "is said to be an element of G with degree s."
     "Sums are defined in each module G[s] so two elements of G"
     "have a sum if they have the same degree."
     " "
     "Morphisms can be defined and composed by degree to give the"
     "mathematical category of graded modules."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|degree| '(|E|) '(%)
       '("degree(g) names the degree of g.  The set of all elements"
         "of a given degree form an R-module."))
     (make-signature '|0| '(%)  '(|constant|)
       '("0 denotes the zero of degree 0."))
     (make-signature '|*| '(%)  '(|(R, %)|)
       '("r*g is left module multiplication.") () t)
     (make-signature '|*| '(%)  '(|(%, R)|)
       '("g*r is right module multiplication.") () t)
     (make-signature '|-| '(%)  '(%)
       '("-g is the additive inverse of g in the module of elements"
         "of the same grade as g.") () t)
     (make-signature '|+| '(%)  '(|(%, %)|)
       '("g+h is the sum of g and h in the module of elements of"
         "the same degree as g and h.  Error: if g and h"
         "have different degrees." () t))
     (make-signature '|-| '(%)  '(|(%, %)|)
       '("g-h is the difference of g and h in the module of elements of"
         "the same degree as g and h.  Error: if g and h" 
         "have different degrees.") () t)
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GradedModule|
  (progn
    (push '|GradedModule| *Categories*)
    (make-instance '|GradedModuleType|)))

\end{chunk}

\subsection{HomogeneousAggregate}
\index[cat]{HomogeneousAggregate!Category}
\index[cat]{Category!HomogeneousAggregate}
\index[cat]{HOAGG}
\begin{chunk}{defclass HomogeneousAggregateType}
(defclass |HomogeneousAggregateType| (|AggregateType| |EvalableType| |SetCategoryType|)
  ((parents  :initform '(|SetCategory| |Aggregate| |Evalable|))
   (name :initform "HomogeneousAggregate")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'HOAGG)
   (comment :initform (list
     "A homogeneous aggregate is an aggregate of elements all of the"
     "same type."
     "In the current system, all aggregates are homogeneous."
     "Two attributes characterize classes of aggregates."
     "Aggregates from domains with attribute finiteAggregate"
     "have a finite number of members."
     "Those with attribute shallowlyMutable allow an element"
     "to be modified or updated without changing its overall value."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |HomogeneousAggregate|
  (progn
    (push '|HomogeneousAggregate| *Categories*)
    (make-instance '|HomogeneousAggregateType|)))

\end{chunk}

\subsection{IndexedDirectProductCategory}
\index[cat]{IndexedDirectProductCategory!Category}
\index[cat]{Category!IndexedDirectProductCategory}
\index[cat]{IDPC}
\begin{chunk}{defclass IndexedDirectProductCategoryType}
(defclass |IndexedDirectProductCategoryType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "IndexedDirectProductCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'IDPC)
   (comment :initform (list
     "This category represents the direct product of some set with"
     "respect to an ordered indexing set."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|map| '|%| '((|->| A A))
       '("map(f,z) returns the new element created by applying the"
         "function f to each component of the direct product element z."))
     (make-signature '|monomial| '(|%|) '(A S)
       '("monomial(a,s) constructs a direct product element with the s"
         "component set to a"))
     (make-signature '|leadingCoefficient| '(A) '(|%|)
       '("leadingCoefficient(z) returns the coefficient of the leading"
         "(with respect to the ordering on the indexing set)"
         "monomial of z."
         "Error: if z has no support."))
     (make-signature '|leadingSupport| '(S) '(|%|)
       '("leadingSupport(z) returns the index of leading"
         "(with respect to the ordering on the indexing set) monomial of z."
         "Error: if z has no support."))
     (make-signature '|reductum| '(|%|) '(|%|)
       '("reductum(z) returns a new element created by removing the"
         "leading coefficient/support pair from the element z."
         "Error: if z has no support."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexedDirectProductCategory|
  (progn
    (push '|IndexedDirectProductCategory| *Categories*)
    (make-instance '|IndexedDirectProductCategoryType|)))

\end{chunk}

\subsection{LiouvillianFunctionCategory}
\index[cat]{LiouvillianFunctionCategory!Category}
\index[cat]{Category!LiouvillianFunctionCategory}
\index[cat]{LFCAT}
\begin{chunk}{defclass LiouvillianFunctionCategoryType}
(defclass |LiouvillianFunctionCategoryType| (|PrimitiveFunctionCategoryType| 
                                             |TranscendentalFunctionCategoryType|)
  ((parents :initform '(|PrimitiveFunctionCategory| |TranscendentalFunctionCategory|))
   (name :initform "LiouvillianFunctionCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'LFCAT)
   (comment :initform (list
     "Category for the transcendental Liouvillian functions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|Ei| '(|%|) '(|%|)
      '("Ei(x) returns the exponential integral of x, that is,"
        "the integral of exp(x)/x dx."))
 
    (make-signature '|Si| '(|%|) '(|%|)
      '("Si(x) returns the sine integral of x, that is,"
        "the integral of sin(x) / x dx."))

    (make-signature '|Ci| '(|%|) '(|%|)
      '("Ci(x) returns the cosine integral of x, that is,"
        "the integral of cos(x) / x dx."))

    (make-signature '|li| '(|%|) '(|%|)
      '("li(x) returns the logarithmic integral of x, that is,"
        "the integral of dx / log(x)."))

    (make-signature '|dilog| '(|%|) '(|%|)
      '("dilog(x) returns the dilogarithm of x, that is,"
        "the integral of log(x) / (1 - x) dx."))

    (make-signature '|erf| '(|%|) '(|%|)
      '("erf(x) returns the error function of x, that is,"
        "2 / sqrt(%pi) times the integral of exp(-x**2) dx."))

    (make-signature '|fresnelS| '(|%|) '(|%|)
      '("fresnelS(x) is the Fresnel integral S, defined by"
        "S(x) = integrate(sin(t^2),t=0..x)"))

    (make-signature '|fresnelC| '(|%|) '(|%|)
      '("fresnelC(x) is the Fresnel integral C, defined by"
        "C(x) = integrate(cos(t^2),t=0..x)"))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LiouvillianFunctionCategory|
  (progn
    (push '|LiouvillianFunctionCategory| *Categories*)
    (make-instance '|LiouvillianFunctionCategoryType|)))

\end{chunk}

\subsection{Monad}
\index[cat]{Monad!Category}
\index[cat]{Category!Monad}
\index[cat]{MONAD}
\begin{chunk}{defclass MonadType}
(defclass |MonadType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "Monad")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'MONAD)
   (comment :initform (list
     "Monad is the class of all multiplicative monads, that is sets"
     "with a binary operation."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
    (make-signature '|*| '(|%|) '(|%| |%|)
      '("a*b is the product of a and b in a set with"
        "a binary operation.") () t)
    (make-signature '|rightPower| '(|%|) '(|%| |PositiveInteger|)
      '("rightPower(a,n) returns the n-th right power of a,"
        "that is, rightPower(a,n) := rightPower(a,n-1) * a and"
        "rightPower(a,1) := a."))
    (make-signature '|leftPower| '(|%|) '(|%| |PositiveInteger|)
      '("leftPower(a,n) returns the n-th left power of a,"
        "that is, leftPower(a,n) := a * leftPower(a,n-1) and"
        "leftPower(a,1) := a."))
    (make-signature '|**| '(|%|) '(|%| |PositiveInteger|)
       '("a**n returns the n-th power of a,"
         "defined by repeated squaring.") () t)
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Monad|
  (progn
    (push '|Monad| *Categories*)
    (make-instance '|MonadType|)))

\end{chunk}

\subsection{NumericalIntegrationCategory}
\index[cat]{NumericalIntegrationCategory!Category}
\index[cat]{Category!NumericalIntegrationCategory}
\index[cat]{NUMINT}
\begin{chunk}{defclass NumericalIntegrationCategoryType}
(defclass |NumericalIntegrationCategoryType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "NumericalIntegrationCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'NUMINT)
   (comment :initform (list
     "NumericalIntegrationCategory is the category for"
     "describing the set of Numerical Integration domains with"
     "measure and numericalIntegration."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NumericalIntegrationCategory|
  (progn
    (push '|NumericalIntegrationCategory| *Categories*)
    (make-instance '|NumericalIntegrationCategoryType|)))

\end{chunk}

\subsection{NumericalOptimizationCategory}
\index[cat]{NumericalOptimizationCategory!Category}
\index[cat]{Category!NumericalOptimizationCategory}
\index[cat]{OPTCAT}
\begin{chunk}{defclass NumericalOptimizationCategoryType}
(defclass |NumericalOptimizationCategoryType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "NumericalOptimizationCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'OPTCAT)
   (comment :initform (list
     "NumericalOptimizationCategory is the category for"
     "describing the set of Numerical Optimization domains with"
     "measure and optimize."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NumericalOptimizationCategory|
  (progn
    (push '|NumericalOptimizationCategory| *Categories*)
    (make-instance '|NumericalOptimizationCategoryType|)))

\end{chunk}

\subsection{OrderedSet}
\index[cat]{OrderedSet!Category}
\index[cat]{Category!OrderedSet}
\index[cat]{ORDSET}
\begin{chunk}{defclass OrderedSetType}
(defclass |OrderedSetType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "OrderedSet")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'ORDSET)
   (comment :initform (list
     "The class of totally ordered sets, that is, sets such that for each "
     "pair of elements (a,b)"
     "exactly one of the following relations holds a<b or a=b or b<a"
     "and the relation is transitive, that is, a<b and b<c => a<c."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
    (make-signature '|<| '(|Boolean|) '(|%| |%|)
      '("x < y is a strict total ordering on the elements of the set.") () t)
    (make-signature '|>| '(|Boolean|) '(|%| |%|)
      '("x > y is a greater than test.") () t)
    (make-signature '|>=| '(|Boolean|) '(|%| |%|)
      '("x >= y is a greater than or equal test.") () t)
    (make-signature '|<=| '(|Boolean|) '(|%| |%|)
      '("x <= y is a less than or equal test.") () t)
    (make-signature '|max| '(|%|) '(|%| |%|)
      '("max(x,y) returns the maximum of x and y relative to '<'"))
    (make-signature '|min| '(|%|) '(|%| |%|)
      '("min(x,y) returns the minimum of x and y relative to '<'"))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderedSet|
  (progn
    (push '|OrderedSet| *Categories*)
    (make-instance '|OrderedSetType|)))

\end{chunk}

\subsection{OrdinaryDifferentialEquationsSolverCategory}
\index[cat]{OrdinaryDifferentialEquationsSolverCategory!Category}
\index[cat]{Category!OrdinaryDifferentialEquationsSolverCategory}
\index[cat]{ODECAT}
\begin{chunk}{defclass OrdinaryDifferentialEquationsSolverCategoryType}
(defclass |OrdinaryDifferentialEquationsSolverCategoryType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "OrdinaryDifferentialEquationsSolverCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'ODECAT)
   (comment :initform (list
     "OrdinaryDifferentialEquationsSolverCategory is the"
     "category for describing the set of ODE solver domains"
     "with measure and ODEsolve."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrdinaryDifferentialEquationsSolverCategory|
  (progn
    (push '|OrdinaryDifferentialEquationsSolverCategory| *Categories*)
    (make-instance '|OrdinaryDifferentialEquationsSolverCategoryType|)))

\end{chunk}

\subsection{PartialDifferentialEquationsSolverCategory}
\index[cat]{PartialDifferentialEquationsSolverCategory!Category}
\index[cat]{Category!PartialDifferentialEquationsSolverCategory}
\index[cat]{PDECAT}
\begin{chunk}{defclass PartialDifferentialEquationsSolverCategoryType}
(defclass |PartialDifferentialEquationsSolverCategoryType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "PartialDifferentialEquationsSolverCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'PDECAT)
   (comment :initform (list
     "PartialDifferentialEquationsSolverCategory is the"
     "category for describing the set of PDE solver domains"
     "with measure and PDEsolve."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PartialDifferentialEquationsSolverCategory|
  (progn
    (push '|PartialDifferentialEquationsSolverCategory| *Categories*)
    (make-instance '|PartialDifferentialEquationsSolverCategoryType|)))

\end{chunk}

\subsection{PatternMatchable}
\index[cat]{PatternMatchable!Category}
\index[cat]{Category!PatternMatchable}
\index[cat]{PATMAB}
\begin{chunk}{defclass PatternMatchableType}
(defclass |PatternMatchableType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "PatternMatchable")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'PATMAB)
   (comment :initform (list
     "A set R is PatternMatchable over S if elements of R can"
     "be matched to patterns over S."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
    (make-signature '|sign| '(Z) '(|ThePols| |%|)
      '("sign(pol,aRoot) gives the sign of pol interpreted as aRoot"))
    (make-signature '|zero?| '(|Boolean|) '(|ThePols| |%|)
      '("zero?(pol,aRoot) answers if pol interpreted as aRoot is 0"))
    (make-signature '|negative?| '(|Boolean|) '(|ThePols| |%|)
      '("negative?(pol,aRoot) answers if pol interpreted as aRoot is negative"))
    (make-signature '|positive?| '(|Boolean|) '(|ThePols| |%|)
      '("positive?(pol,aRoot) answers if pol interpreted as aRoot is positive"))
    (make-signature '|recip| '((|Union| |ThePols| "failed")) '(|ThePols| |%|)
      '("recip(pol,aRoot) tries to inverse pol interpreted as aRoot"))
    (make-signature '|definingPolynomial| '(|ThePols|) '(|%|)
      '("definingPolynomial(aRoot) gives a polynomial"
        "such that definingPolynomial(aRoot).aRoot = 0")) 
    (make-signature '|allRootsOf| '((|List| |%|))  '(|ThePols|)
      '("allRootsOf(pol) creates all the roots of pol" 
        "in the Real Closure, assumed in order."))
    (make-signature '|rootOf| '(|Union| $ "failed") '(|ThePols| N) 
      '("rootOf(pol,n) gives the nth root for the order of the Real Closure"))
    (make-signature '|approximate| '(|TheField|) '(|ThePols| $ |TheField|)
      '("approximate(term,root,prec) gives an approximation"
        "of term over root with precision prec"))
    (make-signature '|relativeApprox| '(|TheField|) '(|ThePols| $ |TheField|)
      '("approximate(term,root,prec) gives an approximation"
        "of term over root with precision prec"))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternMatchable|
  (progn
    (push '|PatternMatchable| *Categories*)
    (make-instance '|PatternMatchableType|)))

\end{chunk}

\subsection{RealRootCharacterizationCategory}
\index[cat]{RealRootCharacterizationCategory!Category}
\index[cat]{Category!RealRootCharacterizationCategory}
\index[cat]{RRCC}
\begin{chunk}{defclass RealRootCharacterizationCategoryType}
(defclass |RealRootCharacterizationCategoryType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "RealRootCharacterizationCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'RRCC)
   (comment :initform (list
     "RealRootCharacterizationCategory provides common access"
     "functions for all real roots of polynomials"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|sign| '(Z) '(|ThePols| %)
       '("sign(pol,aRoot) gives the sign of pol"
         "interpreted as aRoot"))
     (make-signature '|zero?| '(|Boolean|) '(|ThePols| %)
       '("zero?(pol,aRoot) answers if pol"
         "interpreted as aRoot is 0"))
     (make-signature '|negative?| '(|Boolean|) '(|ThePols| %)
       '("negative?(pol,aRoot) answers if pol"
         "interpreted as aRoot is negative"))
     (make-signature '|positive?| '(|Boolean|) '(|ThePols| %)
       '("positive?(pol,aRoot) answers if pol"
         "interpreted as aRoot is positive"))
     (make-signature '|recip| '((|Union| |ThePols| "failed")) '(|ThePols| %)
       '("recip(pol,aRoot) tries to inverse pol"
         "interpreted as aRoot"))
     (make-signature '|definingPolynomial| '(|ThePols|) '(%)
       '("definingPolynomial(aRoot) gives a polynomial"
         "such that definingPolynomial(aRoot).aRoot = 0")) 
     (make-signature '|allRootsOf| '((|List| %)) '(|ThePols|)
       '("allRootsOf(pol) creates all the roots of pol"
         "in the Real Closure, assumed in order."))
     (make-signature '|rootOf| '((|Union| % "failed")) '(|ThePols| N)
       '("rootOf(pol,n) gives the nth root for the order of the"
         "Real Closure"))
     (make-signature '|approximate| '(|TheField|) '(|ThePols| % |TheField|)
       '("approximate(term,root,prec) gives an approximation"
         "of term over root with precision prec"))
     (make-signature '|relativeApprox| '(|TheField|) '(|ThePols| % |TheField|)
       '("approximate(term,root,prec) gives an approximation"
         "of term over root with precision prec"))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RealRootCharacterizationCategory|
  (progn
    (push '|RealRootCharacterizationCategory| *Categories*)
    (make-instance '|RealRootCharacterizationCategoryType|)))

\end{chunk}

\subsection{SExpressionCategory}
\index[cat]{SExpressionCategory!Category}
\index[cat]{Category!SExpressionCategory}
\index[cat]{SEXCAT}
\begin{chunk}{defclass SExpressionCategoryType}
(defclass |SExpressionCategoryType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "SExpressionCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'SEXCAT)
   (comment :initform (list
     "This category allows the manipulation of Lisp values while keeping"
     "the grunge fairly localized."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|eq| '(|Boolean|) '(% %)
       '("eq(s, t) is true if EQ(s,t) is true in Lisp."))

     (make-signature '|null?| '(|Boolean|) '(%)
       '("null?(s) is true if s is the S-expression ()."))

     (make-signature '|atom?| '(|Boolean|) '(%)
       '("atom?(s) is true if s is a Lisp atom."))

     (make-signature '|pair?| '(|Boolean|) '(%)
       '("pair?(s) is true if s has is a non-null Lisp list."))

     (make-signature '|list?| '(|Boolean|) '(%)
       '("list?(s) is true if s is a Lisp list, possibly ()."))

     (make-signature '|string?| '(|Boolean|) '(%)
       '("string?(s) is true if s is an atom and belong to Str."))

     (make-signature '|symbol?| '(|Boolean|) '(%)
       '("symbol?(s) is true if s is an atom and belong to Sym."))

     (make-signature '|integer?| '(|Boolean|) '(%)
       '("integer?(s) is true if s is an atom and belong to Int."))

     (make-signature '|float?| '(|Boolean|) '(%)
       '("float?(s) is true if s is an atom and belong to Flt."))

     (make-signature '|destruct| '(|List %|) '(%)
       '("destruct((a1,...,an)) returns the list [a1,...,an]."))

     (make-signature '|string| '(|Str|) '(%)
       '("string(s) returns s as an element of Str."
         "Error: if s is not an atom that also belongs to Str."))

    (make-signature '| symbol| '(|Sym|) '(%)
       '("symbol(s) returns s as an element of Sym."
         "Error: if s is not an atom that also belongs to Sym."))

    (make-signature '| integer| '(|Int|) '(%)
       '("integer(s) returns s as an element of Int."
         "Error: if s is not an atom that also belongs to Int."))

    (make-signature '| float| '(|Flt|) '(%)
       '("float(s) returns s as an element of Flt;"
         "Error: if s is not an atom that also belongs to Flt."))

    (make-signature '| expr| '(|Expr|) '(%)
       '("expr(s) returns s as an element of Expr;"
         "Error: if s is not an atom that also belongs to Expr."))

    (make-signature '| convert| '(%) '(|List| %)
       '("convert([a1,...,an]) returns an S-expression (a1,...,an)."))

     (make-signature '|convert| '(%) '(|Str|)
       '("convert(x) returns the Lisp atom x;"))

     (make-signature '|convert| '(%) '(|Sym|)
       '("convert(x) returns the Lisp atom x."))

     (make-signature '|convert| '(%) '(|Int|)
       '("convert(x) returns the Lisp atom x."))

     (make-signature '|convert| '(%) '(|Flt|)
       '("convert(x) returns the Lisp atom x."))

     (make-signature '|convert| '(%) '(|Expr|)
       '("convert(x) returns the Lisp atom x."))

     (make-signature '|car| '(%) '(%)
       '("car((a1,...,an)) returns a1."))

     (make-signature '|cdr| '(%) '(%)
       '("cdr((a1,...,an)) returns (a2,...,an)."))

     (make-signature '|"#"| '(|Integer|) '(%)
       '("#((a1,...,an)) returns n."))

     (make-signature '|elt| '(%) '(% |Integer|)
       '("elt((a1,...,an), i) returns ai."))

     (make-signature '|elt| '(%) '(% (|List| |Integer|))
       '("elt((a1,...,an), [i1,...,im]) returns (a_i1,...,a_im)."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SExpressionCategory|
  (progn
    (push '|SExpressionCategory| *Categories*)
    (make-instance '|SExpressionCategoryType|)))

\end{chunk}

\subsection{SegmentExpansionCategory}
\index[cat]{SegmentExpansionCategory!Category}
\index[cat]{Category!SegmentExpansionCategory}
\index[cat]{SEGXCAT}
\begin{chunk}{defclass SegmentExpansionCategoryType}
(defclass |SegmentExpansionCategoryType| (|SegmentCategoryType|)
  ((parents :initform '(|SegmentCategory|))
   (name :initform "SegmentExpansionCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'SEGXCAT)
   (comment :initform (list
     "This category provides an interface for expanding segments to"
     "a stream of elements."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|expand| '(L) '(|List| %)
       '("expand(l) creates a new value of type L in which each segment"
         "l..h by k is replaced with l, l+k, ... lN,"
         "where lN <= h < lN+k."
         "For example, expand [1..4, 7..9] = [1,2,3,4,7,8,9]."))
     (make-signature '|expand| '(L) '(%)
       '("expand(l..h by k) creates value of type L with elements"
         "l, l+k, ... lN where lN <= h < lN+k."
         "For example, expand(1..5 by 2) = [1,3,5]."))
     (make-signature '|map| '(L) '(|S -> S| %) 
       '("map(f,l..h by k) produces a value of type L by applying f"
         "to each of the succesive elements of the segment, that is,"
         "[f(l), f(l+k), ..., f(lN)], where lN <= h < lN+k."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SegmentExpansionCategory|
  (progn
    (push '|SegmentExpansionCategory| *Categories*)
    (make-instance '|SegmentExpansionCategoryType|)))

\end{chunk}

\subsection{SemiGroup}
\index[cat]{SemiGroup!Category}
\index[cat]{Category!SemiGroup}
\index[cat]{SGROUP}
\begin{chunk}{defclass SemiGroupType}
(defclass |SemiGroupType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "SemiGroup")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'SGROUP)
   (comment :initform (list
     "The class of all multiplicative semigroups, that is, a set"
     "with an associative operation *."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|*| '(%) '(% %)
       '("x*y returns the product of x and y.") () t)

     (make-signature '|**| '(%) '(% |PositiveInteger|)
       '("x**n returns the repeated product of x n times, exponentiation.") () t)

     (make-signature '|^| '(%) '(% |PositiveInteger|)
       '("x^n returns the repeated product of x n times, exponentiation.") () t)
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SemiGroup|
  (progn
    (push '|SemiGroup| *Categories*)
    (make-instance '|SemiGroupType|)))

\end{chunk}

\subsection{SetCategoryWithDegree}
\index[cat]{SetCategoryWithDegree!Category}
\index[cat]{Category!SetCategoryWithDegree}
\index[cat]{SETCATD}
\begin{chunk}{defclass SetCategoryWithDegreeType}
(defclass |SetCategoryWithDegreeType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "SetCategoryWithDegree")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'SETCATD)
   (comment :initform (list
     "This is part of the PAFF package, related to projective space."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|degree| '(|PositiveInteger|) '(%) ())
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SetCategoryWithDegree|
  (progn
    (push '|SetCategoryWithDegree| *Categories*)
    (make-instance '|SetCategoryWithDegreeType|)))

\end{chunk}

\subsection{StepThrough}
\index[cat]{StepThrough!Category}
\index[cat]{Category!StepThrough}
\index[cat]{STEP}
\begin{chunk}{defclass StepThroughType}
(defclass |StepThroughType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "StepThrough")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'STEP)
   (comment :initform (list
     "A class of objects which can be 'stepped through'."
     "Repeated applications of nextItem is guaranteed never to"
     "return duplicate items and only return 'failed' after exhausting"
     "all elements of the domain."
     "This assumes that the sequence starts with init()."
     "For infinite domains, repeated application"
     "of nextItem is not required to reach all possible domain elements"
     "starting from any initial element."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|init| '(%) '(|constant|)
       '("init() chooses an initial object for stepping."))
  
     (make-signature '|nextItem| '(|Union| % "failed") '(%)
       '("nextItem(x) returns the next item, or \"failed\""
         "if domain is exhausted."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StepThrough|
  (progn
    (push '|StepThrough| *Categories*)
    (make-instance '|StepThroughType|)))

\end{chunk}

\subsection{ThreeSpaceCategory}
\index[cat]{ThreeSpaceCategory!Category}
\index[cat]{Category!ThreeSpaceCategory}
\index[cat]{SPACEC}
\begin{chunk}{defclass ThreeSpaceCategoryType}
(defclass |ThreeSpaceCategoryType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "ThreeSpaceCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'SPACEC)
   (comment :initform (list
     "The category ThreeSpaceCategory is used for creating" 
     "three dimensional objects using functions for defining points, curves,"
     "polygons, constructs and the subspaces containing them."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|create3Space| '(%) '() 
       '("create3Space() creates a ThreeSpace object capable of "
         "holding point, curve, mesh components and any combination."))

     (make-signature '|create3Space| '(%) '(SUBSPACE)
       '("create3Space(s) creates a ThreeSpace object containing"
         "objects pre-defined within some SubSpace s."))

     (make-signature '|numberOfComponents| '(NNI) '(%)
       '("numberOfComponents(s) returns the number of distinct"
         "object components in the indicated ThreeSpace, s, such"
         "as points, curves, polygons, and constructs."))

     (make-signature '|numberOfComposites| '(NNI) '(%)
       '("numberOfComposites(s) returns the number of supercomponents,"
         "or composites, in the ThreeSpace, s; Composites are "
         "arbitrary groupings of otherwise distinct and unrelated components;"
         "A ThreeSpace need not have any composites defined at all"
         "and, outside of the requirement that no component can belong"
         "to more than one composite at a time, the definition and"
         "interpretation of composites are unrestricted."))

     (make-signature '|merge| '(%) '((|List| %))
       '("merge([s1,s2,...,sn]) will create a new ThreeSpace that"
         "has the components of all the ones in the list; Groupings of "
         "components into composites are maintained."))

     (make-signature '|merge| '(%) '(% %)
       '("merge(s1,s2) will create a new ThreeSpace that has the"
         "components of s1 and s2; Groupings of components"
         "into composites are maintained."))

     (make-signature '|composite| '(%) '((|List| %))
       '("composite([s1,s2,...,sn]) will create a new ThreeSpace"
         "that is a union of all the components from each "
         "ThreeSpace in the parameter list, grouped as a composite."))

     (make-signature '|components| '(|List| %) '(%)
       '("components(s) takes the ThreeSpace s, and creates a list "
         "containing a unique ThreeSpace for each single component "
         "of s. If s has no components defined, the list returned is empty."))

     (make-signature '|composites| '((|List| %)) '(%)
       '("composites(s) takes the ThreeSpace s, and creates a list "
         "containing a unique ThreeSpace for each single composite "
         "of s. If s has no composites defined (composites need to be "
         "explicitly created), the list returned is empty. Note that not all "
         "the components need to be part of a composite."))

     (make-signature '|copy| '(%) '(%)
       '("copy(s) returns a new ThreeSpace that is an exact copy "
         "of s."))

     (make-signature '|enterPointData| '(NNI) '(% (|List| POINT))
       '("enterPointData(s,[p0,p1,...,pn]) adds a list of points from p0 "
         "through pn to the ThreeSpace, s, and returns the index, "
         "to the starting point of the list;"))

     (make-signature '|modifyPointData| '(%) '(% NNI POINT)
       '("modifyPointData(s,i,p) changes the point at the indexed "
         "location i in the ThreeSpace, s, to that of point p."
         "This is useful for making changes to a point which has been "
         "transformed."))

     (make-signature '|point| '(%) '(% POINT)
       '("point(s,p) adds a point component defined by the point, p, "
         "specified as a list from List(R), to the "
         "ThreeSpace, s, where R is the Ring over "
         "which the point is defined."))

     (make-signature '|point| '(%) '(% (|List| R))
       '("point(s,[x,y,z]) adds a point component defined by a list of "
         "elements which are from the PointDomain(R) to the "
         "ThreeSpace, s, where R is the Ring over "
         "which the point elements are defined."))

     (make-signature '|point| '(%) '(% NNI)
       '("point(s,i) adds a point component which is placed into a component"
         "list of the ThreeSpace, s, at the index given by i."))

     (make-signature '|point| '(%) '(POINT)
       '("point(p) returns a ThreeSpace object which is composed "
         "of one component, the point p."))

     (make-signature '|point| '(POINT) '(%)
       '("point(s) checks to see if the ThreeSpace, s, is "
         "composed of only a single point and if so, returns the point. "
         "An error is signaled otherwise."))

     (make-signature '|point?| '(B) '(%)
       '("point?(s) queries whether the ThreeSpace, s, is "
         "composed of a single component which is a point and returns the "
         "boolean result."))

     (make-signature '|curve| '(%) '(% (|List| POINT))
       '("curve(s,[p0,p1,...,pn]) adds a space curve component defined by a "
         "list of points p0 through pn, to the "
         "ThreeSpace s."))

     (make-signature '|curve| '(%) '(% (|List| |List| R))
       '("curve(s,[[p0],[p1],...,[pn]]) adds a space curve which is a list of "
         "points p0 through pn defined by lists of elements from the domain "
         "PointDomain(m,R), where R is the Ring over which "
         "the point elements are defined and m is the dimension of the "
         "points, to the ThreeSpace s."))

;     (make-signature '|curve| '(%) '(|List| POINT)
;       '("curve([p0,p1,p2,...,pn]) creates a space curve defined"
;         "by the list of points p0 through pn, and returns the "
;         "ThreeSpace whose component is the curve."))
;
;     (make-signature '|curve| '(|List| POINT) '(%)
;       '("curve(s) checks to see if the ThreeSpace, s, is "
;         "composed of a single curve defined by a list of points and if so, "
;         "returns the curve, that is, list of points. An error is signaled "
;         "otherwise."))
;
;     (make-signature '|curve?| '(B) '(%)
;       '("curve?(s) queries whether the ThreeSpace, s, is a curve, "
;         "that is, has one component, a list of list of points, and returns "
;         "true if it is, or false otherwise."))
;
;     (make-signature '|closedCurve| '(%) '(% (|List| POINT))
;       '("closedCurve(s,[p0,p1,...,pn,p0]) adds a closed curve component "
;         "which is a list of points defined by the first element p0 through "
;         "the last element pn and back to the first element p0 again, to the "
;         "ThreeSpace s."))
;
;     (make-signature '|closedCurve| '(%) '(|List| (|List| R))
;       '("closedCurve(s,[[lr0],[lr1],...,[lrn],[lr0]]) adds a closed curve "
;         "component defined by a list of points lr0 through "
;         "lrn, which are lists of elements from the domain "
;         "PointDomain(m,R), where R is the Ring over which "
;         "the point elements are defined and m is the dimension of the "
;         "points, in which the last element of the list of points contains "
;         "a copy of the first element list, lr0."
;         "The closed curve is added to the ThreeSpace, s."))
;
;     (make-signature '|closedCurve| '(%) '(|List| POINT)
;       '("closedCurve(lp) sets a list of points defined by the first element"
;         "of lp through the last element of lp and back to the first elelment"
;         "again and returns a ThreeSpace whose component is the"
;         "closed curve defined by lp."))
;
;     (make-signature '|closedCurve| '(List| POINT) '(%)
;       '("closedCurve(s) checks to see if the ThreeSpace, s, is "
;         "composed of a single closed curve component defined by a list of "
;         "points in which the first point is also the last point, all of "
;         "which are from the domain PointDomain(m,R) and if so, "
;         "returns the list of points.  An error is signaled otherwise."))
;
;     (make-signature '|closedCurve?| '(B) '(%)
;       '("closedCurve?(s) returns true if the ThreeSpace s "))
;      ++ contains a single closed curve component, that is, the first element 
;      ++ of the curve is also the last element, or false otherwise.
;
;     (make-signature '|polygon| '(%) '(|List| POINT)
;       '("polygon(s,[p0,p1,...,pn]) adds a polygon component defined by a "
;         "list of points, p0 throught pn, to the ThreeSpace s."))
;
;     (make-signature '|polygon| '(%) '(% |List| (|List| R))
;       '("polygon(s,[[r0],[r1],...,[rn]]) adds a polygon component defined"
;         "by a list of points r0 through rn, which are lists of"
;         "elements from the domain PointDomain(m,R) to the "
;         "ThreeSpace s, where m is the dimension of the points"
;         "and R is the Ring over which the points are defined."))
;
;     (make-signature '|polygon| '(%) '(|List| POINT)
;       '("polygon([p0,p1,...,pn]) creates a polygon defined by a list of "
;         "points, p0 through pn, and returns a ThreeSpace whose "
;         "component is the polygon."))
;
;     (make-signature '|polygon| '(|List| POINT) '(%)
;       '("polygon(s) checks to see if the ThreeSpace, s, is "
;         "composed of a single polygon component defined by a list of "
;         "points, and if so, returns the list of points;  An error is "
;         "signaled otherwise."))
;
;     (make-signature '|polygon?| '(B) '(%)
;       '("polygon?(s) returns true if the ThreeSpace s contains "
;         "a single polygon component, or false otherwise."))
;
;     (make-signature '|mesh| '(%) '(% (|List| (|List POINT)) (|List| PROP) PROP)
;       '("mesh(s,[[p0],[p1],...,[pn]],[props],prop) adds a surface component, "
;         "defined over a list curves which contains lists of points, to the "
;         "ThreeSpace s; props is a list which contains the "
;         "subspace component properties for each surface parameter, and "
;         "prop is the subspace component property by which the points are "
;         "defined."))
;
;     (make-signature '|mesh| '(%) '(% (|List| (|List| (|List| R))) (|List| PROP) PROP)
;       '("mesh(s, LLLR, [props], prop)"
;         "where LLLR is of the form:"
;         "[[[r10]...,[r1m]],[[r20]...,[r2m]],...,[[rn0]...,[rnm]]],"
;         "adds a surface component to the ThreeSpace s, which is "
;         "defined over a rectangular domain of size WxH where W is the number "
;         "of lists of points from the domain PointDomain(R) and H is "
;         "the number of elements in each of those lists; lprops is the list "
;         "of the subspace component properties for each curve list, and "
;         "prop is the subspace component property by which the points are "
;         "defined."))
;
;     (make-signature '|mesh| '(%) '(% (|List| (|List| POINT)) B B)
;       '("mesh(s, LLP, close1, close2) "
;         "where LLP is of the form [[p0],[p1],...,[pn]] adds a surface "
;         "component to the ThreeSpace, which is defined over a "
;         "list of curves, in which each of these curves is a list of points. "
;         "The boolean arguments close1 and close2 indicate how the surface "
;         "is to be closed. Argument close1 equal true"
;         "means that each individual list (a curve) is to be closed, that is,"
;         "the last point of the list is to be connected to the first point."
;         "Argument close2 equal true "
;         "means that the boundary at one end of the surface is to be"
;         "connected to the boundary at the other end, that is, the boundaries "
;         "are defined as the first list of points (curve) and "
;         "the last list of points (curve)."))
;
;     (make-signature '|mesh| '(%) '(% (|List| (|List| (|List| R))) B B)
;       '("mesh(s, LLLR, close1, close2)"
;         "where LLLR is of the form"
;         "[[[r10]...,[r1m]],[[r20]...,[r2m]],...,[[rn0]...,[rnm]]],"
;         "adds a surface component to the ThreeSpace s, which is "
;         "defined over a rectangular domain of size WxH where W is the number "
;         "of lists of points from the domain PointDomain(R) and H is "
;         "the number of elements in each of those lists; the booleans close1 "
;         "and close2 indicate how the surface is to be closed: if close1 is "
;         "true this means that each individual list (a curve) is to be "
;         "closed (that is,"
;         "the last point of the list is to be connected to the first point);"
;         "if close2 is true, this means that the boundary at one end of the"
;         "surface is to be connected to the boundary at the other end"
;         "(the boundaries are defined as the first list of points (curve)"
;         "and the last list of points (curve))."))
;
;     (make-signature '|mesh| '(%) '(|List| (|List| POINT))
;       '("mesh([[p0],[p1],...,[pn]]) creates a surface defined by a list of "
;         "curves which are lists, p0 through pn, of points, and returns a "
;         "ThreeSpace whose component is the surface."))
;
;     (make-signature '|mesh| '(%) '(|List| (|List| POINT) B B)
;       '("mesh([[p0],[p1],...,[pn]], close1, close2) creates a surface "
;         "defined over a list of curves, p0 through pn, which are lists of "
;         "points; the booleans close1 and close2 indicate how the surface is "
;         "to be closed: close1 set to true means that each individual list "
;         "(a curve) is to be closed (that is, the last point of the list is "
;         "to be connected to the first point); close2 set to true means "
;         "that the boundary at one end of the surface is to be connected to "
;         "the boundary at the other end (the boundaries are defined as the "
;         "first list of points (curve) and the last list of points (curve)); "
;         "the ThreeSpace containing this surface is returned."))
;
;     (make-signature '|mesh| '(|List| (|List| POINT)) '(%)
;       '("mesh(s) checks to see if the ThreeSpace, s, is "
;         "composed of a single surface component defined by a list curves "
;         "which contain lists of points, and if so, returns the list of "
;         "lists of points;  An error is signaled otherwise."))
;
;     (make-signature '|mesh?| '(B) '(%)
;       '("mesh?(s) returns true if the ThreeSpace s is composed "
;         "of one component, a mesh comprising a list of curves which are lists"
;         "of points, or returns false if otherwise"))
;
;     (make-signature '|lp| '(|List| POINT) '(%)
;       '("lp(s) returns the list of points component which the "
;         "ThreeSpace, s, contains; these points are used by "
;         "reference, that is, the component holds indices referring to the "
;         "points rather than the points themselves. This allows for sharing "
;         "of the points."))
;
;     (make-signature '|lllip| '(|List| (|List| (|List| NNI))) '(%)
;       '("lllip(s) checks to see if the ThreeSpace, s, is "
;         "composed of a list of components, which are lists of curves, "
;         "which are lists of indices to points, and if so, returns the list "
;         "of lists of lists;  An error is signaled otherwise."))
;
;     (make-signature '|lllp| '(|List| (|List| (|List| POINT))) '(%)
;       '("lllp(s) checks to see if the ThreeSpace, s, is "
;         "composed of a list of components, which are lists of curves, "
;         "which are lists of points, and if so, returns the list of "
;         "lists of lists;  An error is signaled otherwise."))
;
;     (make-signature '|llprop| '(|List| (|List| PROP)) '(%)
;       '("llprop(s) checks to see if the ThreeSpace, s, is "
;         "composed of a list of curves which are lists of the"
;         "subspace component properties of the curves, and if so, returns the "
;         "list of lists;  An error is signaled otherwise."))
;
;     (make-signature '|lprop| '(|List| PROP) '(%)
;       '("lprop(s) checks to see if the ThreeSpace, s, is "
;         "composed of a list of subspace component properties, and if so, "
;         "returns the list;  An error is signaled otherwise."))
;
;     (make-signature '|objects| '(OBJ3D) '(%)
;       '("objects(s) returns the ThreeSpace, s, in the form of a "
;         "3D object record containing information on the number of points, "
;         "curves, polygons and constructs comprising the "
;         "ThreeSpace.."))
;
;     (make-signature '|check| '(%) '(%)
;       '("check(s) returns lllpt, list of lists of lists of point information "
;         "about the ThreeSpace} s.")
;
;     (make-signature '|subspace| '(SUBSPACE) '(%)
;       '("subspace(s) returns the SubSpace which holds all the "
;         "point information in the ThreeSpace, s."))
;
;     (make-signature '|coerce| '(O) '(%)
;       '("coerce(s) returns the ThreeSpace s to Output format."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ThreeSpaceCategory|
  (progn
    (push '|ThreeSpaceCategory| *Categories*)
    (make-instance '|ThreeSpaceCategoryType|)))

\end{chunk}

\section{Level 4}

\begin{chunk}{defvar level4}
(defvar level4
 '(|AbelianMonoid| |AffineSpaceCategory| |BagAggregate| |CachableSet|
   |Collection| |DifferentialVariableCategory| |ExpressionSpace|
   |FullyPatternMatchable| |GradedAlgebra| |IndexedAggregate|
   |InfinitlyClosePointCategory| |MonadWithUnit| |Monoid|
   |OrderedAbelianSemiGroup| |OrderedFinite| |PlacesCategory|
   |ProjectiveSpaceCategory| |RecursiveAggregate| |TwoDimensionalArrayCategory|))

\end{chunk}

\subsection{AbelianMonoid}
\index[cat]{AbelianMonoid!Category}
\index[cat]{Category!AbelianMonoid}
\index[cat]{ABELMON}
\begin{chunk}{defclass AbelianMonoidType}
(defclass |AbelianMonoidType| (|AbelianSemiGroupType|)
  ((parents :initform '(|AbelianSemiGroup|))
   (name :initform "AbelianMonoid")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'ABELMON)
   (comment :initform (list
     "The class of multiplicative monoids, that is, semigroups with an"
     "additive identity element."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AbelianMonoid|
  (progn
    (push '|AbelianMonoid| *Categories*)
    (make-instance '|AbelianMonoidType|)))

\end{chunk}

\subsection{AffineSpaceCategory}
\index[cat]{AffineSpaceCategory!Category}
\index[cat]{Category!AffineSpaceCategory}
\index[cat]{AFSPCAT}
\begin{chunk}{defclass AffineSpaceCategoryType}
(defclass |AffineSpaceCategoryType| (|SetCategoryWithDegreeType|)
  ((parents :initform '(|SetCategoryWithDegree|))
   (name :initform "AffineSpaceCategory")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'AFSPCAT)
   (comment :initform (list
     "The following is all the categories and domains related to projective"
     "space and part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AffineSpaceCategory|
  (progn
    (push '|AffineSpaceCategory| *Categories*)
    (make-instance '|AffineSpaceCategoryType|)))

\end{chunk}

\subsection{BagAggregate}
\index[cat]{BagAggregate!Category}
\index[cat]{Category!BagAggregate}
\index[cat]{BGAGG}
\begin{chunk}{defclass BagAggregateType}
(defclass |BagAggregateType| (|HomogeneousAggregateType|)
  ((parents :initform '(|HomogeneousAggregate|))
   (name :initform "BagAggregate")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'BGAGG)
   (comment :initform (list
     "A bag aggregate is an aggregate for which one can insert and extract"
     "objects, and where the order in which objects are inserted determines"
     "the order of extraction."
     "Examples of bags are stacks, queues, and dequeues."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BagAggregate|
  (progn
    (push '|BagAggregate| *Categories*)
    (make-instance '|BagAggregateType|)))

\end{chunk}

\subsection{CachableSet}
\index[cat]{CachableSet!Category}
\index[cat]{Category!CachableSet}
\index[cat]{CACHSET}
\begin{chunk}{defclass CachableSetType}
(defclass |CachableSetType| (|OrderedSetType|)
  ((parents :initform '(|OrderedSet|))
   (name :initform "CachableSet")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'CACHSET)
   (comment :initform (list
     "A cachable set is a set whose elements keep an integer as part"
     "of their structure."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CachableSet|
  (progn
    (push '|CachableSet| *Categories*)
    (make-instance '|CachableSetType|)))

\end{chunk}

\subsection{Collection}
\index[cat]{Collection!Category}
\index[cat]{Category!Collection}
\index[cat]{CLAGG}
\begin{chunk}{defclass CollectionType}
(defclass |CollectionType| (|ConvertibleToType| |HomogeneousAggregateType|)
  ((parents  :initform '(|ConvertibleTo| |HomogeneousAggregate|))
   (name :initform "Collection")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'CLAGG)
   (comment :initform (list
     "A collection is a homogeneous aggregate which can built from"
     "list of members. The operation used to build the aggregate is"
     "generically named construct. However, each collection"
     "provides its own special function with the same name as the"
     "data type, except with an initial lower case letter, For example,"
     "list for List, flexibleArray for FlexibleArray, and so on."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Collection|
  (progn
    (push '|Collection| *Categories*)
    (make-instance '|CollectionType|)))

\end{chunk}

\subsection{DifferentialVariableCategory}
\index[cat]{DifferentialVariableCategory!Category}
\index[cat]{Category!DifferentialVariableCategory}
\index[cat]{DVARCAT}
\begin{chunk}{defclass DifferentialVariableCategoryType}
(defclass |DifferentialVariableCategoryType| (|RetractableToType| |OrderedSetType|)
  ((parents :initform '(|RetractableTo| |OrderedSet|))
   (name :initform "DifferentialVariableCategory")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'DVARCAT)
   (comment :initform (list
     "DifferentialVariableCategory constructs the"
     "set of derivatives of a given set of"
     "(ordinary) differential indeterminates."
     "If x,...,y is an ordered set of differential indeterminates,"
     "and the prime notation is used for differentiation, then"
     "the set of derivatives (including"
     "zero-th order) of the differential indeterminates is"
     "x,x',x'',..., y,y',y'',..."
     "(Note that in the interpreter, the n-th derivative of y is displayed as"
     "y with a subscript n.)  This set is"
     "viewed as a set of algebraic indeterminates, totally ordered in a"
     "way compatible with differentiation and the given order on the"
     "differential indeterminates.  Such a total order is called a"
     "ranking of the differential indeterminates."
     " "
     "A domain in this category is needed to construct a differential"
     "polynomial domain.  Differential polynomials are ordered"
     "by a ranking on the derivatives,  and by an order (extending the"
     "ranking) on"
     "on the set of differential monomials.  One may thus associate"
     "a domain in this category with a ranking of the differential"
     "indeterminates, just as one associates a domain in the category"
     "OrderedAbelianMonoidSup with an ordering of the set of"
     "monomials in a set of algebraic indeterminates.  The ranking"
     "is specified through the binary relation <."
     "For example, one may define"
     "one derivative to be less than another by lexicographically comparing"
     "first the order, then the given order of the differential"
     "indeterminates appearing in the derivatives.  This is the default"
     "implementation."
     " "
     "The notion of weight generalizes that of degree.  A"
     "polynomial domain may be made into a graded ring"
     "if a weight function is given on the set of indeterminates,"
     "Very often, a grading is the first step in ordering the set of"
     "monomials.  For differential polynomial domains, this"
     "constructor provides a function weight, which"
     "allows the assignment of a non-negative number to each derivative of a"
     "differential indeterminate.  For example, one may define"
     "the weight of a derivative to be simply its order"
     "(this is the default assignment)."
     "This weight function can then be extended to the set of"
     "all differential polynomials, providing a graded ring structure."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DifferentialVariableCategory|
  (progn
    (push '|DifferentialVariableCategory| *Categories*)
    (make-instance '|DifferentialVariableCategoryType|)))

\end{chunk}

\subsection{ExpressionSpace}
\index[cat]{ExpressionSpace!Category}
\index[cat]{Category!ExpressionSpace}
\index[cat]{ES}
\begin{chunk}{defclass ExpressionSpaceType}
(defclass |ExpressionSpaceType| (|RetractableToType| |EvalableType| |OrderedSetType|)
  ((parents :initform '(|RetractableTo| |Evalable| |OrderedSet|))
   (name :initform "ExpressionSpace")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'ES)
   (comment :initform (list
     "An expression space is a set which is closed under certain operators"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExpressionSpace|
  (progn
    (push '|ExpressionSpace| *Categories*)
    (make-instance '|ExpressionSpaceType|)))

\end{chunk}

\subsection{FullyPatternMatchable}
\index[cat]{FullyPatternMatchable!Category}
\index[cat]{Category!FullyPatternMatchable}
\index[cat]{FPATMAB}
\begin{chunk}{defclass FullyPatternMatchableType}
(defclass |FullyPatternMatchableType| (|TypeType| |PatternMatchableType|)
  ((parents :initform '(|Type| |PatternMatchable|))
   (name :initform "FullyPatternMatchable")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'FPATMAB)
   (comment :initform (list
     "A set S is PatternMatchable over R if S can lift the"
     "pattern-matching functions of S over the integers and float"
     "to itself (necessary for matching in towers)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FullyPatternMatchable|
  (progn
    (push '|FullyPatternMatchable| *Categories*)
    (make-instance '|FullyPatternMatchableType|)))

\end{chunk}

\subsection{GradedAlgebra}
\index[cat]{GradedAlgebra!Category}
\index[cat]{Category!GradedAlgebra}
\index[cat]{GRALG}
\begin{chunk}{defclass GradedAlgebraType}
(defclass |GradedAlgebraType| (|RetractableToType| |GradedModuleType|)
  ((parents :initform '(|RetractableTo| |GradedModule|))
   (name :initform "GradedAlgebra")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'GRALG)
   (comment :initform (list
     "GradedAlgebra(R,E) denotes 'E-graded R-algebra'."
     "A graded algebra is a graded module together with a degree preserving"
     "R-linear map, called the product."
     " "
     "The name 'product' is written out in full so inner and outer products"
     "with the same mapping type can be distinguished by name."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GradedAlgebra|
  (progn
    (push '|GradedAlgebra| *Categories*)
    (make-instance '|GradedAlgebraType|)))

\end{chunk}

\subsection{IndexedAggregate}
\index[cat]{IndexedAggregate!Category}
\index[cat]{Category!IndexedAggregate}
\index[cat]{IXAGG}
\begin{chunk}{defclass IndexedAggregateType}
(defclass |IndexedAggregateType| (|EltableAggregateType| |HomogeneousAggregateType|)
  ((parents  :initform '(|EltableAggregate| |HomogeneousAggregate|))
   (name :initform "IndexedAggregate")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'IXAGG)
   (comment :initform (list
     "An indexed aggregate is a many-to-one mapping of indices to entries."
     "For example, a one-dimensional-array is an indexed aggregate where"
     "the index is an integer.  Also, a table is an indexed aggregate"
     "where the indices and entries may have any type."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexedAggregate|
  (progn
    (push '|IndexedAggregate| *Categories*)
    (make-instance '|IndexedAggregateType|)))

\end{chunk}

\subsection{InfinitlyClosePointCategory}
\index[cat]{InfinitlyClosePointCategory!Category}
\index[cat]{Category!InfinitlyClosePointCategory}
\index[cat]{INFCLCT}
\begin{chunk}{defclass InfinitlyClosePointCategoryType}
(defclass |InfinitlyClosePointCategoryType| (|SetCategoryWithDegreeType|)
  ((parents :initform '(|SetCategoryWithDegree|))
   (name :initform "InfinitlyClosePointCategory")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'INFCLCT)
   (comment :initform (list
     "This category is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InfinitlyClosePointCategory|
  (progn
    (push '|InfinitlyClosePointCategory| *Categories*)
    (make-instance '|InfinitlyClosePointCategoryType|)))

\end{chunk}

\subsection{MonadWithUnit}
\index[cat]{MonadWithUnit!Category}
\index[cat]{Category!MonadWithUnit}
\index[cat]{MONADWU}
\begin{chunk}{defclass MonadWithUnitType}
(defclass |MonadWithUnitType| (|MonadType|)
  ((parents :initform '(|Monad|))
   (name :initform "MonadWithUnit")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'MONADWU)
   (comment :initform (list
     "MonadWithUnit is the class of multiplicative monads with unit,"
     "that is, sets with a binary operation and a unit element."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MonadWithUnit|
  (progn
    (push '|MonadWithUnit| *Categories*)
    (make-instance '|MonadWithUnitType|)))

\end{chunk}

\subsection{Monoid}
\index[cat]{Monoid!Category}
\index[cat]{Category!Monoid}
\index[cat]{MONOID}
\begin{chunk}{defclass MonoidType}
(defclass |MonoidType| (|SemiGroupType|)
  ((parents :initform '(|SemiGroup|))
   (name :initform "Monoid")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'MONOID)
   (comment :initform (list
     "The class of multiplicative monoids, that is, semigroups with a"
     "multiplicative identity element."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Monoid|
  (progn
    (push '|Monoid| *Categories*)
    (make-instance '|MonoidType|)))

\end{chunk}

\subsection{OrderedAbelianSemiGroup}
\index[cat]{OrderedAbelianSemiGroup!Category}
\index[cat]{Category!OrderedAbelianSemiGroup}
\index[cat]{OASGP}
\begin{chunk}{defclass |OrderedAbelianSemiGroupType}
(defclass |OrderedAbelianSemiGroupType| (|AbelianSemiGroupType| |OrderedSetType|)
  ((parents :initform '(|AbelianSemiGroup| |OrderedSet|))
   (name :initform "OrderedAbelianSemiGroup")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'OASGP)
   (comment :initform (list
     "Ordered sets which are also abelian semigroups, such that the addition"
     "preserves the ordering."
     " "
     "Axiom x < y => x+z < y+z"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderedAbelianSemiGroup|
  (progn
    (push '|OrderedAbelianSemiGroup| *Categories*)
    (make-instance '|OrderedAbelianSemiGroupType|)))

\end{chunk}

\subsection{OrderedFinite}
\index[cat]{OrderedFinite!Category}
\index[cat]{Category!OrderedFinite}
\index[cat]{ORDFIN}
\begin{chunk}{defclass OrderedFiniteType}
(defclass |OrderedFiniteType| (|OrderedSetType| |FiniteType|)
  ((parents :initform '(|OrderedSet| |Finite|))
   (name :initform "OrderedFinite")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'ORDFIN)
   (comment :initform (list
     "Ordered finite sets."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderedFinite|
  (progn
    (push '|OrderedFinite| *Categories*)
    (make-instance '|OrderedFiniteType|)))

\end{chunk}

\subsection{PlacesCategory}
\index[cat]{PlacesCategory!Category}
\index[cat]{Category!PlacesCategory}
\index[cat]{PLACESC}
\begin{chunk}{defclass PlacesCategoryType}
(defclass |PlacesCategoryType| (|SetCategoryWithDegreeType|)
  ((parents :initform '(|SetCategoryWithDegree|))
   (name :initform "PlacesCategory")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'PLACESC)
   (comment :initform (list
     "This is part of the PAFF package, related to projective space."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PlacesCategory|
  (progn
    (push '|PlacesCategory| *Categories*)
    (make-instance '|PlacesCategoryType|)))

\end{chunk}

\subsection{ProjectiveSpaceCategory}
\index[cat]{ProjectiveSpaceCategory!Category}
\index[cat]{Category!ProjectiveSpaceCategory}
\index[cat]{PRSPCAT}
\begin{chunk}{defclass ProjectiveSpaceCategoryType}
(defclass |ProjectiveSpaceCategoryType| (|SetCategoryWithDegreeType|)
  ((parents :initform '(|SetCategoryWithDegree|))
   (name :initform "ProjectiveSpaceCategory")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'PRSPCAT)
   (comment :initform (list
     "This is part of the PAFF package, related to projective space."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ProjectiveSpaceCategory|
  (progn
    (push '|ProjectiveSpaceCategory| *Categories*)
    (make-instance '|ProjectiveSpaceCategoryType|)))

\end{chunk}

\subsection{RecursiveAggregate}
\index[cat]{RecursiveAggregate!Category}
\index[cat]{Category!RecursiveAggregate}
\index[cat]{RCAGG}
\begin{chunk}{defclass RecursiveAggregateType}
(defclass |RecursiveAggregateType| (|HomogeneousAggregateType|)
  ((parents :initform '(|HomogeneousAggregate|))
   (name :initform "RecursiveAggregate")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'RCAGG)
   (comment :initform (list
     "A recursive aggregate over a type S is a model for a"
     "a directed graph containing values of type S."
     "Recursively, a recursive aggregate is a node"
     "consisting of a value from S and 0 or more children"
     "which are recursive aggregates."
     "A node with no children is called a leaf node."
     "A recursive aggregate may be cyclic for which some operations as noted"
     "may go into an infinite loop."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RecursiveAggregate|
  (progn
    (push '|RecursiveAggregate| *Categories*)
    (make-instance '|RecursiveAggregateType|)))

\end{chunk}

\subsection{TwoDimensionalArrayCategory}
\index[cat]{TwoDimensionalArrayCategory!Category}
\index[cat]{Category!TwoDimensionalArrayCategory}
\index[cat]{ARR2CAT}
\begin{chunk}{defclass TwoDimensionalArrayCategoryType}
(defclass |TwoDimensionalArrayCategoryType| (|HomogeneousAggregateType|)
  ((parents :initform '(|HomogeneousAggregate|))
   (name :initform "TwoDimensionalArrayCategory")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'ARR2CAT)
   (comment :initform (list
     "Two dimensional array categories and domains"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TwoDimensionalArrayCategory|
  (progn
    (push '|TwoDimensionalArrayCategory| *Categories*)
    (make-instance '|TwoDimensionalArrayCategoryType|)))

\end{chunk}

\section{Level 5}

\begin{chunk}{defvar level5}
(defvar level5 
 '(|BinaryRecursiveAggregate| |CancellationAbelianMonoid| |DesingTreeCategory|
   |DoublyLinkedAggregate| |Group| |LinearAggregate| |MatrixCategory|
   |OrderedAbelianMonoid| |OrderedMonoid| |PolynomialSetCategory|
   |PriorityQueueAggregate| |QueueAggregate| |SetAggregate| |StackAggregate|
   |UnaryRecursiveAggregate|))

\end{chunk}

\subsection{BinaryRecursiveAggregate}
\index[cat]{BinaryRecursiveAggregate!Category}
\index[cat]{Category!BinaryRecursiveAggregate}
\index[cat]{BRAGG}
\begin{chunk}{defclass BinaryRecursiveAggregateType}
(defclass |BinaryRecursiveAggregateType| (|RecursiveAggregateType|)
  ((parents :initform '(|RecursiveAggregate|))
   (name :initform "BinaryRecursiveAggregate")
   (marker :initform 'category)
   (level :initform 5)
   (abbreviation :initform 'BRAGG)
   (comment :initform (list
     "A binary-recursive aggregate has 0, 1 or 2 children and serves"
     "as a model for a binary tree or a doubly-linked aggregate structure"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BinaryRecursiveAggregate|
  (progn
    (push '|BinaryRecursiveAggregate| *Categories*)
    (make-instance '|BinaryRecursiveAggregateType|)))

\end{chunk}

\subsection{CancellationAbelianMonoid}
\index[cat]{CancellationAbelianMonoid!Category}
\index[cat]{Category!CancellationAbelianMonoid}
\index[cat]{CABMON}
\begin{chunk}{defclass CancellationAbelianMonoidType}
(defclass |CancellationAbelianMonoidType| (|AbelianMonoidType|)
  ((parents :initform '(|AbelianMonoid|))
   (name :initform "CancellationAbelianMonoid")
   (marker :initform 'category)
   (level :initform 5)
   (abbreviation :initform 'CABMON)
   (comment :initform (list
     "This is an AbelianMonoid with the cancellation property,"
     "   a+b = a+c => b=c "
     "This is formalised by the partial subtraction operator,"
     "which satisfies the  Axioms"
     "   c = a+b <=> c-b = a"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CancellationAbelianMonoid|
  (progn
    (push '|CancellationAbelianMonoid| *Categories*)
    (make-instance '|CancellationAbelianMonoidType|)))

\end{chunk}

\subsection{DesingTreeCategory}
\index[cat]{DesingTreeCategory!Category}
\index[cat]{Category!DesingTreeCategory}
\index[cat]{DSTRCAT}
\begin{chunk}{defclass DesingTreeCategoryType}
(defclass |DesingTreeCategoryType| (|RecursiveAggregateType|)
  ((parents :initform '(|RecursiveAggregate|))
   (name :initform "DesingTreeCategory")
   (marker :initform 'category)
   (level :initform 5)
   (abbreviation :initform 'DSTRCAT)
   (comment :initform (list
     "This category is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DesingTreeCategory|
  (progn
    (push '|DesingTreeCategory| *Categories*)
    (make-instance '|DesingTreeCategoryType|)))

\end{chunk}

\subsection{DoublyLinkedAggregate}
\index[cat]{DoublyLinkedAggregate!Category}
\index[cat]{Category!DoublyLinkedAggregate}
\index[cat]{DLAGG}
\begin{chunk}{defclass DoublyLinkedAggregateType}
(defclass |DoublyLinkedAggregateType| (|RecursiveAggregateType|)
  ((parents :initform '(|RecursiveAggregate|))
   (name :initform "DoublyLinkedAggregate")
   (marker :initform 'category)
   (level :initform 5)
   (abbreviation :initform 'DLAGG)
   (comment :initform (list
     "A doubly-linked aggregate serves as a model for a doubly-linked"
     "list, that is, a list which can has links to both next and previous"
     "nodes and thus can be efficiently traversed in both directions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DoublyLinkedAggregate|
  (progn
    (push '|DoublyLinkedAggregate| *Categories*)
    (make-instance '|DoublyLinkedAggregateType|)))

\end{chunk}

\subsection{Group}
\index[cat]{Group!Category}
\index[cat]{Category!Group}
\index[cat]{GROUP}
Voevodsky's \cite{Gray18a} definition of a group:

Let $U$ be a {\sl universe}

A {\sl group} in $U$ is a sequence
${(G,e,i,m,\lambda,\rho,\lambda^\prime,\rho^\prime,\alpha,\iota)}$,
where
\begin{itemize}
\item $G$ is a type of $U$
\item $e:G$
\item $i:G\rightarrow G$
\item $m:G\times G\rightarrow G$
\item $\lambda$ is a proof that for every $a:G, m(e,a)=a$
\item $\rho$ is a proof that for every $a:G, m(a,e)=a$
\item $\lambda^\prime$ is a proof that for every $a:G, m(i(a),a)=e$
\item $\rho^\prime$ is a proof that for every $a:G, m(a,i(a))=e$
\item $\alpha$ is a proof that for every 
$a,b,c:G:m(m(a,b),c)=m(a,m(b,c))$
\item $\iota$ is a proof that $G$ is a set
\end{itemize}

\begin{chunk}{defclass GroupType}
(defclass |GroupType| (|MonoidType|)
  ((parents :initform '(|Monoid|))
   (name :initform "Group")
   (marker :initform 'category)
   (level :initform 5)
   (abbreviation :initform 'GROUP)
   (comment :initform (list
     "The class of multiplicative groups, that is, monoids with"
     "multiplicative inverses."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Group|
  (progn
    (push '|Group| *Categories*)
    (make-instance '|GroupType|)))

\end{chunk}

\subsection{LinearAggregate}
\index[cat]{LinearAggregate!Category}
\index[cat]{Category!LinearAggregate}
\index[cat]{LNAGG}
\begin{chunk}{defclass LinearAggregateType}
(defclass |LinearAggregateType| (|CollectionType| |IndexedAggregateType|)
  ((parents :initform '(|Collection| |IndexedAggregate|))
   (name :initform "LinearAggregate")
   (marker :initform 'category)
   (level :initform 5)
   (abbreviation :initform 'LNAGG)
   (comment :initform (list
     "A linear aggregate is an aggregate whose elements are indexed by integers."
     "Examples of linear aggregates are strings, lists, and"
     "arrays."
     "Most of the exported operations for linear aggregates are non-destructive"
     "but are not always efficient for a particular aggregate."
     "For example, concat of two lists needs only to copy its first"
     "argument, whereas concat of two arrays needs to copy both"
     "arguments. Most of the operations exported here apply to infinite"
     "objects (for example, streams) as well to finite ones."
     "For finite linear aggregates, see FiniteLinearAggregate."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LinearAggregate|
  (progn
    (push '|LinearAggregate| *Categories*)
    (make-instance '|LinearAggregateType|)))

\end{chunk}

\subsection{MatrixCategory}
\index[cat]{MatrixCategory!Category}
\index[cat]{Category!MatrixCategory}
\index[cat]{MATCAT}
\begin{chunk}{defclass MatrixCategoryType}
(defclass |MatrixCategoryType| (|TwoDimensionalArrayCategoryType|)
  ((parents :initform '(|TwoDimensionalArrayCategory|))
   (name :initform "MatrixCategory")
   (marker :initform 'category)
   (level :initform 5)
   (abbreviation :initform 'MATCAT)
   (comment :initform (list
     "MatrixCategory is a general matrix category which allows"
     "different representations and indexing schemes.  Rows and"
     "columns may be extracted with rows returned as objects of"
     "type Row and colums returned as objects of type Col."
     "A domain belonging to this category will be shallowly mutable."
     "The index of the 'first' row may be obtained by calling the"
     "function minRowIndex.  The index of the 'first' column may"
     "be obtained by calling the function minColIndex.  The index of"
     "the first element of a Row is the same as the index of the"
     "first column in a matrix and vice versa."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MatrixCategory|
  (progn
    (push '|MatrixCategory| *Categories*)
    (make-instance '|MatrixCategoryType|)))

\end{chunk}

\subsection{OrderedAbelianMonoid}
\index[cat]{OrderedAbelianMonoid!Category}
\index[cat]{Category!OrderedAbelianMonoid}
\index[cat]{OAMON}
\begin{chunk}{defclass OrderedAbelianMonoidType}
(defclass |OrderedAbelianMonoidType| (|AbelianMonoidType| |OrderedAbelianSemiGroupType|)
  ((parents :initform '(|AbelianMonoid| |OrderedAbelianSemiGroup|))
   (name :initform "OrderedAbelianMonoid")
   (marker :initform 'category)
   (level :initform 5)
   (abbreviation :initform 'OAMON)
   (comment :initform (list
     "Ordered sets which are also abelian monoids, such that the addition"
     "preserves the ordering."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderedAbelianMonoid|
  (progn
    (push '|OrderedAbelianMonoid| *Categories*)
    (make-instance '|OrderedAbelianMonoidType|)))

\end{chunk}

\subsection{OrderedMonoid}
\index[cat]{OrderedMonoid!Category}
\index[cat]{Category!OrderedMonoid}
\index[cat]{ORDMON}
\begin{chunk}{defclass OrderedMonoidType}
(defclass |OrderedMonoidType| (|OrderedSetType| |MonoidType|)
  ((parents :initform '(|OrderedSet| |Monoid|))
   (name :initform "OrderedMonoid")
   (marker :initform 'category)
   (level :initform 5)
   (abbreviation :initform 'ORDMON)
   (comment :initform (list
     "Ordered sets which are also monoids, such that multiplication"
     "preserves the ordering."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderedMonoid|
  (progn
    (push '|OrderedMonoid| *Categories*)
    (make-instance '|OrderedMonoidType|)))

\end{chunk}

\subsection{PolynomialSetCategory}
\index[cat]{PolynomialSetCategory!Category}
\index[cat]{Category!PolynomialSetCategory}
\index[cat]{PSETCAT}
\begin{chunk}{defclass PolynomialSetCategoryType}
(defclass |PolynomialSetCategoryType| (|CollectionType|)
  ((parents :initform '(|Collection|))
   (name :initform "PolynomialSetCategory")
   (marker :initform 'category)
   (level :initform 5)
   (abbreviation :initform 'PSETCAT)
   (comment :initform (list
     "A category for finite subsets of a polynomial ring."
     "Such a set is only regarded as a set of polynomials and not"
     "identified to the ideal it generates. So two distinct sets may"
     "generate the same the ideal. Furthermore, for R being an"
     "integral domain, a set of polynomials may be viewed as a representation"
     "of the ideal it generates in the polynomial ring R)^(-1) P,"
     "or the set of its zeros (described for instance by the radical of the"
     "previous ideal, or a split of the associated affine variety) and so on."
     "So this category provides operations about those different notions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialSetCategory|
  (progn
    (push '|PolynomialSetCategory| *Categories*)
    (make-instance '|PolynomialSetCategoryType|)))

\end{chunk}

\subsection{PriorityQueueAggregate}
\index[cat]{PriorityQueueAggregate!Category}
\index[cat]{Category!PriorityQueueAggregate}
\index[cat]{PRQAGG}
\begin{chunk}{defclass PriorityQueueAggregateType}
(defclass |PriorityQueueAggregateType| (|BagAggregateType|)
  ((parents :initform '(|BagAggregate|))
   (name :initform "PriorityQueueAggregate")
   (marker :initform 'category)
   (level :initform 5)
   (abbreviation :initform 'PRQAGG)
   (comment :initform (list
     "A priority queue is a bag of items from an ordered set where the item"
     "extracted is always the maximum element."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PriorityQueueAggregate|
  (progn
    (push '|PriorityQueueAggregate| *Categories*)
    (make-instance '|PriorityQueueAggregateType|)))

\end{chunk}

\subsection{QueueAggregate}
\index[cat]{QueueAggregate!Category}
\index[cat]{Category!QueueAggregate}
\index[cat]{QUAGG}
\begin{chunk}{defclass QueueAggregateType}
(defclass |QueueAggregateType| (|BagAggregateType|)
  ((parents :initform '(|BagAggregate|))
   (name :initform "QueueAggregate")
   (marker :initform 'category)
   (level :initform 5)
   (abbreviation :initform 'QUAGG)
   (comment :initform (list
     "A queue is a bag where the first item inserted is the first"
     "item extracted."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |QueueAggregate|
  (progn
    (push '|QueueAggregate| *Categories*)
    (make-instance '|QueueAggregateType|)))

\end{chunk}

\subsection{SetAggregate}
\index[cat]{SetAggregate!Category}
\index[cat]{Category!SetAggregate}
\index[cat]{SETAGG}
\begin{chunk}{defclass SetAggregateType}
(defclass |SetAggregateType| (|CollectionType|)
  ((parents :initform '(|Collection|))
   (name :initform "SetAggregate")
   (marker :initform 'category)
   (level :initform 5)
   (abbreviation :initform 'SETAGG)
   (comment :initform (list
     "A set category lists a collection of set-theoretic operations"
     "useful for both finite sets and multisets."
     "Note however that finite sets are distinct from multisets."
     "Although the operations defined for set categories are"
     "common to both, the relationship between the two cannot"
     "be described by inclusion or inheritance."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SetAggregate|
  (progn
    (push '|SetAggregate| *Categories*)
    (make-instance '|SetAggregateType|)))

\end{chunk}

\subsection{StackAggregate}
\index[cat]{StackAggregate!Category}
\index[cat]{Category!StackAggregate}
\index[cat]{SKAGG}
\begin{chunk}{defclass StackAggregateType}
(defclass |StackAggregateType| (|BagAggregateType|)
  ((parents :initform '(|BagAggregate|))
   (name :initform "StackAggregate")
   (marker :initform 'category)
   (level :initform 5)
   (abbreviation :initform 'SKAGG)
   (comment :initform (list
     "A stack is a bag where the last item inserted is the first item extracted."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StackAggregate|
  (progn
    (push '|StackAggregate| *Categories*)
    (make-instance '|StackAggregateType|)))

\end{chunk}

\subsection{UnaryRecursiveAggregate}
\index[cat]{UnaryRecursiveAggregate!Category}
\index[cat]{Category!UnaryRecursiveAggregate}
\index[cat]{URAGG}
\begin{chunk}{defclass UnaryRecursiveAggregateType}
(defclass |UnaryRecursiveAggregateType| (|RecursiveAggregateType|)
  ((parents :initform '(|RecursiveAggregate|))
   (name :initform "UnaryRecursiveAggregate")
   (marker :initform 'category)
   (level :initform 5)
   (abbreviation :initform 'URAGG)
   (comment :initform (list
     "A unary-recursive aggregate is a one where nodes may have either"
     "0 or 1 children."
     "This aggregate models, though not precisely, a linked"
     "list possibly with a single cycle."
     "A node with one children models a non-empty list, with the"
     "value of the list designating the head, or first,"
     "of the list, and the child designating the tail, or rest,"
     "of the list. A node with no child then designates the empty list."
     "Since these aggregates are recursive aggregates, they may be cyclic."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnaryRecursiveAggregate|
  (progn
    (push '|UnaryRecursiveAggregate| *Categories*)
    (make-instance '|UnaryRecursiveAggregateType|)))

\end{chunk}

\section{Level 6}

\begin{chunk}{defvar level6}
(defvar level6
 '(|AbelianGroup| |BinaryTreeCategory| |DequeueAggregate| |DictionaryOperations|
   |ExtensibleLinearAggregate| |FiniteLinearAggregate|
   |FreeAbelianMonoidCategory| 
   |OrderedCancellationAbelianMonoid| |PermutationCategory| |StreamAggregate|
   |TriangularSetCategory|))

\end{chunk}

\subsection{AbelianGroup}
\index[cat]{AbelianGroup!Category}
\index[cat]{Category!AbelianGroup}
\index[cat]{ABELGRP}
\begin{chunk}{defclass AbelianGroupType}
(defclass |AbelianGroupType| (|CancellationAbelianMonoidType|)
  ((parents :initform '(|CancellationAbelianMonoid|))
   (name :initform "AbelianGroup")
   (marker :initform 'category)
   (level :initform 6)
   (abbreviation :initform 'ABELGRP)
   (comment :initform (list
     "The class of abelian groups, additive monoids where"
     "each element has an additive inverse."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AbelianGroup|
  (progn
    (push '|AbelianGroup| *Categories*)
    (make-instance '|AbelianGroupType|)))

\end{chunk}

\subsection{BinaryTreeCategory}
\index[cat]{BinaryTreeCategory!Category}
\index[cat]{Category!BinaryTreeCategory}
\index[cat]{BTCAT}
\begin{chunk}{defclass BinaryTreeCategoryType}
(defclass |BinaryTreeCategoryType| (|BinaryRecursiveAggregateType|)
  ((parents :initform '(|BinaryRecursiveAggregate|))
   (name :initform "BinaryTreeCategory")
   (marker :initform 'category)
   (level :initform 6)
   (abbreviation :initform 'BTCAT)
   (comment :initform (list
     "BinaryTreeCategory(S) is the category of"
     "binary trees: a tree which is either empty or else is a"
     "node consisting of a value and a left and"
     "right, both binary trees. "))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BinaryTreeCategory|
  (progn
    (push '|BinaryTreeCategory| *Categories*)
    (make-instance '|BinaryTreeCategoryType|)))

\end{chunk}

\subsection{DequeueAggregate}
\index[cat]{DequeueAggregate!Category}
\index[cat]{Category!DequeueAggregate}
\index[cat]{DQAGG}
\begin{chunk}{defclass DequeueAggregateType}
(defclass |DequeueAggregateType| (|QueueAggregateType| |StackAggregateType|)
  ((parents :initform '(|QueueAggregate| |StackAggregate|))
   (name :initform "DequeueAggregate")
   (marker :initform 'category)
   (level :initform 6)
   (abbreviation :initform 'DQAGG)
   (comment :initform (list
     "A dequeue is a doubly ended stack, that is, a bag where first items"
     "inserted are the first items extracted, at either the front or"
     "the back end of the data structure."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DequeueAggregate|
  (progn
    (push '|DequeueAggregate| *Categories*)
    (make-instance '|DequeueAggregateType|)))

\end{chunk}

\subsection{DictionaryOperations}
\index[cat]{DictionaryOperations!Category}
\index[cat]{Category!DictionaryOperations}
\index[cat]{DIOPS}
\begin{chunk}{defclass DictionaryOperationsType}
(defclass |DictionaryOperationsType| (|BagAggregateType| |CollectionType|)
  ((parents :initform '(|BagAggregate| |Collection|))
   (name :initform "DictionaryOperations")
   (marker :initform 'category)
   (level :initform 6)
   (abbreviation :initform 'DIOPS)
   (comment :initform (list
     "This category is a collection of operations common to both"
     "categories Dictionary and MultiDictionary"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DictionaryOperations|
  (progn
    (push '|DictionaryOperations| *Categories*)
    (make-instance '|DictionaryOperationsType|)))

\end{chunk}

\subsection{ExtensibleLinearAggregate}
\index[cat]{ExtensibleLinearAggregate!Category}
\index[cat]{Category!ExtensibleLinearAggregate}
\index[cat]{ELAGG}
\begin{chunk}{defclass ExtensibleLinearAggregateType}
(defclass |ExtensibleLinearAggregateType| (|LinearAggregateType|)
  ((parents :initform '(|LinearAggregate|))
   (name :initform "ExtensibleLinearAggregate")
   (marker :initform 'category)
   (level :initform 6)
   (abbreviation :initform 'ELAGG)
   (comment :initform (list
     "An extensible aggregate is one which allows insertion and deletion of"
     "entries. These aggregates are models of lists and streams which are"
     "represented by linked structures so as to make insertion, deletion, and"
     "concatenation efficient. However, access to elements of these"
     "extensible aggregates is generally slow since access is made from the end."
     "See FlexibleArray for an exception."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExtensibleLinearAggregate|
  (progn
    (push '|ExtensibleLinearAggregate| *Categories*)
    (make-instance '|ExtensibleLinearAggregateType|)))

\end{chunk}

\subsection{FiniteLinearAggregate}
\index[cat]{FiniteLinearAggregate!Category}
\index[cat]{Category!FiniteLinearAggregate}
\index[cat]{FLAGG}
\begin{chunk}{defclass FiniteLinearAggregateType}
(defclass |FiniteLinearAggregateType| (|OrderedSetType| |LinearAggregateType|)
  ((parents :initform '(|OrderedSet| |LinearAggregate|))
   (name :initform "FiniteLinearAggregate")
   (marker :initform 'category)
   (level :initform 6)
   (abbreviation :initform 'FLAGG)
   (comment :initform (list
     "A finite linear aggregate is a linear aggregate of finite length."
     "The finite property of the aggregate adds several exports to the"
     "list of exports from LinearAggregate such as"
     "reverse, sort, and so on."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteLinearAggregate|
  (progn
    (push '|FiniteLinearAggregate| *Categories*)
    (make-instance '|FiniteLinearAggregateType|)))

\end{chunk}

\subsection{FreeAbelianMonoidCategory}
\index[cat]{FreeAbelianMonoidCategory!Category}
\index[cat]{Category!FreeAbelianMonoidCategory}
\index[cat]{FAMONC}
\begin{chunk}{defclass FreeAbelianMonoidCategoryType}
(defclass |FreeAbelianMonoidCategoryType| (|RetractableToType| |CancellationAbelianMonoidType|)
  ((parents :initform '(|RetractableTo| |CancellationAbelianMonoid|))
   (name :initform "FreeAbelianMonoidCategory")
   (marker :initform 'category)
   (level :initform 6)
   (abbreviation :initform 'FAMONC)
   (comment :initform (list
     "A free abelian monoid on a set S is the monoid of finite sums of"
     "the form reduce(+,[ni * si]) where the si's are in S, and the ni's"
     "are in a given abelian monoid. The operation is commutative."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FreeAbelianMonoidCategory|
  (progn
    (push '|FreeAbelianMonoidCategory| *Categories*)
    (make-instance '|FreeAbelianMonoidCategoryType|)))

\end{chunk}

\subsection{OrderedCancellationAbelianMonoid}
\index[cat]{OrderedCancellationAbelianMonoid!Category}
\index[cat]{Category!OrderedCancellationAbelianMonoid}
\index[cat]{OCAMON}
\begin{chunk}{defclass OrderedCancellationAbelianMonoidType}
(defclass |OrderedCancellationAbelianMonoidType| (|CancellationAbelianMonoidType|
                                                  |OrderedAbelianMonoidType|)
  ((parents :initform '(|CancellationAbelianMonoid|
                        |OrderedAbelianMonoid|))
   (name :initform "OrderedCancellationAbelianMonoid")
   (marker :initform 'category)
   (level :initform 6)
   (abbreviation :initform 'OCAMON)
   (comment :initform (list
     "Ordered sets which are also abelian cancellation monoids,"
     "such that the addition preserves the ordering."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderedCancellationAbelianMonoid|
  (progn
    (push '|OrderedCancellationAbelianMonoid| *Categories*)
    (make-instance '|OrderedCancellationAbelianMonoidType|)))

\end{chunk}

\subsection{PermutationCategory}
\index[cat]{PermutationCategory!Category}
\index[cat]{Category!PermutationCategory}
\index[cat]{PERMCAT}
\begin{chunk}{defclass PermutationCategoryType}
(defclass |PermutationCategoryType| (|OrderedSetType| |GroupType|)
  ((parents :initform '(|OrderedSet| |Group|))
   (name :initform "PermutationCategory")
   (marker :initform 'category)
   (level :initform 6)
   (abbreviation :initform 'PERMCAT)
   (comment :initform (list
     "PermutationCategory provides a categorial environment"
     "for subgroups of bijections of a set (that is, permutations)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PermutationCategory|
  (progn
    (push '|PermutationCategory| *Categories*)
    (make-instance '|PermutationCategoryType|)))

\end{chunk}

\subsection{StreamAggregate}
\index[cat]{StreamAggregate!Category}
\index[cat]{Category!StreamAggregate}
\index[cat]{STAGG}
\begin{chunk}{defclass StreamAggregateType}
(defclass |StreamAggregateType| (|LinearAggregateType| |UnaryRecursiveAggregateType|)
  ((parents :initform '(|LinearAggregate| |UnaryRecursiveAggregate|))
   (name :initform "StreamAggregate")
   (marker :initform 'category)
   (level :initform 6)
   (abbreviation :initform 'STAGG)
   (comment :initform (list
     "A stream aggregate is a linear aggregate which possibly has an infinite"
     "number of elements. A basic domain constructor which builds stream"
     "aggregates is Stream. From streams, a number of infinite"
     "structures such power series can be built. A stream aggregate may"
     "also be infinite since it may be cyclic."
     "For example, see DecimalExpansion."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StreamAggregate|
  (progn
    (push '|StreamAggregate| *Categories*)
    (make-instance '|StreamAggregateType|)))

\end{chunk}

\subsection{TriangularSetCategory}
\index[cat]{TriangularSetCategory!Category}
\index[cat]{Category!TriangularSetCategory}
\index[cat]{TSETCAT}
\begin{chunk}{defclass TriangularSetCategoryType}
(defclass |TriangularSetCategoryType| (|PolynomialSetCategoryType|)
  ((parents :initform '(|PolynomialSetCategory|))
   (name :initform "TriangularSetCategory")
   (marker :initform 'category)
   (level :initform 6)
   (abbreviation :initform 'TSETCAT)
   (comment :initform (list
     "The category of triangular sets of multivariate polynomials"
     "with coefficients in an integral domain."
     "Let R be an integral domain and V a finite ordered set of"
     "variables, say X1 < X2 < ... < Xn."
     "A set S of polynomials in R[X1,X2,...,Xn] is triangular"
     "if no elements of S lies in R, and if two distinct"
     "elements of S have distinct main variables."
     "Note that the empty set is a triangular set. A triangular set is not"
     "necessarily a (lexicographical) Groebner basis and the notion of"
     "reduction related to triangular sets is based on the recursive view"
     "of polynomials. We recall this notion here and refer to [1] for more"
     "details."
     "A polynomial P is reduced w.r.t a non-constant polynomial"
     "Q if the degree of P in the main variable of Q" 
     "is less than the main degree of Q."
     "A polynomial P is reduced w.r.t a triangular set T"
     "if it is reduced w.r.t. every polynomial of T."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TriangularSetCategory|
  (progn
    (push '|TriangularSetCategory| *Categories*)
    (make-instance '|TriangularSetCategoryType|)))

\end{chunk}

\section{Level 7}

\begin{chunk}{defvar level7}
(defvar level7
 '(|Dictionary| |FiniteDivisorCategory| |LazyStreamAggregate| |LeftModule|
   |ListAggregate| |MultiDictionary| |MultisetAggregate| |NonAssociativeRng|
   |OneDimensionalArrayAggregate| |OrderedAbelianGroup| |OrderedAbelianMonoidSup|
   |RegularTriangularSetCategory| |RightModule| |Rng|))

\end{chunk}

\subsection{Dictionary}
\index[cat]{Dictionary!Category}
\index[cat]{Category!Dictionary}
\index[cat]{DIAGG}
\begin{chunk}{defclass DictionaryType}
(defclass |DictionaryType| (|DictionaryOperationsType|)
  ((parents :initform '(|DictionaryOperations|))
   (name :initform "Dictionary")
   (marker :initform 'category)
   (level :initform 7)
   (abbreviation :initform 'DIAGG)
   (comment :initform (list
     "A dictionary is an aggregate in which entries can be inserted,"
     "searched for and removed. Duplicates are thrown away on insertion."
     "This category models the usual notion of dictionary which involves"
     "large amounts of data where copying is impractical."
     "Principal operations are thus destructive (non-copying) ones."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Dictionary|
  (progn
    (push '|Dictionary| *Categories*)
    (make-instance '|DictionaryType|)))

\end{chunk}

\subsection{FiniteDivisorCategory}
\index[cat]{FiniteDivisorCategory!Category}
\index[cat]{Category!FiniteDivisorCategory}
\index[cat]{FDIVCAT}
\begin{chunk}{defclass FiniteDivisorCategoryType}
(defclass |FiniteDivisorCategoryType| (|AbelianGroupType|)
  ((parents :initform '(|AbelianGroup|))
   (name :initform "FiniteDivisorCategory")
   (marker :initform 'category)
   (level :initform 7)
   (abbreviation :initform 'FDIVCAT)
   (comment :initform (list
     "This category describes finite rational divisors on a curve, that"
     "is finite formal sums SUM(n * P) where the n's are integers and the"
     "P's are finite rational points on the curve."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteDivisorCategory|
  (progn
    (push '|FiniteDivisorCategory| *Categories*)
    (make-instance '|FiniteDivisorCategoryType|)))

\end{chunk}

\subsection{LazyStreamAggregate}
\index[cat]{LazyStreamAggregate!Category}
\index[cat]{Category!LazyStreamAggregate}
\index[cat]{LZSTAGG}
\begin{chunk}{defclass LazyStreamAggregateType}
(defclass |LazyStreamAggregateType| (|StreamAggregateType|)
  ((parents :initform '(|StreamAggregate|))
   (name :initform "LazyStreamAggregate")
   (marker :initform 'category)
   (level :initform 7)
   (abbreviation :initform 'LZSTAGG)
   (comment :initform (list
     "LazyStreamAggregate is the category of streams with lazy"
     "evaluation.  It is understood that the function 'empty?' will"
     "cause lazy evaluation if necessary to determine if there are"
     "entries.  Functions which call 'empty?', for example 'first' and 'rest',"
     "will also cause lazy evaluation if necessary."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LazyStreamAggregate|
  (progn
    (push '|LazyStreamAggregate| *Categories*)
    (make-instance '|LazyStreamAggregateType|)))

\end{chunk}

\subsection{LeftModule}
\index[cat]{LeftModule!Category}
\index[cat]{Category!LeftModule}
\index[cat]{LMODULE}
\begin{chunk}{defclass LeftModuleType}
(defclass |LeftModuleType| (|AbelianGroupType|)
  ((parents :initform '(|AbelianGroup|))
   (name :initform "LeftModule")
   (marker :initform 'category)
   (level :initform 7)
   (abbreviation :initform 'LMODULE)
   (comment :initform (list
     "This is an abelian group which supports left multiplication by elements of"
     "the rng."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LeftModule|
  (progn
    (push '|LeftModule| *Categories*)
    (make-instance '|LeftModuleType|)))

\end{chunk}

\subsection{ListAggregate}
\index[cat]{ListAggregate!Category}
\index[cat]{Category!ListAggregate}
\index[cat]{LSAGG}
\begin{chunk}{defclass ListAggregateType}
(defclass |ListAggregateType| (|ExtensibleLinearAggregateType|
                               |FiniteLinearAggregateType|
                               |StreamAggregateType|)
  ((parents :initform '(|ExtensibleLinearAggregate| 
                          |FiniteLinearAggregate| 
                          |StreamAggregate|))
   (name :initform "ListAggregate")
   (marker :initform 'category)
   (level :initform 7)
   (abbreviation :initform 'LSAGG)
   (comment :initform (list
     "A list aggregate is a model for a linked list data structure."
     "A linked list is a versatile"
     "data structure. Insertion and deletion are efficient and"
     "searching is a linear operation."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ListAggregate|
  (progn
    (push '|ListAggregate| *Categories*)
    (make-instance '|ListAggregateType|)))

\end{chunk}

\subsection{MultiDictionary}
\index[cat]{MultiDictionary!Category}
\index[cat]{Category!MultiDictionary}
\index[cat]{MDAGG}
\begin{chunk}{defclass MultiDictionaryType}
(defclass |MultiDictionaryType| (|DictionaryOperationsType|)
  ((parents :initform '(|DictionaryOperations|))
   (name :initform "MultiDictionary")
   (marker :initform 'category)
   (level :initform 7)
   (abbreviation :initform 'MDAGG)
   (comment :initform (list
     "A multi-dictionary is a dictionary which may contain duplicates."
     "As for any dictionary, its size is assumed large so that"
     "copying (non-destructive) operations are generally to be avoided."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MultiDictionary|
  (progn
    (push '|MultiDictionary| *Categories*)
    (make-instance '|MultiDictionaryType|)))

\end{chunk}

\subsection{MultisetAggregate}
\index[cat]{MultisetAggregate!Category}
\index[cat]{Category!MultisetAggregate}
\index[cat]{MSETAGG}
\begin{chunk}{defclass MultisetAggregateType}
(defclass |MultisetAggregateType| (|SetAggregateType| |MultiDictionaryType|)
  ((parents :initform '(|SetAggregate| |MultiDictionary|))
   (name :initform "MultisetAggregate")
   (marker :initform 'category)
   (level :initform 7)
   (abbreviation :initform 'MSETAGG)
   (comment :initform (list
     "A multi-set aggregate is a set which keeps track of the multiplicity"
     "of its elements."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MultisetAggregate|
  (progn
    (push '|MultisetAggregate| *Categories*)
    (make-instance '|MultisetAggregateType|)))

\end{chunk}

\subsection{NonAssociativeRng}
\index[cat]{NonAssociativeRng!Category}
\index[cat]{Category!NonAssociativeRng}
\index[cat]{NARNG}
\begin{chunk}{defclass NonAssociativeRngType}
(defclass |NonAssociativeRngType| (|MonadType| |AbelianGroupType|)
  ((parents :initform '(|Monad| |AbelianGroup|))
   (name :initform "NonAssociativeRng")
   (marker :initform 'category)
   (level :initform 7)
   (abbreviation :initform 'NARGN)
   (comment :initform (list
     "NonAssociativeRng is a basic ring-type structure, not necessarily"
     "commutative or associative, and not necessarily with unit."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NonAssociativeRng|
  (progn
    (push '|NonAssociativeRng| *Categories*)
    (make-instance '|NonAssociativeRngType|)))

\end{chunk}

\subsection{OneDimensionalArrayAggregate}
\index[cat]{OneDimensionalArrayAggregate!Category}
\index[cat]{Category!OneDimensionalArrayAggregate}
\index[cat]{A1AGG}
\begin{chunk}{defclass OneDimensionalArrayAggregateType}
(defclass |OneDimensionalArrayAggregateType| (|FiniteLinearAggregateType|)
  ((parents  :initform '(|FiniteLinearAggregate|))
   (name :initform "OneDimensionalArrayAggregate")
   (marker :initform 'category)
   (level :initform 7)
   (abbreviation :initform 'A1AGG)
   (comment :initform (list
     "One-dimensional-array aggregates serves as models for one-dimensional"
     "arrays. Categorically, these aggregates are finite linear aggregates"
     "with the shallowlyMutable property, that is, any component of"
     "the array may be changed without affecting the"
     "identity of the overall array."
     "Array data structures are typically represented by a fixed area in"
     "storage and cannot efficiently grow or shrink on demand as can list"
     "structures (see however FlexibleArray for a data structure"
     "which is a cross between a list and an array)."
     "Iteration over, and access to, elements of arrays is extremely fast"
     "(and often can be optimized to open-code)."
     "Insertion and deletion however is generally slow since an entirely new"
     "data structure must be created for the result."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OneDimensionalArrayAggregate|
  (progn
    (push '|OneDimensionalArrayAggregate| *Categories*)
    (make-instance '|OneDimensionalArrayAggregateType|)))

\end{chunk}

\subsection{OrderedAbelianGroup}
\index[cat]{OrderedAbelianGroup!Category}
\index[cat]{Category!OrderedAbelianGroup}
\index[cat]{OAGROUP}
\begin{chunk}{defclass OrderedAbelianGroupType}
(defclass |OrderedAbelianGroupType| (|AbelianGroupType| |OrderedCancellationAbelianMonoidType|)
  ((parents :initform '(|AbelianGroup| |OrderedCancellationAbelianMonoid|))
   (name :initform "OrderedAbelianGroup")
   (marker :initform 'category)
   (level :initform 7)
   (abbreviation :initform 'OAGROUP)
   (comment :initform (list
     "Ordered sets which are also abelian groups, such that the"
     "addition preserves the ordering."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderedAbelianGroup|
  (progn
    (push '|OrderedAbelianGroup| *Categories*)
    (make-instance '|OrderedAbelianGroupType|)))

\end{chunk}

\subsection{OrderedAbelianMonoidSup}
\index[cat]{OrderedAbelianMonoidSup!Category}
\index[cat]{Category!OrderedAbelianMonoidSup}
\index[cat]{OAMONS}
\begin{chunk}{defclass OrderedAbelianMonoidSupType}
(defclass |OrderedAbelianMonoidSupType| (|OrderedCancellationAbelianMonoidType|)
  ((parents  :initform '(|OrderedCancellationAbelianMonoid|))
   (name :initform "OrderedAbelianMonoidSup")
   (marker :initform 'category)
   (level :initform 7)
   (abbreviation :initform 'OAMONS)
   (comment :initform (list
     "This domain is an OrderedAbelianMonoid with a sup"
     "operation added. The purpose of the sup operator"
     "in this domain is to act as a supremum with respect to the"
     "partial order imposed by `-`, rather than with respect to"
     "the total > order (since that is 'max')."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderedAbelianMonoidSup|
  (progn
    (push '|OrderedAbelianMonoidSup| *Categories*)
    (make-instance '|OrderedAbelianMonoidSupType|)))

\end{chunk}

\subsection{RegularTriangularSetCategory}
\index[cat]{RegularTriangularSetCategory!Category}
\index[cat]{Category!RegularTriangularSetCategory}
\index[cat]{RSETCAT}
\begin{chunk}{defclass RegularTriangularSetCategoryType}
(defclass |RegularTriangularSetCategoryType| (|TriangularSetCategoryType|)
  ((parents :initform '(|TriangularSetCategory|))
   (name :initform "RegularTriangularSetCategory")
   (marker :initform 'category)
   (level :initform 7)
   (abbreviation :initform 'RSETCAT)
   (comment :initform (list
     "The category of regular triangular sets, introduced under"
     "the name regular chains in [1] (and other papers)."
     "In [3] it is proved that regular triangular sets and towers of simple"
     "extensions of a field are equivalent notions."
     "In the following definitions, all polynomials and ideals"
     "are taken from the polynomial ring k[x1,...,xn] where k"
     "is the fraction field of R."
     "The triangular set [t1,...,tm] is regular"
     "iff for every id} the initial of ti+1 is invertible"
     "in the tower of simple extensions associated with [t1,...,ti]."
     "A family [T1,...,Ts] of regular triangular sets"
     "is a split of Kalkbrener of a given ideal I"
     "iff the radical of I is equal to the intersection"
     "of the radical ideals generated by the saturated ideals"
     "of the [T1,...,Ti]."
     "A family [T1,...,Ts] of regular triangular sets"
     "is a split of Kalkbrener of a given triangular set T"
     "iff it is a split of Kalkbrener of the saturated ideal of T."
     "Let K be an algebraic closure of k."
     "Assume that V is finite with cardinality"
     "n and let A be the affine space K^n."
     "For a regular triangular set T let denote by W(T) the"
     "set of regular zeros of T."
     "A family [T1,...,Ts] of regular triangular sets"
     "is a split of Lazard of a given subset S of A"
     "iff the union of the W(Ti) contains S and"
     "is contained in the closure of S (w.r.t. Zariski topology)."
     "A family [T1,...,Ts] of regular triangular sets"
     "is a split of Lazard of a given triangular set T"
     "if it is a split of Lazard of W(T)."
     "Note that if [T1,...,Ts] is a split of Lazard of"
     "T then it is also a split of Kalkbrener of T."
     "The converse is false."
     "This category provides operations related to both kinds of"
     "splits, the former being related to ideals decomposition whereas"
     "the latter deals with varieties decomposition."
     "See the example illustrating the RegularTriangularSet constructor for more"
     "explanations about decompositions by means of regular triangular sets."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RegularTriangularSetCategory|
  (progn
    (push '|RegularTriangularSetCategory| *Categories*)
    (make-instance '|RegularTriangularSetCategoryType|)))

\end{chunk}

\subsection{RightModule}
\index[cat]{RightModule!Category}
\index[cat]{Category!RightModule}
\index[cat]{RMODULE}
\begin{chunk}{defclass RightModuleType}
(defclass |RightModuleType| (|AbelianGroupType|)
  ((parents :initform '(|AbelianGroup|))
   (name :initform "RightModule")
   (marker :initform 'category)
   (level :initform 7)
   (abbreviation :initform 'RMODULE)
   (comment :initform (list
     "The category of right modules over an rng (ring not necessarily"
     "with unit). This is an abelian group which supports right"
     "multiplication by elements of the rng."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RightModule|
  (progn
    (push '|RightModule| *Categories*)
    (make-instance '|RightModuleType|)))

\end{chunk}

\subsection{Rng}
\index[cat]{Rng!Category}
\index[cat]{Category!Rng}
\index[cat]{RNG}
\begin{chunk}{defclass RngType}
(defclass |RngType| (|SemiGroupType| |AbelianGroupType|)
  ((parents :initform '(|SemiGroup| |AbelianGroup|))
   (name :initform "Rng")
   (marker :initform 'category)
   (level :initform 7)
   (abbreviation :initform 'RNG)
   (comment :initform (list
     "The category of associative rings, not necessarily commutative, and not"
     "necessarily with a 1. This is a combination of an abelian group"
     "and a semigroup, with multiplication distributing over addition."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Rng|
  (progn
    (push '|Rng| *Categories*)
    (make-instance '|RngType|)))

\end{chunk}

\section{Level 8}

\begin{chunk}{defvar level8}
(defvar level8
 '(|BiModule| |BitAggregate| |FiniteSetAggregate| |KeyedDictionary|
   |NonAssociativeRing| |NormalizedTriangularSetCategory|
   |OrderedMultisetAggregate| |Ring| |SquareFreeRegularTriangularSetCategory|
   |StringAggregate| |VectorCategory|))

\end{chunk}

\subsection{BiModule}
\index[cat]{BiModule!Category}
\index[cat]{Category!BiModule}
\index[cat]{BMODULE}
\begin{chunk}{defclass BiModuleType}
(defclass |BiModuleType| (|LeftModuleType| |RightModuleType|)
  ((parents :initform '(|LeftModule| |RightModule|))
   (name :initform "BiModule")
   (marker :initform 'category)
   (level :initform 8)
   (abbreviation :initform 'BMODULE)
   (comment :initform (list
     "A BiModule is both a left and right module with respect"
     "to potentially different rings."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BiModule|
  (progn
    (push '|BiModule| *Categories*)
    (make-instance '|BiModuleType|)))

\end{chunk}

\subsection{BitAggregate}
\index[cat]{BitAggregate!Category}
\index[cat]{Category!BitAggregate}
\index[cat]{BTAGG}
\begin{chunk}{defclass |BitAggregateType}
(defclass |BitAggregateType| (|LogicType| |OneDimensionalArrayAggregateType|)
  ((parents :initform '(|Logic| |OneDimensionalArrayAggregate|))
   (name :initform "BitAggregate")
   (marker :initform 'category)
   (level :initform 8)
   (abbreviation :initform 'BTAGG)
   (comment :initform (list
     "The bit aggregate category models aggregates representing large"
     "quantities of Boolean data."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BitAggregate|
  (progn
    (push '|BitAggregate| *Categories*)
    (make-instance '|BitAggregateType|)))

\end{chunk}

\subsection{FiniteSetAggregate}
\index[cat]{FiniteSetAggregate!Category}
\index[cat]{Category!FiniteSetAggregate}
\index[cat]{FSAGG}
\begin{chunk}{defclass FiniteSetAggregateType}
(defclass |FiniteSetAggregateType| (|FiniteType| |SetAggregateType| |DictionaryType|)
  ((parents :initform '(|Finite| |SetAggregate| |Dictionary|))
   (name :initform "FiniteSetAggregate")
   (marker :initform 'category)
   (level :initform 8)
   (abbreviation :initform 'FSAGG)
   (comment :initform (list
     "A finite-set aggregate models the notion of a finite set, that is,"
     "a collection of elements characterized by membership, but not"
     "by order or multiplicity."
     "See Set for an example."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteSetAggregate|
  (progn
    (push '|FiniteSetAggregate| *Categories*)
    (make-instance '|FiniteSetAggregateType|)))

\end{chunk}

\subsection{KeyedDictionary}
\index[cat]{KeyedDictionary!Category}
\index[cat]{Category!KeyedDictionary}
\index[cat]{KDAGG}
\begin{chunk}{defclass KeyedDictionaryType}
(defclass |KeyedDictionaryType| (|DictionaryType|)
  ((parents :initform '(|Dictionary|))
   (name :initform "KeyedDictionary")
   (marker :initform 'category)
   (level :initform 8)
   (abbreviation :initform 'KDAGG)
   (comment :initform (list
     "A keyed dictionary is a dictionary of key-entry pairs for which there is"
     "a unique entry for each key."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |KeyedDictionary|
  (progn
    (push '|KeyedDictionary| *Categories*)
    (make-instance '|KeyedDictionaryType|)))

\end{chunk}

\subsection{NonAssociativeRing}
\index[cat]{NonAssociativeRing!Category}
\index[cat]{Category!NonAssociativeRing}
\index[cat]{NASRING}
\begin{chunk}{defclass NonAssociativeRingType}
(defclass |NonAssociativeRingType| (|MonadWithUnitType| |NonAssociativeRngType|)
  ((parents :initform '(|MonadWithUnit| |NonAssociativeRng|))
   (name :initform "NonAssociativeRing")
   (marker :initform 'category)
   (level :initform 8)
   (abbreviation :initform 'NASRING)
   (comment :initform (list
     "A NonAssociativeRing is a non associative rng which has a unit,"
     "the multiplication is not necessarily commutative or associative."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NonAssociativeRing|
  (progn
    (push '|NonAssociativeRing| *Categories*)
    (make-instance '|NonAssociativeRingType|)))

\end{chunk}

\subsection{NormalizedTriangularSetCategory}
\index[cat]{NormalizedTriangularSetCategory!Category}
\index[cat]{Category!NormalizedTriangularSetCategory}
\index[cat]{NTSCAT}
\begin{chunk}{defclass NormalizedTriangularSetCategoryType}
(defclass |NormalizedTriangularSetCategoryType| (|RegularTriangularSetCategoryType|)
  ((parents :initform '(|RegularTriangularSetCategory|))
   (name :initform "NormalizedTriangularSetCategory")
   (marker :initform 'category)
   (level :initform 8)
   (abbreviation :initform 'NTSCAT)
   (comment :initform (list
     "The category of normalized triangular sets. A triangular"
     "set ts is said normalized if for every algebraic"
     "variable v of ts the polynomial select(ts,v)"
     "is normalized w.r.t. every polynomial in collectUnder(ts,v)."
     "A polynomial p is said normalized w.r.t. a non-constant"
     "polynomial q if p is constant or degree(p,mdeg(q)) = 0"
     "and init(p) is normalized w.r.t. q. One of the important"
     "features of normalized triangular sets is that they are regular sets."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NormalizedTriangularSetCategory|
  (progn
    (push '|NormalizedTriangularSetCategory| *Categories*)
    (make-instance '|NormalizedTriangularSetCategoryType|)))

\end{chunk}

\subsection{OrderedMultisetAggregate}
\index[cat]{OrderedMultisetAggregate!Category}
\index[cat]{Category!OrderedMultisetAggregate}
\index[cat]{OMSAGG}
\begin{chunk}{defclass OrderedMultisetAggregateType}
(defclass |OrderedMultisetAggregateType| (|MultisetAggregateType| |PriorityQueueAggregateType|)
  ((parents :initform '(|MultisetAggregate| |PriorityQueueAggregate|))
   (name :initform "OrderedMultisetAggregate")
   (marker :initform 'category)
   (level :initform 8)
   (abbreviation :initform 'OMSAGG)
   (comment :initform (list
     "An ordered-multiset aggregate is a multiset built over an ordered set S"
     "so that the relative sizes of its entries can be assessed."
     "These aggregates serve as models for priority queues."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderedMultisetAggregate|
  (progn
    (push '|OrderedMultisetAggregate| *Categories*)
    (make-instance '|OrderedMultisetAggregateType|)))

\end{chunk}

\subsection{Ring}
\index[cat]{Ring!Category}
\index[cat]{Category!Ring}
\index[cat]{RING}
\begin{chunk}{defclass RingType}
(defclass |RingType| (|MonoidType| |LeftModuleType| |RngType|)
  ((parents :initform '(|Monoid| |LeftModule| |Rng|))
   (name :initform "Ring")
   (marker :initform 'category)
   (level :initform 8)
   (abbreviation :initform 'RING)
   (comment :initform (list
     "The category of rings with unity, always associative, but"
     "not necessarily commutative."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Ring|
  (progn
    (push '|Ring| *Categories*)
    (make-instance '|RingType|)))

\end{chunk}

\subsection{SquareFreeRegularTriangularSetCategory}
\index[cat]{SquareFreeRegularTriangularSetCategory!Category}
\index[cat]{Category!SquareFreeRegularTriangularSetCategory}
\index[cat]{SFRTCAT}
\begin{chunk}{defclass SquareFreeRegularTriangularSetCategoryType}
(defclass |SquareFreeRegularTriangularSetCategoryType| (|RegularTriangularSetCategoryType|)
  ((parents :initform '(|RegularTriangularSetCategory|))
   (name :initform "SquareFreeRegularTriangularSetCategory")
   (marker :initform 'category)
   (level :initform 8)
   (abbreviation :initform 'SFRTCAT)
   (comment :initform (list
     "The category of square-free regular triangular sets."
     "A regular triangular set ts is square-free if"
     "the gcd of any polynomial p in ts and"
     "differentiate(p,mvar(p)) w.r.t. collectUnder(ts,mvar(p))"
     "has degree zero w.r.t. mvar(p). Thus any square-free regular"
     "set defines a tower of square-free simple extensions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SquareFreeRegularTriangularSetCategory|
  (progn
    (push '|SquareFreeRegularTriangularSetCategory| *Categories*)
    (make-instance '|SquareFreeRegularTriangularSetCategoryType|)))

\end{chunk}

\subsection{StringAggregate}
\index[cat]{StringAggregate!Category}
\index[cat]{Category!StringAggregate}
\index[cat]{SRAGG}
\begin{chunk}{defclass StringAggregateType}
(defclass |StringAggregateType| (|OneDimensionalArrayAggregateType|)
  ((parents :initform '(|OneDimensionalArrayAggregate|))
   (name :initform "StringAggregate")
   (marker :initform 'category)
   (level :initform 8)
   (abbreviation :initform 'SRAGG)
   (comment :initform (list
     "A string aggregate is a category for strings, that is,"
     "one dimensional arrays of characters."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StringAggregate|
  (progn
    (push '|StringAggregate| *Categories*)
    (make-instance '|StringAggregateType|)))

\end{chunk}

\subsection{VectorCategory}
\index[cat]{VectorCategory!Category}
\index[cat]{Category!VectorCategory}
\index[cat]{VECTCAT}
\begin{chunk}{defclass |VectorCategoryType}
(defclass |VectorCategoryType| (|OneDimensionalArrayAggregateType|)
  ((parents :initform '(|OneDimensionalArrayAggregate|))
   (name :initform "VectorCategory")
   (marker :initform 'category)
   (level :initform 8)
   (abbreviation :initform 'VECTCAT)
   (comment :initform (list
     "VectorCategory represents the type of vector like objects,"
     "that is, finite sequences indexed by some finite segment of the"
     "integers. The operations available on vectors depend on the structure"
     "of the underlying components. Many operations from the component domain"
     "are defined for vectors componentwise. It can by assumed that extraction or"
     "updating components can be done in constant time."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |VectorCategory|
  (progn
    (push '|VectorCategory| *Categories*)
    (make-instance '|VectorCategoryType|)))

\end{chunk}

\section{Level 9}

\begin{chunk}{defvar level9}
(defvar level9
 '(|CharacteristicNonZero| |CharacteristicZero| |CommutativeRing|
   |DifferentialRing| |EntireRing| |LeftAlgebra| |LinearlyExplicitRingOver|
   |Module| |OrderedRing| |PartialDifferentialRing| |PointCategory|
   |SquareFreeNormalizedTriangularSetCategory| |StringCategory| |TableAggregate|))

\end{chunk}

\subsection{CharacteristicNonZero}
\index[cat]{CharacteristicNonZero!Category}
\index[cat]{Category!CharacteristicNonZero}
\index[cat]{CHARNZ}
\begin{chunk}{defclass CharacteristicNonZeroType}
(defclass |CharacteristicNonZeroType| (|RingType|)
  ((parents :initform '(|Ring|))
   (name :initform "CharacteristicNonZero")
   (marker :initform 'category)
   (level :initform 9)
   (abbreviation :initform 'CHARNZ)
   (comment :initform (list
     "Rings of Characteristic Non Zero"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CharacteristicNonZero|
  (progn
    (push '|CharacteristicNonZero| *Categories*)
    (make-instance '|CharacteristicNonZeroType|)))

\end{chunk}

\subsection{CharacteristicZero}
\index[cat]{CharacteristicZero!Category}
\index[cat]{Category!CharacteristicZero}
\index[cat]{CHARZ}
\begin{chunk}{defclass CharacteristicZeroType}
(defclass |CharacteristicZeroType| (|RingType|)
  ((parents :initform '(|Ring|))
   (name :initform "CharacteristicZero")
   (marker :initform 'category)
   (level :initform 9)
   (abbreviation :initform 'CHARZ)
   (comment :initform (list
     "Rings of Characteristic Zero."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CharacteristicZero|
  (progn
    (push '|CharacteristicZero| *Categories*)
    (make-instance '|CharacteristicZeroType|)))

\end{chunk}

\subsection{CommutativeRing}
\index[cat]{CommutativeRing!Category}
\index[cat]{Category!CommutativeRing}
\index[cat]{COMRING}
\begin{chunk}{defclass CommutativeRingType}
(defclass |CommutativeRingType| (|RingType| |BiModuleType|)
  ((parents :initform '(|Ring| |BiModule|))
   (name :initform "CommutativeRing")
   (marker :initform 'category)
   (level :initform 9)
   (abbreviation :initform 'COMRING)
   (comment :initform (list
     "The category of commutative rings with unity, rings where"
     "* is commutative, and which have a multiplicative identity"
     "element."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CommutativeRing|
  (progn
    (push '|CommutativeRing| *Categories*)
    (make-instance '|CommutativeRingType|)))

\end{chunk}

\subsection{DifferentialRing}
\index[cat]{DifferentialRing!Category}
\index[cat]{Category!DifferentialRing}
\index[cat]{DIFRING}
\begin{chunk}{defclass DifferentialRingType}
(defclass |DifferentialRingType| (|RingType|)
  ((parents :initform '(|Ring|))
   (name :initform "DifferentialRing")
   (marker :initform 'category)
   (level :initform 9)
   (abbreviation :initform 'DIFRING)
   (comment :initform (list
     "An ordinary differential ring, that is, a ring with an operation"
     "differentiate."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DifferentialRing|
  (progn
    (push '|DifferentialRing| *Categories*)
    (make-instance '|DifferentialRingType|)))

\end{chunk}

\subsection{EntireRing}
\index[cat]{EntireRing!Category}
\index[cat]{Category!EntireRing}
\index[cat]{ENTIRER}
\begin{chunk}{defclass EntireRingType}
(defclass |EntireRingType| (|RingType| |BiModuleType|)
  ((parents :initform '(|Ring| |BiModule|))
   (name :initform "EntireRing")
   (marker :initform 'category)
   (level :initform 9)
   (abbreviation :initform 'ENTIRER)
   (comment :initform (list
     "Entire Rings (non-commutative Integral Domains), a ring"
     "not necessarily commutative which has no zero divisors."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |EntireRing|
  (progn
    (push '|EntireRing| *Categories*)
    (make-instance '|EntireRingType|)))

\end{chunk}

\subsection{LeftAlgebra}
\index[cat]{LeftAlgebra!Category}
\index[cat]{Category!LeftAlgebra}
\index[cat]{LALG}
\begin{chunk}{defclass LeftAlgebraType}
(defclass |LeftAlgebraType| (|RingType|)
  ((parents :initform '(|Ring|))
   (name :initform "LeftAlgebra")
   (marker :initform 'category)
   (level :initform 9)
   (abbreviation :initform 'LALG)
   (comment :initform (list
     "The category of all left algebras over an arbitrary ring."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LeftAlgebra|
  (progn
    (push '|LeftAlgebra| *Categories*)
    (make-instance '|LeftAlgebraType|)))

\end{chunk}

\subsection{LinearlyExplicitRingOver}
\index[cat]{LinearlyExplicitRingOver!Category}
\index[cat]{Category!LinearlyExplicitRingOver}
\index[cat]{LINEXP}
\begin{chunk}{defclass LinearlyExplicitRingOverType}
(defclass |LinearlyExplicitRingOverType| (|RingType|)
  ((parents :initform '(|Ring|))
   (name :initform "LinearlyExplicitRingOver")
   (marker :initform 'category)
   (level :initform 9)
   (abbreviation :initform 'LINEXP)
   (comment :initform (list
     "An extension ring with an explicit linear dependence test."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LinearlyExplicitRingOver|
  (progn
    (push '|LinearlyExplicitRingOver| *Categories*)
    (make-instance '|LinearlyExplicitRingOverType|)))

\end{chunk}

\subsection{Module}
\index[cat]{Module!Category}
\index[cat]{Category!Module}
\index[cat]{MODULE}
\begin{chunk}{defclass ModuleType}
(defclass |ModuleType| (|BiModuleType|)
  ((parents :initform '(|BiModule|))
   (name :initform "Module")
   (marker :initform 'category)
   (level :initform 9)
   (abbreviation :initform 'MODULE)
   (comment :initform (list
     "The category of modules over a commutative ring."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Module|
  (progn
    (push '|Module| *Categories*)
    (make-instance '|ModuleType|)))

\end{chunk}

\subsection{OrderedRing}
\index[cat]{OrderedRing!Category}
\index[cat]{Category!OrderedRing}
\index[cat]{ORDRING}
\begin{chunk}{defclass OrderedRingType}
(defclass |OrderedRingType| (|OrderedAbelianGroupType| |RingType|)
  ((parents :initform '(|OrderedAbelianGroup| |Ring|))
   (name :initform "OrderedRing")
   (marker :initform 'category)
   (level :initform 9)
   (abbreviation :initform 'ORDRING)
   (comment :initform (list
     "Ordered sets which are also rings, that is, domains where the ring"
     "operations are compatible with the ordering."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderedRing|
  (progn
    (push '|OrderedRing| *Categories*)
    (make-instance '|OrderedRingType|)))

\end{chunk}

\subsection{PartialDifferentialRing}
\index[cat]{PartialDifferentialRing!Category}
\index[cat]{Category!PartialDifferentialRing}
\index[cat]{PDRING}
\begin{chunk}{defclass PartialDifferentialRingType}
(defclass |PartialDifferentialRingType| (|RingType|)
  ((parents :initform '(|Ring|))
   (name :initform "PartialDifferentialRing")
   (marker :initform 'category)
   (level :initform 9)
   (abbreviation :initform 'PDRING)
   (comment :initform (list
     "A partial differential ring with differentiations indexed by a"
     "parameter type S."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PartialDifferentialRing|
  (progn
    (push '|PartialDifferentialRing| *Categories*)
    (make-instance '|PartialDifferentialRingType|)))

\end{chunk}

\subsection{PointCategory}
\index[cat]{PointCategory!Category}
\index[cat]{Category!PointCategory}
\index[cat]{PTCAT}
\begin{chunk}{defclass PointCategoryType}
(defclass |PointCategoryType| (|VectorCategoryType|)
  ((parents :initform '(|VectorCategory|))
   (name :initform "PointCategory")
   (marker :initform 'category)
   (level :initform 9)
   (abbreviation :initform 'PTCAT)
   (comment :initform (list
     "PointCategory is the category of points in space which"
     "may be plotted via the graphics facilities.  Functions are provided for"
     "defining points and handling elements of points."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PointCategory|
  (progn
    (push '|PointCategory| *Categories*)
    (make-instance '|PointCategoryType|)))

\end{chunk}

\subsection{SquareFreeNormalizedTriangularSetCategory}
\index[cat]{SquareFreeNormalizedTriangularSetCategory!Category}
\index[cat]{Category!SquareFreeNormalizedTriangularSetCategory}
\index[cat]{SNTSCAT}
\begin{chunk}{defclass SquareFreeNormalizedTriangularSetCategoryType}
(defclass |SquareFreeNormalizedTriangularSetCategoryType| (|NormalizedTriangularSetCategoryType| 
                                                           |SquareFreeRegularTriangularSetCategoryType|)
  ((parents :initform '(|NormalizedTriangularSetCategory| |SquareFreeRegularTriangularSetCategory|))
   (name :initform "SquareFreeNormalizedTriangularSetCategory")
   (marker :initform 'category)
   (level :initform 9)
   (abbreviation :initform 'SNTSCAT)
   (comment :initform (list
     "The category of square-free and normalized triangular sets."
     "Thus, up to the primitivity axiom of [1], these sets are Lazard"
     "triangular sets."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SquareFreeNormalizedTriangularSetCategory|
  (progn
    (push '|SquareFreeNormalizedTriangularSetCategory| *Categories*)
    (make-instance '|SquareFreeNormalizedTriangularSetCategoryType|)))

\end{chunk}

\subsection{StringCategory}
\index[cat]{StringCategory!Category}
\index[cat]{Category!StringCategory}
\index[cat]{STRICAT}
\begin{chunk}{defclass StringCategoryType}
(defclass |StringCategoryType| (|OpenMathType| |StringAggregateType|)
  ((parents :initform '(|OpenMath| |StringAggregate|))
   (name :initform "StringCategory")
   (marker :initform 'category)
   (level :initform 9)
   (abbreviation :initform 'STRICAT)
   (comment :initform (list
     "A category for string-like objects"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StringCategory|
  (progn
    (push '|StringCategory| *Categories*)
    (make-instance '|StringCategoryType|)))

\end{chunk}

\subsection{TableAggregate}
\index[cat]{TableAggregate!Category}
\index[cat]{Category!TableAggregate}
\index[cat]{TBAGG}
\begin{chunk}{defclass TableAggregateType}
(defclass |TableAggregateType| (|KeyedDictionaryType| |IndexedAggregateType|)
  ((parents :initform '(|KeyedDictionary| |IndexedAggregate|))
   (name :initform "TableAggregate")
   (marker :initform 'category)
   (level :initform 9)
   (abbreviation :initform 'TBAGG)
   (comment :initform (list
     "A table aggregate is a model of a table, that is, a discrete many-to-one"
     "mapping from keys to entries."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TableAggregate|
  (progn
    (push '|TableAggregate| *Categories*)
    (make-instance '|TableAggregateType|)))

\end{chunk}

\section{Level 10}

\begin{chunk}{defvar level10}
(defvar level10
 '(|Algebra| |AssociationListAggregate| |DifferentialExtension| |DivisorCategory|
   |FreeModuleCat| |FullyLinearlyExplicitRingOver| |LeftOreRing| |LieAlgebra|
   |NonAssociativeAlgebra| |RectangularMatrixCategory| |VectorSpace|))

\end{chunk}

\subsection{Algebra}
\index[cat]{Algebra!Category}
\index[cat]{Category!Algebra}
\index[cat]{ALGEBRA}
\begin{chunk}{defclass AlgebraType}
(defclass |AlgebraType| (|RingType| |ModuleType|)
  ((parents :initform '(|Ring| |Module|))
   (name :initform "Algebra")
   (marker :initform 'category)
   (level :initform 10)
   (abbreviation :initform 'ALGEBRA)
   (comment :initform (list
     "The category of associative algebras (modules which are themselves rings)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Algebra|
  (progn
    (push '|Algebra| *Categories*)
    (make-instance '|AlgebraType|)))

\end{chunk}

\subsection{AssociationListAggregate}
\index[cat]{AssociationListAggregate!Category}
\index[cat]{Category!AssociationListAggregate}
\index[cat]{ALAGG}
\begin{chunk}{defclass AssociationListAggregateType}
(defclass |AssociationListAggregateType| (|ListAggregateType| |TableAggregateType|)
  ((parents :initform '(|ListAggregate| |TableAggregate|))
   (name :initform "AssociationListAggregate")
   (marker :initform 'category)
   (level :initform 10)
   (abbreviation :initform 'ALAGG)
   (comment :initform (list
     "An association list is a list of key entry pairs which may be viewed"
     "as a table. It is a poor mans version of a table:"
     "searching for a key is a linear operation."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AssociationListAggregate|
  (progn
    (push '|AssociationListAggregate| *Categories*)
    (make-instance '|AssociationListAggregateType|)))

\end{chunk}

\subsection{DifferentialExtension}
\index[cat]{DifferentialExtension!Category}
\index[cat]{Category!DifferentialExtension}
\index[cat]{DIFEXT}
\begin{chunk}{defclass DifferentialExtensionType}
(defclass |DifferentialExtensionType| (|DifferentialRingType| |PartialDifferentialRingType|)
  ((parents :initform '(|DifferentialRing| |PartialDifferentialRing|))
   (name :initform "DifferentialExtension")
   (marker :initform 'category)
   (level :initform 10)
   (abbreviation :initform 'DIFEXT)
   (comment :initform (list
     "Differential extensions of a ring R."
     "Given a differentiation on R, extend it to a differentiation on %."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DifferentialExtension|
  (progn
    (push '|DifferentialExtension| *Categories*)
    (make-instance '|DifferentialExtensionType|)))

\end{chunk}

\subsection{DivisorCategory}
\index[cat]{DivisorCategory!Category}
\index[cat]{Category!DivisorCategory}
\index[cat]{DIVCAT}
\begin{chunk}{defclass DivisorCategoryType}
(defclass |DivisorCategoryType| (|FreeAbelianMonoidCategoryType| |ModuleType|)
  ((parents :initform '(|FreeAbelianMonoidCategory| |Module|))
   (name :initform "DivisorCategory")
   (marker :initform 'category)
   (level :initform 10)
   (abbreviation :initform 'DIVCAT)
   (comment :initform (list
     "This category exports the function for domains "))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DivisorCategory|
  (progn
    (push '|DivisorCategory| *Categories*)
    (make-instance '|DivisorCategoryType|)))

\end{chunk}

\subsection{FreeModuleCat}
\index[cat]{FreeModuleCat!Category}
\index[cat]{Category!FreeModuleCat}
\index[cat]{FMCAT}
\begin{chunk}{defclass FreeModuleCatType}
(defclass |FreeModuleCatType| (|RetractableToType| |ModuleType|)
  ((parents :initform '(|RetractableTo| |Module|))
   (name :initform "FreeModuleCat")
   (marker :initform 'category)
   (level :initform 10)
   (abbreviation :initform 'FMCAT)
   (comment :initform (list
     "A domain of this category"
     "implements formal linear combinations"
     "of elements from a domain Basis with coefficients"
     "in a domain R. The domain Basis needs only"
     "to belong to the category SetCategory and R"
     "to the category Ring. Thus the coefficient ring"
     "may be non-commutative."
     "See the XDistributedPolynomial constructor"
     "for examples of domains built with the FreeModuleCat"
     "category constructor."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FreeModuleCat|
  (progn
    (push '|FreeModuleCat| *Categories*)
    (make-instance '|FreeModuleCatType|)))

\end{chunk}

\subsection{FullyLinearlyExplicitRingOver}
\index[cat]{FullyLinearlyExplicitRingOver!Category}
\index[cat]{Category!FullyLinearlyExplicitRingOver}
\index[cat]{FLINEXP}
\begin{chunk}{defclass FullyLinearlyExplicitRingOverType}
(defclass |FullyLinearlyExplicitRingOverType| (|LinearlyExplicitRingOverType|)
  ((parents :initform '(|LinearlyExplicitRingOver|))
   (name :initform "FullyLinearlyExplicitRingOver")
   (marker :initform 'category)
   (level :initform 10)
   (abbreviation :initform 'FLINEXP)
   (comment :initform (list
     "S is FullyLinearlyExplicitRingOver R means that S is a"
     "LinearlyExplicitRingOver R and, in addition, if R is a"
     "LinearlyExplicitRingOver Integer, then so is S"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FullyLinearlyExplicitRingOver|
  (progn
    (push '|FullyLinearlyExplicitRingOver| *Categories*)
    (make-instance '|FullyLinearlyExplicitRingOverType|)))

\end{chunk}

\subsection{LeftOreRing}
\index[cat]{LeftOreRing!Category}
\index[cat]{Category!LeftOreRing}
\index[cat]{LORER}
\begin{chunk}{defclass LeftOreRingType}
(defclass |LeftOreRingType| (|EntireRingType|)
  ((parents :initform '(|EntireRing|))
   (name :initform "LeftOreRing")
   (marker :initform 'category)
   (level :initform 10)
   (abbreviation :initform 'LORER)
   (comment :initform (list
     "This is the category of left ore rings, that is noncommutative"
     "rings without zero divisors where we can compute the least left"
     "common multiple."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LeftOreRing|
  (progn
    (push '|LeftOreRing| *Categories*)
    (make-instance '|LeftOreRingType|)))

\end{chunk}

\subsection{LieAlgebra}
\index[cat]{LieAlgebra!Category}
\index[cat]{Category!LieAlgebra}
\index[cat]{LIECAT}
\begin{chunk}{defclass LieAlgebraType}
(defclass |LieAlgebraType| (|ModuleType|)
  ((parents :initform '(|Module|))
   (name :initform "LieAlgebra")
   (marker :initform 'category)
   (level :initform 10)
   (abbreviation :initform 'LIECAT)
   (comment :initform (list
     "The category of Lie Algebras."
     "It is used by the domains of non-commutative algebra,"
     "LiePolynomial and XPBWPolynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LieAlgebra|
  (progn
    (push '|LieAlgebra| *Categories*)
    (make-instance '|LieAlgebraType|)))

\end{chunk}

\subsection{NonAssociativeAlgebra}
\index[cat]{NonAssociativeAlgebra!Category}
\index[cat]{Category!NonAssociativeAlgebra}
\index[cat]{NAALG}
\begin{chunk}{defclass NonAssociativeAlgebraType}
(defclass |NonAssociativeAlgebraType| (|NonAssociativeRngType| |ModuleType|)
  ((parents :initform '(|NonAssociativeRng| |Module|))
   (name :initform "NonAssociativeAlgebra")
   (marker :initform 'category)
   (level :initform 10)
   (abbreviation :initform 'NAALG)
   (comment :initform (list
     "NonAssociativeAlgebra is the category of non associative algebras"
     "(modules which are themselves non associative rngs)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NonAssociativeAlgebra|
  (progn
    (push '|NonAssociativeAlgebra| *Categories*)
    (make-instance '|NonAssociativeAlgebraType|)))

\end{chunk}

\subsection{RectangularMatrixCategory}
\index[cat]{RectangularMatrixCategory!Category}
\index[cat]{Category!RectangularMatrixCategory}
\index[cat]{RMATCAT}
\begin{chunk}{defclass RectangularMatrixCategoryType}
(defclass |RectangularMatrixCategoryType| (|ModuleType| |HomogeneousAggregateType|)
  ((parents :initform '(|Module| |HomogeneousAggregate|))
   (name :initform "RectangularMatrixCategory")
   (marker :initform 'category)
   (level :initform 10)
   (abbreviation :initform 'RMATCAT)
   (comment :initform (list
     "RectangularMatrixCategory is a category of matrices of fixed"
     "dimensions. The dimensions of the matrix will be parameters of the"
     "domain. Domains in this category will be R-modules and will be non-mutable."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RectangularMatrixCategory|
  (progn
    (push '|RectangularMatrixCategory| *Categories*)
    (make-instance '|RectangularMatrixCategoryType|)))

\end{chunk}

\subsection{VectorSpace}
\index[cat]{VectorSpace!Category}
\index[cat]{Category!VectorSpace}
\index[cat]{VSPACE}
\begin{chunk}{defclass VectorSpaceType}
(defclass |VectorSpaceType| (|ModuleType|)
  ((parents :initform '(|Module|))
   (name :initform "VectorSpace")
   (marker :initform 'category)
   (level :initform 10)
   (abbreviation :initform 'VSPACE)
   (comment :initform (list
     "Vector Spaces (not necessarily finite dimensional) over a field."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |VectorSpace|
  (progn
    (push '|VectorSpace| *Categories*)
    (make-instance '|VectorSpaceType|)))

\end{chunk}

\section{Level 11}

\begin{chunk}{defvar level11}
(defvar level11
 '(|DirectProductCategory| |DivisionRing| |FiniteRankAlgebra|
   |FiniteRankNonAssociativeAlgebra| |FreeLieAlgebra| |IntegralDomain|
   |MonogenicLinearOperator| |OctonionCategory| |SquareMatrixCategory|
   |UnivariateSkewPolynomialCategory| |XAlgebra|))

\end{chunk}

\subsection{DirectProductCategory}
\index[cat]{DirectProductCategory!Category}
\index[cat]{Category!DirectProductCategory}
\index[cat]{DIRPCAT}
\begin{chunk}{defclass DirectProductCategoryType}
(defclass |DirectProductCategoryType| (|FullyRetractableToType|
                                       |FiniteType|
                                       |IndexedAggregateType|
                                       |OrderedAbelianMonoidSupType|
                                       |CommutativeRingType|
                                       |OrderedRingType|
                                       |AlgebraType|
                                       |DifferentialExtensionType|
                                       |FullyLinearlyExplicitRingOverType|
                                       |VectorSpaceType|)
  ((parents :initform '(|FullyRetractableTo|
                        |Finite|
                        |IndexedAggregate|
                        |OrderedAbelianMonoidSup|
                        |CommutativeRing|
                        |OrderedRing|
                        |Algebra|
                        |DifferentialExtension|
                        |FullyLinearlyExplicitRingOver|
                        |VectorSpace|))
   (name :initform "DirectProductCategory")
   (marker :initform 'category)
   (level :initform 11)
   (abbreviation :initform 'DIRPCAT)
   (comment :initform (list
     "This category represents a finite cartesian product of a given type."
     "Many categorical properties are preserved under this construction."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DirectProductCategory|
  (progn
    (push '|DirectProductCategory| *Categories*)
    (make-instance '|DirectProductCategoryType|)))

\end{chunk}

\subsection{DivisionRing}
\index[cat]{DivisionRing!Category}
\index[cat]{Category!DivisionRing}
\index[cat]{DIVRING}
\begin{chunk}{defclass DivisionRingType}
(defclass |DivisionRingType| (|AlgebraType| |EntireRingType|)
  ((parents :initform '(|Algebra| |EntireRing|))
   (name :initform "DivisionRing")
   (marker :initform 'category)
   (level :initform 11)
   (abbreviation :initform 'DIVRING)
   (comment :initform (list
     "A division ring (sometimes called a skew field),"
     "a not necessarily commutative ring where"
     "all non-zero elements have multiplicative inverses."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DivisionRing|
  (progn
    (push '|DivisionRing| *Categories*)
    (make-instance '|DivisionRingType|)))

\end{chunk}

\subsection{FiniteRankAlgebra}
\index[cat]{FiniteRankAlgebra!Category}
\index[cat]{Category!FiniteRankAlgebra}
\index[cat]{FINRALG}
\begin{chunk}{defclass FiniteRankAlgebraType}
(defclass |FiniteRankAlgebraType| (|CharacteristicNonZeroType| |CharacteristicZeroType| 
                                   |AlgebraType|)
  ((parents :initform '(|CharacteristicNonZero| |CharacteristicZero| 
                          |Algebra|))
   (name :initform "FiniteRankAlgebra")
   (marker :initform 'category)
   (level :initform 11)
   (abbreviation :initform 'FINRALG)
   (comment :initform (list
     "A FiniteRankAlgebra is an algebra over a commutative ring R which"
     "is a free R-module of finite rank."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteRankAlgebra|
  (progn
    (push '|FiniteRankAlgebra| *Categories*)
    (make-instance '|FiniteRankAlgebraType|)))

\end{chunk}

\subsection{FiniteRankNonAssociativeAlgebra}
\index[cat]{FiniteRankNonAssociativeAlgebra!Category}
\index[cat]{Category!FiniteRankNonAssociativeAlgebra}
\index[cat]{FINAALG}
\begin{chunk}{defclass FiniteRankNonAssociativeAlgebraType}
(defclass |FiniteRankNonAssociativeAlgebraType| (|NonAssociativeAlgebraType|)
  ((parents :initform '(|NonAssociativeAlgebra|))
   (name :initform "FiniteRankNonAssociativeAlgebra")
   (marker :initform 'category)
   (level :initform 11)
   (abbreviation :initform 'FINAALG)
   (comment :initform (list
     "A FiniteRankNonAssociativeAlgebra is a non associative algebra over"
     "a commutative ring R which is a free R-module of finite rank."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteRankNonAssociativeAlgebra|
  (progn
    (push '|FiniteRankNonAssociativeAlgebra| *Categories*)
    (make-instance '|FiniteRankNonAssociativeAlgebraType|)))

\end{chunk}

\subsection{FreeLieAlgebra}
\index[cat]{FreeLieAlgebra!Category}
\index[cat]{Category!FreeLieAlgebra}
\index[cat]{FLALG}
\begin{chunk}{defclass FreeLieAlgebraType}
(defclass |FreeLieAlgebraType| (|LieAlgebraType|)
  ((parents :initform '(|LieAlgebra|))
   (name :initform "FreeLieAlgebra")
   (marker :initform 'category)
   (level :initform 11)
   (abbreviation :initform 'FLALG)
   (comment :initform (list
     "The category of free Lie algebras."
     "It is used by domains of non-commutative algebra:"
     "LiePolynomial and XPBWPolynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FreeLieAlgebra|
  (progn
    (push '|FreeLieAlgebra| *Categories*)
    (make-instance '|FreeLieAlgebraType|)))

\end{chunk}

\subsection{IntegralDomain}
\index[cat]{IntegralDomain!Category}
\index[cat]{Category!IntegralDomain}
\index[cat]{INTDOM}
\begin{chunk}{defclass IntegralDomainType}
(defclass |IntegralDomainType| (|CommutativeRingType| |AlgebraType| |EntireRingType|)
  ((parents :initform '(|CommutativeRing| |Algebra| |EntireRing|))
   (name :initform "IntegralDomain")
   (marker :initform 'category)
   (level :initform 11)
   (abbreviation :initform 'INTDOM)
   (comment :initform (list
     "The category of commutative integral domains, commutative"
     "rings with no zero divisors."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegralDomain|
  (progn
    (push '|IntegralDomain| *Categories*)
    (make-instance '|IntegralDomainType|)))

\end{chunk}

\subsection{MonogenicLinearOperator}
\index[cat]{MonogenicLinearOperator!Category}
\index[cat]{Category!MonogenicLinearOperator}
\index[cat]{MLO}
\begin{chunk}{defclass MonogenicLinearOperatorType}
(defclass |MonogenicLinearOperatorType| (|AlgebraType|)
  ((parents :initform '(|Algebra|))
   (name :initform "MonogenicLinearOperator")
   (marker :initform 'category)
   (level :initform 11)
   (abbreviation :initform 'MLO)
   (comment :initform (list
     "This is the category of linear operator rings with one generator."
     "The generator is not named by the category but can always be"
     "constructed as monomial(1,1)."
     " "
     "For convenience, call the generator G."
     "Then each value is equal to"
     "sum(a(i)*G**i, i = 0..n)"
     "for some unique n and a(i) in R."
     " "
     "Note that multiplication is not necessarily commutative."
     "In fact,  if a is in R, it is quite normal"
     "to have a*G ^= G*a."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MonogenicLinearOperator|
  (progn
    (push '|MonogenicLinearOperator| *Categories*)
    (make-instance '|MonogenicLinearOperatorType|)))

\end{chunk}

\subsection{OctonionCategory}
\index[cat]{OctonionCategory!Category}
\index[cat]{Category!OctonionCategory}
\index[cat]{OC}
\begin{chunk}{defclass OctonionCategoryType}
(defclass |OctonionCategoryType| (|ConvertibleToType|
                                  |FullyRetractableToType| 
                                  |FiniteType| 
                                  |FullyEvalableOverType| 
                                  |OrderedSetType| 
                                  |CharacteristicNonZeroType|
                                  |CharacteristicZeroType| 
                                  |AlgebraType|)
  ((parents :initform '(|ConvertibleTo|
                        |FullyRetractableTo| 
                        |Finite| 
                        |FullyEvalableOver| 
                        |OrderedSet| 
                        |CharacteristicNonZero|
                        |CharacteristicZero| 
                        |Algebra|))
   (name :initform "OctonionCategory")
   (marker :initform 'category)
   (level :initform 11)
   (abbreviation :initform 'OC)
   (comment :initform (list
     "OctonionCategory gives the categorial frame for the"
     "octonions, and eight-dimensional non-associative algebra,"
     "doubling the the quaternions in the same way as doubling"
     "the Complex numbers to get the quaternions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OctonionCategory|
  (progn
    (push '|OctonionCategory| *Categories*)
    (make-instance '|OctonionCategoryType|)))

\end{chunk}

\subsection{SquareMatrixCategory}
\index[cat]{SquareMatrixCategory!Category}
\index[cat]{Category!SquareMatrixCategory}
\index[cat]{SMATCAT}
\begin{chunk}{defclass SquareMatrixCategoryType}
(defclass |SquareMatrixCategoryType| (|FullyRetractableToType| |AlgebraType| |DifferentialExtensionType| 
                                      |FullyLinearlyExplicitRingOverType|
                                      |RectangularMatrixCategoryType|)
  ((parents :initform '(|FullyRetractableTo| |Algebra| |DifferentialExtension| 
                          |FullyLinearlyExplicitRingOver|
                          |RectangularMatrixCategory|))
   (name :initform "SquareMatrixCategory")
   (marker :initform 'category)
   (level :initform 11)
   (abbreviation :initform 'SMATCAT)
   (comment :initform (list
     "SquareMatrixCategory is a general square matrix category which"
     "allows different representations and indexing schemes.  Rows and"
     "columns may be extracted with rows returned as objects of"
     "type Row and colums returned as objects of type Col."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SquareMatrixCategory|
  (progn
    (push '|SquareMatrixCategory| *Categories*)
    (make-instance '|SquareMatrixCategoryType|)))

\end{chunk}

\subsection{UnivariateSkewPolynomialCategory}
\index[cat]{UnivariateSkewPolynomialCategory!Category}
\index[cat]{Category!UnivariateSkewPolynomialCategory}
\index[cat]{OREPCAT}
\begin{chunk}{defclass UnivariateSkewPolynomialCategoryType}
(defclass |UnivariateSkewPolynomialCategoryType| (|FullyRetractableToType| |AlgebraType|)
  ((parents :initform '(|FullyRetractableTo| |Algebra|))
   (name :initform "UnivariateSkewPolynomialCategory")
   (marker :initform 'category)
   (level :initform 11)
   (abbreviation :initform 'OREPCAT)
   (comment :initform (list
     "This is the category of univariate skew polynomials over an Ore"
     "coefficient ring."
     "The multiplication is given by x a = sigma(a) x + delta a."
     "This category is an evolution of the types"
     "MonogenicLinearOperator, OppositeMonogenicLinearOperator, and"
     "NonCommutativeOperatorDivision"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariateSkewPolynomialCategory|
  (progn
    (push '|UnivariateSkewPolynomialCategory| *Categories*)
    (make-instance '|UnivariateSkewPolynomialCategoryType|)))

\end{chunk}

\subsection{XAlgebra}
\index[cat]{XAlgebra!Category}
\index[cat]{Category!XAlgebra}
\index[cat]{XALG}
\begin{chunk}{defclass XAlgebraType}
(defclass |XAlgebraType| (|AlgebraType|)
  ((parents :initform '(|Algebra|))
   (name :initform "XAlgebra")
   (marker :initform 'category)
   (level :initform 11)
   (abbreviation :initform 'XALG)
   (comment :initform (list
     "This is the category of algebras over non-commutative rings."
     "It is used by constructors of non-commutative algebras such as"
     "XPolynomialRing and XFreeAlgebra"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |XAlgebra|
  (progn
    (push '|XAlgebra| *Categories*)
    (make-instance '|XAlgebraType|)))

\end{chunk}

\section{Level 12}

\begin{chunk}{defvar level12}
(defvar level12
 '(|AbelianMonoidRing| |FortranMachineTypeCategory| |FramedAlgebra|
   |FramedNonAssociativeAlgebra| |GcdDomain|
   |LinearOrdinaryDifferentialOperatorCategory| |OrderedIntegralDomain|
   |QuaternionCategory| |XFreeAlgebra|))

\end{chunk}

\subsection{AbelianMonoidRing}
\index[cat]{AbelianMonoidRing!Category}
\index[cat]{Category!AbelianMonoidRing}
\index[cat]{AMR}
\begin{chunk}{defclass AbelianMonoidRingType}
(defclass |AbelianMonoidRingType| (|CharacteristicNonZeroType| |CharacteristicZeroType| |IntegralDomainType|)
  ((parents :initform '(|CharacteristicNonZero| |CharacteristicZero| |IntegralDomain|))
   (name :initform "AbelianMonoidRing")
   (marker :initform 'category)
   (level :initform 12)
   (abbreviation :initform 'AMR)
   (comment :initform (list
     "Abelian monoid ring elements (not necessarily of finite support)"
     "of this ring are of the form formal SUM (r_i * e_i)"
     "where the r_i are coefficents and the e_i, elements of the"
     "ordered abelian monoid, are thought of as exponents or monomials."
     "The monomials commute with each other, and with"
     "the coefficients (which themselves may or may not be commutative)."
     "See FiniteAbelianMonoidRing for the case of finite support"
     "a useful common model for polynomials and power series."
     "Conceptually at least, only the non-zero terms are ever operated on."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AbelianMonoidRing|
  (progn
    (push '|AbelianMonoidRing| *Categories*)
    (make-instance '|AbelianMonoidRingType|)))

\end{chunk}

\subsection{FortranMachineTypeCategory}
\index[cat]{FortranMachineTypeCategory!Category}
\index[cat]{Category!FortranMachineTypeCategory}
\index[cat]{FMTC}
\begin{chunk}{defclass FortranMachineTypeCategoryType}
(defclass |FortranMachineTypeCategoryType| (|RetractableToType| |OrderedSetType| 
                                            |IntegralDomainType|)
  ((parents :initform '(|RetractableTo| |OrderedSet| 
                          |IntegralDomain|))
   (name :initform "FortranMachineTypeCategory")
   (marker :initform 'category)
   (level :initform 12)
   (abbreviation :initform 'FMTC)
   (comment :initform (list
     "A category of domains which model machine arithmetic"
     "used by machines in the AXIOM-NAG link."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FortranMachineTypeCategory|
  (progn
    (push '|FortranMachineTypeCategory| *Categories*)
    (make-instance '|FortranMachineTypeCategoryType|)))

\end{chunk}

\subsection{FramedAlgebra}
\index[cat]{FramedAlgebra!Category}
\index[cat]{Category!FramedAlgebra}
\index[cat]{FRAMALG}
\begin{chunk}{defclass FramedAlgebraType}
(defclass |FramedAlgebraType| (|FiniteRankAlgebraType|)
  ((parents :initform '(|FiniteRankAlgebra|))
   (name :initform "FramedAlgebra")
   (marker :initform 'category)
   (level :initform 12)
   (abbreviation :initform 'FRAMALG)
   (comment :initform (list
     "A FramedAlgebra is a FiniteRankAlgebra together"
     "with a fixed R-module basis."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FramedAlgebra|
  (progn
    (push '|FramedAlgebra| *Categories*)
    (make-instance '|FramedAlgebraType|)))

\end{chunk}

\subsection{FramedNonAssociativeAlgebra}
\index[cat]{FramedNonAssociativeAlgebra!Category}
\index[cat]{Category!FramedNonAssociativeAlgebra}
\index[cat]{FRNAALG}
\begin{chunk}{defclass FramedNonAssociativeAlgebraType}
(defclass |FramedNonAssociativeAlgebraType| (|FiniteRankNonAssociativeAlgebraType|)
  ((parents :initform '(|FiniteRankNonAssociativeAlgebra|))
   (name :initform "FramedNonAssociativeAlgebra")
   (marker :initform 'category)
   (level :initform 12)
   (abbreviation :initform 'FRNAALG)
   (comment :initform (list
     "FramedNonAssociativeAlgebra(R) is a"
     "FiniteRankNonAssociativeAlgebra (a non associative"
     "algebra over R which is a free R-module of finite rank)"
     "over a commutative ring R together with a fixed R-module basis."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FramedNonAssociativeAlgebra|
  (progn
    (push '|FramedNonAssociativeAlgebra| *Categories*)
    (make-instance '|FramedNonAssociativeAlgebraType|)))

\end{chunk}

\subsection{GcdDomain}
\index[cat]{GcdDomain!Category}
\index[cat]{Category!GcdDomain}
\index[cat]{GCDDOM}
\begin{chunk}{defclass GcdDomainType}
(defclass |GcdDomainType| (|IntegralDomainType| |LeftOreRingType|)
  ((parents :initform '(|IntegralDomain| |LeftOreRing|))
   (name :initform "GcdDomain")
   (marker :initform 'category)
   (level :initform 12)
   (abbreviation :initform 'GCDDOM)
   (comment :initform (list
     "This category describes domains where"
     "gcd can be computed but where there is no guarantee"
     "of the existence of factor operation for factorisation"
     "into irreducibles. However, if such a factor operation exist,"
     "factorization will be unique up to order and units."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GcdDomain|
  (progn
    (push '|GcdDomain| *Categories*)
    (make-instance '|GcdDomainType|)))

\end{chunk}
\begin{verbatim}
( ?~=? : (%,%) -> Boolean
 (~= (((|Boolean|) $ $) 7))

 zero? : % -> Boolean
 (|zero?| (((|Boolean|) $) 15))

 unitNormal : % -> Record(unit: %,canonical: %,associate: %)
 (|unitNormal| (((|Record| (|:| |unit| $) (|:| |canonical| $) (|:| |associate| $)) $) 40))

 unitCanonical : % -> %
 (|unitCanonical| (($ $) 39))

 unit? : % -> Boolean
 (|unit?| (((|Boolean|) $) 37))

 subtractIfCan : (%,%) -> Union(%,"failed")
 (|subtractIfCan| (((|Union| $ "failed") $ $) 18))

 sample : () -> %
 (|sample| (($) 16 T CONST))

 recip : % -> Union(%,"failed")
 (|recip| (((|Union| $ "failed") $) 33))

 one? : % -> Boolean
 (|one?| (((|Boolean|) $) 30))

 lcmCoef : (%,%) -> Record(llcmres: %,coeff1: %,coeff2: %)
 (|lcmCoef| (((|Record| (|:| |llcmres| $) (|:| |coeff1| $) (|:| |coeff2| $)) $ $) 48))

 lcm : (%,%) -> %
 lcm : List(%) -> %
 (|lcm| (($ $ $) 45) (($ (|List| $)) 44))

 latex : % -> String
 (|latex| (((|String|) $) 9))

 hash : % -> SingleInteger
 (|hash| (((|SingleInteger|) $) 10))

 gcdPolynomial : (SparseUnivariatePolynomial(%),SparseUnivariatePolynomial(%)) -> SparseUnivariatePolynomial(%)
 (|gcdPolynomial| (((|SparseUnivariatePolynomial| $) (|SparseUnivariatePolynomial| $) (|SparseUnivariatePolynomial| $)) 43))

 gcd : (%,%) -> %
 gcd : List(%) -> %
 (|gcd| (($ $ $) 47) (($ (|List| $)) 46))

 exquo : (%,%) -> Union(%,"failed")
 (|exquo| (((|Union| $ "failed") $ $) 41))

 coerce : % -> OutputForm
 coerce : Integer -> %
 coerce : % -> %
 (|coerce| (((|OutputForm|) $) 11) (($ (|Integer|)) 27) (($ $) 42))

 characteristic : () -> NonNegativeInteger
 (|characteristic| (((|NonNegativeInteger|)) 28))

 associates? : (%,%) -> Boolean
 (|associates?| (((|Boolean|) $ $) 38))

 ?^? : (%,PositiveInteger) -> %
 ?^? : (%,NonNegativeInteger) -> %
 (^ (($ $ (|PositiveInteger|)) 25) (($ $ (|NonNegativeInteger|)) 32))

 0 : () -> %
 (|Zero| (($) 17 T CONST))

 1 : () -> %
 (|One| (($) 29 T CONST))

 ?=? : (%,%) -> Boolean
 (= (((|Boolean|) $ $) 6))

 -? : % -> %
 ?-? : (%,%) -> %
 (- (($ $) 21) (($ $ $) 20))

 ?+? : (%,%) -> %
 (+ (($ $ $) 13))

 ?**? : (%,PositiveInteger) -> %
 ?**? : (%,NonNegativeInteger) -> %
 (** (($ $ (|PositiveInteger|)) 24) (($ $ (|NonNegativeInteger|)) 31))
 
 ?*? : (PositiveInteger,%) -> %
 ?*? : (NonNegativeInteger,%) -> %
 ?*? : (Integer,%) -> %
 ?*? : (%,%) -> %
 (* (($ (|PositiveInteger|) $) 12) (($ (|NonNegativeInteger|) $) 14) (($ (|Integer|) $) 19) (($ $ $) 23)))
\end{verbatim}

\subsection{LinearOrdinaryDifferentialOperatorCategory}
\index[cat]{LinearOrdinaryDifferentialOperatorCategory!Category}
\index[cat]{Category!LinearOrdinaryDifferentialOperatorCategory}
\index[cat]{LODOCAT}
\begin{chunk}{defclass LinearOrdinaryDifferentialOperatorCategoryType}
(defclass |LinearOrdinaryDifferentialOperatorCategoryType| (
                   |EltableType| |UnivariateSkewPolynomialCategoryType|)
  ((parents :initform '(|Eltable| |UnivariateSkewPolynomialCategory|))
   (name :initform "LinearOrdinaryDifferentialOperatorCategory")
   (marker :initform 'category)
   (level :initform 12)
   (abbreviation :initform 'LODOCAT)
   (comment :initform (list
     "LinearOrdinaryDifferentialOperatorCategory is the category"
     "of differential operators with coefficients in a ring A with a given"
     "derivation."
     " "
     "Multiplication of operators corresponds to functional composition:"
     "   (L1 * L2).(f) = L1 L2 f"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LinearOrdinaryDifferentialOperatorCategory|
  (progn
    (push '|LinearOrdinaryDifferentialOperatorCategory| *Categories*)
    (make-instance '|LinearOrdinaryDifferentialOperatorCategoryType|)))

\end{chunk}

\subsection{OrderedIntegralDomain}
\index[cat]{OrderedIntegralDomain!Category}
\index[cat]{Category!OrderedIntegralDomain}
\index[cat]{OINTDOM}
\begin{chunk}{defclass OrderedIntegralDomainType}
(defclass |OrderedIntegralDomainType| (|OrderedRingType| |IntegralDomainType|)
  ((parents :initform '(|OrderedRing| |IntegralDomain|))
   (name :initform "OrderedIntegralDomain")
   (marker :initform 'category)
   (level :initform 12)
   (abbreviation :initform 'OINTDOM)
   (comment :initform (list
     "The category of ordered commutative integral domains, where ordering"
     "and the arithmetic operations are compatible"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderedIntegralDomain|
  (progn
    (push '|OrderedIntegralDomain| *Categories*)
    (make-instance '|OrderedIntegralDomainType|)))

\end{chunk}

\subsection{QuaternionCategory}
\index[cat]{QuaternionCategory!Category}
\index[cat]{Category!QuaternionCategory}
\index[cat]{QUATCAT}
\begin{chunk}{defclass QuaternionCategoryType}
(defclass |QuaternionCategoryType| (|ConvertibleToType|
                                    |FullyRetractableToType|
                                    |FullyEvalableOverType|
                                    |OrderedSetType|
                                    |CharacteristicNonZeroType|
                                    |CharacteristicZeroType|
                                    |DifferentialExtensionType|
                                    |FullyLinearlyExplicitRingOverType|
                                    |DivisionRingType|)
  ((parents :initform '(|ConvertibleTo|
                        |FullyRetractableTo|
                        |FullyEvalableOver|
                        |OrderedSet|
                        |CharacteristicNonZero|
                        |CharacteristicZero|
                        |DifferentialExtension|
                        |FullyLinearlyExplicitRingOver|
                        |DivisionRing|))
   (name :initform "QuaternionCategory")
   (marker :initform 'category)
   (level :initform 12)
   (abbreviation :initform 'QUATCAT)
   (comment :initform (list
     "QuaternionCategory describes the category of quaternions"
     "and implements functions that are not representation specific."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |QuaternionCategory|
  (progn
    (push '|QuaternionCategory| *Categories*)
    (make-instance '|QuaternionCategoryType|)))

\end{chunk}

\subsection{XFreeAlgebra}
\index[cat]{XFreeAlgebra!Category}
\index[cat]{Category!XFreeAlgebra}
\index[cat]{XFALG}
\begin{chunk}{defclass XFreeAlgebraType}
(defclass |XFreeAlgebraType| (|RetractableToType| |XAlgebraType|)
  ((parents :initform '(|RetractableTo| |XAlgebra|))
   (name :initform "XFreeAlgebra")
   (marker :initform 'category)
   (level :initform 12)
   (abbreviation :initform 'XFALG)
   (comment :initform (list
     "This category specifies opeations for  polynomials"
     "and formal series with non-commutative variables."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |XFreeAlgebra|
  (progn
    (push '|XFreeAlgebra| *Categories*)
    (make-instance '|XFreeAlgebraType|)))

\end{chunk}

\section{Level 13}

\begin{chunk}{defvar level13}
(defvar level13
 '(|FiniteAbelianMonoidRing| |IntervalCategory| |PowerSeriesCategory|
   |PrincipalIdealDomain| |UniqueFactorizationDomain| |XPolynomialsCat|))

\end{chunk}

\subsection{FiniteAbelianMonoidRing}
\index[cat]{FiniteAbelianMonoidRing!Category}
\index[cat]{Category!FiniteAbelianMonoidRing}
\index[cat]{FAMR}
\begin{chunk}{defclass FiniteAbelianMonoidRingType}
(defclass |FiniteAbelianMonoidRingType| (|FullyRetractableToType| |AbelianMonoidRingType|)
  ((parents :initform '(|FullyRetractableTo| |AbelianMonoidRing|))
   (name :initform "FiniteAbelianMonoidRing")
   (marker :initform 'category)
   (level :initform 13)
   (abbreviation :initform 'FAMR)
   (comment :initform (list
     "This category is similar to AbelianMonoidRing, except that the sum is"
     "assumed to be finite. It is a useful model for polynomials,"
     "but is somewhat more general."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteAbelianMonoidRing|
  (progn
    (push '|FiniteAbelianMonoidRing| *Categories*)
    (make-instance '|FiniteAbelianMonoidRingType|)))

\end{chunk}

\subsection{IntervalCategory}
\index[cat]{IntervalCategory!Category}
\index[cat]{Category!IntervalCategory}
\index[cat]{INTCAT}
\begin{chunk}{defclass IntervalCategoryType}
(defclass |IntervalCategoryType| (|RadicalCategoryType| |RetractableToType|
                                  |TranscendentalFunctionCategoryType|
                                  |OrderedSetType| |GcdDomainType|)
  ((parents :initform '(|RadicalCategory| |RetractableTo|
                          |TranscendentalFunctionCategory|
                          |OrderedSet| |GcdDomain|))
   (name :initform "IntervalCategory")
   (marker :initform 'category)
   (level :initform 13)
   (abbreviation :initform 'INTCAT)
   (comment :initform (list
     "This category implements of interval arithmetic and transcendental"
     "functions over intervals."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntervalCategory|
  (progn
    (push '|IntervalCategory| *Categories*)
    (make-instance '|IntervalCategoryType|)))

\end{chunk}

\subsection{PowerSeriesCategory}
\index[cat]{PowerSeriesCategory!Category}
\index[cat]{Category!PowerSeriesCategory}
\index[cat]{PSCAT}
\begin{chunk}{defclass PowerSeriesCategoryType}
(defclass |PowerSeriesCategoryType| (|AbelianMonoidRingType|)
  ((parents :initform '(|AbelianMonoidRing|))
   (name :initform "PowerSeriesCategory")
   (marker :initform 'category)
   (level :initform 13)
   (abbreviation :initform 'PSCAT)
   (comment :initform (list
     "PowerSeriesCategory is the most general power series"
     "category with exponents in an ordered abelian monoid."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PowerSeriesCategory|
  (progn
    (push '|PowerSeriesCategory| *Categories*)
    (make-instance '|PowerSeriesCategoryType|)))

\end{chunk}

\subsection{PrincipalIdealDomain}
\index[cat]{PrincipalIdealDomain!Category}
\index[cat]{Category!PrincipalIdealDomain}
\index[cat]{PID}
\begin{chunk}{defclass PrincipalIdealDomainType}
(defclass |PrincipalIdealDomainType| (|GcdDomainType|)
  ((parents :initform '(|GcdDomain|))
   (name :initform "PrincipalIdealDomain")
   (marker :initform 'category)
   (level :initform 13)
   (abbreviation :initform 'PID)
   (comment :initform (list
     "The category of constructive principal ideal domains, that is,"
     "where a single generator can be constructively found for"
     "any ideal given by a finite set of generators."
     "Note that this constructive definition only implies that"
     "finitely generated ideals are principal. It is not clear"
     "what we would mean by an infinitely generated ideal."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PrincipalIdealDomain|
  (progn
    (push '|PrincipalIdealDomain| *Categories*)
    (make-instance '|PrincipalIdealDomainType|)))

\end{chunk}

\subsection{UniqueFactorizationDomain}
\index[cat]{UniqueFactorizationDomain!Category}
\index[cat]{Category!UniqueFactorizationDomain}
\index[cat]{UFD}
\begin{chunk}{defclass UniqueFactorizationDomainType}
(defclass |UniqueFactorizationDomainType| (|GcdDomainType|)
  ((parents :initform '(|GcdDomain|))
   (name :initform "UniqueFactorizationDomain")
   (marker :initform 'category)
   (level :initform 13)
   (abbreviation :initform 'UFD)
   (comment :initform (list
     "A constructive unique factorization domain, where"
     "we can constructively factor members into a product of"
     "a finite number of irreducible elements."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UniqueFactorizationDomain|
  (progn
    (push '|UniqueFactorizationDomain| *Categories*)
    (make-instance '|UniqueFactorizationDomainType|)))

\end{chunk}

\subsection{XPolynomialsCat}
\index[cat]{XPolynomialsCat!Category}
\index[cat]{Category!XPolynomialsCat}
\index[cat]{XPOLYC}
\begin{chunk}{defclass XPolynomialsCatType}
(defclass |XPolynomialsCatType| (|XFreeAlgebraType|)
  ((parents :initform '(|XFreeAlgebra|))
   (name :initform "XPolynomialsCat")
   (marker :initform 'category)
   (level :initform 13)
   (abbreviation :initform 'XPOLYC)
   (comment :initform (list
     "The Category of polynomial rings with non-commutative variables."
     "The coefficient ring may be non-commutative too."
     "However coefficients commute with variables."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |XPolynomialsCat|
  (progn
    (push '|XPolynomialsCat| *Categories*)
    (make-instance '|XPolynomialsCatType|)))

\end{chunk}

\section{Level 14}

\begin{chunk}{defvar level14}
(defvar level14
  '(|EuclideanDomain| |MultivariateTaylorSeriesCategory| 
    |PolynomialFactorizationExplicit| |UnivariatePowerSeriesCategory|))

\end{chunk}

\subsection{EuclideanDomain}
\index[cat]{EuclideanDomain!Category}
\index[cat]{Category!EuclideanDomain}
\index[cat]{EUCDOM}
\begin{chunk}{defclass EuclideanDomainType}
(defclass |EuclideanDomainType| (|PrincipalIdealDomainType|)
  ((parents :initform '(|PrincipalIdealDomain|))
   (name :initform "EuclideanDomain")
   (marker :initform 'category)
   (level :initform 14)
   (abbreviation :initform 'EUCDOM)
   (comment :initform (list
     "A constructive euclidean domain, one can divide producing"
     "a quotient and a remainder where the remainder is either zero"
     "or is smaller (euclideanSize) than the divisor."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |EuclideanDomain|
  (progn
    (push '|EuclideanDomain| *Categories*)
    (make-instance '|EuclideanDomainType|)))

\end{chunk}

\subsection{MultivariateTaylorSeriesCategory}
\index[cat]{MultivariateTaylorSeriesCategory!Category}
\index[cat]{Category!MultivariateTaylorSeriesCategory}
\index[cat]{MTSCAT}
\begin{chunk}{defclass MultivariateTaylorSeriesCategoryType}
(defclass |MultivariateTaylorSeriesCategoryType| (|RadicalCategoryType| 
                                                  |EvalableType| 
                                                  |TranscendentalFunctionCategoryType| 
                                                  |PartialDifferentialRingType| 
                                                  |PowerSeriesCategoryType|)
  ((parents :initform '(|RadicalCategory| 
                        |Evalable| 
                        |TranscendentalFunctionCategory| 
                        |PartialDifferentialRing| 
                        |PowerSeriesCategory|))
   (name :initform "MultivariateTaylorSeriesCategory")
   (marker :initform 'category)
   (level :initform 14)
   (abbreviation :initform 'MTSCAT)
   (comment :initform (list
     "MultivariateTaylorSeriesCategory is the most general"
     "multivariate Taylor series category."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MultivariateTaylorSeriesCategory|
  (progn
    (push '|MultivariateTaylorSeriesCategory| *Categories*)
    (make-instance '|MultivariateTaylorSeriesCategoryType|)))

\end{chunk}

\subsection{PolynomialFactorizationExplicit}
\index[cat]{PolynomialFactorizationExplicit!Category}
\index[cat]{Category!PolynomialFactorizationExplicit}
\index[cat]{PFECAT}
\begin{chunk}{defclass PolynomialFactorizationExplicitType}
(defclass |PolynomialFactorizationExplicitType| (|UniqueFactorizationDomainType|)
  ((parents :initform '(|UniqueFactorizationDomain|))
   (name :initform "PolynomialFactorizationExplicit")
   (marker :initform 'category)
   (level :initform 14)
   (abbreviation :initform 'PFECAT)
   (comment :initform (list
     "This is the category of domains that know 'enough' about"
     "themselves in order to factor univariate polynomials over themselves."
     "This will be used in future releases for supporting factorization"
     "over finitely generated coefficient fields, it is not yet available"
     "in the current release of axiom."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialFactorizationExplicit|
  (progn
    (push '|PolynomialFactorizationExplicit| *Categories*)
    (make-instance '|PolynomialFactorizationExplicitType|)))

\end{chunk}

\subsection{UnivariatePowerSeriesCategory}
\index[cat]{UnivariatePowerSeriesCategory!Category}
\index[cat]{Category!UnivariatePowerSeriesCategory}
\index[cat]{UPSCAT}
\begin{chunk}{defclass UnivariatePowerSeriesCategoryType}
(defclass |UnivariatePowerSeriesCategoryType| (|EltableType|
                                               |PowerSeriesCategoryType|
                                               |DifferentialRingType|
                                               |PartialDifferentialRingType|)
  ((parents :initform '(|Eltable|
                        |PowerSeriesCategory|
                        |DifferentialRing|
                        |PartialDifferentialRing|))
   (name :initform "UnivariatePowerSeriesCategory")
   (marker :initform 'category)
   (level :initform 14)
   (abbreviation :initform 'UPSCAT)
   (comment :initform (list
     "UnivariatePowerSeriesCategory is the most general"
     "univariate power series category with exponents in an ordered"
     "abelian monoid."
     "Note that this category exports a substitution function if it is"
     "possible to multiply exponents."
     "Also note that this category exports a derivative operation if it is"
     "possible to multiply coefficients by exponents."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariatePowerSeriesCategory|
  (progn
    (push '|UnivariatePowerSeriesCategory| *Categories*)
    (make-instance '|UnivariatePowerSeriesCategoryType|)))

\end{chunk}

\section{Level 15}

\begin{chunk}{defvar level15}
(defvar level15
  '(|Field| |IntegerNumberSystem| |PAdicIntegerCategory|
    |PolynomialCategory| |UnivariateTaylorSeriesCategory|))

\end{chunk}

\subsection{Field}
\index[cat]{Field!Category}
\index[cat]{Category!Field}
\index[cat]{FIELD}
\begin{chunk}{defclass FieldType}
(defclass |FieldType| (|DivisionRingType| |UniqueFactorizationDomainType| |EuclideanDomainType|)
  ((parents :initform '(|DivisionRing| 
                          |UniqueFactorizationDomain| |EuclideanDomain|))
   (name :initform "Field")
   (marker :initform 'category)
   (level :initform 15)
   (abbreviation :initform 'FIELD)
   (comment :initform (list
     "The category of commutative fields, commutative rings"
     "where all non-zero elements have multiplicative inverses."
     "The factor operation while trivial is useful to have defined."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Field|
  (progn
    (push '|Field| *Categories*)
    (make-instance '|FieldType|)))

\end{chunk}

\subsection{IntegerNumberSystem}
\index[cat]{IntegerNumberSystem!Category}
\index[cat]{Category!IntegerNumberSystem}
\index[cat]{INS}
\begin{chunk}{defclass IntegerNumberSystemType}
(defclass |IntegerNumberSystemType| (|CombinatorialFunctionCategoryType|
                                     |RetractableToType|
                                     |RealConstantType|
                                     |PatternMatchableType|
                                     |StepThroughType| 
                                     |CharacteristicZeroType|
                                     |DifferentialRingType|
                                     |LinearlyExplicitRingOverType|
                                     |OrderedIntegralDomainType| 
                                     |UniqueFactorizationDomainType|
                                     |EuclideanDomainType|)
  ((parents :initform '(|CombinatorialFunctionCategory|
                        |RetractableTo|
                        |RealConstant|
                        |PatternMatchable|
                        |StepThrough| 
                        |CharacteristicZero|
                        |DifferentialRing|
                        |LinearlyExplicitRingOver|
                        |OrderedIntegralDomain| 
                        |UniqueFactorizationDomain|
                        |EuclideanDomain|))
   (name :initform "IntegerNumberSystem")
   (marker :initform 'category)
   (level :initform 15)
   (abbreviation :initform 'INS)
   (comment :initform (list
     "An IntegerNumberSystem is a model for the integers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegerNumberSystem|
  (progn
    (push '|IntegerNumberSystem| *Categories*)
    (make-instance '|IntegerNumberSystemType|)))

\end{chunk}

\subsection{PAdicIntegerCategory}
\index[cat]{PAdicIntegerCategory!Category}
\index[cat]{Category!PAdicIntegerCategory}
\index[cat]{PADICCT}
\begin{chunk}{defclass PAdicIntegerCategoryType}
(defclass |PAdicIntegerCategoryType| (|CharacteristicZeroType| |EuclideanDomainType|)
  ((parents :initform '(|CharacteristicZero| |EuclideanDomain|))
   (name :initform "PAdicIntegerCategory")
   (marker :initform 'category)
   (level :initform 15)
   (abbreviation :initform 'PADICCT)
   (comment :initform (list
     "This is the category of stream-based representations of"
     "the p-adic integers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PAdicIntegerCategory|
  (progn
    (push '|PAdicIntegerCategory| *Categories*)
    (make-instance '|PAdicIntegerCategoryType|)))

\end{chunk}

\subsection{PolynomialCategory}
\index[cat]{PolynomialCategory!Category}
\index[cat]{Category!PolynomialCategory}
\index[cat]{POLYCAT}
\begin{chunk}{defclass PolynomialCategoryType}
(defclass |PolynomialCategoryType| (|ConvertibleToType|
                                    |EvalableType| 
                                    |OrderedSetType|
                                    |PatternMatchableType| 
                                    |PartialDifferentialRingType|
                                    |FullyLinearlyExplicitRingOverType|
                                    |FiniteAbelianMonoidRingType| 
                                    |PolynomialFactorizationExplicitType|)
  ((parents :initform '(|ConvertibleTo|
                        |Evalable| 
                        |OrderedSet|
                        |PatternMatchable| 
                        |PartialDifferentialRing|
                        |FullyLinearlyExplicitRingOver|
                        |FiniteAbelianMonoidRing| 
                        |PolynomialFactorizationExplicit|))
   (name :initform "PolynomialCategory")
   (marker :initform 'category)
   (level :initform 15)
   (abbreviation :initform 'POLYCAT)
   (comment :initform (list
     "The category for general multi-variate polynomials over a ring"
     "R, in variables from VarSet, with exponents from the OrderedAbelianMonoidSup."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialCategory|
  (progn
    (push '|PolynomialCategory| *Categories*)
    (make-instance '|PolynomialCategoryType|)))

\end{chunk}

\subsection{UnivariateTaylorSeriesCategory}
\index[cat]{UnivariateTaylorSeriesCategory!Category}
\index[cat]{Category!UnivariateTaylorSeriesCategory}
\index[cat]{UTSCAT}
\begin{chunk}{defclass UnivariateTaylorSeriesCategoryType}
(defclass |UnivariateTaylorSeriesCategoryType| (|RadicalCategoryType| 
                                                |TranscendentalFunctionCategoryType| 
                                                |UnivariatePowerSeriesCategoryType|)
  ((parents :initform '(|RadicalCategory| 
                        |TranscendentalFunctionCategory|
                        |UnivariatePowerSeriesCategory|))
   (name :initform "UnivariateTaylorSeriesCategory")
   (marker :initform 'category)
   (level :initform 15)
   (abbreviation :initform 'UTSCAT)
   (comment :initform (list
     "UnivariateTaylorSeriesCategory is the category of Taylor"
     "series in one variable."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariateTaylorSeriesCategory|
  (progn
    (push '|UnivariateTaylorSeriesCategory| *Categories*)
    (make-instance '|UnivariateTaylorSeriesCategoryType|)))

\end{chunk}

\section{Level 16}

\begin{chunk}{defvar level16}
(defvar level16
 '(|AlgebraicallyClosedField| |DifferentialPolynomialCategory|
   |FieldOfPrimeCharacteristic| |FunctionSpace| |LocalPowerSeriesCategory|
   |PseudoAlgebraicClosureOfPerfectFieldCategory| |QuotientFieldCategory|
   |RealClosedField| |RealNumberSystem| |RecursivePolynomialCategory|
   |UnivariateLaurentSeriesCategory| |UnivariatePolynomialCategory|
   |UnivariatePuiseuxSeriesCategory|))

\end{chunk}

\subsection{AlgebraicallyClosedField}
\index[cat]{AlgebraicallyClosedField!Category}
\index[cat]{Category!AlgebraicallyClosedField}
\index[cat]{ACF}
\begin{chunk}{defclass AlgebraicallyClosedFieldType}
(defclass |AlgebraicallyClosedFieldType| (|RadicalCategoryType| |FieldType|)
  ((parents :initform '(|RadicalCategory| |Field|))
   (name :initform "AlgebraicallyClosedField")
   (marker :initform 'category)
   (level :initform 16)
   (abbreviation :initform 'ACF)
   (comment :initform (list
     "Model for algebraically closed fields."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AlgebraicallyClosedField|
  (progn
    (push '|AlgebraicallyClosedField| *Categories*)
    (make-instance '|AlgebraicallyClosedFieldType|)))

\end{chunk}

\subsection{DifferentialPolynomialCategory}
\index[cat]{DifferentialPolynomialCategory!Category}
\index[cat]{Category!DifferentialPolynomialCategory}
\index[cat]{DPOLCAT}
\begin{chunk}{defclass DifferentialPolynomialCategoryType}
(defclass |DifferentialPolynomialCategoryType| (|DifferentialExtensionType| |PolynomialCategoryType|)
  ((parents :initform '(|DifferentialExtension| 
                        |PolynomialCategory|))
   (name :initform "DifferentialPolynomialCategory")
   (marker :initform 'category)
   (level :initform 16)
   (abbreviation :initform 'DPOLCAT)
   (comment :initform (list
     "DifferentialPolynomialCategory is a category constructor"
     "specifying basic functions in an ordinary differential polynomial"
     "ring with a given ordered set of differential indeterminates."
     "In addition, it implements defaults for the basic functions."
     "The functions order and weight are extended"
     "from the set of derivatives of differential indeterminates"
     "to the set of differential polynomials.  Other operations"
     "provided on differential polynomials are"
     "leader, initial,"
     "separant, differentialVariables, and"
     "isobaric?.   Furthermore, if the ground ring is"
     "a differential ring, then evaluation (substitution"
     "of differential indeterminates by elements of the ground ring"
     "or by differential polynomials) is"
     "provided by eval."
     "A convenient way of referencing derivatives is provided by"
     "the functions makeVariable."
     " "
     "To construct a domain using this constructor, one needs"
     "to provide a ground ring R, an ordered set S of differential"
     "indeterminates, a ranking V on the set of derivatives"
     "of the differential indeterminates, and a set E of"
     "exponents in bijection with the set of differential monomials"
     "in the given differential indeterminates."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DifferentialPolynomialCategory|
  (progn
    (push '|DifferentialPolynomialCategory| *Categories*)
    (make-instance '|DifferentialPolynomialCategoryType|)))

\end{chunk}

\subsection{FieldOfPrimeCharacteristic}
\index[cat]{FieldOfPrimeCharacteristic!Category}
\index[cat]{Category!FieldOfPrimeCharacteristic}
\index[cat]{FPC}
\begin{chunk}{defclass FieldOfPrimeCharacteristicType}
(defclass |FieldOfPrimeCharacteristicType| (|CharacteristicNonZeroType| |FieldType|)
  ((parents :initform '(|CharacteristicNonZero| |Field|))
   (name :initform "FieldOfPrimeCharacteristic")
   (marker :initform 'category)
   (level :initform 16)
   (abbreviation :initform 'FPC)
   (comment :initform (list
     "FieldOfPrimeCharacteristic is the category of fields of prime"
     "characteristic, for example, finite fields, algebraic closures of"
     "fields of prime characteristic, transcendental extensions of"
     "of fields of prime characteristic."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FieldOfPrimeCharacteristic|
  (progn
    (push '|FieldOfPrimeCharacteristic| *Categories*)
    (make-instance '|FieldOfPrimeCharacteristicType|)))

\end{chunk}

\subsection{FunctionSpace}
\index[cat]{FunctionSpace!Category}
\index[cat]{Category!FunctionSpace}
\index[cat]{FS}
\begin{chunk}{defclass FunctionSpaceType}
(defclass |FunctionSpaceType| (|PatternableType|
                               |FullyRetractableToType|
                               |ExpressionSpaceType|
                               |FullyPatternMatchableType|
                               |GroupType|
                               |CharacteristicNonZeroType|
                               |CharacteristicZeroType| 
                               |PartialDifferentialRingType| 
                               |FullyLinearlyExplicitRingOverType| 
                               |FieldType|)
  ((parents :initform '(|Patternable|
                        |FullyRetractableTo|
                        |ExpressionSpace|
                        |FullyPatternMatchable|
                        |Group|
                        |CharacteristicNonZero|
                        |CharacteristicZero| 
                        |PartialDifferentialRing| 
                        |FullyLinearlyExplicitRingOver| 
                        |Field|))
   (name :initform "FunctionSpace")
   (marker :initform 'category)
   (level :initform 16)
   (abbreviation :initform 'FS)
   (comment :initform (list
     "A space of formal functions with arguments in an arbitrary ordered set."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionSpace|
  (progn
    (push '|FunctionSpace| *Categories*)
    (make-instance '|FunctionSpaceType|)))

\end{chunk}

\subsection{LocalPowerSeriesCategory}
\index[cat]{LocalPowerSeriesCategory!Category}
\index[cat]{Category!LocalPowerSeriesCategory}
\index[cat]{LOCPOWC}
\begin{chunk}{defclass LocalPowerSeriesCategoryType}
(defclass |LocalPowerSeriesCategoryType| (|UnivariatePowerSeriesCategoryType| |FieldType|)
  ((parents :initform '(|UnivariatePowerSeriesCategory| |Field|))
   (name :initform "LocalPowerSeriesCategory")
   (marker :initform 'category)
   (level :initform 16)
   (abbreviation :initform 'LOCPOWC)
   (comment :initform nil)
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LocalPowerSeriesCategory|
  (progn
    (push '|LocalPowerSeriesCategory| *Categories*)
    (make-instance '|LocalPowerSeriesCategoryType|)))

\end{chunk}

\subsection{PseudoAlgebraicClosureOfPerfectFieldCategory}
\index[cat]{PseudoAlgebraicClosureOfPerfectFieldCategory!Category}
\index[cat]{Category!PseudoAlgebraicClosureOfPerfectFieldCategory}
\index[cat]{PACPERC}
\begin{chunk}{defclass PseudoAlgebraicClosureOfPerfectFieldCategoryType}
(defclass |PseudoAlgebraicClosureOfPerfectFieldCategoryType| (|FieldType|)
  ((parents :initform '(|Field|))
   (name :initform "PseudoAlgebraicClosureOfPerfectFieldCategory")
   (marker :initform 'category)
   (level :initform 16)
   (abbreviation :initform 'PACPERC)
   (comment :initform (list
     "This category exports the function for domains"
     "which implement dynamic extension using the simple notion of tower"
     "extensions."
     "A tower extension T of the ground"
     "field K is any sequence of field extension "
     "(T : K_0, K_1, ..., K_i...,K_n) where K_0 = K"
     "and for i =1,2,...,n, K_i is an extension of K_{i-1} of degree > 1"
     "and defined by an irreducible polynomial p(Z) in K_{i-1}."
     "Two towers (T_1: K_01, K_11,...,K_i1,...,K_n1)"
     "and (T_2: K_02, K_12,...,K_i2,...,K_n2)"
     "are said to be related if T_1 <= T_2 (or T_1 >= T_2),"
     "that is if K_i1 = K_i2 for i=1,2,...,n1 (or i=1,2,...,n2)."
     "Any algebraic operations defined for several elements" 
     "are only defined if all of the concerned elements are coming from"
     "a set of related tower extensions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PseudoAlgebraicClosureOfPerfectFieldCategory|
  (progn
    (push '|PseudoAlgebraicClosureOfPerfectFieldCategory| *Categories*)
    (make-instance '|PseudoAlgebraicClosureOfPerfectFieldCategoryType|)))

\end{chunk}

\subsection{QuotientFieldCategory}
\index[cat]{QuotientFieldCategory!Category}
\index[cat]{Category!QuotientFieldCategory}
\index[cat]{QFCAT}
\begin{chunk}{defclass QuotientFieldCategoryType}
(defclass |QuotientFieldCategoryType| (|PatternableType| 
                                       |RetractableToType| 
                                       |RealConstantType| 
                                       |FullyEvalableOverType| 
                                       |StepThroughType|
                                       |FullyPatternMatchableType|
                                       |CharacteristicNonZeroType| 
                                       |CharacteristicZeroType| 
                                       |DifferentialExtensionType|
                                       |FullyLinearlyExplicitRingOverType| 
                                       |OrderedIntegralDomainType| 
                                       |PolynomialFactorizationExplicitType|
                                       |FieldType|)
  ((parents :initform '(|Patternable| 
                        |RetractableTo| 
                        |RealConstant| 
                        |FullyEvalableOver| 
                        |StepThrough|
                        |FullyPatternMatchable|
                        |CharacteristicNonZero| 
                        |CharacteristicZero| 
                        |DifferentialExtension|
                        |FullyLinearlyExplicitRingOver| 
                        |OrderedIntegralDomain| 
                        |PolynomialFactorizationExplicit|
                        |Field|))
   (name :initform "QuotientFieldCategory")
   (marker :initform 'category)
   (level :initform 16)
   (abbreviation :initform 'QFCAT)
   (comment :initform (list
     "QuotientField(S) is the category of fractions of an Integral Domain S."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |QuotientFieldCategory|
  (progn
    (push '|QuotientFieldCategory| *Categories*)
    (make-instance '|QuotientFieldCategoryType|)))

\end{chunk}

\subsection{RealClosedField}
\index[cat]{RealClosedField!Category}
\index[cat]{Category!RealClosedField}
\index[cat]{RCFIELD}
\begin{chunk}{defclass RealClosedFieldType}
(defclass |RealClosedFieldType| (|RadicalCategoryType| |FullyRetractableToType| 
                                 |CharacteristicZeroType| |OrderedRingType| 
                                 |FieldType|)
  ((parents :initform '(|RadicalCategory| |FullyRetractableTo| 
                        |CharacteristicZero| |OrderedRing| 
                        |Field|))
   (name :initform "RealClosedField")
   (marker :initform 'category)
   (level :initform 16)
   (abbreviation :initform 'RCFIELD)
   (comment :initform (list
     "RealClosedField provides common access"
     "functions for all real closed fields."
     "provides computations with generic real roots of polynomials"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RealClosedField|
  (progn
    (push '|RealClosedField| *Categories*)
    (make-instance '|RealClosedFieldType|)))

\end{chunk}

\subsection{RealNumberSystem}
\index[cat]{RealNumberSystem!Category}
\index[cat]{Category!RealNumberSystem}
\index[cat]{RNS}
\begin{chunk}{defclass RealNumberSystemType}
(defclass |RealNumberSystemType| (|RadicalCategoryType| |RetractableToType| 
                                  |RealConstantType| |PatternMatchableType|
                                  |CharacteristicZeroType| |OrderedRingType| |FieldType|)
  ((parents :initform '(|RadicalCategory| |RetractableTo| 
                        |RealConstant| |PatternMatchable|
                        |CharacteristicZero| |OrderedRing| |Field|))
   (name :initform "RealNumberSystem")
   (marker :initform 'category)
   (level :initform 16)
   (abbreviation :initform 'RNS)
   (comment :initform (list
     "The real number system category is intended as a model for the real"
     "numbers.  The real numbers form an ordered normed field.  Note that"
     "we have purposely not included DifferentialRing or"
     "the elementary functions (see TranscendentalFunctionCategory)"
     "in the definition."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RealNumberSystem|
  (progn
    (push '|RealNumberSystem| *Categories*)
    (make-instance '|RealNumberSystemType|)))

\end{chunk}

\subsection{RecursivePolynomialCategory}
\index[cat]{RecursivePolynomialCategory!Category}
\index[cat]{Category!RecursivePolynomialCategory}
\index[cat]{RPOLCAT}
\begin{chunk}{defclass RecursivePolynomialCategoryType}
(defclass |RecursivePolynomialCategoryType| (|PolynomialCategoryType|)
  ((parents :initform '(|PolynomialCategory|))
   (name :initform "RecursivePolynomialCategory")
   (marker :initform 'category)
   (level :initform 16)
   (abbreviation :initform 'RPOLCAT)
   (comment :initform nil)
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RecursivePolynomialCategory|
  (progn
    (push '|RecursivePolynomialCategory| *Categories*)
    (make-instance '|RecursivePolynomialCategoryType|)))

\end{chunk}

\subsection{UnivariateLaurentSeriesCategory}
\index[cat]{UnivariateLaurentSeriesCategory!Category}
\index[cat]{Category!UnivariateLaurentSeriesCategory}
\index[cat]{ULSCAT}
\begin{chunk}{defclass UnivariateLaurentSeriesCategoryType}
(defclass |UnivariateLaurentSeriesCategoryType| (|RadicalCategoryType| 
                                                 |TranscendentalFunctionCategoryType|
                                                 |UnivariatePowerSeriesCategoryType|
                                                 |FieldType|)
  ((parents :initform '(|RadicalCategory| 
                        |TranscendentalFunctionCategory|
                        |UnivariatePowerSeriesCategory|
                        |Field|))
   (name :initform "UnivariateLaurentSeriesCategory")
   (marker :initform 'category)
   (level :initform 16)
   (abbreviation :initform 'ULSCAT)
   (comment :initform (list
     "UnivariateLaurentSeriesCategory is the category of"
     "Laurent series in one variable."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariateLaurentSeriesCategory|
  (progn
    (push '|UnivariateLaurentSeriesCategory| *Categories*)
    (make-instance '|UnivariateLaurentSeriesCategoryType|)))

\end{chunk}

\subsection{UnivariatePolynomialCategory}
\index[cat]{UnivariatePolynomialCategory!Category}
\index[cat]{Category!UnivariatePolynomialCategory}
\index[cat]{UPOLYC}
\begin{chunk}{defclass UnivariatePolynomialCategoryType}
(defclass |UnivariatePolynomialCategoryType| (|EltableType| |StepThroughType|
                                              |DifferentialExtensionType| 
                                              |EuclideanDomainType|
                                              |PolynomialCategoryType|)
  ((parents :initform '(|Eltable| |StepThrough| 
                        |DifferentialExtension| 
                        |EuclideanDomain|
                        |PolynomialCategory|))
   (name :initform "UnivariatePolynomialCategory")
   (marker :initform 'category)
   (level :initform 16)
   (abbreviation :initform 'UPOLYC)
   (comment :initform (list
     "The category of univariate polynomials over a ring R."
     "No particular model is assumed - implementations can be either"
     "sparse or dense."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariatePolynomialCategory|
  (progn
    (push '|UnivariatePolynomialCategory| *Categories*)
    (make-instance '|UnivariatePolynomialCategoryType|)))

\end{chunk}

\subsection{UnivariatePuiseuxSeriesCategory}
\index[cat]{UnivariatePuiseuxSeriesCategory!Category}
\index[cat]{Category!UnivariatePuiseuxSeriesCategory}
\index[cat]{UPXSCAT}
\begin{chunk}{defclass UnivariatePuiseuxSeriesCategoryType}
(defclass |UnivariatePuiseuxSeriesCategoryType| (|RadicalCategoryType| 
                                                 |TranscendentalFunctionCategoryType|
                                                 |UnivariatePowerSeriesCategoryType|
                                                 |FieldType|)
  ((parents :initform '(|RadicalCategory| 
                        |TranscendentalFunctionCategory|
                        |UnivariatePowerSeriesCategory|
                        |Field|))
   (name :initform "UnivariatePuiseuxSeriesCategory")
   (marker :initform 'category)
   (level :initform 16)
   (abbreviation :initform 'UPXSCAT)
   (comment :initform (list
     "UnivariatePuiseuxSeriesCategory is the category of Puiseux"
     "series in one variable."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariatePuiseuxSeriesCategory|
  (progn
    (push '|UnivariatePuiseuxSeriesCategory| *Categories*)
    (make-instance '|UnivariatePuiseuxSeriesCategoryType|)))

\end{chunk}

\section{Level 17}

\begin{chunk}{defvar level17}
(defvar level17
  '(|AlgebraicallyClosedFunctionSpace| |ExtensionField| |FiniteFieldCategory|
    |FloatingPointSystem| |UnivariateLaurentSeriesConstructorCategory|
    |UnivariatePuiseuxSeriesConstructorCategory|))

\end{chunk}

\subsection{AlgebraicallyClosedFunctionSpace}
\index[cat]{AlgebraicallyClosedFunctionSpace!Category}
\index[cat]{Category!AlgebraicallyClosedFunctionSpace}
\index[cat]{ACFS}
\begin{chunk}{defclass AlgebraicallyClosedFunctionSpaceType}
(defclass |AlgebraicallyClosedFunctionSpaceType| (|AlgebraicallyClosedFieldType| |FunctionSpaceType|)
  ((parents :initform '(|AlgebraicallyClosedField| |FunctionSpace|))
   (name :initform "AlgebraicallyClosedFunctionSpace")
   (marker :initform 'category)
   (level :initform 17)
   (abbreviation :initform 'ACFS)
   (comment :initform (list
     "Model for algebraically closed function spaces."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AlgebraicallyClosedFunctionSpace|
  (progn
    (push '|AlgebraicallyClosedFunctionSpace| *Categories*)
    (make-instance '|AlgebraicallyClosedFunctionSpaceType|)))

\end{chunk}

\subsection{ExtensionField}
\index[cat]{ExtensionField!Category}
\index[cat]{Category!ExtensionField}
\index[cat]{XF}
\begin{chunk}{defclass ExtensionFieldType}
(defclass |ExtensionFieldType| (|RetractableToType|
                                |CharacteristicZeroType| 
                                |VectorSpaceType| 
                                |FieldOfPrimeCharacteristicType|)
  ((parents :initform '(|RetractableTo|
                        |CharacteristicZero| 
                        |VectorSpace|
                        |FieldOfPrimeCharacteristic|))
   (name :initform "ExtensionField")
   (marker :initform 'category)
   (level :initform 17)
   (abbreviation :initform 'XF)
   (comment :initform (list
     "ExtensionField F is the category of fields which extend the field F"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExtensionField|
  (progn
    (push '|ExtensionField| *Categories*)
    (make-instance '|ExtensionFieldType|)))

\end{chunk}

\subsection{FiniteFieldCategory}
\index[cat]{FiniteFieldCategory!Category}
\index[cat]{Category!FiniteFieldCategory}
\index[cat]{FFIELDC}
\begin{chunk}{defclass FiniteFieldCategoryType}
(defclass |FiniteFieldCategoryType| (|FiniteType| |StepThroughType| 
                                     |DifferentialRingType| 
                                     |FieldOfPrimeCharacteristicType|)
  ((parents :initform '(|Finite| |StepThrough| 
                        |DifferentialRing| 
                        |FieldOfPrimeCharacteristic|))
   (name :initform "FiniteFieldCategory")
   (marker :initform 'category)
   (level :initform 17)
   (abbreviation :initform 'FFIELDC)
   (comment :initform (list
     "FiniteFieldCategory is the category of finite fields"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldCategory|
  (progn
    (push '|FiniteFieldCategory| *Categories*)
    (make-instance '|FiniteFieldCategoryType|)))

\end{chunk}

\subsection{FloatingPointSystem}
\index[cat]{FloatingPointSystem!Category}
\index[cat]{Category!FloatingPointSystem}
\index[cat]{FPS}
\begin{chunk}{defclass FloatingPointSystemType}
(defclass |FloatingPointSystemType| (|RealNumberSystemType|)
  ((parents :initform '(|RealNumberSystem|))
   (name :initform "FloatingPointSystem")
   (marker :initform 'category)
   (level :initform 17)
   (abbreviation :initform 'FPS)
   (comment :initform (list
     "This category is intended as a model for floating point systems."
     "A floating point system is a model for the real numbers.  In fact,"
     "it is an approximation in the sense that not all real numbers are"
     "exactly representable by floating point numbers."
     "A floating point system is characterized by the following:"
     " "
     "1: base of the exponent where the actual implemenations are" 
     "usually binary or decimal)"
     "2: precision of the mantissa (arbitrary or fixed)"
     "3: rounding error for operations"
      " "
     "Because a Float is an approximation to the real numbers, even though"
     "it is defined to be a join of a Field and OrderedRing, some of"
     "the attributes do not hold.  In particular associative('+')"
     "does not hold.  Algorithms defined over a field need special"
     "considerations when the field is a floating point system."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FloatingPointSystem|
  (progn
    (push '|FloatingPointSystem| *Categories*)
    (make-instance '|FloatingPointSystemType|)))

\end{chunk}

\subsection{UnivariateLaurentSeriesConstructorCategory}
\index[cat]{UnivariateLaurentSeriesConstructorCategory!Category}
\index[cat]{Category!UnivariateLaurentSeriesConstructorCategory}
\index[cat]{ULSCCAT}
\begin{chunk}{defclass UnivariateLaurentSeriesConstructorCategoryType}
(defclass |UnivariateLaurentSeriesConstructorCategoryType| (
     |QuotientFieldCategoryType| |UnivariateLaurentSeriesCategoryType|)
  ((parents :initform '(
     |QuotientFieldCategory| |UnivariateLaurentSeriesCategory|))
   (name :initform "UnivariateLaurentSeriesConstructorCategory")
   (marker :initform 'category)
   (level :initform 17)
   (abbreviation :initform 'ULSCCAT)
   (comment :initform (list
     "This is a category of univariate Laurent series constructed from"
     "univariate Taylor series.  A Laurent series is represented by a pair"
     "[n,f(x)], where n is an arbitrary integer and f(x)"
     "is a Taylor series.  This pair represents the Laurent series"
     "x**n * f(x)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariateLaurentSeriesConstructorCategory|
  (progn
    (push '|UnivariateLaurentSeriesConstructorCategory| *Categories*)
    (make-instance '|UnivariateLaurentSeriesConstructorCategoryType|)))

\end{chunk}

\subsection{UnivariatePuiseuxSeriesConstructorCategory}
\index[cat]{UnivariatePuiseuxSeriesConstructorCategory!Category}
\index[cat]{Category!UnivariatePuiseuxSeriesConstructorCategory}
\index[cat]{UPXSCCA}
\begin{chunk}{defclass UnivariatePuiseuxSeriesConstructorCategoryType}
(defclass |UnivariatePuiseuxSeriesConstructorCategoryType| (|RetractableToType|
                                                            |UnivariatePuiseuxSeriesCategoryType|)
  ((parents :initform '(|RetractableTo| |UnivariatePuiseuxSeriesCategory|))
   (name :initform "UnivariatePuiseuxSeriesConstructorCategory")
   (marker :initform 'category)
   (level :initform 17)
   (abbreviation :initform 'UPXSCCA)
   (comment :initform (list
     "This is a category of univariate Puiseux series constructed"
     "from univariate Laurent series.  A Puiseux series is represented"
     "by a pair [r,f(x)], where r is a positive rational number and"
     "f(x) is a Laurent series.  This pair represents the Puiseux"
     "series f(x^r)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariatePuiseuxSeriesConstructorCategory|
  (progn
    (push '|UnivariatePuiseuxSeriesConstructorCategory| *Categories*)
    (make-instance '|UnivariatePuiseuxSeriesConstructorCategoryType|)))

\end{chunk}

\section{Level 18}

\begin{chunk}{defvar level18}
(defvar level18
  '(|FiniteAlgebraicExtensionField| |MonogenicAlgebra|
    |PseudoAlgebraicClosureOfFiniteFieldCategory|
    |PseudoAlgebraicClosureOfRationalNumberCategory|))

\end{chunk}

\subsection{FiniteAlgebraicExtensionField}
\index[cat]{FiniteAlgebraicExtensionField!Category}
\index[cat]{Category!FiniteAlgebraicExtensionField}
\index[cat]{FAXF}
\begin{chunk}{defclass FiniteAlgebraicExtensionFieldType}
(defclass |FiniteAlgebraicExtensionFieldType| (|FiniteFieldCategoryType| |ExtensionFieldType|)
  ((parents :initform '(|FiniteFieldCategory| |ExtensionField|))
   (name :initform "FiniteAlgebraicExtensionField")
   (marker :initform 'category)
   (level :initform 18)
   (abbreviation :initform 'FAXF)
   (comment :initform (list
     "FiniteAlgebraicExtensionField F is the category of fields"
     "which are finite algebraic extensions of the field F."
     "If F is finite then any finite algebraic extension of F"
     "is finite, too. Let K be a finite algebraic extension of the"
     "finite field F. The exponentiation of elements of K"
     "defines a Z-module structure on the multiplicative group of K."
     "The additive group of K becomes a module over the ring of"
     "polynomials over F via the operation"
     "linearAssociatedExp(a:K,f:SparseUnivariatePolynomial F)"
     "which is linear over F, that is, for elements a from K,"
     "c,d from F and f,g univariate polynomials over F"
     "we have linearAssociatedExp(a,cf+dg) equals c times"
     "linearAssociatedExp(a,f) plus d times"
     "linearAssociatedExp(a,g)."
     "Therefore linearAssociatedExp is defined completely by"
     "its action on  monomials from F[X]:"
     "linearAssociatedExp(a,monomial(1,k)$SUP(F)) is defined to be"
     "Frobenius(a,k) which is a**(q**k) where q=size()$F."
     "The operations order and discreteLog associated with the multiplicative"
     "exponentiation have additive analogues associated to the operation"
     "linearAssociatedExp. These are the functions"
     "linearAssociatedOrder and linearAssociatedLog,"
     "respectively."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteAlgebraicExtensionField|
  (progn
    (push '|FiniteAlgebraicExtensionField| *Categories*)
    (make-instance '|FiniteAlgebraicExtensionFieldType|)))

\end{chunk}

\subsection{MonogenicAlgebra}
\index[cat]{MonogenicAlgebra!Category}
\index[cat]{Category!MonogenicAlgebra}
\index[cat]{MONOGEN}
\begin{chunk}{defclass MonogenicAlgebraType}
(defclass |MonogenicAlgebraType| (|ConvertibleToType| |FullyRetractableToType|
                                  |DifferentialExtensionType|
                                  |FullyLinearlyExplicitRingOverType|
                                  |FramedAlgebraType| |FiniteFieldCategoryType|)
  ((parents :initform '(|ConvertibleTo| |FullyRetractableTo|
                        |DifferentialExtension|
                        |FullyLinearlyExplicitRingOver|
                        |FramedAlgebra| |FiniteFieldCategory|))
   (name :initform "MonogenicAlgebra")
   (marker :initform 'category)
   (level :initform 18)
   (abbreviation :initform 'MONOGEN)
   (comment :initform (list
     "A MonogenicAlgebra is an algebra of finite rank which"
     "can be generated by a single element."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MonogenicAlgebra|
  (progn
    (push '|MonogenicAlgebra| *Categories*)
    (make-instance '|MonogenicAlgebraType|)))

\end{chunk}

\subsection{PseudoAlgebraicClosureOfFiniteFieldCategory}
\index[cat]{PseudoAlgebraicClosureOfFiniteFieldCategory!Category}
\index[cat]{Category!PseudoAlgebraicClosureOfFiniteFieldCategory}
\index[cat]{PACFFC}
\begin{chunk}{defclass PseudoAlgebraicClosureOfFiniteFieldCategoryType}
(defclass |PseudoAlgebraicClosureOfFiniteFieldCategoryType| (
    |PseudoAlgebraicClosureOfPerfectFieldCategoryType| |FiniteFieldCategoryType|)
  ((parents :initform '(
     |PseudoAlgebraicClosureOfPerfectFieldCategory| |FiniteFieldCategory|))
   (name :initform "PseudoAlgebraicClosureOfFiniteFieldCategory")
   (marker :initform 'category)
   (level :initform 18)
   (abbreviation :initform 'PACFFC)
   (comment :initform (list
     "This category exports the function for the domain"
     "PseudoAlgebraicClosureOfFiniteField which implement dynamic extension"
     "using the simple notion of tower extensions."
     "A tower extension T of the ground"
     "field K is any sequence of field extension (T : K_0, K_1, ..., K_i...,K_n)"
     "where K_0 = K and for i =1,2,...,n, K_i is an extension"
     "of K_{i-1} of degree > 1 and defined by an irreducible polynomial"
     "p(Z) in K_{i-1}."
     "Two towers (T_1: K_01, K_11,...,K_i1,...,K_n1)"
     "and (T_2: K_02, K_12,...,K_i2,...,K_n2)"
     "are said to be related if T_1 <= T_2 (or T_1 >= T_2),"
     "that is if K_i1 = K_i2 for i=1,2,...,n1"
     "(or i=1,2,...,n2). Any algebraic operations defined for several elements"
     "are only defined if all of the concerned elements are comming from"
     "a set of related tour extensions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PseudoAlgebraicClosureOfFiniteFieldCategory|
  (progn
    (push '|PseudoAlgebraicClosureOfFiniteFieldCategory| *Categories*)
    (make-instance '|PseudoAlgebraicClosureOfFiniteFieldCategoryType|)))

\end{chunk}

\subsection{PseudoAlgebraicClosureOfRationalNumberCategory}
\index[cat]{PseudoAlgebraicClosureOfRationalNumberCategory!Category}
\index[cat]{Category!PseudoAlgebraicClosureOfRationalNumberCategory}
\index[cat]{PACRATC}
\begin{chunk}{defclass PseudoAlgebraicClosureOfRationalNumberCategoryType}
(defclass |PseudoAlgebraicClosureOfRationalNumberCategoryType| (
                 |ExtensionFieldType| |PseudoAlgebraicClosureOfPerfectFieldCategoryType|)
  ((parents :initform '(|ExtensionField| |PseudoAlgebraicClosureOfPerfectFieldCategory|))
   (name :initform "PseudoAlgebraicClosureOfRationalNumberCategory")
   (marker :initform 'category)
   (level :initform 18)
   (abbreviation :initform 'PACRATC)
   (comment :initform (list
     "This category exports the function for the domain"
     "PseudoAlgebraicClosureOfRationalNumber"
     "which implement dynamic extension using the simple notion of tower"
     "extensions. A tower extension T of the ground"
     "field K is any sequence of field extension (T : K_0, K_1, ..., K_i...,K_n)"
     "where K_0 = K and for i =1,2,...,n, K_i is an extension"
     "of K_{i-1} of degree > 1 and defined by an irreducible polynomial"
     "p(Z) in K_{i-1}."
     "Two towers (T_1: K_01, K_11,...,K_i1,...,K_n1)"
     "and (T_2: K_02, K_12,...,K_i2,...,K_n2)"
     "are said to be related if T_1 <= T_2 (or T_1 >= T_2),"
     "that is if K_i1 = K_i2 for i=1,2,...,n1"
     "(or i=1,2,...,n2). Any algebraic operations defined for several elements"
     "are only defined if all of the concerned elements are comming from"
     "a set of related tour extensions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PseudoAlgebraicClosureOfRationalNumberCategory|
  (progn
    (push '|PseudoAlgebraicClosureOfRationalNumberCategory| *Categories*)
    (make-instance '|PseudoAlgebraicClosureOfRationalNumberCategoryType|)))

\end{chunk}

\section{Level 19}

\begin{chunk}{defvar level19}
(defvar level19
  '(|ComplexCategory| |FunctionFieldCategory|
    |PseudoAlgebraicClosureOfAlgExtOfRationalNumberCategory|))

\end{chunk}

\subsection{ComplexCategory}
\index[cat]{ComplexCategory!Category}
\index[cat]{Category!ComplexCategory}
\index[cat]{COMPCAT}
\begin{chunk}{defclass ComplexCategoryType}
(defclass |ComplexCategoryType| (|PatternableType| |RadicalCategoryType| 
                                 |TranscendentalFunctionCategoryType| 
                                 |FullyEvalableOverType| |OrderedSetType| 
                                 |FullyPatternMatchableType| 
                                 |PolynomialFactorizationExplicitType| 
                                 |MonogenicAlgebraType|)
  ((parents :initform '(|Patternable| |RadicalCategory| 
                        |TranscendentalFunctionCategory| 
                        |FullyEvalableOver| |OrderedSet| 
                        |FullyPatternMatchable| 
                        |PolynomialFactorizationExplicit| 
                        |MonogenicAlgebra|))
   (name :initform "ComplexCategory")
   (marker :initform 'category)
   (level :initform 19)
   (abbreviation :initform 'COMPCAT)
   (comment :initform (list
     "This category represents the extension of a ring by a square root of -1."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ComplexCategory|
  (progn
    (push '|ComplexCategory| *Categories*)
    (make-instance '|ComplexCategoryType|)))

\end{chunk}

\subsection{FunctionFieldCategory}
\index[cat]{FunctionFieldCategory!Category}
\index[cat]{Category!FunctionFieldCategory}
\index[cat]{FFCAT}
\begin{chunk}{defclass FunctionFieldCategoryType}
(defclass |FunctionFieldCategoryType| (|MonogenicAlgebraType|)
  ((parents :initform '(|MonogenicAlgebra|))
   (name :initform "FunctionFieldCategory")
   (marker :initform 'category)
   (level :initform 19)
   (abbreviation :initform 'FFCAT)
   (comment :initform (list
     "This category is a model for the function field of a"
     "plane algebraic curve."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionFieldCategory|
  (progn
    (push '|FunctionFieldCategory| *Categories*)
    (make-instance '|FunctionFieldCategoryType|)))

\end{chunk}

\subsection{PseudoAlgebraicClosureOfAlgExtOfRationalNumberCategory}
\index[cat]{PseudoAlgebraicClosureOfAlgExtOfRationalNumberCategory!Category}
\index[cat]{Category!PseudoAlgebraicClosureOfAlgExtOfRationalNumberCategory}
\index[cat]{PACEXTC}
\begin{chunk}{defclass PseudoAlgebraicClosureOfAlgExtOfRationalNumberCategoryType}
(defclass |PseudoAlgebraicClosureOfAlgExtOfRationalNumberCategoryType| (
             |PseudoAlgebraicClosureOfRationalNumberCategoryType|)
  ((parents :initform '(|PseudoAlgebraicClosureOfRationalNumberCategory|))
   (name :initform "PseudoAlgebraicClosureOfAlgExtOfRationalNumberCategory")
   (marker :initform 'category)
   (level :initform 19)
   (abbreviation :initform 'PACEXTC)
   (comment :initform (list
     "This category exports the function for the domain"
     "PseudoAlgebraicClosureOfAlgExtOfRationalNumber which implement dynamic"
     "extension using the simple notion of tower extensions. A tower extension"
     "T of the ground field K is any sequence of field extension"
     "(T : K0, K1, ..., Ki...,Kn) where K0 = K and for i =1,2,...,n,"
     "Ki is an extension of K{i-1} of degree > 1 and defined by an"
     "irreducible polynomial p(Z) in K{i-1}."
     "Two towers (T1: K01, K11,...,Ki1,...,Kn1) and"
     "(T2: K02, K12,...,Ki2,...,Kn2)"
     "are said to be related if T1 <= T2 (or T1 >= T2),"
     "that is if Ki1 = Ki2 for i=1,2,...,n1 (or i=1,2,...,n2)."
     "Any algebraic operations defined for several elements"
     "are only defined if all of the concerned elements are comming from"
     "a set of related tour extensions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PseudoAlgebraicClosureOfAlgExtOfRationalNumberCategory|
  (progn
    (push '|PseudoAlgebraicClosureOfAlgExtOfRationalNumberCategory| *Categories*)
    (make-instance '|PseudoAlgebraicClosureOfAlgExtOfRationalNumberCategoryType|)))

\end{chunk}



\chapter{The NonNegativeInteger Domain}

\begin{verbatim}
)show NNI
 NonNegativeInteger is a domain constructor
 Abbreviation for NonNegativeInteger is NNI 
 This constructor is exposed in this frame.
 Issue )edit bookvol10.3.pamphlet to see algebra source code for NNI 

------------------------------- Operations --------------------------------
 ?*? : (%,%) -> %                      ?*? : (NonNegativeInteger,%) -> %
 ?*? : (PositiveInteger,%) -> %        ?**? : (%,PositiveInteger) -> %
 ?**? : (%,NonNegativeInteger) -> %    ?+? : (%,%) -> %
 ?<? : (%,%) -> Boolean                ?<=? : (%,%) -> Boolean
 ?=? : (%,%) -> Boolean                ?>? : (%,%) -> Boolean
 ?>=? : (%,%) -> Boolean               1 : () -> %
 0 : () -> %                           ?^? : (%,PositiveInteger) -> %
 ?^? : (%,NonNegativeInteger) -> %     coerce : % -> OutputForm
 gcd : (%,%) -> %                      hash : % -> SingleInteger
 latex : % -> String                   max : (%,%) -> %
 min : (%,%) -> %                      one? : % -> Boolean
 qcoerce : Integer -> %                ?quo? : (%,%) -> %
 random : % -> %                       recip : % -> Union(%,"failed")
 ?rem? : (%,%) -> %                    sample : () -> %
 shift : (%,Integer) -> %              sup : (%,%) -> %
 zero? : % -> Boolean                  ?~=? : (%,%) -> Boolean
 divide : (%,%) -> Record(quotient: %,remainder: %)
 exquo : (%,%) -> Union(%,"failed")
 subtractIfCan : (%,%) -> Union(%,"failed")

\end{verbatim}

\subsection{Database Files}

Database files are very similar to kaf files except that there
is an optimization (currently broken) which makes the first
item a pair of two numbers. The first number in the pair is
the offset of the key-value table, the second is a time stamp.
If the time stamp in the database matches the time stamp in
the image the database is not needed (since the internal hash
tables already contain all of the information). When the database
is built the time stamp is saved in both the gcl image and the
database.

Regarding the 'ancestors field in a category: At database build
time there exists a *ancestors-hash* hash table that gets filled
with CATEGORY (not domain) ancestor information. This later provides
the information that goes into interp.daase This *ancestors-hash*
does not exist at normal runtime (it can be made by a call to
genCategoryTable). Note that the ancestor information in
*ancestors-hash* (and hence interp.daase) involves \verb|#1|, \verb|#2|, etc
instead of R, Coef, etc. The latter thingies appear in all
.nrlib/index.kaf files. So we need to be careful when we )lib
categories and update the ancestor info.

This file contains the code to build, open and access the .daase
files. This file contains the code to )library nrlibs and asy files

There is a major issue about the data that resides in these
databases.  the fundamental problem is that the system requires more
information to build the databases than it needs to run the
interpreter.  in particular, modemap.daase is constructed using
properties like "modemaps" but the interpreter will never ask for
this information.

So, the design is as follows:
\begin{itemize}
\item the modemap.daase needs to be built. this is done by doing
a )library on ALL of the nrlib files that are going into the system.
this will bring in "modemap" information and add it to the
*modemaps-hash* hashtable.
\item database build proceeds, accessing the "modemap" property
from the hashtables. once this completes this information is never
used again.
\item the interp.daase database is built. this contains only the
information necessary to run the interpreter. note that during the
running of the interpreter users can extend the system by do a
)library on a new nrlib file. this will cause fields such as "modemap"
to be read and hashed.
\end{itemize}

Each constructor (e.g. LIST) had one library directory (e.g. LIST.nrlib). 
This directory contained a random access file called the index.kaf file. 
These files contain runtime information such as the operationAlist and
the ConstructorModemap. At system build time we merge all of these 
.nrlib/index.kaf files into one database, INTERP.daase.  Requests to 
get information from this database are cached so that multiple 
references do not cause additional disk i/o.

This database is left open at all times as it is used frequently by
the interpreter. one minor complication is that newly compiled files
need to override information that exists in this database.

The design calls for constructing a random read (kaf format) file
that is accessed by functions that cache their results. when the
database is opened the list of constructor-index pairs is hashed
by constructor name. a request for information about a constructor
causes the information to replace the index in the hash table. since
the index is a number and the data is a non-numeric sexpr there is
no source of confusion about when the data needs to be read.

The format of this new database is as follows:
\begin{verbatim}
 first entry:
   an integer giving the byte offset to the constructor alist
   at the bottom of the file
 second and subsequent entries (one per constructor)
   (operationAlist)
   (constructorModemap)
   ....
 last entry: (pointed at by the first entry)
   an alist of (constructor . index) e.g.
      ( (PI offset-of-operationAlist offset-of-constructorModemap)
      (NNI offset-of-operationAlist offset-of-constructorModemap)
       ....)
  This list is read at open time and hashed by the car of each item.
\end{verbatim}

The system has been changed to use the property list of the
symbols rather than hash tables. since we already hashed once
to get the symbol we need only an offset to get the property
list. this also has the advantage that eq hash tables no longer
need to be moved during garbage collection.

There are 3 potential speedups that could be done. 
\begin{itemize}
\item the best would be to use the value cell of the symbol rather than the
property list but i'm unable to determine all uses of the
value cell at the present time.
\item a second speedup is to guarantee that the property list is
a single item, namely the database structure. this removes
an assoc but leaves one open to breaking the system if someone
adds something to the property list. this was not done because
of the danger mentioned.
\item a third speedup is to make the getdatabase call go away, either
by making it a macro or eliding it entirely. this was not done
because we want to keep the flexibility of changing the database forms.
\end{itemize}

The new design does not use hash tables. the database structure
contains an entry for each item that used to be in a hash table.
initially the structure contains file-position pointers and
these are replaced by real data when they are first looked up.
the database structure is kept on the property list of the
constructor, thus, (get '|DenavitHartenbergMatrix| 'database)
will return the database structure object.

Each operation has a property on its symbol name called 'operation
which is a list of all of the signatures of operations with that name.

\index[code]{defstruct!database}
\index[code]{database!defstruct}
\begin{chunk}{initvars}
(defstruct database
 abbreviation               ; interp.
 ancestors                  ; interp.
 constructor                ; interp.
 constructorcategory        ; interp.
 constructorkind            ; interp.
 constructormodemap         ; interp.
 cosig                      ; interp.
 defaultdomain              ; interp.
 modemaps                   ; interp.
 niladic                    ; interp.
 object                     ; interp.
 operationalist             ; interp.
 documentation              ; browse.
 constructorform            ; browse.
 attributes                 ; browse.
 predicates                 ; browse.
 sourcefile                 ; browse.
 parents                    ; browse.
 users                      ; browse.
 dependents                 ; browse.
 spare                      ; superstition
 ) ; database structure

\end{chunk}

\index[code]{defvar!*defaultdomain-list*}
\index[code]{*defaultdomain-list*!defvar}
There are only a small number of domains that have default domains.
rather than keep this slot in every domain we maintain a list here.
\begin{chunk}{initvars}
(defvar *defaultdomain-list* '(
  (|MultisetAggregate| |Multiset|)
  (|FunctionSpace| |Expression|)
  (|AlgebraicallyClosedFunctionSpace| |Expression|)
  (|ThreeSpaceCategory| |ThreeSpace|)
  (|DequeueAggregate| |Dequeue|)
  (|ComplexCategory| |Complex|)
  (|LazyStreamAggregate| |Stream|)
  (|AssociationListAggregate| |AssociationList|)
  (|QuaternionCategory| |Quaternion|)
  (|PriorityQueueAggregate| |Heap|)
  (|PointCategory| |Point|)
  (|PlottableSpaceCurveCategory| |Plot3D|)
  (|PermutationCategory| |Permutation|)
  (|StringCategory| |String|)
  (|FileNameCategory| |FileName|)
  (|OctonionCategory| |Octonion|)))

\end{chunk}

\index[code]{*operation-hash*}
\begin{chunk}{initvars}
(defvar *operation-hash* nil "given an operation name, what are its modemaps?")

\end{chunk}

\index[all]{*hasCategory-hash*}
This hash table is used to answer the question``does domain x
have category y?''. this is answered by constructing a pair of
(x . y) and doing an equal hash into this table.
\begin{chunk}{initvars}
(defvar *hasCategory-hash* nil "answers x has y category questions")

\end{chunk}

\index[all]{*miss*}
This variable is used for debugging. If a hash table lookup fails
and this variable is non-nil then a message is printed.
\begin{chunk}{initvars}
(defvar *miss* nil "print out cache misses on getdatabase calls")

\end{chunk}

Note that constructorcategory information need only be kept for
items of type category. this will be fixed in the next iteration
when the need for the various caches are reviewed

Note that the *modemaps-hash* information does not need to be kept
for system files. these are precomputed and kept in modemap.daase
however, for user-defined files these are needed.
Currently these are added to the database for 2 reasons;
there is a still-unresolved issue of user database extensions and
this information is used during database build time

\begin{verbatim}
)lisp (showdatabase '|NonNegativeInteger|)
getdatabase call: NonNegativeInteger   CONSTRUCTORKIND
CONSTRUCTORKIND: domain
getdatabase call: NonNegativeInteger   COSIG
COSIG: (NIL)
getdatabase call: NonNegativeInteger   OPERATION
OPERATION: NIL
CONSTRUCTORMODEMAP: 
getdatabase call: NonNegativeInteger   CONSTRUCTORMODEMAP

(((|NonNegativeInteger|)
  (|Join| (|OrderedAbelianMonoidSup|) (|Monoid|)
          (CATEGORY |domain| (SIGNATURE |quo| ($ $ $))
              (SIGNATURE |rem| ($ $ $)) (SIGNATURE |gcd| ($ $ $))
              (SIGNATURE |divide|
                  ((|Record| (|:| |quotient| $) (|:| |remainder| $)) $
                   $))
              (SIGNATURE |exquo| ((|Union| $ "failed") $ $))
              (SIGNATURE |shift| ($ $ (|Integer|)))
              (SIGNATURE |random| ($ $))
              (SIGNATURE |qcoerce| ($ (|Integer|))))))
 (T |NonNegativeInteger|))
CONSTRUCTORCATEGORY: 
getdatabase call: NonNegativeInteger   CONSTRUCTORCATEGORY
getdatabase miss: NonNegativeInteger   CONSTRUCTORCATEGORY

(|Join| (|OrderedAbelianMonoidSup|) (|Monoid|)
        (CATEGORY |domain| (SIGNATURE |quo| ($ $ $))
            (SIGNATURE |rem| ($ $ $)) (SIGNATURE |gcd| ($ $ $))
            (SIGNATURE |divide|
                ((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $))
            (SIGNATURE |exquo| ((|Union| $ "failed") $ $))
            (SIGNATURE |shift| ($ $ (|Integer|)))
            (SIGNATURE |random| ($ $))
            (SIGNATURE |qcoerce| ($ (|Integer|)))))
OPERATIONALIST: 
getdatabase call: NonNegativeInteger   OPERATIONALIST

((~= (((|Boolean|) $ $) NIL)) (|zero?| (((|Boolean|) $) NIL))
 (|sup| (($ $ $) 6)) (|subtractIfCan| (((|Union| $ "failed") $ $) 10))
 (|shift| (($ $ (|Integer|)) 7)) (|sample| (($) NIL T CONST))
 (|rem| (($ $ $) NIL)) (|recip| (((|Union| $ "failed") $) NIL))
 (|random| (($ $) NIL)) (|quo| (($ $ $) NIL))
 (|qcoerce| (($ (|Integer|)) 8)) (|one?| (((|Boolean|) $) NIL))
 (|min| (($ $ $) NIL)) (|max| (($ $ $) NIL))
 (|latex| (((|String|) $) NIL)) (|hash| (((|SingleInteger|) $) NIL))
 (|gcd| (($ $ $) 11)) (|exquo| (((|Union| $ "failed") $ $) NIL))
 (|divide|
     (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $) NIL))
 (|coerce| (((|OutputForm|) $) NIL))
 (^ (($ $ (|NonNegativeInteger|)) NIL) (($ $ (|PositiveInteger|)) NIL))
 (|Zero| (($) NIL T CONST)) (|One| (($) NIL T CONST))
 (>= (((|Boolean|) $ $) NIL)) (> (((|Boolean|) $ $) NIL))
 (= (((|Boolean|) $ $) NIL)) (<= (((|Boolean|) $ $) NIL))
 (< (((|Boolean|) $ $) NIL)) (+ (($ $ $) NIL))
 (** (($ $ (|NonNegativeInteger|)) NIL)
     (($ $ (|PositiveInteger|)) NIL))
 (* (($ (|PositiveInteger|) $) NIL) (($ (|NonNegativeInteger|) $) NIL)
    (($ $ $) NIL)))
MODEMAPS: 
getdatabase call: NonNegativeInteger   MODEMAPS
getdatabase miss: NonNegativeInteger   MODEMAPS

((|quo| (*1 *1 *1 *1) (|isDomain| *1 (|NonNegativeInteger|)))
 (|rem| (*1 *1 *1 *1) (|isDomain| *1 (|NonNegativeInteger|)))
 (|gcd| (*1 *1 *1 *1) (|isDomain| *1 (|NonNegativeInteger|)))
 (|divide| (*1 *2 *1 *1)
     (AND (|isDomain| *2
              (|Record| (|:| |quotient| (|NonNegativeInteger|))
                  (|:| |remainder| (|NonNegativeInteger|))))
          (|isDomain| *1 (|NonNegativeInteger|))))
 (|exquo| (*1 *1 *1 *1)
          (|partial| |isDomain| *1 (|NonNegativeInteger|)))
 (|shift| (*1 *1 *1 *2)
          (AND (|isDomain| *2 (|Integer|))
               (|isDomain| *1 (|NonNegativeInteger|))))
 (|random| (*1 *1 *1) (|isDomain| *1 (|NonNegativeInteger|)))
 (|qcoerce| (*1 *1 *2)
     (AND (|isDomain| *2 (|Integer|))
          (|isDomain| *1 (|NonNegativeInteger|)))))getdatabase call: NonNegativeInteger   HASCATEGORY
HASCATEGORY: NIL
getdatabase call: NonNegativeInteger   OBJECT
OBJECT: /mnt/c/Users/markb/EXE/axiom/mnt/ubuntu/algebra/NNI.o
getdatabase call: NonNegativeInteger   NILADIC
NILADIC: T
getdatabase call: NonNegativeInteger   ABBREVIATION
ABBREVIATION: NNI
getdatabase call: NonNegativeInteger   CONSTRUCTOR?
CONSTRUCTOR?: T
getdatabase call: NonNegativeInteger   CONSTRUCTOR
CONSTRUCTOR: NIL
getdatabase call: NonNegativeInteger   DEFAULTDOMAIN
DEFAULTDOMAIN: NIL
getdatabase call: NonNegativeInteger   ANCESTORS
ANCESTORS: NIL
getdatabase call: NonNegativeInteger   SOURCEFILE
SOURCEFILE: bookvol10.3.pamphlet
getdatabase call: NonNegativeInteger   CONSTRUCTORFORM
CONSTRUCTORFORM: (NonNegativeInteger)
getdatabase call: NonNegativeInteger   CONSTRUCTORARGS
getdatabase call: NonNegativeInteger   CONSTRUCTORFORM
CONSTRUCTORARGS: NIL
getdatabase call: NonNegativeInteger   ATTRIBUTES
getdatabase miss: NonNegativeInteger   ATTRIBUTES
ATTRIBUTES: NIL
PREDICATES: 
getdatabase call: NonNegativeInteger   PREDICATES
getdatabase miss: NonNegativeInteger   PREDICATES

NILgetdatabase call: NonNegativeInteger   DOCUMENTATION
getdatabase miss: NonNegativeInteger   DOCUMENTATION
DOCUMENTATION: ((constructor (NIL \spadtype{NonNegativeInteger} provides functions for non negative integers.)) (qcoerce (($ (Integer)) \spad{qcoerce(n)} coerces \spad{n} to \spad{\%} trusting that \spad{n} is nonnegative)) (random (($ $) \spad{random(n)} returns a random integer from 0 to \spad{n-1}.)) (shift (($ $ (Integer)) \spad{shift(a, i)} shift \spad{a} by \spad{i} bits.)) (exquo (((Union $ failed) $ $) \spad{exquo(a,b)} returns the quotient of \spad{a} and \spad{b,} or "failed" if \spad{b} is zero or \spad{a} rem \spad{b} is zero.)) (divide (((Record (: quotient $) (: remainder $)) $ $) \spad{divide(a, \spad{b)}} returns a record containing both remainder and quotient.)) (gcd (($ $ $) \spad{gcd(a, \spad{b)}} computes the greatest common divisor of two \indented{1}{non negative integers \spad{a} and \spad{b.}} \blankline \spad{X} gcd(2415,945) \spad{X} gcd(945,2415) \spad{X} gcd(2415,0) \spad{X} gcd(0,945) \spad{X} gcd(15,15) \spad{X} gcd(0,0))) (rem (($ $ $) \spad{a rem \spad{b}} returns the remainder of \spad{a} and \spad{b.})) (quo (($ $ $) \spad{a quo \spad{b}} returns the quotient of \spad{a} and \spad{b,} forgetting the remainder.)))
getdatabase call: NonNegativeInteger   PARENTS
PARENTS: NIL
Value = NIL
\end{verbatim}

\begin{verbatim}
#S(DATABASE 
   ABBREVIATION NNI 
   ANCESTORS NIL 
   CONSTRUCTOR NIL 
   CONSTRUCTORCATEGORY 3449807 
   CONSTRUCTORKIND |domain| 
   CONSTRUCTORMODEMAP 
    (((|NonNegativeInteger|)
      (|Join|
        (|OrderedAbelianMonoidSup|)
        (|Monoid|)
        (CATEGORY 
          |domain|
          (SIGNATURE |quo| ($ $ $))
          (SIGNATURE |rem| ($ $ $))
          (SIGNATURE |gcd| ($ $ $))
          (SIGNATURE |divide| ((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $))
          (SIGNATURE |exquo| ((|Union| $ "failed") $ $))
          (SIGNATURE |shift| ($ $ (|Integer|)))
          (SIGNATURE |random| ($ $))
          (SIGNATURE |qcoerce| ($ (|Integer|))))))
      (T |NonNegativeInteger|))
     COSIG (NIL) 
     DEFAULTDOMAIN NIL 
     MODEMAPS 3449116 
     NILADIC T 
     OBJECT "NNI" 
     OPERATIONALIST (
       (~= (((|Boolean|) $ $) NIL))
       (|zero?| (((|Boolean|) $) NIL))
       (|sup| (($ $ $) 6))
       (|subtractIfCan| (((|Union| $ "failed") $ $) 10))
       (|shift| (($ $ (|Integer|)) 7))
       (|sample| (($) NIL T CONST))
       (|rem| (($ $ $) NIL)) 
       (|recip| (((|Union| $ "failed") $) NIL)) 
       (|random| (($ $) NIL)) 
       (|quo| (($ $ $) NIL))
       (|qcoerce| (($ (|Integer|)) 8)) 
       (|one?| (((|Boolean|) $) NIL))
       (|min| (($ $ $) NIL)) 
       (|max| (($ $ $) NIL))
       (|latex| (((|String|) $) NIL)) 
       (|hash| (((|SingleInteger|) $) NIL))
       (|gcd| (($ $ $) 11)) 
       (|exquo| (((|Union| $ "failed") $ $) NIL))
       (|divide| (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $) NIL))
       (|coerce| (((|OutputForm|) $) NIL))
       (^ (($ $ (|NonNegativeInteger|)) NIL) (($ $ (|PositiveInteger|)) NIL))
       (|Zero| (($) NIL T CONST))
       (|One| (($) NIL T CONST))
       (>= (((|Boolean|) $ $) NIL))
       (> (((|Boolean|) $ $) NIL))
       (= (((|Boolean|) $ $) NIL))
       (<= (((|Boolean|) $ $) NIL))
       (< (((|Boolean|) $ $) NIL))
       (+ (($ $ $) NIL))
       (** (($ $ (|NonNegativeInteger|)) NIL) (($ $ (|PositiveInteger|)) NIL))
       (* (($ (|PositiveInteger|) $) NIL) (($ (|NonNegativeInteger|) $) NIL) (($ $ $) NIL)))
   DOCUMENTATION 1437684 
   CONSTRUCTORFORM (|NonNegativeInteger|) 
   ATTRIBUTES 1438930 
   PREDICATES 1438935 
   SOURCEFILE "bookvol10.3.pamphlet" 
   PARENTS NIL 
   USERS NIL 
   DEPENDENTS NIL 
   SPARE NIL)

\end{verbatim}

\chapter{The Domains}
\section{A}

\subsection{AffinePlane}
\index[dom]{AffinePlane!Domain}
\index[dom]{Domain!AffinePlane}
\index[dom]{AFFPL}
\begin{chunk}{defclass AffinePlaneType}
(defclass |AffinePlaneType| (|AffineSpaceCategoryType|)
  ((parents :initform '(|AffineSpaceCategory|))
   (name :initform "AffinePlane")
   (marker :initform 'domain)
   (abbreviation :initform 'AFFPL)
   (comment :initform (list
     "The following is all the categories and domains related to projective"
     "space and part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AffinePlane|
  (progn
    (push '|AffinePlane| *Domains*)
    (make-instance '|AffinePlaneType|)))

\end{chunk}

\subsection{AffinePlaneOverPseudoAlgebraicClosureOfFiniteField}
\index[dom]{AffinePlaneOverPseudoAlgebraicClosureOfFiniteField!Domain}
\index[dom]{Domain!AffinePlaneOverPseudoAlgebraicClosureOfFiniteField}
\index[dom]{AFFPLPS}
\begin{chunk}{defclass AffinePlaneOverPseudoAlgebraicClosureOfFiniteFieldType}
(defclass |AffinePlaneOverPseudoAlgebraicClosureOfFiniteFieldType| (|AffineSpaceCategoryType|)
  ((parents :initform '(|AffineSpaceCategory|))
   (name :initform "AffinePlaneOverPseudoAlgebraicClosureOfFiniteField")
   (marker :initform 'domain)
   (abbreviation :initform 'AFFPLPS)
   (comment :initform (list
     "The following is all the categories and domains related to projective"
     "space and part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AffinePlaneOverPseudoAlgebraicClosureOfFiniteField|
  (progn
    (push '|AffinePlaneOverPseudoAlgebraicClosureOfFiniteField| *Domains*)
    (make-instance '|AffinePlaneOverPseudoAlgebraicClosureOfFiniteFieldType|)))

\end{chunk}

\subsection{AffineSpace}
\index[dom]{AffineSpace!Domain}
\index[dom]{Domain!AffineSpace}
\index[dom]{AFFSP}
\begin{chunk}{defclass AffineSpaceType}
(defclass |AffineSpaceType| (|AffineSpaceCategoryType|)
  ((parents :initform '(|AffineSpaceCategory|))
   (name :initform "AffineSpace")
   (marker :initform 'domain)
   (abbreviation :initform 'AFFSP)
   (comment :initform (list
     "The following is all the categories and domains related to projective"
     "space and part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AffineSpace|
  (progn
    (push '|AffineSpace| *Domains*)
    (make-instance '|AffineSpaceType|)))

\end{chunk}

\subsection{AlgebraGivenByStructuralConstants}
\index[dom]{AlgebraGivenByStructuralConstants!Domain}
\index[dom]{Domain!AlgebraGivenByStructuralConstants}
\index[dom]{ALGSC}
\begin{chunk}{defclass AlgebraGivenByStructuralConstantsType}
(defclass |AlgebraGivenByStructuralConstantsType| (|FramedNonAssociativeAlgebraType|)
  ((parents :initform '(|FramedNonAssociativeAlgebra|))
   (name :initform "AlgebraGivenByStructuralConstants")
   (marker :initform 'domain)
   (abbreviation :initform 'ALGSC)
   (comment :initform (list
     "The following is all the categories and domains related to projective"
     "space and part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AlgebraGivenByStructuralConstants|
  (progn
    (push '|AlgebraGivenByStructuralConstants| *Domains*)
    (make-instance '|AlgebraGivenByStructuralConstantsType|)))

\end{chunk}

\subsection{AlgebraicFunctionField}
\index[dom]{AlgebraicFunctionField!Domain}
\index[dom]{Domain!AlgebraicFunctionField}
\index[dom]{ALGFF}
\begin{chunk}{defclass AlgebraicFunctionFieldType}
(defclass |AlgebraicFunctionFieldType| (|FunctionFieldCategoryType|)
  ((parents :initform '(|FunctionFieldCategory|))
   (name :initform "AlgebraicFunctionField")
   (marker :initform 'domain)
   (abbreviation :initform 'ALGFF)
   (comment :initform (list
     "Function field defined by f(x, y) = 0."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AlgebraicFunctionField|
  (progn
    (push '|AlgebraicFunctionField| *Domains*)
    (make-instance '|AlgebraicFunctionFieldType|)))

\end{chunk}

\subsection{AlgebraicNumber}
\index[dom]{AlgebraicNumber!Domain}
\index[dom]{Domain!AlgebraicNumber}
\index[dom]{AN}
\begin{chunk}{defclass AlgebraicNumberType}
(defclass |AlgebraicNumberType| (|AlgebraicallyClosedFieldType| 
                                 |CharacteristicZeroType| 
                                 |DifferentialRingType|
                                 |ExpressionSpaceType| 
                                 |LinearlyExplicitRingOverType| 
                                 |RealConstantType|)
  ((parents :initform '(|AlgebraicallyClosedField| 
                        |CharacteristicZero| 
                        |DifferentialRing|
                        |ExpressionSpace| 
                        |LinearlyExplicitRingOver| 
                        |RealConstant|))
   (name :initform "AlgebraicNumber")
   (marker :initform 'domain)
   (abbreviation :initform 'AN)
   (comment :initform (list
     "Algebraic closure of the rational numbers, with mathematical ="))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AlgebraicNumber|
  (progn
    (push '|AlgebraicNumber| *Domains*)
    (make-instance '|AlgebraicNumberType|)))

\end{chunk}

\subsection{AnonymousFunction}
\index[dom]{AnonymousFunction!Domain}
\index[dom]{Domain!AnonymousFunction}
\index[dom]{ANON}
\begin{chunk}{defclass AnonymousFunctionType}
(defclass |AnonymousFunctionType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "AnonymousFunction")
   (marker :initform 'domain)
   (abbreviation :initform 'ANON)
   (comment :initform (list
     "This domain implements anonymous functions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AnonymousFunction|
  (progn
    (push '|AnonymousFunction| *Domains*)
    (make-instance '|AnonymousFunctionType|)))

\end{chunk}

\subsection{AntiSymm}
\index[dom]{AntiSymm!Domain}
\index[dom]{Domain!AntiSymm}
\index[dom]{ANTISYM}
\begin{chunk}{defclass AntiSymmType}
(defclass |AntiSymmType| (|RetractableToType| |LeftAlgebraType|)
  ((parents :initform '(|RetractableTo| |LeftAlgebra|))
   (name :initform "AntiSymm")
   (marker :initform 'domain)
   (abbreviation :initform 'ANTISYM)
   (comment :initform (list
     "The domain of antisymmetric polynomials."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AntiSymm|
  (progn
    (push '|AntiSymm| *Domains*)
    (make-instance '|AntiSymmType|)))

\end{chunk}

\subsection{Any}
\index[dom]{Any!Domain}
\index[dom]{Domain!Any}
\index[dom]{ANY}
\begin{chunk}{defclass AnyType}
(defclass |AnyType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "Any")
   (marker :initform 'domain)
   (abbreviation :initform 'ANY)
   (comment :initform (list
     "Any implements a type that packages up objects and their"
     "types in objects of Any. Roughly speaking that means"
     "that if s : S then when converted to Any, the new"
     "object will include both the original object and its type. This is"
     "a way of converting arbitrary objects into a single type without"
     "losing any of the original information. Any object can be converted"
     "to one of Any."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Any|
  (progn
    (push '|Any| *Domains*)
    (make-instance '|AnyType|)))

\end{chunk}

\subsection{ArrayStack}
\index[dom]{ArrayStack!Domain}
\index[dom]{Domain!ArrayStack}
\index[dom]{ASTACK}
\begin{chunk}{defclass ArrayStackType}
(defclass |ArrayStackType| (|StackAggregateType|)
  ((parents :initform '(|StackAggregate|))
   (name :initform "ArrayStack")
   (marker :initform 'domain)
   (abbreviation :initform 'ASTACK)
   (comment :initform (list
     "A stack represented as a flexible array."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ArrayStack|
  (progn
    (push '|ArrayStack| *Domains*)
    (make-instance '|ArrayStackType|)))

\end{chunk}

\subsection{Asp1}
\index[dom]{Asp1!Domain}
\index[dom]{Domain!Asp1}
\index[dom]{Asp1}
\begin{chunk}{defclass Asp1Type}
(defclass |Asp1Type| (|FortranFunctionCategoryType|)
  ((parents :initform '(|FortranFunctionCategory|))
   (name :initform "Asp1")
   (marker :initform 'domain)
   (abbreviation :initform 'Asp1)
   (comment :initform (list
     "Asp1 produces Fortran for Type 1 ASPs, needed for various"
     "NAG routines. Type 1 ASPs take a univariate expression (in the symbol x)"
     "and turn it into a Fortran Function like the following:"
     " "
     "     DOUBLE PRECISION FUNCTION F(X)"
     "     DOUBLE PRECISION X"
     "     F=DSIN(X)"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp1|
  (progn
    (push '|Asp1| *Domains*)
    (make-instance '|Asp1Type|)))

\end{chunk}

\subsection{Asp10}
\index[dom]{Asp10!Domain}
\index[dom]{Domain!Asp10}
\index[dom]{ASP10}
\begin{chunk}{defclass Asp10Type}
(defclass |Asp10Type| (|FortranVectorFunctionCategoryType|)
  ((parents :initform '(|FortranVectorFunctionCategory|))
   (name :initform "Asp10")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP10)
   (comment :initform (list
     "ASP10 produces Fortran for Type 10 ASPs, needed for NAG routine"
     "d02kef. This ASP computes the values of a set of functions, for example:"
     " "
     "     SUBROUTINE COEFFN(P,Q,DQDL,X,ELAM,JINT)"
     "     DOUBLE PRECISION ELAM,P,Q,X,DQDL"
     "     INTEGER JINT"
     "     P=1.0D0"
     "     Q=((-1.0D0*X**3)+ELAM*X*X-2.0D0)/(X*X)"
     "     DQDL=1.0D0"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp10|
  (progn
    (push '|Asp10| *Domains*)
    (make-instance '|Asp10Type|)))

\end{chunk}

\subsection{Asp12}
\index[dom]{Asp12!Domain}
\index[dom]{Domain!Asp12}
\index[dom]{ASP12}
\begin{chunk}{defclass |Asp12Type}
(defclass |Asp12Type| (|FortranProgramCategoryType|)
  ((parents :initform '(|FortranProgramCategory|))
   (name :initform "Asp12")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP12)
   (comment :initform (list
     "Asp12 produces Fortran for Type 12 ASPs, needed for NAG routine"
     "d02kef etc., for example:"
     " "
     "     SUBROUTINE MONIT (MAXIT,IFLAG,ELAM,FINFO)"
     "     DOUBLE PRECISION ELAM,FINFO(15)"
     "     INTEGER MAXIT,IFLAG"
     "     IF(MAXIT.EQ.-1)THEN"
     "     PRINT*,\"Output from Monit\""
     "     ENDIF"
     "     PRINT*,MAXIT,IFLAG,ELAM,(FINFO(I),I=1,4)"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp12|
  (progn
    (push '|Asp12| *Domains*)
    (make-instance '|Asp12Type|)))

\end{chunk}

\subsection{Asp19}
\index[dom]{Asp19!Domain}
\index[dom]{Domain!Asp19}
\index[dom]{ASP19}
\begin{chunk}{defclass Asp19Type}
(defclass |Asp19Type| (|FortranVectorFunctionCategoryType|)
  ((parents :initform '(|FortranVectorFunctionCategory|))
   (name :initform "Asp19")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP19)
   (comment :initform (list
     "Asp19 produces Fortran for Type 19 ASPs, evaluating a set of"
     "functions and their jacobian at a given point, for example:"
     " "
     "     SUBROUTINE LSFUN2(M,N,XC,FVECC,FJACC,LJC)"
     "     DOUBLE PRECISION FVECC(M),FJACC(LJC,N),XC(N)"
     "     INTEGER M,N,LJC"
     "     INTEGER I,J"
     "     DO 25003 I=1,LJC"
     "       DO 25004 J=1,N"
     "         FJACC(I,J)=0.0D0"
     "25004   CONTINUE"
     "25003 CONTINUE"
     "     FVECC(1)=((XC(1)-0.14D0)*XC(3)+(15.0D0*XC(1)-2.1D0)*XC(2)+1.0D0)/("
     "    &XC(3)+15.0D0*XC(2))"
     "     FVECC(2)=((XC(1)-0.18D0)*XC(3)+(7.0D0*XC(1)-1.26D0)*XC(2)+1.0D0)/("
     "    &XC(3)+7.0D0*XC(2))"
     "     FVECC(3)=((XC(1)-0.22D0)*XC(3)+(4.333333333333333D0*XC(1)-0.953333"
     "    &3333333333D0)*XC(2)+1.0D0)/(XC(3)+4.333333333333333D0*XC(2))"
     "     FVECC(4)=((XC(1)-0.25D0)*XC(3)+(3.0D0*XC(1)-0.75D0)*XC(2)+1.0D0)/("
     "    &XC(3)+3.0D0*XC(2))"
     "     FVECC(5)=((XC(1)-0.29D0)*XC(3)+(2.2D0*XC(1)-0.6379999999999999D0)*"
     "    &XC(2)+1.0D0)/(XC(3)+2.2D0*XC(2))"
     "     FVECC(6)=((XC(1)-0.32D0)*XC(3)+(1.666666666666667D0*XC(1)-0.533333"
     "    &3333333333D0)*XC(2)+1.0D0)/(XC(3)+1.666666666666667D0*XC(2))"
     "     FVECC(7)=((XC(1)-0.35D0)*XC(3)+(1.285714285714286D0*XC(1)-0.45D0)*"
     "    &XC(2)+1.0D0)/(XC(3)+1.285714285714286D0*XC(2))"
     "     FVECC(8)=((XC(1)-0.39D0)*XC(3)+(XC(1)-0.39D0)*XC(2)+1.0D0)/(XC(3)+"
     "    &XC(2))"
     "     FVECC(9)=((XC(1)-0.37D0)*XC(3)+(XC(1)-0.37D0)*XC(2)+1.285714285714"
     "    &286D0)/(XC(3)+XC(2))"
     "     FVECC(10)=((XC(1)-0.58D0)*XC(3)+(XC(1)-0.58D0)*XC(2)+1.66666666666"
     "    &6667D0)/(XC(3)+XC(2))"
     "     FVECC(11)=((XC(1)-0.73D0)*XC(3)+(XC(1)-0.73D0)*XC(2)+2.2D0)/(XC(3)"
     "    &+XC(2))"
     "     FVECC(12)=((XC(1)-0.96D0)*XC(3)+(XC(1)-0.96D0)*XC(2)+3.0D0)/(XC(3)"
     "    &+XC(2))"
     "     FVECC(13)=((XC(1)-1.34D0)*XC(3)+(XC(1)-1.34D0)*XC(2)+4.33333333333"
     "    &3333D0)/(XC(3)+XC(2))"
     "     FVECC(14)=((XC(1)-2.1D0)*XC(3)+(XC(1)-2.1D0)*XC(2)+7.0D0)/(XC(3)+X"
     "    &C(2))"
     "     FVECC(15)=((XC(1)-4.39D0)*XC(3)+(XC(1)-4.39D0)*XC(2)+15.0D0)/(XC(3"
     "    &)+XC(2))"
     "     FJACC(1,1)=1.0D0"
     "     FJACC(1,2)=-15.0D0/(XC(3)**2+30.0D0*XC(2)*XC(3)+225.0D0*XC(2)**2)"
     "     FJACC(1,3)=-1.0D0/(XC(3)**2+30.0D0*XC(2)*XC(3)+225.0D0*XC(2)**2)"
     "     FJACC(2,1)=1.0D0"
     "     FJACC(2,2)=-7.0D0/(XC(3)**2+14.0D0*XC(2)*XC(3)+49.0D0*XC(2)**2)"
     "     FJACC(2,3)=-1.0D0/(XC(3)**2+14.0D0*XC(2)*XC(3)+49.0D0*XC(2)**2)"
     "     FJACC(3,1)=1.0D0"
     "     FJACC(3,2)=((-0.1110223024625157D-15*XC(3))-4.333333333333333D0)/("
     "    &XC(3)**2+8.666666666666666D0*XC(2)*XC(3)+18.77777777777778D0*XC(2)"
     "    &**2)"
     "     FJACC(3,3)=(0.1110223024625157D-15*XC(2)-1.0D0)/(XC(3)**2+8.666666"
     "    &666666666D0*XC(2)*XC(3)+18.77777777777778D0*XC(2)**2)"
     "     FJACC(4,1)=1.0D0"
     "     FJACC(4,2)=-3.0D0/(XC(3)**2+6.0D0*XC(2)*XC(3)+9.0D0*XC(2)**2)"
     "     FJACC(4,3)=-1.0D0/(XC(3)**2+6.0D0*XC(2)*XC(3)+9.0D0*XC(2)**2)"
     "     FJACC(5,1)=1.0D0"
     "     FJACC(5,2)=((-0.1110223024625157D-15*XC(3))-2.2D0)/(XC(3)**2+4.399"
     "    &999999999999D0*XC(2)*XC(3)+4.839999999999998D0*XC(2)**2)"
     "     FJACC(5,3)=(0.1110223024625157D-15*XC(2)-1.0D0)/(XC(3)**2+4.399999"
     "    &999999999D0*XC(2)*XC(3)+4.839999999999998D0*XC(2)**2)"
     "     FJACC(6,1)=1.0D0"
     "     FJACC(6,2)=((-0.2220446049250313D-15*XC(3))-1.666666666666667D0)/("
     "    &XC(3)**2+3.333333333333333D0*XC(2)*XC(3)+2.777777777777777D0*XC(2)"
     "    &**2)"
     "     FJACC(6,3)=(0.2220446049250313D-15*XC(2)-1.0D0)/(XC(3)**2+3.333333"
     "    &333333333D0*XC(2)*XC(3)+2.777777777777777D0*XC(2)**2)"
     "     FJACC(7,1)=1.0D0"
     "     FJACC(7,2)=((-0.5551115123125783D-16*XC(3))-1.285714285714286D0)/("
     "    &XC(3)**2+2.571428571428571D0*XC(2)*XC(3)+1.653061224489796D0*XC(2)"
     "    &**2)"
     "     FJACC(7,3)=(0.5551115123125783D-16*XC(2)-1.0D0)/(XC(3)**2+2.571428"
     "    &571428571D0*XC(2)*XC(3)+1.653061224489796D0*XC(2)**2)"
     "     FJACC(8,1)=1.0D0"
     "     FJACC(8,2)=-1.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)"
     "     FJACC(8,3)=-1.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)"
     "     FJACC(9,1)=1.0D0"
     "     FJACC(9,2)=-1.285714285714286D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)*"
     "    &*2)"
     "     FJACC(9,3)=-1.285714285714286D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)*"
     "    &*2)"
     "     FJACC(10,1)=1.0D0"
     "     FJACC(10,2)=-1.666666666666667D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)"
     "    &**2)"
     "     FJACC(10,3)=-1.666666666666667D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)"
     "    &**2)"
     "     FJACC(11,1)=1.0D0"
     "     FJACC(11,2)=-2.2D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)"
     "     FJACC(11,3)=-2.2D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)"
     "     FJACC(12,1)=1.0D0"
     "     FJACC(12,2)=-3.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)"
     "     FJACC(12,3)=-3.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)"
     "     FJACC(13,1)=1.0D0"
     "     FJACC(13,2)=-4.333333333333333D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)"
     "    &**2)"
     "     FJACC(13,3)=-4.333333333333333D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)"
     "    &**2)"
     "     FJACC(14,1)=1.0D0"
     "     FJACC(14,2)=-7.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)"
     "     FJACC(14,3)=-7.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)"
     "     FJACC(15,1)=1.0D0"
     "     FJACC(15,2)=-15.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)"
     "     FJACC(15,3)=-15.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp19|
  (progn
    (push '|Asp19| *Domains*)
    (make-instance '|Asp19Type|)))

\end{chunk}

\subsection{Asp20}
\index[dom]{Asp20!Domain}
\index[dom]{Domain!Asp20}
\index[dom]{ASP20}
\begin{chunk}{defclass Asp20Type}
(defclass |Asp20Type| (|FortranMatrixFunctionCategoryType|)
  ((parents :initform '(|FortranMatrixFunctionCategory|))
   (name :initform "Asp20")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP20)
   (comment :initform (list
     "Asp20 produces Fortran for Type 20 ASPs, for example:"
     " "
     "     SUBROUTINE QPHESS(N,NROWH,NCOLH,JTHCOL,HESS,X,HX)"
     "     DOUBLE PRECISION HX(N),X(N),HESS(NROWH,NCOLH)"
     "     INTEGER JTHCOL,N,NROWH,NCOLH"
     "     HX(1)=2.0D0*X(1)"
     "     HX(2)=2.0D0*X(2)"
     "     HX(3)=2.0D0*X(4)+2.0D0*X(3)"
     "     HX(4)=2.0D0*X(4)+2.0D0*X(3)"
     "     HX(5)=2.0D0*X(5)"
     "     HX(6)=(-2.0D0*X(7))+(-2.0D0*X(6))"
     "     HX(7)=(-2.0D0*X(7))+(-2.0D0*X(6))"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp20|
  (progn
    (push '|Asp20| *Domains*)
    (make-instance '|Asp20Type|)))

\end{chunk}

\subsection{Asp24}
\index[dom]{Asp24!Domain}
\index[dom]{Domain!Asp24}
\index[dom]{ASP24}
\begin{chunk}{defclass Asp24Type}
(defclass |Asp24Type| (|FortranFunctionCategoryType|)
  ((parents :initform '(|FortranFunctionCategory|))
   (name :initform "Asp24")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP24)
   (comment :initform (list
     "Asp24 produces Fortran for Type 24 ASPs which evaluate a"
     "multivariate function at a point (needed for NAG routine e04jaf),"
     "for example:"
     " "
     "     SUBROUTINE FUNCT1(N,XC,FC)"
     "     DOUBLE PRECISION FC,XC(N)"
     "     INTEGER N"
     "     FC=10.0D0*XC(4)**4+(-40.0D0*XC(1)*XC(4)**3)+(60.0D0*XC(1)**2+5"
     "    &.0D0)*XC(4)**2+((-10.0D0*XC(3))+(-40.0D0*XC(1)**3))*XC(4)+16.0D0*X"
     "    &C(3)**4+(-32.0D0*XC(2)*XC(3)**3)+(24.0D0*XC(2)**2+5.0D0)*XC(3)**2+"
     "    &(-8.0D0*XC(2)**3*XC(3))+XC(2)**4+100.0D0*XC(2)**2+20.0D0*XC(1)*XC("
     "    &2)+10.0D0*XC(1)**4+XC(1)**2"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp24|
  (progn
    (push '|Asp24| *Domains*)
    (make-instance '|Asp24Type|)))

\end{chunk}

\subsection{Asp27}
\index[dom]{Asp27!Domain}
\index[dom]{Domain!Asp27}
\index[dom]{ASP27}
\begin{chunk}{defclass Asp27Type}
(defclass |Asp27Type| (|FortranMatrixCategoryType|)
  ((parents :initform '(|FortranMatrixCategory|))
   (name :initform "Asp27")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP27)
   (comment :initform (list
     "Asp27 produces Fortran for Type 27 ASPs, needed for NAG routine"
     "f02fjf ,for example:"
     " "
     "     FUNCTION DOT(IFLAG,N,Z,W,RWORK,LRWORK,IWORK,LIWORK)"
     "     DOUBLE PRECISION W(N),Z(N),RWORK(LRWORK)"
     "     INTEGER N,LIWORK,IFLAG,LRWORK,IWORK(LIWORK)"
     "     DOT=(W(16)+(-0.5D0*W(15)))*Z(16)+((-0.5D0*W(16))+W(15)+(-0.5D0*W(1"
     "    &4)))*Z(15)+((-0.5D0*W(15))+W(14)+(-0.5D0*W(13)))*Z(14)+((-0.5D0*W("
     "    &14))+W(13)+(-0.5D0*W(12)))*Z(13)+((-0.5D0*W(13))+W(12)+(-0.5D0*W(1"
     "    &1)))*Z(12)+((-0.5D0*W(12))+W(11)+(-0.5D0*W(10)))*Z(11)+((-0.5D0*W("
     "    &11))+W(10)+(-0.5D0*W(9)))*Z(10)+((-0.5D0*W(10))+W(9)+(-0.5D0*W(8))"
     "    &)*Z(9)+((-0.5D0*W(9))+W(8)+(-0.5D0*W(7)))*Z(8)+((-0.5D0*W(8))+W(7)"
     "    &+(-0.5D0*W(6)))*Z(7)+((-0.5D0*W(7))+W(6)+(-0.5D0*W(5)))*Z(6)+((-0."
     "    &5D0*W(6))+W(5)+(-0.5D0*W(4)))*Z(5)+((-0.5D0*W(5))+W(4)+(-0.5D0*W(3"
     "    &)))*Z(4)+((-0.5D0*W(4))+W(3)+(-0.5D0*W(2)))*Z(3)+((-0.5D0*W(3))+W("
     "    &2)+(-0.5D0*W(1)))*Z(2)+((-0.5D0*W(2))+W(1))*Z(1)"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp27|
  (progn
    (push '|Asp27| *Domains*)
    (make-instance '|Asp27Type|)))

\end{chunk}

\subsection{Asp28}
\index[dom]{Asp28!Domain}
\index[dom]{Domain!Asp28}
\index[dom]{ASP28}
\begin{chunk}{defclass Asp28Type}
(defclass |Asp28Type| (|FortranMatrixCategoryType|)
  ((parents :initform '(|FortranMatrixCategory|))
   (name :initform "Asp28")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP28)
   (comment :initform (list
     "Asp28 produces Fortran for Type 28 ASPs, used in NAG routine"
     "f02fjf, for example:"
     " "
     "     SUBROUTINE IMAGE(IFLAG,N,Z,W,RWORK,LRWORK,IWORK,LIWORK)"
     "     DOUBLE PRECISION Z(N),W(N),IWORK(LRWORK),RWORK(LRWORK)"
     "     INTEGER N,LIWORK,IFLAG,LRWORK"
     "     W(1)=0.01707454969713436D0*Z(16)+0.001747395874954051D0*Z(15)+0.00"
     "    &2106973900813502D0*Z(14)+0.002957434991769087D0*Z(13)+(-0.00700554"
     "    &0882865317D0*Z(12))+(-0.01219194009813166D0*Z(11))+0.0037230647365"
     "    &3087D0*Z(10)+0.04932374658377151D0*Z(9)+(-0.03586220812223305D0*Z("
     "    &8))+(-0.04723268012114625D0*Z(7))+(-0.02434652144032987D0*Z(6))+0."
     "    &2264766947290192D0*Z(5)+(-0.1385343580686922D0*Z(4))+(-0.116530050"
     "    &8238904D0*Z(3))+(-0.2803531651057233D0*Z(2))+1.019463911841327D0*Z"
     "    &(1)"
     "     W(2)=0.0227345011107737D0*Z(16)+0.008812321197398072D0*Z(15)+0.010"
     "    &94012210519586D0*Z(14)+(-0.01764072463999744D0*Z(13))+(-0.01357136"
     "    &72105995D0*Z(12))+0.00157466157362272D0*Z(11)+0.05258889186338282D"
     "    &0*Z(10)+(-0.01981532388243379D0*Z(9))+(-0.06095390688679697D0*Z(8)"
     "    &)+(-0.04153119955569051D0*Z(7))+0.2176561076571465D0*Z(6)+(-0.0532"
     "    &5555586632358D0*Z(5))+(-0.1688977368984641D0*Z(4))+(-0.32440166056"
     "    &67343D0*Z(3))+0.9128222941872173D0*Z(2)+(-0.2419652703415429D0*Z(1"
     "    &))"
     "     W(3)=0.03371198197190302D0*Z(16)+0.02021603150122265D0*Z(15)+(-0.0"
     "    &06607305534689702D0*Z(14))+(-0.03032392238968179D0*Z(13))+0.002033"
     "    &305231024948D0*Z(12)+0.05375944956767728D0*Z(11)+(-0.0163213312502"
     "    &9967D0*Z(10))+(-0.05483186562035512D0*Z(9))+(-0.04901428822579872D"
     "    &0*Z(8))+0.2091097927887612D0*Z(7)+(-0.05760560341383113D0*Z(6))+(-"
     "    &0.1236679206156403D0*Z(5))+(-0.3523683853026259D0*Z(4))+0.88929961"
     "    &32269974D0*Z(3)+(-0.2995429545781457D0*Z(2))+(-0.02986582812574917"
     "    &D0*Z(1))"
     "     W(4)=0.05141563713660119D0*Z(16)+0.005239165960779299D0*Z(15)+(-0."
     "    &01623427735779699D0*Z(14))+(-0.01965809746040371D0*Z(13))+0.054688"
     "    &97337339577D0*Z(12)+(-0.014224695935687D0*Z(11))+(-0.0505181779315"
     "    &6355D0*Z(10))+(-0.04353074206076491D0*Z(9))+0.2012230497530726D0*Z"
     "    &(8)+(-0.06630874514535952D0*Z(7))+(-0.1280829963720053D0*Z(6))+(-0"
     "    &.305169742604165D0*Z(5))+0.8600427128450191D0*Z(4)+(-0.32415033802"
     "    &68184D0*Z(3))+(-0.09033531980693314D0*Z(2))+0.09089205517109111D0*"
     "    &Z(1)"
     "     W(5)=0.04556369767776375D0*Z(16)+(-0.001822737697581869D0*Z(15))+("
     "    &-0.002512226501941856D0*Z(14))+0.02947046460707379D0*Z(13)+(-0.014"
     "    &45079632086177D0*Z(12))+(-0.05034242196614937D0*Z(11))+(-0.0376966"
     "    &3291725935D0*Z(10))+0.2171103102175198D0*Z(9)+(-0.0824949256021352"
     "    &4D0*Z(8))+(-0.1473995209288945D0*Z(7))+(-0.315042193418466D0*Z(6))"
     "    &+0.9591623347824002D0*Z(5)+(-0.3852396953763045D0*Z(4))+(-0.141718"
     "    &5427288274D0*Z(3))+(-0.03423495461011043D0*Z(2))+0.319820917706851"
     "    &6D0*Z(1)"
     "     W(6)=0.04015147277405744D0*Z(16)+0.01328585741341559D0*Z(15)+0.048"
     "    &26082005465965D0*Z(14)+(-0.04319641116207706D0*Z(13))+(-0.04931323"
     "    &319055762D0*Z(12))+(-0.03526886317505474D0*Z(11))+0.22295383396730"
     "    &01D0*Z(10)+(-0.07375317649315155D0*Z(9))+(-0.1589391311991561D0*Z("
     "    &8))+(-0.328001910890377D0*Z(7))+0.952576555482747D0*Z(6)+(-0.31583"
     "    &09975786731D0*Z(5))+(-0.1846882042225383D0*Z(4))+(-0.0703762046700"
     "    &4427D0*Z(3))+0.2311852964327382D0*Z(2)+0.04254083491825025D0*Z(1)"
     "     W(7)=0.06069778964023718D0*Z(16)+0.06681263884671322D0*Z(15)+(-0.0"
     "    &2113506688615768D0*Z(14))+(-0.083996867458326D0*Z(13))+(-0.0329843"
     "    &8523869648D0*Z(12))+0.2276878326327734D0*Z(11)+(-0.067356038933017"
     "    &95D0*Z(10))+(-0.1559813965382218D0*Z(9))+(-0.3363262957694705D0*Z("
     "    &8))+0.9442791158560948D0*Z(7)+(-0.3199955249404657D0*Z(6))+(-0.136"
     "    &2463839920727D0*Z(5))+(-0.1006185171570586D0*Z(4))+0.2057504515015"
     "    &423D0*Z(3)+(-0.02065879269286707D0*Z(2))+0.03160990266745513D0*Z(1"
     "    &)"
     "     W(8)=0.126386868896738D0*Z(16)+0.002563370039476418D0*Z(15)+(-0.05"
     "    &581757739455641D0*Z(14))+(-0.07777893205900685D0*Z(13))+0.23117338"
     "    &45834199D0*Z(12)+(-0.06031581134427592D0*Z(11))+(-0.14805474755869"
     "    &52D0*Z(10))+(-0.3364014128402243D0*Z(9))+0.9364014128402244D0*Z(8)"
     "    &+(-0.3269452524413048D0*Z(7))+(-0.1396841886557241D0*Z(6))+(-0.056"
     "    &1733845834199D0*Z(5))+0.1777789320590069D0*Z(4)+(-0.04418242260544"
     "    &359D0*Z(3))+(-0.02756337003947642D0*Z(2))+0.07361313110326199D0*Z("
     "    &1)"
     "     W(9)=0.07361313110326199D0*Z(16)+(-0.02756337003947642D0*Z(15))+(-"
     "    &0.04418242260544359D0*Z(14))+0.1777789320590069D0*Z(13)+(-0.056173"
     "    &3845834199D0*Z(12))+(-0.1396841886557241D0*Z(11))+(-0.326945252441"
     "    &3048D0*Z(10))+0.9364014128402244D0*Z(9)+(-0.3364014128402243D0*Z(8"
     "    &))+(-0.1480547475586952D0*Z(7))+(-0.06031581134427592D0*Z(6))+0.23"
     "    &11733845834199D0*Z(5)+(-0.07777893205900685D0*Z(4))+(-0.0558175773"
     "    &9455641D0*Z(3))+0.002563370039476418D0*Z(2)+0.126386868896738D0*Z("
     "    &1)"
     "     W(10)=0.03160990266745513D0*Z(16)+(-0.02065879269286707D0*Z(15))+0"
     "    &.2057504515015423D0*Z(14)+(-0.1006185171570586D0*Z(13))+(-0.136246"
     "    &3839920727D0*Z(12))+(-0.3199955249404657D0*Z(11))+0.94427911585609"
     "    &48D0*Z(10)+(-0.3363262957694705D0*Z(9))+(-0.1559813965382218D0*Z(8"
     "    &))+(-0.06735603893301795D0*Z(7))+0.2276878326327734D0*Z(6)+(-0.032"
     "    &98438523869648D0*Z(5))+(-0.083996867458326D0*Z(4))+(-0.02113506688"
     "    &615768D0*Z(3))+0.06681263884671322D0*Z(2)+0.06069778964023718D0*Z("
     "    &1)"
     "     W(11)=0.04254083491825025D0*Z(16)+0.2311852964327382D0*Z(15)+(-0.0"
     "    &7037620467004427D0*Z(14))+(-0.1846882042225383D0*Z(13))+(-0.315830"
     "    &9975786731D0*Z(12))+0.952576555482747D0*Z(11)+(-0.328001910890377D"
     "    &0*Z(10))+(-0.1589391311991561D0*Z(9))+(-0.07375317649315155D0*Z(8)"
     "    &)+0.2229538339673001D0*Z(7)+(-0.03526886317505474D0*Z(6))+(-0.0493"
     "    &1323319055762D0*Z(5))+(-0.04319641116207706D0*Z(4))+0.048260820054"
     "    &65965D0*Z(3)+0.01328585741341559D0*Z(2)+0.04015147277405744D0*Z(1)"
     "     W(12)=0.3198209177068516D0*Z(16)+(-0.03423495461011043D0*Z(15))+(-"
     "    &0.1417185427288274D0*Z(14))+(-0.3852396953763045D0*Z(13))+0.959162"
     "    &3347824002D0*Z(12)+(-0.315042193418466D0*Z(11))+(-0.14739952092889"
     "    &45D0*Z(10))+(-0.08249492560213524D0*Z(9))+0.2171103102175198D0*Z(8"
     "    &)+(-0.03769663291725935D0*Z(7))+(-0.05034242196614937D0*Z(6))+(-0."
     "    &01445079632086177D0*Z(5))+0.02947046460707379D0*Z(4)+(-0.002512226"
     "    &501941856D0*Z(3))+(-0.001822737697581869D0*Z(2))+0.045563697677763"
     "    &75D0*Z(1)"
     "     W(13)=0.09089205517109111D0*Z(16)+(-0.09033531980693314D0*Z(15))+("
     "    &-0.3241503380268184D0*Z(14))+0.8600427128450191D0*Z(13)+(-0.305169"
     "    &742604165D0*Z(12))+(-0.1280829963720053D0*Z(11))+(-0.0663087451453"
     "    &5952D0*Z(10))+0.2012230497530726D0*Z(9)+(-0.04353074206076491D0*Z("
     "    &8))+(-0.05051817793156355D0*Z(7))+(-0.014224695935687D0*Z(6))+0.05"
     "    &468897337339577D0*Z(5)+(-0.01965809746040371D0*Z(4))+(-0.016234277"
     "    &35779699D0*Z(3))+0.005239165960779299D0*Z(2)+0.05141563713660119D0"
     "    &*Z(1)"
     "     W(14)=(-0.02986582812574917D0*Z(16))+(-0.2995429545781457D0*Z(15))"
     "    &+0.8892996132269974D0*Z(14)+(-0.3523683853026259D0*Z(13))+(-0.1236"
     "    &679206156403D0*Z(12))+(-0.05760560341383113D0*Z(11))+0.20910979278"
     "    &87612D0*Z(10)+(-0.04901428822579872D0*Z(9))+(-0.05483186562035512D"
     "    &0*Z(8))+(-0.01632133125029967D0*Z(7))+0.05375944956767728D0*Z(6)+0"
     "    &.002033305231024948D0*Z(5)+(-0.03032392238968179D0*Z(4))+(-0.00660"
     "    &7305534689702D0*Z(3))+0.02021603150122265D0*Z(2)+0.033711981971903"
     "    &02D0*Z(1)"
     "     W(15)=(-0.2419652703415429D0*Z(16))+0.9128222941872173D0*Z(15)+(-0"
     "    &.3244016605667343D0*Z(14))+(-0.1688977368984641D0*Z(13))+(-0.05325"
     "    &555586632358D0*Z(12))+0.2176561076571465D0*Z(11)+(-0.0415311995556"
     "    &9051D0*Z(10))+(-0.06095390688679697D0*Z(9))+(-0.01981532388243379D"
     "    &0*Z(8))+0.05258889186338282D0*Z(7)+0.00157466157362272D0*Z(6)+(-0."
     "    &0135713672105995D0*Z(5))+(-0.01764072463999744D0*Z(4))+0.010940122"
     "    &10519586D0*Z(3)+0.008812321197398072D0*Z(2)+0.0227345011107737D0*Z"
     "    &(1)"
     "     W(16)=1.019463911841327D0*Z(16)+(-0.2803531651057233D0*Z(15))+(-0."
     "    &1165300508238904D0*Z(14))+(-0.1385343580686922D0*Z(13))+0.22647669"
     "    &47290192D0*Z(12)+(-0.02434652144032987D0*Z(11))+(-0.04723268012114"
     "    &625D0*Z(10))+(-0.03586220812223305D0*Z(9))+0.04932374658377151D0*Z"
     "    &(8)+0.00372306473653087D0*Z(7)+(-0.01219194009813166D0*Z(6))+(-0.0"
     "    &07005540882865317D0*Z(5))+0.002957434991769087D0*Z(4)+0.0021069739"
     "    &00813502D0*Z(3)+0.001747395874954051D0*Z(2)+0.01707454969713436D0*"
     "    &Z(1)"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp28|
  (progn
    (push '|Asp28| *Domains*)
    (make-instance '|Asp28Type|)))

\end{chunk}

\subsection{Asp29}
\index[dom]{Asp29!Domain}
\index[dom]{Domain!Asp29}
\index[dom]{ASP29}
\begin{chunk}{defclass Asp29Type}
(defclass |Asp29Type| (|FortranProgramCategoryType|)
  ((parents :initform '(|FortranProgramCategory|))
   (name :initform "Asp29")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP29)
   (comment :initform (list
     "Asp29 produces Fortran for Type 29 ASPs, needed for NAG routine"
     "f02fjf, for example:"
     " "
     "     SUBROUTINE MONIT(ISTATE,NEXTIT,NEVALS,NEVECS,K,F,D)"
     "     DOUBLE PRECISION D(K),F(K)"
     "     INTEGER K,NEXTIT,NEVALS,NVECS,ISTATE"
     "     CALL F02FJZ(ISTATE,NEXTIT,NEVALS,NEVECS,K,F,D)"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp29|
  (progn
    (push '|Asp29| *Domains*)
    (make-instance '|Asp29Type|)))

\end{chunk}

\subsection{Asp30}
\index[dom]{Asp30!Domain}
\index[dom]{Domain!Asp30}
\index[dom]{ASP30}
\begin{chunk}{defclass Asp30Type}
(defclass |Asp30Type| (|FortranMatrixCategoryType|)
  ((parents :initform '(|FortranMatrixCategory|))
   (name :initform "Asp30")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP30)
   (comment :initform (list
     "Asp30 produces Fortran for Type 30 ASPs, needed for NAG routine"
     "f04qaf, for example:"
     " "
     "     SUBROUTINE APROD(MODE,M,N,X,Y,RWORK,LRWORK,IWORK,LIWORK)"
     "     DOUBLE PRECISION X(N),Y(M),RWORK(LRWORK)"
     "     INTEGER M,N,LIWORK,IFAIL,LRWORK,IWORK(LIWORK),MODE"
     "     DOUBLE PRECISION A(5,5)"
     "     EXTERNAL F06PAF"
     "     A(1,1)=1.0D0"
     "     A(1,2)=0.0D0"
     "     A(1,3)=0.0D0"
     "     A(1,4)=-1.0D0"
     "     A(1,5)=0.0D0"
     "     A(2,1)=0.0D0"
     "     A(2,2)=1.0D0"
     "     A(2,3)=0.0D0"
     "     A(2,4)=0.0D0"
     "     A(2,5)=-1.0D0"
     "     A(3,1)=0.0D0"
     "     A(3,2)=0.0D0"
     "     A(3,3)=1.0D0"
     "     A(3,4)=-1.0D0"
     "     A(3,5)=0.0D0"
     "     A(4,1)=-1.0D0"
     "     A(4,2)=0.0D0"
     "     A(4,3)=-1.0D0"
     "     A(4,4)=4.0D0"
     "     A(4,5)=-1.0D0"
     "     A(5,1)=0.0D0"
     "     A(5,2)=-1.0D0"
     "     A(5,3)=0.0D0"
     "     A(5,4)=-1.0D0"
     "     A(5,5)=4.0D0"
     "     IF(MODE.EQ.1)THEN"
     "       CALL F06PAF('N',M,N,1.0D0,A,M,X,1,1.0D0,Y,1)"
     "     ELSEIF(MODE.EQ.2)THEN"
     "       CALL F06PAF('T',M,N,1.0D0,A,M,Y,1,1.0D0,X,1)"
     "     ENDIF"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp30|
  (progn
    (push '|Asp30| *Domains*)
    (make-instance '|Asp30Type|)))

\end{chunk}

\subsection{Asp31}
\index[dom]{Asp31!Domain}
\index[dom]{Domain!Asp31}
\index[dom]{ASP31}
\begin{chunk}{defclass Asp31Type}
(defclass |Asp31Type| (|FortranVectorFunctionCategoryType|)
  ((parents :initform '(|FortranVectorFunctionCategory|))
   (name :initform "Asp31")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP31)
   (comment :initform (list
     "Asp31 produces Fortran for Type 31 ASPs, needed for NAG routine"
     "d02ejf, for example:"
     " "
     "     SUBROUTINE PEDERV(X,Y,PW)"
     "     DOUBLE PRECISION X,Y(*)"
     "     DOUBLE PRECISION PW(3,3)"
     "     PW(1,1)=-0.03999999999999999D0"
     "     PW(1,2)=10000.0D0*Y(3)"
     "     PW(1,3)=10000.0D0*Y(2)"
     "     PW(2,1)=0.03999999999999999D0"
     "     PW(2,2)=(-10000.0D0*Y(3))+(-60000000.0D0*Y(2))"
     "     PW(2,3)=-10000.0D0*Y(2)"
     "     PW(3,1)=0.0D0"
     "     PW(3,2)=60000000.0D0*Y(2)"
     "     PW(3,3)=0.0D0"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp31|
  (progn
    (push '|Asp31| *Domains*)
    (make-instance '|Asp31Type|)))

\end{chunk}

\subsection{Asp33}
\index[dom]{Asp33!Domain}
\index[dom]{Domain!Asp33}
\index[dom]{ASP33}
\begin{chunk}{defclass Asp33Type}
(defclass |Asp33Type| (|FortranProgramCategoryType|)
  ((parents :initform '(|FortranProgramCategory|))
   (name :initform "Asp33")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP33)
   (comment :initform (list
     "Asp33 produces Fortran for Type 33 ASPs, needed for NAG routine"
     "d02kef.  The code is a dummy ASP:"
     " "
     "     SUBROUTINE REPORT(X,V,JINT)"
     "     DOUBLE PRECISION V(3),X"
     "     INTEGER JINT"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp33|
  (progn
    (push '|Asp33| *Domains*)
    (make-instance '|Asp33Type|)))

\end{chunk}

\subsection{Asp34}
\index[dom]{Asp34!Domain}
\index[dom]{Domain!Asp34}
\index[dom]{ASP34}
\begin{chunk}{defclass Asp34Type}
(defclass |Asp34Type| (|FortranMatrixCategoryType|)
  ((parents :initform '(|FortranMatrixCategory|))
   (name :initform "Asp34")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP34)
   (comment :initform (list
     "Asp34 produces Fortran for Type 34 ASPs, needed for NAG routine"
     "f04mbf, for example:"
     " "
     "     SUBROUTINE MSOLVE(IFLAG,N,X,Y,RWORK,LRWORK,IWORK,LIWORK)"
     "     DOUBLE PRECISION RWORK(LRWORK),X(N),Y(N)"
     "     INTEGER I,J,N,LIWORK,IFLAG,LRWORK,IWORK(LIWORK)"
     "     DOUBLE PRECISION W1(3),W2(3),MS(3,3)"
     "     IFLAG=-1"
     "     MS(1,1)=2.0D0"
     "     MS(1,2)=1.0D0"
     "     MS(1,3)=0.0D0"
     "     MS(2,1)=1.0D0"
     "     MS(2,2)=2.0D0"
     "     MS(2,3)=1.0D0"
     "     MS(3,1)=0.0D0"
     "     MS(3,2)=1.0D0"
     "     MS(3,3)=2.0D0"
     "     CALL F04ASF(MS,N,X,N,Y,W1,W2,IFLAG)"
     "     IFLAG=-IFLAG"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp34|
  (progn
    (push '|Asp34| *Domains*)
    (make-instance '|Asp34Type|)))

\end{chunk}

\subsection{Asp35}
\index[dom]{Asp35!Domain}
\index[dom]{Domain!Asp35}
\index[dom]{ASP35}
\begin{chunk}{defclass Asp35Type}
(defclass |Asp35Type| (|FortranVectorFunctionCategoryType|)
  ((parents :initform '(|FortranVectorFunctionCategory|))
   (name :initform "Asp35")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP35)
   (comment :initform (list
     "Asp35 produces Fortran for Type 35 ASPs, needed for NAG routines"
     "c05pbf, c05pcf, for example:"
     " "
     "     SUBROUTINE FCN(N,X,FVEC,FJAC,LDFJAC,IFLAG)"
     "     DOUBLE PRECISION X(N),FVEC(N),FJAC(LDFJAC,N)"
     "     INTEGER LDFJAC,N,IFLAG"
     "     IF(IFLAG.EQ.1)THEN"
     "       FVEC(1)=(-1.0D0*X(2))+X(1)"
     "       FVEC(2)=(-1.0D0*X(3))+2.0D0*X(2)"
     "       FVEC(3)=3.0D0*X(3)"
     "     ELSEIF(IFLAG.EQ.2)THEN"
     "       FJAC(1,1)=1.0D0"
     "       FJAC(1,2)=-1.0D0"
     "       FJAC(1,3)=0.0D0"
     "       FJAC(2,1)=0.0D0"
     "       FJAC(2,2)=2.0D0"
     "       FJAC(2,3)=-1.0D0"
     "       FJAC(3,1)=0.0D0"
     "       FJAC(3,2)=0.0D0"
     "       FJAC(3,3)=3.0D0"
     "     ENDIF"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp35|
  (progn
    (push '|Asp35| *Domains*)
    (make-instance '|Asp35Type|)))

\end{chunk}

\subsection{Asp4}
\index[dom]{Asp4!Domain}
\index[dom]{Domain!Asp4}
\index[dom]{ASP4}
\begin{chunk}{defclass Asp4Type}
(defclass |Asp4Type| (|FortranFunctionCategoryType|)
  ((parents :initform '(|FortranFunctionCategory|))
   (name :initform "Asp4")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP4)
   (comment :initform (list
     "Asp4 produces Fortran for Type 4 ASPs, which take an expression"
     "in X(1) .. X(NDIM) and produce a real function of the form:"
     " "
     "     DOUBLE PRECISION FUNCTION FUNCTN(NDIM,X)"
     "     DOUBLE PRECISION X(NDIM)"
     "     INTEGER NDIM"
     "     FUNCTN=(4.0D0*X(1)*X(3)**2*DEXP(2.0D0*X(1)*X(3)))/(X(4)**2+(2.0D0*"
     "    &X(2)+2.0D0)*X(4)+X(2)**2+2.0D0*X(2)+1.0D0)"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp4|
  (progn
    (push '|Asp4| *Domains*)
    (make-instance '|Asp4Type|)))

\end{chunk}

\subsection{Asp41}
\index[dom]{Asp41!Domain}
\index[dom]{Domain!Asp41}
\index[dom]{ASP41}
\begin{chunk}{defclass Asp41Type}
(defclass |Asp41Type| (|FortranVectorFunctionCategoryType|)
  ((parents :initform '(|FortranVectorFunctionCategory|))
   (name :initform "Asp41")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP41)
   (comment :initform (list
     "Asp41 produces Fortran for Type 41 ASPs, needed for NAG"
     "routines d02raf and d02saf in particular.  These ASPs are in fact"
     "three Fortran routines which return a vector of functions, and their"
     "derivatives wrt Y(i) and also a continuation parameter EPS, for example:"
     " "
     "     SUBROUTINE FCN(X,EPS,Y,F,N)"
     "     DOUBLE PRECISION EPS,F(N),X,Y(N)"
     "     INTEGER N"
     "     F(1)=Y(2)"
     "     F(2)=Y(3)"
     "     F(3)=(-1.0D0*Y(1)*Y(3))+2.0D0*EPS*Y(2)**2+(-2.0D0*EPS)"
     "     RETURN"
     "     END"
     "     SUBROUTINE JACOBF(X,EPS,Y,F,N)"
     "     DOUBLE PRECISION EPS,F(N,N),X,Y(N)"
     "     INTEGER N"
     "     F(1,1)=0.0D0"
     "     F(1,2)=1.0D0"
     "     F(1,3)=0.0D0"
     "     F(2,1)=0.0D0"
     "     F(2,2)=0.0D0"
     "     F(2,3)=1.0D0"
     "     F(3,1)=-1.0D0*Y(3)"
     "     F(3,2)=4.0D0*EPS*Y(2)"
     "     F(3,3)=-1.0D0*Y(1)"
     "     RETURN"
     "     END"
     "     SUBROUTINE JACEPS(X,EPS,Y,F,N)"
     "     DOUBLE PRECISION EPS,F(N),X,Y(N)"
     "     INTEGER N"
     "     F(1)=0.0D0"
     "     F(2)=0.0D0"
     "     F(3)=2.0D0*Y(2)**2-2.0D0"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp41|
  (progn
    (push '|Asp41| *Domains*)
    (make-instance '|Asp41Type|)))

\end{chunk}

\subsection{Asp42}
\index[dom]{Asp42!Domain}
\index[dom]{Domain!Asp42}
\index[dom]{ASP42}
\begin{chunk}{defclass Asp42Type}
(defclass |Asp42Type| (|FortranVectorFunctionCategoryType|)
  ((parents :initform '(|FortranVectorFunctionCategory|))
   (name :initform "Asp42")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP42)
   (comment :initform (list
     "Asp42 produces Fortran for Type 42 ASPs, needed for NAG"
     "routines d02raf and d02saf"
     "in particular.  These ASPs are in fact"
     "three Fortran routines which return a vector of functions, and their"
     "derivatives wrt Y(i) and also a continuation parameter EPS, for example:"
     " "
     "     SUBROUTINE G(EPS,YA,YB,BC,N)"
     "     DOUBLE PRECISION EPS,YA(N),YB(N),BC(N)"
     "     INTEGER N"
     "     BC(1)=YA(1)"
     "     BC(2)=YA(2)"
     "     BC(3)=YB(2)-1.0D0"
     "     RETURN"
     "     END"
     "     SUBROUTINE JACOBG(EPS,YA,YB,AJ,BJ,N)"
     "     DOUBLE PRECISION EPS,YA(N),AJ(N,N),BJ(N,N),YB(N)"
     "     INTEGER N"
     "     AJ(1,1)=1.0D0"
     "     AJ(1,2)=0.0D0"
     "     AJ(1,3)=0.0D0"
     "     AJ(2,1)=0.0D0"
     "     AJ(2,2)=1.0D0"
     "     AJ(2,3)=0.0D0"
     "     AJ(3,1)=0.0D0"
     "     AJ(3,2)=0.0D0"
     "     AJ(3,3)=0.0D0"
     "     BJ(1,1)=0.0D0"
     "     BJ(1,2)=0.0D0"
     "     BJ(1,3)=0.0D0"
     "     BJ(2,1)=0.0D0"
     "     BJ(2,2)=0.0D0"
     "     BJ(2,3)=0.0D0"
     "     BJ(3,1)=0.0D0"
     "     BJ(3,2)=1.0D0"
     "     BJ(3,3)=0.0D0"
     "     RETURN"
     "     END"
     "     SUBROUTINE JACGEP(EPS,YA,YB,BCEP,N)"
     "     DOUBLE PRECISION EPS,YA(N),YB(N),BCEP(N)"
     "     INTEGER N"
     "     BCEP(1)=0.0D0"
     "     BCEP(2)=0.0D0"
     "     BCEP(3)=0.0D0"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp42|
  (progn
    (push '|Asp42| *Domains*)
    (make-instance '|Asp42Type|)))

\end{chunk}

\subsection{Asp49}
\index[dom]{Asp49!Domain}
\index[dom]{Domain!Asp49}
\index[dom]{ASP49}
\begin{chunk}{defclass Asp49Type}
(defclass |Asp49Type| (|FortranFunctionCategoryType|)
  ((parents :initform '(|FortranFunctionCategory|))
   (name :initform "Asp49")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP49)
   (comment :initform (list
     "Asp49 produces Fortran for Type 49 ASPs, needed for NAG routines"
     "e04dgf, e04ucf, for example:"
     " "
     "     SUBROUTINE OBJFUN(MODE,N,X,OBJF,OBJGRD,NSTATE,IUSER,USER)"
     "     DOUBLE PRECISION X(N),OBJF,OBJGRD(N),USER(*)"
     "     INTEGER N,IUSER(*),MODE,NSTATE"
     "     OBJF=X(4)*X(9)+((-1.0D0*X(5))+X(3))*X(8)+((-1.0D0*X(3))+X(1))*X(7)"
     "    &+(-1.0D0*X(2)*X(6))"
     "     OBJGRD(1)=X(7)"
     "     OBJGRD(2)=-1.0D0*X(6)"
     "     OBJGRD(3)=X(8)+(-1.0D0*X(7))"
     "     OBJGRD(4)=X(9)"
     "     OBJGRD(5)=-1.0D0*X(8)"
     "     OBJGRD(6)=-1.0D0*X(2)"
     "     OBJGRD(7)=(-1.0D0*X(3))+X(1)"
     "     OBJGRD(8)=(-1.0D0*X(5))+X(3)"
     "     OBJGRD(9)=X(4)"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp49|
  (progn
    (push '|Asp49| *Domains*)
    (make-instance '|Asp49Type|)))

\end{chunk}

\subsection{Asp50}
\index[dom]{Asp50!Domain}
\index[dom]{Domain!Asp50}
\index[dom]{ASP50}
\begin{chunk}{defclass Asp50Type}
(defclass |Asp50Type| (|FortranVectorFunctionCategoryType|)
  ((parents :initform '(|FortranVectorFunctionCategory|))
   (name :initform "Asp50")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP50)
   (comment :initform (list
     "Asp50 produces Fortran for Type 50 ASPs, needed for NAG routine"
     "e04fdf, for example:"
     " "
     "     SUBROUTINE LSFUN1(M,N,XC,FVECC)"
     "     DOUBLE PRECISION FVECC(M),XC(N)"
     "     INTEGER I,M,N"
     "     FVECC(1)=((XC(1)-2.4D0)*XC(3)+(15.0D0*XC(1)-36.0D0)*XC(2)+1.0D0)/("
     "    &XC(3)+15.0D0*XC(2))"
     "     FVECC(2)=((XC(1)-2.8D0)*XC(3)+(7.0D0*XC(1)-19.6D0)*XC(2)+1.0D0)/(X"
     "    &C(3)+7.0D0*XC(2))"
     "     FVECC(3)=((XC(1)-3.2D0)*XC(3)+(4.333333333333333D0*XC(1)-13.866666"
     "    &66666667D0)*XC(2)+1.0D0)/(XC(3)+4.333333333333333D0*XC(2))"
     "     FVECC(4)=((XC(1)-3.5D0)*XC(3)+(3.0D0*XC(1)-10.5D0)*XC(2)+1.0D0)/(X"
     "    &C(3)+3.0D0*XC(2))"
     "     FVECC(5)=((XC(1)-3.9D0)*XC(3)+(2.2D0*XC(1)-8.579999999999998D0)*XC"
     "    &(2)+1.0D0)/(XC(3)+2.2D0*XC(2))"
     "     FVECC(6)=((XC(1)-4.199999999999999D0)*XC(3)+(1.666666666666667D0*X"
     "    &C(1)-7.0D0)*XC(2)+1.0D0)/(XC(3)+1.666666666666667D0*XC(2))"
     "     FVECC(7)=((XC(1)-4.5D0)*XC(3)+(1.285714285714286D0*XC(1)-5.7857142"
     "    &85714286D0)*XC(2)+1.0D0)/(XC(3)+1.285714285714286D0*XC(2))"
     "     FVECC(8)=((XC(1)-4.899999999999999D0)*XC(3)+(XC(1)-4.8999999999999"
     "    &99D0)*XC(2)+1.0D0)/(XC(3)+XC(2))"
     "     FVECC(9)=((XC(1)-4.699999999999999D0)*XC(3)+(XC(1)-4.6999999999999"
     "    &99D0)*XC(2)+1.285714285714286D0)/(XC(3)+XC(2))"
     "     FVECC(10)=((XC(1)-6.8D0)*XC(3)+(XC(1)-6.8D0)*XC(2)+1.6666666666666"
     "    &67D0)/(XC(3)+XC(2))"
     "     FVECC(11)=((XC(1)-8.299999999999999D0)*XC(3)+(XC(1)-8.299999999999"
     "    &999D0)*XC(2)+2.2D0)/(XC(3)+XC(2))"
     "     FVECC(12)=((XC(1)-10.6D0)*XC(3)+(XC(1)-10.6D0)*XC(2)+3.0D0)/(XC(3)"
     "    &+XC(2))"
     "     FVECC(13)=((XC(1)-1.34D0)*XC(3)+(XC(1)-1.34D0)*XC(2)+4.33333333333"
     "    &3333D0)/(XC(3)+XC(2))"
     "     FVECC(14)=((XC(1)-2.1D0)*XC(3)+(XC(1)-2.1D0)*XC(2)+7.0D0)/(XC(3)+X"
     "    &C(2))"
     "     FVECC(15)=((XC(1)-4.39D0)*XC(3)+(XC(1)-4.39D0)*XC(2)+15.0D0)/(XC(3"
     "    &)+XC(2))"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp50|
  (progn
    (push '|Asp50| *Domains*)
    (make-instance '|Asp50Type|)))

\end{chunk}

\subsection{Asp55}
\index[dom]{Asp55!Domain}
\index[dom]{Domain!Asp55}
\index[dom]{ASP55}
\begin{chunk}{defclass Asp55Type}
(defclass |Asp55Type| (|FortranVectorFunctionCategoryType|)
  ((parents :initform '(|FortranVectorFunctionCategory|))
   (name :initform "Asp55")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP55)
   (comment :initform (list
     "Asp55 produces Fortran for Type 55 ASPs, needed for NAG routines"
     "e04dgf and e04ucf, for example:"
     " "
     "     SUBROUTINE CONFUN(MODE,NCNLN,N,NROWJ,NEEDC,X,C,CJAC,NSTATE,IUSER"
     "    &,USER)"
     "     DOUBLE PRECISION C(NCNLN),X(N),CJAC(NROWJ,N),USER(*)"
     "     INTEGER N,IUSER(*),NEEDC(NCNLN),NROWJ,MODE,NCNLN,NSTATE"
     "     IF(NEEDC(1).GT.0)THEN"
     "       C(1)=X(6)**2+X(1)**2"
     "       CJAC(1,1)=2.0D0*X(1)"
     "       CJAC(1,2)=0.0D0"
     "       CJAC(1,3)=0.0D0"
     "       CJAC(1,4)=0.0D0"
     "       CJAC(1,5)=0.0D0"
     "       CJAC(1,6)=2.0D0*X(6)"
     "     ENDIF"
     "     IF(NEEDC(2).GT.0)THEN"
     "       C(2)=X(2)**2+(-2.0D0*X(1)*X(2))+X(1)**2"
     "       CJAC(2,1)=(-2.0D0*X(2))+2.0D0*X(1)"
     "       CJAC(2,2)=2.0D0*X(2)+(-2.0D0*X(1))"
     "       CJAC(2,3)=0.0D0"
     "       CJAC(2,4)=0.0D0"
     "       CJAC(2,5)=0.0D0"
     "       CJAC(2,6)=0.0D0"
     "     ENDIF"
     "     IF(NEEDC(3).GT.0)THEN"
     "       C(3)=X(3)**2+(-2.0D0*X(1)*X(3))+X(2)**2+X(1)**2"
     "       CJAC(3,1)=(-2.0D0*X(3))+2.0D0*X(1)"
     "       CJAC(3,2)=2.0D0*X(2)"
     "       CJAC(3,3)=2.0D0*X(3)+(-2.0D0*X(1))"
     "       CJAC(3,4)=0.0D0"
     "       CJAC(3,5)=0.0D0"
     "       CJAC(3,6)=0.0D0"
     "     ENDIF"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp55|
  (progn
    (push '|Asp55| *Domains*)
    (make-instance '|Asp55Type|)))

\end{chunk}

\subsection{Asp6}
\index[dom]{Asp6!Domain}
\index[dom]{Domain!Asp6}
\index[dom]{ASP6}
\begin{chunk}{defclass Asp6Type}
(defclass |Asp6Type| (|FortranVectorFunctionCategoryType|)
  ((parents :initform '(|FortranVectorFunctionCategory|))
   (name :initform "Asp6")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP6)
   (comment :initform (list
     "Asp6 produces Fortran for Type 6 ASPs, needed for NAG routines"
     "c05nbf, c05ncf. These represent vectors of functions of X(i) and look like:"
     " "
     "     SUBROUTINE FCN(N,X,FVEC,IFLAG)"
     "     DOUBLE PRECISION X(N),FVEC(N)"
     "     INTEGER N,IFLAG"
     "     FVEC(1)=(-2.0D0*X(2))+(-2.0D0*X(1)**2)+3.0D0*X(1)+1.0D0"
     "     FVEC(2)=(-2.0D0*X(3))+(-2.0D0*X(2)**2)+3.0D0*X(2)+(-1.0D0*X(1))+1."
     "    &0D0"
     "     FVEC(3)=(-2.0D0*X(4))+(-2.0D0*X(3)**2)+3.0D0*X(3)+(-1.0D0*X(2))+1."
     "    &0D0"
     "     FVEC(4)=(-2.0D0*X(5))+(-2.0D0*X(4)**2)+3.0D0*X(4)+(-1.0D0*X(3))+1."
     "    &0D0"
     "     FVEC(5)=(-2.0D0*X(6))+(-2.0D0*X(5)**2)+3.0D0*X(5)+(-1.0D0*X(4))+1."
     "    &0D0"
     "     FVEC(6)=(-2.0D0*X(7))+(-2.0D0*X(6)**2)+3.0D0*X(6)+(-1.0D0*X(5))+1."
     "    &0D0"
     "     FVEC(7)=(-2.0D0*X(8))+(-2.0D0*X(7)**2)+3.0D0*X(7)+(-1.0D0*X(6))+1."
     "    &0D0"
     "     FVEC(8)=(-2.0D0*X(9))+(-2.0D0*X(8)**2)+3.0D0*X(8)+(-1.0D0*X(7))+1."
     "    &0D0"
     "     FVEC(9)=(-2.0D0*X(9)**2)+3.0D0*X(9)+(-1.0D0*X(8))+1.0D0"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp6|
  (progn
    (push '|Asp6| *Domains*)
    (make-instance '|Asp6Type|)))

\end{chunk}

\subsection{Asp7}
\index[dom]{Asp7!Domain}
\index[dom]{Domain!Asp7}
\index[dom]{ASP7}
\begin{chunk}{defclass Asp7Type}
(defclass |Asp7Type| (|FortranVectorFunctionCategoryType|)
  ((parents :initform '(|FortranVectorFunctionCategory|))
   (name :initform "Asp7")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP7)
   (comment :initform (list
     "Asp7 produces Fortran for Type 7 ASPs, needed for NAG routines"
     "d02bbf, d02gaf. These represent a vector of functions of the scalar X and"
     "the array Z, and look like:"
     " "
     "     SUBROUTINE FCN(X,Z,F)"
     "     DOUBLE PRECISION F(*),X,Z(*)"
     "     F(1)=DTAN(Z(3))"
     "     F(2)=((-0.03199999999999999D0*DCOS(Z(3))*DTAN(Z(3)))+(-0.02D0*Z(2)"
     "    &**2))/(Z(2)*DCOS(Z(3)))"
     "     F(3)=-0.03199999999999999D0/(X*Z(2)**2)"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp7|
  (progn
    (push '|Asp7| *Domains*)
    (make-instance '|Asp7Type|)))

\end{chunk}

\subsection{Asp73}
\index[dom]{Asp73!Domain}
\index[dom]{Domain!Asp73}
\index[dom]{ASP73}
\begin{chunk}{defclass Asp73Type}
(defclass |Asp73Type| (|FortranVectorFunctionCategoryType|)
  ((parents :initform '(|FortranVectorFunctionCategory|))
   (name :initform "Asp73")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP73)
   (comment :initform (list
     "Asp73 produces Fortran for Type 73 ASPs, needed for NAG routine"
     "d03eef, for example:"
     " "
     "     SUBROUTINE PDEF(X,Y,ALPHA,BETA,GAMMA,DELTA,EPSOLN,PHI,PSI)"
     "     DOUBLE PRECISION ALPHA,EPSOLN,PHI,X,Y,BETA,DELTA,GAMMA,PSI"
     "     ALPHA=DSIN(X)"
     "     BETA=Y"
     "     GAMMA=X*Y"
     "     DELTA=DCOS(X)*DSIN(Y)"
     "     EPSOLN=Y+X"
     "     PHI=X"
     "     PSI=Y"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp73|
  (progn
    (push '|Asp73| *Domains*)
    (make-instance '|Asp73Type|)))

\end{chunk}

\subsection{Asp74}
\index[dom]{Asp74!Domain}
\index[dom]{Domain!Asp74}
\index[dom]{ASp74}
\begin{chunk}{defclass Asp74Type}
(defclass |Asp74Type| (|FortranMatrixFunctionCategoryType|)
  ((parents :initform '(|FortranMatrixFunctionCategory|))
   (name :initform "Asp74")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP74)
   (comment :initform (list
     "Asp74 produces Fortran for Type 74 ASPs, needed for NAG routine"
     "d03eef, for example:"
     " "
     "     SUBROUTINE BNDY(X,Y,A,B,C,IBND)"
     "     DOUBLE PRECISION A,B,C,X,Y"
     "     INTEGER IBND"
     "     IF(IBND.EQ.0)THEN"
     "       A=0.0D0"
     "       B=1.0D0"
     "       C=-1.0D0*DSIN(X)"
     "     ELSEIF(IBND.EQ.1)THEN"
     "       A=1.0D0"
     "       B=0.0D0"
     "       C=DSIN(X)*DSIN(Y)"
     "     ELSEIF(IBND.EQ.2)THEN"
     "       A=1.0D0"
     "       B=0.0D0"
     "       C=DSIN(X)*DSIN(Y)"
     "     ELSEIF(IBND.EQ.3)THEN"
     "       A=0.0D0"
     "       B=1.0D0"
     "       C=-1.0D0*DSIN(Y)"
     "     ENDIF"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp74|
  (progn
    (push '|Asp74| *Domains*)
    (make-instance '|Asp74Type|)))

\end{chunk}

\subsection{Asp77}
\index[dom]{Asp77!Domain}
\index[dom]{Domain!Asp77}
\index[dom]{ASP77}
\begin{chunk}{defclass Asp77Type}
(defclass |Asp77Type| (|FortranMatrixFunctionCategoryType|)
  ((parents :initform '(|FortranMatrixFunctionCategory|))
   (name :initform "Asp77")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP77)
   (comment :initform (list
     "Asp77 produces Fortran for Type 77 ASPs, needed for NAG routine"
     "d02gbf, for example:"
     " "
     "     SUBROUTINE FCNF(X,F)"
     "     DOUBLE PRECISION X"
     "     DOUBLE PRECISION F(2,2)"
     "     F(1,1)=0.0D0"
     "     F(1,2)=1.0D0"
     "     F(2,1)=0.0D0"
     "     F(2,2)=-10.0D0"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp77|
  (progn
    (push '|Asp77| *Domains*)
    (make-instance '|Asp77Type|)))

\end{chunk}

\subsection{Asp78}
\index[dom]{Asp78!Domain}
\index[dom]{Domain!Asp78}
\index[dom]{ASP78}
\begin{chunk}{defclass Asp78Type}
(defclass |Asp78Type| (|FortranVectorFunctionCategoryType|)
  ((parents :initform '(|FortranVectorFunctionCategory|))
   (name :initform "Asp78")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP78)
   (comment :initform (list
     "Asp78 produces Fortran for Type 78 ASPs, needed for NAG routine"
     "d02gbf, for example:"
     " "
     "     SUBROUTINE FCNG(X,G)"
     "     DOUBLE PRECISION G(*),X"
     "     G(1)=0.0D0"
     "     G(2)=0.0D0"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp78|
  (progn
    (push '|Asp78| *Domains*)
    (make-instance '|Asp78Type|)))

\end{chunk}

\subsection{Asp8}
\index[dom]{Asp8!Domain}
\index[dom]{Domain!Asp8}
\index[dom]{ASP8}
\begin{chunk}{defclass Asp8Type}
(defclass |Asp8Type| (|FortranVectorCategoryType|)
  ((parents :initform '(|FortranVectorCategory|))
   (name :initform "Asp8")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP8)
   (comment :initform (list
     "Asp8 produces Fortran for Type 8 ASPs, needed for NAG routine"
     "d02bbf.  This ASP prints intermediate values of the computed solution of"
     "an ODE and might look like:"
     " "
     "     SUBROUTINE OUTPUT(XSOL,Y,COUNT,M,N,RESULT,FORWRD)"
     "     DOUBLE PRECISION Y(N),RESULT(M,N),XSOL"
     "     INTEGER M,N,COUNT"
     "     LOGICAL FORWRD"
     "     DOUBLE PRECISION X02ALF,POINTS(8)"
     "     EXTERNAL X02ALF"
     "     INTEGER I"
     "     POINTS(1)=1.0D0"
     "     POINTS(2)=2.0D0"
     "     POINTS(3)=3.0D0"
     "     POINTS(4)=4.0D0"
     "     POINTS(5)=5.0D0"
     "     POINTS(6)=6.0D0"
     "     POINTS(7)=7.0D0"
     "     POINTS(8)=8.0D0"
     "     COUNT=COUNT+1"
     "     DO 25001 I=1,N"
     "        RESULT(COUNT,I)=Y(I)"
     "25001 CONTINUE"
     "     IF(COUNT.EQ.M)THEN"
     "       IF(FORWRD)THEN"
     "         XSOL=X02ALF()"
     "       ELSE"
     "         XSOL=-X02ALF()"
     "       ENDIF"
     "     ELSE"
     "        XSOL=POINTS(COUNT)"
     "     ENDIF"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp8|
  (progn
    (push '|Asp8| *Domains*)
    (make-instance '|Asp8Type|)))

\end{chunk}

\subsection{Asp80}
\index[dom]{Asp80!Domain}
\index[dom]{Domain!Asp80}
\index[dom]{ASP80}
\begin{chunk}{defclass Asp80Type}
(defclass |Asp80Type| (|FortranMatrixFunctionCategoryType|)
  ((parents :initform '(|FortranMatrixFunctionCategory|))
   (name :initform "Asp80")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP80)
   (comment :initform (list
     "Asp80 produces Fortran for Type 80 ASPs, needed for NAG routine"
     "d02kef, for example:"
     " "
     "     SUBROUTINE BDYVAL(XL,XR,ELAM,YL,YR)"
     "     DOUBLE PRECISION ELAM,XL,YL(3),XR,YR(3)"
     "     YL(1)=XL"
     "     YL(2)=2.0D0"
     "     YR(1)=1.0D0"
     "     YR(2)=-1.0D0*DSQRT(XR+(-1.0D0*ELAM))"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp80|
  (progn
    (push '|Asp80| *Domains*)
    (make-instance '|Asp80Type|)))

\end{chunk}

\subsection{Asp9}
\index[dom]{Asp9!Domain}
\index[dom]{Domain!Asp9}
\index[dom]{ASP9}
\begin{chunk}{defclass Asp9Type}
(defclass |Asp9Type| (|FortranFunctionCategoryType|)
  ((parents :initform '(|FortranFunctionCategory|))
   (name :initform "Asp9")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP9)
   (comment :initform (list
     "Asp9 produces Fortran for Type 9 ASPs, needed for NAG routines"
     "d02bhf, d02cjf, d02ejf."
     "These ASPs represent a function of a scalar X and a vector Y, for example:"
     " "
     "     DOUBLE PRECISION FUNCTION G(X,Y)"
     "     DOUBLE PRECISION X,Y(*)"
     "     G=X+Y(1)"
     "     RETURN"
     "     END"
     " "
     "If the user provides a constant value for G, then extra information is added"
     "via COMMON blocks used by certain routines.  This specifies that the value"
     "returned by G in this case is to be ignored."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp9|
  (progn
    (push '|Asp9| *Domains*)
    (make-instance '|Asp9Type|)))

\end{chunk}

\subsection{AssociatedJordanAlgebra}
\index[dom]{AssociatedJordanAlgebra!Domain}
\index[dom]{Domain!AssociatedJordanAlgebra}
\index[dom]{JORDAN}
\begin{chunk}{defclass AssociatedJordanAlgebraType}
(defclass |AssociatedJordanAlgebraType| (|FramedNonAssociativeAlgebraType|)
  ((parents :initform '(|FramedNonAssociativeAlgebra|))
   (name :initform "AssociatedJordanAlgebra")
   (marker :initform 'domain)
   (abbreviation :initform 'JORDAN)
   (comment :initform (list
     "AssociatedJordanAlgebra takes an algebra A and uses *$A"
     "to define the new multiplications a*b := (a *$A b + b *$A a)/2"
     "(anticommutator)."
     "The usual notation {a,b}_+ cannot be used due to"
     "restrictions in the current language."
     "This domain only gives a Jordan algebra if the"
     "Jordan-identity (a*b)*c + (b*c)*a + (c*a)*b = 0 holds"
     "for all a,b,c in A."
     "This relation can be checked by"
     "jordanAdmissible?()$A."
     " "
     "If the underlying algebra is of type"
     "FramedNonAssociativeAlgebra(R) (a non"
     "associative algebra over R which is a free R-module of finite"
     "rank, together with a fixed R-module basis), then the same"
     "is true for the associated Jordan algebra."
     "Moreover, if the underlying algebra is of type"
     "FiniteRankNonAssociativeAlgebra(R) (a non"
     "associative algebra over R which is a free R-module of finite"
     "rank), then the same true for the associated Jordan algebra."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AssociatedJordanAlgebra|
  (progn
    (push '|AssociatedJordanAlgebra| *Domains*)
    (make-instance '|AssociatedJordanAlgebraType|)))

\end{chunk}

\subsection{AssociatedLieAlgebra}
\index[dom]{AssociatedLieAlgebra!Domain}
\index[dom]{Domain!AssociatedLieAlgebra}
\index[dom]{LIE}
\begin{chunk}{defclass AssociatedLieAlgebraType}
(defclass |AssociatedLieAlgebraType| (|FramedNonAssociativeAlgebraType|)
  ((parents :initform '(|FramedNonAssociativeAlgebra|))
   (name :initform "AssociatedLieAlgebra")
   (marker :initform 'domain)
   (abbreviation :initform 'LIE)
   (comment :initform (list
     "AssociatedLieAlgebra takes an algebra A"
     "and uses *$A to define the"
     "Lie bracket a*b := (a *$A b - b *$A a) (commutator). Note that"
     "the notation [a,b] cannot be used due to"
     "restrictions of the current compiler."
     "This domain only gives a Lie algebra if the"
     "Jacobi-identity (a*b)*c + (b*c)*a + (c*a)*b = 0 holds"
     "for all a,b,c in A."
     "This relation can be checked by"
     "lieAdmissible?()$A."
     " "
     "If the underlying algebra is of type"
     "FramedNonAssociativeAlgebra(R) (a non"
     "associative algebra over R which is a free R-module of finite"
     "rank, together with a fixed R-module basis), then the same"
     "is true for the associated Lie algebra."
     "Also, if the underlying algebra is of type"
     "FiniteRankNonAssociativeAlgebra(R) (a non"
     "associative algebra over R which is a free R-module of finite"
     "rank), then the same is true for the associated Lie algebra."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AssociatedLieAlgebra|
  (progn
    (push '|AssociatedLieAlgebra| *Domains*)
    (make-instance '|AssociatedLieAlgebraType|)))

\end{chunk}

\subsection{AssociationList}
\index[dom]{AssociationList!Domain}
\index[dom]{Domain!AssociationList}
\index[dom]{ALIST}
\begin{chunk}{defclass AssociationListType}
(defclass |AssociationListType| (|AssociationListAggregateType|)
  ((parents :initform '(|AssociationListAggregate|))
   (name :initform "AssociationList")
   (marker :initform 'domain)
   (abbreviation :initform 'ALIST)
   (comment :initform (list
     "AssociationList implements association lists. These"
     "may be viewed as lists of pairs where the first part is a key"
     "and the second is the stored value. For example, the key might"
     "be a string with a persons employee identification number and"
     "the value might be a record with personnel data."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AssociationList|
  (progn
    (push '|AssociationList| *Domains*)
    (make-instance '|AssociationListType|)))

\end{chunk}

\subsection{AttributeButtons}
\index[dom]{AttributeButtons!Domain}
\index[dom]{Domain!AttributeButtons}
\index[dom]{ATTRBUT}
\begin{chunk}{defclass AttributeButtonsType}
(defclass |AttributeButtonsType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "AttributeButtons")
   (marker :initform 'domain)
   (abbreviation :initform 'ATTRBUT)
   (comment :initform (list
     "AttributeButtons implements a database and associated"
     "adjustment mechanisms for a set of attributes."
     " "
     "For ODEs these attributes are 'stiffness', 'stability' (how much"
     "affect the cosine or sine component of the solution has on the stability of"
     "the result), 'accuracy' and 'expense' (how expensive is the evaluation"
     "of the ODE).  All these have bearing on the cost of calculating the"
     "solution given that reducing the step-length to achieve greater accuracy"
     "requires considerable number of evaluations and calculations."
     " "
     "The effect of each of these attributes can be altered by increasing or"
     "decreasing the button value."
     " "
     "For Integration there is a button for increasing and decreasing the preset"
     "number of function evaluations for each method.  This is automatically used"
     "by ANNA when a method fails due to insufficient workspace or where the"
     "limit of function evaluations has been reached before the required"
     "accuracy is achieved."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AttributeButtons|
  (progn
    (push '|AttributeButtons| *Domains*)
    (make-instance '|AttributeButtonsType|)))

\end{chunk}

\subsection{Automorphism}
\index[dom]{Automorphism!Domain}
\index[dom]{Domain!Automorphism}
\index[dom]{AUTOMOR}
\begin{chunk}{defclass AutomorphismType}
(defclass |AutomorphismType| (|EltableType| |GroupType|)
  ((parents :initform '(|Eltable| |Group|))
   (name :initform "Automorphism")
   (marker :initform 'domain)
   (abbreviation :initform 'AUTOMOR)
   (comment :initform (list
     "Automorphism R is the multiplicative group of automorphisms of R."
     "In fact, non-invertible endomorphism are allowed as partial functions."
     "This domain is noncanonical in that f*f^{-1} will be the identity"
     "function but won't be equal to 1."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Automorphism|
  (progn
    (push '|Automorphism| *Domains*)
    (make-instance '|AutomorphismType|)))

\end{chunk}

\section{B}

\subsection{BalancedBinaryTree}
\index[dom]{BalancedBinaryTree!Domain}
\index[dom]{Domain!BalancedBinaryTree}
\index[dom]{BBTREE}
\begin{chunk}{defclass BalancedBinaryTreeType}
(defclass |BalancedBinaryTreeType| (|BinaryTreeCategoryType|)
  ((parents :initform '(|BinaryTreeCategory|))
   (name :initform "BalancedBinaryTree")
   (marker :initform 'domain)
   (abbreviation :initform 'BBTREE)
   (comment :initform (list
     "BalancedBinaryTree(S) is the domain of balanced"
     "binary trees (bbtree). A balanced binary tree of 2**k leaves,"
     "for some k > 0, is symmetric, that is, the left and right"
     "subtree of each interior node have identical shape."
     "In general, the left and right subtree of a given node can differ"
     "by at most leaf node."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BalancedBinaryTree|
  (progn
    (push '|BalancedBinaryTree| *Domains*)
    (make-instance '|BalancedBinaryTreeType|)))

\end{chunk}

\subsection{BalancedPAdicInteger}
\index[dom]{BalancedPAdicInteger!Domain}
\index[dom]{Domain!BalancedPAdicInteger}
\index[dom]{BPADIC}
\begin{chunk}{defclass BalancedPAdicIntegerType}
(defclass |BalancedPAdicIntegerType| (|PAdicIntegerCategoryType|)
  ((parents :initform '(|PAdicIntegerCategory|))
   (name :initform "BalancedPAdicInteger")
   (marker :initform 'domain)
   (abbreviation :initform 'BPADIC)
   (comment :initform (list
     "Stream-based implementation of Zp: p-adic numbers are represented as"
     "sum(i = 0.., a[i] * p^i), where the a[i] lie in -(p - 1)/2,...,(p - 1)/2."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BalancedPAdicInteger|
  (progn
    (push '|BalancedPAdicInteger| *Domains*)
    (make-instance '|BalancedPAdicIntegerType|)))

\end{chunk}

\subsection{BalancedPAdicRational}
\index[dom]{BalancedPAdicRational!Domain}
\index[dom]{Domain!BalancedPAdicRational}
\index[dom]{BPADICRT}
\begin{chunk}{defclass BalancedPAdicRationalType}
(defclass |BalancedPAdicRationalType| (|QuotientFieldCategoryType|)
  ((parents :initform '(|QuotientFieldCategory|))
   (name :initform "BalancedPAdicRational")
   (marker :initform 'domain)
   (abbreviation :initform 'BPADICRT)
   (comment :initform (list
     "Stream-based implementation of Qp: numbers are represented as"
     "sum(i = k.., a[i] * p^i), where the a[i] lie in -(p - 1)/2,...,(p - 1)/2."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BalancedPAdicRational|
  (progn
    (push '|BalancedPAdicRational| *Domains*)
    (make-instance '|BalancedPAdicRationalType|)))

\end{chunk}

\subsection{BasicFunctions}
\index[dom]{BasicFunctions!Domain}
\index[dom]{Domain!BasicFunctions}
\index[dom]{BFUNCT}
\begin{chunk}{defclass BasicFunctionsType}
(defclass |BasicFunctionsType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "BasicFunctions")
   (marker :initform 'domain)
   (abbreviation :initform 'BFUNCT)
   (comment :initform (list
     "A Domain which implements a table containing details of"
     "points at which particular functions have evaluation problems."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BasicFunctions|
  (progn
    (push '|BasicFunctions| *Domains*)
    (make-instance '|BasicFunctionsType|)))

\end{chunk}

\subsection{BasicOperator}
\index[dom]{BasicOperator!Domain}
\index[dom]{Domain!BasicOperator}
\index[dom]{BOP}
\begin{chunk}{defclass BasicOperatorType}
(defclass |BasicOperatorType| (|OrderedSetType|)
  ((parents :initform '(|OrderedSet|))
   (name :initform "BasicOperator")
   (marker :initform 'domain)
   (abbreviation :initform 'BOP)
   (comment :initform (list
     "A basic operator is an object that can be applied to a list of"
     "arguments from a set, the result being a kernel over that set."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BasicOperator|
  (progn
    (push '|BasicOperator| *Domains*)
    (make-instance '|BasicOperatorType|)))

\end{chunk}

\subsection{BasicStochasticDifferential}
\index[dom]{BasicStochasticDifferential!Domain}
\index[dom]{Domain!BasicStochasticDifferential}
\index[dom]{BSD}
\begin{chunk}{defclass BasicStochasticDifferentialType}
(defclass |BasicStochasticDifferentialType| (|ConvertibleToType| |OrderedSetType|)
  ((parents :initform '(|ConvertibleTo| |OrderedSet|))
   (name :initform "BasicStochasticDifferential")
   (marker :initform 'domain)
   (abbreviation :initform 'BSD)
   (comment :initform (list
     "Based on Symbol: a domain of symbols representing basic stochastic"
     "differentials, used in StochasticDifferential(R) in the underlying"
     "sparse multivariate polynomial representation."
     " "
     "We create new BSD only by coercion from Symbol using a special"
     "function introduce! first of all to add to a private set SDset."
     "We allow a separate function convertIfCan which will check whether the"
     "argument has previously been declared as a BSD."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BasicStochasticDifferential|
  (progn
    (push '|BasicStochasticDifferential| *Domains*)
    (make-instance '|BasicStochasticDifferentialType|)))

\end{chunk}

\subsection{BinaryExpansion}
\index[dom]{BinaryExpansion!Domain}
\index[dom]{Domain!BinaryExpansion}
\index[dom]{BINARY}
\begin{chunk}{defclass BinaryExpansionType}
(defclass |BinaryExpansionType| (|QuotientFieldCategoryType|)
  ((parents :initform '(|QuotientFieldCategory|))
   (name :initform "BinaryExpansion")
   (marker :initform 'domain)
   (abbreviation :initform 'BINARY)
   (comment :initform (list
     "This domain allows rational numbers to be presented as repeating"
     "binary expansions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BinaryExpansion|
  (progn
    (push '|BinaryExpansion| *Domains*)
    (make-instance '|BinaryExpansionType|)))

\end{chunk}

\subsection{BinaryFile}
\index[dom]{BinaryFile!Domain}
\index[dom]{Domain!BinaryFile}
\index[dom]{BINFILE}
\begin{chunk}{defclass BinaryFileType}
(defclass |BinaryFileType| (|FileCategoryType|)
  ((parents :initform '(|FileCategory|))
   (name :initform "BinaryFile")
   (marker :initform 'domain)
   (abbreviation :initform 'BINFILE)
   (comment :initform (list
     "This domain provides an implementation of binary files. Data is"
     "accessed one byte at a time as a small integer."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BinaryFile|
  (progn
    (push '|BinaryFile| *Domains*)
    (make-instance '|BinaryFileType|)))

\end{chunk}

\subsection{BinarySearchTree}
\index[dom]{BinarySearchTree!Domain}
\index[dom]{Domain!BinarySearchTree}
\index[dom]{BSTREE}
\begin{chunk}{defclass BinarySearchTreeType}
(defclass |BinarySearchTreeType| (|BinaryTreeCategoryType|)
  ((parents :initform '(|BinaryTreeCategory|))
   (name :initform "BinarySearchTree")
   (marker :initform 'domain)
   (abbreviation :initform 'BSTREE)
   (comment :initform (list
     "BinarySearchTree(S) is the domain of"
     "a binary trees where elements are ordered across the tree."
     "A binary search tree is either empty or has"
     "a value which is an S, and a"
     "right and left which are both BinaryTree(S)"
     "Elements are ordered across the tree."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BinarySearchTree|
  (progn
    (push '|BinarySearchTree| *Domains*)
    (make-instance '|BinarySearchTreeType|)))

\end{chunk}

\subsection{BinaryTournament}
\index[dom]{BinaryTournament!Domain}
\index[dom]{Domain!BinaryTournament}
\index[dom]{BTOURN}
\begin{chunk}{defclass BinaryTournamentType}
(defclass |BinaryTournamentType| (|BinaryTreeCategoryType|)
  ((parents :initform '(|BinaryTreeCategory|))
   (name :initform "BinaryTournament")
   (marker :initform 'domain)
   (abbreviation :initform 'BTOURN)
   (comment :initform (list
     "BinaryTournament creates a binary tournament with the"
     "elements of ls as values at the nodes."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BinaryTournament|
  (progn
    (push '|BinaryTournament| *Domains*)
    (make-instance '|BinaryTournamentType|)))

\end{chunk}

\subsection{BinaryTree}
\index[dom]{BinaryTree!Domain}
\index[dom]{Domain!BinaryTree}
\index[dom]{BTREE}
\begin{chunk}{defclass BinaryTreeType}
(defclass |BinaryTreeType| (|BinaryTreeCategoryType|)
  ((parents :initform '(|BinaryTreeCategory|))
   (name :initform "BinaryTree")
   (marker :initform 'domain)
   (abbreviation :initform 'BTREE)
   (comment :initform (list
     "BinaryTree(S) is the domain of all"
     "binary trees. A binary tree over S is either empty or has"
     "a value which is an S and a right"
     "and left which are both binary trees."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BinaryTree|
  (progn
    (push '|BinaryTree| *Domains*)
    (make-instance '|BinaryTreeType|)))

\end{chunk}

\subsection{Bits}
\index[dom]{Bits!Domain}
\index[dom]{Domain!Bits}
\index[dom]{BITS}
\begin{chunk}{defclass BitsType}
(defclass |BitsType| (|BitAggregateType|)
  ((parents :initform '(|BitAggregate|))
   (name :initform "Bits")
   (marker :initform 'domain)
   (abbreviation :initform 'BITS)
   (comment :initform (list
     "Bits provides logical functions for Indexed Bits."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Bits|
  (progn
    (push '|Bits| *Domains*)
    (make-instance '|BitsType|)))

\end{chunk}

\subsection{BlowUpWithHamburgerNoether}
\index[dom]{BlowUpWithHamburgerNoether!Domain}
\index[dom]{Domain!BlowUpWithHamburgerNoether}
\index[dom]{BLHN}
\begin{chunk}{defclass BlowUpWithHamburgerNoetherType}
(defclass |BlowUpWithHamburgerNoetherType| (|BlowUpMethodCategoryType|)
  ((parents :initform '(|BlowUpMethodCategory|))
   (name :initform "BlowUpWithHamburgerNoether")
   (marker :initform 'domain)
   (abbreviation :initform 'BLHN)
   (comment :initform (list
     "This domain is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BlowUpWithHamburgerNoether|
  (progn
    (push '|BlowUpWithHamburgerNoether| *Domains*)
    (make-instance '|BlowUpWithHamburgerNoetherType|)))

\end{chunk}

\subsection{BlowUpWithQuadTrans}
\index[dom]{BlowUpWithQuadTrans!Domain}
\index[dom]{Domain!BlowUpWithQuadTrans}
\index[dom]{BLQT}
\begin{chunk}{defclass BlowUpWithQuadTransType}
(defclass |BlowUpWithQuadTransType| (|BlowUpMethodCategoryType|)
  ((parents :initform '(|BlowUpMethodCategory|))
   (name :initform "BlowUpWithQuadTrans")
   (marker :initform 'domain)
   (abbreviation :initform 'BLQT)
   (comment :initform (list
     "This domain is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BlowUpWithQuadTrans|
  (progn
    (push '|BlowUpWithQuadTrans| *Domains*)
    (make-instance '|BlowUpWithQuadTransType|)))

\end{chunk}

\subsection{Boolean}
\index[dom]{Boolean!Domain}
\index[dom]{Domain!Boolean}
\index[dom]{BOOLEAN}
\begin{chunk}{defclass BooleanType}
(defclass |BooleanType| (|ConvertibleToType| |FiniteType| |LogicType| |OrderedSetType|)
  ((parents :initform '(|ConvertibleTo| |Finite| |Logic| |OrderedSet|))
   (name :initform "Boolean")
   (marker :initform 'domain)
   (abbreviation :initform 'BOOLEAN)
   (comment :initform (list
     "Boolean is the elementary logic with 2 values:"
     "true and false"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Boolean|
  (progn
    (push '|Boolean| *Domains*)
    (make-instance '|BooleanType|)))

\end{chunk}

\section{C}

\subsection{CardinalNumber}
\index[dom]{CardinalNumber!Domain}
\index[dom]{Domain!CardinalNumber}
\index[dom]{CARD}
\begin{chunk}{defclass CardinalNumberType}
(defclass |CardinalNumberType| (|AbelianMonoidType| |MonoidType| |OrderedSetType| |RetractableToType|)
  ((parents :initform '(|AbelianMonoid| |Monoid| |OrderedSet| |RetractableTo|))
   (name :initform "CardinalNumber")
   (marker :initform 'domain)
   (abbreviation :initform 'CARD)
   (comment :initform (list
     "Members of the domain CardinalNumber are values indicating the"
     "cardinality of sets, both finite and infinite.  Arithmetic operations"
     "are defined on cardinal numbers as follows."
     " "
     "If x = #X and y = #Y then"
     "   x+y  = #(X+Y) disjoint union"
     "   x-y  = #(X-Y) relative complement"
     "   x*y  = #(X*Y) cartesian product"
     "   x**y = #(X**Y) X**Y = g \| g:Y->X"
     " "
     "The non-negative integers have a natural construction as cardinals"
     "  0 = #{}, 1 = {0},"
     " 2 = {0, 1}}, ..., n = {i\| 0 <= i < n}."
     " "
     "That 0 acts as a zero for the multiplication of cardinals is"
     "equivalent to the axiom of choice."
     " "
     "The generalized continuum hypothesis asserts"
     "2**Aleph i = Aleph(i+1)"
     "and is independent of the axioms of set theory [Goedel 1940]"
     " "
     "Three commonly encountered cardinal numbers are"
     "  a = #Z countable infinity"
     "  c = #R the continuum"
     "  f = # g \| g:[0,1]->R"
     " "
     "In this domain, these values are obtained using"
     "  a := Aleph 0, c := 2**a, f := 2**c."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CardinalNumber|
  (progn
    (push '|CardinalNumber| *Domains*)
    (make-instance '|CardinalNumberType|)))

\end{chunk}

\subsection{CartesianTensor}
\index[dom]{CartesianTensor!Domain}
\index[dom]{Domain!CartesianTensor}
\index[dom]{CARTEN}
\begin{chunk}{defclass CartesianTensorType}
(defclass |CartesianTensorType| (|GradedAlgebraType|)
  ((parents :initform '(|GradedAlgebra|))
   (name :initform "CartesianTensor")
   (marker :initform 'domain)
   (abbreviation :initform 'CARTEN)
   (comment :initform (list
     "CartesianTensor(minix,dim,R) provides Cartesian tensors with"
     "components belonging to a commutative ring R.  These tensors"
     "can have any number of indices.  Each index takes values from"
     "minix to minix + dim - 1."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CartesianTensor|
  (progn
    (push '|CartesianTensor| *Domains*)
    (make-instance '|CartesianTensorType|)))

\end{chunk}

\subsection{Cell}
\index[dom]{Cell!Domain}
\index[dom]{Domain!Cell}
\index[dom]{CELL}
\begin{chunk}{defclass CellType}
(defclass |CellType| (|CoercibleToType|)
  ((parents :initform '(|CoercibleTo|))
   (name :initform "Cell")
   (marker :initform 'domain)
   (abbreviation :initform 'CELL)
   (comment :initform nil)
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Cell|
  (progn
    (push '|Cell| *Domains*)
    (make-instance '|CellType|)))

\end{chunk}

\subsection{Character}
\index[dom]{Character!Domain}
\index[dom]{Domain!Character}
\index[dom]{CHAR}
\begin{chunk}{defclass CharacterType}
(defclass |CharacterType| (|OrderedFiniteType|)
  ((parents :initform '(|OrderedFinite|))
   (name :initform "Character")
   (marker :initform 'domain)
   (abbreviation :initform 'CHAR)))

(defvar |Character|
  (progn
    (push '|Character| *Domains*)
    (make-instance '|CharacterType|)))

\end{chunk}

\subsection{CharacterClass}
\index[dom]{CharacterClass!Domain}
\index[dom]{Domain!CharacterClass}
\index[dom]{CCLASS}
\begin{chunk}{defclass CharacterClassType}
(defclass |CharacterClassType| (|FiniteSetAggregateType|)
  ((parents :initform '(|FiniteSetAggregate|))
   (name :initform "CharacterClass")
   (marker :initform 'domain)
   (abbreviation :initform 'CCLASS)
   (comment :initform (list
     "This domain allows classes of characters to be defined and manipulated"
     "efficiently."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CharacterClass|
  (progn
    (push '|CharacterClass| *Domains*)
    (make-instance '|CharacterClassType|)))

\end{chunk}

\subsection{CliffordAlgebra}
\index[dom]{CliffordAlgebra!Domain}
\index[dom]{Domain!CliffordAlgebra}
\index[dom]{CLIF}
\begin{chunk}{defclass CliffordAlgebraType}
(defclass |CliffordAlgebraType| (|VectorSpaceType| |AlgebraType|)
  ((parents :initform '(|VectorSpace| |Algebra|))
   (name :initform "CliffordAlgebra")
   (marker :initform 'domain)
   (abbreviation :initform 'CLIF)
   (comment :initform (list
     "CliffordAlgebra(n, K, Q) defines a vector space of dimension 2**n"
     "over K, given a quadratic form Q on K**n."
     " "
     "If e[i], 1<=i<=n is a basis for K**n then"
     "   1, e[i] (1<=i<=n), e[i1]*e[i2]"
     "   (1<=i1<i2<=n},...,e[1]*e[2]*..*e[n]"
     "is a basis for the Clifford Algebra."
     " "
     "The algebra is defined by the relations"
     "   e[i]*e[j] = -e[j]*e[i]}  (i \~~= j),"
     "   e[i]*e[i] = Q(e[i])"
     " "
     "Examples of Clifford Algebras are: gaussians, quaternions, exterior"
     "algebras and spin algebras."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CliffordAlgebra|
  (progn
    (push '|CliffordAlgebra| *Domains*)
    (make-instance '|CliffordAlgebraType|)))

\end{chunk}

\subsection{Color}
\index[dom]{Color!Domain}
\index[dom]{Domain!Color}
\index[dom]{COLOR}
\begin{chunk}{defclass ColorType}
(defclass |ColorType| (|AbelianSemiGroupType|)
  ((parents :initform '(|AbelianSemiGroup|))
   (name :initform "Color")
   (marker :initform 'domain)
   (abbreviation :initform 'COLOR)
   (comment :initform (list
     "Color() specifies a domain of 27 colors provided in the"
     "Axiom system (the colors mix additively)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Color|
  (progn
    (push '|Color| *Domains*)
    (make-instance '|ColorType|)))

\end{chunk}

\subsection{Commutator}
\index[dom]{Commutator!Domain}
\index[dom]{Domain!Commutator}
\index[dom]{COMM}
\begin{chunk}{defclass CommutatorType}
(defclass |CommutatorType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "Commutator")
   (marker :initform 'domain)
   (abbreviation :initform 'COMM)
   (comment :initform (list
     "A type for basic commutators"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Commutator|
  (progn
    (push '|Commutator| *Domains*)
    (make-instance '|CommutatorType|)))

\end{chunk}

\subsection{Complex}
\index[dom]{Complex!Domain}
\index[dom]{Domain!Complex}
\index[dom]{COMPLEX}
\begin{chunk}{defclass ComplexType}
(defclass |ComplexType| (|ComplexCategoryType| |OpenMathType|)
  ((parents :initform '(|ComplexCategory| |OpenMath|))
   (name :initform "Complex")
   (marker :initform 'domain)
   (abbreviation :initform 'COMPLEX)
   (comment :initform (list
     "Complex(R) creates the domain of elements of the form"
     "a + b * i where a and b come from the ring R,"
     "and i is a new element such that i**2 = -1."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Complex|
  (progn
    (push '|Complex| *Domains*)
    (make-instance '|ComplexType|)))

\end{chunk}

\subsection{ComplexDoubleFloatMatrix}
\index[dom]{ComplexDoubleFloatMatrix!Domain}
\index[dom]{Domain!ComplexDoubleFloatMatrix}
\index[dom]{CDFMAT}
\begin{chunk}{defclass ComplexDoubleFloatMatrixType}
(defclass |ComplexDoubleFloatMatrixType| (|MatrixCategoryType|)
  ((parents :initform '(|MatrixCategory|))
   (name :initform "ComplexDoubleFloatMatrix")
   (marker :initform 'domain)
   (abbreviation :initform 'CDFMAT)
   (comment :initform (list
     "This is a low-level domain which implements matrices"
     "(two dimensional arrays) of complex double precision floating point"
     "numbers.  Indexing is 0 based, there is no bound checking (unless"
     "provided by lower level)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ComplexDoubleFloatMatrix|
  (progn
    (push '|ComplexDoubleFloatMatrix| *Domains*)
    (make-instance '|ComplexDoubleFloatMatrixType|)))

\end{chunk}

\subsection{ComplexDoubleFloatVector}
\index[dom]{ComplexDoubleFloatVector!Domain}
\index[dom]{Domain!ComplexDoubleFloatVector}
\index[dom]{CDFVEC}
\begin{chunk}{defclass ComplexDoubleFloatVectorType}
(defclass |ComplexDoubleFloatVectorType| (|VectorCategoryType|)
  ((parents :initform '(|VectorCategory|))
   (name :initform "ComplexDoubleFloatVector")
   (marker :initform 'domain)
   (abbreviation :initform 'CDFVEC)
   (comment :initform (list
     "This is a low-level domain which implements vectors"
     "(one dimensional arrays) of complex double precision floating point"
     "numbers.  Indexing is 0 based, there is no bound checking (unless"
     "provided by lower level)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ComplexDoubleFloatVector|
  (progn
    (push '|ComplexDoubleFloatVector| *Domains*)
    (make-instance '|ComplexDoubleFloatVectorType|)))

\end{chunk}

\subsection{ContinuedFraction}
\index[dom]{ContinuedFraction!Domain}
\index[dom]{Domain!ContinuedFraction}
\index[dom]{CONTFRAC}
\begin{chunk}{defclass ContinuedFractionType}
(defclass |ContinuedFractionType| (|FieldType|)
  ((parents :initform '(|Field|))
   (name :initform "ContinuedFraction")
   (marker :initform 'domain)
   (abbreviation :initform 'CONTFRAC)
   (comment :initform (list
     "ContinuedFraction implements general"
     "continued fractions.  This version is not restricted to simple,"
     "finite fractions and uses the Stream as a"
     "representation.  The arithmetic functions assume that the"
     "approximants alternate below/above the convergence point."
     "This is enforced by ensuring the partial numerators and partial"
     "denominators are greater than 0 in the Euclidean domain view of R"
     "(sizeLess?(0, x))."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ContinuedFraction|
  (progn
    (push '|ContinuedFraction| *Domains*)
    (make-instance '|ContinuedFractionType|)))

\end{chunk}

\section{D}

\subsection{Database}
\index[dom]{Database!Domain}
\index[dom]{Domain!Database}
\index[dom]{DBASE}
\begin{chunk}{defclass DatabaseType}
(defclass |DatabaseType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "Database")
   (marker :initform 'domain)
   (abbreviation :initform 'DBASE)
   (comment :initform (list
     "This domain implements a simple view of a database whose fields are"
     "indexed by symbols"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Database|
  (progn
    (push '|Database| *Domains*)
    (make-instance '|DatabaseType|)))

\end{chunk}

\subsection{DataList}
\index[dom]{DataList!Domain}
\index[dom]{Domain!DataList}
\index[dom]{DLIST}
\begin{chunk}{defclass DataListType}
(defclass |DataListType| (|ListAggregateType|)
  ((parents :initform '(|ListAggregate|))
   (name :initform "DataList")
   (marker :initform 'domain)
   (abbreviation :initform 'DLIST)
   (comment :initform (list
     "This domain provides some nice functions on lists"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DataList|
  (progn
    (push '|DataList| *Domains*)
    (make-instance '|DataListType|)))

\end{chunk}

\subsection{DecimalExpansion}
\index[dom]{DecimalExpansion!Domain}
\index[dom]{Domain!DecimalExpansion}
\index[dom]{DECIMAL}
\begin{chunk}{defclass DecimalExpansionType}
(defclass |DecimalExpansionType| (|QuotientFieldCategoryType|)
  ((parents :initform '(|QuotientFieldCategory|))
   (name :initform "DecimalExpansion")
   (marker :initform 'domain)
   (abbreviation :initform 'DECIMAL)
   (comment :initform (list
     "This domain allows rational numbers to be presented as repeating"
     "decimal expansions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DecimalExpansion|
  (progn
    (push '|DecimalExpansion| *Domains*)
    (make-instance '|DecimalExpansionType|)))

\end{chunk}

\subsection{DenavitHartenbergMatrix}
\index[dom]{DenavitHartenbergMatrix!Domain}
\index[dom]{Domain!DenavitHartenbergMatrix}
\index[dom]{DHMATRIX}
\begin{chunk}{defclass DenavitHartenbergMatrixType}
(defclass |DenavitHartenbergMatrixType| (|MatrixCategoryType|)
  ((parents :initform '(|MatrixCategory|))
   (name :initform "DenavitHartenbergMatrix")
   (marker :initform 'domain)
   (abbreviation :initform 'DHMATRIX)
   (comment :initform (list
     "4x4 Matrices for coordinate transformations"
     "This package contains functions to create 4x4 matrices"
     "useful for rotating and transforming coordinate systems."
     "These matrices are useful for graphics and robotics."
     "(Reference: Robot Manipulators Richard Paul MIT Press 1981)"
     " "
     "A Denavit-Hartenberg Matrix is a 4x4 Matrix of the form:"
     "     nx ox ax px"
     "     ny oy ay py"
     "     nz oz az pz"
     "     0  0  0  1"
     "(n, o, and a are the direction cosines)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DenavitHartenbergMatrix|
  (progn
    (push '|DenavitHartenbergMatrix| *Domains*)
    (make-instance '|DenavitHartenbergMatrixType|)))

\end{chunk}

\subsection{Dequeue}
\index[dom]{Dequeue!Domain}
\index[dom]{Domain!Dequeue}
\index[dom]{DEQUEUE}
\begin{chunk}{defclass DequeueType}
(defclass |DequeueType| (|DequeueAggregateType|)
  ((parents :initform '(|DequeueAggregate|))
   (name :initform "Dequeue")
   (marker :initform 'domain)
   (abbreviation :initform 'DEQUEUE)
   (comment :initform (list
     "Linked list implementation of a Dequeue"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Dequeue|
  (progn
    (push '|Dequeue| *Domains*)
    (make-instance '|DequeueType|)))

\end{chunk}

\subsection{DeRhamComplex}
\index[dom]{DeRhamComplex!Domain}
\index[dom]{Domain!DeRhamComplex}
\index[dom]{DERHAM}
\begin{chunk}{defclass DeRhamComplexType}
(defclass |DeRhamComplexType| (|RetractableToType| |LeftAlgebraType|)
  ((parents :initform '(|RetractableTo| |LeftAlgebra|))
   (name :initform "DeRhamComplex")
   (marker :initform 'domain)
   (abbreviation :initform 'DERHAM)
   (comment :initform (list
     "The deRham complex of Euclidean space, that is, the"
     "class of differential forms of arbitary degree over a coefficient ring."
     "See Flanders, Harley, Differential Forms, With Applications to the Physical"
     "Sciences, New York, Academic Press, 1963."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DeRhamComplex|
  (progn
    (push '|DeRhamComplex| *Domains*)
    (make-instance '|DeRhamComplexType|)))

\end{chunk}

\subsection{DesingTree}
\index[dom]{DesingTree!Domain}
\index[dom]{Domain!DesingTree}
\index[dom]{DSTREE}
\begin{chunk}{defclass DesingTreeType}
(defclass |DesingTreeType| (|DesingTreeCategoryType|)
  ((parents :initform '(|DesingTreeCategory|))
   (name :initform "DesingTree")
   (marker :initform 'domain)
   (abbreviation :initform 'DSTREE)
   (comment :initform (list
     "This category is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DesingTree|
  (progn
    (push '|DesingTree| *Domains*)
    (make-instance '|DesingTreeType|)))

\end{chunk}

\subsection{DifferentialSparseMultivariatePolynomial}
\index[dom]{DifferentialSparseMultivariatePolynomial!Domain}
\index[dom]{Domain!DifferentialSparseMultivariatePolynomial}
\index[dom]{DSMP}
\begin{chunk}{defclass DifferentialSparseMultivariatePolynomialType}
(defclass |DifferentialSparseMultivariatePolynomialType| (|DifferentialPolynomialCategoryType|)
  ((parents :initform '(|DifferentialPolynomialCategory|))
   (name :initform "DifferentialSparseMultivariatePolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'DSMP)
   (comment :initform (list
     "DifferentialSparseMultivariatePolynomial implements"
     "an ordinary differential polynomial ring by combining a"
     "domain belonging to the category DifferentialVariableCategory"
     "with the domain SparseMultivariatePolynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DifferentialSparseMultivariatePolynomial|
  (progn
    (push '|DifferentialSparseMultivariatePolynomial| *Domains*)
    (make-instance '|DifferentialSparseMultivariatePolynomialType|)))

\end{chunk}

\subsection{DirectProduct}
\index[dom]{DirectProduct!Domain}
\index[dom]{Domain!DirectProduct}
\index[dom]{DIRPROD}
\begin{chunk}{defclass DirectProductType}
(defclass |DirectProductType| (|DirectProductCategoryType|)
  ((parents :initform '(|DirectProductCategory|))
   (name :initform "DirectProduct")
   (marker :initform 'domain)
   (abbreviation :initform 'DIRPROD)
   (comment :initform (list
     "This type represents the finite direct or cartesian product of an"
     "underlying component type. This contrasts with simple vectors in that"
     "the members can be viewed as having constant length. Thus many"
     "categorical properties can by lifted from the underlying component type."
     "Component extraction operations are provided but no updating operations."
     "Thus new direct product elements can either be created by converting"
     "vector elements using the directProduct function"
     "or by taking appropriate linear combinations of basis vectors provided"
     "by the unitVector operation."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DirectProduct|
  (progn
    (push '|DirectProduct| *Domains*)
    (make-instance '|DirectProductType|)))

\end{chunk}

\subsection{DirectProductMatrixModule}
\index[dom]{DirectProductMatrixModule!Domain}
\index[dom]{Domain!DirectProductMatrixModule}
\index[dom]{DPMM}
\begin{chunk}{defclass DirectProductMatrixModuleType}
(defclass |DirectProductMatrixModuleType| (|DirectProductCategoryType|)
  ((parents :initform '(|DirectProductCategory|))
   (name :initform "DirectProductMatrixModule")
   (marker :initform 'domain)
   (abbreviation :initform 'DPMM)
   (comment :initform (list
     "This constructor provides a direct product type with a"
     "left matrix-module view."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DirectProductMatrixModule|
  (progn
    (push '|DirectProductMatrixModule| *Domains*)
    (make-instance '|DirectProductMatrixModuleType|)))

\end{chunk}

\subsection{DirectProductModule}
\index[dom]{DirectProductModule!Domain}
\index[dom]{Domain!DirectProductModule}
\index[dom]{DPMO}
\begin{chunk}{defclass DirectProductModuleType}
(defclass |DirectProductModuleType| (|DirectProductCategoryType|)
  ((parents :initform '(|DirectProductCategory|))
   (name :initform "DirectProductModule")
   (marker :initform 'domain)
   (abbreviation :initform 'DPMO)
   (comment :initform (list
     "This constructor provides a direct product of R-modules"
     "with an R-module view."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DirectProductModule|
  (progn
    (push '|DirectProductModule| *Domains*)
    (make-instance '|DirectProductModuleType|)))

\end{chunk}

\subsection{DirichletRing}
\index[dom]{DirichletRing!Domain}
\index[dom]{Domain!DirichletRing}
\index[dom]{DIRRING}
\begin{chunk}{defclass DirichletRingType}
(defclass |DirichletRingType| (|IntegralDomainType| |EltableType|)
  ((parents :initform '(|IntegralDomain| |Eltable|))
   (name :initform "DirichletRing")
   (marker :initform 'domain)
   (abbreviation :initform 'DIRRING)
   (comment :initform (list
     "DirichletRing is the ring of arithmetical functions"
     "with Dirichlet convolution as multiplication"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DirichletRing|
  (progn
    (push '|DirichletRing| *Domains*)
    (make-instance '|DirichletRingType|)))

\end{chunk}

\subsection{DistributedMultivariatePolynomial}
\index[dom]{DistributedMultivariatePolynomial!Domain}
\index[dom]{Domain!DistributedMultivariatePolynomial}
\index[dom]{DMP}
\begin{chunk}{defclass DistributedMultivariatePolynomialType}
(defclass |DistributedMultivariatePolynomialType| (|PolynomialCategoryType|)
  ((parents :initform '(|PolynomialCategory|))
   (name :initform "DistributedMultivariatePolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'DMP)
   (comment :initform (list
     "This type supports distributed multivariate polynomials"
     "whose variables are from a user specified list of symbols."
     "The coefficient ring may be non commutative,"
     "but the variables are assumed to commute."
     "The term ordering is lexicographic specified by the variable"
     "list parameter with the most significant variable first in the list."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DistributedMultivariatePolynomial|
  (progn
    (push '|DistributedMultivariatePolynomial| *Domains*)
    (make-instance '|DistributedMultivariatePolynomialType|)))

\end{chunk}

\subsection{Divisor}
\index[dom]{Divisor!Domain}
\index[dom]{Domain!Divisor}
\index[dom]{DIV}
\begin{chunk}{defclass DivisorType}
(defclass |DivisorType| (|DivisorCategoryType|)
  ((parents :initform '(|DivisorCategory|))
   (name :initform "Divisor")
   (marker :initform 'domain)
   (abbreviation :initform 'DIV)
   (comment :initform (list
     "The following is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Divisor|
  (progn
    (push '|Divisor| *Domains*)
    (make-instance '|DivisorType|)))

\end{chunk}

\subsection{DoubleFloat}
\index[dom]{DoubleFloat!Domain}
\index[dom]{Domain!DoubleFloat}
\index[dom]{DFLOAT}
\begin{chunk}{defclass DoubleFloatType}
(defclass |DoubleFloatType| (|TranscendentalFunctionCategoryType|
                             |SpecialFunctionCategoryType|
                             |OpenMathType|
                             |FloatingPointSystemType|
                             |DifferentialRingType|)
  ((parents :initform '(|TranscendentalFunctionCategory|
                        |SpecialFunctionCategory|
                        |OpenMath|
                        |FloatingPointSystem|
                        |DifferentialRing|))
   (name :initform "DoubleFloat")
   (marker :initform 'domain)
   (abbreviation :initform 'DFLOAT)
   (comment :initform (list
     "DoubleFloat is intended to make accessible"
     "hardware floating point arithmetic in Axiom, either native double"
     "precision, or IEEE. On most machines, there will be hardware support for"
     "the arithmetic operations: +, *, / and possibly also the"
     "sqrt operation."
     "The operations exp, log, sin, cos, atan are normally coded in"
     "software based on minimax polynomial/rational approximations."
     " "
     "Some general comments about the accuracy of the operations:"
     "the operations +, *, / and sqrt are expected to be fully accurate."
     "The operations exp, log, sin, cos and atan are not expected to be"
     "fully accurate.  In particular, sin and cos"
     "will lose all precision for large arguments."
     " "
     "The Float domain provides an alternative to the DoubleFloat domain."
     "It provides an arbitrary precision model of floating point arithmetic."
     "This means that accuracy problems like those above are eliminated"
     "by increasing the working precision where necessary. Float"
     "provides some special functions such as erf, the error function"
     "in addition to the elementary functions.  The disadvantage of Float is that"
     "it is much more expensive than small floats when the latter can be used."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DoubleFloat|
  (progn
    (push '|DoubleFloat| *Domains*)
    (make-instance '|DoubleFloatType|)))

\end{chunk}

\subsection{DoubleFloatMatrix}
\index[dom]{DoubleFloatMatrix!Domain}
\index[dom]{Domain!DoubleFloatMatrix}
\index[dom]{DFMAT}
\begin{chunk}{defclass DoubleFloatMatrixType}
(defclass |DoubleFloatMatrixType| (|MatrixCategoryType|)
  ((parents :initform '(|MatrixCategory|))
   (name :initform "DoubleFloatMatrix")
   (marker :initform 'domain)
   (abbreviation :initform 'DFMAT)
   (comment :initform (list
     "This is a low-level domain which implements matrices"
     "(two dimensional arrays) of double precision floating point"
     "numbers.  Indexing is 0 based, there is no bound checking (unless"
     "provided by lower level)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DoubleFloatMatrix|
  (progn
    (push '|DoubleFloatMatrix| *Domains*)
    (make-instance '|DoubleFloatMatrixType|)))

\end{chunk}

\subsection{DoubleFloatVector}
\index[dom]{DoubleFloatVector!Domain}
\index[dom]{Domain!DoubleFloatVector}
\index[dom]{DFVEC}
\begin{chunk}{defclass DoubleFloatVectorType}
(defclass |DoubleFloatVectorType| (|VectorCategoryType|)
  ((parents :initform '(|VectorCategory|))
   (name :initform "DoubleFloatVector")
   (marker :initform 'domain)
   (abbreviation :initform 'DFVEC)
   (comment :initform (list
     "This is a low-level domain which implements vectors"
     "(one dimensional arrays) of double precision floating point"
     "numbers.  Indexing is 0 based, there is no bound checking (unless"
     "provided by lower level)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DoubleFloatVector|
  (progn
    (push '|DoubleFloatVector| *Domains*)
    (make-instance '|DoubleFloatVectorType|)))

\end{chunk}

\subsection{DrawOption}
\index[dom]{DrawOption!Domain}
\index[dom]{Domain!DrawOption}
\index[dom]{DROPT}
\begin{chunk}{defclass DrawOptionType}
(defclass |DrawOptionType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "DrawOption")
   (marker :initform 'domain)
   (abbreviation :initform 'DROPT)
   (comment :initform (list
     "DrawOption allows the user to specify defaults for the"
     "creation and rendering of plots."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DrawOption|
  (progn
    (push '|DrawOption| *Domains*)
    (make-instance '|DrawOptionType|)))

\end{chunk}

\subsection{d01ajfAnnaType}
\index[dom]{d01ajfAnnaType!Domain}
\index[dom]{Domain!d01ajfAnnaType}
\index[dom]{D01AJFA}
\begin{chunk}{defclass d01ajfAnnaTypeType}
(defclass |d01ajfAnnaTypeType| (|NumericalIntegrationCategoryType|)
  ((parents :initform '(|NumericalIntegrationCategory|))
   (name :initform "d01ajfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'D01AJFA)
   (comment :initform (list
     "d01ajfAnnaType is a domain of"
     "NumericalIntegrationCategory"
     "for the NAG routine D01AJF, a general numerical integration routine which"
     "can handle some singularities in the input function.  The function"
     "measure measures the usefulness of the routine D01AJF"
     "for the given problem.  The function numericalIntegration"
     "performs the integration by using NagIntegrationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d01ajfAnnaType|
  (progn
    (push '|d01ajfAnnaType| *Domains*)
    (make-instance '|d01ajfAnnaTypeType|)))

\end{chunk}

\subsection{d01akfAnnaType}
\index[dom]{d01akfAnnaType!Domain}
\index[dom]{Domain!d01akfAnnaType}
\index[dom]{D01AKFA}
\begin{chunk}{defclass d01akfAnnaTypeType}
(defclass |d01akfAnnaTypeType| (|NumericalIntegrationCategoryType|)
  ((parents :initform '(|NumericalIntegrationCategory|))
   (name :initform "d01akfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'D01AKFA)
   (comment :initform (list
     "d01akfAnnaType is a domain of"
     "NumericalIntegrationCategory"
     "for the NAG routine D01AKF, a numerical integration routine which is"
     "is suitable for oscillating, non-singular functions.  The function"
     "measure measures the usefulness of the routine D01AKF"
     "for the given problem.  The function numericalIntegration"
     "performs the integration by using NagIntegrationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d01akfAnnaType|
  (progn
    (push '|d01akfAnnaType| *Domains*)
    (make-instance '|d01akfAnnaTypeType|)))

\end{chunk}

\subsection{d01alfAnnaType}
\index[dom]{d01alfAnnaType!Domain}
\index[dom]{Domain!d01alfAnnaType}
\index[dom]{D01ALFA}
\begin{chunk}{defclass d01alfAnnaTypeType}
(defclass |d01alfAnnaTypeType| (|NumericalIntegrationCategoryType|)
  ((parents :initform '(|NumericalIntegrationCategory|))
   (name :initform "d01alfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'D01ALFA)
   (comment :initform (list
     "d01alfAnnaType is a domain of"
     "NumericalIntegrationCategory"
     "for the NAG routine D01ALF, a general numerical integration routine which"
     "can handle a list of singularities.  The"
     "function measure measures the usefulness of the routine D01ALF"
     "for the given problem.  The function numericalIntegration"
     "performs the integration by using NagIntegrationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d01alfAnnaType|
  (progn
    (push '|d01alfAnnaType| *Domains*)
    (make-instance '|d01alfAnnaTypeType|)))

\end{chunk}

\subsection{d01amfAnnaType}
\index[dom]{d01amfAnnaType!Domain}
\index[dom]{Domain!d01amfAnnaType}
\index[dom]{D01AMFA}
\begin{chunk}{defclass d01amfAnnaTypeType}
(defclass |d01amfAnnaTypeType| (|NumericalIntegrationCategoryType|)
  ((parents :initform '(|NumericalIntegrationCategory|))
   (name :initform "d01amfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'D01AMFA)
   (comment :initform (list
     "d01amfAnnaType is a domain of"
     "NumericalIntegrationCategory"
     "for the NAG routine D01AMF, a general numerical integration routine which"
     "can handle infinite or semi-infinite range of the input function.  The"
     "function measure measures the usefulness of the routine D01AMF"
     "for the given problem.  The function numericalIntegration"
     "performs the integration by using NagIntegrationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d01amfAnnaType|
  (progn
    (push '|d01amfAnnaType| *Domains*)
    (make-instance '|d01amfAnnaTypeType|)))

\end{chunk}

\subsection{d01anfAnnaType}
\index[dom]{d01anfAnnaType!Domain}
\index[dom]{Domain!d01anfAnnaType}
\index[dom]{D01ANFA}
\begin{chunk}{defclass d01anfAnnaTypeType}
(defclass |d01anfAnnaTypeType| (|NumericalIntegrationCategoryType|)
  ((parents :initform '(|NumericalIntegrationCategory|))
   (name :initform "d01anfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'D01ANFA)
   (comment :initform (list
     "d01anfAnnaType is a domain of"
     "NumericalIntegrationCategory"
     "for the NAG routine D01ANF, a numerical integration routine which can"
     "handle weight functions of the form cos(omega x) or sin(omega x).  The"
     "function measure measures the usefulness of the routine D01ANF"
     "for the given problem.  The function numericalIntegration"
     "performs the integration by using NagIntegrationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d01anfAnnaType|
  (progn
    (push '|d01anfAnnaType| *Domains*)
    (make-instance '|d01anfAnnaTypeType|)))

\end{chunk}

\subsection{d01apfAnnaType}
\index[dom]{d01apfAnnaType!Domain}
\index[dom]{Domain!d01apfAnnaType}
\index[dom]{D01APFA}
\begin{chunk}{defclass d01apfAnnaTypeType}
(defclass |d01apfAnnaTypeType| (|NumericalIntegrationCategoryType|)
  ((parents :initform '(|NumericalIntegrationCategory|))
   (name :initform "d01apfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'D01APFA)
   (comment :initform (list
     "d01apfAnnaType is a domain of"
     "NumericalIntegrationCategory"
     "for the NAG routine D01APF, a general numerical integration routine which"
     "can handle end point singularities of the algebraico-logarithmic form"
     "   w(x) = (x-a)^c * (b-x)^d.  The"
     "function measure measures the usefulness of the routine D01APF"
     "for the given problem.  The function numericalIntegration"
     "performs the integration by using NagIntegrationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d01apfAnnaType|
  (progn
    (push '|d01apfAnnaType| *Domains*)
    (make-instance '|d01apfAnnaTypeType|)))

\end{chunk}

\subsection{d01aqfAnnaType}
\index[dom]{d01aqfAnnaType!Domain}
\index[dom]{Domain!d01aqfAnnaType}
\index[dom]{D01AQFA}
\begin{chunk}{defclass d01aqfAnnaTypeType}
(defclass |d01aqfAnnaTypeType| (|NumericalIntegrationCategoryType|)
  ((parents :initform '(|NumericalIntegrationCategory|))
   (name :initform "d01aqfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'D01AQFA)
   (comment :initform (list
     "d01aqfAnnaType is a domain of"
     "NumericalIntegrationCategory"
     "for the NAG routine D01AQF, a general numerical integration routine which"
     "can solve an integral of the form"
     "/home/bjd/Axiom/anna/hypertex/bitmaps/d01aqf.xbm"
     "The function measure measures the usefulness of the routine"
     "D01AQF for the given problem.  The function numericalIntegration"
     "performs the integration by using NagIntegrationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d01aqfAnnaType|
  (progn
    (push '|d01aqfAnnaType| *Domains*)
    (make-instance '|d01aqfAnnaTypeType|)))

\end{chunk}

\subsection{d01asfAnnaType}
\index[dom]{d01asfAnnaType!Domain}
\index[dom]{Domain!d01asfAnnaType}
\index[dom]{D01ASFA}
\begin{chunk}{defclass d01asfAnnaTypeType}
(defclass |d01asfAnnaTypeType| (|NumericalIntegrationCategoryType|)
  ((parents :initform '(|NumericalIntegrationCategory|))
   (name :initform "d01asfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'D01ASFA)
   (comment :initform (list
     "d01asfAnnaType is a domain of"
     "NumericalIntegrationCategory"
     "for the NAG routine D01ASF, a numerical integration routine which can"
     "handle weight functions of the form cos(omega x) or sin(omega x) on an"
     "semi-infinite range.  The"
     "function measure measures the usefulness of the routine D01ASF"
     "for the given problem.  The function numericalIntegration"
     "performs the integration by using NagIntegrationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d01asfAnnaType|
  (progn
    (push '|d01asfAnnaType| *Domains*)
    (make-instance '|d01asfAnnaTypeType|)))

\end{chunk}

\subsection{d01fcfAnnaType}
\index[dom]{d01fcfAnnaType!Domain}
\index[dom]{Domain!d01fcfAnnaType}
\index[dom]{D01FCFA}
\begin{chunk}{defclass d01fcfAnnaTypeType}
(defclass |d01fcfAnnaTypeType| (|NumericalIntegrationCategoryType|)
  ((parents :initform '(|NumericalIntegrationCategory|))
   (name :initform "d01fcfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'D01FCFA)
   (comment :initform (list
     "d01fcfAnnaType is a domain of"
     "NumericalIntegrationCategory"
     "for the NAG routine D01FCF, a numerical integration routine which can"
     "handle multi-dimensional quadrature over a finite region.  The"
     "function measure measures the usefulness of the routine D01GBF"
     "for the given problem.  The function numericalIntegration"
     "performs the integration by using NagIntegrationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d01fcfAnnaType|
  (progn
    (push '|d01fcfAnnaType| *Domains*)
    (make-instance '|d01fcfAnnaTypeType|)))

\end{chunk}

\subsection{d01gbfAnnaType}
\index[dom]{d01gbfAnnaType!Domain}
\index[dom]{Domain!d01gbfAnnaType}
\index[dom]{D01GBFA}
\begin{chunk}{defclass d01gbfAnnaTypeType}
(defclass |d01gbfAnnaTypeType| (|NumericalIntegrationCategoryType|)
  ((parents :initform '(|NumericalIntegrationCategory|))
   (name :initform "d01gbfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'D01GBFA)
   (comment :initform (list
     "d01gbfAnnaType is a domain of"
     "NumericalIntegrationCategory"
     "for the NAG routine D01GBF, a numerical integration routine which can"
     "handle multi-dimensional quadrature over a finite region.  The"
     "function measure measures the usefulness of the routine D01GBF"
     "for the given problem.  The function numericalIntegration"
     "performs the integration by using NagIntegrationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d01gbfAnnaType|
  (progn
    (push '|d01gbfAnnaType| *Domains*)
    (make-instance '|d01gbfAnnaTypeType|)))

\end{chunk}

\subsection{d01TransformFunctionType}
\index[dom]{d01TransformFunctionType!Domain}
\index[dom]{Domain!d01TransformFunctionType}
\index[dom]{D01TRNS}
\begin{chunk}{defclass d01TransformFunctionTypeType}
(defclass |d01TransformFunctionTypeType| (|NumericalIntegrationCategoryType|)
  ((parents :initform '(|NumericalIntegrationCategory|))
   (name :initform "d01TransformFunctionType")
   (marker :initform 'domain)
   (abbreviation :initform 'D01TRNS)
   (comment :initform (list
     "Since an infinite integral cannot be evaluated numerically"
     "it is necessary to transform the integral onto finite ranges."
     "d01TransformFunctionType uses the mapping x -> 1/x"
     "and contains the functions measure and"
     "numericalIntegration."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d01TransformFunctionType|
  (progn
    (push '|d01TransformFunctionType| *Domains*)
    (make-instance '|d01TransformFunctionTypeType|)))

\end{chunk}

\subsection{d02bbfAnnaType}
\index[dom]{d02bbfAnnaType!Domain}
\index[dom]{Domain!d02bbfAnnaType}
\index[dom]{D02BBFA}
\begin{chunk}{defclass d02bbfAnnaTypeType}
(defclass |d02bbfAnnaTypeType| (|OrdinaryDifferentialEquationsSolverCategoryType|)
  ((parents :initform '(|OrdinaryDifferentialEquationsSolverCategory|))
   (name :initform "d02bbfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'D02BBFA)
   (comment :initform (list
     "d02bbfAnnaType is a domain of"
     "OrdinaryDifferentialEquationsInitialValueProblemSolverCategory"
     "for the NAG routine D02BBF, a ODE routine which uses an"
     "Runge-Kutta method to solve a system of differential"
     "equations.  The function measure measures the"
     "usefulness of the routine D02BBF for the given problem.  The"
     "function ODESolve performs the integration by using"
     "NagOrdinaryDifferentialEquationsPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d02bbfAnnaType|
  (progn
    (push '|d02bbfAnnaType| *Domains*)
    (make-instance '|d02bbfAnnaTypeType|)))

\end{chunk}

\subsection{d02bhfAnnaType}
\index[dom]{d02bhfAnnaType!Domain}
\index[dom]{Domain!d02bhfAnnaType}
\index[dom]{D02BHFA}
\begin{chunk}{defclass d02bhfAnnaTypeType}
(defclass |d02bhfAnnaTypeType| (|OrdinaryDifferentialEquationsSolverCategoryType|)
  ((parents :initform '(|OrdinaryDifferentialEquationsSolverCategory|))
   (name :initform "d02bhfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'D02BHFA)
   (comment :initform (list
     "d02bhfAnnaType is a domain of"
     "OrdinaryDifferentialEquationsInitialValueProblemSolverCategory"
     "for the NAG routine D02BHF, a ODE routine which uses an"
     "Runge-Kutta method to solve a system of differential"
     "equations.  The function measure measures the"
     "usefulness of the routine D02BHF for the given problem.  The"
     "function ODESolve performs the integration by using"
     "NagOrdinaryDifferentialEquationsPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d02bhfAnnaType|
  (progn
    (push '|d02bhfAnnaType| *Domains*)
    (make-instance '|d02bhfAnnaTypeType|)))

\end{chunk}

\subsection{d02cjfAnnaType}
\index[dom]{d02cjfAnnaType!Domain}
\index[dom]{Domain!d02cjfAnnaType}
\index[dom]{D02CJFA}
\begin{chunk}{defclass d02cjfAnnaTypeType}
(defclass |d02cjfAnnaTypeType| (|OrdinaryDifferentialEquationsSolverCategoryType|)
  ((parents :initform '(|OrdinaryDifferentialEquationsSolverCategory|))
   (name :initform "d02cjfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'D02CJFA)
   (comment :initform (list
     "d02cjfAnnaType is a domain of"
     "OrdinaryDifferentialEquationsInitialValueProblemSolverCategory"
     "for the NAG routine D02CJF, a ODE routine which uses an"
     "Adams-Moulton-Bashworth method to solve a system of differential"
     "equations.  The function measure measures the"
     "usefulness of the routine D02CJF for the given problem.  The"
     "function ODESolve performs the integration by using"
     "NagOrdinaryDifferentialEquationsPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d02cjfAnnaType|
  (progn
    (push '|d02cjfAnnaType| *Domains*)
    (make-instance '|d02cjfAnnaTypeType|)))

\end{chunk}

\subsection{d02ejfAnnaType}
\index[dom]{d02ejfAnnaType!Domain}
\index[dom]{Domain!d02ejfAnnaType}
\index[dom]{D02EJFA}
\begin{chunk}{defclass d02ejfAnnaTypeType}
(defclass |d02ejfAnnaTypeType| (|OrdinaryDifferentialEquationsSolverCategoryType|)
  ((parents :initform '(|OrdinaryDifferentialEquationsSolverCategory|))
   (name :initform "d02ejfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'D02EJFA)
   (comment :initform (list
     "d02ejfAnnaType is a domain of"
     "OrdinaryDifferentialEquationsInitialValueProblemSolverCategory"
     "for the NAG routine D02EJF, a ODE routine which uses a backward"
     "differentiation formulae method to handle a stiff system"
     "of differential equations.  The function measure measures"
     "the usefulness of the routine D02EJF for the given problem.  The"
     "function ODESolve performs the integration by using"
     "NagOrdinaryDifferentialEquationsPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d02ejfAnnaType|
  (progn
    (push '|d02ejfAnnaType| *Domains*)
    (make-instance '|d02ejfAnnaTypeType|)))

\end{chunk}

\subsection{d03eefAnnaType}
\index[dom]{d03eefAnnaType!Domain}
\index[dom]{Domain!d03eefAnnaType}
\index[dom]{D03EEFA}
\begin{chunk}{defclass d03eefAnnaTypeType}
(defclass |d03eefAnnaTypeType| (|PartialDifferentialEquationsSolverCategoryType|)
  ((parents :initform '(|PartialDifferentialEquationsSolverCategory|))
   (name :initform "d03eefAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'D03EEFA)
   (comment :initform (list
     "d03eefAnnaType is a domain of"
     "PartialDifferentialEquationsSolverCategory"
     "for the NAG routines D03EEF/D03EDF."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d03eefAnnaType|
  (progn
    (push '|d03eefAnnaType| *Domains*)
    (make-instance '|d03eefAnnaTypeType|)))

\end{chunk}

\subsection{d03fafAnnaType}
\index[dom]{d03fafAnnaType!Domain}
\index[dom]{Domain!d03fafAnnaType}
\index[dom]{D03FAFA}
\begin{chunk}{defclass d03fafAnnaTypeType}
(defclass |d03fafAnnaTypeType| (|PartialDifferentialEquationsSolverCategoryType|)
  ((parents :initform '(|PartialDifferentialEquationsSolverCategory|))
   (name :initform "d03fafAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'D03FAFA)
   (comment :initform (list
     "d03fafAnnaType is a domain of"
     "PartialDifferentialEquationsSolverCategory"
     "for the NAG routine D03FAF."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d03fafAnnaType|
  (progn
    (push '|d03fafAnnaType| *Domains*)
    (make-instance '|d03fafAnnaTypeType|)))

\end{chunk}

\section{E}

\subsection{ElementaryFunctionsUnivariateLaurentSeries}
\index[dom]{ElementaryFunctionsUnivariateLaurentSeries!Domain}
\index[dom]{Domain!ElementaryFunctionsUnivariateLaurentSeries}
\index[dom]{EFULS}
\begin{chunk}{defclass ElementaryFunctionsUnivariateLaurentSeriesType}
(defclass |ElementaryFunctionsUnivariateLaurentSeriesType| (|PartialTranscendentalFunctionsType|)
  ((parents :initform '(|PartialTranscendentalFunctions|))
   (name :initform "ElementaryFunctionsUnivariateLaurentSeries")
   (marker :initform 'domain)
   (abbreviation :initform 'EFULS)
   (comment :initform (list
     "This domain provides elementary functions on any Laurent series"
     "domain over a field which was constructed from a Taylor series"
     "domain.  These functions are implemented by calling the"
     "corresponding functions on the Taylor series domain.  We also"
     "provide 'partial functions' which compute transcendental"
     "functions of Laurent series when possible and return 'failed'"
     "when this is not possible."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ElementaryFunctionsUnivariateLaurentSeries|
  (progn
    (push '|ElementaryFunctionsUnivariateLaurentSeries| *Domains*)
    (make-instance '|ElementaryFunctionsUnivariateLaurentSeriesType|)))

\end{chunk}

\subsection{ElementaryFunctionsUnivariatePuiseuxSeries}
\index[dom]{ElementaryFunctionsUnivariatePuiseuxSeries!Domain}
\index[dom]{Domain!ElementaryFunctionsUnivariatePuiseuxSeries}
\index[dom]{EFUPXS}
\begin{chunk}{defclass ElementaryFunctionsUnivariatePuiseuxSeriesType}
(defclass |ElementaryFunctionsUnivariatePuiseuxSeriesType| (|PartialTranscendentalFunctionsType|)
  ((parents :initform '(|PartialTranscendentalFunctions|))
   (name :initform "ElementaryFunctionsUnivariatePuiseuxSeries")
   (marker :initform 'domain)
   (abbreviation :initform 'EFUPXS)
   (comment :initform (list
     "This package provides elementary functions on any Laurent series"
     "domain over a field which was constructed from a Taylor series"
     "domain.  These functions are implemented by calling the"
     "corresponding functions on the Taylor series domain.  We also"
     "provide 'partial functions' which compute transcendental"
     "functions of Laurent series when possible and return 'failed'"
     "when this is not possible."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ElementaryFunctionsUnivariatePuiseuxSeries|
  (progn
    (push '|ElementaryFunctionsUnivariatePuiseuxSeries| *Domains*)
    (make-instance '|ElementaryFunctionsUnivariatePuiseuxSeriesType|)))

\end{chunk}

\subsection{Equation}
\index[dom]{Equation!Domain}
\index[dom]{Domain!Equation}
\index[dom]{EQ}
\begin{chunk}{defclass EquationType}
(defclass |EquationType| (|GroupType|
                          |InnerEvalableType|
                          |PartialDifferentialRingType|
                          |TypeType|
                          |VectorSpaceType|)
  ((parents :initform '(|Group|
                        |InnerEvalable|
                        |PartialDifferentialRing|
                        |Type|
                        |VectorSpace|))
   (name :initform "Equation")
   (marker :initform 'domain)
   (abbreviation :initform 'EQ)
   (comment :initform (list
     "Equations as mathematical objects.  All properties of the basis domain,"
     "for example being an abelian group are carried over the equation domain,"
     "by performing the structural operations on the left and on the"
     "right hand side."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Equation|
  (progn
    (push '|Equation| *Domains*)
    (make-instance '|EquationType|)))

\end{chunk}

\subsection{EqTable}
\index[dom]{EqTable!Domain}
\index[dom]{Domain!EqTable}
\index[dom]{EQTBL}
\begin{chunk}{defclass EqTableType}
(defclass |EqTableType| (|TableAggregateType|)
  ((parents :initform '(|TableAggregate|))
   (name :initform "EqTable")
   (marker :initform 'domain)
   (abbreviation :initform 'EQTBL)
   (comment :initform (list
     "This domain provides tables where the keys are compared using"
     "eq?.  Thus keys are considered equal only if they"
     "are the same instance of a structure."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |EqTable|
  (progn
    (push '|EqTable| *Domains*)
    (make-instance '|EqTableType|)))

\end{chunk}

\subsection{EuclideanModularRing}
\index[dom]{EuclideanModularRing!Domain}
\index[dom]{Domain!EuclideanModularRing}
\index[dom]{EMR}
\begin{chunk}{defclass EuclideanModularRingType}
(defclass |EuclideanModularRingType| (|EuclideanDomainType|)
  ((parents :initform '(|EuclideanDomain|))
   (name :initform "EuclideanModularRing")
   (marker :initform 'domain)
   (abbreviation :initform 'EMR)
   (comment :initform (list
     "These domains are used for the factorization and gcds"
     "of univariate polynomials over the integers in order to work modulo"
     "different  primes."
     "See ModularRing, ModularField"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |EuclideanModularRing|
  (progn
    (push '|EuclideanModularRing| *Domains*)
    (make-instance '|EuclideanModularRingType|)))

\end{chunk}

\subsection{Exit}
\index[dom]{Exit!Domain}
\index[dom]{Domain!Exit}
\index[dom]{EXIT}
\begin{chunk}{defclass ExitType}
(defclass |ExitType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "Exit")
   (marker :initform 'domain)
   (abbreviation :initform 'EXIT)
   (comment :initform (list
     "A function which does not return directly to its caller should"
     "have Exit as its return type."
     " "
     "Note that It is convenient to have a formal coerce into each type"
     "from type Exit. This allows, for example, errors to be raised in"
     "one half of a type-balanced if."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Exit|
  (progn
    (push '|Exit| *Domains*)
    (make-instance '|ExitType|)))

\end{chunk}

\subsection{ExponentialExpansion}
\index[dom]{ExponentialExpansion!Domain}
\index[dom]{Domain!ExponentialExpansion}
\index[dom]{EXPEXPAN}
\begin{chunk}{defclass ExponentialExpansionType}
(defclass |ExponentialExpansionType| (|QuotientFieldCategoryType|)
  ((parents :initform '(|QuotientFieldCategory|))
   (name :initform "ExponentialExpansion")
   (marker :initform 'domain)
   (abbreviation :initform 'EXPEXPAN)
   (comment :initform (list
     "UnivariatePuiseuxSeriesWithExponentialSingularity is a domain used to"
     "represent essential singularities of functions.  Objects in this domain"
     "are quotients of sums, where each term in the sum is a univariate Puiseux"
     "series times the exponential of a univariate Puiseux series."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExponentialExpansion|
  (progn
    (push '|ExponentialExpansion| *Domains*)
    (make-instance '|ExponentialExpansionType|)))

\end{chunk}

\subsection{Expression}
\index[dom]{Expression!Domain}
\index[dom]{Domain!Expression}
\index[dom]{EXPR}
\begin{chunk}{defclass ExpressionType}
(defclass |ExpressionType| (|SpecialFunctionCategoryType|
                            |LiouvillianFunctionCategoryType|
                            |CombinatorialOpsCategoryType|
                            |AlgebraicallyClosedFunctionSpaceType|)
  ((parents :initform '(|SpecialFunctionCategory|
                        |LiouvillianFunctionCategory|
                        |CombinatorialOpsCategory|
                        |AlgebraicallyClosedFunctionSpace|))
   (name :initform "Expression")
   (marker :initform 'domain)
   (abbreviation :initform 'EXPR)
   (comment :initform (list
     "Top-level mathematical expressions involving symbolic functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Expression|
  (progn
    (push '|Expression| *Domains*)
    (make-instance '|ExpressionType|)))

\end{chunk}

\subsection{ExponentialOfUnivariatePuiseuxSeries}
\index[dom]{ExponentialOfUnivariatePuiseuxSeries!Domain}
\index[dom]{Domain!ExponentialOfUnivariatePuiseuxSeries}
\index[dom]{EXPUPXS}
\begin{chunk}{defclass ExponentialOfUnivariatePuiseuxSeriesType}
(defclass |ExponentialOfUnivariatePuiseuxSeriesType| (|OrderedAbelianMonoidType|
                                                      |UnivariatePuiseuxSeriesCategoryType|)
  ((parents :initform '(|OrderedAbelianMonoid| |UnivariatePuiseuxSeriesCategory|))
   (name :initform "ExponentialOfUnivariatePuiseuxSeries")
   (marker :initform 'domain)
   (abbreviation :initform 'EXPUPXS)
   (comment :initform (list
     "ExponentialOfUnivariatePuiseuxSeries is a domain used to represent"
     "essential singularities of functions.  An object in this domain is a"
     "function of the form exp(f(x)), where f(x) is a Puiseux"
     "series with no terms of non-negative degree.  Objects are ordered"
     "according to order of singularity, with functions which tend more"
     "rapidly to zero or infinity considered to be larger.  Thus, if"
     "order(f(x)) < order(g(x)), the first non-zero term of"
     "f(x) has lower degree than the first non-zero term of g(x),"
     "then exp(f(x)) > exp(g(x)).  If order(f(x)) = order(g(x)),"
     "then the ordering is essentially random.  This domain is used"
     "in computing limits involving functions with essential singularities."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExponentialOfUnivariatePuiseuxSeries|
  (progn
    (push '|ExponentialOfUnivariatePuiseuxSeries| *Domains*)
    (make-instance '|ExponentialOfUnivariatePuiseuxSeriesType|)))

\end{chunk}

\subsection{ExtAlgBasis}
\index[dom]{ExtAlgBasis!Domain}
\index[dom]{Domain!ExtAlgBasis}
\index[dom]{EAB}
\begin{chunk}{defclass ExtAlgBasisType}
(defclass |ExtAlgBasisType| (|OrderedSetType|)
  ((parents :initform '(|OrderedSet|))
   (name :initform "ExtAlgBasis")
   (marker :initform 'domain)
   (abbreviation :initform 'EAB)
   (comment :initform (list
     "A domain used in the construction of the exterior algebra on a set"
     "X over a ring R.  This domain represents the set of all ordered"
     "subsets of the set X, assumed to be in correspondance with"
     "{1,2,3, ...}.  The ordered subsets are themselves ordered"
     "lexicographically and are in bijective correspondance with an ordered"
     "basis of the exterior algebra.  In this domain we are dealing strictly"
     "with the exponents of basis elements which can only be 0 or 1."
     " "
     "The multiplicative identity element of the exterior algebra corresponds"
     "to the empty subset of X.  A coerce from List Integer to an"
     "ordered basis element is provided to allow the convenient input of"
     "expressions. Another exported function forgets the ordered structure"
     "and simply returns the list corresponding to an ordered subset."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExtAlgBasis|
  (progn
    (push '|ExtAlgBasis| *Domains*)
    (make-instance '|ExtAlgBasisType|)))

\end{chunk}

\subsection{e04dgfAnnaType}
\index[dom]{e04dgfAnnaType!Domain}
\index[dom]{Domain!e04dgfAnnaType}
\index[dom]{E04DGFA}
\begin{chunk}{defclass e04dgfAnnaTypeType}
(defclass |e04dgfAnnaTypeType| (|NumericalOptimizationCategoryType|)
  ((parents :initform '(|NumericalOptimizationCategory|))
   (name :initform "e04dgfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'E04DGFA)
   (comment :initform (list
     "e04dgfAnnaType is a domain of NumericalOptimization"
     "for the NAG routine E04DGF, a general optimization routine which"
     "can handle some singularities in the input function.  The function"
     "measure measures the usefulness of the routine E04DGF"
     "for the given problem.  The function numericalOptimization"
     "performs the optimization by using NagOptimisationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |e04dgfAnnaType|
  (progn
    (push '|e04dgfAnnaType| *Domains*)
    (make-instance '|e04dgfAnnaTypeType|)))

\end{chunk}

\subsection{e04fdfAnnaType}
\index[dom]{e04fdfAnnaType!Domain}
\index[dom]{Domain!e04fdfAnnaType}
\index[dom]{E04FDFA}
\begin{chunk}{defclass e04fdfAnnaTypeType}
(defclass |e04fdfAnnaTypeType| (|NumericalOptimizationCategoryType|)
  ((parents :initform '(|NumericalOptimizationCategory|))
   (name :initform "e04fdfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'E04FDFA)
   (comment :initform (list
     "e04fdfAnnaType is a domain of NumericalOptimization"
     "for the NAG routine E04FDF, a general optimization routine which"
     "can handle some singularities in the input function.  The function"
     "measure measures the usefulness of the routine E04FDF"
     "for the given problem.  The function numericalOptimization"
     "performs the optimization by using NagOptimisationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |e04fdfAnnaType|
  (progn
    (push '|e04fdfAnnaType| *Domains*)
    (make-instance '|e04fdfAnnaTypeType|)))

\end{chunk}

\subsection{e04gcfAnnaType}
\index[dom]{e04gcfAnnaType!Domain}
\index[dom]{Domain!e04gcfAnnaType}
\index[dom]{E04GCFA}
\begin{chunk}{defclass e04gcfAnnaTypeType}
(defclass |e04gcfAnnaTypeType| (|NumericalOptimizationCategoryType|)
  ((parents :initform '(|NumericalOptimizationCategory|))
   (name :initform "e04gcfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'E04GCFA)
   (comment :initform (list
     "e04gcfAnnaType is a domain of NumericalOptimization"
     "for the NAG routine E04GCF, a general optimization routine which"
     "can handle some singularities in the input function.  The function"
     "measure measures the usefulness of the routine E04GCF"
     "for the given problem.  The function numericalOptimization"
     "performs the optimization by using NagOptimisationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |e04gcfAnnaType|
  (progn
    (push '|e04gcfAnnaType| *Domains*)
    (make-instance '|e04gcfAnnaTypeType|)))

\end{chunk}

\subsection{e04jafAnnaType}
\index[dom]{e04jafAnnaType!Domain}
\index[dom]{Domain!e04jafAnnaType}
\index[dom]{E04JAFA}
\begin{chunk}{defclass e04jafAnnaTypeType}
(defclass |e04jafAnnaTypeType| (|NumericalOptimizationCategoryType|)
  ((parents :initform '(|NumericalOptimizationCategory|))
   (name :initform "e04jafAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'E04JAFA)
   (comment :initform (list
     "e04jafAnnaType is a domain of NumericalOptimization"
     "for the NAG routine E04JAF, a general optimization routine which"
     "can handle some singularities in the input function.  The function"
     "measure measures the usefulness of the routine E04JAF"
     "for the given problem.  The function numericalOptimization"
     "performs the optimization by using NagOptimisationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |e04jafAnnaType|
  (progn
    (push '|e04jafAnnaType| *Domains*)
    (make-instance '|e04jafAnnaTypeType|)))

\end{chunk}

\subsection{e04mbfAnnaType}
\index[dom]{e04mbfAnnaType!Domain}
\index[dom]{Domain!e04mbfAnnaType}
\index[dom]{E04MBFA}
\begin{chunk}{defclass e04mbfAnnaTypeType}
(defclass |e04mbfAnnaTypeType| (|NumericalOptimizationCategoryType|)
  ((parents :initform '(|NumericalOptimizationCategory|))
   (name :initform "e04mbfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'E04MBFA)
   (comment :initform (list
     "e04mbfAnnaType is a domain of NumericalOptimization"
     "for the NAG routine E04MBF, an optimization routine for Linear functions."
     "The function"
     "measure measures the usefulness of the routine E04MBF"
     "for the given problem.  The function numericalOptimization"
     "performs the optimization by using NagOptimisationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |e04mbfAnnaType|
  (progn
    (push '|e04mbfAnnaType| *Domains*)
    (make-instance '|e04mbfAnnaTypeType|)))

\end{chunk}

\subsection{e04nafAnnaType}
\index[dom]{e04nafAnnaType!Domain}
\index[dom]{Domain!e04nafAnnaType}
\index[dom]{E04NAFA}
\begin{chunk}{defclass e04nafAnnaTypeType}
(defclass |e04nafAnnaTypeType| (|NumericalOptimizationCategoryType|)
  ((parents :initform '(|NumericalOptimizationCategory|))
   (name :initform "e04nafAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'E04NAFA)
   (comment :initform (list
     "e04nafAnnaType is a domain of NumericalOptimization"
     "for the NAG routine E04NAF, an optimization routine for Quadratic functions."
     "The function"
     "measure measures the usefulness of the routine E04NAF"
     "for the given problem.  The function numericalOptimization"
     "performs the optimization by using NagOptimisationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |e04nafAnnaType|
  (progn
    (push '|e04nafAnnaType| *Domains*)
    (make-instance '|e04nafAnnaTypeType|)))

\end{chunk}

\subsection{e04ucfAnnaType}
\index[dom]{e04ucfAnnaType!Domain}
\index[dom]{Domain!e04ucfAnnaType}
\index[dom]{E04UCFA}
\begin{chunk}{defclass e04ucfAnnaTypeType}
(defclass |e04ucfAnnaTypeType| (|NumericalOptimizationCategoryType|)
  ((parents :initform '(|NumericalOptimizationCategory|))
   (name :initform "e04ucfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'E04UCFA)
   (comment :initform (list
     "e04ucfAnnaType is a domain of NumericalOptimization"
     "for the NAG routine E04UCF, a general optimization routine which"
     "can handle some singularities in the input function.  The function"
     "measure measures the usefulness of the routine E04UCF"
     "for the given problem.  The function numericalOptimization"
     "performs the optimization by using NagOptimisationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |e04ucfAnnaType|
  (progn
    (push '|e04ucfAnnaType| *Domains*)
    (make-instance '|e04ucfAnnaTypeType|)))

\end{chunk}

\section{F}

\subsection{Factored}
\index[dom]{Factored!Domain}
\index[dom]{Domain!Factored}
\index[dom]{FR}
\begin{chunk}{defclass FactoredType}
(defclass |FactoredType| (|UniqueFactorizationDomainType|
                          |RealConstantType|
                          |FullyRetractableToType|
                          |FullyEvalableOverType|
                          |DifferentialExtensionType|)
  ((parents :initform '(|UniqueFactorizationDomain|
                        |RealConstant|
                        |FullyRetractableTo|
                        |FullyEvalableOver|
                        |DifferentialExtension|))
   (name :initform "Factored")
   (marker :initform 'domain)
   (abbreviation :initform 'FR)
   (comment :initform (list
     "Factored creates a domain whose objects are kept in"
     "factored form as long as possible.  Thus certain operations like"
     "multiplication and gcd are relatively easy to do.  Others, like"
     "addition require somewhat more work, and unless the argument"
     "domain provides a factor function, the result may not be"
     "completely factored.  Each object consists of a unit and a list of"
     "factors, where a factor has a member of R (the 'base'), and"
     "exponent and a flag indicating what is known about the base.  A"
     "flag may be one of 'nil', 'sqfr', 'irred' or 'prime', which respectively mean"
     "that nothing is known about the base, it is square-free, it is"
     "irreducible, or it is prime.  The current"
     "restriction to integral domains allows simplification to be"
     "performed without worrying about multiplication order."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Factored|
  (progn
    (push '|Factored| *Domains*)
    (make-instance '|FactoredType|)))

\end{chunk}

\subsection{File}
\index[dom]{File!Domain}
\index[dom]{Domain!File}
\index[dom]{FILE}
\begin{chunk}{defclass FileType}
(defclass |FileType| (|FileCategoryType|)
  ((parents :initform '(|FileCategory|))
   (name :initform "File")
   (marker :initform 'domain)
   (abbreviation :initform 'FILE)
   (comment :initform (list
     "This domain provides a basic model of files to save arbitrary values."
     "The operations provide sequential access to the contents."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |File|
  (progn
    (push '|File| *Domains*)
    (make-instance '|FileType|)))

\end{chunk}

\subsection{FileName}
\index[dom]{FileName!Domain}
\index[dom]{Domain!FileName}
\index[dom]{FNAME}
\begin{chunk}{defclass FileNameType}
(defclass |FileNameType| (|FileNameCategoryType|)
  ((parents :initform '(|FileNameCategory|))
   (name :initform "FileName")
   (marker :initform 'domain)
   (abbreviation :initform 'FNAME)
   (comment :initform (list
     "This domain provides an interface to names in the file system."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FileName|
  (progn
    (push '|FileName| *Domains*)
    (make-instance '|FileNameType|)))

\end{chunk}

\subsection{FiniteDivisor}
\index[dom]{FiniteDivisor!Domain}
\index[dom]{Domain!FiniteDivisor}
\index[dom]{FDIV}
\begin{chunk}{defclass FiniteDivisorType}
(defclass |FiniteDivisorType| (|FiniteDivisorCategoryType|)
  ((parents :initform '(|FiniteDivisorCategory|))
   (name :initform "FiniteDivisor")
   (marker :initform 'domain)
   (abbreviation :initform 'FDIV)
   (comment :initform (list
     "This domains implements finite rational divisors on a curve, that"
     "is finite formal sums SUM(n * P) where the n's are integers and the"
     "P's are finite rational points on the curve."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteDivisor|
  (progn
    (push '|FiniteDivisor| *Domains*)
    (make-instance '|FiniteDivisorType|)))

\end{chunk}

\subsection{FiniteField}
\index[dom]{FiniteField!Domain}
\index[dom]{Domain!FiniteField}
\index[dom]{FF}
\begin{chunk}{defclass FiniteFieldType}
(defclass |FiniteFieldType| (|FiniteAlgebraicExtensionFieldType|)
  ((parents :initform '(|FiniteAlgebraicExtensionField|))
   (name :initform "FiniteField")
   (marker :initform 'domain)
   (abbreviation :initform 'FF)
   (comment :initform (list
     "FiniteField(p,n) implements finite fields with p**n elements."
     "This packages checks that p is prime."
     "For a non-checking version, see InnerFiniteField."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteField|
  (progn
    (push '|FiniteField| *Domains*)
    (make-instance '|FiniteFieldType|)))

\end{chunk}

\subsection{FiniteFieldCyclicGroup}
\index[dom]{FiniteFieldCyclicGroup!Domain}
\index[dom]{Domain!FiniteFieldCyclicGroup}
\index[dom]{FFCG}
\begin{chunk}{defclass FiniteFieldCyclicGroupType}
(defclass |FiniteFieldCyclicGroupType| (|FiniteAlgebraicExtensionFieldType|)
  ((parents :initform '(|FiniteAlgebraicExtensionField|))
   (name :initform "FiniteFieldCyclicGroup")
   (marker :initform 'domain)
   (abbreviation :initform 'FFCG)
   (comment :initform (list
     "FiniteFieldCyclicGroup(p,n) implements a finite field extension of degee n"
     "over the prime field with p elements. Its elements are represented by"
     "powers of a primitive element, a generator of the multiplicative"
     "(cyclic) group. As primitive element we choose the root of the extension"
     "polynomial, which is created by createPrimitivePoly from"
     "FiniteFieldPolynomialPackage. The Zech logarithms are stored"
     "in a table of size half of the field size, and use SingleInteger"
     "for representing field elements, hence, there are restrictions"
     "on the size of the field."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldCyclicGroup|
  (progn
    (push '|FiniteFieldCyclicGroup| *Domains*)
    (make-instance '|FiniteFieldCyclicGroupType|)))

\end{chunk}

\subsection{FiniteFieldCyclicGroupExtension}
\index[dom]{FiniteFieldCyclicGroupExtension!Domain}
\index[dom]{Domain!FiniteFieldCyclicGroupExtension}
\index[dom]{FFCGX}
\begin{chunk}{defclass FiniteFieldCyclicGroupExtensionType}
(defclass |FiniteFieldCyclicGroupExtensionType| (|FiniteAlgebraicExtensionFieldType|)
  ((parents :initform '(|FiniteAlgebraicExtensionField|))
   (name :initform "FiniteFieldCyclicGroupExtension")
   (marker :initform 'domain)
   (abbreviation :initform 'FFCGX)
   (comment :initform (list
     "FiniteFieldCyclicGroupExtension(GF,n)  implements a extension of degree n"
     "over the ground field GF. Its elements are represented by powers of"
     "a primitive element, a generator of the multiplicative (cyclic) group."
     "As primitive element we choose the root of the extension polynomial, which"
     "is created by createPrimitivePoly from"
     "FiniteFieldPolynomialPackage. Zech logarithms are stored"
     "in a table of size half of the field size, and use SingleInteger"
     "for representing field elements, hence, there are restrictions"
     "on the size of the field."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldCyclicGroupExtension|
  (progn
    (push '|FiniteFieldCyclicGroupExtension| *Domains*)
    (make-instance '|FiniteFieldCyclicGroupExtensionType|)))

\end{chunk}

\subsection{FiniteFieldCyclicGroupExtensionByPolynomial}
\index[dom]{FiniteFieldCyclicGroupExtensionByPolynomial!Domain}
\index[dom]{Domain!FiniteFieldCyclicGroupExtensionByPolynomial}
\index[dom]{FFCGP}
\begin{chunk}{defclass FiniteFieldCyclicGroupExtensionByPolynomialType}
(defclass |FiniteFieldCyclicGroupExtensionByPolynomialType| (|FiniteAlgebraicExtensionFieldType|)
  ((parents :initform '(|FiniteAlgebraicExtensionField|))
   (name :initform "FiniteFieldCyclicGroupExtensionByPolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'FFCGP)
   (comment :initform (list
     "FiniteFieldCyclicGroupExtensionByPolynomial(GF,defpol)  implements a"
     "finite extension field of the ground field GF. Its elements are"
     "represented by powers of a primitive element, a generator of the"
     "multiplicative (cyclic) group. As primitive"
     "element we choose the root of the extension polynomial defpol,"
     "which MUST be primitive (user responsibility). Zech logarithms are stored"
     "in a table of size half of the field size, and use SingleInteger"
     "for representing field elements, hence, there are restrictions"
     "on the size of the field."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldCyclicGroupExtensionByPolynomial|
  (progn
    (push '|FiniteFieldCyclicGroupExtensionByPolynomial| *Domains*)
    (make-instance '|FiniteFieldCyclicGroupExtensionByPolynomialType|)))

\end{chunk}

\subsection{FiniteFieldExtension}
\index[dom]{FiniteFieldExtension!Domain}
\index[dom]{Domain!FiniteFieldExtension}
\index[dom]{FFX}
\begin{chunk}{defclass FiniteFieldExtensionType}
(defclass |FiniteFieldExtensionType| (|FiniteAlgebraicExtensionFieldType|)
  ((parents :initform '(|FiniteAlgebraicExtensionField|))
   (name :initform "FiniteFieldExtension")
   (marker :initform 'domain)
   (abbreviation :initform 'FFX)
   (comment :initform (list
     "FiniteFieldExtensionByPolynomial(GF, n) implements an extension"
     "of the finite field GF of degree n generated by the extension"
     "polynomial constructed by createIrreduciblePoly from"
     "FiniteFieldPolynomialPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldExtension|
  (progn
    (push '|FiniteFieldExtension| *Domains*)
    (make-instance '|FiniteFieldExtensionType|)))

\end{chunk}

\subsection{FiniteFieldExtensionByPolynomial}
\index[dom]{FiniteFieldExtensionByPolynomial!Domain}
\index[dom]{Domain!FiniteFieldExtensionByPolynomial}
\index[dom]{FFP}
\begin{chunk}{defclass FiniteFieldExtensionByPolynomialType}
(defclass |FiniteFieldExtensionByPolynomialType| (|FiniteAlgebraicExtensionFieldType|)
  ((parents :initform '(|FiniteAlgebraicExtensionField|))
   (name :initform "FiniteFieldExtensionByPolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'FFP)
   (comment :initform (list
     "FiniteFieldExtensionByPolynomial(GF, defpol) implements the extension"
     "of the finite field GF generated by the extension polynomial"
     "defpol which MUST be irreducible."
     "Note: the user has the responsibility to ensure that"
     "defpol is irreducible."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldExtensionByPolynomial|
  (progn
    (push '|FiniteFieldExtensionByPolynomial| *Domains*)
    (make-instance '|FiniteFieldExtensionByPolynomialType|)))

\end{chunk}

\subsection{FiniteFieldNormalBasis}
\index[dom]{FiniteFieldNormalBasis!Domain}
\index[dom]{Domain!FiniteFieldNormalBasis}
\index[dom]{FFNB}
\begin{chunk}{defclass FiniteFieldNormalBasisType}
(defclass |FiniteFieldNormalBasisType| (|FiniteAlgebraicExtensionFieldType|)
  ((parents :initform '(|FiniteAlgebraicExtensionField|))
   (name :initform "FiniteFieldNormalBasis")
   (marker :initform 'domain)
   (abbreviation :initform 'FFNB)
   (comment :initform (list
     "FiniteFieldNormalBasis(p,n) implements a"
     "finite extension field of degree n over the prime field with p elements."
     "The elements are represented by coordinate vectors with respect to"
     "a normal basis,"
     "a basis consisting of the conjugates (q-powers) of an element, in"
     "this case called normal element."
     "This is chosen as a root of the extension polynomial"
     "created by createNormalPoly"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldNormalBasis|
  (progn
    (push '|FiniteFieldNormalBasis| *Domains*)
    (make-instance '|FiniteFieldNormalBasisType|)))

\end{chunk}

\subsection{FiniteFieldNormalBasisExtension}
\index[dom]{FiniteFieldNormalBasisExtension!Domain}
\index[dom]{Domain!FiniteFieldNormalBasisExtension}
\index[dom]{FFNBX}
\begin{chunk}{defclass FiniteFieldNormalBasisExtensionType}
(defclass |FiniteFieldNormalBasisExtensionType| (|FiniteAlgebraicExtensionFieldType|)
  ((parents :initform '(|FiniteAlgebraicExtensionField|))
   (name :initform "FiniteFieldNormalBasisExtension")
   (marker :initform 'domain)
   (abbreviation :initform 'FFNBX)
   (comment :initform (list
     "FiniteFieldNormalBasisExtensionByPolynomial(GF,n)  implements a"
     "finite extension field of degree n over the ground field GF."
     "The elements are represented by coordinate vectors with respect"
     "to a normal basis,"
     "a basis consisting of the conjugates (q-powers) of an element,"
     "in this case called normal element. This is chosen as a root of the extension"
     "polynomial, created by createNormalPoly from"
     "FiniteFieldPolynomialPackage"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldNormalBasisExtension|
  (progn
    (push '|FiniteFieldNormalBasisExtension| *Domains*)
    (make-instance '|FiniteFieldNormalBasisExtensionType|)))

\end{chunk}

\subsection{FiniteFieldNormalBasisExtensionByPolynomial}
\index[dom]{FiniteFieldNormalBasisExtensionByPolynomial!Domain}
\index[dom]{Domain!FiniteFieldNormalBasisExtensionByPolynomial}
\index[dom]{FFNBP}
\begin{chunk}{defclass FiniteFieldNormalBasisExtensionByPolynomialType}
(defclass |FiniteFieldNormalBasisExtensionByPolynomialType| (|FiniteAlgebraicExtensionFieldType|)
  ((parents :initform '(|FiniteAlgebraicExtensionField|))
   (name :initform "FiniteFieldNormalBasisExtensionByPolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'FFNBP)
   (comment :initform (list
     "FiniteFieldNormalBasisExtensionByPolynomial(GF,uni) implements a"
     "finite extension of the ground field GF. The elements are"
     "represented by coordinate vectors with respect to a normal basis, a basis"
     "consisting of the conjugates (q-powers) of an element, in this case"
     "called normal element, where q is the size of GF."
     "The normal element is chosen as a root of the extension"
     "polynomial, which MUST be normal over GF  (user responsibility)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldNormalBasisExtensionByPolynomial|
  (progn
    (push '|FiniteFieldNormalBasisExtensionByPolynomial| *Domains*)
    (make-instance '|FiniteFieldNormalBasisExtensionByPolynomialType|)))

\end{chunk}

\subsection{FlexibleArray}
\index[dom]{FlexibleArray!Domain}
\index[dom]{Domain!FlexibleArray}
\index[dom]{FARRAY}
\begin{chunk}{defclass FlexibleArrayType}
(defclass |FlexibleArrayType| (|ExtensibleLinearAggregateType|
                               |OneDimensionalArrayAggregateType|)
  ((parents :initform '(|ExtensibleLinearAggregate| |OneDimensionalArrayAggregate|))
   (name :initform "FlexibleArray")
   (marker :initform 'domain)
   (abbreviation :initform 'FARRAY)
   (comment :initform (list
     "A FlexibleArray is the notion of an array intended to allow for growth"
     "at the end only.  Hence the following efficient operations"
     "append(x,a) meaning append item x at the end of the array a"
     "delete(a,n) meaning delete the last item from the array a"
     "Flexible arrays support the other operations inherited from"
     "ExtensibleLinearAggregate. However, these are not efficient."
     "Flexible arrays combine the O(1) access time property of arrays"
     "with growing and shrinking at the end in O(1) (average) time."
     "This is done by using an ordinary array which may have zero or more"
     "empty slots at the end.  When the array becomes full it is copied"
     "into a new larger (50% larger) array.  Conversely, when the array"
     "becomes less than 1/2 full, it is copied into a smaller array."
     "Flexible arrays provide for an efficient implementation of many"
     "data structures in particular heaps, stacks and sets."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FlexibleArray|
  (progn
    (push '|FlexibleArray| *Domains*)
    (make-instance '|FlexibleArrayType|)))

\end{chunk}

\subsection{Float}
\index[dom]{Float!Domain}
\index[dom]{Domain!Float}
\index[dom]{FLOAT}
\begin{chunk}{defclass FloatType}
(defclass |FloatType| (|TranscendentalFunctionCategoryType|
                       |OpenMathType|
                       |FloatingPointSystemType|
                       |DifferentialRingType|)
  ((parents :initform '(|TranscendentalFunctionCategory|
                        |OpenMath|
                        |FloatingPointSystem|
                        |DifferentialRing|))
   (name :initform "Float")
   (marker :initform 'domain)
   (abbreviation :initform 'FLOAT)
   (comment :initform (list
     "Float implements arbitrary precision floating point arithmetic."
     "The number of significant digits of each operation can be set"
     "to an arbitrary value (the default is 20 decimal digits)."
     "The operation float(mantissa,exponent,base) for integer"
     "mantissa, exponent specifies the number"
     "mantissa * base ** exponent"
     "The underlying representation for floats is binary"
     "not decimal. The implications of this are described below."
     " "
     "The model adopted is that arithmetic operations are rounded to"
     "to nearest unit in the last place, that is, accurate to within"
     "2**(-bits). Also, the elementary functions and constants are"
     "accurate to one unit in the last place."
     "A float is represented as a record of two integers, the mantissa"
     "and the exponent.  The base of the representation is binary, hence"
     "a Record(m:mantissa,e:exponent) represents the number"
     "m * 2 ** e."
     "Though it is not assumed that the underlying integers are represented"
     "with a binary base, the code will be most efficient when this is the"
     "the case (this is true in most implementations of Lisp)."
     "The decision to choose the base to be binary has some unfortunate"
     "consequences.  First, decimal numbers like 0.3 cannot be represented"
     "exactly.  Second, there is a further loss of accuracy during"
     "conversion to decimal for output.  To compensate for this, if d digits"
     "of precision are specified, 1 + ceiling(log2(10^d)) bits are used."
     "Two numbers that are displayed identically may therefore be"
     "not equal.  On the other hand, a significant efficiency loss would"
     "be incurred if we chose to use a decimal base when the underlying"
     "integer base is binary."
     " "
     "Algorithms used:"
     "For the elementary functions, the general approach is to apply"
     "identities so that the taylor series can be used, and, so"
     "that it will converge within O( sqrt n ) steps.  For example,"
     "using the identity exp(x) = exp(x/2)**2, we can compute"
     "exp(1/3) to n digits of precision as follows.  We have"
     "exp(1/3) = exp(2 ** (-sqrt s) / 3) ** (2 ** sqrt s)."
     "The taylor series will converge in less than sqrt n steps and the"
     "exponentiation requires sqrt n multiplications for a total of"
     "2 sqrt n multiplications.  Assuming integer multiplication costs"
     "O( n**2 ) the overall running time is O( sqrt(n) n**2 )."
     "This approach is the best known approach for precisions up to"
     "about 10,000 digits at which point the methods of Brent"
     "which are O( log(n) n**2 ) become competitive.  Note also that"
     "summing the terms of the taylor series for the elementary"
     "functions is done using integer operations.  This avoids the"
     "overhead of floating point operations and results in efficient"
     "code at low precisions.  This implementation makes no attempt"
     "to reuse storage, relying on the underlying system to do"
     "garbage collection. I estimate that the efficiency of this"
     "package at low precisions could be improved by a factor of 2"
     "if in-place operations were available."
     " "
     "Running times: in the following, n is the number of bits of precision"
     "*, /, sqrt, pi, exp1, log2, log10:  O( n**2 )"
     "exp, log, sin, atan: O(sqrt(n) n**2)"
     "The other elementary functions are coded in terms of the ones above."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Float|
  (progn
    (push '|Float| *Domains*)
    (make-instance '|FloatType|)))

\end{chunk}

\subsection{FortranCode}
\index[dom]{FortranCode!Domain}
\index[dom]{Domain!FortranCode}
\index[dom]{FC}
\begin{chunk}{defclass FortranCodeType}
(defclass |FortranCodeType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "FortranCode")
   (marker :initform 'domain)
   (abbreviation :initform 'FC)
   (comment :initform (list
     "This domain builds representations of program code segments for use with"
     "the FortranProgram domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FortranCode|
  (progn
    (push '|FortranCode| *Domains*)
    (make-instance '|FortranCodeType|)))

\end{chunk}

\subsection{FortranExpression}
\index[dom]{FortranExpression!Domain}
\index[dom]{Domain!FortranExpression}
\index[dom]{FEXPR}
\begin{chunk}{defclass FortranExpressionType}
(defclass |FortranExpressionType| (|AlgebraType|
                                   |ExpressionSpaceType|
                                   |PartialDifferentialRingType|)
  ((parents :initform '(|Algebra|
                        |ExpressionSpace|
                        |PartialDifferentialRing|))
   (name :initform "FortranExpression")
   (marker :initform 'domain)
   (abbreviation :initform 'FEXPR)
   (comment :initform (list
     "A domain of expressions involving functions which can be"
     "translated into standard Fortran-77, with some extra extensions from"
     "the NAG Fortran Library."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FortranExpression|
  (progn
    (push '|FortranExpression| *Domains*)
    (make-instance '|FortranExpressionType|)))

\end{chunk}

\subsection{FortranProgram}
\index[dom]{FortranProgram!Domain}
\index[dom]{Domain!FortranProgram}
\index[dom]{FORTRAN}
\begin{chunk}{defclass FortranProgramType}
(defclass |FortranProgramType| (|FortranProgramCategoryType|)
  ((parents :initform '(|FortranProgramCategory|))
   (name :initform "FortranProgram")
   (marker :initform 'domain)
   (abbreviation :initform 'FORTRAN)
   (comment :initform (list
     "FortranProgram allows the user to build and manipulate simple"
     "models of FORTRAN subprograms.  These can then be transformed into"
     "actual FORTRAN notation."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FortranProgram|
  (progn
    (push '|FortranProgram| *Domains*)
    (make-instance '|FortranProgramType|)))

\end{chunk}

\subsection{FortranScalarType}
\index[dom]{FortranScalarType!Domain}
\index[dom]{Domain!FortranScalarType}
\index[dom]{FST}
\begin{chunk}{defclass FortranScalarTypeType}
(defclass |FortranScalarTypeType| (|CoercibleToType|)
  ((parents :initform '(|CoercibleTo|))
   (name :initform "FortranScalarType")
   (marker :initform 'domain)
   (abbreviation :initform 'FST)
   (comment :initform (list
     "Creates and manipulates objects which correspond to the"
     "basic FORTRAN data types: REAL, INTEGER, COMPLEX, LOGICAL and CHARACTER"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FortranScalarType|
  (progn
    (push '|FortranScalarType| *Domains*)
    (make-instance '|FortranScalarTypeType|)))

\end{chunk}

\subsection{FortranTemplate}
\index[dom]{FortranTemplate!Domain}
\index[dom]{Domain!FortranTemplate}
\index[dom]{FTEM}
\begin{chunk}{defclass FortranTemplateType}
(defclass |FortranTemplateType| (|FileCategoryType|)
  ((parents :initform '(|FileCategory|))
   (name :initform "FortranTemplate")
   (marker :initform 'domain)
   (abbreviation :initform 'FTEM)
   (comment :initform (list
     "Code to manipulate Fortran templates"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FortranTemplate|
  (progn
    (push '|FortranTemplate| *Domains*)
    (make-instance '|FortranTemplateType|)))

\end{chunk}

\subsection{FortranType}
\index[dom]{FortranType!Domain}
\index[dom]{Domain!FortranType}
\index[dom]{FT}
\begin{chunk}{defclass FortranTypeType}
(defclass |FortranTypeType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "FortranType")
   (marker :initform 'domain)
   (abbreviation :initform 'FT)
   (comment :initform (list
     "Creates and manipulates objects which correspond to FORTRAN"
     "data types, including array dimensions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FortranType|
  (progn
    (push '|FortranType| *Domains*)
    (make-instance '|FortranTypeType|)))

\end{chunk}

\subsection{FourierComponent}
\index[dom]{FourierComponent!Domain}
\index[dom]{Domain!FourierComponent}
\index[dom]{FCOMP}
\begin{chunk}{defclass FourierComponentType}
(defclass |FourierComponentType| (|OrderedSetType|)
  ((parents :initform '(|OrderedSet|))
   (name :initform "FourierComponent")
   (marker :initform 'domain)
   (abbreviation :initform 'FCOMP)
   (comment :initform (list
     "This domain creates kernels for use in Fourier series"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FourierComponent|
  (progn
    (push '|FourierComponent| *Domains*)
    (make-instance '|FourierComponentType|)))

\end{chunk}

\subsection{FourierSeries}
\index[dom]{FourierSeries!Domain}
\index[dom]{Domain!FourierSeries}
\index[dom]{FSERIES}
\begin{chunk}{defclass FourierSeriesType}
(defclass |FourierSeriesType| (|AlgebraType|)
  ((parents :initform '(|Algebra|))
   (name :initform "FourierSeries")
   (marker :initform 'domain)
   (abbreviation :initform 'FSERIES)
   (comment :initform (list
     "This domain converts terms into Fourier series"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FourierSeries|
  (progn
    (push '|FourierSeries| *Domains*)
    (make-instance '|FourierSeriesType|)))

\end{chunk}

\subsection{Fraction}
\index[dom]{Fraction!Domain}
\index[dom]{Domain!Fraction}
\index[dom]{FRAC}
\begin{chunk}{defclass FractionType}
(defclass |FractionType| (|QuotientFieldCategoryType| |OpenMathType|)
  ((parents :initform '(|QuotientFieldCategory| |OpenMath|))
   (name :initform "Fraction")
   (marker :initform 'domain)
   (abbreviation :initform 'FRAC)
   (comment :initform (list
     "Fraction takes an IntegralDomain S and produces"
     "the domain of Fractions with numerators and denominators from S."
     "If S is also a GcdDomain, then gcd's between numerator and"
     "denominator will be cancelled during all operations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Fraction|
  (progn
    (push '|Fraction| *Domains*)
    (make-instance '|FractionType|)))

\end{chunk}

\subsection{FractionalIdeal}
\index[dom]{FractionalIdeal!Domain}
\index[dom]{Domain!FractionalIdeal}
\index[dom]{FRIDEAL}
\begin{chunk}{defclass FractionalIdealType}
(defclass |FractionalIdealType| (|GroupType|)
  ((parents :initform '(|Group|))
   (name :initform "FractionalIdeal")
   (marker :initform 'domain)
   (abbreviation :initform 'FRIDEAL)
   (comment :initform (list
     "Fractional ideals in a framed algebra."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FractionalIdeal|
  (progn
    (push '|FractionalIdeal| *Domains*)
    (make-instance '|FractionalIdealType|)))

\end{chunk}

\subsection{FramedModule}
\index[dom]{FramedModule!Domain}
\index[dom]{Domain!FramedModule}
\index[dom]{FRMOD}
\begin{chunk}{defclass FramedModuleType}
(defclass |FramedModuleType| (|MonoidType|)
  ((parents :initform '(|Monoid|))
   (name :initform "FramedModule")
   (marker :initform 'domain)
   (abbreviation :initform 'FRMOD)
   (comment :initform (list
     "Module representation of fractional ideals."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FramedModule|
  (progn
    (push '|FramedModule| *Domains*)
    (make-instance '|FramedModuleType|)))

\end{chunk}

\subsection{FreeAbelianGroup}
\index[dom]{FreeAbelianGroup!Domain}
\index[dom]{Domain!FreeAbelianGroup}
\index[dom]{FAGROUP}
\begin{chunk}{defclass FreeAbelianGroupType}
(defclass |FreeAbelianGroupType| (|OrderedSetType|
                                  |ModuleType|
                                  |FreeAbelianMonoidCategoryType|)
  ((parents :initform '(|OrderedSet| |Module| |FreeAbelianMonoidCategory|))
   (name :initform "FreeAbelianGroup")
   (marker :initform 'domain)
   (abbreviation :initform 'FAGROUP)
   (comment :initform (list
     "Free abelian group on any set of generators"
     "The free abelian group on a set S is the monoid of finite sums of"
     "the form reduce(+,[ni * si]) where the si's are in S, and the ni's"
     "are integers. The operation is commutative."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FreeAbelianGroup|
  (progn
    (push '|FreeAbelianGroup| *Domains*)
    (make-instance '|FreeAbelianGroupType|)))

\end{chunk}

\subsection{FreeAbelianMonoid}
\index[dom]{FreeAbelianMonoid!Domain}
\index[dom]{Domain!FreeAbelianMonoid}
\index[dom]{FAMONOID}
\begin{chunk}{defclass FreeAbelianMonoidType}
(defclass |FreeAbelianMonoidType| (|FreeAbelianMonoidCategoryType|)
  ((parents :initform '(|FreeAbelianMonoidCategory|))
   (name :initform "FreeAbelianMonoid")
   (marker :initform 'domain)
   (abbreviation :initform 'FAMONOID)
   (comment :initform (list
     "Free abelian monoid on any set of generators"
     "The free abelian monoid on a set S is the monoid of finite sums of"
     "the form reduce(+,[ni * si]) where the si's are in S, and the ni's"
     "are non-negative integers. The operation is commutative."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FreeAbelianMonoid|
  (progn
    (push '|FreeAbelianMonoid| *Domains*)
    (make-instance '|FreeAbelianMonoidType|)))

\end{chunk}

\subsection{FreeGroup}
\index[dom]{FreeGroup!Domain}
\index[dom]{Domain!FreeGroup}
\index[dom]{FGROUP}
\begin{chunk}{defclass FreeGroupType}
(defclass |FreeGroupType| (|GroupType| |RetractableToType|)
  ((parents :initform '(|Group| |RetractableTo|))
   (name :initform "FreeGroup")
   (marker :initform 'domain)
   (abbreviation :initform 'FGROUP)
   (comment :initform (list
     "Free group on any set of generators"
     "The free group on a set S is the group of finite products of"
     "the form reduce(*,[si ** ni]) where the si's are in S, and the ni's"
     "are integers. The multiplication is not commutative."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FreeGroup|
  (progn
    (push '|FreeGroup| *Domains*)
    (make-instance '|FreeGroupType|)))

\end{chunk}

\subsection{FreeModule}
\index[dom]{FreeModule!Domain}
\index[dom]{Domain!FreeModule}
\index[dom]{FM}
\begin{chunk}{defclass FreeModuleType}
(defclass |FreeModuleType| (|IndexedDirectProductCategoryType|
                            |ModuleType|)
  ((parents :initform '(|IndexedDirectProductCategory| |Module|))
   (name :initform "FreeModule")
   (marker :initform 'domain)
   (abbreviation :initform 'FM)
   (comment :initform (list
     "A bi-module is a free module"
     "over a ring with generators indexed by an ordered set."
     "Each element can be expressed as a finite linear combination of"
     "generators. Only non-zero terms are stored."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FreeModule|
  (progn
    (push '|FreeModule| *Domains*)
    (make-instance '|FreeModuleType|)))

\end{chunk}

\subsection{FreeModule1}
\index[dom]{FreeModule1!Domain}
\index[dom]{Domain!FreeModule1}
\index[dom]{FM1}
\begin{chunk}{defclass FreeModule1Type}
(defclass |FreeModule1Type| (|FreeModuleCatType|)
  ((parents :initform '(|FreeModuleCat|))
   (name :initform "FreeModule1")
   (marker :initform 'domain)
   (abbreviation :initform 'FM1)
   (comment :initform (list
     "This domain implements linear combinations"
     "of elements from the domain S with coefficients"
     "in the domain R where S is an ordered set"
     "and R is a ring (which may be non-commutative)."
     "This domain is used by domains of non-commutative algebra such as:"
     "XDistributedPolynomial, XRecursivePolynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FreeModule1|
  (progn
    (push '|FreeModule1| *Domains*)
    (make-instance '|FreeModule1Type|)))

\end{chunk}

\subsection{FreeMonoid}
\index[dom]{FreeMonoid!Domain}
\index[dom]{Domain!FreeMonoid}
\index[dom]{FMONOID}
\begin{chunk}{defclass FreeMonoidType}
(defclass |FreeMonoidType| (|MonoidType| |OrderedSetType| |RetractableToType|)
  ((parents :initform '(|Monoid| |OrderedSet| |RetractableTo|))
   (name :initform "FreeMonoid")
   (marker :initform 'domain)
   (abbreviation :initform 'FMONOID)
   (comment :initform (list
     "Free monoid on any set of generators"
     "The free monoid on a set S is the monoid of finite products of"
     "the form reduce(*,[si ** ni]) where the si's are in S, and the ni's"
     "are nonnegative integers. The multiplication is not commutative."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FreeMonoid|
  (progn
    (push '|FreeMonoid| *Domains*)
    (make-instance '|FreeMonoidType|)))

\end{chunk}

\subsection{FreeNilpotentLie}
\index[dom]{FreeNilpotentLie!Domain}
\index[dom]{Domain!FreeNilpotentLie}
\index[dom]{FNLA}
\begin{chunk}{defclass FreeNilpotentLieType}
(defclass |FreeNilpotentLieType| (|NonAssociativeAlgebraType|)
  ((parents :initform '(|NonAssociativeAlgebra|))
   (name :initform "FreeNilpotentLie")
   (marker :initform 'domain)
   (abbreviation :initform 'FNLA)
   (comment :initform (list
     "Generate the Free Lie Algebra over a ring R with identity;"
     "A P. Hall basis is generated by a package call to HallBasis."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FreeNilpotentLie|
  (progn
    (push '|FreeNilpotentLie| *Domains*)
    (make-instance '|FreeNilpotentLieType|)))

\end{chunk}

\subsection{FullPartialFractionExpansion}
\index[dom]{FullPartialFractionExpansion!Domain}
\index[dom]{Domain!FullPartialFractionExpansion}
\index[dom]{FPARFRAC}
\begin{chunk}{defclass FullPartialFractionExpansionType}
(defclass |FullPartialFractionExpansionType| (|SetCategoryType| |ConvertibleToType|)
  ((parents :initform '(|SetCategory| |ConvertibleTo|))
   (name :initform "FullPartialFractionExpansion")
   (marker :initform 'domain)
   (abbreviation :initform 'FPARFRAC)
   (comment :initform (list
     "Full partial fraction expansion of rational functions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FullPartialFractionExpansion|
  (progn
    (push '|FullPartialFractionExpansion| *Domains*)
    (make-instance '|FullPartialFractionExpansionType|)))

\end{chunk}

\subsection{FunctionCalled}
\index[dom]{FunctionCalled!Domain}
\index[dom]{Domain!FunctionCalled}
\index[dom]{FUNCTION}
\begin{chunk}{defclass FunctionCalledType}
(defclass |FunctionCalledType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "FunctionCalled")
   (marker :initform 'domain)
   (abbreviation :initform 'FUNCTION)
   (comment :initform (list
     "This domain implements named functions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionCalled|
  (progn
    (push '|FunctionCalled| *Domains*)
    (make-instance '|FunctionCalledType|)))

\end{chunk}

\section{G}

\subsection{GeneralDistributedMultivariatePolynomial}
\index[dom]{GeneralDistributedMultivariatePolynomial!Domain}
\index[dom]{Domain!GeneralDistributedMultivariatePolynomial}
\index[dom]{GDMP}
\begin{chunk}{defclass GeneralDistributedMultivariatePolynomialType}
(defclass |GeneralDistributedMultivariatePolynomialType| (|PolynomialCategoryType|)
  ((parents :initform '(|PolynomialCategory|))
   (name :initform "GeneralDistributedMultivariatePolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'GDMP)
   (comment :initform (list
     "This type supports distributed multivariate polynomials"
     "whose variables are from a user specified list of symbols."
     "The coefficient ring may be non commutative,"
     "but the variables are assumed to commute."
     "The term ordering is specified by its third parameter."
     "Suggested types which define term orderings include:"
     "DirectProduct, HomogeneousDirectProduct,"
     "SplitHomogeneousDirectProduct and finally"
     "OrderedDirectProduct which accepts an arbitrary user"
     "function to define a term ordering."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GeneralDistributedMultivariatePolynomial|
  (progn
    (push '|GeneralDistributedMultivariatePolynomial| *Domains*)
    (make-instance '|GeneralDistributedMultivariatePolynomialType|)))

\end{chunk}

\subsection{GeneralModulePolynomial}
\index[dom]{GeneralModulePolynomial!Domain}
\index[dom]{Domain!GeneralModulePolynomial}
\index[dom]{GMODPOL}
\begin{chunk}{defclass GeneralModulePolynomialType}
(defclass |GeneralModulePolynomialType| (|ModuleType|)
  ((parents :initform '(|Module|))
   (name :initform "GeneralModulePolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'GMODPOL)
   (comment :initform (list
     "This package is undocumented"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GeneralModulePolynomial|
  (progn
    (push '|GeneralModulePolynomial| *Domains*)
    (make-instance '|GeneralModulePolynomialType|)))

\end{chunk}

\subsection{GenericNonAssociativeAlgebra}
\index[dom]{GenericNonAssociativeAlgebra!Domain}
\index[dom]{Domain!GenericNonAssociativeAlgebra}
\index[dom]{GCNAALG}
\begin{chunk}{defclass GenericNonAssociativeAlgebraType}
(defclass |GenericNonAssociativeAlgebraType| (|FramedNonAssociativeAlgebraType|)
  ((parents :initform '(|FramedNonAssociativeAlgebra|))
   (name :initform "GenericNonAssociativeAlgebra")
   (marker :initform 'domain)
   (abbreviation :initform 'GCNAALG)
   (comment :initform (list
     "AlgebraGenericElementPackage allows you to create generic elements"
     "of an algebra, the scalars are extended to include symbolic"
     "coefficients"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GenericNonAssociativeAlgebra|
  (progn
    (push '|GenericNonAssociativeAlgebra| *Domains*)
    (make-instance '|GenericNonAssociativeAlgebraType|)))

\end{chunk}

\subsection{GeneralPolynomialSet}
\index[dom]{GeneralPolynomialSet!Domain}
\index[dom]{Domain!GeneralPolynomialSet}
\index[dom]{GPOLSET}
\begin{chunk}{defclass GeneralPolynomialSetType}
(defclass |GeneralPolynomialSetType| (|PolynomialSetCategoryType|)
  ((parents :initform '(|PolynomialSetCategory|))
   (name :initform "GeneralPolynomialSet")
   (marker :initform 'domain)
   (abbreviation :initform 'GPOLSET)
   (comment :initform (list
     "A domain for polynomial sets."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GeneralPolynomialSet|
  (progn
    (push '|GeneralPolynomialSet| *Domains*)
    (make-instance '|GeneralPolynomialSetType|)))

\end{chunk}

\subsection{GeneralSparseTable}
\index[dom]{GeneralSparseTable!Domain}
\index[dom]{Domain!GeneralSparseTable}
\index[dom]{GSTBL}
\begin{chunk}{defclass GeneralSparseTableType}
(defclass |GeneralSparseTableType| (|TableAggregateType|)
  ((parents :initform '(|TableAggregate|))
   (name :initform "GeneralSparseTable")
   (marker :initform 'domain)
   (abbreviation :initform 'GSTBL)
   (comment :initform (list
     "A sparse table has a default entry, which is returned if no other"
     "value has been explicitly stored for a key."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GeneralSparseTable|
  (progn
    (push '|GeneralSparseTable| *Domains*)
    (make-instance '|GeneralSparseTableType|)))

\end{chunk}

\subsection{GeneralTriangularSet}
\index[dom]{GeneralTriangularSet!Domain}
\index[dom]{Domain!GeneralTriangularSet}
\index[dom]{GTSET}
\begin{chunk}{defclass GeneralTriangularSetType}
(defclass |GeneralTriangularSetType| (|TriangularSetCategoryType|)
  ((parents :initform '(|TriangularSetCategory|))
   (name :initform "GeneralTriangularSet")
   (marker :initform 'domain)
   (abbreviation :initform 'GTSET)
   (comment :initform (list
     "A domain constructor of the category TriangularSetCategory."
     "The only requirement for a list of polynomials to be a member of such"
     "a domain is the following: no polynomial is constant and two distinct"
     "polynomials have distinct main variables. Such a triangular set may"
     "not be auto-reduced or consistent. Triangular sets are stored"
     "as sorted lists w.r.t. the main variables of their members but they"
     "are displayed in reverse order."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GeneralTriangularSet|
  (progn
    (push '|GeneralTriangularSet| *Domains*)
    (make-instance '|GeneralTriangularSetType|)))

\end{chunk}

\subsection{GeneralUnivariatePowerSeries}
\index[dom]{GeneralUnivariatePowerSeries!Domain}
\index[dom]{Domain!GeneralUnivariatePowerSeries}
\index[dom]{GSERIES}
\begin{chunk}{defclass GeneralUnivariatePowerSeriesType}
(defclass |GeneralUnivariatePowerSeriesType| (|UnivariatePuiseuxSeriesCategoryType|)
  ((parents :initform '(|UnivariatePuiseuxSeriesCategory|))
   (name :initform "GeneralUnivariatePowerSeries")
   (marker :initform 'domain)
   (abbreviation :initform 'GSERIES)
   (comment :initform (list
     "This is a category of univariate Puiseux series constructed"
     "from univariate Laurent series.  A Puiseux series is represented"
     "by a pair [r,f(x)], where r is a positive rational number and"
     "f(x) is a Laurent series.  This pair represents the Puiseux"
     "series f(x\^r)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GeneralUnivariatePowerSeries|
  (progn
    (push '|GeneralUnivariatePowerSeries| *Domains*)
    (make-instance '|GeneralUnivariatePowerSeriesType|)))

\end{chunk}

\subsection{GraphImage}
\index[dom]{GraphImage!Domain}
\index[dom]{Domain!GraphImage}
\index[dom]{GRIMAGE}
\begin{chunk}{defclass GraphImageType}
(defclass |GraphImageType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "GraphImage")
   (marker :initform 'domain)
   (abbreviation :initform 'GRIMAGE)
   (comment :initform (list
     "TwoDimensionalGraph creates virtual two dimensional graphs"
     "(to be displayed on TwoDimensionalViewports)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GraphImage|
  (progn
    (push '|GraphImage| *Domains*)
    (make-instance '|GraphImageType|)))

\end{chunk}

\subsection{GuessOption}
\index[dom]{GuessOption!Domain}
\index[dom]{Domain!GuessOption}
\index[dom]{GOPT}
\begin{chunk}{defclass GuessOptionType}
(defclass |GuessOptionType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "GuessOption")
   (marker :initform 'domain)
   (abbreviation :initform 'GOPT)
   (comment :initform (list
     "GuessOption is a domain whose elements are various options used"
     "by Guess."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GuessOption|
  (progn
    (push '|GuessOption| *Domains*)
    (make-instance '|GuessOptionType|)))

\end{chunk}

\subsection{GuessOptionFunctions0}
\index[dom]{GuessOptionFunctions0!Domain}
\index[dom]{Domain!GuessOptionFunctions0}
\index[dom]{GOPT0}
\begin{chunk}{defclass GuessOptionFunctions0Type}
(defclass |GuessOptionFunctions0Type| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "GuessOptionFunctions0")
   (marker :initform 'domain)
   (abbreviation :initform 'GOPT0)
   (comment :initform (list
     "GuessOptionFunctions0 provides operations that extract the"
     "values of options for Guess."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GuessOptionFunctions0|
  (progn
    (push '|GuessOptionFunctions0| *Domains*)
    (make-instance '|GuessOptionFunctions0Type|)))

\end{chunk}

\section{H}

\subsection{HashTable}
\index[dom]{HashTable!Domain}
\index[dom]{Domain!HashTable}
\index[dom]{HASHTBL}
\begin{chunk}{defclass HashTableType}
(defclass |HashTableType| (|TableAggregateType|)
  ((parents :initform '(|TableAggregate|))
   (name :initform "HashTable")
   (marker :initform 'domain)
   (abbreviation :initform 'HASHTBL)
   (comment :initform (list
     "This domain provides access to the underlying Lisp hash tables."
     "By varying the hashfn parameter, tables suited for different"
     "purposes can be obtained."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |HashTable|
   (progn
     (push '|HashTable| *Domains*)
     (make-instance '|HashTableType|)))

\end{chunk}

\subsection{Heap}
\index[dom]{Heap!Domain}
\index[dom]{Domain!Heap}
\index[dom]{HEAP}
\begin{chunk}{defclass HeapType}
(defclass |HeapType| (|PriorityQueueAggregateType|)
  ((parents :initform '(|PriorityQueueAggregate|))
   (name :initform "Heap")
   (marker :initform 'domain)
   (abbreviation :initform 'HEAP)
   (comment :initform (list
     "Heap implemented in a flexible array to allow for insertions"
     "Complexity: O(log n) insertion, extraction and O(n) construction"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Heap|
  (progn
    (push '|Heap| *Domains*)
    (make-instance '|HeapType|)))

\end{chunk}

\subsection{HexadecimalExpansion}
\index[dom]{HexadecimalExpansion!Domain}
\index[dom]{Domain!HexadecimalExpansion}
\index[dom]{HEXADEC}
\begin{chunk}{defclass HexadecimalExpansionType}
(defclass |HexadecimalExpansionType| (|QuotientFieldCategoryType|)
  ((parents :initform '(|QuotientFieldCategory|))
   (name :initform "HexadecimalExpansion")
   (marker :initform 'domain)
   (abbreviation :initform 'HEXADEC)
   (comment :initform (list
     "This domain allows rational numbers to be presented as repeating"
     "hexadecimal expansions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |HexadecimalExpansion|
  (progn
    (push '|HexadecimalExpansion| *Domains*)
    (make-instance '|HexadecimalExpansionType|)))

\end{chunk}

\subsection{HTMLFormat}
\index[dom]{HTMLFormat!Domain}
\index[dom]{Domain!HTMLFormat}
\index[dom]{HTMLFORM}
\begin{chunk}{defclass HTMLFormatType}
(defclass |HTMLFormatType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "HTMLFormat")
   (marker :initform 'domain)
   (abbreviation :initform 'HTMLFORM)
   (comment :initform (list
     "HtmlFormat provides a coercion from OutputForm to html."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |HTMLFormat|
  (progn
    (push '|HTMLFormat| *Domains*)
    (make-instance '|HTMLFormatType|)))

\end{chunk}

\subsection{HomogeneousDirectProduct}
\index[dom]{HomogeneousDirectProduct!Domain}
\index[dom]{Domain!HomogeneousDirectProduct}
\index[dom]{HDP}
\begin{chunk}{defclass HomogeneousDirectProductType}
(defclass |HomogeneousDirectProductType| (|DirectProductCategoryType|)
  ((parents :initform '(|DirectProductCategory|))
   (name :initform "HomogeneousDirectProduct")
   (marker :initform 'domain)
   (abbreviation :initform 'HDP)
   (comment :initform (list
     "This type represents the finite direct or cartesian product of an"
     "underlying ordered component type. The vectors are ordered first"
     "by the sum of their components, and then refined using a reverse"
     "lexicographic ordering. This type is a suitable third argument for"
     "GeneralDistributedMultivariatePolynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |HomogeneousDirectProduct|
  (progn
    (push '|HomogeneousDirectProduct| *Domains*)
    (make-instance '|HomogeneousDirectProductType|)))

\end{chunk}

\subsection{HomogeneousDistributedMultivariatePolynomial}
\index[dom]{HomogeneousDistributedMultivariatePolynomial!Domain}
\index[dom]{Domain!HomogeneousDistributedMultivariatePolynomial}
\index[dom]{HDMP}
\begin{chunk}{defclass HomogeneousDistributedMultivariatePolynomialType}
(defclass |HomogeneousDistributedMultivariatePolynomialType| (|PolynomialCategoryType|)
  ((parents :initform '(|PolynomialCategory|))
   (name :initform "HomogeneousDistributedMultivariatePolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'HDMP)
   (comment :initform (list
     "This type supports distributed multivariate polynomials"
     "whose variables are from a user specified list of symbols."
     "The coefficient ring may be non commutative,"
     "but the variables are assumed to commute."
     "The term ordering is total degree ordering refined by reverse"
     "lexicographic ordering with respect to the position that the variables"
     "appear in the list of variables parameter."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |HomogeneousDistributedMultivariatePolynomial|
  (progn
    (push '|HomogeneousDistributedMultivariatePolynomial| *Domains*)
    (make-instance '|HomogeneousDistributedMultivariatePolynomialType|)))

\end{chunk}

\subsection{HyperellipticFiniteDivisor}
\index[dom]{HyperellipticFiniteDivisor!Domain}
\index[dom]{Domain!HyperellipticFiniteDivisor}
\index[dom]{HELLFDIV}
\begin{chunk}{defclass HyperellipticFiniteDivisorType}
(defclass |HyperellipticFiniteDivisorType| (|FiniteDivisorCategoryType|)
  ((parents :initform '(|FiniteDivisorCategory|))
   (name :initform "HyperellipticFiniteDivisor")
   (marker :initform 'domain)
   (abbreviation :initform 'HELLFDIV)
   (comment :initform (list
     "This domains implements finite rational divisors on an hyperelliptic curve,"
     "that is finite formal sums SUM(n * P) where the n's are integers and the"
     "P's are finite rational points on the curve."
     "The equation of the curve must be  y^2 = f(x) and f must have odd degree."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |HyperellipticFiniteDivisor|
  (progn
    (push '|HyperellipticFiniteDivisor| *Domains*)
    (make-instance '|HyperellipticFiniteDivisorType|)))

\end{chunk}

\section{I}

\subsection{InfClsPt}
\index[dom]{InfClsPt!Domain}
\index[dom]{Domain!InfClsPt}
\index[dom]{ICP}
\begin{chunk}{defclass InfClsPtType}
(defclass |InfClsPtType| (|InfinitlyClosePointCategoryType|)
  ((parents :initform '(|InfinitlyClosePointCategory|))
   (name :initform "InfClsPt")
   (marker :initform 'domain)
   (abbreviation :initform 'ICP)
   (comment :initform (list
     "This domain is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InfClsPt|
  (progn
    (push '|InfClsPt| *Domains*)
    (make-instance '|InfClsPtType|)))

\end{chunk}

\subsection{IndexCard}
\index[dom]{IndexCard!Domain}
\index[dom]{Domain!IndexCard}
\index[dom]{ICARD}
\begin{chunk}{defclass IndexCardType}
(defclass |IndexCardType| (|OrderedSetType|)
  ((parents :initform '(|OrderedSet|))
   (name :initform "IndexCard")
   (marker :initform 'domain)
   (abbreviation :initform 'ICARD)
   (comment :initform (list
     "This domain implements a container of information about the AXIOM library"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexCard|
  (progn
    (push '|IndexCard| *Domains*)
    (make-instance '|IndexCardType|)))

\end{chunk}

\subsection{IndexedBits}
\index[dom]{IndexedBits!Domain}
\index[dom]{Domain!IndexedBits}
\index[dom]{IBITS}
\begin{chunk}{defclass IndexedBitsType}
(defclass |IndexedBitsType| (|BitAggregateType|)
  ((parents :initform '(|BitAggregate|))
   (name :initform "IndexedBits")
   (marker :initform 'domain)
   (abbreviation :initform 'IBITS)
   (comment :initform (list
     "IndexedBits is a domain to compactly represent"
     "large quantities of Boolean data."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexedBits|
  (progn
    (push '|IndexedBits| *Domains*)
    (make-instance '|IndexedBitsType|)))

\end{chunk}

\subsection{IndexedDirectProductAbelianGroup}
\index[dom]{IndexedDirectProductAbelianGroup!Domain}
\index[dom]{Domain!IndexedDirectProductAbelianGroup}
\index[dom]{IDPAG}
\begin{chunk}{defclass IndexedDirectProductAbelianGroupType}
(defclass |IndexedDirectProductAbelianGroupType| (|AbelianGroupType|
                                                  |IndexedDirectProductCategoryType|)
  ((parents :initform '(|AbelianGroup|
                        |IndexedDirectProductCategory|))
   (name :initform "IndexedDirectProductAbelianGroup")
   (marker :initform 'domain)
   (abbreviation :initform 'IDPAG)
   (comment :initform (list
     "Indexed direct products of abelian groups over an abelian group A of"
     "generators indexed by the ordered set S."
     "All items have finite support: only non-zero terms are stored."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexedDirectProductAbelianGroup|
  (progn
    (push '|IndexedDirectProductAbelianGroup| *Domains*)
    (make-instance '|IndexedDirectProductAbelianGroupType|)))

\end{chunk}

\subsection{IndexedDirectProductAbelianMonoid}
\index[dom]{IndexedDirectProductAbelianMonoid!Domain}
\index[dom]{Domain!IndexedDirectProductAbelianMonoid}
\index[dom]{IDPAM}
\begin{chunk}{defclass IndexedDirectProductAbelianMonoidType}
(defclass |IndexedDirectProductAbelianMonoidType| (|AbelianMonoidType|
                                                   |IndexedDirectProductCategoryType|)
  ((parents :initform '(|AbelianMonoid|
                        |IndexedDirectProductCategory|))
   (name :initform "IndexedDirectProductAbelianMonoid")
   (marker :initform 'domain)
   (abbreviation :initform 'IDPAM)
   (comment :initform (list
     "Indexed direct products of abelian monoids over an abelian monoid"
     "A of generators indexed by the ordered set S. All items have"
     "finite support. Only non-zero terms are stored."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexedDirectProductAbelianMonoid|
  (progn
    (push '|IndexedDirectProductAbelianMonoid| *Domains*)
    (make-instance '|IndexedDirectProductAbelianMonoidType|)))

\end{chunk}

\subsection{IndexedDirectProductObject}
\index[dom]{IndexedDirectProductObject!Domain}
\index[dom]{Domain!IndexedDirectProductObject}
\index[dom]{IDPO}
\begin{chunk}{defclass IndexedDirectProductObjectType}
(defclass |IndexedDirectProductObjectType| (|IndexedDirectProductCategoryType|)
  ((parents :initform '(|IndexedDirectProductCategory|))
   (name :initform "IndexedDirectProductObject")
   (marker :initform 'domain)
   (abbreviation :initform 'IDPO)
   (comment :initform (list
     "Indexed direct products of objects over a set A"
     "of generators indexed by an ordered set S. All items have finite support."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexedDirectProductObject|
  (progn
    (push '|IndexedDirectProductObject| *Domains*)
    (make-instance '|IndexedDirectProductObjectType|)))

\end{chunk}

\subsection{IndexedDirectProductOrderedAbelianMonoid}
\index[dom]{IndexedDirectProductOrderedAbelianMonoid!Domain}
\index[dom]{Domain!IndexedDirectProductOrderedAbelianMonoid}
\index[dom]{IDPOAM}
\begin{chunk}{defclass IndexedDirectProductOrderedAbelianMonoidType}
(defclass |IndexedDirectProductOrderedAbelianMonoidType| (|OrderedAbelianMonoidType|
                                                          |IndexedDirectProductCategoryType|)
  ((parents :initform '(|OrderedAbelianMonoid|
                        |IndexedDirectProductCategory|))
   (name :initform "IndexedDirectProductOrderedAbelianMonoid")
   (marker :initform 'domain)
   (abbreviation :initform 'IDPOAM)
   (comment :initform (list
     "Indexed direct products of ordered abelian monoids A of"
     "generators indexed by the ordered set S."
     "The inherited order is lexicographical."
     "All items have finite support: only non-zero terms are stored."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexedDirectProductOrderedAbelianMonoid|
  (progn
    (push '|IndexedDirectProductOrderedAbelianMonoid| *Domains*)
    (make-instance '|IndexedDirectProductOrderedAbelianMonoidType|)))

\end{chunk}

\subsection{IndexedDirectProductOrderedAbelianMonoidSup}
\index[dom]{IndexedDirectProductOrderedAbelianMonoidSup!Domain}
\index[dom]{Domain!IndexedDirectProductOrderedAbelianMonoidSup}
\index[dom]{IDPOAMS}
\begin{chunk}{defclass IndexedDirectProductOrderedAbelianMonoidSupType}
(defclass |IndexedDirectProductOrderedAbelianMonoidSupType| (|IndexedDirectProductCategoryType|
                                                             |OrderedAbelianMonoidSupType|)
  ((parents :initform '(|IndexedDirectProductCategory| |OrderedAbelianMonoidSup|))
   (name :initform "IndexedDirectProductOrderedAbelianMonoidSup")
   (marker :initform 'domain)
   (abbreviation :initform 'IDPOAMS)
   (comment :initform (list
     "Indexed direct products of ordered abelian monoid sups A,"
     "generators indexed by the ordered set S."
     "All items have finite support: only non-zero terms are stored."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexedDirectProductOrderedAbelianMonoidSup|
  (progn
    (push '|IndexedDirectProductOrderedAbelianMonoidSup| *Domains*)
    (make-instance '|IndexedDirectProductOrderedAbelianMonoidSupType|)))

\end{chunk}

\subsection{IndexedExponents}
\index[dom]{IndexedExponents!Domain}
\index[dom]{Domain!IndexedExponents}
\index[dom]{INDE}
\begin{chunk}{defclass IndexedExponentsType}
(defclass |IndexedExponentsType| (|IndexedDirectProductCategoryType|
                                  |OrderedAbelianMonoidSupType|)
  ((parents :initform '(|IndexedDirectProductCategory| |OrderedAbelianMonoidSup|))
   (name :initform "IndexedExponents")
   (marker :initform 'domain)
   (abbreviation :initform 'INDE)
   (comment :initform (list
     "IndexedExponents of an ordered set of variables gives a representation"
     "for the degree of polynomials in commuting variables. It gives an ordered"
     "pairing of non negative integer exponents with variables"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexedExponents|
  (progn
    (push '|IndexedExponents| *Domains*)
    (make-instance '|IndexedExponentsType|)))

\end{chunk}

\subsection{IndexedFlexibleArray}
\index[dom]{IndexedFlexibleArray!Domain}
\index[dom]{Domain!IndexedFlexibleArray}
\index[dom]{IFARRAY}
\begin{chunk}{defclass IndexedFlexibleArrayType}
(defclass |IndexedFlexibleArrayType| (|ExtensibleLinearAggregateType|
                                      |OneDimensionalArrayAggregateType|)
  ((parents :initform '(|ExtensibleLinearAggregate| |OneDimensionalArrayAggregate|))
   (name :initform "IndexedFlexibleArray")
   (marker :initform 'domain)
   (abbreviation :initform 'IFARRAY)
   (comment :initform (list
     "A FlexibleArray is the notion of an array intended to allow for growth"
     "at the end only.  Hence the following efficient operations"
     "append(x,a) meaning append item x at the end of the array a"
     "delete(a,n) meaning delete the last item from the array a"
     "Flexible arrays support the other operations inherited from"
     "ExtensibleLinearAggregate. However, these are not efficient."
     "Flexible arrays combine the O(1) access time property of arrays"
     "with growing and shrinking at the end in O(1) (average) time."
     "This is done by using an ordinary array which may have zero or more"
     "empty slots at the end.  When the array becomes full it is copied"
     "into a new larger (50% larger) array.  Conversely, when the array"
     "becomes less than 1/2 full, it is copied into a smaller array."
     "Flexible arrays provide for an efficient implementation of many"
     "data structures in particular heaps, stacks and sets."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexedFlexibleArray|
  (progn
    (push '|IndexedFlexibleArray| *Domains*)
    (make-instance '|IndexedFlexibleArrayType|)))

\end{chunk}

\subsection{IndexedList}
\index[dom]{IndexedList!Domain}
\index[dom]{Domain!IndexedList}
\index[dom]{ILIST}
\begin{chunk}{defclass IndexedListType}
(defclass |IndexedListType| (|ListAggregateType|)
  ((parents :initform '(|ListAggregate|))
   (name :initform "IndexedList")
   (marker :initform 'domain)
   (abbreviation :initform 'ILIST)
   (comment :initform (list
     "IndexedList is a basic implementation of the functions"
     "in ListAggregate, often using functions in the underlying"
     "LISP system. The second parameter to the constructor (mn)"
     "is the beginning index of the list. That is, if l is a"
     "list, then elt(l,mn) is the first value. This constructor"
     "is probably best viewed as the implementation of singly-linked"
     "lists that are addressable by index rather than as a mere wrapper"
     "for LISP lists."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexedList|
  (progn
    (push '|IndexedList| *Domains*)
    (make-instance '|IndexedListType|)))

\end{chunk}

\subsection{IndexedMatrix}
\index[dom]{IndexedMatrix!Domain}
\index[dom]{Domain!IndexedMatrix}
\index[dom]{IMATRIX}
\begin{chunk}{defclass IndexedMatrixType}
(defclass |IndexedMatrixType| (|MatrixCategoryType|)
  ((parents :initform '(|MatrixCategory|))
   (name :initform "IndexedMatrix")
   (marker :initform 'domain)
   (abbreviation :initform 'IMATRIX)
   (comment :initform (list
     "An IndexedMatrix is a matrix where the minimal row and column"
     "indices are parameters of the type.  The domains Row and Col"
     "are both IndexedVectors."
     "The index of the 'first' row may be obtained by calling the"
     "function minRowIndex.  The index of the 'first' column may"
     "be obtained by calling the function minColIndex.  The index of"
     "the first element of a 'Row' is the same as the index of the"
     "first column in a matrix and vice versa."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexedMatrix|
  (progn
    (push '|IndexedMatrix| *Domains*)
    (make-instance '|IndexedMatrixType|)))

\end{chunk}

\subsection{IndexedOneDimensionalArray}
\index[dom]{IndexedOneDimensionalArray!Domain}
\index[dom]{Domain!IndexedOneDimensionalArray}
\index[dom]{IARRAY1}
\begin{chunk}{defclass IndexedOneDimensionalArrayType}
(defclass |IndexedOneDimensionalArrayType| (|OneDimensionalArrayAggregateType|)
  ((parents :initform '(|OneDimensionalArrayAggregate|))
   (name :initform "IndexedOneDimensionalArray")
   (marker :initform 'domain)
   (abbreviation :initform 'IARRAY1)
   (comment :initform (list
     "This is the basic one dimensional array data type."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexedOneDimensionalArray|
  (progn
    (push '|IndexedOneDimensionalArray| *Domains*)
    (make-instance '|IndexedOneDimensionalArrayType|)))

\end{chunk}

\subsection{IndexedString}
\index[dom]{IndexedString!Domain}
\index[dom]{Domain!IndexedString}
\index[dom]{ISTRING}
\begin{chunk}{defclass IndexedStringType}
(defclass |IndexedStringType| (|StringAggregateType|)
  ((parents :initform '(|StringAggregate|))
   (name :initform "IndexedString")
   (marker :initform 'domain)
   (abbreviation :initform 'ISTRING)
   (comment :initform (list
     "This domain implements low-level strings"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexedString|
  (progn
    (push '|IndexedString| *Domains*)
    (make-instance '|IndexedStringType|)))

\end{chunk}

\subsection{IndexedTwoDimensionalArray}
\index[dom]{IndexedTwoDimensionalArray!Domain}
\index[dom]{Domain!IndexedTwoDimensionalArray}
\index[dom]{IARRAY2}
\begin{chunk}{defclass IndexedTwoDimensionalArrayType}
(defclass |IndexedTwoDimensionalArrayType| (|TwoDimensionalArrayCategoryType|)
  ((parents :initform '(|TwoDimensionalArrayCategory|))
   (name :initform "IndexedTwoDimensionalArray")
   (marker :initform 'domain)
   (abbreviation :initform 'IARRAY2)
   (comment :initform (list
     "This domain implements two dimensional arrays"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexedTwoDimensionalArray|
  (progn
    (push '|IndexedTwoDimensionalArray| *Domains*)
    (make-instance '|IndexedTwoDimensionalArrayType|)))

\end{chunk}

\subsection{IndexedVector}
\index[dom]{IndexedVector!Domain}
\index[dom]{Domain!IndexedVector}
\index[dom]{IVECTOR}
\begin{chunk}{defclass IndexedVectorType}
(defclass |IndexedVectorType| (|VectorCategoryType|)
  ((parents :initform '(|VectorCategory|))
   (name :initform "IndexedVector")
   (marker :initform 'domain)
   (abbreviation :initform 'IVECTOR)
   (comment :initform (list
     "This type represents vector like objects with varying lengths"
     "and a user-specified initial index."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexedVector|
  (progn
    (push '|IndexedVector| *Domains*)
    (make-instance '|IndexedVectorType|)))

\end{chunk}

\subsection{InfiniteTuple}
\index[dom]{InfiniteTuple!Domain}
\index[dom]{Domain!InfiniteTuple}
\index[dom]{ITUPLE}
\begin{chunk}{defclass InfiniteTupleType}
(defclass |InfiniteTupleType| (|CoercibleToType|)
  ((parents :initform '(|CoercibleTo|))
   (name :initform "InfiniteTuple")
   (marker :initform 'domain)
   (abbreviation :initform 'ITUPLE)
   (comment :initform (list
     "This package implements 'infinite tuples' for the interpreter."
     "The representation is a stream."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InfiniteTuple|
  (progn
    (push '|InfiniteTuple| *Domains*)
    (make-instance '|InfiniteTupleType|)))

\end{chunk}

\subsection{InfinitlyClosePoint}
\index[dom]{InfinitlyClosePoint!Domain}
\index[dom]{Domain!InfinitlyClosePoint}
\index[dom]{INFCLSPT}
\begin{chunk}{defclass InfinitlyClosePointType}
(defclass |InfinitlyClosePointType| (|InfinitlyClosePointCategoryType|)
  ((parents :initform '(|InfinitlyClosePointCategory|))
   (name :initform "InfinitlyClosePoint")
   (marker :initform 'domain)
   (abbreviation :initform 'INFCLSPT)
   (comment :initform (list
     "This domain is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InfinitlyClosePoint|
  (progn
    (push '|InfinitlyClosePoint| *Domains*)
    (make-instance '|InfinitlyClosePointType|)))

\end{chunk}

\subsection{InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteField}
\index[dom]{InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteField!Domain}
\index[dom]{Domain!InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteField}
\index[dom]{INFCLSPS}
\begin{chunk}{defclass InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteFieldType}
(defclass |InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteFieldType| (|InfinitlyClosePointCategoryType|)
  ((parents :initform '(|InfinitlyClosePointCategory|))
   (name :initform "InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteField")
   (marker :initform 'domain)
   (abbreviation :initform 'INFCLSPS)
   (comment :initform (list
     "This domain is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteField|
  (progn
    (push '|InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteField| *Domains*)
    (make-instance '|InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteFieldType|)))

\end{chunk}

\subsection{InnerAlgebraicNumber}
\index[dom]{InnerAlgebraicNumber!Domain}
\index[dom]{Domain!InnerAlgebraicNumber}
\index[dom]{IAN}
\begin{chunk}{defclass InnerAlgebraicNumberType}
(defclass |InnerAlgebraicNumberType| (|AlgebraicallyClosedFieldType|
                                      |CharacteristicZeroType|
                                      |DifferentialRingType|
                                      |ExpressionSpaceType|
                                      |LinearlyExplicitRingOverType|
                                      |RealConstantType|)
  ((parents :initform '(|AlgebraicallyClosedField|
                        |CharacteristicZero|
                        |DifferentialRing|
                        |ExpressionSpace|
                        |LinearlyExplicitRingOver|
                        |RealConstant|))
   (name :initform "InnerAlgebraicNumber")
   (marker :initform 'domain)
   (abbreviation :initform 'IAN)
   (comment :initform (list
     "Algebraic closure of the rational numbers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerAlgebraicNumber|
  (progn
    (push '|InnerAlgebraicNumber| *Domains*)
    (make-instance '|InnerAlgebraicNumberType|)))

\end{chunk}

\subsection{InnerFiniteField}
\index[dom]{InnerFiniteField!Domain}
\index[dom]{Domain!InnerFiniteField}
\index[dom]{IFF}
\begin{chunk}{defclass InnerFiniteFieldType}
(defclass |InnerFiniteFieldType| (|FiniteAlgebraicExtensionFieldType|)
  ((parents :initform '(|FiniteAlgebraicExtensionField|))
   (name :initform "InnerFiniteField")
   (marker :initform 'domain)
   (abbreviation :initform 'IFF)
   (comment :initform (list
     "InnerFiniteField(p,n) implements finite fields with p**n elements"
     "where p is assumed prime but does not check."
     "For a version which checks that p is prime, see FiniteField."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerFiniteField|
  (progn
    (push '|InnerFiniteField| *Domains*)
    (make-instance '|InnerFiniteFieldType|)))

\end{chunk}

\subsection{InnerFreeAbelianMonoid}
\index[dom]{InnerFreeAbelianMonoid!Domain}
\index[dom]{Domain!InnerFreeAbelianMonoid}
\index[dom]{IFAMON}
\begin{chunk}{defclass InnerFreeAbelianMonoidType}
(defclass |InnerFreeAbelianMonoidType| (|FreeAbelianMonoidCategoryType|)
  ((parents :initform '(|FreeAbelianMonoidCategory|))
   (name :initform "InnerFreeAbelianMonoid")
   (marker :initform 'domain)
   (abbreviation :initform 'IFAMON)
   (comment :initform (list
     "Internal implementation of a free abelian monoid on any set of generators"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerFreeAbelianMonoid|
  (progn
    (push '|InnerFreeAbelianMonoid| *Domains*)
    (make-instance '|InnerFreeAbelianMonoidType|)))

\end{chunk}

\subsection{InnerIndexedTwoDimensionalArray}
\index[dom]{InnerIndexedTwoDimensionalArray!Domain}
\index[dom]{Domain!InnerIndexedTwoDimensionalArray}
\index[dom]{IIARRAY2}
\begin{chunk}{defclass InnerIndexedTwoDimensionalArrayType}
(defclass |InnerIndexedTwoDimensionalArrayType| (|TwoDimensionalArrayCategoryType|)
  ((parents :initform '(|TwoDimensionalArrayCategory|))
   (name :initform "InnerIndexedTwoDimensionalArray")
   (marker :initform 'domain)
   (abbreviation :initform 'IIARRAY2)
   (comment :initform (list
     "There is no description for this domain"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerIndexedTwoDimensionalArray|
  (progn
    (push '|InnerIndexedTwoDimensionalArray| *Domains*)
    (make-instance '|InnerIndexedTwoDimensionalArrayType|)))

\end{chunk}

\subsection{InnerPAdicInteger}
\index[dom]{InnerPAdicInteger!Domain}
\index[dom]{Domain!InnerPAdicInteger}
\index[dom]{IPADIC}
\begin{chunk}{defclass InnerPAdicIntegerType}
(defclass |InnerPAdicIntegerType| (|PAdicIntegerCategoryType|)
  ((parents :initform '(|PAdicIntegerCategory|))
   (name :initform "InnerPAdicInteger")
   (marker :initform 'domain)
   (abbreviation :initform 'IPADIC)
   (comment :initform (list
     "This domain implements Zp, the p-adic completion of the integers."
     "This is an internal domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerPAdicInteger|
  (progn
    (push '|InnerPAdicInteger| *Domains*)
    (make-instance '|InnerPAdicIntegerType|)))

\end{chunk}

\subsection{InnerPrimeField}
\index[dom]{InnerPrimeField!Domain}
\index[dom]{Domain!InnerPrimeField}
\index[dom]{IPF}
\begin{chunk}{defclass InnerPrimeFieldType}
(defclass |InnerPrimeFieldType| (|ConvertibleToType|
                                 |FiniteAlgebraicExtensionFieldType|)
  ((parents :initform '(|ConvertibleTo| |FiniteAlgebraicExtensionField|))
   (name :initform "InnerPrimeField")
   (marker :initform 'domain)
   (abbreviation :initform 'IPF)
   (comment :initform (list
     "InnerPrimeField(p) implements the field with p elements."
     "Note: argument p MUST be a prime (this domain does not check)."
     "See PrimeField for a domain that does check."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerPrimeField|
  (progn
    (push '|InnerPrimeField| *Domains*)
    (make-instance '|InnerPrimeFieldType|)))

\end{chunk}

\subsection{InnerSparseUnivariatePowerSeries}
\index[dom]{InnerSparseUnivariatePowerSeries!Domain}
\index[dom]{Domain!InnerSparseUnivariatePowerSeries}
\index[dom]{ISUPS}
\begin{chunk}{defclass InnerSparseUnivariatePowerSeriesType}
(defclass |InnerSparseUnivariatePowerSeriesType| (|UnivariatePowerSeriesCategoryType|)
  ((parents :initform '(|UnivariatePowerSeriesCategory|))
   (name :initform "InnerSparseUnivariatePowerSeries")
   (marker :initform 'domain)
   (abbreviation :initform 'ISUPS)
   (comment :initform (list
     "InnerSparseUnivariatePowerSeries is an internal domain"
     "used for creating sparse Taylor and Laurent series."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerSparseUnivariatePowerSeries|
  (progn
    (push '|InnerSparseUnivariatePowerSeries| *Domains*)
    (make-instance '|InnerSparseUnivariatePowerSeriesType|)))

\end{chunk}

\subsection{InnerTable}
\index[dom]{InnerTable!Domain}
\index[dom]{Domain!InnerTable}
\index[dom]{INTABL}
\begin{chunk}{defclass InnerTableType}
(defclass |InnerTableType| (|TableAggregateType|)
  ((parents :initform '(|TableAggregate|))
   (name :initform "InnerTable")
   (marker :initform 'domain)
   (abbreviation :initform 'INTABL)
   (comment :initform (list
     "This domain is used to provide a conditional 'add' domain"
     "for the implementation of Table."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerTable|
  (progn
    (push '|InnerTable| *Domains*)
    (make-instance '|InnerTableType|)))

\end{chunk}

\subsection{InnerTaylorSeries}
\index[dom]{InnerTaylorSeries!Domain}
\index[dom]{Domain!InnerTaylorSeries}
\index[dom]{ITAYLOR}
\begin{chunk}{defclass InnerTaylorSeriesType}
(defclass |InnerTaylorSeriesType| (|IntegralDomainType|)
  ((parents :initform '(|IntegralDomain|))
   (name :initform "InnerTaylorSeries")
   (marker :initform 'domain)
   (abbreviation :initform 'ITAYLOR)
   (comment :initform (list
     "This is an internal Taylor series type in which Taylor series"
     "are represented by a Stream of Ring elements."
     "For univariate series, the Stream elements are the Taylor"
     "coefficients. For multivariate series, the nth Stream element"
     "is a form of degree n in the power series variables."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerTaylorSeries|
  (progn
    (push '|InnerTaylorSeries| *Domains*)
    (make-instance '|InnerTaylorSeriesType|)))

\end{chunk}

\subsection{InputForm}
\index[dom]{InputForm!Domain}
\index[dom]{Domain!InputForm}
\index[dom]{INFORM}
\begin{chunk}{defclass InputFormType}
(defclass |InputFormType| (|ConvertibleToType| |SExpressionCategoryType|)
  ((parents :initform '(|ConvertibleTo| |SExpressionCategory|))
   (name :initform "InputForm")
   (marker :initform 'domain)
   (abbreviation :initform 'INFORM)
   (comment :initform (list
     "Domain of parsed forms which can be passed to the interpreter."
     "This is also the interface between algebra code and facilities"
     "in the interpreter."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InputForm|
  (progn
    (push '|InputForm| *Domains*)
    (make-instance '|InputFormType|)))

\end{chunk}

\subsection{Integer}
\index[dom]{Integer!Domain}
\index[dom]{Domain!Integer}
\index[dom]{INT}
\begin{chunk}{defclass IntegerType}
(defclass |IntegerType| (|IntegerNumberSystemType| |OpenMathType|)
  ((parents :initform '(|IntegerNumberSystem| |OpenMath|))
   (name :initform "Integer")
   (marker :initform 'domain)
   (abbreviation :initform 'INT)
   (comment :initform (list
     "Integer provides the domain of arbitrary precision integers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Integer|
  (progn
    (push '|Integer| *Domains*)
    (make-instance '|IntegerType|)))

\end{chunk}

\subsection{IntegerMod}
\index[dom]{IntegerMod!Domain}
\index[dom]{Domain!IntegerMod}
\index[dom]{ZMOD}
\begin{chunk}{defclass IntegerModType}
(defclass |IntegerModType| (|StepThroughType|
                            |FiniteType|
                            |ConvertibleToType|
                            |CommutativeRingType|)
  ((parents :initform '(|StepThrough|
                        |Finite|
                        |ConvertibleTo|
                        |CommutativeRing|))
   (name :initform "IntegerMod")
   (marker :initform 'domain)
   (abbreviation :initform 'ZMOD)
   (comment :initform (list
     "IntegerMod(n) creates the ring of integers reduced modulo the integer n."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegerMod|
  (progn
    (push '|IntegerMod| *Domains*)
    (make-instance '|IntegerModType|)))

\end{chunk}

\subsection{IntegrationFunctionsTable}
\index[dom]{IntegrationFunctionsTable!Domain}
\index[dom]{Domain!IntegrationFunctionsTable}
\index[dom]{INTFTBL}
\begin{chunk}{defclass IntegrationFunctionsTableType}
(defclass |IntegrationFunctionsTableType| (|AxiomClass|)
  ((parents :initform '())
   (name :initform "IntegrationFunctionsTable")
   (marker :initform 'domain)
   (abbreviation :initform 'INTFTBL)
   (comment :initform (list
     "There is no description for this domain"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegrationFunctionsTable|
  (progn
    (push '|IntegrationFunctionsTable| *Domains*)
    (make-instance '|IntegrationFunctionsTableType|)))

\end{chunk}

\subsection{IntegrationResult}
\index[dom]{IntegrationResult!Domain}
\index[dom]{Domain!IntegrationResult}
\index[dom]{IR}
\begin{chunk}{defclass IntegrationResultType}
(defclass |IntegrationResultType| (|RetractableToType| |ModuleType|)
  ((parents :initform '(|RetractableTo| |Module|))
   (name :initform "IntegrationResult")
   (marker :initform 'domain)
   (abbreviation :initform 'IR)
   (comment :initform (list
     "The result of a transcendental integration."
     "If a function f has an elementary integral g, then g can be written"
     "in the form g = h + c1 log(u1) + c2 log(u2) + ... + cn log(un)"
     "where h, which is in the same field than f, is called the rational"
     "part of the integral, and c1 log(u1) + ... cn log(un) is called the"
     "logarithmic part of the integral. This domain manipulates integrals"
     "represented in that form, by keeping both parts separately. The logs"
     "are not explicitly computed."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegrationResult|
  (progn
    (push '|IntegrationResult| *Domains*)
    (make-instance '|IntegrationResultType|)))

\end{chunk}

\subsection{Interval}
\index[dom]{Interval!Domain}
\index[dom]{Domain!Interval}
\index[dom]{INTRVL}
\begin{chunk}{defclass IntervalType}
(defclass |IntervalType| (|IntervalCategoryType|)
  ((parents :initform '(|IntervalCategory|))
   (name :initform "Interval")
   (marker :initform 'domain)
   (abbreviation :initform 'INTRVL)
   (comment :initform (list
     "This domain is an implementation of interval arithmetic and transcendental"
     "functions over intervals."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Interval|
  (progn
    (push '|Interval| *Domains*)
    (make-instance '|IntervalType|)))

\end{chunk}

\section{K}

\subsection{Kernel}
\index[dom]{Kernel!Domain}
\index[dom]{Domain!Kernel}
\index[dom]{KERNEL}
\begin{chunk}{defclass KernelType}
(defclass |KernelType| (|CachableSetType| |PatternableType|)
  ((parents :initform '(|CachableSet| |Patternable|))
   (name :initform "Kernel")
   (marker :initform 'domain)
   (abbreviation :initform 'KERNEL)
   (comment :initform (list
     "A kernel over a set S is an operator applied to a given list"
     "of arguments from S."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Kernel|
  (progn
    (push '|Kernel| *Domains*)
    (make-instance '|KernelType|)))

\end{chunk}

\subsection{KeyedAccessFile}
\index[dom]{KeyedAccessFile!Domain}
\index[dom]{Domain!KeyedAccessFile}
\index[dom]{KAFILE}
\begin{chunk}{defclass KeyedAccessFileType}
(defclass |KeyedAccessFileType| (|TableAggregateType| |FileCategoryType|)
  ((parents :initform '(|TableAggregate| |FileCategory|))
   (name :initform "KeyedAccessFile")
   (marker :initform 'domain)
   (abbreviation :initform 'KAFILE)
   (comment :initform (list
     "This domain allows a random access file to be viewed both as a table"
     "and as a file object. The KeyedAccessFile format is a directory"
     "containing a single file called ``index.kaf''. This file is a random"
     "access file. The first thing in the file is an integer which is the"
     "byte offset of an association list (the dictionary) at the end of"
     "the file. The association list is of the form"
     "((key . byteoffset) (key . byteoffset)...)"
     "where the byte offset is the number of bytes from the beginning of"
     "the file. This offset contains an s-expression for the value of the key."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |KeyedAccessFile|
  (progn
    (push '|KeyedAccessFile| *Domains*)
    (make-instance '|KeyedAccessFileType|)))

\end{chunk}

\section{L}

\subsection{LaurentPolynomial}
\index[dom]{LaurentPolynomial!Domain}
\index[dom]{Domain!LaurentPolynomial}
\index[dom]{LAUPOL}
\begin{chunk}{defclass LaurentPolynomialType}
(defclass |LaurentPolynomialType| (|FullyRetractableToType|
                                   |EuclideanDomainType|
                                   |DifferentialExtensionType|
                                   |ConvertibleToType|
                                   |CharacteristicZeroType|
                                   |CharacteristicNonZeroType|)
  ((parents :initform '(|FullyRetractableTo|
                        |EuclideanDomain|
                        |DifferentialExtension|
                        |ConvertibleTo|
                        |CharacteristicZero|
                        |CharacteristicNonZero|))
   (name :initform "LaurentPolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'LAUPOL)
   (comment :initform (list
     "Univariate polynomials with negative and positive exponents."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LaurentPolynomial|
  (progn
    (push '|LaurentPolynomial| *Domains*)
    (make-instance '|LaurentPolynomialType|)))

\end{chunk}

\subsection{Library}
\index[dom]{Library!Domain}
\index[dom]{Domain!Library}
\index[dom]{LIB}
\begin{chunk}{defclass LibraryType}
(defclass |LibraryType| (|TableAggregateType|)
  ((parents :initform '(|TableAggregate|))
   (name :initform "Library")
   (marker :initform 'domain)
   (abbreviation :initform 'LIB)
   (comment :initform (list
     "This domain provides a simple way to save values in files."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Library|
  (progn
    (push '|Library| *Domains*)
    (make-instance '|LibraryType|)))

\end{chunk}

\subsection{LieExponentials}
\index[dom]{LieExponentials!Domain}
\index[dom]{Domain!LieExponentials}
\index[dom]{LEXP}
\begin{chunk}{defclass LieExponentialsType}
(defclass |LieExponentialsType| (|GroupType|)
  ((parents :initform '(|Group|))
   (name :initform "LieExponentials")
   (marker :initform 'domain)
   (abbreviation :initform 'LEXP)
   (comment :initform (list
     "Management of the Lie Group associated with a"
     "free nilpotent Lie algebra. Every Lie bracket with"
     "length greater than Order are assumed to be null."
     "The implementation inherits from the XPBWPolynomial"
     "domain constructor: Lyndon coordinates are exponential coordinates"
     "of the second kind. "))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LieExponentials|
  (progn
    (push '|LieExponentials| *Domains*)
    (make-instance '|LieExponentialsType|)))

\end{chunk}

\subsection{LiePolynomial}
\index[dom]{LiePolynomial!Domain}
\index[dom]{Domain!LiePolynomial}
\index[dom]{LPOLY}
\begin{chunk}{defclass LiePolynomialType}
(defclass |LiePolynomialType| (|FreeLieAlgebraType| |FreeModuleCatType|)
  ((parents :initform '(|FreeLieAlgebra| |FreeModuleCat|))
   (name :initform "LiePolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'LPOLY)
   (comment :initform (list
     "This type supports Lie polynomials in Lyndon basis"
     "see Free Lie Algebras by C. Reutenauer"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LiePolynomial|
  (progn
    (push '|LiePolynomial| *Domains*)
    (make-instance '|LiePolynomialType|)))

\end{chunk}

\subsection{LieSquareMatrix}
\index[dom]{LieSquareMatrix!Domain}
\index[dom]{Domain!LieSquareMatrix}
\index[dom]{LSQM}
\begin{chunk}{defclass LieSquareMatrixType}
(defclass |LieSquareMatrixType| (|FramedNonAssociativeAlgebraType|
                                 |SquareMatrixCategoryType|)
  ((parents :initform '(|FramedNonAssociativeAlgebra| |SquareMatrixCategory|))
   (name :initform "LieSquareMatrix")
   (marker :initform 'domain)
   (abbreviation :initform 'LSQM)
   (comment :initform (list
     "LieSquareMatrix(n,R) implements the Lie algebra of the n by n"
     "matrices over the commutative ring R."
     "The Lie bracket (commutator) of the algebra is given by"
     "a*b := (a *$SQMATRIX(n,R) b - b *$SQMATRIX(n,R) a),"
     "where *$SQMATRIX(n,R) is the usual matrix multiplication."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LieSquareMatrix|
  (progn
    (push '|LieSquareMatrix| *Domains*)
    (make-instance '|LieSquareMatrixType|)))

\end{chunk}

\subsection{LinearOrdinaryDifferentialOperator}
\index[dom]{LinearOrdinaryDifferentialOperator!Domain}
\index[dom]{Domain!LinearOrdinaryDifferentialOperator}
\index[dom]{LODO}
\begin{chunk}{defclass LinearOrdinaryDifferentialOperatorType}
(defclass |LinearOrdinaryDifferentialOperatorType| (|LinearOrdinaryDifferentialOperatorCategoryType|)
  ((parents :initform '(|LinearOrdinaryDifferentialOperatorCategory|))
   (name :initform "LinearOrdinaryDifferentialOperator")
   (marker :initform 'domain)
   (abbreviation :initform 'LODO)
   (comment :initform (list
     "LinearOrdinaryDifferentialOperator defines a ring of"
     "differential operators with coefficients in a ring A with a given"
     "derivation."
     "Multiplication of operators corresponds to functional composition:"
     "(L1 * L2).(f) = L1 L2 f"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LinearOrdinaryDifferentialOperator|
  (progn
    (push '|LinearOrdinaryDifferentialOperator| *Domains*)
    (make-instance '|LinearOrdinaryDifferentialOperatorType|)))

\end{chunk}

\subsection{LinearOrdinaryDifferentialOperator1}
\index[dom]{LinearOrdinaryDifferentialOperator1!Domain}
\index[dom]{Domain!LinearOrdinaryDifferentialOperator1}
\index[dom]{LODO1}
\begin{chunk}{defclass LinearOrdinaryDifferentialOperator1Type}
(defclass |LinearOrdinaryDifferentialOperator1Type| (|LinearOrdinaryDifferentialOperatorCategoryType|)
  ((parents :initform '(|LinearOrdinaryDifferentialOperatorCategory|))
   (name :initform "LinearOrdinaryDifferentialOperator1")
   (marker :initform 'domain)
   (abbreviation :initform 'LODO1)
   (comment :initform (list
     "LinearOrdinaryDifferentialOperator1 defines a ring of"
     "differential operators with coefficients in a differential ring A"
     "Multiplication of operators corresponds to functional composition:"
     "(L1 * L2).(f) = L1 L2 f"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LinearOrdinaryDifferentialOperator1|
  (progn
    (push '|LinearOrdinaryDifferentialOperator1| *Domains*)
    (make-instance '|LinearOrdinaryDifferentialOperator1Type|)))

\end{chunk}

\subsection{LinearOrdinaryDifferentialOperator2}
\index[dom]{LinearOrdinaryDifferentialOperator2!Domain}
\index[dom]{Domain!LinearOrdinaryDifferentialOperator2}
\index[dom]{LODO2}
\begin{chunk}{defclass LinearOrdinaryDifferentialOperator2Type}
(defclass |LinearOrdinaryDifferentialOperator2Type| (|LinearOrdinaryDifferentialOperatorCategoryType|)
  ((parents :initform '(|LinearOrdinaryDifferentialOperatorCategory|))
   (name :initform "LinearOrdinaryDifferentialOperator2")
   (marker :initform 'domain)
   (abbreviation :initform 'LODO2)
   (comment :initform (list
     "LinearOrdinaryDifferentialOperator2 defines a ring of"
     "differential operators with coefficients in a differential ring A"
     "and acting on an A-module M."
     "Multiplication of operators corresponds to functional composition:"
     "(L1 * L2).(f) = L1 L2 f"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LinearOrdinaryDifferentialOperator2|
  (progn
    (push '|LinearOrdinaryDifferentialOperator2| *Domains*)
    (make-instance '|LinearOrdinaryDifferentialOperator2Type|)))

\end{chunk}

\subsection{List}
\index[dom]{List!Domain}
\index[dom]{Domain!List}
\index[dom]{LIST}
\begin{chunk}{defclass ListType}
(defclass |ListType| (|OpenMathType| |ListAggregateType|)
  ((parents :initform '(|OpenMath| |ListAggregate|))
   (name :initform "List")
   (marker :initform 'domain)
   (abbreviation :initform 'LIST)
   (comment :initform (list
     "List implements singly-linked lists that are"
     "addressable by indices; the index of the first element"
     "is 1. In addition to the operations provided by"
     "IndexedList, this constructor provides some"
     "LISP-like functions such as null and cons."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |List|
  (progn
    (push '|List| *Domains*)
    (make-instance '|ListType|)))

\end{chunk}

\subsection{ListMonoidOps}
\index[dom]{ListMonoidOps!Domain}
\index[dom]{Domain!ListMonoidOps}
\index[dom]{LMOPS}
\begin{chunk}{defclass ListMonoidOpsType}
(defclass |ListMonoidOpsType| (|SetCategoryType| |RetractableToType|)
  ((parents :initform '(|SetCategory| |RetractableTo|))
   (name :initform "ListMonoidOps")
   (marker :initform 'domain)
   (abbreviation :initform 'LMOPS)
   (comment :initform (list
     "This internal package represents monoid (abelian or not, with or"
     "without inverses) as lists and provides some common operations"
     "to the various flavors of monoids."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ListMonoidOps|
  (progn
    (push '|ListMonoidOps| *Domains*)
    (make-instance '|ListMonoidOpsType|)))

\end{chunk}

\subsection{ListMultiDictionary}
\index[dom]{ListMultiDictionary!Domain}
\index[dom]{Domain!ListMultiDictionary}
\index[dom]{LMDICT}
\begin{chunk}{defclass ListMultiDictionaryType}
(defclass |ListMultiDictionaryType| (|MultiDictionaryType|)
  ((parents :initform '(|MultiDictionary|))
   (name :initform "ListMultiDictionary")
   (marker :initform 'domain)
   (abbreviation :initform 'LMDICT)
   (comment :initform (list
     "The ListMultiDictionary domain implements a"
     "dictionary with duplicates"
     "allowed.  The representation is a list with duplicates represented"
     "explicitly.  Hence most operations will be relatively inefficient"
     "when the number of entries in the dictionary becomes large."
     "If the objects in the dictionary belong to an ordered set,"
     "the entries are maintained in ascending order."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ListMultiDictionary|
  (progn
    (push '|ListMultiDictionary| *Domains*)
    (make-instance '|ListMultiDictionaryType|)))

\end{chunk}

\subsection{LocalAlgebra}
\index[dom]{LocalAlgebra!Domain}
\index[dom]{Domain!LocalAlgebra}
\index[dom]{LA}
\begin{chunk}{defclass LocalAlgebraType}
(defclass |LocalAlgebraType| (|AlgebraType| |OrderedRingType|)
  ((parents :initform '(|Algebra| |OrderedRing|))
   (name :initform "LocalAlgebra")
   (marker :initform 'domain)
   (abbreviation :initform 'LA)
   (comment :initform (list
     "LocalAlgebra produces the localization of an algebra,"
     "fractions whose numerators come from some R algebra."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LocalAlgebra|
  (progn
    (push '|LocalAlgebra| *Domains*)
    (make-instance '|LocalAlgebraType|)))

\end{chunk}

\subsection{Localize}
\index[dom]{Localize!Domain}
\index[dom]{Domain!Localize}
\index[dom]{LO}
\begin{chunk}{defclass LocalizeType}
(defclass |LocalizeType| (|ModuleType| |OrderedAbelianGroupType|)
  ((parents :initform '(|Module| |OrderedAbelianGroup|))
   (name :initform "Localize")
   (marker :initform 'domain)
   (abbreviation :initform 'LO)
   (comment :initform (list
     "Localize(M,R,S) produces fractions with numerators"
     "from an R module M and denominators from some multiplicative subset D of R."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Localize|
  (progn
    (push '|Localize| *Domains*)
    (make-instance '|LocalizeType|)))

\end{chunk}

\subsection{LyndonWord}
\index[dom]{LyndonWord!Domain}
\index[dom]{Domain!LyndonWord}
\index[dom]{LWORD}
\begin{chunk}{defclass LyndonWordType}
(defclass |LyndonWordType| (|OrderedSetType| |RetractableToType|)
  ((parents :initform '(|OrderedSet| |RetractableTo|))
   (name :initform "LyndonWord")
   (marker :initform 'domain)
   (abbreviation :initform 'LWORD)
   (comment :initform (list
     "Lyndon words over arbitrary (ordered) symbols:"
     "see Free Lie Algebras by C. Reutenauer (Oxford science publications)."
     "A Lyndon word is a word which is smaller than any of its right factors"
     "w.r.t. the pure lexicographical ordering."
     "If a and b are two Lyndon words such that a < b"
     "holds w.r.t lexicographical ordering then a*b is a Lyndon word."
     "Parenthesized Lyndon words can be generated from symbols by using the"
     "following rule:"
     "[[a,b],c] is a Lyndon word iff a*b < c <= b holds."
     "Lyndon words are internally represented by binary trees using the"
     "Magma domain constructor."
     "Two ordering are provided: lexicographic and"
     "length-lexicographic. "))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LyndonWord|
  (progn
    (push '|LyndonWord| *Domains*)
    (make-instance '|LyndonWordType|)))

\end{chunk}

\section{M}

%TPDHERE class precedence error
\subsection{MachineComplex}
\index[dom]{MachineComplex!Domain}
\index[dom]{Domain!MachineComplex}
\index[dom]{MCMPLX}
\begin{chunk}{insane}
(defclass |MachineComplexType| (|ComplexCategoryType| |FortranMachineTypeCategoryType|)
  ((parents :initform '(|ComplexCategory| |FortranMachineTypeCategory|))
   (name :initform "MachineComplex")
   (marker :initform 'domain)
   (abbreviation :initform 'MCMPLX)
   (comment :initform (list
     "A domain which models the complex number representation"
     "used by machines in the AXIOM-NAG link."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MachineComplex|
  (progn
    (push '|MachineComplex| *Domains*)
    (make-instance '|MachineComplexType|)))

\end{chunk}

%TPDHERE class precedence error
\subsection{MachineFloat}
\index[dom]{MachineFloat!Domain}
\index[dom]{Domain!MachineFloat}
\index[dom]{MFLOAT}
\begin{chunk}{insane}
(defclass |MachineFloatType| (|FloatingPointSystemType| |FortranMachineTypeCategoryType|)
  ((parents :initform '(|FloatingPointSystem| |FortranMachineTypeCategory|))
   (name :initform "MachineFloat")
   (marker :initform 'domain)
   (abbreviation :initform 'MFLOAT)
   (comment :initform (list
     "A domain which models the floating point representation"
     " used by machines in the AXIOM-NAG link."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MachineFloat|
  (progn
    (push '|MachineFloat| *Domains*)
    (make-instance '|MachineFloatType|)))

\end{chunk}

%TPDHERE class precedence failure
\subsection{MachineInteger}
\index[dom]{MachineInteger!Domain}
\index[dom]{Domain!MachineInteger}
\index[dom]{MINT}
\begin{chunk}{defclass MachineIntegerType}
(defclass |MachineIntegerType| (|IntegerNumberSystemType|); |FortranMachineTypeCategoryType|)
  ((parents :initform '(|IntegerNumberSystem| |FortranMachineTypeCategory|))
   (name :initform "MachineInteger")
   (marker :initform 'domain)
   (abbreviation :initform 'MINT)
   (comment :initform (list
     "A domain which models the integer representation"
     " used by machines in the AXIOM-NAG link."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MachineInteger|
  (progn
    (push '|MachineInteger| *Domains*)
    (make-instance '|MachineIntegerType|)))

\end{chunk}

\subsection{Magma}
\index[dom]{Magma!Domain}
\index[dom]{Domain!Magma}
\index[dom]{MAGMA}
\begin{chunk}{defclass MagmaType}
(defclass |MagmaType| (|OrderedSetType| |RetractableToType|)
  ((parents :initform '(|OrderedSet| |RetractableTo|))
   (name :initform "Magma")
   (marker :initform 'domain)
   (abbreviation :initform 'MAGMA)
   (comment :initform (list
     "This type is the basic representation of"
     "parenthesized words (binary trees over arbitrary symbols)"
     "useful in LiePolynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Magma|
  (progn
    (push '|Magma| *Domains*)
    (make-instance '|MagmaType|)))

\end{chunk}

\subsection{MakeCachableSet}
\index[dom]{MakeCachableSet!Domain}
\index[dom]{Domain!MakeCachableSet}
\index[dom]{MKCHSET}
\begin{chunk}{defclass MakeCachableSetType}
(defclass |MakeCachableSetType| (|CachableSetType|)
  ((parents :initform '(|CachableSet|))
   (name :initform "MakeCachableSet")
   (marker :initform 'domain)
   (abbreviation :initform 'MKCHSET)
   (comment :initform (list
     "MakeCachableSet(S) returns a cachable set which is equal to S as a set."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MakeCachableSet|
  (progn
    (push '|MakeCachableSet| *Domains*)
    (make-instance '|MakeCachableSetType|)))

\end{chunk}

\subsection{MathMLFormat}
\index[dom]{MathMLFormat!Domain}
\index[dom]{Domain!MathMLFormat}
\index[dom]{MMLFORM}
\begin{chunk}{defclass MathMLFormatType}
(defclass |MathMLFormatType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "MathMLFormat")
   (marker :initform 'domain)
   (abbreviation :initform 'MMLFORM)
   (comment :initform (list
     "This package is based on the TeXFormat domain by Robert S. Sutor"
     "MathMLFormat provides a coercion from OutputForm"
     "to MathML format."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MathMLFormat|
  (progn
    (push '|MathMLFormat| *Domains*)
    (make-instance '|MathMLFormatType|)))

\end{chunk}

\subsection{Matrix}
\index[dom]{Matrix!Domain}
\index[dom]{Domain!Matrix}
\index[dom]{MATRIX}
\begin{chunk}{defclass MatrixType}
(defclass |MatrixType| (|ConvertibleToType| |MatrixCategoryType|)
  ((parents :initform '(|ConvertibleTo| |MatrixCategory|))
   (name :initform "Matrix")
   (marker :initform 'domain)
   (abbreviation :initform 'MATRIX)
   (comment :initform (list
     "Matrix is a matrix domain where 1-based indexing is used"
     "for both rows and columns."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Matrix|
  (progn
    (push '|Matrix| *Domains*)
    (make-instance '|MatrixType|)))

\end{chunk}

\subsection{ModMonic}
\index[dom]{ModMonic!Domain}
\index[dom]{Domain!ModMonic}
\index[dom]{MODMON}
\begin{chunk}{defclass ModMonicType}
(defclass |ModMonicType| (|UnivariatePolynomialCategoryType| |FiniteType|)
  ((parents :initform '(|UnivariatePolynomialCategory| |Finite|))
   (name :initform "ModMonic")
   (marker :initform 'domain)
   (abbreviation :initform 'MODMON)
   (comment :initform (list
     "This package has not been documented"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ModMonic|
  (progn
    (push '|ModMonic| *Domains*)
    (make-instance '|ModMonicType|)))

\end{chunk}

\subsection{ModularField}
\index[dom]{ModularField!Domain}
\index[dom]{Domain!ModularField}
\index[dom]{MODFIELD}
\begin{chunk}{defclass ModularFieldType}
(defclass |ModularFieldType| (|FieldType|)
  ((parents :initform '(|Field|))
   (name :initform "ModularField")
   (marker :initform 'domain)
   (abbreviation :initform 'MODFIELD)
   (comment :initform (list
     "These domains are used for the factorization and gcds"
     "of univariate polynomials over the integers in order to work modulo"
     "different  primes."
     "See ModularRing, EuclideanModularRing"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ModularField|
  (progn
    (push '|ModularField| *Domains*)
    (make-instance '|ModularFieldType|)))

\end{chunk}

\subsection{ModularRing}
\index[dom]{ModularRing!Domain}
\index[dom]{Domain!ModularRing}
\index[dom]{MODRING}
\begin{chunk}{defclass ModularRingType}
(defclass |ModularRingType| (|RingType|)
  ((parents :initform '(|Ring|))
   (name :initform "ModularRing")
   (marker :initform 'domain)
   (abbreviation :initform 'MODRING)
   (comment :initform (list
     "These domains are used for the factorization and gcds"
     "of univariate polynomials over the integers in order to work modulo"
     "different  primes."
     "See EuclideanModularRing ,ModularField"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ModularRing|
  (progn
    (push '|ModularRing| *Domains*)
    (make-instance '|ModularRingType|)))

\end{chunk}

\subsection{ModuleMonomial}
\index[dom]{ModuleMonomial!Domain}
\index[dom]{Domain!ModuleMonomial}
\index[dom]{MODMONOM}
\begin{chunk}{defclass ModuleMonomialType}
(defclass |ModuleMonomialType| (|OrderedSetType|)
  ((parents :initform '(|OrderedSet|))
   (name :initform "ModuleMonomial")
   (marker :initform 'domain)
   (abbreviation :initform 'MODMONOM)
   (comment :initform (list
     "This package has no documentation"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ModuleMonomial|
  (progn
    (push '|ModuleMonomial| *Domains*)
    (make-instance '|ModuleMonomialType|)))

\end{chunk}

\subsection{ModuleOperator}
\index[dom]{ModuleOperator!Domain}
\index[dom]{Domain!ModuleOperator}
\index[dom]{MODOP}
\begin{chunk}{defclass ModuleOperatorType}
(defclass |ModuleOperatorType| (|AlgebraType|
                                |CharacteristicNonZeroType|
                                |CharacteristicZeroType|
                                |EltableType|
                                |RetractableToType|)
  ((parents :initform '(|Algebra|
                        |CharacteristicNonZero|
                        |CharacteristicZero|
                        |Eltable|
                        |RetractableTo|))
   (name :initform "ModuleOperator")
   (marker :initform 'domain)
   (abbreviation :initform 'MODOP)
   (comment :initform (list
     "Algebra of ADDITIVE operators on a module."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ModuleOperator|
  (progn
    (push '|ModuleOperator| *Domains*)
    (make-instance '|ModuleOperatorType|)))

\end{chunk}

\subsection{MoebiusTransform}
\index[dom]{MoebiusTransform!Domain}
\index[dom]{Domain!MoebiusTransform}
\index[dom]{MOEBIUS}
\begin{chunk}{defclass MoebiusTransformType}
(defclass |MoebiusTransformType| (|GroupType|)
  ((parents :initform '(|Group|))
   (name :initform "MoebiusTransform")
   (marker :initform 'domain)
   (abbreviation :initform 'MOEBIUS)
   (comment :initform (list
     "MoebiusTransform(F) is the domain of fractional linear (Moebius)"
     "transformations over F. This a domain of 2-by-2 matrices acting on P1(F)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MoebiusTransform|
  (progn
    (push '|MoebiusTransform| *Domains*)
    (make-instance '|MoebiusTransformType|)))

\end{chunk}

\subsection{MonoidRing}
\index[dom]{MonoidRing!Domain}
\index[dom]{Domain!MonoidRing}
\index[dom]{MRING}
\begin{chunk}{defclass MonoidRingType}
(defclass |MonoidRingType| (|RetractableToType|
                            |FiniteType|
                            |CharacteristicZeroType|
                            |CharacteristicNonZeroType|
                            |AlgebraType|)
  ((parents :initform '(|RetractableTo|
                        |Finite|
                        |CharacteristicZero|
                        |CharacteristicNonZero|
                        |Algebra|))
   (name :initform "MonoidRing")
   (marker :initform 'domain)
   (abbreviation :initform 'MRING)
   (comment :initform (list
     "MonoidRing(R,M), implements the algebra"
     "of all maps from the monoid M to the commutative ring R with"
     "finite support."
     "Multiplication of two maps f and g is defined"
     "to map an element c of M to the (convolution) sum over f(a)g(b)"
     "such that ab = c. Thus M can be identified with a canonical"
     "basis and the maps can also be considered as formal linear combinations"
     "of the elements in M. Scalar multiples of a basis element are called"
     "monomials. A prominent example is the class of polynomials"
     "where the monoid is a direct product of the natural numbers"
     "with pointwise addition. When M is"
     "FreeMonoid Symbol, one gets polynomials"
     "in infinitely many non-commuting variables. Another application"
     "area is representation theory of finite groups G, where modules"
     "over MonoidRing(R,G) are studied."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MonoidRing|
  (progn
    (push '|MonoidRing| *Domains*)
    (make-instance '|MonoidRingType|)))

\end{chunk}

\subsection{Multiset}
\index[dom]{Multiset!Domain}
\index[dom]{Domain!Multiset}
\index[dom]{MSET}
\begin{chunk}{defclass MultisetType}
(defclass |MultisetType| (|MultisetAggregateType|)
  ((parents :initform '(|MultisetAggregate|))
   (name :initform "Multiset")
   (marker :initform 'domain)
   (abbreviation :initform 'MSET)
   (comment :initform (list
     "A multiset is a set with multiplicities."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Multiset|
  (progn
    (push '|Multiset| *Domains*)
    (make-instance '|MultisetType|)))

\end{chunk}

\subsection{MultivariatePolynomial}
\index[dom]{MultivariatePolynomial!Domain}
\index[dom]{Domain!MultivariatePolynomial}
\index[dom]{MPOLY}
\begin{chunk}{defclass MultivariatePolynomialType}
(defclass |MultivariatePolynomialType| (|PolynomialCategoryType|)
  ((parents :initform '(|PolynomialCategory|))
   (name :initform "MultivariatePolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'MPOLY)
   (comment :initform (list
     "This type is the basic representation of sparse recursive multivariate"
     "polynomials whose variables are from a user specified list of symbols."
     "The ordering is specified by the position of the variable in the list."
     "The coefficient ring may be non commutative,"
     "but the variables are assumed to commute."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MultivariatePolynomial|
  (progn
    (push '|MultivariatePolynomial| *Domains*)
    (make-instance '|MultivariatePolynomialType|)))

\end{chunk}

\subsection{MyExpression}
\index[dom]{MyExpression!Domain}
\index[dom]{Domain!MyExpression}
\index[dom]{MYEXPR}
\begin{chunk}{defclass MyExpressionType}
(defclass |MyExpressionType| (|FunctionSpaceType| |CombinatorialOpsCategoryType|)
  ((parents :initform '(|FunctionSpace| |CombinatorialOpsCategory|))
   (name :initform "MyExpression")
   (marker :initform 'domain)
   (abbreviation :initform 'MYEXPR)
   (comment :initform (list
     "This domain has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MyExpression|
  (progn
    (push '|MyExpression| *Domains*)
    (make-instance '|MyExpressionType|)))

\end{chunk}

\subsection{MyUnivariatePolynomial}
\index[dom]{MyUnivariatePolynomial!Domain}
\index[dom]{Domain!MyUnivariatePolynomial}
\index[dom]{MYUP}
\begin{chunk}{defclass MyUnivariatePolynomialType}
(defclass |MyUnivariatePolynomialType| (|UnivariatePolynomialCategoryType|)
  ((parents :initform '(|UnivariatePolynomialCategory|))
   (name :initform "MyUnivariatePolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'MYUP)
   (comment :initform (list
     "This domain has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MyUnivariatePolynomial|
  (progn
    (push '|MyUnivariatePolynomial| *Domains*)
    (make-instance '|MyUnivariatePolynomialType|)))

\end{chunk}

\section{N}

\subsection{NeitherSparseOrDensePowerSeries}
\index[dom]{NeitherSparseOrDensePowerSeries!Domain}
\index[dom]{Domain!NeitherSparseOrDensePowerSeries}
\index[dom]{NSDPS}
\begin{chunk}{defclass NeitherSparseOrDensePowerSeriesType}
(defclass |NeitherSparseOrDensePowerSeriesType| (|LocalPowerSeriesCategoryType|
                                                 |LazyStreamAggregateType|)
  ((parents :initform '(|LocalPowerSeriesCategory| |LazyStreamAggregate|))
   (name :initform "NeitherSparseOrDensePowerSeries")
   (marker :initform 'domain)
   (abbreviation :initform 'NSDPS)
   (comment :initform (list
     "This domain is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NeitherSparseOrDensePowerSeries|
  (progn
    (push '|NeitherSparseOrDensePowerSeries| *Domains*)
    (make-instance '|NeitherSparseOrDensePowerSeriesType|)))

\end{chunk}

\subsection{NewSparseMultivariatePolynomial}
\index[dom]{NewSparseMultivariatePolynomial!Domain}
\index[dom]{Domain!NewSparseMultivariatePolynomial}
\index[dom]{NSMP}
\begin{chunk}{defclass NewSparseMultivariatePolynomialType}
(defclass |NewSparseMultivariatePolynomialType| (|RecursivePolynomialCategoryType|)
  ((parents :initform '(|RecursivePolynomialCategory|))
   (name :initform "NewSparseMultivariatePolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'NSMP)
   (comment :initform (list
     "A post-facto extension for SMP in order"
     "to speed up operations related to pseudo-division and gcd."
     "This domain is based on the NSUP constructor which is"
     "itself a post-facto extension of the SUP constructor."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NewSparseMultivariatePolynomial|
  (progn
    (push '|NewSparseMultivariatePolynomial| *Domains*)
    (make-instance '|NewSparseMultivariatePolynomialType|)))

\end{chunk}

\subsection{NewSparseUnivariatePolynomial}
\index[dom]{NewSparseUnivariatePolynomial!Domain}
\index[dom]{Domain!NewSparseUnivariatePolynomial}
\index[dom]{NSUP}
\begin{chunk}{defclass NewSparseUnivariatePolynomialType}
(defclass |NewSparseUnivariatePolynomialType| (|UnivariatePolynomialCategoryType|)
  ((parents :initform '(|UnivariatePolynomialCategory|))
   (name :initform "NewSparseUnivariatePolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'NSUP)
   (comment :initform (list
     "A post-facto extension for SUP in order"
     "to speed up operations related to pseudo-division and gcd for"
     "both SUP and, consequently, NSMP."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NewSparseUnivariatePolynomial|
  (progn
    (push '|NewSparseUnivariatePolynomial| *Domains*)
    (make-instance '|NewSparseUnivariatePolynomialType|)))

\end{chunk}

\subsection{None}
\index[dom]{None!Domain}
\index[dom]{Domain!None}
\index[dom]{NONE}
\begin{chunk}{defclass NoneType}
(defclass |NoneType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "None")
   (marker :initform 'domain)
   (abbreviation :initform 'NONE)
   (comment :initform (list
     "None implements a type with no objects. It is mainly"
     "used in technical situations where such a thing is needed (for example,"
     "the interpreter and some of the internal Expression code)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |None|
  (progn
    (push '|None| *Domains*)
    (make-instance '|NoneType|)))

\end{chunk}

\subsection{NonNegativeInteger}
\index[dom]{NonNegativeInteger!Domain}
\index[dom]{Domain!NonNegativeInteger}
\index[dom]{NNI}
\begin{chunk}{defclass NonNegativeIntegerType}
(defclass |NonNegativeIntegerType| (|OrderedAbelianMonoidSupType| |MonoidType|)
  ((parents :initform '(|OrderedAbelianMonoidSup| |Monoid|))
   (name :initform "NonNegativeInteger")
   (marker :initform 'domain)
   (abbreviation :initform 'NNI)
   (comment :initform (list
     "NonNegativeInteger provides functions for non negative integers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NonNegativeInteger|
  (progn
    (push '|NonNegativeInteger| *Domains*)
    (make-instance '|NonNegativeIntegerType|)))

\end{chunk}

\subsection{NottinghamGroup}
\index[dom]{NottinghamGroup!Domain}
\index[dom]{Domain!NottinghamGroup}
\index[dom]{NOTTING}
\begin{chunk}{defclass NottinghamGroupType}
(defclass |NottinghamGroupType| (|GroupType|)
  ((parents :initform '(|Group|))
   (name :initform "NottinghamGroup")
   (marker :initform 'domain)
   (abbreviation :initform 'NOTTING)
   (comment :initform (list
     "This is an implmenentation of the Nottingham Group"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NottinghamGroup|
  (progn
    (push '|NottinghamGroup| *Domains*)
    (make-instance '|NottinghamGroupType|)))

\end{chunk}

\subsection{NumericalIntegrationProblem}
\index[dom]{NumericalIntegrationProblem!Domain}
\index[dom]{Domain!NumericalIntegrationProblem}
\index[dom]{NIPROB}
\begin{chunk}{defclass NumericalIntegrationProblemType}
(defclass |NumericalIntegrationProblemType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "NumericalIntegrationProblem")
   (marker :initform 'domain)
   (abbreviation :initform 'NIPROB)
   (comment :initform (list
     "NumericalIntegrationProblem is a domain"
     "for the representation of Numerical Integration problems for use"
     "by ANNA."
     " "
     "The representation is a Union of two record types - one for integration of"
     "a function of one variable:"
     " "
     "Record(var:Symbol,"
     "fn:Expression DoubleFloat,"
     "range:Segment OrderedCompletion DoubleFloat,"
     "abserr:DoubleFloat,"
     "relerr:DoubleFloat,)"
     " "
     "and one for multivariate integration:"
     " "
     "Record(fn:Expression DoubleFloat,"
     "range:List Segment OrderedCompletion DoubleFloat,"
     "abserr:DoubleFloat,"
     "relerr:DoubleFloat,)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NumericalIntegrationProblem|
  (progn
    (push '|NumericalIntegrationProblem| *Domains*)
    (make-instance '|NumericalIntegrationProblemType|)))

\end{chunk}

\subsection{NumericalODEProblem}
\index[dom]{NumericalODEProblem!Domain}
\index[dom]{Domain!NumericalODEProblem}
\index[dom]{ODEPROB}
\begin{chunk}{defclass NumericalODEProblemType}
(defclass |NumericalODEProblemType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "NumericalODEProblem")
   (marker :initform 'domain)
   (abbreviation :initform 'ODEPROB)
   (comment :initform (list
     "NumericalODEProblem is a domain"
     "for the representation of Numerical ODE problems for use"
     "by ANNA."
     " "
     "The representation is of type:"
     " "
     "Record(xinit:DoubleFloat,"
     "xend:DoubleFloat,"
     "fn:Vector Expression DoubleFloat,"
     "yinit:List DoubleFloat,intvals:List DoubleFloat,"
     "g:Expression DoubleFloat,abserr:DoubleFloat,"
     "relerr:DoubleFloat)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NumericalODEProblem|
  (progn
    (push '|NumericalODEProblem| *Domains*)
    (make-instance '|NumericalODEProblemType|)))

\end{chunk}

\subsection{NumericalOptimizationProblem}
\index[dom]{NumericalOptimizationProblem!Domain}
\index[dom]{Domain!NumericalOptimizationProblem}
\index[dom]{OPTPROB}
\begin{chunk}{defclass NumericalOptimizationProblemType}
(defclass |NumericalOptimizationProblemType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "NumericalOptimizationProblem")
   (marker :initform 'domain)
   (abbreviation :initform 'OPTPROB)
   (comment :initform (list
     "NumericalOptimizationProblem is a domain"
     "for the representation of Numerical Optimization problems for use"
     "by ANNA."
     " "
     "The representation is a Union of two record types - one for optimization of"
     "a single function of one or more variables:"
     " "
     "Record("
     "fn:Expression DoubleFloat,"
     "init:List DoubleFloat,"
     "lb:List OrderedCompletion DoubleFloat,"
     "cf:List Expression DoubleFloat,"
     "ub:List OrderedCompletion DoubleFloat)"
     " "
     "and one for least-squares problems that is, optimization of a set of"
     "observations of a data set:"
     " "
     "Record(lfn:List Expression DoubleFloat,"
     "init:List DoubleFloat)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NumericalOptimizationProblem|
  (progn
    (push '|NumericalOptimizationProblem| *Domains*)
    (make-instance '|NumericalOptimizationProblemType|)))

\end{chunk}

\subsection{NumericalPDEProblem}
\index[dom]{NumericalPDEProblem!Domain}
\index[dom]{Domain!NumericalPDEProblem}
\index[dom]{PDEPROB}
\begin{chunk}{defclass NumericalPDEProblemType}
(defclass |NumericalPDEProblemType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "NumericalPDEProblem")
   (marker :initform 'domain)
   (abbreviation :initform 'PDEPROB)
   (comment :initform (list
     "NumericalPDEProblem is a domain"
     "for the representation of Numerical PDE problems for use"
     "by ANNA."
     " "
     "The representation is of type:"
     " "
     "Record(pde:List Expression DoubleFloat,"
     "constraints:List PDEC,"
     "f:List List Expression DoubleFloat,"
     "st:String,"
     "tol:DoubleFloat)"
     " "
     "where PDEC is of type:"
     " "
     "Record(start:DoubleFloat,"
     "finish:DoubleFloat,"
     "grid:NonNegativeInteger,"
     "boundaryType:Integer,"
     "dStart:Matrix DoubleFloat,"
     "dFinish:Matrix DoubleFloat)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NumericalPDEProblem|
  (progn
    (push '|NumericalPDEProblem| *Domains*)
    (make-instance '|NumericalPDEProblemType|)))

\end{chunk}

\section{O}

\subsection{Octonion}
\index[dom]{Octonion!Domain}
\index[dom]{Domain!Octonion}
\index[dom]{OCT}
\begin{chunk}{defclass OctonionType}
(defclass |OctonionType| (|OctonionCategoryType|)
  ((parents :initform '(|OctonionCategory|))
   (name :initform "Octonion")
   (marker :initform 'domain)
   (abbreviation :initform 'OCT)
   (comment :initform (list
     "Octonion implements octonions (Cayley-Dixon algebra) over a"
     "commutative ring, an eight-dimensional non-associative"
     "algebra, doubling the quaternions in the same way as doubling"
     "the complex numbers to get the quaternions"
     "the main constructor function is octon which takes 8"
     "arguments: the real part, the i imaginary part, the j"
     "imaginary part, the k imaginary part, (as with quaternions)"
     "and in addition the imaginary parts E, I, J, K."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Octonion|
  (progn
    (push '|Octonion| *Domains*)
    (make-instance '|OctonionType|)))

\end{chunk}

\subsection{ODEIntensityFunctionsTable}
\index[dom]{ODEIntensityFunctionsTable!Domain}
\index[dom]{Domain!ODEIntensityFunctionsTable}
\index[dom]{ODEIFTBL}
\begin{chunk}{defclass ODEIntensityFunctionsTableType}
(defclass |ODEIntensityFunctionsTableType| (|AxiomClass|)
  ((parents :initform '())
   (name :initform "ODEIntensityFunctionsTable")
   (marker :initform 'domain)
   (abbreviation :initform 'ODEIFTBL)
   (comment :initform (list
     "ODEIntensityFunctionsTable() provides a dynamic table and a set of"
     "functions to store details found out about sets of ODE's."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ODEIntensityFunctionsTable|
  (progn
    (push '|ODEIntensityFunctionsTable| *Domains*)
    (make-instance '|ODEIntensityFunctionsTableType|)))

\end{chunk}

\subsection{OneDimensionalArray}
\index[dom]{OneDimensionalArray!Domain}
\index[dom]{Domain!OneDimensionalArray}
\index[dom]{ARRAY1}
\begin{chunk}{defclass OneDimensionalArrayType}
(defclass |OneDimensionalArrayType| (|OneDimensionalArrayAggregateType|)
  ((parents :initform '(|OneDimensionalArrayAggregate|))
   (name :initform "OneDimensionalArray")
   (marker :initform 'domain)
   (abbreviation :initform 'ARRAY1)
   (comment :initform (list
     "This is the domain of 1-based one dimensional arrays"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OneDimensionalArray|
  (progn
    (push '|OneDimensionalArray| *Domains*)
    (make-instance '|OneDimensionalArrayType|)))

\end{chunk}

\subsection{OnePointCompletion}
\index[dom]{OnePointCompletion!Domain}
\index[dom]{Domain!OnePointCompletion}
\index[dom]{ONECOMP}
\begin{chunk}{defclass OnePointCompletionType}
(defclass |OnePointCompletionType| (|OrderedRingType| |FullyRetractableToType|)
  ((parents :initform '(|OrderedRing| |FullyRetractableTo|))
   (name :initform "OnePointCompletion")
   (marker :initform 'domain)
   (abbreviation :initform 'ONECOMP)
   (comment :initform (list
     "Completion with infinity."
     "Adjunction of a complex infinity to a set."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OnePointCompletion|
  (progn
    (push '|OnePointCompletion| *Domains*)
    (make-instance '|OnePointCompletionType|)))

\end{chunk}

\subsection{OpenMathConnection}
\index[dom]{OpenMathConnection!Domain}
\index[dom]{Domain!OpenMathConnection}
\index[dom]{OMCONN}
\begin{chunk}{defclass OpenMathConnectionType}
(defclass |OpenMathConnectionType| (|AxiomClass|)
  ((parents :initform '())
   (name :initform "OpenMathConnection")
   (marker :initform 'domain)
   (abbreviation :initform 'OMCONN)
   (comment :initform (list
     "OpenMathConnection provides low-level functions"
     "for handling connections to and from OpenMathDevices."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OpenMathConnection|
  (progn
    (push '|OpenMathConnection| *Domains*)
    (make-instance '|OpenMathConnectionType|)))

\end{chunk}

\subsection{OpenMathDevice}
\index[dom]{OpenMathDevice!Domain}
\index[dom]{Domain!OpenMathDevice}
\index[dom]{OMDEV}
\begin{chunk}{defclass OpenMathDeviceType}
(defclass |OpenMathDeviceType| (|AxiomClass|)
  ((parents :initform '())
   (name :initform "OpenMathDevice")
   (marker :initform 'domain)
   (abbreviation :initform 'OMDEV)
   (comment :initform (list
     "OpenMathDevice provides support for reading"
     "and writing openMath objects to files, strings etc.  It also provides"
     "access to low-level operations from within the interpreter."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OpenMathDevice|
  (progn
    (push '|OpenMathDevice| *Domains*)
    (make-instance '|OpenMathDeviceType|)))

\end{chunk}

\subsection{OpenMathEncoding}
\index[dom]{OpenMathEncoding!Domain}
\index[dom]{Domain!OpenMathEncoding}
\index[dom]{OMENC}
\begin{chunk}{defclass OpenMathEncodingType}
(defclass |OpenMathEncodingType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "OpenMathEncoding")
   (marker :initform 'domain)
   (abbreviation :initform 'OMENC)
   (comment :initform (list
     "OpenMathEncoding is the set of valid OpenMath encodings."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OpenMathEncoding|
  (progn
    (push '|OpenMathEncoding| *Domains*)
    (make-instance '|OpenMathEncodingType|)))

\end{chunk}

\subsection{OpenMathError}
\index[dom]{OpenMathError!Domain}
\index[dom]{Domain!OpenMathError}
\index[dom]{OMERR}
\begin{chunk}{defclass OpenMathErrorType}
(defclass |OpenMathErrorType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "OpenMathError")
   (marker :initform 'domain)
   (abbreviation :initform 'OMERR)
   (comment :initform (list
     "OpenMathError is the domain of OpenMath errors."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OpenMathError|
  (progn
    (push '|OpenMathError| *Domains*)
    (make-instance '|OpenMathErrorType|)))

\end{chunk}

\subsection{OpenMathErrorKind}
\index[dom]{OpenMathErrorKind!Domain}
\index[dom]{Domain!OpenMathErrorKind}
\index[dom]{OMERRK}
\begin{chunk}{defclass OpenMathErrorKindType}
(defclass |OpenMathErrorKindType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "OpenMathErrorKind")
   (marker :initform 'domain)
   (abbreviation :initform 'OMERRK)
   (comment :initform (list
     "OpenMathErrorKind represents different kinds"
     "of OpenMath errors: specifically parse errors, unknown CD or symbol"
     "errors, and read errors."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OpenMathErrorKind|
  (progn
    (push '|OpenMathErrorKind| *Domains*)
    (make-instance '|OpenMathErrorKindType|)))

\end{chunk}

\subsection{Operator}
\index[dom]{Operator!Domain}
\index[dom]{Domain!Operator}
\index[dom]{OP}
\begin{chunk}{defclass OperatorType}
(defclass |OperatorType| (|AlgebraType|
                          |CharacteristicNonZeroType|
                          |CharacteristicZeroType|
                          |EltableType|
                          |RetractableToType|)
  ((parents :initform '(|Algebra|
                        |CharacteristicNonZero|
                        |CharacteristicZero|
                        |Eltable|
                        |RetractableTo|))
   (name :initform "Operator")
   (marker :initform 'domain)
   (abbreviation :initform 'OP)
   (comment :initform (list
     "Algebra of ADDITIVE operators over a ring."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Operator|
  (progn
    (push '|Operator| *Domains*)
    (make-instance '|OperatorType|)))

\end{chunk}

\subsection{OppositeMonogenicLinearOperator}
\index[dom]{OppositeMonogenicLinearOperator!Domain}
\index[dom]{Domain!OppositeMonogenicLinearOperator}
\index[dom]{OMLO}
\begin{chunk}{defclass OppositeMonogenicLinearOperatorType}
(defclass |OppositeMonogenicLinearOperatorType| (|DifferentialRingType|
                                                 |MonogenicLinearOperatorType|)
  ((parents :initform '(|DifferentialRing| |MonogenicLinearOperator|))
   (name :initform "OppositeMonogenicLinearOperator")
   (marker :initform 'domain)
   (abbreviation :initform 'OMLO)
   (comment :initform (list
     "This constructor creates the MonogenicLinearOperator domain"
     "which is 'opposite' in the ring sense to P."
     "That is, as sets P = $ but a * b in $ is equal to"
     "b * a in P."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OppositeMonogenicLinearOperator|
  (progn
    (push '|OppositeMonogenicLinearOperator| *Domains*)
    (make-instance '|OppositeMonogenicLinearOperatorType|)))

\end{chunk}

\subsection{OrderedCompletion}
\index[dom]{OrderedCompletion!Domain}
\index[dom]{Domain!OrderedCompletion}
\index[dom]{ORDCOMP}
\begin{chunk}{defclass OrderedCompletionType}
(defclass |OrderedCompletionType| (|OrderedRingType| |FullyRetractableToType|)
  ((parents :initform '(|OrderedRing| |FullyRetractableTo|))
   (name :initform "OrderedCompletion")
   (marker :initform 'domain)
   (abbreviation :initform 'ORDCOMP)
   (comment :initform (list
     "Completion with + and - infinity."
     "Adjunction of two real infinites quantities to a set."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderedCompletion|
  (progn
    (push '|OrderedCompletion| *Domains*)
    (make-instance '|OrderedCompletionType|)))

\end{chunk}

\subsection{OrderedDirectProduct}
\index[dom]{OrderedDirectProduct!Domain}
\index[dom]{Domain!OrderedDirectProduct}
\index[dom]{ODP}
\begin{chunk}{defclass OrderedDirectProductType}
(defclass |OrderedDirectProductType| (|DirectProductCategoryType|)
  ((parents :initform '(|DirectProductCategory|))
   (name :initform "OrderedDirectProduct")
   (marker :initform 'domain)
   (abbreviation :initform 'ODP)
   (comment :initform nil)
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderedDirectProduct|
  (progn
    (push '|OrderedDirectProduct| *Domains*)
    (make-instance '|OrderedDirectProductType|)))

\end{chunk}

\subsection{OrderedFreeMonoid}
\index[dom]{OrderedFreeMonoid!Domain}
\index[dom]{Domain!OrderedFreeMonoid}
\index[dom]{OFMONOID}
\begin{chunk}{defclass OrderedFreeMonoidType}
(defclass |OrderedFreeMonoidType| (|RetractableToType| |OrderedMonoidType|)
  ((parents :initform '(|RetractableTo| |OrderedMonoid|))
   (name :initform "OrderedFreeMonoid")
   (marker :initform 'domain)
   (abbreviation :initform 'OFMONOID)
   (comment :initform (list
     "The free monoid on a set S is the monoid of finite products of"
     "the form reduce(*,[si ** ni]) where the si's are in S, and the ni's"
     "are non-negative integers. The multiplication is not commutative."
     "For two elements x and y the relation x < y"
     "holds if either length(x) < length(y) holds or if these lengths"
     "are equal and if x is smaller than y w.r.t. the"
     "lexicographical ordering induced by S."
     "This domain inherits implementation from FreeMonoid."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderedFreeMonoid|
  (progn
    (push '|OrderedFreeMonoid| *Domains*)
    (make-instance '|OrderedFreeMonoidType|)))

\end{chunk}

\subsection{OrderedVariableList}
\index[dom]{OrderedVariableList!Domain}
\index[dom]{Domain!OrderedVariableList}
\index[dom]{OVAR}
\begin{chunk}{defclass OrderedVariableListType}
(defclass |OrderedVariableListType| (|ConvertibleToType| |OrderedFiniteType|)
  ((parents :initform '(|ConvertibleTo| |OrderedFinite|))
   (name :initform "OrderedVariableList")
   (marker :initform 'domain)
   (abbreviation :initform 'OVAR)
   (comment :initform (list
     "This domain implements ordered variables"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderedVariableList|
  (progn
    (push '|OrderedVariableList| *Domains*)
    (make-instance '|OrderedVariableListType|)))

\end{chunk}

\subsection{OrderlyDifferentialPolynomial}
\index[dom]{OrderlyDifferentialPolynomial!Domain}
\index[dom]{Domain!OrderlyDifferentialPolynomial}
\index[dom]{ODPOL}
\begin{chunk}{defclass OrderlyDifferentialPolynomialType}
(defclass |OrderlyDifferentialPolynomialType| (|DifferentialPolynomialCategoryType|)
  ((parents :initform '(|DifferentialPolynomialCategory|))
   (name :initform "OrderlyDifferentialPolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'ODPOL)
   (comment :initform (list
     "OrderlyDifferentialPolynomial implements"
     "an ordinary differential polynomial ring in arbitrary number"
     "of differential indeterminates, with coefficients in a"
     "ring.  The ranking on the differential indeterminate is orderly."
     "This is analogous to the domain Polynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderlyDifferentialPolynomial|
  (progn
    (push '|OrderlyDifferentialPolynomial| *Domains*)
    (make-instance '|OrderlyDifferentialPolynomialType|)))

\end{chunk}

\subsection{OrderlyDifferentialVariable}
\index[dom]{OrderlyDifferentialVariable!Domain}
\index[dom]{Domain!OrderlyDifferentialVariable}
\index[dom]{ODVAR}
\begin{chunk}{defclass OrderlyDifferentialVariableType}
(defclass |OrderlyDifferentialVariableType| (|DifferentialVariableCategoryType|)
  ((parents :initform '(|DifferentialVariableCategory|))
   (name :initform "OrderlyDifferentialVariable")
   (marker :initform 'domain)
   (abbreviation :initform 'ODVAR)
   (comment :initform (list
     "OrderlyDifferentialVariable adds a commonly used orderly"
     "ranking to the set of derivatives of an ordered list of differential"
     "indeterminates.  An orderly ranking is a ranking < of the"
     "derivatives with the property that for two derivatives u and v,"
     "u < v if the order of u is less than that of v."
     "This domain belongs to DifferentialVariableCategory.  It"
     "defines weight to be just order, and it"
     "defines an orderly ranking < on derivatives u via the"
     "lexicographic order on the pair"
     "(order(u), variable}(u)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderlyDifferentialVariable|
  (progn
    (push '|OrderlyDifferentialVariable| *Domains*)
    (make-instance '|OrderlyDifferentialVariableType|)))

\end{chunk}

\subsection{OrdinaryDifferentialRing}
\index[dom]{OrdinaryDifferentialRing!Domain}
\index[dom]{Domain!OrdinaryDifferentialRing}
\index[dom]{ODR}
\begin{chunk}{defclass OrdinaryDifferentialRingType}
(defclass |OrdinaryDifferentialRingType| (|FieldType| |DifferentialRingType|)
  ((parents :initform '(|Field| |DifferentialRing|))
   (name :initform "OrdinaryDifferentialRing")
   (marker :initform 'domain)
   (abbreviation :initform 'ODR)
   (comment :initform (list
     "This constructor produces an ordinary differential ring from"
     "a partial differential ring by specifying a variable."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrdinaryDifferentialRing|
  (progn
    (push '|OrdinaryDifferentialRing| *Domains*)
    (make-instance '|OrdinaryDifferentialRingType|)))

\end{chunk}

\subsection{OrdinaryWeightedPolynomials}
\index[dom]{OrdinaryWeightedPolynomials!Domain}
\index[dom]{Domain!OrdinaryWeightedPolynomials}
\index[dom]{OWP}
\begin{chunk}{defclass OrdinaryWeightedPolynomialsType}
(defclass |OrdinaryWeightedPolynomialsType| (|AlgebraType|)
  ((parents :initform '(|Algebra|))
   (name :initform "OrdinaryWeightedPolynomials")
   (marker :initform 'domain)
   (abbreviation :initform 'OWP)
   (comment :initform (list
     "This domain represents truncated weighted polynomials over the"
     "'Polynomial' type. The variables must be"
     "specified, as must the weights."
     "The representation is sparse"
     "in the sense that only non-zero terms are represented."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrdinaryWeightedPolynomials|
  (progn
    (push '|OrdinaryWeightedPolynomials| *Domains*)
    (make-instance '|OrdinaryWeightedPolynomialsType|)))

\end{chunk}

\subsection{OrdSetInts}
\index[dom]{OrdSetInts!Domain}
\index[dom]{Domain!OrdSetInts}
\index[dom]{OSI}
\begin{chunk}{defclass OrdSetIntsType}
(defclass |OrdSetIntsType| (|OrderedSetType|)
  ((parents :initform '(|OrderedSet|))
   (name :initform "OrdSetInts")
   (marker :initform 'domain)
   (abbreviation :initform 'OSI)
   (comment :initform (list
     "A domain used in order to take the free R-module on the"
     "Integers I.  This is actually the forgetful functor from OrderedRings"
     "to OrderedSets applied to I"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrdSetInts|
  (progn
    (push '|OrdSetInts| *Domains*)
    (make-instance '|OrdSetIntsType|)))

\end{chunk}

\subsection{OutputForm}
\index[dom]{OutputForm!Domain}
\index[dom]{Domain!OutputForm}
\index[dom]{OUTFORM}
\begin{chunk}{defclass OutputFormType}
(defclass |OutputFormType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "OutputForm")
   (marker :initform 'domain)
   (abbreviation :initform 'OUTFORM)
   (comment :initform (list
     "This domain is used to create and manipulate mathematical expressions"
     "for output.  It is intended to provide an insulating layer between"
     "the expression rendering software (for example, FORTRAN or TeX) and"
     "the output coercions in the various domains."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OutputForm|
  (progn
    (push '|OutputForm| *Domains*)
    (make-instance '|OutputFormType|)))

\end{chunk}

\section{P}

\subsection{PAdicInteger}
\index[dom]{PAdicInteger!Domain}
\index[dom]{Domain!PAdicInteger}
\index[dom]{PADIC}
\begin{chunk}{defclass PAdicIntegerType}
(defclass |PAdicIntegerType| (|PAdicIntegerCategoryType|)
  ((parents :initform '(|PAdicIntegerCategory|))
   (name :initform "PAdicInteger")
   (marker :initform 'domain)
   (abbreviation :initform 'PADIC)
   (comment :initform (list
     "Stream-based implementation of Zp: p-adic numbers are represented as"
     "sum(i = 0.., a[i] * p^i), where the a[i] lie in 0,1,...,(p - 1)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PAdicInteger|
  (progn
    (push '|PAdicInteger| *Domains*)
    (make-instance '|PAdicIntegerType|)))

\end{chunk}

\subsection{PAdicRational}
\index[dom]{PAdicRational!Domain}
\index[dom]{Domain!PAdicRational}
\index[dom]{PADICRAT}
\begin{chunk}{defclass PAdicRationalType}
(defclass |PAdicRationalType| (|QuotientFieldCategoryType|)
  ((parents :initform '(|QuotientFieldCategory|))
   (name :initform "PAdicRational")
   (marker :initform 'domain)
   (abbreviation :initform 'PADICRAT)
   (comment :initform (list
     "Stream-based implementation of Qp: numbers are represented as"
     " sum(i = k.., a[i] * p^i) where the a[i] lie in 0,1,...,(p - 1)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PAdicRational|
  (progn
    (push '|PAdicRational| *Domains*)
    (make-instance '|PAdicRationalType|)))

\end{chunk}

\subsection{PAdicRationalConstructor}
\index[dom]{PAdicRationalConstructor!Domain}
\index[dom]{Domain!PAdicRationalConstructor}
\index[dom]{PADICRC}
\begin{chunk}{defclass PAdicRationalConstructorType}
(defclass |PAdicRationalConstructorType| (|QuotientFieldCategoryType|)
  ((parents :initform '(|QuotientFieldCategory|))
   (name :initform "PAdicRationalConstructor")
   (marker :initform 'domain)
   (abbreviation :initform 'PADICRC)
   (comment :initform (list
     "This is the category of stream-based representations of Qp."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PAdicRationalConstructor|
  (progn
    (push '|PAdicRationalConstructor| *Domains*)
    (make-instance '|PAdicRationalConstructorType|)))

\end{chunk}

\subsection{Palette}
\index[dom]{Palette!Domain}
\index[dom]{Domain!Palette}
\index[dom]{PALETTE}
\begin{chunk}{defclass PaletteType}
(defclass |PaletteType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "Palette")
   (marker :initform 'domain)
   (abbreviation :initform 'PALETTE)
   (comment :initform (list
     "This domain describes four groups of color shades (palettes)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Palette|
  (progn
    (push '|Palette| *Domains*)
    (make-instance '|PaletteType|)))

\end{chunk}

\subsection{ParametricPlaneCurve}
\index[dom]{ParametricPlaneCurve!Domain}
\index[dom]{Domain!ParametricPlaneCurve}
\index[dom]{PARPCURV}
\begin{chunk}{defclass ParametricPlaneCurveType}
(defclass |ParametricPlaneCurveType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ParametricPlaneCurve")
   (marker :initform 'domain)
   (abbreviation :initform 'PARPCURV)
   (comment :initform (list
     "ParametricPlaneCurve is used for plotting parametric plane"
     "curves in the affine plane."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ParametricPlaneCurve|
  (progn
    (push '|ParametricPlaneCurve| *Domains*)
    (make-instance '|ParametricPlaneCurveType|)))

\end{chunk}

\subsection{ParametricSpaceCurve}
\index[dom]{ParametricSpaceCurve!Domain}
\index[dom]{Domain!ParametricSpaceCurve}
\index[dom]{PARSCURV}
\begin{chunk}{defclass ParametricSpaceCurveType}
(defclass |ParametricSpaceCurveType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ParametricSpaceCurve")
   (marker :initform 'domain)
   (abbreviation :initform 'PARSCURV)
   (comment :initform (list
     "ParametricSpaceCurve is used for plotting parametric space"
     "curves in affine 3-space."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ParametricSpaceCurve|
  (progn
    (push '|ParametricSpaceCurve| *Domains*)
    (make-instance '|ParametricSpaceCurveType|)))

\end{chunk}

\subsection{ParametricSurface}
\index[dom]{ParametricSurface!Domain}
\index[dom]{Domain!ParametricSurface}
\index[dom]{PARSURF}
\begin{chunk}{defclass ParametricSurfaceType}
(defclass |ParametricSurfaceType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ParametricSurface")
   (marker :initform 'domain)
   (abbreviation :initform 'PARSURF)
   (comment :initform (list
     "ParametricSurface is used for plotting parametric surfaces in"
     "affine 3-space."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ParametricSurface|
  (progn
    (push '|ParametricSurface| *Domains*)
    (make-instance '|ParametricSurfaceType|)))

\end{chunk}

\subsection{PartialFraction}
\index[dom]{PartialFraction!Domain}
\index[dom]{Domain!PartialFraction}
\index[dom]{PFR}
\begin{chunk}{defclass PartialFractionType}
(defclass |PartialFractionType| (|FieldType|)
  ((parents :initform '(|Field|))
   (name :initform "PartialFraction")
   (marker :initform 'domain)
   (abbreviation :initform 'PFR)
   (comment :initform (list
     "The domain PartialFraction implements partial fractions"
     "over a euclidean domain R. This requirement on the"
     "argument domain allows us to normalize the fractions.  Of"
     "particular interest are the 2 forms for these fractions.  The"
     "``compact'' form has only one fractional term per prime in the"
     "denominator, while the ``p-adic'' form expands each numerator"
     "p-adically via the prime p in the denominator.  For computational"
     "efficiency, the compact form is used, though the p-adic form may"
     "be gotten by calling the function padicFraction}.  For a"
     "general euclidean domain, it is not known how to factor the"
     "denominator.  Thus the function partialFraction takes as its"
     "second argument an element of Factored(R)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PartialFraction|
  (progn
    (push '|PartialFraction| *Domains*)
    (make-instance '|PartialFractionType|)))

\end{chunk}

\subsection{Partition}
\index[dom]{Partition!Domain}
\index[dom]{Domain!Partition}
\index[dom]{PRTITION}
\begin{chunk}{defclass PartitionType}
(defclass |PartitionType| (|ConvertibleToType| |OrderedCancellationAbelianMonoidType|)
  ((parents :initform '(|ConvertibleTo| |OrderedCancellationAbelianMonoid|))
   (name :initform "Partition")
   (marker :initform 'domain)
   (abbreviation :initform 'PRTITION)
   (comment :initform (list
     "Partition is an OrderedCancellationAbelianMonoid which is used"
     "as the basis for symmetric polynomial representation of the"
     "sums of powers in SymmetricPolynomial.  Thus, (5 2 2 1) will"
     "represent s5 * s2**2 * s1."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Partition|
  (progn
    (push '|Partition| *Domains*)
    (make-instance '|PartitionType|)))

\end{chunk}

\subsection{Pattern}
\index[dom]{Pattern!Domain}
\index[dom]{Domain!Pattern}
\index[dom]{PATTERN}
\begin{chunk}{defclass PatternType}
(defclass |PatternType| (|SetCategoryType| |RetractableToType|)
  ((parents :initform '(|SetCategory| |RetractableTo|))
   (name :initform "Pattern")
   (marker :initform 'domain)
   (abbreviation :initform 'PATTERN)
   (comment :initform (list
     "Patterns for use by the pattern matcher."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Pattern|
  (progn
    (push '|Pattern| *Domains*)
    (make-instance '|PatternType|)))

\end{chunk}

\subsection{PatternMatchListResult}
\index[dom]{PatternMatchListResult!Domain}
\index[dom]{Domain!PatternMatchListResult}
\index[dom]{PATLRES}
\begin{chunk}{defclass PatternMatchListResultType}
(defclass |PatternMatchListResultType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "PatternMatchListResult")
   (marker :initform 'domain)
   (abbreviation :initform 'PATLRES)
   (comment :initform (list
     "A PatternMatchListResult is an object internally returned by the"
     "pattern matcher when matching on lists."
     "It is either a failed match, or a pair of PatternMatchResult,"
     "one for atoms (elements of the list), and one for lists."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternMatchListResult|
  (progn
    (push '|PatternMatchListResult| *Domains*)
    (make-instance '|PatternMatchListResultType|)))

\end{chunk}

\subsection{PatternMatchResult}
\index[dom]{PatternMatchResult!Domain}
\index[dom]{Domain!PatternMatchResult}
\index[dom]{PATRES}
\begin{chunk}{defclass PatternMatchResultType}
(defclass |PatternMatchResultType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "PatternMatchResult")
   (marker :initform 'domain)
   (abbreviation :initform 'PATRES)
   (comment :initform (list
     "A PatternMatchResult is an object internally returned by the"
     "pattern matcher; It is either a failed match, or a list of"
     "matches of the form (var, expr) meaning that the variable var"
     "matches the expression expr."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternMatchResult|
  (progn
    (push '|PatternMatchResult| *Domains*)
    (make-instance '|PatternMatchResultType|)))

\end{chunk}

\subsection{PendantTree}
\index[dom]{PendantTree!Domain}
\index[dom]{Domain!PendantTree}
\index[dom]{PENDTREE}
\begin{chunk}{defclass PendantTreeType}
(defclass |PendantTreeType| (|BinaryRecursiveAggregateType|)
  ((parents :initform '(|BinaryRecursiveAggregate|))
   (name :initform "PendantTree")
   (marker :initform 'domain)
   (abbreviation :initform 'PENDTREE)
   (comment :initform (list
     "A PendantTree(S) is either a leaf? and is an S or has"
     "a left and a right both PendantTree(S)'s"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PendantTree|
  (progn
    (push '|PendantTree| *Domains*)
    (make-instance '|PendantTreeType|)))

\end{chunk}

\subsection{Permutation}
\index[dom]{Permutation!Domain}
\index[dom]{Domain!Permutation}
\index[dom]{PERM}
\begin{chunk}{defclass PermutationType}
(defclass |PermutationType| (|PermutationCategoryType|)
  ((parents :initform '(|PermutationCategory|))
   (name :initform "Permutation")
   (marker :initform 'domain)
   (abbreviation :initform 'PERM)
   (comment :initform (list
     "Permutation(S) implements the group of all bijections"
     "on a set S, which move only a finite number of points."
     "A permutation is considered as a map from S into S. In particular"
     "multiplication is defined as composition of maps:"
     "pi1 * pi2 = pi1 o pi2."
     "The internal representation of permuatations are two lists"
     "of equal length representing preimages and images."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Permutation|
  (progn
    (push '|Permutation| *Domains*)
    (make-instance '|PermutationType|)))

\end{chunk}

\subsection{PermutationGroup}
\index[dom]{PermutationGroup!Domain}
\index[dom]{Domain!PermutationGroup}
\index[dom]{PERMGRP}
\begin{chunk}{defclass PermutationGroupType}
(defclass |PermutationGroupType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "PermutationGroup")
   (marker :initform 'domain)
   (abbreviation :initform 'PERMGRP)
   (comment :initform (list
     "PermutationGroup implements permutation groups acting"
     "on a set S, all subgroups of the symmetric group of S,"
     "represented as a list of permutations (generators). Note that"
     "therefore the objects are not members of the Axiom category"
     "Group."
     "Using the idea of base and strong generators by Sims,"
     "basic routines and algorithms"
     "are implemented so that the word problem for"
     "permutation groups can be solved."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PermutationGroup|
  (progn
    (push '|PermutationGroup| *Domains*)
    (make-instance '|PermutationGroupType|)))

\end{chunk}

\subsection{Pi}
\index[dom]{Pi!Domain}
\index[dom]{Domain!Pi}
\index[dom]{HACKPI}
\begin{chunk}{defclass PiType}
(defclass |PiType| (|CharacteristicZeroType|
                    |FieldType|
                    |RealConstantType|
                    |RetractableToType|)
  ((parents :initform '(|CharacteristicZero|
                        |Field|
                        |RealConstant|
                        |RetractableTo|))
   (name :initform "Pi")
   (marker :initform 'domain)
   (abbreviation :initform 'HACKPI)
   (comment :initform (list
     "Symbolic fractions in %pi with integer coefficients;"
     "The point for using Pi as the default domain for those fractions"
     "is that Pi is coercible to the float types, and not Expression."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Pi|
  (progn
    (push '|Pi| *Domains*)
    (make-instance '|PiType|)))

\end{chunk}

\subsection{PlaneAlgebraicCurvePlot}
\index[dom]{PlaneAlgebraicCurvePlot!Domain}
\index[dom]{Domain!PlaneAlgebraicCurvePlot}
\index[dom]{ACPLOT}
\begin{chunk}{defclass PlaneAlgebraicCurvePlotType}
(defclass |PlaneAlgebraicCurvePlotType| (|PlottablePlaneCurveCategoryType|)
  ((parents :initform '(|PlottablePlaneCurveCategory|))
   (name :initform "PlaneAlgebraicCurvePlot")
   (marker :initform 'domain)
   (abbreviation :initform 'ACPLOT)
   (comment :initform (list
     "Plot a NON-SINGULAR plane algebraic curve p(x,y) = 0."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PlaneAlgebraicCurvePlot|
  (progn
    (push '|PlaneAlgebraicCurvePlot| *Domains*)
    (make-instance '|PlaneAlgebraicCurvePlotType|)))

\end{chunk}

\subsection{Places}
\index[dom]{Places!Domain}
\index[dom]{Domain!Places}
\index[dom]{PLACES}
\begin{chunk}{defclass PlacesType}
(defclass |PlacesType| (|PlacesCategoryType|)
  ((parents :initform '(|PlacesCategory|))
   (name :initform "Places")
   (marker :initform 'domain)
   (abbreviation :initform 'PLACES)
   (comment :initform (list
     "The following is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Places|
  (progn
    (push '|Places| *Domains*)
    (make-instance '|PlacesType|)))

\end{chunk}

\subsection{PlacesOverPseudoAlgebraicClosureOfFiniteField}
\index[dom]{PlacesOverPseudoAlgebraicClosureOfFiniteField!Domain}
\index[dom]{Domain!PlacesOverPseudoAlgebraicClosureOfFiniteField}
\index[dom]{PLACESPS}
\begin{chunk}{defclass PlacesOverPseudoAlgebraicClosureOfFiniteFieldType}
(defclass |PlacesOverPseudoAlgebraicClosureOfFiniteFieldType| (|PlacesCategoryType|)
  ((parents :initform '(|PlacesCategory|))
   (name :initform "PlacesOverPseudoAlgebraicClosureOfFiniteField")
   (marker :initform 'domain)
   (abbreviation :initform 'PLACESPS)
   (comment :initform (list
     "The following is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PlacesOverPseudoAlgebraicClosureOfFiniteField|
  (progn
    (push '|PlacesOverPseudoAlgebraicClosureOfFiniteField| *Domains*)
    (make-instance '|PlacesOverPseudoAlgebraicClosureOfFiniteFieldType|)))

\end{chunk}

\subsection{Plcs}
\index[dom]{Plcs!Domain}
\index[dom]{Domain!Plcs}
\index[dom]{PLCS}
\begin{chunk}{defclass PlcsType}
(defclass |PlcsType| (|PlacesCategoryType|)
  ((parents :initform '(|PlacesCategory|))
   (name :initform "Plcs")
   (marker :initform 'domain)
   (abbreviation :initform 'PLCS)
   (comment :initform (list
     "The following is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Plcs|
  (progn
    (push '|Plcs| *Domains*)
    (make-instance '|PlcsType|)))

\end{chunk}

\subsection{Plot}
\index[dom]{Plot!Domain}
\index[dom]{Domain!Plot}
\index[dom]{PLOT}
\begin{chunk}{defclass PlotType}
(defclass |PlotType| (|PlottablePlaneCurveCategoryType|)
  ((parents :initform '(|PlottablePlaneCurveCategory|))
   (name :initform "Plot")
   (marker :initform 'domain)
   (abbreviation :initform 'PLOT)
   (comment :initform (list
     "The Plot domain supports plotting of functions defined over a"
     "real number system.  A real number system is a model for the real"
     "numbers and as such may be an approximation.  For example"
     "floating point numbers and infinite continued fractions."
     "The facilities at this point are limited to 2-dimensional plots"
     "or either a single function or a parametric function."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Plot|
  (progn
    (push '|Plot| *Domains*)
    (make-instance '|PlotType|)))

\end{chunk}

\subsection{Plot3D}
\index[dom]{Plot3D!Domain}
\index[dom]{Domain!Plot3D}
\index[dom]{PLOT3D}
\begin{chunk}{defclass Plot3DType}
(defclass |Plot3DType| (|PlottableSpaceCurveCategoryType|)
  ((parents :initform '(|PlottableSpaceCurveCategory|))
   (name :initform "Plot3D")
   (marker :initform 'domain)
   (abbreviation :initform 'PLOT3D)
   (comment :initform (list
     "Plot3D supports parametric plots defined over a real"
     "number system.  A real number system is a model for the real"
     "numbers and as such may be an approximation.  For example,"
     "floating point numbers and infinite continued fractions are"
     "real number systems. The facilities at this point are limited"
     "to 3-dimensional parametric plots."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Plot3D|
  (progn
    (push '|Plot3D| *Domains*)
    (make-instance '|Plot3DType|)))

\end{chunk}

\subsection{PoincareBirkhoffWittLyndonBasis}
\index[dom]{PoincareBirkhoffWittLyndonBasis!Domain}
\index[dom]{Domain!PoincareBirkhoffWittLyndonBasis}
\index[dom]{PBWLB}
\begin{chunk}{defclass PoincareBirkhoffWittLyndonBasisType}
(defclass |PoincareBirkhoffWittLyndonBasisType| (|OrderedSetType| |RetractableToType|)
  ((parents :initform '(|OrderedSet| |RetractableTo|))
   (name :initform "PoincareBirkhoffWittLyndonBasis")
   (marker :initform 'domain)
   (abbreviation :initform 'PBWLB)
   (comment :initform (list
     "This domain provides the internal representation"
     "of polynomials in non-commutative variables written"
     "over the Poincare-Birkhoff-Witt basis."
     "See the XPBWPolynomial domain constructor."
     "See Free Lie Algebras by C. Reutenauer "))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PoincareBirkhoffWittLyndonBasis|
  (progn
    (push '|PoincareBirkhoffWittLyndonBasis| *Domains*)
    (make-instance '|PoincareBirkhoffWittLyndonBasisType|)))

\end{chunk}

\subsection{Point}
\index[dom]{Point!Domain}
\index[dom]{Domain!Point}
\index[dom]{POINT}
\begin{chunk}{defclass PointType}
(defclass |PointType| (|PointCategoryType|)
  ((parents :initform '(|PointCategory|))
   (name :initform "Point")
   (marker :initform 'domain)
   (abbreviation :initform 'POINT)
   (comment :initform (list
     "This domain implements points in coordinate space"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Point|
  (progn
    (push '|Point| *Domains*)
    (make-instance '|PointType|)))

\end{chunk}

\subsection{Polynomial}
\index[dom]{Polynomial!Domain}
\index[dom]{Domain!Polynomial}
\index[dom]{POLY}
\begin{chunk}{defclass PolynomialType}
(defclass |PolynomialType| (|PolynomialCategoryType|)
  ((parents :initform '(|PolynomialCategory|))
   (name :initform "Polynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'POLY)
   (comment :initform (list
     "This type is the basic representation of sparse recursive multivariate"
     "polynomials whose variables are arbitrary symbols. The ordering"
     "is alphabetic determined by the Symbol type."
     "The coefficient ring may be non commutative,"
     "but the variables are assumed to commute."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Polynomial|
  (progn
    (push '|Polynomial| *Domains*)
    (make-instance '|PolynomialType|)))

\end{chunk}

\subsection{PolynomialIdeals}
\index[dom]{PolynomialIdeals!Domain}
\index[dom]{Domain!PolynomialIdeals}
\index[dom]{IDEAL}
\begin{chunk}{defclass PolynomialIdealsType}
(defclass |PolynomialIdealsType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "PolynomialIdeals")
   (marker :initform 'domain)
   (abbreviation :initform 'IDEAL)
   (comment :initform (list
     "This domain represents polynomial ideals with coefficients in any"
     "field and supports the basic ideal operations, including intersection"
     "sum and quotient."
     "An ideal is represented by a list of polynomials (the generators of"
     "the ideal) and a boolean that is true if the generators are a Groebner"
     "basis."
     "The algorithms used are based on Groebner basis computations. The"
     "ordering is determined by the datatype of the input polynomials."
     "Users may use refinements of total degree orderings."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialIdeals|
  (progn
    (push '|PolynomialIdeals| *Domains*)
    (make-instance '|PolynomialIdealsType|)))

\end{chunk}

\subsection{PolynomialRing}
\index[dom]{PolynomialRing!Domain}
\index[dom]{Domain!PolynomialRing}
\index[dom]{PR}
\begin{chunk}{defclass PolynomialRingType}
(defclass |PolynomialRingType| (|FiniteAbelianMonoidRingType|)
  ((parents :initform '(|FiniteAbelianMonoidRing|))
   (name :initform "PolynomialRing")
   (marker :initform 'domain)
   (abbreviation :initform 'PR)
   (comment :initform (list
     "This domain represents generalized polynomials with coefficients"
     "(from a not necessarily commutative ring), and terms"
     "indexed by their exponents (from an arbitrary ordered abelian monoid)."
     "This type is used, for example,"
     "by the DistributedMultivariatePolynomial domain where"
     "the exponent domain is a direct product of non negative integers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialRing|
  (progn
    (push '|PolynomialRing| *Domains*)
    (make-instance '|PolynomialRingType|)))

\end{chunk}

\subsection{PositiveInteger}
\index[dom]{PositiveInteger!Domain}
\index[dom]{Domain!PositiveInteger}
\index[dom]{PI}
\begin{chunk}{defclass PositiveIntegerType}
(defclass |PositiveIntegerType| (|OrderedSetType| |MonoidType| |AbelianSemiGroupType|)
  ((parents :initform '(|OrderedSet| |Monoid| |AbelianSemiGroup|))
   (name :initform "PositiveInteger")
   (marker :initform 'domain)
   (abbreviation :initform 'PI)
   (comment :initform (list
     "PositiveInteger provides functions for positive integers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PositiveInteger|
  (progn
    (push '|PositiveInteger| *Domains*)
    (make-instance '|PositiveIntegerType|)))

\end{chunk}

\subsection{PrimeField}
\index[dom]{PrimeField!Domain}
\index[dom]{Domain!PrimeField}
\index[dom]{PF}
\begin{chunk}{defclass PrimeFieldType}
(defclass |PrimeFieldType| (|ConvertibleToType|
                            |FiniteAlgebraicExtensionFieldType|)
  ((parents :initform '(|ConvertibleTo| 
                        |FiniteAlgebraicExtensionField|))
   (name :initform "PrimeField")
   (marker :initform 'domain)
   (abbreviation :initform 'PF)
   (comment :initform (list
     "PrimeField(p) implements the field with p elements if p is a prime number."
     "Error: if p is not prime."
     "Note: this domain does not check that argument is a prime."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PrimeField|
  (progn
    (push '|PrimeField| *Domains*)
    (make-instance '|PrimeFieldType|)))

\end{chunk}

\subsection{PrimitiveArray}
\index[dom]{PrimitiveArray!Domain}
\index[dom]{Domain!PrimitiveArray}
\index[dom]{PRIMARR}
\begin{chunk}{defclass PrimitiveArrayType}
(defclass |PrimitiveArrayType| (|OneDimensionalArrayAggregateType|)
  ((parents :initform '(|OneDimensionalArrayAggregate|))
   (name :initform "PrimitiveArray")
   (marker :initform 'domain)
   (abbreviation :initform 'PRIMARR)
   (comment :initform (list
     "This provides a fast array type with no bound checking on elt's."
     "Minimum index is 0 in this type, cannot be changed"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PrimitiveArray|
  (progn
    (push '|PrimitiveArray| *Domains*)
    (make-instance '|PrimitiveArrayType|)))

\end{chunk}

\subsection{Product}
\index[dom]{Product!Domain}
\index[dom]{Domain!Product}
\index[dom]{PRODUCT}
\begin{chunk}{defclass ProductType}
(defclass |ProductType| (|AbelianGroupType|
                         |FiniteType|
                         |GroupType|
                         |OrderedAbelianMonoidSupType|)
  ((parents :initform '(|AbelianGroup| |Finite| |Group| |OrderedAbelianMonoidSup|))
   (name :initform "Product")
   (marker :initform 'domain)
   (abbreviation :initform 'PRODUCT)
   (comment :initform (list
     "This domain implements cartesian product"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Product|
  (progn
    (push '|Product| *Domains*)
    (make-instance '|ProductType|)))

\end{chunk}

\subsection{ProjectivePlane}
\index[dom]{ProjectivePlane!Domain}
\index[dom]{Domain!ProjectivePlane}
\index[dom]{PROJPL}
\begin{chunk}{defclass ProjectivePlaneType}
(defclass |ProjectivePlaneType| (|ProjectiveSpaceCategoryType|)
  ((parents :initform '(|ProjectiveSpaceCategory|))
   (name :initform "ProjectivePlane")
   (marker :initform 'domain)
   (abbreviation :initform 'PROJPL)
   (comment :initform (list
     "This is part of the PAFF package, related to projective space."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ProjectivePlane|
  (progn
    (push '|ProjectivePlane| *Domains*)
    (make-instance '|ProjectivePlaneType|)))

\end{chunk}

\subsection{ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteField}
\index[dom]{ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteField!Domain}
\index[dom]{Domain!ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteField}
\index[dom]{PROJPLPS}
\begin{chunk}{defclass ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteFieldType}
(defclass |ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteFieldType| (|ProjectiveSpaceCategoryType|)
  ((parents :initform '(|ProjectiveSpaceCategory|))
   (name :initform "ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteField")
   (marker :initform 'domain)
   (abbreviation :initform 'PROJPLPS)
   (comment :initform (list
     "This is part of the PAFF package, related to projective space."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteField|
  (progn
    (push '|ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteField| *Domains*)
    (make-instance '|ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteFieldType|)))

\end{chunk}

\subsection{ProjectiveSpace}
\index[dom]{ProjectiveSpace!Domain}
\index[dom]{Domain!ProjectiveSpace}
\index[dom]{PROJSP}
\begin{chunk}{defclass ProjectiveSpaceType}
(defclass |ProjectiveSpaceType| (|ProjectiveSpaceCategoryType|)
  ((parents :initform '(|ProjectiveSpaceCategory|))
   (name :initform "ProjectiveSpace")
   (marker :initform 'domain)
   (abbreviation :initform 'PROJSP)
   (comment :initform (list
     "This is part of the PAFF package, related to projective space."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ProjectiveSpace|
  (progn
    (push '|ProjectiveSpace| *Domains*)
    (make-instance '|ProjectiveSpaceType|)))

\end{chunk}

\subsection{PseudoAlgebraicClosureOfAlgExtOfRationalNumber}
\index[dom]{PseudoAlgebraicClosureOfAlgExtOfRationalNumber!Domain}
\index[dom]{Domain!PseudoAlgebraicClosureOfAlgExtOfRationalNumber}
\index[dom]{PACEXT}
\begin{chunk}{defclass PseudoAlgebraicClosureOfAlgExtOfRationalNumberType}
(defclass |PseudoAlgebraicClosureOfAlgExtOfRationalNumberType| (
                    |PseudoAlgebraicClosureOfAlgExtOfRationalNumberCategoryType|)
  ((parents :initform '(|PseudoAlgebraicClosureOfAlgExtOfRationalNumberCategory|))
   (name :initform "PseudoAlgebraicClosureOfAlgExtOfRationalNumber")
   (marker :initform 'domain)
   (abbreviation :initform 'PACEXT)
   (comment :initform (list
     "This domain implement dynamic extension over the"
     "PseudoAlgebraicClosureOfRationalNumber."
     "A tower extension T  of the ground field K is any sequence of field"
     "extension (T : K_0, K_1, ..., K_i...,K_n) where K_0 = K"
     "and for i =1,2,...,n, K_i is an extension of K_{i-1} of degree > 1"
     "and defined by an irreducible polynomial p(Z) in K_{i-1}."
     "Two towers (T_1: K_01, K_11,...,K_i1,...,K_n1) and "
     "(T_2: K_02, K_12,...,K_i2,...,K_n2)"
     "are said to be related if T_1 <= T_2 (or T_1 >= T_2),"
     "that is if K_i1 = K_i2 for i=1,2,...,n1"
     "(or i=1,2,...,n2). Any algebraic operations defined for several elements"
     "are only defined if all of the concerned elements are comming from"
     "a set of related tour extensions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PseudoAlgebraicClosureOfAlgExtOfRationalNumber|
  (progn
    (push '|PseudoAlgebraicClosureOfAlgExtOfRationalNumber| *Domains*)
    (make-instance '|PseudoAlgebraicClosureOfAlgExtOfRationalNumberType|)))

\end{chunk}

\subsection{PseudoAlgebraicClosureOfFiniteField}
\index[dom]{PseudoAlgebraicClosureOfFiniteField!Domain}
\index[dom]{Domain!PseudoAlgebraicClosureOfFiniteField}
\index[dom]{PACOFF}
\begin{chunk}{defclass PseudoAlgebraicClosureOfFiniteFieldType}
(defclass |PseudoAlgebraicClosureOfFiniteFieldType| (|PseudoAlgebraicClosureOfFiniteFieldCategoryType| 
                                                     |ExtensionFieldType|)
  ((parents :initform '(|PseudoAlgebraicClosureOfFiniteFieldCategory| |ExtensionField|))
   (name :initform "PseudoAlgebraicClosureOfFiniteField")
   (marker :initform 'domain)
   (abbreviation :initform 'PACOFF)
   (comment :initform (list
     "This domain implement  dynamic extension using the simple notion of"
     "tower extensions. A tower extension T  of the ground  field K is any"
     "sequence of field extension (T : K_0, K_1, ..., K_i...,K_n) where K_0 = K"
     "and for i =1,2,...,n, K_i is an extension of K_{i-1} of degree > 1 and"
     "defined by an irreducible polynomial p(Z) in K_{i-1}."
     "Two towers (T_1: K_01, K_11,...,K_i1,...,K_n1)"
     "and (T_2: K_02, K_12,...,K_i2,...,K_n2) are said to be related"
     "if T_1 <= T_2 (or T_1 >= T_2), that is if K_i1 = K_i2 for i=1,2,...,n1"
     "(or i=1,2,...,n2). Any algebraic operations defined for several elements"
     "are only defined if all of the concerned elements are comming from"
     "a set of related tour extensions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PseudoAlgebraicClosureOfFiniteField|
  (progn
    (push '|PseudoAlgebraicClosureOfFiniteField| *Domains*)
    (make-instance '|PseudoAlgebraicClosureOfFiniteFieldType|)))

\end{chunk}

\subsection{PseudoAlgebraicClosureOfRationalNumber}
\index[dom]{PseudoAlgebraicClosureOfRationalNumber!Domain}
\index[dom]{Domain!PseudoAlgebraicClosureOfRationalNumber}
\index[dom]{PACRAT}
\begin{chunk}{defclass PseudoAlgebraicClosureOfRationalNumberType}
(defclass |PseudoAlgebraicClosureOfRationalNumberType| (
                        |PseudoAlgebraicClosureOfRationalNumberCategoryType|)
  ((parents :initform '(|PseudoAlgebraicClosureOfRationalNumberCategory|))
   (name :initform "PseudoAlgebraicClosureOfRationalNumber")
   (marker :initform 'domain)
   (abbreviation :initform 'PACRAT)
   (comment :initform (list
     "++ This domain implements dynamic extension using the simple notion of"
     "tower extensions. A tower extension T of the ground field K is any"
     "sequence of field extension (T : K_0, K_1, ..., K_i...,K_n) where K_0 = K"
     "and for i =1,2,...,n, K_i is an extension of K_{i-1} of degree > 1 and"
     "defined by an irreducible polynomial p(Z) in K_{i-1}."
     "Two towers (T_1: K_01, K_11,...,K_i1,...,K_n1) and"
     "(T_2: K_02, K_12,...,K_i2,...,K_n2) are said to be related if T_1 <= T_2"
     "(or T_1 >= T_2), that is if K_i1 = K_i2 for i=1,2,...,n1"
     "(or i=1,2,...,n2). Any algebraic operations defined for several elements"
     "are only defined if all of the concerned elements are comming from"
     "a set of related tour extensions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PseudoAlgebraicClosureOfRationalNumber|
  (progn
    (push '|PseudoAlgebraicClosureOfRationalNumber| *Domains*)
    (make-instance '|PseudoAlgebraicClosureOfRationalNumberType|)))

\end{chunk}

\section{Q}

\subsection{QuadraticForm}
\index[dom]{QuadraticForm!Domain}
\index[dom]{Domain!QuadraticForm}
\index[dom]{QFORM}
\begin{chunk}{defclass QuadraticFormType}
(defclass |QuadraticFormType| (|AbelianGroupType|)
  ((parents :initform '(|AbelianGroup|))
   (name :initform "QuadraticForm")
   (marker :initform 'domain)
   (abbreviation :initform 'QFORM)
   (comment :initform (list
     "This domain provides modest support for quadratic forms."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |QuadraticForm|
  (progn
    (push '|QuadraticForm| *Domains*)
    (make-instance '|QuadraticFormType|)))

\end{chunk}

\subsection{QuasiAlgebraicSet}
\index[dom]{QuasiAlgebraicSet!Domain}
\index[dom]{Domain!QuasiAlgebraicSet}
\index[dom]{QALGSET}
\begin{chunk}{defclass QuasiAlgebraicSetType}
(defclass |QuasiAlgebraicSetType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "QuasiAlgebraicSet")
   (marker :initform 'domain)
   (abbreviation :initform 'QALGSET)
   (comment :initform (list
     "QuasiAlgebraicSet constructs a domain representing"
     "quasi-algebraic sets, which is the intersection of a Zariski"
     "closed set, defined as the common zeros of a given list of"
     "polynomials (the defining polynomials for equations), and a principal"
     "Zariski open set, defined as the complement of the common"
     "zeros of a polynomial f (the defining polynomial for the inequation)."
     "This domain provides simplification of a user-given representation"
     "using groebner basis computations."
     "There are two simplification routines: the first function"
     "idealSimplify  uses groebner"
     "basis of ideals alone, while the second, simplify uses both"
     "groebner basis and factorization.  The resulting defining equations L"
     "always form a groebner basis, and the resulting defining"
     "inequation f is always reduced.  The function simplify may"
     "be applied several times if desired.   A third simplification"
     "routine radicalSimplify is provided in"
     "QuasiAlgebraicSet2  for comparison study only,"
     "as it is inefficient compared to the other two, as well as is"
     "restricted to only certain coefficient domains.  For detail analysis"
     "and a comparison of the three methods, please consult the reference"
     "cited."
     " "
     "A polynomial function q defined on the quasi-algebraic set"
     "is equivalent to its reduced form with respect to L.  While"
     "this may be obtained using the usual normal form"
     "algorithm, there is no canonical form for q."
     " "
     "The ordering in groebner basis computation is determined by"
     "the data type of the input polynomials.  If it is possible"
     "we suggest to use refinements of total degree orderings."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |QuasiAlgebraicSet|
  (progn
    (push '|QuasiAlgebraicSet| *Domains*)
    (make-instance '|QuasiAlgebraicSetType|)))

\end{chunk}

\subsection{Quaternion}
\index[dom]{Quaternion!Domain}
\index[dom]{Domain!Quaternion}
\index[dom]{QUAT}
\begin{chunk}{defclass QuaternionType}
(defclass |QuaternionType| (|QuaternionCategoryType|)
  ((parents :initform '(|QuaternionCategory|))
   (name :initform "Quaternion")
   (marker :initform 'domain)
   (abbreviation :initform 'QUAT)
   (comment :initform (list
     "Quaternion implements quaternions over a"
     "commutative ring. The main constructor function is quatern"
     "which takes 4 arguments: the real part, the i imaginary part, the j"
     "imaginary part and the k imaginary part."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Quaternion|
  (progn
    (push '|Quaternion| *Domains*)
    (make-instance '|QuaternionType|)))

\end{chunk}

\subsection{QueryEquation}
\index[dom]{QueryEquation!Domain}
\index[dom]{Domain!QueryEquation}
\index[dom]{QEQUAT}
\begin{chunk}{defclass QueryEquationType}
(defclass |QueryEquationType| (|CoercibleToType|)
  ((parents :initform '(|CoercibleTo|))
   (name :initform "QueryEquation")
   (marker :initform 'domain)
   (abbreviation :initform 'QEQUAT)
   (comment :initform (list
     "This domain implements simple database queries"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |QueryEquation|
  (progn
    (push '|QueryEquation| *Domains*)
    (make-instance '|QueryEquationType|)))

\end{chunk}

\subsection{Queue}
\index[dom]{Queue!Domain}
\index[dom]{Domain!Queue}
\index[dom]{QUEUE}
\begin{chunk}{defclass QueueType}
(defclass |QueueType| (|QueueAggregateType|)
  ((parents :initform '(|QueueAggregate|))
   (name :initform "Queue")
   (marker :initform 'domain)
   (abbreviation :initform 'QUEUE)
   (comment :initform (list
     "Linked List implementation of a Queue"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Queue|
  (progn
    (push '|Queue| *Domains*)
    (make-instance '|QueueType|)))

\end{chunk}

\section{R}

\subsection{RadicalFunctionField}
\index[dom]{RadicalFunctionField!Domain}
\index[dom]{Domain!RadicalFunctionField}
\index[dom]{RADFF}
\begin{chunk}{defclass RadicalFunctionFieldType}
(defclass |RadicalFunctionFieldType| (|FunctionFieldCategoryType|)
  ((parents :initform '(|FunctionFieldCategory|))
   (name :initform "RadicalFunctionField")
   (marker :initform 'domain)
   (abbreviation :initform 'RADFF)
   (comment :initform (list
     "Function field defined by y**n = f(x)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RadicalFunctionField|
  (progn
    (push '|RadicalFunctionField| *Domains*)
    (make-instance '|RadicalFunctionFieldType|)))

\end{chunk}

\subsection{RadixExpansion}
\index[dom]{RadixExpansion!Domain}
\index[dom]{Domain!RadixExpansion}
\index[dom]{RADIX}
\begin{chunk}{defclass RadixExpansionType}
(defclass |RadixExpansionType| (|QuotientFieldCategoryType|)
  ((parents :initform '(|QuotientFieldCategory|))
   (name :initform "RadixExpansion")
   (marker :initform 'domain)
   (abbreviation :initform 'RADIX)
   (comment :initform (list
     "This domain allows rational numbers to be presented as repeating"
     "decimal expansions or more generally as repeating expansions in any base."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RadixExpansion|
  (progn
    (push '|RadixExpansion| *Domains*)
    (make-instance '|RadixExpansionType|)))

\end{chunk}

\subsection{RealClosure}
\index[dom]{RealClosure!Domain}
\index[dom]{Domain!RealClosure}
\index[dom]{RECLOS}
\begin{chunk}{defclass RealClosureType}
(defclass |RealClosureType| (|RealClosedFieldType|)
  ((parents :initform '(|RealClosedField|))
   (name :initform "RealClosure")
   (marker :initform 'domain)
   (abbreviation :initform 'RECLOS)
   (comment :initform (list
     "This domain implements the real closure of an ordered field."
     "Note:"
     "The code here is generic it does not depend of the way the operations"
     "are done. The two macros PME and SEG should be passed as functorial"
     "arguments to the domain. It does not help much to write a category"
     "since non trivial methods cannot be placed there either."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RealClosure|
  (progn
    (push '|RealClosure| *Domains*)
    (make-instance '|RealClosureType|)))

\end{chunk}

\subsection{RectangularMatrix}
\index[dom]{RectangularMatrix!Domain}
\index[dom]{Domain!RectangularMatrix}
\index[dom]{RMATRIX}
\begin{chunk}{defclass RectangularMatrixType}
(defclass |RectangularMatrixType| (|ConvertibleToType|
                                   |RectangularMatrixCategoryType|
                                   |VectorSpaceType|)
  ((parents :initform '(|ConvertibleTo|
                        |RectangularMatrixCategory|
                        |VectorSpace|))
   (name :initform "RectangularMatrix")
   (marker :initform 'domain)
   (abbreviation :initform 'RMATRIX)
   (comment :initform (list
     "RectangularMatrix is a matrix domain where the number of rows"
     "and the number of columns are parameters of the domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RectangularMatrix|
  (progn
    (push '|RectangularMatrix| *Domains*)
    (make-instance '|RectangularMatrixType|)))

\end{chunk}

\subsection{Reference}
\index[dom]{Reference!Domain}
\index[dom]{Domain!Reference}
\index[dom]{REF}
\begin{chunk}{defclass ReferenceType}
(defclass |ReferenceType| (|TypeType| |SetCategoryType|)
  ((parents :initform '(|Type| |SetCategory|))
   (name :initform "Reference")
   (marker :initform 'domain)
   (abbreviation :initform 'REF)
   (comment :initform (list
     "Reference is for making a changeable instance of something."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Reference|
  (progn
    (push '|Reference| *Domains*)
    (make-instance '|ReferenceType|)))

\end{chunk}

\subsection{RegularChain}
\index[dom]{RegularChain!Domain}
\index[dom]{Domain!RegularChain}
\index[dom]{RGCHAIN}
\begin{chunk}{defclass RegularChainType}
(defclass |RegularChainType| (|RegularTriangularSetCategoryType|)
  ((parents :initform '(|RegularTriangularSetCategory|))
   (name :initform "RegularChain")
   (marker :initform 'domain)
   (abbreviation :initform 'RGCHAIN)
   (comment :initform (list
     "A domain for regular chains (regular triangular sets) over"
     "a Gcd-Domain and with a fix list of variables."
     "This is just a front-end for the RegularTriangularSet"
     "domain constructor."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RegularChain|
  (progn
    (push '|RegularChain| *Domains*)
    (make-instance '|RegularChainType|)))

\end{chunk}

\subsection{RegularTriangularSet}
\index[dom]{RegularTriangularSet!Domain}
\index[dom]{Domain!RegularTriangularSet}
\index[dom]{REGSET}
\begin{chunk}{defclass RegularTriangularSetType}
(defclass |RegularTriangularSetType| (|RegularTriangularSetCategoryType|)
  ((parents :initform '(|RegularTriangularSetCategory|))
   (name :initform "RegularTriangularSet")
   (marker :initform 'domain)
   (abbreviation :initform 'REGSET)
   (comment :initform (list
     "This domain provides an implementation of regular chains."
     "Moreover, the operation zeroSetSplit is an implementation of a new"
     "algorithm for solving polynomial systems by means of regular chains."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RegularTriangularSet|
  (progn
    (push '|RegularTriangularSet| *Domains*)
    (make-instance '|RegularTriangularSetType|)))

\end{chunk}

\subsection{ResidueRing}
\index[dom]{ResidueRing!Domain}
\index[dom]{Domain!ResidueRing}
\index[dom]{RESRING}
\begin{chunk}{defclass ResidueRingType}
(defclass |ResidueRingType| (|CommutativeRingType| |AlgebraType|)
  ((parents :initform '(|CommutativeRing| |Algebra|))
   (name :initform "ResidueRing")
   (marker :initform 'domain)
   (abbreviation :initform 'RESRING)
   (comment :initform (list
     "ResidueRing is the quotient of a polynomial ring by  an ideal."
     "The ideal is given as a list of generators. The elements of the domain"
     "are equivalence classes expressed in terms of reduced elements"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ResidueRing|
  (progn
    (push '|ResidueRing| *Domains*)
    (make-instance '|ResidueRingType|)))

\end{chunk}

\subsection{Result}
\index[dom]{Result!Domain}
\index[dom]{Domain!Result}
\index[dom]{RESULT}
\begin{chunk}{defclass ResultType}
(defclass |ResultType| (|TableAggregateType|)
  ((parents :initform '(|TableAggregate|))
   (name :initform "Result")
   (marker :initform 'domain)
   (abbreviation :initform 'RESULT)
   (comment :initform (list
     "A domain used to return the results from a call to the NAG"
     "Library.  It prints as a list of names and types, though the user may"
     "choose to display values automatically if he or she wishes."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Result|
  (progn
    (push '|Result| *Domains*)
    (make-instance '|ResultType|)))

\end{chunk}

\subsection{RewriteRule}
\index[dom]{RewriteRule!Domain}
\index[dom]{Domain!RewriteRule}
\index[dom]{RULE}
\begin{chunk}{defclass RewriteRuleType}
(defclass |RewriteRuleType| (|SetCategoryType| |RetractableToType| |EltableType|)
  ((parents :initform '(|SetCategory| |RetractableTo| |Eltable|))
   (name :initform "RewriteRule")
   (marker :initform 'domain)
   (abbreviation :initform 'RULE)
   (comment :initform (list
     "Rules for the pattern matcher"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RewriteRule|
  (progn
    (push '|RewriteRule| *Domains*)
    (make-instance '|RewriteRuleType|)))

\end{chunk}

\subsection{RightOpenIntervalRootCharacterization}
\index[dom]{RightOpenIntervalRootCharacterization!Domain}
\index[dom]{Domain!RightOpenIntervalRootCharacterization}
\index[dom]{ROIRC}
\begin{chunk}{defclass RightOpenIntervalRootCharacterizationType}
(defclass |RightOpenIntervalRootCharacterizationType| (|RealRootCharacterizationCategoryType|)
  ((parents :initform '(|RealRootCharacterizationCategory|))
   (name :initform "RightOpenIntervalRootCharacterization")
   (marker :initform 'domain)
   (abbreviation :initform 'ROIRC)
   (comment :initform (list
     "RightOpenIntervalRootCharacterization provides work with"
     "interval root coding."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RightOpenIntervalRootCharacterization|
  (progn
    (push '|RightOpenIntervalRootCharacterization| *Domains*)
    (make-instance '|RightOpenIntervalRootCharacterizationType|)))

\end{chunk}

\subsection{RomanNumeral}
\index[dom]{RomanNumeral!Domain}
\index[dom]{Domain!RomanNumeral}
\index[dom]{ROMAN}
\begin{chunk}{defclass RomanNumeralType}
(defclass |RomanNumeralType| (|IntegerNumberSystemType|)
  ((parents :initform '(|IntegerNumberSystem|))
   (name :initform "RomanNumeral")
   (marker :initform 'domain)
   (abbreviation :initform 'ROMAN)
   (comment :initform (list
     "RomanNumeral provides functions for converting"
     "integers to roman numerals."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RomanNumeral|
  (progn
    (push '|RomanNumeral| *Domains*)
    (make-instance '|RomanNumeralType|)))

\end{chunk}

\subsection{RoutinesTable}
\index[dom]{RoutinesTable!Domain}
\index[dom]{Domain!RoutinesTable}
\index[dom]{ROUTINE}
\begin{chunk}{defclass RoutinesTableType}
(defclass |RoutinesTableType| (|TableAggregateType|)
  ((parents :initform '(|TableAggregate|))
   (name :initform "RoutinesTable")
   (marker :initform 'domain)
   (abbreviation :initform 'ROUTINE)
   (comment :initform (list
     "RoutinesTable implements a database and associated tuning"
     "mechanisms for a set of known NAG routines"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RoutinesTable|
  (progn
    (push '|RoutinesTable| *Domains*)
    (make-instance '|RoutinesTableType|)))

\end{chunk}

\subsection{RuleCalled}
\index[dom]{RuleCalled!Domain}
\index[dom]{Domain!RuleCalled}
\index[dom]{RULECOLD}
\begin{chunk}{defclass RuleCalledType}
(defclass |RuleCalledType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "RuleCalled")
   (marker :initform 'domain)
   (abbreviation :initform 'RULECOLD)
   (comment :initform (list
     "This domain implements named rules "))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RuleCalled|
  (progn
    (push '|RuleCalled| *Domains*)
    (make-instance '|RuleCalledType|)))

\end{chunk}

\subsection{Ruleset}
\index[dom]{Ruleset!Domain}
\index[dom]{Domain!Ruleset}
\index[dom]{RULESET}
\begin{chunk}{defclass RulesetType}
(defclass |RulesetType| (|SetCategoryType| |EltableType|)
  ((parents :initform '(|SetCategory| |Eltable|))
   (name :initform "Ruleset")
   (marker :initform 'domain)
   (abbreviation :initform 'RULESET)
   (comment :initform (list
     "Sets of rules for the pattern matcher."
     "A ruleset is a set of pattern matching rules grouped together."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Ruleset|
  (progn
    (push '|Ruleset| *Domains*)
    (make-instance '|RulesetType|)))

\end{chunk}

\section{S}

\subsection{ScriptFormulaFormat}
\index[dom]{ScriptFormulaFormat!Domain}
\index[dom]{Domain!ScriptFormulaFormat}
\index[dom]{FORMULA}
\begin{chunk}{defclass ScriptFormulaFormatType}
(defclass |ScriptFormulaFormatType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "ScriptFormulaFormat")
   (marker :initform 'domain)
   (abbreviation :initform 'FORMULA)
   (comment :initform (list
     "ScriptFormulaFormat provides a coercion from"
     "OutputForm to IBM SCRIPT/VS Mathematical Formula Format."
     "The basic SCRIPT formula format object consists of three parts:"
     "a prologue, a formula part and an epilogue.  The functions"
     "prologue, formula and epilogue"
     "extract these parts, respectively.  The central parts of the expression"
     "go into the formula part.  The other parts can be set"
     "(setPrologue!, setEpilogue!) so that contain the"
     "appropriate tags for printing.  For example, the prologue and"
     "epilogue might simply contain ':df.'  and ':edf.'  so that the"
     "formula section will be printed in display math mode."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ScriptFormulaFormat|
  (progn
    (push '|ScriptFormulaFormat| *Domains*)
    (make-instance '|ScriptFormulaFormatType|)))

\end{chunk}

\subsection{Segment}
\index[dom]{Segment!Domain}
\index[dom]{Domain!Segment}
\index[dom]{SEG}
\begin{chunk}{defclass SegmentType}
(defclass |SegmentType| (|SetCategoryType| |SegmentExpansionCategoryType|)
  ((parents :initform '(|SetCategory| |SegmentExpansionCategory|))
   (name :initform "Segment")
   (marker :initform 'domain)
   (abbreviation :initform 'SEG)
   (comment :initform (list
     "This type is used to specify a range of values from type S."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Segment|
  (progn
    (push '|Segment| *Domains*)
    (make-instance '|SegmentType|)))

\end{chunk}

\subsection{SegmentBinding}
\index[dom]{SegmentBinding!Domain}
\index[dom]{Domain!SegmentBinding}
\index[dom]{SEGBIND}
\begin{chunk}{defclass SegmentBindingType}
(defclass |SegmentBindingType| (|TypeType| |SetCategoryType|)
  ((parents :initform '(|Type| |SetCategory|))
   (name :initform "SegmentBinding")
   (marker :initform 'domain)
   (abbreviation :initform 'SEGBIND)
   (comment :initform (list
     "This domain is used to provide the function argument syntax v=a..b."
     "This is used, for example, by the top-level draw functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SegmentBinding|
  (progn
    (push '|SegmentBinding| *Domains*)
    (make-instance '|SegmentBindingType|)))

\end{chunk}

\subsection{Set}
\index[dom]{Set!Domain}
\index[dom]{Domain!Set}
\index[dom]{SET}
\begin{chunk}{defclass SetType}
(defclass |SetType| (|FiniteSetAggregateType|)
  ((parents :initform '(|FiniteSetAggregate|))
   (name :initform "Set")
   (marker :initform 'domain)
   (abbreviation :initform 'SET)
   (comment :initform (list
     "A set over a domain D models the usual mathematical notion of a finite set"
     "of elements from D."
     "Sets are unordered collections of distinct elements"
     "(that is, order and duplication does not matter)."
     "The notation set [a,b,c] can be used to create"
     "a set and the usual operations such as union and intersection are available"
     "to form new sets."
     "In our implementation, Axiom maintains the entries in"
     "sorted order.  Specifically, the parts function returns the entries"
     "as a list in ascending order and"
     "the extract operation returns the maximum entry."
     "Given two sets s and t where #s = m and #t = n,"
     "the complexity of"
     "     s = t is O(min(n,m)"
     "     s < t is O(max(n,m)"
     "     union(s,t), intersect(s,t), minus(s,t)"
     "        symmetricDifference(s,t) is O(max(n,m)"
     "     member(x,t) is O(n log n)"
     "     insert(x,t) and remove(x,t) is O(n)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Set|
  (progn
    (push '|Set| *Domains*)
    (make-instance '|SetType|)))

\end{chunk}

\subsection{SetOfMIntegersInOneToN}
\index[dom]{SetOfMIntegersInOneToN!Domain}
\index[dom]{Domain!SetOfMIntegersInOneToN}
\index[dom]{SETMN}
\begin{chunk}{defclass SetOfMIntegersInOneToNType}
(defclass |SetOfMIntegersInOneToNType| (|FiniteType|)
  ((parents :initform '(|Finite|))
   (name :initform "SetOfMIntegersInOneToN")
   (marker :initform 'domain)
   (abbreviation :initform 'SETMN)
   (comment :initform (list
     "SetOfMIntegersInOneToN implements the subsets of M integers"
     "in the interval [1..n]"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SetOfMIntegersInOneToN|
  (progn
    (push '|SetOfMIntegersInOneToN| *Domains*)
    (make-instance '|SetOfMIntegersInOneToNType|)))

\end{chunk}

\subsection{SequentialDifferentialPolynomial}
\index[dom]{SequentialDifferentialPolynomial!Domain}
\index[dom]{Domain!SequentialDifferentialPolynomial}
\index[dom]{SDPOL}
\begin{chunk}{defclass SequentialDifferentialPolynomialType}
(defclass |SequentialDifferentialPolynomialType| (|DifferentialPolynomialCategoryType|)
  ((parents :initform '(|DifferentialPolynomialCategory|))
   (name :initform "SequentialDifferentialPolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'SDPOL)
   (comment :initform (list
     "SequentialDifferentialPolynomial implements"
     "an ordinary differential polynomial ring in arbitrary number"
     "of differential indeterminates, with coefficients in a"
     "ring.  The ranking on the differential indeterminate is sequential."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SequentialDifferentialPolynomial|
  (progn
    (push '|SequentialDifferentialPolynomial| *Domains*)
    (make-instance '|SequentialDifferentialPolynomialType|)))

\end{chunk}

\subsection{SequentialDifferentialVariable}
\index[dom]{SequentialDifferentialVariable!Domain}
\index[dom]{Domain!SequentialDifferentialVariable}
\index[dom]{SDVAR}
\begin{chunk}{defclass SequentialDifferentialVariableType}
(defclass |SequentialDifferentialVariableType| (|DifferentialVariableCategoryType|)
  ((parents :initform '(|DifferentialVariableCategory|))
   (name :initform "SequentialDifferentialVariable")
   (marker :initform 'domain)
   (abbreviation :initform 'SDVAR)
   (comment :initform (list
     "OrderlyDifferentialVariable adds a commonly used sequential"
     "ranking to the set of derivatives of an ordered list of differential"
     "indeterminates.  A sequential ranking is a ranking < of the"
     "derivatives with the property that for any derivative v,"
     "there are only a finite number of derivatives u with u < v."
     "This domain belongs to DifferentialVariableCategory. It"
     "defines weight to be just order, and it"
     "defines a sequential ranking < on derivatives u by the"
     "lexicographic order on the pair"
     "(variable(u), order(u))."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SequentialDifferentialVariable|
  (progn
    (push '|SequentialDifferentialVariable| *Domains*)
    (make-instance '|SequentialDifferentialVariableType|)))

\end{chunk}

\subsection{SExpression}
\index[dom]{SExpression!Domain}
\index[dom]{Domain!SExpression}
\index[dom]{SEX}
\begin{chunk}{defclass SExpressionType}
(defclass |SExpressionType| (|SExpressionCategoryType|)
  ((parents :initform '(|SExpressionCategory|))
   (name :initform "SExpression")
   (marker :initform 'domain)
   (abbreviation :initform 'SEX)
   (comment :initform (list
     "This domain allows the manipulation of the usual Lisp values"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SExpression|
  (progn
    (push '|SExpression| *Domains*)
    (make-instance '|SExpressionType|)))

\end{chunk}

\subsection{SExpressionOf}
\index[dom]{SExpressionOf!Domain}
\index[dom]{Domain!SExpressionOf}
\index[dom]{SEXOF}
\begin{chunk}{defclass SExpressionOfType}
(defclass |SExpressionOfType| (|SExpressionCategoryType|)
  ((parents :initform '(|SExpressionCategory|))
   (name :initform "SExpressionOf")
   (marker :initform 'domain)
   (abbreviation :initform 'SEXOF)
   (comment :initform (list
     "This domain allows the manipulation of Lisp values over"
     "arbitrary atomic types."
     "Allows the names of the atomic types to be chosen."
     "Warning: Although the parameters are declared only to be Sets,"
     "they must have the appropriate representations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SExpressionOf|
  (progn
    (push '|SExpressionOf| *Domains*)
    (make-instance '|SExpressionOfType|)))

\end{chunk}

\subsection{SimpleAlgebraicExtension}
\index[dom]{SimpleAlgebraicExtension!Domain}
\index[dom]{Domain!SimpleAlgebraicExtension}
\index[dom]{SAE}
\begin{chunk}{defclass SimpleAlgebraicExtensionType}
(defclass |SimpleAlgebraicExtensionType| (|MonogenicAlgebraType|)
  ((parents :initform '(|MonogenicAlgebra|))
   (name :initform "SimpleAlgebraicExtension")
   (marker :initform 'domain)
   (abbreviation :initform 'SAE)
   (comment :initform (list
     "Algebraic extension of a ring by a single polynomial."
     "Domain which represents simple algebraic extensions of arbitrary"
     "rings. The first argument to the domain, R, is the underlying ring,"
     "the second argument is a domain of univariate polynomials over K,"
     "while the last argument specifies the defining minimal polynomial."
     "The elements of the domain are canonically represented as polynomials"
     "of degree less than that of the minimal polynomial with coefficients"
     "in R. The second argument is both the type of the third argument and"
     "the underlying representation used by SAE itself."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SimpleAlgebraicExtension|
  (progn
    (push '|SimpleAlgebraicExtension| *Domains*)
    (make-instance '|SimpleAlgebraicExtensionType|)))

\end{chunk}

\subsection{SimpleCell}
\index[dom]{SimpleCell!Domain}
\index[dom]{Domain!SimpleCell}
\index[dom]{SCELL}
\begin{chunk}{defclass SimpleCellType}
(defclass |SimpleCellType| (|CoercibleToType|)
  ((parents :initform '(|CoercibleTo|))
   (name :initform "SimpleCell")
   (marker :initform 'domain)
   (abbreviation :initform 'SCELL)
   (comment :initform nil)
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SimpleCell|
  (progn
    (push '|SimpleCell| *Domains*)
    (make-instance '|SimpleCellType|)))

\end{chunk}

\subsection{SimpleFortranProgram}
\index[dom]{SimpleFortranProgram!Domain}
\index[dom]{Domain!SimpleFortranProgram}
\index[dom]{SFORT}
\begin{chunk}{defclass SimpleFortranProgramType}
(defclass |SimpleFortranProgramType| (|FortranProgramCategoryType|)
  ((parents :initform '(|FortranProgramCategory|))
   (name :initform "SimpleFortranProgram")
   (marker :initform 'domain)
   (abbreviation :initform 'SFORT)
   (comment :initform (list
     "SimpleFortranProgram(f,type) provides a simple model of some"
     "FORTRAN subprograms, making it possible to coerce objects of various"
     "domains into a FORTRAN subprogram called f."
     "These can then be translated into legal FORTRAN code."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SimpleFortranProgram|
  (progn
    (push '|SimpleFortranProgram| *Domains*)
    (make-instance '|SimpleFortranProgramType|)))

\end{chunk}

\subsection{SingleInteger}
\index[dom]{SingleInteger!Domain}
\index[dom]{Domain!SingleInteger}
\index[dom]{SINT}
\begin{chunk}{defclass SingleIntegerType}
(defclass |SingleIntegerType| (|OpenMathType| |LogicType| |IntegerNumberSystemType|)
  ((parents :initform '(|OpenMath| |Logic| |IntegerNumberSystem|))
   (name :initform "SingleInteger")
   (marker :initform 'domain)
   (abbreviation :initform 'SINT)
   (comment :initform (list
     "SingleInteger is intended to support machine integer arithmetic."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SingleInteger|
  (progn
    (push '|SingleInteger| *Domains*)
    (make-instance '|SingleIntegerType|)))

\end{chunk}

\subsection{SingletonAsOrderedSet}
\index[dom]{SingletonAsOrderedSet!Domain}
\index[dom]{Domain!SingletonAsOrderedSet}
\index[dom]{SAOS}
\begin{chunk}{defclass SingletonAsOrderedSetType}
(defclass |SingletonAsOrderedSetType| (|OrderedSetType|)
  ((parents :initform '(|OrderedSet|))
   (name :initform "SingletonAsOrderedSet")
   (marker :initform 'domain)
   (abbreviation :initform 'SAOS)
   (comment :initform (list
     "This trivial domain lets us build Univariate Polynomials"
     "in an anonymous variable"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SingletonAsOrderedSet|
  (progn
    (push '|SingletonAsOrderedSet| *Domains*)
    (make-instance '|SingletonAsOrderedSetType|)))

\end{chunk}

\subsection{SparseEchelonMatrix}
\index[dom]{SparseEchelonMatrix!Domain}
\index[dom]{Domain!SparseEchelonMatrix}
\index[dom]{SEM}
\begin{chunk}{defclass SparseEchelonMatrixType}
(defclass |SparseEchelonMatrixType| (|CoercibleToType|)
  ((parents :initform '(|CoercibleTo|))
   (name :initform "SparseEchelonMatrix")
   (marker :initform 'domain)
   (abbreviation :initform 'SEM)
   (comment :initform (list
     "SparseEchelonMatrix(C, D) implements sparse matrices whose columns"
     "are enumerated by the OrderedSet C and whose entries"
     "belong to the GcdDomain D. The basic operation of"
     "this domain is the computation of an row echelon form. The used algorithm"
     "tries to maintain the sparsity and is especially adapted to matrices who"
     "are already close to a row echelon form."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SparseEchelonMatrix|
  (progn
    (push '|SparseEchelonMatrix| *Domains*)
    (make-instance '|SparseEchelonMatrixType|)))

\end{chunk}

\subsection{SparseMultivariatePolynomial}
\index[dom]{SparseMultivariatePolynomial!Domain}
\index[dom]{Domain!SparseMultivariatePolynomial}
\index[dom]{SMP}
\begin{chunk}{defclass SparseMultivariatePolynomialType}
(defclass |SparseMultivariatePolynomialType| (|PolynomialCategoryType|)
  ((parents :initform '(|PolynomialCategory|))
   (name :initform "SparseMultivariatePolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'SMP)
   (comment :initform (list
     "This type is the basic representation of sparse recursive multivariate"
     "polynomials. It is parameterized by the coefficient ring and the"
     "variable set which may be infinite. The variable ordering is determined"
     "by the variable set parameter. The coefficient ring may be non-commutative,"
     "but the variables are assumed to commute."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SparseMultivariatePolynomial|
  (progn
    (push '|SparseMultivariatePolynomial| *Domains*)
    (make-instance '|SparseMultivariatePolynomialType|)))

\end{chunk}

\subsection{SparseMultivariateTaylorSeries}
\index[dom]{SparseMultivariateTaylorSeries!Domain}
\index[dom]{Domain!SparseMultivariateTaylorSeries}
\index[dom]{SMTS}
\begin{chunk}{defclass SparseMultivariateTaylorSeriesType}
(defclass |SparseMultivariateTaylorSeriesType| (|MultivariateTaylorSeriesCategoryType|)
  ((parents :initform '(|MultivariateTaylorSeriesCategory|))
   (name :initform "SparseMultivariateTaylorSeries")
   (marker :initform 'domain)
   (abbreviation :initform 'SMTS)
   (comment :initform (list
     "This domain provides multivariate Taylor series with variables"
     "from an arbitrary ordered set.  A Taylor series is represented"
     "by a stream of polynomials from the polynomial domain SMP."
     "The nth element of the stream is a form of degree n.  SMTS is an"
     "internal domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SparseMultivariateTaylorSeries|
  (progn
    (push '|SparseMultivariateTaylorSeries| *Domains*)
    (make-instance '|SparseMultivariateTaylorSeriesType|)))

\end{chunk}

\subsection{SparseTable}
\index[dom]{SparseTable!Domain}
\index[dom]{Domain!SparseTable}
\index[dom]{STBL}
\begin{chunk}{defclass SparseTableType}
(defclass |SparseTableType| (|TableAggregateType|)
  ((parents :initform '(|TableAggregate|))
   (name :initform "SparseTable")
   (marker :initform 'domain)
   (abbreviation :initform 'STBL)
   (comment :initform (list
     "A sparse table has a default entry, which is returned if no other"
     "value has been explicitly stored for a key."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SparseTable|
  (progn
    (push '|SparseTable| *Domains*)
    (make-instance '|SparseTableType|)))

\end{chunk}

\subsection{SparseUnivariateLaurentSeries}
\index[dom]{SparseUnivariateLaurentSeries!Domain}
\index[dom]{Domain!SparseUnivariateLaurentSeries}
\index[dom]{SULS}
\begin{chunk}{defclass SparseUnivariateLaurentSeriesType}
(defclass |SparseUnivariateLaurentSeriesType| (|UnivariateLaurentSeriesConstructorCategoryType|)
  ((parents :initform '(|UnivariateLaurentSeriesConstructorCategory|))
   (name :initform "SparseUnivariateLaurentSeries")
   (marker :initform 'domain)
   (abbreviation :initform 'SULS)
   (comment :initform (list
     "SparseUnivariateLaurentSeries is a domain representing Laurent"
     "series in one variable with coefficients in an arbitrary ring.  The"
     "parameters of the type specify the coefficient ring, the power series"
     "variable, and the center of the power series expansion.  For example,"
     "SparseUnivariateLaurentSeries(Integer,x,3) represents Laurent"
     "series in (x - 3) with integer coefficients."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SparseUnivariateLaurentSeries|
  (progn
    (push '|SparseUnivariateLaurentSeries| *Domains*)
    (make-instance '|SparseUnivariateLaurentSeriesType|)))

\end{chunk}

\subsection{SparseUnivariatePolynomial}
\index[dom]{SparseUnivariatePolynomial!Domain}
\index[dom]{Domain!SparseUnivariatePolynomial}
\index[dom]{SUP}
\begin{chunk}{defclass SparseUnivariatePolynomialType}
(defclass |SparseUnivariatePolynomialType| (|UnivariatePolynomialCategoryType|)
  ((parents :initform '(|UnivariatePolynomialCategory|))
   (name :initform "SparseUnivariatePolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'SUP)
   (comment :initform (list
     "This domain represents univariate polynomials over arbitrary"
     "(not necessarily commutative) coefficient rings. The variable is"
     "unspecified  so that the variable displays as ? on output."
     "If it is necessary to specify the variable name,"
     "use type UnivariatePolynomial. The representation is sparse"
     "in the sense that only non-zero terms are represented."
     "Note that if the coefficient ring is a field,"
     "this domain forms a euclidean domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SparseUnivariatePolynomial|
  (progn
    (push '|SparseUnivariatePolynomial| *Domains*)
    (make-instance '|SparseUnivariatePolynomialType|)))

\end{chunk}

\subsection{SparseUnivariatePolynomialExpressions}
\index[dom]{SparseUnivariatePolynomialExpressions!Domain}
\index[dom]{Domain!SparseUnivariatePolynomialExpressions}
\index[dom]{SUPEXPR}
\begin{chunk}{defclass SparseUnivariatePolynomialExpressionsType}
(defclass |SparseUnivariatePolynomialExpressionsType| (|UnivariatePolynomialCategoryType|
                                                       |TranscendentalFunctionCategoryType|)
  ((parents :initform '(|UnivariatePolynomialCategory| |TranscendentalFunctionCategory|))
   (name :initform "SparseUnivariatePolynomialExpressions")
   (marker :initform 'domain)
   (abbreviation :initform 'SUPEXPR)
   (comment :initform (list
     "This domain has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SparseUnivariatePolynomialExpressions|
  (progn
    (push '|SparseUnivariatePolynomialExpressions| *Domains*)
    (make-instance '|SparseUnivariatePolynomialExpressionsType|)))

\end{chunk}

\subsection{SparseUnivariatePuiseuxSeries}
\index[dom]{SparseUnivariatePuiseuxSeries!Domain}
\index[dom]{Domain!SparseUnivariatePuiseuxSeries}
\index[dom]{SUPXS}
\begin{chunk}{defclass SparseUnivariatePuiseuxSeriesType}
(defclass |SparseUnivariatePuiseuxSeriesType| (|UnivariatePuiseuxSeriesConstructorCategoryType|)
  ((parents :initform '(|UnivariatePuiseuxSeriesConstructorCategory|))
   (name :initform "SparseUnivariatePuiseuxSeries")
   (marker :initform 'domain)
   (abbreviation :initform 'SUPXS)
   (comment :initform (list
     "Sparse Puiseux series in one variable"
     "SparseUnivariatePuiseuxSeries is a domain representing Puiseux"
     "series in one variable with coefficients in an arbitrary ring.  The"
     "parameters of the type specify the coefficient ring, the power series"
     "variable, and the center of the power series expansion.  For example,"
     "SparseUnivariatePuiseuxSeries(Integer,x,3) represents Puiseux"
     "series in (x - 3) with Integer coefficients."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SparseUnivariatePuiseuxSeries|
  (progn
    (push '|SparseUnivariatePuiseuxSeries| *Domains*)
    (make-instance '|SparseUnivariatePuiseuxSeriesType|)))

\end{chunk}

\subsection{SparseUnivariateSkewPolynomial}
\index[dom]{SparseUnivariateSkewPolynomial!Domain}
\index[dom]{Domain!SparseUnivariateSkewPolynomial}
\index[dom]{ORESUP}
\begin{chunk}{defclass SparseUnivariateSkewPolynomialType}
(defclass |SparseUnivariateSkewPolynomialType| (|UnivariateSkewPolynomialCategoryType|)
  ((parents :initform '(|UnivariateSkewPolynomialCategory|))
   (name :initform "SparseUnivariateSkewPolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'ORESUP)
   (comment :initform (list
     "This is the domain of sparse univariate skew polynomials over an Ore"
     "coefficient field."
     "The multiplication is given by x a = sigma(a) x + delta a."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SparseUnivariateSkewPolynomial|
  (progn
    (push '|SparseUnivariateSkewPolynomial| *Domains*)
    (make-instance '|SparseUnivariateSkewPolynomialType|)))

\end{chunk}

\subsection{SparseUnivariateTaylorSeries}
\index[dom]{SparseUnivariateTaylorSeries!Domain}
\index[dom]{Domain!SparseUnivariateTaylorSeries}
\index[dom]{SUTS}
\begin{chunk}{defclass SparseUnivariateTaylorSeriesType}
(defclass |SparseUnivariateTaylorSeriesType| (|UnivariateTaylorSeriesCategoryType|)
  ((parents :initform '(|UnivariateTaylorSeriesCategory|))
   (name :initform "SparseUnivariateTaylorSeries")
   (marker :initform 'domain)
   (abbreviation :initform 'SUTS)
   (comment :initform (list
     "SparseUnivariateTaylorSeries is a domain representing Taylor"
     "series in one variable with coefficients in an arbitrary ring.  The"
     "parameters of the type specify the coefficient ring, the power series"
     "variable, and the center of the power series expansion.  For example,"
     "SparseUnivariateTaylorSeries(Integer,x,3) represents Taylor"
     "series in (x - 3) with Integer coefficients."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SparseUnivariateTaylorSeries|
  (progn
    (push '|SparseUnivariateTaylorSeries| *Domains*)
    (make-instance '|SparseUnivariateTaylorSeriesType|)))

\end{chunk}

\subsection{SplitHomogeneousDirectProduct}
\index[dom]{SplitHomogeneousDirectProduct!Domain}
\index[dom]{Domain!SplitHomogeneousDirectProduct}
\index[dom]{SHDP}
\begin{chunk}{defclass SplitHomogeneousDirectProductType}
(defclass |SplitHomogeneousDirectProductType| (|DirectProductCategoryType|)
  ((parents :initform '(|DirectProductCategory|))
   (name :initform "SplitHomogeneousDirectProduct")
   (marker :initform 'domain)
   (abbreviation :initform 'SHDP)
   (comment :initform (list
     "This type represents the finite direct or cartesian product of an"
     "underlying ordered component type. The vectors are ordered as if"
     "they were split into two blocks. The dim1 parameter specifies the"
     "length of the first block. The ordering is lexicographic between"
     "the blocks but acts like HomogeneousDirectProduct"
     "within each block. This type is a suitable third argument for"
     "GeneralDistributedMultivariatePolynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SplitHomogeneousDirectProduct|
  (progn
    (push '|SplitHomogeneousDirectProduct| *Domains*)
    (make-instance '|SplitHomogeneousDirectProductType|)))

\end{chunk}

\subsection{SplittingNode}
\index[dom]{SplittingNode!Domain}
\index[dom]{Domain!SplittingNode}
\index[dom]{SPLNODE}
\begin{chunk}{defclass SplittingNodeType}
(defclass |SplittingNodeType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "SplittingNode")
   (marker :initform 'domain)
   (abbreviation :initform 'SPLNODE)
   (comment :initform (list
     "This domain exports a modest implementation for the"
     "vertices of splitting trees. These vertices are called"
     "here splitting nodes. Every of these nodes store 3 informations."
     "The first one is its value, that is the current expression"
     "to evaluate. The second one is its condition, that is the"
     "hypothesis under which the value has to be evaluated."
     "The last one is its status, that is a boolean flag"
     "which is true iff the value is the result of its"
     "evaluation under its condition. Two splitting vertices"
     "are equal iff they have the sane values and the same"
     "conditions (so their status do not matter)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SplittingNode|
  (progn
    (push '|SplittingNode| *Domains*)
    (make-instance '|SplittingNodeType|)))

\end{chunk}

\subsection{SplittingTree}
\index[dom]{SplittingTree!Domain}
\index[dom]{Domain!SplittingTree}
\index[dom]{SPLTREE}
\begin{chunk}{defclass SplittingTreeType}
(defclass |SplittingTreeType| (|RecursiveAggregateType|)
  ((parents :initform '(|RecursiveAggregate|))
   (name :initform "SplittingTree")
   (marker :initform 'domain)
   (abbreviation :initform 'SPLTREE)
   (comment :initform (list
     "This domain exports a modest implementation of splitting"
     "trees. Spliiting trees are needed when the"
     "evaluation of some quantity under some hypothesis"
     "requires to split the hypothesis into sub-cases."
     "For instance by adding some new hypothesis on one"
     "hand and its negation on another hand. The computations"
     "are terminated is a splitting tree a when"
     "status(value(a)) is true. Thus,"
     "if for the splitting tree a the flag"
     "status(value(a)) is true, then"
     "status(value(d)) is true for any"
     "subtree d of a. This property"
     "of splitting trees is called the termination"
     "condition. If no vertex in a splitting tree a"
     "is equal to another, a is said to satisfy"
     "the no-duplicates condition. The splitting "
     "tree a will satisfy this condition"
     "if nodes are added to \axiom{a} by mean of"
     "splitNodeOf! and if construct"
     "is only used to create the root of a"
     "with no children."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SplittingTree|
  (progn
    (push '|SplittingTree| *Domains*)
    (make-instance '|SplittingTreeType|)))

\end{chunk}

\subsection{SquareFreeRegularTriangularSet}
\index[dom]{SquareFreeRegularTriangularSet!Domain}
\index[dom]{Domain!SquareFreeRegularTriangularSet}
\index[dom]{SREGSET}
\begin{chunk}{defclass SquareFreeRegularTriangularSetType}
(defclass |SquareFreeRegularTriangularSetType| (|SquareFreeRegularTriangularSetCategoryType|)
  ((parents :initform '(|SquareFreeRegularTriangularSetCategory|))
   (name :initform "SquareFreeRegularTriangularSet")
   (marker :initform 'domain)
   (abbreviation :initform 'SREGSET)
   (comment :initform (list
     "This domain provides an implementation of square-free regular chains."
     "Moreover, the operation zeroSetSplit"
     "is an implementation of a new algorithm for solving polynomial systems by"
     "means of regular chains."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SquareFreeRegularTriangularSet|
  (progn
    (push '|SquareFreeRegularTriangularSet| *Domains*)
    (make-instance '|SquareFreeRegularTriangularSetType|)))

\end{chunk}

\subsection{SquareMatrix}
\index[dom]{SquareMatrix!Domain}
\index[dom]{Domain!SquareMatrix}
\index[dom]{SQMATRIX}
\begin{chunk}{defclass SquareMatrixType}
(defclass |SquareMatrixType| (|SquareMatrixCategoryType| |ConvertibleToType|)
  ((parents :initform '(|SquareMatrixCategory| |ConvertibleTo|))
   (name :initform "SquareMatrix")
   (marker :initform 'domain)
   (abbreviation :initform 'SQMATRIX)
   (comment :initform (list
     "SquareMatrix is a matrix domain of square matrices, where the"
     "number of rows (= number of columns) is a parameter of the type."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SquareMatrix|
  (progn
    (push '|SquareMatrix| *Domains*)
    (make-instance '|SquareMatrixType|)))

\end{chunk}

\subsection{Stack}
\index[dom]{Stack!Domain}
\index[dom]{Domain!Stack}
\index[dom]{STACK}
\begin{chunk}{defclass StackType}
(defclass |StackType| (|StackAggregateType|)
  ((parents :initform '(|StackAggregate|))
   (name :initform "Stack")
   (marker :initform 'domain)
   (abbreviation :initform 'STACK)
   (comment :initform (list
     "Linked List implementation of a Stack"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Stack|
  (progn
    (push '|Stack| *Domains*)
    (make-instance '|StackType|)))

\end{chunk}

\subsection{StochasticDifferential}
\index[dom]{StochasticDifferential!Domain}
\index[dom]{Domain!StochasticDifferential}
\index[dom]{SD}
\begin{chunk}{defclass StochasticDifferentialType}
(defclass |StochasticDifferentialType| (|RngType| |RetractableToType| |ModuleType|)
  ((parents :initform '(|Rng| |RetractableTo| |Module|))
   (name :initform "StochasticDifferential")
   (marker :initform 'domain)
   (abbreviation :initform 'SD)
   (comment :initform (list
     "A basic implementation of StochasticDifferential(R) using the"
     "associated domain BasicStochasticDifferential in the underlying"
     "representation as sparse multivariate polynomials. The domain is"
     "a module over Expression(R), and is a ring without identity"
     "(AXIOM term is 'Rng'). Note that separate instances, for example"
     "using R=Integer and R=Float, have different hidden structure"
     "(multiplication and drift tables)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StochasticDifferential|
  (progn
    (push '|StochasticDifferential| *Domains*)
    (make-instance '|StochasticDifferentialType|)))

\end{chunk}

\subsection{Stream}
\index[dom]{Stream!Domain}
\index[dom]{Domain!Stream}
\index[dom]{STREAM}
\begin{chunk}{defclass StreamType}
(defclass |StreamType| (|LazyStreamAggregateType|)
  ((parents :initform '(|LazyStreamAggregate|))
   (name :initform "Stream")
   (marker :initform 'domain)
   (abbreviation :initform 'STREAM)
   (comment :initform (list
     "A stream is an implementation of an infinite sequence using"
     "a list of terms that have been computed and a function closure"
     "to compute additional terms when needed."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Stream|
  (progn
    (push '|Stream| *Domains*)
    (make-instance '|StreamType|)))

\end{chunk}

\subsection{String}
\index[dom]{String!Domain}
\index[dom]{Domain!String}
\index[dom]{STRING}
\begin{chunk}{defclass StringType}
(defclass |StringType| (|StringCategoryType|)
  ((parents :initform '(|StringCategory|))
   (name :initform "String")
   (marker :initform 'domain)
   (abbreviation :initform 'STRING)
   (comment :initform (list
     "This is the domain of character strings. Strings are 1 based."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |String|
  (progn
    (push '|String| *Domains*)
    (make-instance '|StringType|)))

\end{chunk}

\subsection{StringTable}
\index[dom]{StringTable!Domain}
\index[dom]{Domain!StringTable}
\index[dom]{STRTBL}
\begin{chunk}{defclass StringTableType}
(defclass |StringTableType| (|TableAggregateType|)
  ((parents :initform '(|TableAggregate|))
   (name :initform "StringTable")
   (marker :initform 'domain)
   (abbreviation :initform 'STRTBL)
   (comment :initform (list
     "This domain provides tables where the keys are strings."
     "A specialized hash function for strings is used."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StringTable|
  (progn
    (push '|StringTable| *Domains*)
    (make-instance '|StringTableType|)))

\end{chunk}

\subsection{SubSpace}
\index[dom]{SubSpace!Domain}
\index[dom]{Domain!SubSpace}
\index[dom]{SUBSPACE}
\begin{chunk}{defclass SubSpaceType}
(defclass |SubSpaceType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "SubSpace")
   (marker :initform 'domain)
   (abbreviation :initform 'SUBSPACE)
   (comment :initform (list
     "This domain is not documented"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SubSpace|
  (progn
    (push '|SubSpace| *Domains*)
    (make-instance '|SubSpaceType|)))

\end{chunk}

\subsection{SubSpaceComponentProperty}
\index[dom]{SubSpaceComponentProperty!Domain}
\index[dom]{Domain!SubSpaceComponentProperty}
\index[dom]{COMPPROP}
\begin{chunk}{defclass SubSpaceComponentPropertyType}
(defclass |SubSpaceComponentPropertyType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "SubSpaceComponentProperty")
   (marker :initform 'domain)
   (abbreviation :initform 'COMPPROP)
   (comment :initform (list
     "This domain implements some global properties of subspaces."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SubSpaceComponentProperty|
  (progn
    (push '|SubSpaceComponentProperty| *Domains*)
    (make-instance '|SubSpaceComponentPropertyType|)))

\end{chunk}

\subsection{SuchThat}
\index[dom]{SuchThat!Domain}
\index[dom]{Domain!SuchThat}
\index[dom]{SUCH}
\begin{chunk}{defclass SuchThatType}
(defclass |SuchThatType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "SuchThat")
   (marker :initform 'domain)
   (abbreviation :initform 'SUCH)
   (comment :initform (list
     "This domain implements 'such that' forms"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SuchThat|
  (progn
    (push '|SuchThat| *Domains*)
    (make-instance '|SuchThatType|)))

\end{chunk}

\subsection{Switch}
\index[dom]{Switch!Domain}
\index[dom]{Domain!Switch}
\index[dom]{SWITCH}
\begin{chunk}{defclass SwitchType}
(defclass |SwitchType| (|CoercibleToType|)
  ((parents :initform '(|CoercibleTo|))
   (name :initform "Switch")
   (marker :initform 'domain)
   (abbreviation :initform 'SWITCH)
   (comment :initform (list
     "This domain builds representations of boolean expressions for use with"
     "the FortranCode domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Switch|
  (progn
    (push '|Switch| *Domains*)
    (make-instance '|SwitchType|)))

\end{chunk}

\subsection{Symbol}
\index[dom]{Symbol!Domain}
\index[dom]{Domain!Symbol}
\index[dom]{SYMBOL}
\begin{chunk}{defclass SymbolType}
(defclass |SymbolType| (|PatternMatchableType|
                        |OrderedSetType|
                        |OpenMathType|
                        |ConvertibleToType|)
  ((parents :initform '(|PatternMatchable|
                        |OrderedSet|
                        |OpenMath|
                        |ConvertibleTo|))
   (name :initform "Symbol")
   (marker :initform 'domain)
   (abbreviation :initform 'SYMBOL)
   (comment :initform (list
     "Basic and scripted symbols."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Symbol|
  (progn
    (push '|Symbol| *Domains*)
    (make-instance '|SymbolType|)))

\end{chunk}

\subsection{SymbolTable}
\index[dom]{SymbolTable!Domain}
\index[dom]{Domain!SymbolTable}
\index[dom]{SYMTAB}
\begin{chunk}{defclass SymbolTableType}
(defclass |SymbolTableType| (|CoercibleToType|)
  ((parents :initform '(|CoercibleTo|))
   (name :initform "SymbolTable")
   (marker :initform 'domain)
   (abbreviation :initform 'SYMTAB)
   (comment :initform (list
     "Create and manipulate a symbol table for generated FORTRAN code"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SymbolTable|
  (progn
    (push '|SymbolTable| *Domains*)
    (make-instance '|SymbolTableType|)))

\end{chunk}

\subsection{SymmetricPolynomial}
\index[dom]{SymmetricPolynomial!Domain}
\index[dom]{Domain!SymmetricPolynomial}
\index[dom]{SYMPOLY}
\begin{chunk}{defclass SymmetricPolynomialType}
(defclass |SymmetricPolynomialType| (|FiniteAbelianMonoidRingType|)
  ((parents :initform '(|FiniteAbelianMonoidRing|))
   (name :initform "SymmetricPolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'SYMPOLY)
   (comment :initform (list
     "This domain implements symmetric polynomial"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SymmetricPolynomial|
  (progn
    (push '|SymmetricPolynomial| *Domains*)
    (make-instance '|SymmetricPolynomialType|)))

\end{chunk}

\section{T}

\subsection{Table}
\index[dom]{Table!Domain}
\index[dom]{Domain!Table}
\index[dom]{TABLE}
\begin{chunk}{defclass TableType}
(defclass |TableType| (|TableAggregateType|)
  ((parents :initform '(|TableAggregate|))
   (name :initform "Table")
   (marker :initform 'domain)
   (abbreviation :initform 'TABLE)
   (comment :initform (list
     "This is the general purpose table type."
     "The keys are hashed to look up the entries."
     "This creates a HashTable if equal for the Key"
     "domain is consistent with Lisp EQUAL otherwise an"
     "AssociationList"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Table|
  (progn
    (push '|Table| *Domains*)
    (make-instance '|TableType|)))

\end{chunk}

\subsection{Tableau}
\index[dom]{Tableau!Domain}
\index[dom]{Domain!Tableau}
\index[dom]{TABLEAU}
\begin{chunk}{defclass TableauType}
(defclass |TableauType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "Tableau")
   (marker :initform 'domain)
   (abbreviation :initform 'TABLEAU)
   (comment :initform (list
     "The tableau domain is for printing Young tableaux, and"
     "coercions to and from List List S where S is a set."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Tableau|
  (progn
    (push '|Tableau| *Domains*)
    (make-instance '|TableauType|)))

\end{chunk}

\subsection{TaylorSerieso}
\index[dom]{TaylorSerieso!Domain}
\index[dom]{Domain!TaylorSerieso}
\index[dom]{TS}
\begin{chunk}{defclass TaylorSeriesoType}
(defclass |TaylorSeriesoType| (|MultivariateTaylorSeriesCategoryType|)
  ((parents :initform '(|MultivariateTaylorSeriesCategory|))
   (name :initform "TaylorSerieso")
   (marker :initform 'domain)
   (abbreviation :initform 'TS)
   (comment :initform (list
     "TaylorSeries is a general multivariate Taylor series domain"
     "over the ring Coef and with variables of type Symbol."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TaylorSerieso|
  (progn
    (push '|TaylorSerieso| *Domains*)
    (make-instance '|TaylorSeriesoType|)))

\end{chunk}

\subsection{TexFormat}
\index[dom]{TexFormat!Domain}
\index[dom]{Domain!TexFormat}
\index[dom]{TEX}
\begin{chunk}{defclass TexFormatType}
(defclass |TexFormatType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "TexFormat")
   (marker :initform 'domain)
   (abbreviation :initform 'TEX)
   (comment :initform (list
     "TexFormat provides a coercion from OutputForm to"
     "TeX format.  The particular dialect of TeX used is LaTeX."
     "The basic object consists of three parts: a prologue, a"
     "tex part and an epilogue. The functions prologue,"
     "tex and epilogue extract these parts,"
     "respectively.  The main guts of the expression go into the tex part."
     "The other parts can be set (setPrologue!,"
     "setEpilogue!) so that contain the appropriate tags for"
     "printing. For example, the prologue and epilogue might simply"
     "contain '\\verb+\\[+' and '\\verb+\\]+', respectively, so that"
     "the TeX section will be printed in LaTeX display math mode."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TexFormat|
  (progn
    (push '|TexFormat| *Domains*)
    (make-instance '|TexFormatType|)))

\end{chunk}

\subsection{TextFile}
\index[dom]{TextFile!Domain}
\index[dom]{Domain!TextFile}
\index[dom]{TEXTFILE}
\begin{chunk}{defclass TextFileType}
(defclass |TextFileType| (|FileCategoryType|)
  ((parents :initform '(|FileCategory|))
   (name :initform "TextFile")
   (marker :initform 'domain)
   (abbreviation :initform 'TEXTFILE)
   (comment :initform (list
     "This domain provides an implementation of text files.  Text is stored"
     "in these files using the native character set of the computer."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TextFile|
  (progn
    (push '|TextFile| *Domains*)
    (make-instance '|TextFileType|)))

\end{chunk}

\subsection{TheSymbolTable}
\index[dom]{TheSymbolTable!Domain}
\index[dom]{Domain!TheSymbolTable}
\index[dom]{SYMS}
\begin{chunk}{defclass TheSymbolTableType}
(defclass |TheSymbolTableType| (|CoercibleToType|)
  ((parents :initform '(|CoercibleTo|))
   (name :initform "TheSymbolTable")
   (marker :initform 'domain)
   (abbreviation :initform 'SYMS)
   (comment :initform (list
     "Creates and manipulates one global symbol table for FORTRAN"
     "code generation, containing details of types, dimensions, and argument"
     "lists."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TheSymbolTable|
  (progn
    (push '|TheSymbolTable| *Domains*)
    (make-instance '|TheSymbolTableType|)))

\end{chunk}

\subsection{ThreeDimensionalMatrix}
\index[dom]{ThreeDimensionalMatrix!Domain}
\index[dom]{Domain!ThreeDimensionalMatrix}
\index[dom]{M3D}
\begin{chunk}{defclass ThreeDimensionalMatrixType}
(defclass |ThreeDimensionalMatrixType| (|HomogeneousAggregateType|)
  ((parents :initform '(|HomogeneousAggregate|))
   (name :initform "ThreeDimensionalMatrix")
   (marker :initform 'domain)
   (abbreviation :initform 'M3D)
   (comment :initform (list
     "This domain represents three dimensional matrices over a general object type"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ThreeDimensionalMatrix|
  (progn
    (push '|ThreeDimensionalMatrix| *Domains*)
    (make-instance '|ThreeDimensionalMatrixType|)))

\end{chunk}

\subsection{ThreeDimensionalViewport}
\index[dom]{ThreeDimensionalViewport!Domain}
\index[dom]{Domain!ThreeDimensionalViewport}
\index[dom]{VIEW3D}
\begin{chunk}{defclass ThreeDimensionalViewportType}
(defclass |ThreeDimensionalViewportType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "ThreeDimensionalViewport")
   (marker :initform 'domain)
   (abbreviation :initform 'VIEW3D)
   (comment :initform (list
     "ThreeDimensionalViewport creates viewports to display graphs"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ThreeDimensionalViewport|
  (progn
    (push '|ThreeDimensionalViewport| *Domains*)
    (make-instance '|ThreeDimensionalViewportType|)))

\end{chunk}

\subsection{ThreeSpace}
\index[dom]{ThreeSpace!Domain}
\index[dom]{Domain!ThreeSpace}
\index[dom]{SPACE3}
\begin{chunk}{defclass ThreeSpaceType}
(defclass |ThreeSpaceType| (|ThreeSpaceCategoryType|)
  ((parents :initform '(|ThreeSpaceCategory|))
   (name :initform "ThreeSpace")
   (marker :initform 'domain)
   (abbreviation :initform 'SPACE3)
   (comment :initform (list
     "The domain ThreeSpace is used for creating three dimensional"
     "objects using functions for defining points, curves, polygons, constructs"
     "and the subspaces containing them."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ThreeSpace|
  (progn
    (push '|ThreeSpace| *Domains*)
    (make-instance '|ThreeSpaceType|)))

\end{chunk}

\subsection{Tree}
\index[dom]{Tree!Domain}
\index[dom]{Domain!Tree}
\index[dom]{TREE}
\begin{chunk}{defclass TreeType}
(defclass |TreeType| (|RecursiveAggregateType|)
  ((parents :initform '(|RecursiveAggregate|))
   (name :initform "Tree")
   (marker :initform 'domain)
   (abbreviation :initform 'TREE)
   (comment :initform (list
     "Tree(S) is a basic domains of tree structures."
     "Each tree is either empty or else is a node consisting of a value and"
     "a list of (sub)trees."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Tree|
  (progn
    (push '|Tree| *Domains*)
    (make-instance '|TreeType|)))

\end{chunk}

\subsection{TubePlot}
\index[dom]{TubePlot!Domain}
\index[dom]{Domain!TubePlot}
\index[dom]{TUBE}
\begin{chunk}{defclass TubePlotType}
(defclass |TubePlotType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TubePlot")
   (marker :initform 'domain)
   (abbreviation :initform 'TUBE)
   (comment :initform (list
     "Package for constructing tubes around 3-dimensional parametric curves."
     "Domain of tubes around 3-dimensional parametric curves."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TubePlot|
  (progn
    (push '|TubePlot| *Domains*)
    (make-instance '|TubePlotType|)))

\end{chunk}

\subsection{Tuple}
\index[dom]{Tuple!Domain}
\index[dom]{Domain!Tuple}
\index[dom]{TUPLE}
\begin{chunk}{defclass TupleType}
(defclass |TupleType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "Tuple")
   (marker :initform 'domain)
   (abbreviation :initform 'TUPLE)
   (comment :initform (list
     "This domain is used to interface with the interpreter's notion"
     "of comma-delimited sequences of values."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Tuple|
  (progn
    (push '|Tuple| *Domains*)
    (make-instance '|TupleType|)))

\end{chunk}

\subsection{TwoDimensionalArray}
\index[dom]{TwoDimensionalArray!Domain}
\index[dom]{Domain!TwoDimensionalArray}
\index[dom]{ARRAY2}
\begin{chunk}{defclass TwoDimensionalArrayType}
(defclass |TwoDimensionalArrayType| (|TwoDimensionalArrayCategoryType|)
  ((parents :initform '(|TwoDimensionalArrayCategory|))
   (name :initform "TwoDimensionalArray")
   (marker :initform 'domain)
   (abbreviation :initform 'ARRAY2)
   (comment :initform (list
     "A TwoDimensionalArray is a two dimensional array with"
     "1-based indexing for both rows and columns."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TwoDimensionalArray|
  (progn
    (push '|TwoDimensionalArray| *Domains*)
    (make-instance '|TwoDimensionalArrayType|)))

\end{chunk}

\subsection{TwoDimensionalViewport}
\index[dom]{TwoDimensionalViewport!Domain}
\index[dom]{Domain!TwoDimensionalViewport}
\index[dom]{VIEW2D}
\begin{chunk}{defclass TwoDimensionalViewportType}
(defclass |TwoDimensionalViewportType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "TwoDimensionalViewport")
   (marker :initform 'domain)
   (abbreviation :initform 'VIEW2D)
   (comment :initform (list
     "TwoDimensionalViewport creates viewports to display graphs."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TwoDimensionalViewport|
  (progn
    (push '|TwoDimensionalViewport| *Domains*)
    (make-instance '|TwoDimensionalViewportType|)))

\end{chunk}

\section{U}

\subsection{UnivariateFormalPowerSeries}
\index[dom]{UnivariateFormalPowerSeries!Domain}
\index[dom]{Domain!UnivariateFormalPowerSeries}
\index[dom]{UFPS}
\begin{chunk}{defclass UnivariateFormalPowerSeriesType}
(defclass |UnivariateFormalPowerSeriesType| (|UnivariateTaylorSeriesCategoryType|)
  ((parents :initform '(|UnivariateTaylorSeriesCategory|))
   (name :initform "UnivariateFormalPowerSeries")
   (marker :initform 'domain)
   (abbreviation :initform 'UFPS)
   (comment :initform (list
     "This domain has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariateFormalPowerSeries|
  (progn
    (push '|UnivariateFormalPowerSeries| *Domains*)
    (make-instance '|UnivariateFormalPowerSeriesType|)))

\end{chunk}

\subsection{UnivariateLaurentSeries}
\index[dom]{UnivariateLaurentSeries!Domain}
\index[dom]{Domain!UnivariateLaurentSeries}
\index[dom]{ULS}
\begin{chunk}{defclass UnivariateLaurentSeriesType}
(defclass |UnivariateLaurentSeriesType| (|UnivariateLaurentSeriesConstructorCategoryType|)
  ((parents :initform '(|UnivariateLaurentSeriesConstructorCategory|))
   (name :initform "UnivariateLaurentSeries")
   (marker :initform 'domain)
   (abbreviation :initform 'ULS)
   (comment :initform (list
     "UnivariateLaurentSeries is a domain representing Laurent"
     "series in one variable with coefficients in an arbitrary ring.  The"
     "parameters of the type specify the coefficient ring, the power series"
     "variable, and the center of the power series expansion.  For example,"
     "UnivariateLaurentSeries(Integer,x,3) represents Laurent series in"
     "(x - 3) with integer coefficients."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariateLaurentSeries|
  (progn
    (push '|UnivariateLaurentSeries| *Domains*)
    (make-instance '|UnivariateLaurentSeriesType|)))

\end{chunk}

\subsection{UnivariateLaurentSeriesConstructor}
\index[dom]{UnivariateLaurentSeriesConstructor!Domain}
\index[dom]{Domain!UnivariateLaurentSeriesConstructor}
\index[dom]{ULSCONS}
\begin{chunk}{defclass UnivariateLaurentSeriesConstructorType}
(defclass |UnivariateLaurentSeriesConstructorType| (|UnivariateLaurentSeriesConstructorCategoryType|)
  ((parents :initform '(|UnivariateLaurentSeriesConstructorCategory|))
   (name :initform "UnivariateLaurentSeriesConstructor")
   (marker :initform 'domain)
   (abbreviation :initform 'ULSCONS)
   (comment :initform (list
     "This package enables one to construct a univariate Laurent series"
     "domain from a univariate Taylor series domain. Univariate"
     "Laurent series are represented by a pair [n,f(x)], where n is"
     "an arbitrary integer and f(x)} is a Taylor series.  This pair"
     "represents the Laurent series x**n * f(x)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariateLaurentSeriesConstructor|
  (progn
    (push '|UnivariateLaurentSeriesConstructor| *Domains*)
    (make-instance '|UnivariateLaurentSeriesConstructorType|)))

\end{chunk}

\subsection{UnivariatePolynomial}
\index[dom]{UnivariatePolynomial!Domain}
\index[dom]{Domain!UnivariatePolynomial}
\index[dom]{UP}
\begin{chunk}{defclass UnivariatePolynomialType}
(defclass |UnivariatePolynomialType| (|UnivariatePolynomialCategoryType|)
  ((parents :initform '(|UnivariatePolynomialCategory|))
   (name :initform "UnivariatePolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'UP)
   (comment :initform (list
     "This domain represents univariate polynomials in some symbol"
     "over arbitrary (not necessarily commutative) coefficient rings."
     "The representation is sparse"
     "in the sense that only non-zero terms are represented."
     "Note that if the coefficient ring is a field, then this domain"
     "forms a euclidean domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariatePolynomial|
  (progn
    (push '|UnivariatePolynomial| *Domains*)
    (make-instance '|UnivariatePolynomialType|)))

\end{chunk}

\subsection{UnivariatePuiseuxSeries}
\index[dom]{UnivariatePuiseuxSeries!Domain}
\index[dom]{Domain!UnivariatePuiseuxSeries}
\index[dom]{UPXS}
\begin{chunk}{defclass UnivariatePuiseuxSeriesType}
(defclass |UnivariatePuiseuxSeriesType| (|UnivariatePuiseuxSeriesConstructorCategoryType|)
  ((parents :initform '(|UnivariatePuiseuxSeriesConstructorCategory|))
   (name :initform "UnivariatePuiseuxSeries")
   (marker :initform 'domain)
   (abbreviation :initform 'UPXS)
   (comment :initform (list
     "Dense Puiseux series in one variable"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariatePuiseuxSeries|
  (progn
    (push '|UnivariatePuiseuxSeries| *Domains*)
    (make-instance '|UnivariatePuiseuxSeriesType|)))

\end{chunk}

\subsection{UnivariatePuiseuxSeriesConstructor}
\index[dom]{UnivariatePuiseuxSeriesConstructor!Domain}
\index[dom]{Domain!UnivariatePuiseuxSeriesConstructor}
\index[dom]{UPXSCONS}
\begin{chunk}{defclass UnivariatePuiseuxSeriesConstructorType}
(defclass |UnivariatePuiseuxSeriesConstructorType| (|UnivariatePuiseuxSeriesConstructorCategoryType|)
  ((parents :initform '(|UnivariatePuiseuxSeriesConstructorCategory|))
   (name :initform "UnivariatePuiseuxSeriesConstructor")
   (marker :initform 'domain)
   (abbreviation :initform 'UPXSCONS)
   (comment :initform (list
     "This package enables one to construct a univariate Puiseux series"
     "domain from a univariate Laurent series domain. Univariate"
     "Puiseux series are represented by a pair [r,f(x)], where r is"
     "a positive rational number and f(x) is a Laurent series."
     "This pair represents the Puiseux series f(x^r)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariatePuiseuxSeriesConstructor|
  (progn
    (push '|UnivariatePuiseuxSeriesConstructor| *Domains*)
    (make-instance '|UnivariatePuiseuxSeriesConstructorType|)))

\end{chunk}

\subsection{UnivariatePuiseuxSeriesWithExponentialSingularity}
\index[dom]{UnivariatePuiseuxSeriesWithExponentialSingularity!Domain}
\index[dom]{Domain!UnivariatePuiseuxSeriesWithExponentialSingularity}
\index[dom]{UPXSSING}
\begin{chunk}{defclass UnivariatePuiseuxSeriesWithExponentialSingularityType}
(defclass |UnivariatePuiseuxSeriesWithExponentialSingularityType| (|FiniteAbelianMonoidRingType|)
  ((parents :initform '(|FiniteAbelianMonoidRing|))
   (name :initform "UnivariatePuiseuxSeriesWithExponentialSingularity")
   (marker :initform 'domain)
   (abbreviation :initform 'UPXSSING)
   (comment :initform (list
     "UnivariatePuiseuxSeriesWithExponentialSingularity is a domain used to"
     "represent functions with essential singularities.  Objects in this"
     "domain are sums, where each term in the sum is a univariate Puiseux"
     "series times the exponential of a univariate Puiseux series.  Thus,"
     "the elements of this domain are sums of expressions of the form"
     "g(x) * exp(f(x)), where g(x) is a univariate Puiseux series"
     "and f(x) is a univariate Puiseux series with no terms of non-negative"
     "degree."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariatePuiseuxSeriesWithExponentialSingularity|
  (progn
    (push '|UnivariatePuiseuxSeriesWithExponentialSingularity| *Domains*)
    (make-instance '|UnivariatePuiseuxSeriesWithExponentialSingularityType|)))

\end{chunk}

\subsection{UnivariateSkewPolynomial}
\index[dom]{UnivariateSkewPolynomial!Domain}
\index[dom]{Domain!UnivariateSkewPolynomial}
\index[dom]{OREUP}
\begin{chunk}{defclass UnivariateSkewPolynomialType}
(defclass |UnivariateSkewPolynomialType| (|UnivariateSkewPolynomialCategoryType|)
  ((parents :initform '(|UnivariateSkewPolynomialCategory|))
   (name :initform "UnivariateSkewPolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'OREUP)
   (comment :initform (list
     "This is the domain of univariate skew polynomials over an Ore"
     "coefficient field in a named variable."
     "The multiplication is given by x a = sigma(a) x + delta a."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariateSkewPolynomial|
  (progn
    (push '|UnivariateSkewPolynomial| *Domains*)
    (make-instance '|UnivariateSkewPolynomialType|)))

\end{chunk}

\subsection{UnivariateTaylorSeries}
\index[dom]{UnivariateTaylorSeries!Domain}
\index[dom]{Domain!UnivariateTaylorSeries}
\index[dom]{UTS}
\begin{chunk}{defclass UnivariateTaylorSeriesType}
(defclass |UnivariateTaylorSeriesType| (|UnivariateTaylorSeriesCategoryType|)
  ((parents :initform '(|UnivariateTaylorSeriesCategory|))
   (name :initform "UnivariateTaylorSeries")
   (marker :initform 'domain)
   (abbreviation :initform 'UTS)
   (comment :initform (list
     "Dense Taylor series in one variable"
     "UnivariateTaylorSeries is a domain representing Taylor"
     "series in"
     "one variable with coefficients in an arbitrary ring.  The parameters"
     "of the type specify the coefficient ring, the power series variable,"
     "and the center of the power series expansion.  For example,"
     "UnivariateTaylorSeries(Integer,x,3) represents"
     "Taylor series in"
     "(x - 3) with Integer coefficients."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariateTaylorSeries|
  (progn
    (push '|UnivariateTaylorSeries| *Domains*)
    (make-instance '|UnivariateTaylorSeriesType|)))

\end{chunk}

\subsection{UnivariateTaylorSeriesCZero}
\index[dom]{UnivariateTaylorSeriesCZero!Domain}
\index[dom]{Domain!UnivariateTaylorSeriesCZero}
\index[dom]{UTSZ}
\begin{chunk}{defclass UnivariateTaylorSeriesCZeroType}
(defclass |UnivariateTaylorSeriesCZeroType| (|UnivariateTaylorSeriesCategoryType|)
  ((parents :initform '(|UnivariateTaylorSeriesCategory|))
   (name :initform "UnivariateTaylorSeriesCZero")
   (marker :initform 'domain)
   (abbreviation :initform 'UTSZ)
   (comment :initform (list
     "Part of the Package for Algebraic Function Fields in one variable PAFF"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariateTaylorSeriesCZero|
  (progn
    (push '|UnivariateTaylorSeriesCZero| *Domains*)
    (make-instance '|UnivariateTaylorSeriesCZeroType|)))

\end{chunk}

\subsection{UniversalSegment}
\index[dom]{UniversalSegment!Domain}
\index[dom]{Domain!UniversalSegment}
\index[dom]{UNISEG}
\begin{chunk}{defclass UniversalSegmentType}
(defclass |UniversalSegmentType| (|SetCategoryType| |SegmentExpansionCategoryType|)
  ((parents :initform '(|SetCategory| |SegmentExpansionCategory|))
   (name :initform "UniversalSegment")
   (marker :initform 'domain)
   (abbreviation :initform 'UNISEG)
   (comment :initform (list
     "Part of the Package for Algebraic Function Fields in one variable PAFF"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UniversalSegment|
  (progn
    (push '|UniversalSegment| *Domains*)
    (make-instance '|UniversalSegmentType|)))

\end{chunk}

\subsection{U8Matrix}
\index[dom]{U8Matrix!Domain}
\index[dom]{Domain!U8Matrix}
\index[dom]{U8MAT}
\begin{chunk}{defclass U8MatrixType}
(defclass |U8MatrixType| (|MatrixCategoryType|)
  ((parents :initform '(|MatrixCategory|))
   (name :initform "U8Matrix")
   (marker :initform 'domain)
   (abbreviation :initform 'U8MAT)
   (comment :initform (list
     "This is a low-level domain which implements matrices"
     "(two dimensional arrays) of 8-bit integers."
     "Indexing is 0 based, there is no bound checking (unless"
     "provided by lower level)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |U8Matrix|
  (progn
    (push '|U8Matrix| *Domains*)
    (make-instance '|U8MatrixType|)))

\end{chunk}

\subsection{U16Matrix}
\index[dom]{U16Matrix!Domain}
\index[dom]{Domain!U16Matrix}
\index[dom]{U16MAT}
\begin{chunk}{defclass U16MatrixType}
(defclass |U16MatrixType| (|MatrixCategoryType|)
  ((parents :initform '(|MatrixCategory|))
   (name :initform "U16Matrix")
   (marker :initform 'domain)
   (abbreviation :initform 'U16MAT)
   (comment :initform (list
     "This is a low-level domain which implements matrices"
     "(two dimensional arrays) of 16-bit integers."
     "Indexing is 0 based, there is no bound checking (unless"
     "provided by lower level)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |U16Matrix|
  (progn
    (push '|U16Matrix| *Domains*)
    (make-instance '|U16MatrixType|)))

\end{chunk}

\subsection{U32Matrix}
\index[dom]{U32Matrix!Domain}
\index[dom]{Domain!U32Matrix}
\index[dom]{U32MAT}
\begin{chunk}{defclass U32MatrixType}
(defclass |U32MatrixType| (|MatrixCategoryType|)
  ((parents :initform '(|MatrixCategory|))
   (name :initform "U32Matrix")
   (marker :initform 'domain)
   (abbreviation :initform 'U32MAT)
   (comment :initform (list
     "This is a low-level domain which implements matrices"
     "(two dimensional arrays) of 32-bit integers."
     "Indexing is 0 based, there is no bound checking (unless"
     "provided by lower level)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |U32Matrix|
  (progn
    (push '|U32Matrix| *Domains*)
    (make-instance '|U32MatrixType|)))

\end{chunk}

\subsection{U8Vector}
\index[dom]{U8Vector!Domain}
\index[dom]{Domain!U8Vector}
\index[dom]{U8VEC}
\begin{chunk}{defclass U8VectorType}
(defclass |U8VectorType| (|OneDimensionalArrayAggregateType|)
  ((parents :initform '(|OneDimensionalArrayAggregate|))
   (name :initform "U8Vector")
   (marker :initform 'domain)
   (abbreviation :initform 'U8VEC)
   (comment :initform (list
     "This is a low-level domain which implements vectors"
     "(one dimensional arrays) of unsigned 8-bit numbers.  Indexing"
     "is 0 based, there is no bound checking (unless provided by"
     "lower level)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |U8Vector|
  (progn
    (push '|U8Vector| *Domains*)
    (make-instance '|U8VectorType|)))

\end{chunk}

\subsection{U16Vector}
\index[dom]{U16Vector!Domain}
\index[dom]{Domain!U16Vector}
\index[dom]{U16VEC}
\begin{chunk}{defclass U16VectorType}
(defclass |U16VectorType| (|OneDimensionalArrayAggregateType|)
  ((parents :initform '(|OneDimensionalArrayAggregate|))
   (name :initform "U16Vector")
   (marker :initform 'domain)
   (abbreviation :initform 'U16VEC)
   (comment :initform (list
     "This is a low-level domain which implements vectors"
     "(one dimensional arrays) of unsigned 16-bit numbers.  Indexing"
     "is 0 based, there is no bound checking (unless provided by"
     "lower level)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |U16Vector|
  (progn
    (push '|U16Vector| *Domains*)
    (make-instance '|U16VectorType|)))

\end{chunk}

\subsection{U32Vector}
\index[dom]{U32Vector!Domain}
\index[dom]{Domain!U32Vector}
\index[dom]{U32VEC}
\begin{chunk}{defclass U32VectorType}
(defclass |U32VectorType| (|OneDimensionalArrayAggregateType|)
  ((parents :initform '(|OneDimensionalArrayAggregate|))
   (name :initform "U32Vector")
   (marker :initform 'domain)
   (abbreviation :initform 'U32VEC)
   (comment :initform (list
     "This is a low-level domain which implements vectors"
     "(one dimensional arrays) of unsigned 32-bit numbers.  Indexing"
     "is 0 based, there is no bound checking (unless provided by"
     "lower level)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |U32Vector|
  (progn
    (push '|U32Vector| *Domains*)
    (make-instance '|U32VectorType|)))

\end{chunk}

\section{V}

\subsection{Variable}
\index[dom]{Variable!Domain}
\index[dom]{Domain!Variable}
\index[dom]{VARIABLE}
\begin{chunk}{defclass VariableType}
(defclass |VariableType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "Variable")
   (marker :initform 'domain)
   (abbreviation :initform 'VARIABLE)
   (comment :initform (list
     "This domain implements variables"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Variable|
  (progn
    (push '|Variable| *Domains*)
    (make-instance '|VariableType|)))

\end{chunk}

\subsection{Vector}
\index[dom]{Vector!Domain}
\index[dom]{Domain!Vector}
\index[dom]{VECTOR}
\begin{chunk}{defclass VectorType}
(defclass |VectorType| (|VectorCategoryType|)
  ((parents :initform '(|VectorCategory|))
   (name :initform "Vector")
   (marker :initform 'domain)
   (abbreviation :initform 'VECTOR)
   (comment :initform (list
     "This type represents vector like objects with varying lengths"
     "and indexed by a finite segment of integers starting at 1."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Vector|
  (progn
    (push '|Vector| *Domains*)
    (make-instance '|VectorType|)))

\end{chunk}

\subsection{Void}
\index[dom]{Void!Domain}
\index[dom]{Domain!Void}
\index[dom]{VOID}
\begin{chunk}{defclass VoidType}
(defclass |VoidType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "Void")
   (marker :initform 'domain)
   (abbreviation :initform 'VOID)
   (comment :initform (list
     "This type is used when no value is needed, for example, in the then"
     "part of a one armed if."
     "All values can be coerced to type Void.  Once a value has been coerced"
     "to Void, it cannot be recovered."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Void|
  (progn
    (push '|Void| *Domains*)
    (make-instance '|VoidType|)))

\end{chunk}

\section{W}

\subsection{WeightedPolynomials}
\index[dom]{WeightedPolynomials!Domain}
\index[dom]{Domain!WeightedPolynomials}
\index[dom]{WP}
\begin{chunk}{defclass WeightedPolynomialsType}
(defclass |WeightedPolynomialsType| (|AlgebraType|)
  ((parents :initform '(|Algebra|))
   (name :initform "WeightedPolynomials")
   (marker :initform 'domain)
   (abbreviation :initform 'WP)
   (comment :initform (list
     "This domain represents truncated weighted polynomials over a general"
     "(not necessarily commutative) polynomial type. The variables must be"
     "specified, as must the weights."
     "The representation is sparse"
     "in the sense that only non-zero terms are represented."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |WeightedPolynomials|
  (progn
    (push '|WeightedPolynomials| *Domains*)
    (make-instance '|WeightedPolynomialsType|)))

\end{chunk}

\subsection{WuWenTsunTriangularSet}
\index[dom]{WuWenTsunTriangularSet!Domain}
\index[dom]{Domain!WuWenTsunTriangularSet}
\index[dom]{WUTSET}
\begin{chunk}{defclass WuWenTsunTriangularSetType}
(defclass |WuWenTsunTriangularSetType| (|TriangularSetCategoryType|)
  ((parents :initform '(|TriangularSetCategory|))
   (name :initform "WuWenTsunTriangularSet")
   (marker :initform 'domain)
   (abbreviation :initform 'WUTSET)
   (comment :initform (list
     "A domain constructor of the category GeneralTriangularSet."
     "The only requirement for a list of polynomials to be a member of such"
     "a domain is the following: no polynomial is constant and two distinct"
     "polynomials have distinct main variables. Such a triangular set may"
     "not be auto-reduced or consistent. The construct operation"
     "does not check the previous requirement. Triangular sets are stored"
     "as sorted lists w.r.t. the main variables of their members."
     "Furthermore, this domain exports operations dealing with the"
     "characteristic set method of Wu Wen Tsun and some optimizations"
     "mainly proposed by Dong Ming Wang."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |WuWenTsunTriangularSet|
  (progn
    (push '|WuWenTsunTriangularSet| *Domains*)
    (make-instance '|WuWenTsunTriangularSetType|)))

\end{chunk}

\section{X}

\subsection{XDistributedPolynomial}
\index[dom]{XDistributedPolynomial!Domain}
\index[dom]{Domain!XDistributedPolynomial}
\index[dom]{XDPOLY}
\begin{chunk}{defclass XDistributedPolynomialType}
(defclass |XDistributedPolynomialType| (|FreeModuleCatType| |XPolynomialsCatType|)
  ((parents :initform '(|FreeModuleCat| |XPolynomialsCat|))
   (name :initform "XDistributedPolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'XDPOLY)
   (comment :initform (list
     "This type supports distributed multivariate polynomials"
     "whose variables do not commute."
     "The coefficient ring may be non-commutative too."
     "However, coefficients and variables commute."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |XDistributedPolynomial|
  (progn
    (push '|XDistributedPolynomial| *Domains*)
    (make-instance '|XDistributedPolynomialType|)))

\end{chunk}

\subsection{XPBWPolynomial}
\index[dom]{XPBWPolynomial!Domain}
\index[dom]{Domain!XPBWPolynomial}
\index[dom]{XPBWPOLY}
\begin{chunk}{defclass XPBWPolynomialType}
(defclass |XPBWPolynomialType| (|FreeModuleCatType| |XPolynomialsCatType|)
  ((parents :initform '(|FreeModuleCat| |XPolynomialsCat|))
   (name :initform "XPBWPolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'XPBWPOLY)
   (comment :initform (list
     "This domain constructor implements polynomials in non-commutative"
     "variables written in the Poincare-Birkhoff-Witt basis from the"
     "Lyndon basis."
     "These polynomials can be used to compute Baker-Campbell-Hausdorff"
     "relations. "))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |XPBWPolynomial|
  (progn
    (push '|XPBWPolynomial| *Domains*)
    (make-instance '|XPBWPolynomialType|)))

\end{chunk}

\subsection{XPolynomial}
\index[dom]{XPolynomial!Domain}
\index[dom]{Domain!XPolynomial}
\index[dom]{XPOLY}
\begin{chunk}{defclass XPolynomialType}
(defclass |XPolynomialType| (|XPolynomialsCatType|)
  ((parents :initform '(|XPolynomialsCat|))
   (name :initform "XPolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'XPOLY)
   (comment :initform (list
     "This type supports multivariate polynomials whose set of variables"
     "is Symbol. The representation is recursive."
     "The coefficient ring may be non-commutative and the variables"
     "do not commute. However, coefficients and variables commute."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |XPolynomial|
  (progn
    (push '|XPolynomial| *Domains*)
    (make-instance '|XPolynomialType|)))

\end{chunk}

\subsection{XPolynomialRing}
\index[dom]{XPolynomialRing!Domain}
\index[dom]{Domain!XPolynomialRing}
\index[dom]{XPR}
\begin{chunk}{defclass XPolynomialRingType}
(defclass |XPolynomialRingType| (|FreeModuleCatType| |XAlgebraType|)
  ((parents :initform '(|FreeModuleCat| |XAlgebra|))
   (name :initform "XPolynomialRing")
   (marker :initform 'domain)
   (abbreviation :initform 'XPR)
   (comment :initform (list
     "This domain represents generalized polynomials with coefficients"
     "(from a not necessarily commutative ring), and words"
     "belonging to an arbitrary OrderedMonoid."
     "This type is used, for instance, by the XDistributedPolynomial" 
     "domain constructor where the Monoid is free."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |XPolynomialRing|
  (progn
    (push '|XPolynomialRing| *Domains*)
    (make-instance '|XPolynomialRingType|)))

\end{chunk}

\subsection{XRecursivePolynomial}
\index[dom]{XRecursivePolynomial!Domain}
\index[dom]{Domain!XRecursivePolynomial}
\index[dom]{XRPOLY}
\begin{chunk}{defclass XRecursivePolynomialType}
(defclass |XRecursivePolynomialType| (|XPolynomialsCatType|)
  ((parents :initform '(|XPolynomialsCat|))
   (name :initform "XRecursivePolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'XRPOLY)
   (comment :initform (list
     "This type supports multivariate polynomials whose variables do not commute."
     "The representation is recursive. The coefficient ring may be"
     "non-commutative. Coefficients and variables commute."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |XRecursivePolynomial|
  (progn
    (push '|XRecursivePolynomial| *Domains*)
    (make-instance '|XRecursivePolynomialType|)))

\end{chunk}

\chapter{The Packages}

\section{A}

\subsection{AffineAlgebraicSetComputeWithGroebnerBasis}
\index[pkg]{AffineAlgebraicSetComputeWithGroebnerBasis!Domain}
\index[pkg]{Domain!AffineAlgebraicSetComputeWithGroebnerBasis}
\index[pkg]{AFALGGRO}
\begin{chunk}{defclass AffineAlgebraicSetComputeWithGroebnerBasisType}
(defclass |AffineAlgebraicSetComputeWithGroebnerBasisType| (|AxiomClass|)
  ((parents :initform '())
   (name :initform "AffineAlgebraicSetComputeWithGroebnerBasis")
   (marker :initform 'package)
   (abbreviation :initform 'AFALGGRO)
   (comment :initform (list
     "The following is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AffineAlgebraicSetComputeWithGroebnerBasis|
  (progn
    (push '|AffineAlgebraicSetComputeWithGroebnerBasis| *Packages*)
    (make-instance '|AffineAlgebraicSetComputeWithGroebnerBasisType|)))

\end{chunk}

\subsection{AffineAlgebraicSetComputeWithResultant}
\index[pkg]{AffineAlgebraicSetComputeWithResultant!Domain}
\index[pkg]{Domain!AffineAlgebraicSetComputeWithResultant}
\index[pkg]{AFALGRES}
\begin{chunk}{defclass AffineAlgebraicSetComputeWithResultantType}
(defclass |AffineAlgebraicSetComputeWithResultantType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AffineAlgebraicSetComputeWithResultant")
   (marker :initform 'package)
   (abbreviation :initform 'AFALGRES)
   (comment :initform (list
     "The following is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
    (withlist :initform nil)
   (haslist :initform nil)
    (addlist :initform nil)))

 (defvar |AffineAlgebraicSetComputeWithResultant|
   (progn
     (push '|AffineAlgebraicSetComputeWithResultant| *Packages*)
     (make-instance '|AffineAlgebraicSetComputeWithResultantType|)))

\end{chunk}

\subsection{AlgebraicFunction}
\index[pkg]{AlgebraicFunction!Domain}
\index[pkg]{Domain!AlgebraicFunction}
\index[pkg]{AF}
\begin{chunk}{(defclass AlgebraicFunctionType}
 (defclass |AlgebraicFunctionType| (|AxiomClass|)
   ((parents :initform ())
    (name :initform "AlgebraicFunction")
    (marker :initform 'package)
    (abbreviation :initform 'AF)
   (comment :initform (list
     "This package provides algebraic functions over an integral domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AlgebraicFunction|
  (progn
    (push '|AlgebraicFunction| *Packages*)
    (make-instance '|AlgebraicFunctionType|)))

\end{chunk}

\subsection{AlgebraicHermiteIntegration}
\index[pkg]{AlgebraicHermiteIntegration!Domain}
\index[pkg]{Domain!AlgebraicHermiteIntegration}
\index[pkg]{INTHERAL}
\begin{chunk}{defclass AlgebraicHermiteIntegrationType}
(defclass |AlgebraicHermiteIntegrationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AlgebraicHermiteIntegration")
   (marker :initform 'package)
   (abbreviation :initform 'INTHERAL)
   (comment :initform (list
     "Algebraic Hermite reduction."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AlgebraicHermiteIntegration|
  (progn
    (push '|AlgebraicHermiteIntegration| *Packages*)
    (make-instance '|AlgebraicHermiteIntegrationType|)))

\end{chunk}

\subsection{AlgebraicIntegrate}
\index[pkg]{AlgebraicIntegrate!Domain}
\index[pkg]{Domain!AlgebraicIntegrate}
\index[pkg]{INTALG}
\begin{chunk}{defclass AlgebraicIntegrateType}
(defclass |AlgebraicIntegrateType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AlgebraicIntegrate")
   (marker :initform 'package)
   (abbreviation :initform 'INTALG)
   (comment :initform (list
     "This package provides functions for integrating a function"
     "on an algebraic curve."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AlgebraicIntegrate|
  (progn
    (push '|AlgebraicIntegrate| *Packages*)
    (make-instance '|AlgebraicIntegrateType|)))

\end{chunk}

\subsection{AlgebraicIntegration}
\index[pkg]{AlgebraicIntegration!Domain}
\index[pkg]{Domain!AlgebraicIntegration}
\index[pkg]{INTAF}
\begin{chunk}{defclass AlgebraicIntegrationType}
(defclass |AlgebraicIntegrationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AlgebraicIntegration")
   (marker :initform 'package)
   (abbreviation :initform 'INTAF)
   (comment :initform (list
     "This package provides functions for the integration of"
     "algebraic integrands over transcendental functions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AlgebraicIntegration|
  (progn
    (push '|AlgebraicIntegration| *Packages*)
    (make-instance '|AlgebraicIntegrationType|)))

\end{chunk}

\subsection{AlgebraicManipulations}
\index[pkg]{AlgebraicManipulations!Domain}
\index[pkg]{Domain!AlgebraicManipulations}
\index[pkg]{ALGMANIP}
\begin{chunk}{defclass AlgebraicManipulationsType}
(defclass |AlgebraicManipulationsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AlgebraicManipulations")
   (marker :initform 'package)
   (abbreviation :initform 'ALGMANIP)
   (comment :initform (list
     "AlgebraicManipulations provides functions to simplify and expand"
     "expressions involving algebraic operators."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AlgebraicManipulations|
  (progn
    (push '|AlgebraicManipulations| *Packages*)
    (make-instance '|AlgebraicManipulationsType|)))

\end{chunk}

\subsection{AlgebraicMultFact}
\index[pkg]{AlgebraicMultFact!Domain}
\index[pkg]{Domain!AlgebraicMultFact}
\index[pkg]{ALGMFACT}
\begin{chunk}{defclass AlgebraicMultFactType}
(defclass |AlgebraicMultFactType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AlgebraicMultFact")
   (marker :initform 'package)
   (abbreviation :initform 'ALGMFACT)
   (comment :initform (list
     "This package factors multivariate polynomials over the"
     "domain of AlgebraicNumber by allowing the user"
     "to specify a list of algebraic numbers generating the particular"
     "extension to factor over."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AlgebraicMultFact|
  (progn
    (push '|AlgebraicMultFact| *Packages*)
    (make-instance '|AlgebraicMultFactType|)))

\end{chunk}

\subsection{AlgebraPackage}
\index[pkg]{AlgebraPackage!Domain}
\index[pkg]{Domain!AlgebraPackage}
\index[pkg]{ALGPKG}
\begin{chunk}{defclass AlgebraPackageType}
(defclass |AlgebraPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AlgebraPackage")
   (marker :initform 'package)
   (abbreviation :initform 'ALGPKG)
   (comment :initform (list
     "AlgebraPackage assembles a variety of useful functions for"
     "general algebras."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AlgebraPackage|
  (progn
    (push '|AlgebraPackage| *Packages*)
    (make-instance '|AlgebraPackageType|)))

\end{chunk}

\subsection{AlgFactor}
\index[pkg]{AlgFactor!Domain}
\index[pkg]{Domain!AlgFactor}
\index[pkg]{ALGFACT}
\begin{chunk}{defclass AlgFactorType}
(defclass |AlgFactorType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AlgFactor")
   (marker :initform 'package)
   (abbreviation :initform 'ALGFACT)
   (comment :initform (list
     "Factorization of univariate polynomials with coefficients in"
     "AlgebraicNumber."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AlgFactor|
  (progn
    (push '|AlgFactor| *Packages*)
    (make-instance '|AlgFactorType|)))

\end{chunk}

\subsection{AnnaNumericalIntegrationPackage}
\index[pkg]{AnnaNumericalIntegrationPackage!Domain}
\index[pkg]{Domain!AnnaNumericalIntegrationPackage}
\index[pkg]{INTPACK}
\begin{chunk}{defclass AnnaNumericalIntegrationPackageType}
(defclass |AnnaNumericalIntegrationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AnnaNumericalIntegrationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'INTPACK)
   (comment :initform (list
     "AnnaNumericalIntegrationPackage is a package"
     "of functions for the category" 
     "NumericalIntegrationCategory"
     "with measure, and integrate."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AnnaNumericalIntegrationPackage|
  (progn
    (push '|AnnaNumericalIntegrationPackage| *Packages*)
    (make-instance '|AnnaNumericalIntegrationPackageType|)))

\end{chunk}

\subsection{AnnaNumericalOptimizationPackage}
\index[pkg]{AnnaNumericalOptimizationPackage!Domain}
\index[pkg]{Domain!AnnaNumericalOptimizationPackage}
\index[pkg]{OPTPACK}
\begin{chunk}{defclass AnnaNumericalOptimizationPackageType}
(defclass |AnnaNumericalOptimizationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AnnaNumericalOptimizationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'OPTPACK)
   (comment :initform (list
     "AnnaNumericalOptimizationPackage is a package of"
     "functions for the NumericalOptimizationCategory"
     "with measure and optimize."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AnnaNumericalOptimizationPackage|
  (progn
    (push '|AnnaNumericalOptimizationPackage| *Packages*)
    (make-instance '|AnnaNumericalOptimizationPackageType|)))

\end{chunk}

\subsection{AnnaOrdinaryDifferentialEquationPackage}
\index[pkg]{AnnaOrdinaryDifferentialEquationPackage!Domain}
\index[pkg]{Domain!AnnaOrdinaryDifferentialEquationPackage}
\index[pkg]{ODEPACK}
\begin{chunk}{defclass AnnaOrdinaryDifferentialEquationPackageType}
(defclass |AnnaOrdinaryDifferentialEquationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AnnaOrdinaryDifferentialEquationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'ODEPACK)
   (comment :initform (list
     "AnnaOrdinaryDifferentialEquationPackage is a package"
     "of functions for the category"
     "OrdinaryDifferentialEquationsSolverCategory"
     "with measure, and solve."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AnnaOrdinaryDifferentialEquationPackage|
  (progn
    (push '|AnnaOrdinaryDifferentialEquationPackage| *Packages*)
    (make-instance '|AnnaOrdinaryDifferentialEquationPackageType|)))

\end{chunk}

\subsection{AnnaPartialDifferentialEquationPackage}
\index[pkg]{AnnaPartialDifferentialEquationPackage!Domain}
\index[pkg]{Domain!AnnaPartialDifferentialEquationPackage}
\index[pkg]{PDEPACK}
\begin{chunk}{defclass AnnaPartialDifferentialEquationPackageType}
(defclass |AnnaPartialDifferentialEquationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AnnaPartialDifferentialEquationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'PDEPACK)
   (comment :initform (list
     "AnnaPartialDifferentialEquationPackage is an uncompleted"
     "package for the interface to NAG PDE routines.  It has been realised that"
     "a new approach to solving PDEs will need to be created."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AnnaPartialDifferentialEquationPackage|
  (progn
    (push '|AnnaPartialDifferentialEquationPackage| *Packages*)
    (make-instance '|AnnaPartialDifferentialEquationPackageType|)))

\end{chunk}

\subsection{AnyFunctions1}
\index[pkg]{AnyFunctions1!Domain}
\index[pkg]{Domain!AnyFunctions1}
\index[pkg]{ANY1}
\begin{chunk}{defclass AnyFunctions1Type}
(defclass |AnyFunctions1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AnyFunctions1")
   (marker :initform 'package)
   (abbreviation :initform 'ANY1)
   (comment :initform (list
     "AnyFunctions1 implements several utility functions for"
     "working with Any. These functions are used to go back"
     "and forth between objects of Any and objects of other"
     "types."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AnyFunctions1|
  (progn
    (push '|AnyFunctions1| *Packages*)
    (make-instance '|AnyFunctions1Type|)))

\end{chunk}

\subsection{ApplicationProgramInterface}
\index[pkg]{ApplicationProgramInterface!Domain}
\index[pkg]{Domain!ApplicationProgramInterface}
\index[pkg]{API}
\begin{chunk}{defclass ApplicationProgramInterfaceType}
(defclass |ApplicationProgramInterfaceType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ApplicationProgramInterface")
   (marker :initform 'package)
   (abbreviation :initform 'API)
   (comment :initform (list
     "This package contains useful functions that expose Axiom system internals"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ApplicationProgramInterface|
  (progn
    (push '|ApplicationProgramInterface| *Packages*)
    (make-instance '|ApplicationProgramInterfaceType|)))

\end{chunk}

\subsection{ApplyRules}
\index[pkg]{ApplyRules!Domain}
\index[pkg]{Domain!ApplyRules}
\index[pkg]{APPRULE}
\begin{chunk}{defclass ApplyRulesType}
(defclass |ApplyRulesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ApplyRules")
   (marker :initform 'package)
   (abbreviation :initform 'APPRULE)
   (comment :initform (list
     "This package apply rewrite rules to expressions, calling"
     "the pattern matcher."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ApplyRules|
  (progn
    (push '|ApplyRules| *Packages*)
    (make-instance '|ApplyRulesType|)))

\end{chunk}

\subsection{ApplyUnivariateSkewPolynomial}
\index[pkg]{ApplyUnivariateSkewPolynomial!Domain}
\index[pkg]{Domain!ApplyUnivariateSkewPolynomial}
\index[pkg]{APPLYORE}
\begin{chunk}{defclass ApplyUnivariateSkewPolynomialType}
(defclass |ApplyUnivariateSkewPolynomialType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ApplyUnivariateSkewPolynomial")
   (marker :initform 'package)
   (abbreviation :initform 'APPLYORE)
   (comment :initform (list
     "ApplyUnivariateSkewPolynomial (internal) allows univariate"
     "skew polynomials to be applied to appropriate modules."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ApplyUnivariateSkewPolynomial|
  (progn
    (push '|ApplyUnivariateSkewPolynomial| *Packages*)
    (make-instance '|ApplyUnivariateSkewPolynomialType|)))

\end{chunk}

\subsection{AssociatedEquations}
\index[pkg]{AssociatedEquations!Domain}
\index[pkg]{Domain!AssociatedEquations}
\index[pkg]{ASSOCEQ}
\begin{chunk}{defclass AssociatedEquationsType}
(defclass |AssociatedEquationsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AssociatedEquations")
   (marker :initform 'package)
   (abbreviation :initform 'ASSOCEQ)
   (comment :initform (list
     "AssociatedEquations provides functions to compute the"
     "associated equations needed for factoring operators"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AssociatedEquations|
  (progn
    (push '|AssociatedEquations| *Packages*)
    (make-instance '|AssociatedEquationsType|)))

\end{chunk}

\subsection{AttachPredicates}
\index[pkg]{AttachPredicates!Domain}
\index[pkg]{Domain!AttachPredicates}
\index[pkg]{PMPRED}
\begin{chunk}{defclass AttachPredicatesType}
(defclass |AttachPredicatesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AttachPredicates")
   (marker :initform 'package)
   (abbreviation :initform 'PMPRED)
   (comment :initform (list
     "Attaching predicates to symbols for pattern matching."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AttachPredicates|
  (progn
    (push '|AttachPredicates| *Packages*)
    (make-instance '|AttachPredicatesType|)))

\end{chunk}

\subsection{AxiomServer}
\index[pkg]{AxiomServer!Domain}
\index[pkg]{Domain!AxiomServer}
\index[pkg]{AXSERV}
\begin{chunk}{defclass AxiomServerType}
(defclass |AxiomServerType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AxiomServer")
   (marker :initform 'package)
   (abbreviation :initform 'AXSERV)
   (comment :initform (list
     "This package provides a functions to support a web server for the"
     "new Axiom Browser functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AxiomServer|
  (progn
    (push '|AxiomServer| *Packages*)
    (make-instance '|AxiomServerType|)))

\end{chunk}

\section{B}

\subsection{BalancedFactorisation}
\index[pkg]{BalancedFactorisation!Domain}
\index[pkg]{Domain!BalancedFactorisation}
\index[pkg]{BALFACT}
\begin{chunk}{defclass BalancedFactorisationType}
(defclass |BalancedFactorisationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "BalancedFactorisation")
   (marker :initform 'package)
   (abbreviation :initform 'BALFACT)
   (comment :initform (list
     "This package provides balanced factorisations of polynomials."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BalancedFactorisation|
  (progn
    (push '|BalancedFactorisation| *Packages*)
    (make-instance '|BalancedFactorisationType|)))

\end{chunk}

\subsection{BasicOperatorFunctions1}
\index[pkg]{BasicOperatorFunctions1!Domain}
\index[pkg]{Domain!BasicOperatorFunctions1}
\index[pkg]{BOP1}
\begin{chunk}{defclass BasicOperatorFunctions1Type}
(defclass |BasicOperatorFunctions1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "BasicOperatorFunctions1")
   (marker :initform 'package)
   (abbreviation :initform 'BOP1)
   (comment :initform (list
     "This package exports functions to set some commonly used properties"
     "of operators, including properties which contain functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BasicOperatorFunctions1|
  (progn
    (push '|BasicOperatorFunctions1| *Packages*)
    (make-instance '|BasicOperatorFunctions1Type|)))

\end{chunk}

\subsection{Bezier}
\index[pkg]{Bezier!Domain}
\index[pkg]{Domain!Bezier}
\index[pkg]{BEZIER}
\begin{chunk}{defclass BezierType}
(defclass |BezierType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "Bezier")
   (marker :initform 'package)
   (abbreviation :initform 'BEZIER)
   (comment :initform (list
     "Provide linear, quadratic, and cubic spline bezier curves"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Bezier|
  (progn
    (push '|Bezier| *Packages*)
    (make-instance '|BezierType|)))

\end{chunk}

\subsection{BezoutMatrix}
\index[pkg]{BezoutMatrix!Domain}
\index[pkg]{Domain!BezoutMatrix}
\index[pkg]{BEZOUT}
\begin{chunk}{defclass BezoutMatrixType}
(defclass |BezoutMatrixType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "BezoutMatrix")
   (marker :initform 'package)
   (abbreviation :initform 'BEZOUT)
   (comment :initform (list
     "BezoutMatrix contains functions for computing resultants and"
     "discriminants using Bezout matrices."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BezoutMatrix|
  (progn
    (push '|BezoutMatrix| *Packages*)
    (make-instance '|BezoutMatrixType|)))

\end{chunk}

\subsection{BlowUpPackage}
\index[pkg]{BlowUpPackage!Domain}
\index[pkg]{Domain!BlowUpPackage}
\index[pkg]{BLUPPACK}
\begin{chunk}{defclass BlowUpPackageType}
(defclass |BlowUpPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "BlowUpPackage")
   (marker :initform 'package)
   (abbreviation :initform 'BLUPPACK)
   (comment :initform (list
     "The following is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BlowUpPackage|
  (progn
    (push '|BlowUpPackage| *Packages*)
    (make-instance '|BlowUpPackageType|)))

\end{chunk}

\subsection{BoundIntegerRoots}
\index[pkg]{BoundIntegerRoots!Domain}
\index[pkg]{Domain!BoundIntegerRoots}
\index[pkg]{BOUNDZRO}
\begin{chunk}{defclass BoundIntegerRootsType}
(defclass |BoundIntegerRootsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "BoundIntegerRoots")
   (marker :initform 'package)
   (abbreviation :initform 'BOUNDZRO)
   (comment :initform (list
     "BoundIntegerRoots provides functions to"
     "find lower bounds on the integer roots of a polynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BoundIntegerRoots|
  (progn
    (push '|BoundIntegerRoots| *Packages*)
    (make-instance '|BoundIntegerRootsType|)))

\end{chunk}

\subsection{BrillhartTests}
\index[pkg]{BrillhartTests!Domain}
\index[pkg]{Domain!BrillhartTests}
\index[pkg]{BRILL}
\begin{chunk}{defclass BrillhartTestsType}
(defclass |BrillhartTestsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "BrillhartTests")
   (marker :initform 'package)
   (abbreviation :initform 'BRILL)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BrillhartTests|
  (progn
    (push '|BrillhartTests| *Packages*)
    (make-instance '|BrillhartTestsType|)))

\end{chunk}

\section{C}

\subsection{CartesianTensorFunctions2}
\index[pkg]{CartesianTensorFunctions2!Domain}
\index[pkg]{Domain!CartesianTensorFunctions2}
\index[pkg]{CARTEN2}
\begin{chunk}{defclass CartesianTensorFunctions2Type}
(defclass |CartesianTensorFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CartesianTensorFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'CARTEN2)
   (comment :initform (list
     "This package provides functions to enable conversion of tensors"
     "given conversion of the components."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CartesianTensorFunctions2|
  (progn
    (push '|CartesianTensorFunctions2| *Packages*)
    (make-instance '|CartesianTensorFunctions2Type|)))

\end{chunk}

\subsection{ChangeOfVariable}
\index[pkg]{ChangeOfVariable!Domain}
\index[pkg]{Domain!ChangeOfVariable}
\index[pkg]{CHVAR}
\begin{chunk}{defclass ChangeOfVariableType}
(defclass |ChangeOfVariableType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ChangeOfVariable")
   (marker :initform 'package)
   (abbreviation :initform 'CHVAR)
   (comment :initform (list
     "Tools to send a point to infinity on an algebraic curve."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ChangeOfVariable|
  (progn
    (push '|ChangeOfVariable| *Packages*)
    (make-instance '|ChangeOfVariableType|)))

\end{chunk}

\subsection{CharacteristicPolynomialInMonogenicalAlgebra}
\index[pkg]{CharacteristicPolynomialInMonogenicalAlgebra!Domain}
\index[pkg]{Domain!CharacteristicPolynomialInMonogenicalAlgebra}
\index[pkg]{CPIMA}
\begin{chunk}{defclass CharacteristicPolynomialInMonogenicalAlgebraType}
(defclass |CharacteristicPolynomialInMonogenicalAlgebraType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CharacteristicPolynomialInMonogenicalAlgebra")
   (marker :initform 'package)
   (abbreviation :initform 'CPIMA)
   (comment :initform (list
     "This package implements characteristicPolynomials for monogenic algebras"
     "using resultants"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CharacteristicPolynomialInMonogenicalAlgebra|
  (progn
    (push '|CharacteristicPolynomialInMonogenicalAlgebra| *Packages*)
    (make-instance '|CharacteristicPolynomialInMonogenicalAlgebraType|)))

\end{chunk}

\subsection{CharacteristicPolynomialPackage}
\index[pkg]{CharacteristicPolynomialPackage!Domain}
\index[pkg]{Domain!CharacteristicPolynomialPackage}
\index[pkg]{CHARPOL}
\begin{chunk}{defclass CharacteristicPolynomialPackageType}
(defclass |CharacteristicPolynomialPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CharacteristicPolynomialPackage")
   (marker :initform 'package)
   (abbreviation :initform 'CHARPOL)
   (comment :initform (list
     "This package provides a characteristicPolynomial function"
     "for any matrix over a commutative ring."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CharacteristicPolynomialPackage|
  (progn
    (push '|CharacteristicPolynomialPackage| *Packages*)
    (make-instance '|CharacteristicPolynomialPackageType|)))

\end{chunk}

\subsection{ChineseRemainderToolsForIntegralBases}
\index[pkg]{ChineseRemainderToolsForIntegralBases!Domain}
\index[pkg]{Domain!ChineseRemainderToolsForIntegralBases}
\index[pkg]{IBACHIN}
\begin{chunk}{defclass ChineseRemainderToolsForIntegralBasesType}
(defclass |ChineseRemainderToolsForIntegralBasesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ChineseRemainderToolsForIntegralBases")
   (marker :initform 'package)
   (abbreviation :initform 'IBACHIN)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ChineseRemainderToolsForIntegralBases|
  (progn
    (push '|ChineseRemainderToolsForIntegralBases| *Packages*)
    (make-instance '|ChineseRemainderToolsForIntegralBasesType|)))

\end{chunk}

\subsection{CoerceVectorMatrixPackage}
\index[pkg]{CoerceVectorMatrixPackage!Domain}
\index[pkg]{Domain!CoerceVectorMatrixPackage}
\index[pkg]{CVMP}
\begin{chunk}{defclass CoerceVectorMatrixPackageType}
(defclass |CoerceVectorMatrixPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CoerceVectorMatrixPackage")
   (marker :initform 'package)
   (abbreviation :initform 'CVMP)
   (comment :initform (list
     "CoerceVectorMatrixPackage is an unexposed, technical package"
     "for data conversions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CoerceVectorMatrixPackage|
  (progn
    (push '|CoerceVectorMatrixPackage| *Packages*)
    (make-instance '|CoerceVectorMatrixPackageType|)))

\end{chunk}

\subsection{CombinatorialFunction}
\index[pkg]{CombinatorialFunction!Domain}
\index[pkg]{Domain!CombinatorialFunction}
\index[pkg]{COMBF}
\begin{chunk}{defclass CombinatorialFunctionType}
(defclass |CombinatorialFunctionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CombinatorialFunction")
   (marker :initform 'package)
   (abbreviation :initform 'COMBF)
   (comment :initform (list
     "Provides combinatorial functions over an integral domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CombinatorialFunction|
  (progn
    (push '|CombinatorialFunction| *Packages*)
    (make-instance '|CombinatorialFunctionType|)))

\end{chunk}

\subsection{CommonDenominator}
\index[pkg]{CommonDenominator!Domain}
\index[pkg]{Domain!CommonDenominator}
\index[pkg]{CDEN}
\begin{chunk}{defclass CommonDenominatorType}
(defclass |CommonDenominatorType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CommonDenominator")
   (marker :initform 'package)
   (abbreviation :initform 'CDEN)
   (comment :initform (list
     "CommonDenominator provides functions to compute the"
     "common denominator of a finite linear aggregate of elements of"
     "the quotient field of an integral domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CommonDenominator|
  (progn
    (push '|CommonDenominator| *Packages*)
    (make-instance '|CommonDenominatorType|)))

\end{chunk}

\subsection{CommonOperators}
\index[pkg]{CommonOperators!Domain}
\index[pkg]{Domain!CommonOperators}
\index[pkg]{COMMONOP}
\begin{chunk}{defclass CommonOperatorsType}
(defclass |CommonOperatorsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CommonOperators")
   (marker :initform 'package)
   (abbreviation :initform 'COMMONOP)
   (comment :initform (list
     "This package exports the elementary operators, with some semantics"
     "already attached to them. The semantics that is attached here is not"
     "dependent on the set in which the operators will be applied."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CommonOperators|
  (progn
    (push '|CommonOperators| *Packages*)
    (make-instance '|CommonOperatorsType|)))

\end{chunk}

\subsection{CommuteUnivariatePolynomialCategory}
\index[pkg]{CommuteUnivariatePolynomialCategory!Domain}
\index[pkg]{Domain!CommuteUnivariatePolynomialCategory}
\index[pkg]{COMMUPC}
\begin{chunk}{defclass CommuteUnivariatePolynomialCategoryType}
(defclass |CommuteUnivariatePolynomialCategoryType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CommuteUnivariatePolynomialCategory")
   (marker :initform 'package)
   (abbreviation :initform 'COMMUPC)
   (comment :initform (list
     "A package for swapping the order of two variables in a tower of two"
     "UnivariatePolynomialCategory extensions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CommuteUnivariatePolynomialCategory|
  (progn
    (push '|CommuteUnivariatePolynomialCategory| *Packages*)
    (make-instance '|CommuteUnivariatePolynomialCategoryType|)))

\end{chunk}

\subsection{ComplexFactorization}
\index[pkg]{ComplexFactorization!Domain}
\index[pkg]{Domain!ComplexFactorization}
\index[pkg]{COMPFACT}
\begin{chunk}{defclass ComplexFactorizationType}
(defclass |ComplexFactorizationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ComplexFactorization")
   (marker :initform 'package)
   (abbreviation :initform 'COMPFACT)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ComplexFactorization|
  (progn
    (push '|ComplexFactorization| *Packages*)
    (make-instance '|ComplexFactorizationType|)))

\end{chunk}

\subsection{ComplexFunctions2}
\index[pkg]{ComplexFunctions2!Domain}
\index[pkg]{Domain!ComplexFunctions2}
\index[pkg]{COMPLEX2}
\begin{chunk}{defclass ComplexFunctions2Type}
(defclass |ComplexFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ComplexFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'COMPLEX2)
   (comment :initform (list
     "This package extends maps from underlying rings to maps between"
     "complex over those rings."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ComplexFunctions2|
  (progn
    (push '|ComplexFunctions2| *Packages*)
    (make-instance '|ComplexFunctions2Type|)))

\end{chunk}

\subsection{ComplexIntegerSolveLinearPolynomialEquation}
\index[pkg]{ComplexIntegerSolveLinearPolynomialEquation!Domain}
\index[pkg]{Domain!ComplexIntegerSolveLinearPolynomialEquation}
\index[pkg]{CINTSLPE}
\begin{chunk}{defclass ComplexIntegerSolveLinearPolynomialEquationType}
(defclass |ComplexIntegerSolveLinearPolynomialEquationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ComplexIntegerSolveLinearPolynomialEquation")
   (marker :initform 'package)
   (abbreviation :initform 'CINTSLPE)
   (comment :initform (list
     "This package provides the generalized euclidean algorithm which is"
     "needed as the basic step for factoring polynomials."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ComplexIntegerSolveLinearPolynomialEquation|
  (progn
    (push '|ComplexIntegerSolveLinearPolynomialEquation| *Packages*)
    (make-instance '|ComplexIntegerSolveLinearPolynomialEquationType|)))

\end{chunk}

\subsection{ComplexPattern}
\index[pkg]{ComplexPattern!Domain}
\index[pkg]{Domain!ComplexPattern}
\index[pkg]{COMPLPAT}
\begin{chunk}{defclass ComplexPatternType}
(defclass |ComplexPatternType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ComplexPattern")
   (marker :initform 'package)
   (abbreviation :initform 'COMPLPAT)
   (comment :initform (list
     "This package supports converting complex expressions to patterns"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ComplexPattern|
  (progn
    (push '|ComplexPattern| *Packages*)
    (make-instance '|ComplexPatternType|)))

\end{chunk}

\subsection{ComplexPatternMatch}
\index[pkg]{ComplexPatternMatch!Domain}
\index[pkg]{Domain!ComplexPatternMatch}
\index[pkg]{CPMATCH}
\begin{chunk}{defclass ComplexPatternMatchType}
(defclass |ComplexPatternMatchType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ComplexPatternMatch")
   (marker :initform 'package)
   (abbreviation :initform 'CPMATCH)
   (comment :initform (list
     "This package supports matching patterns involving complex expressions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ComplexPatternMatch|
  (progn
    (push '|ComplexPatternMatch| *Packages*)
    (make-instance '|ComplexPatternMatchType|)))

\end{chunk}

\subsection{ComplexRootFindingPackage}
\index[pkg]{ComplexRootFindingPackage!Domain}
\index[pkg]{Domain!ComplexRootFindingPackage}
\index[pkg]{CRFP}
\begin{chunk}{defclass ComplexRootFindingPackageType}
(defclass |ComplexRootFindingPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ComplexRootFindingPackage")
   (marker :initform 'package)
   (abbreviation :initform 'CRFP)
   (comment :initform (list
     "ComplexRootFindingPackage provides functions to"
     "find all roots of a polynomial p over the complex number by"
     "using Plesken's idea to calculate in the polynomial ring"
     "modulo f and employing the Chinese Remainder Theorem."
     "In this first version, the precision (see digits)"
     "is not increased when this is necessary to"
     "avoid rounding errors. Hence it is the user's responsibility to"
     "increase the precision if necessary."
     "Note also, if this package is called with, for example, Fraction Integer,"
     "the precise calculations could require a lot of time."
     "Also note that evaluating the zeros is not necessarily a good check"
     "whether the result is correct: already evaluation can cause"
     "rounding errors."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ComplexRootFindingPackage|
  (progn
    (push '|ComplexRootFindingPackage| *Packages*)
    (make-instance '|ComplexRootFindingPackageType|)))

\end{chunk}

\subsection{ComplexRootPackage}
\index[pkg]{ComplexRootPackage!Domain}
\index[pkg]{Domain!ComplexRootPackage}
\index[pkg]{CMPLXRT}
\begin{chunk}{defclass ComplexRootPackageType}
(defclass |ComplexRootPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ComplexRootPackage")
   (marker :initform 'package)
   (abbreviation :initform 'CMPLXRT)
   (comment :initform (list
     "This package provides functions complexZeros"
     "for finding the complex zeros"
     "of univariate polynomials with complex rational number coefficients."
     "The results are to any user specified precision and are returned"
     "as either complex rational number or complex floating point numbers"
     "depending on the type of the second argument which specifies the"
     "precision."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ComplexRootPackage|
  (progn
    (push '|ComplexRootPackage| *Packages*)
    (make-instance '|ComplexRootPackageType|)))

\end{chunk}

\subsection{ComplexTrigonometricManipulations}
\index[pkg]{ComplexTrigonometricManipulations!Domain}
\index[pkg]{Domain!ComplexTrigonometricManipulations}
\index[pkg]{CTRIGMNP}
\begin{chunk}{defclass ComplexTrigonometricManipulationsType}
(defclass |ComplexTrigonometricManipulationsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ComplexTrigonometricManipulations")
   (marker :initform 'package)
   (abbreviation :initform 'CTRIGMNP)
   (comment :initform (list
     "ComplexTrigonometricManipulations provides function that"
     "compute the real and imaginary parts of complex functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ComplexTrigonometricManipulations|
  (progn
    (push '|ComplexTrigonometricManipulations| *Packages*)
    (make-instance '|ComplexTrigonometricManipulationsType|)))

\end{chunk}

\subsection{ConstantLODE}
\index[pkg]{ConstantLODE!Domain}
\index[pkg]{Domain!ConstantLODE}
\index[pkg]{ODECONST}
\begin{chunk}{defclass ConstantLODEType}
(defclass |ConstantLODEType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ConstantLODE")
   (marker :initform 'package)
   (abbreviation :initform 'ODECONST)
   (comment :initform (list
     "Solution of linear ordinary differential equations,"
     "constant coefficient case."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ConstantLODE|
  (progn
    (push '|ConstantLODE| *Packages*)
    (make-instance '|ConstantLODEType|)))

\end{chunk}

\subsection{CoordinateSystems}
\index[pkg]{CoordinateSystems!Domain}
\index[pkg]{Domain!CoordinateSystems}
\index[pkg]{COORDSYS}
\begin{chunk}{defclass CoordinateSystemsType}
(defclass |CoordinateSystemsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CoordinateSystems")
   (marker :initform 'package)
   (abbreviation :initform 'COORDSYS)
   (comment :initform (list
     "CoordinateSystems provides coordinate transformation functions"
     "for plotting.  Functions in this package return conversion functions"
     "which take points expressed in other coordinate systems and return points"
     "with the corresponding Cartesian coordinates."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CoordinateSystems|
  (progn
    (push '|CoordinateSystems| *Packages*)
    (make-instance '|CoordinateSystemsType|)))

\end{chunk}

\subsection{CRApackage}
\index[pkg]{CRApackage!Domain}
\index[pkg]{Domain!CRApackage}
\index[pkg]{CRAPACK}
\begin{chunk}{defclass CRApackageType}
(defclass |CRApackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CRApackage")
   (marker :initform 'package)
   (abbreviation :initform 'CRAPACK)
   (comment :initform (list
     "This package has no documentation"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CRApackage|
  (progn
    (push '|CRApackage| *Packages*)
    (make-instance '|CRApackageType|)))

\end{chunk}

\subsection{CycleIndicators}
\index[pkg]{CycleIndicators!Domain}
\index[pkg]{Domain!CycleIndicators}
\index[pkg]{CYCLES}
\begin{chunk}{defclass CycleIndicatorsType}
(defclass |CycleIndicatorsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CycleIndicators")
   (marker :initform 'package)
   (abbreviation :initform 'CYCLES)
   (comment :initform (list
     "Polya-Redfield enumeration by cycle indices."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CycleIndicators|
  (progn
    (push '|CycleIndicators| *Packages*)
    (make-instance '|CycleIndicatorsType|)))

\end{chunk}

\subsection{CyclicStreamTools}
\index[pkg]{CyclicStreamTools!Domain}
\index[pkg]{Domain!CyclicStreamTools}
\index[pkg]{CSTTOOLS}
\begin{chunk}{defclass CyclicStreamToolsType}
(defclass |CyclicStreamToolsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CyclicStreamTools")
   (marker :initform 'package)
   (abbreviation :initform 'CSTTOOLS)
   (comment :initform (list
     "This package provides tools for working with cyclic streams."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CyclicStreamTools|
  (progn
    (push '|CyclicStreamTools| *Packages*)
    (make-instance '|CyclicStreamToolsType|)))

\end{chunk}

\subsection{CyclotomicPolynomialPackage}
\index[pkg]{CyclotomicPolynomialPackage!Domain}
\index[pkg]{Domain!CyclotomicPolynomialPackage}
\index[pkg]{CYCLOTOM}
\begin{chunk}{defclass CyclotomicPolynomialPackageType}
(defclass |CyclotomicPolynomialPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CyclotomicPolynomialPackage")
   (marker :initform 'package)
   (abbreviation :initform 'CYCLOTOM)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CyclotomicPolynomialPackage|
  (progn
    (push '|CyclotomicPolynomialPackage| *Packages*)
    (make-instance '|CyclotomicPolynomialPackageType|)))

\end{chunk}

\subsection{CylindricalAlgebraicDecompositionPackage}
\index[pkg]{CylindricalAlgebraicDecompositionPackage!Domain}
\index[pkg]{Domain!CylindricalAlgebraicDecompositionPackage}
\index[pkg]{CAD}
\begin{chunk}{defclass CylindricalAlgebraicDecompositionPackageType}
(defclass |CylindricalAlgebraicDecompositionPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CylindricalAlgebraicDecompositionPackage")
   (marker :initform 'package)
   (abbreviation :initform 'CAD)
   (comment :initform nil)
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CylindricalAlgebraicDecompositionPackage|
  (progn
    (push '|CylindricalAlgebraicDecompositionPackage| *Packages*)
    (make-instance '|CylindricalAlgebraicDecompositionPackageType|)))

\end{chunk}

\subsection{CylindricalAlgebraicDecompositionUtilities}
\index[pkg]{CylindricalAlgebraicDecompositionUtilities!Domain}
\index[pkg]{Domain!CylindricalAlgebraicDecompositionUtilities}
\index[pkg]{CADU}
\begin{chunk}{defclass CylindricalAlgebraicDecompositionUtilitiesType}
(defclass |CylindricalAlgebraicDecompositionUtilitiesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CylindricalAlgebraicDecompositionUtilities")
   (marker :initform 'package)
   (abbreviation :initform 'CADU)
   (comment :initform nil)
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CylindricalAlgebraicDecompositionUtilities|
  (progn
    (push '|CylindricalAlgebraicDecompositionUtilities| *Packages*)
    (make-instance '|CylindricalAlgebraicDecompositionUtilitiesType|)))

\end{chunk}

\section{D}

\subsection{DefiniteIntegrationTools}
\index[pkg]{DefiniteIntegrationTools!Domain}
\index[pkg]{Domain!DefiniteIntegrationTools}
\index[pkg]{DFINTTLS}
\begin{chunk}{defclass DefiniteIntegrationToolsType}
(defclass |DefiniteIntegrationToolsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "DefiniteIntegrationTools")
   (marker :initform 'package)
   (abbreviation :initform 'DFINTTLS)
   (comment :initform (list
     "DefiniteIntegrationTools provides common tools used"
     "by the definite integration of both rational and elementary functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DefiniteIntegrationTools|
  (progn
    (push '|DefiniteIntegrationTools| *Packages*)
    (make-instance '|DefiniteIntegrationToolsType|)))

\end{chunk}

\subsection{DegreeReductionPackage}
\index[pkg]{DegreeReductionPackage!Domain}
\index[pkg]{Domain!DegreeReductionPackage}
\index[pkg]{DEGRED}
\begin{chunk}{defclass DegreeReductionPackageType}
(defclass |DegreeReductionPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "DegreeReductionPackage")
   (marker :initform 'package)
   (abbreviation :initform 'DEGRED)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DegreeReductionPackage|
  (progn
    (push '|DegreeReductionPackage| *Packages*)
    (make-instance '|DegreeReductionPackageType|)))

\end{chunk}

\subsection{DesingTreePackage}
\index[pkg]{DesingTreePackage!Domain}
\index[pkg]{Domain!DesingTreePackage}
\index[pkg]{DTP}
\begin{chunk}{defclass DesingTreePackageType}
(defclass |DesingTreePackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "DesingTreePackage")
   (marker :initform 'package)
   (abbreviation :initform 'DTP)
   (comment :initform (list
     "The following is all the categories, domains and package"
     "used for the desingularisation be means of"
     "monoidal transformation (Blowing-up)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DesingTreePackage|
  (progn
    (push '|DesingTreePackage| *Packages*)
    (make-instance '|DesingTreePackageType|)))

\end{chunk}

\subsection{DiophantineSolutionPackage}
\index[pkg]{DiophantineSolutionPackage!Domain}
\index[pkg]{Domain!DiophantineSolutionPackage}
\index[pkg]{DIOSP}
\begin{chunk}{defclass DiophantineSolutionPackageType}
(defclass |DiophantineSolutionPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "DiophantineSolutionPackage")
   (marker :initform 'package)
   (abbreviation :initform 'DIOSP)
   (comment :initform (list
     "Any solution of a homogeneous linear Diophantine equation"
     "can be represented as a sum of minimal solutions, which"
     "form a 'basis' (a minimal solution cannot be represented"
     "as a nontrivial sum of solutions)"
     "in the case of an inhomogeneous linear Diophantine equation,"
     "each solution is the sum of a inhomogeneous solution and"
     "any number of homogeneous solutions"
     "therefore, it suffices to compute two sets:"
     "1. all minimal inhomogeneous solutions"
     "2. all minimal homogeneous solutions"
     "the algorithm implemented is a completion procedure, which"
     "enumerates all solutions in a recursive depth-first-search"
     "it can be seen as finding monotone paths in a graph"
     "for more details see Reference"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DiophantineSolutionPackage|
  (progn
    (push '|DiophantineSolutionPackage| *Packages*)
    (make-instance '|DiophantineSolutionPackageType|)))

\end{chunk}

\subsection{DirectProductFunctions2}
\index[pkg]{DirectProductFunctions2!Domain}
\index[pkg]{Domain!DirectProductFunctions2}
\index[pkg]{DIRPROD2}
\begin{chunk}{defclass DirectProductFunctions2Type}
(defclass |DirectProductFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "DirectProductFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'DIRPROD2)
   (comment :initform (list
     "This package provides operations which all take as arguments direct"
     "products of elements of some type A and functions from A"
     "to another type B. The operations all iterate over their vector argument"
     "and either return a value of type B or a direct product over B."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DirectProductFunctions2|
  (progn
    (push '|DirectProductFunctions2| *Packages*)
    (make-instance '|DirectProductFunctions2Type|)))

\end{chunk}

\subsection{DiscreteLogarithmPackage}
\index[pkg]{DiscreteLogarithmPackage!Domain}
\index[pkg]{Domain!DiscreteLogarithmPackage}
\index[pkg]{DLP}
\begin{chunk}{defclass DiscreteLogarithmPackageType}
(defclass |DiscreteLogarithmPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "DiscreteLogarithmPackage")
   (marker :initform 'package)
   (abbreviation :initform 'DLP)
   (comment :initform (list
     "DiscreteLogarithmPackage implements help functions for discrete logarithms"
     "in monoids using small cyclic groups."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DiscreteLogarithmPackage|
  (progn
    (push '|DiscreteLogarithmPackage| *Packages*)
    (make-instance '|DiscreteLogarithmPackageType|)))

\end{chunk}

\subsection{DisplayPackage}
\index[pkg]{DisplayPackage!Domain}
\index[pkg]{Domain!DisplayPackage}
\index[pkg]{DISPLAY}
\begin{chunk}{defclass DisplayPackageType}
(defclass |DisplayPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "DisplayPackage")
   (marker :initform 'package)
   (abbreviation :initform 'DISPLAY)
   (comment :initform (list
     "DisplayPackage allows one to print strings in a nice manner,"
     "including highlighting substrings."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DisplayPackage|
  (progn
    (push '|DisplayPackage| *Packages*)
    (make-instance '|DisplayPackageType|)))

\end{chunk}

\subsection{DistinctDegreeFactorize}
\index[pkg]{DistinctDegreeFactorize!Domain}
\index[pkg]{Domain!DistinctDegreeFactorize}
\index[pkg]{DDFACT}
\begin{chunk}{defclass DistinctDegreeFactorizeType}
(defclass |DistinctDegreeFactorizeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "DistinctDegreeFactorize")
   (marker :initform 'package)
   (abbreviation :initform 'DDFACT)
   (comment :initform (list
     "Package for the factorization of a univariate polynomial with"
     "coefficients in a finite field. The algorithm used is the"
     "'distinct degree' algorithm of Cantor-Zassenhaus, modified"
     "to use trace instead of the norm and a table for computing"
     "Frobenius as suggested by Naudin and Quitte."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DistinctDegreeFactorize|
  (progn
    (push '|DistinctDegreeFactorize| *Packages*)
    (make-instance '|DistinctDegreeFactorizeType|)))

\end{chunk}

\subsection{DoubleFloatSpecialFunctions}
\index[pkg]{DoubleFloatSpecialFunctions!Domain}
\index[pkg]{Domain!DoubleFloatSpecialFunctions}
\index[pkg]{DFSFUN}
\label{package DFSFUN DoubleFloatSpecialFunctions}
\begin{chunk}{defclass DoubleFloatSpecialFunctionsType}
(defclass |DoubleFloatSpecialFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "DoubleFloatSpecialFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'DFSFUN)
   (comment :initform (list
     "This package provides special functions for double precision"
     "real and complex floating point."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DoubleFloatSpecialFunctions|
  (progn
    (push '|DoubleFloatSpecialFunctions| *Packages*)
    (make-instance '|DoubleFloatSpecialFunctionsType|)))

\end{chunk}

\subsection{DoubleResultantPackage}
\index[pkg]{DoubleResultantPackage!Domain}
\index[pkg]{Domain!DoubleResultantPackage}
\index[pkg]{DBLRESP}
\begin{chunk}{defclass DoubleResultantPackageType}
(defclass |DoubleResultantPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "DoubleResultantPackage")
   (marker :initform 'package)
   (abbreviation :initform 'DBLRESP)
   (comment :initform (list
     "This package provides functions for computing the residues"
     "of a function on an algebraic curve."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DoubleResultantPackage|
  (progn
    (push '|DoubleResultantPackage| *Packages*)
    (make-instance '|DoubleResultantPackageType|)))

\end{chunk}

\subsection{DrawComplex}
\index[pkg]{DrawComplex!Domain}
\index[pkg]{Domain!DrawComplex}
\index[pkg]{DRAWCX}
\begin{chunk}{defclass DrawComplexType}
(defclass |DrawComplexType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "DrawComplex")
   (marker :initform 'package)
   (abbreviation :initform 'DRAWCX)
   (comment :initform (list
     "DrawComplex provides some facilities"
     "for drawing complex functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DrawComplex|
  (progn
    (push '|DrawComplex| *Packages*)
    (make-instance '|DrawComplexType|)))

\end{chunk}

\subsection{DrawNumericHack}
\index[pkg]{DrawNumericHack!Domain}
\index[pkg]{Domain!DrawNumericHack}
\index[pkg]{DRAWHACK}
\begin{chunk}{defclass DrawNumericHackType}
(defclass |DrawNumericHackType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "DrawNumericHack")
   (marker :initform 'package)
   (abbreviation :initform 'DRAWHACK)
   (comment :initform (list
     "Hack for the draw interface. DrawNumericHack provides"
     "a 'coercion' from something of the form x = a..b where a" 
     "and b are"
     "formal expressions to a binding of the form x = c..d where c and d"
     "are the numerical values of a and b. This 'coercion' fails if"
     "a and b contains symbolic variables, but is meant for expressions"
     "involving %pi."
     "Note that this package is meant for internal use only."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DrawNumericHack|
  (progn
    (push '|DrawNumericHack| *Packages*)
    (make-instance '|DrawNumericHackType|)))

\end{chunk}

\subsection{DrawOptionFunctions0}
\index[pkg]{DrawOptionFunctions0!Domain}
\index[pkg]{Domain!DrawOptionFunctions0}
\index[pkg]{DROPT0}
\begin{chunk}{defclass DrawOptionFunctions0Type}
(defclass |DrawOptionFunctions0Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "DrawOptionFunctions0")
   (marker :initform 'package)
   (abbreviation :initform 'DROPT0)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DrawOptionFunctions0|
  (progn
    (push '|DrawOptionFunctions0| *Packages*)
    (make-instance '|DrawOptionFunctions0Type|)))

\end{chunk}

\subsection{DrawOptionFunctions1}
\index[pkg]{DrawOptionFunctions1!Domain}
\index[pkg]{Domain!DrawOptionFunctions1}
\index[pkg]{DROPT1}
\begin{chunk}{defclass DrawOptionFunctions1Type}
(defclass |DrawOptionFunctions1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "DrawOptionFunctions1")
   (marker :initform 'package)
   (abbreviation :initform 'DROPT1)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DrawOptionFunctions1|
  (progn
    (push '|DrawOptionFunctions1| *Packages*)
    (make-instance '|DrawOptionFunctions1Type|)))

\end{chunk}

\subsection{d01AgentsPackage}
\index[pkg]{d01AgentsPackage!Domain}
\index[pkg]{Domain!d01AgentsPackage}
\index[pkg]{D01AGNT}
\begin{chunk}{defclass d01AgentsPackageType}
(defclass |d01AgentsPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "d01AgentsPackage")
   (marker :initform 'package)
   (abbreviation :initform 'D01AGNT)
   (comment :initform (list
     "d01AgentsPackage is a package of numerical agents to be used"
     "to investigate attributes of an input function so as to decide the"
     "measure of an appropriate numerical integration routine."
     "It contains functions rangeIsFinite to test the input range and"
     "functionIsContinuousAtEndPoints to check for continuity at"
     "the end points of the range."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d01AgentsPackage|
  (progn
    (push '|d01AgentsPackage| *Packages*)
    (make-instance '|d01AgentsPackageType|)))

\end{chunk}

\subsection{d01WeightsPackage}
\index[pkg]{d01WeightsPackage!Domain}
\index[pkg]{Domain!d01WeightsPackage}
\index[pkg]{D01WGTS}
\begin{chunk}{defclass d01WeightsPackageType}
(defclass |d01WeightsPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "d01WeightsPackage")
   (marker :initform 'package)
   (abbreviation :initform 'D01WGTS)
   (comment :initform (list
     "d01WeightsPackage is a package for functions used to investigate"
     "whether a function can be divided into a simpler function and a weight"
     "function.  The types of weights investigated are those giving rise to"
     "end-point singularities of the algebraico-logarithmic type, and"
     "trigonometric weights."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d01WeightsPackage|
  (progn
    (push '|d01WeightsPackage| *Packages*)
    (make-instance '|d01WeightsPackageType|)))

\end{chunk}

\subsection{d02AgentsPackage}
\index[pkg]{d02AgentsPackage!Domain}
\index[pkg]{Domain!d02AgentsPackage}
\index[pkg]{D02AGNT}
\begin{chunk}{defclass d02AgentsPackageType}
(defclass |d02AgentsPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "d02AgentsPackage")
   (marker :initform 'package)
   (abbreviation :initform 'D02AGNT)
   (comment :initform nil)
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d02AgentsPackage|
  (progn
    (push '|d02AgentsPackage| *Packages*)
    (make-instance '|d02AgentsPackageType|)))

\end{chunk}

\subsection{d03AgentsPackage}
\index[pkg]{d03AgentsPackage!Domain}
\index[pkg]{Domain!d03AgentsPackage}
\index[pkg]{D03AGNT}
\begin{chunk}{defclass d03AgentsPackageType}
(defclass |d03AgentsPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "d03AgentsPackage")
   (marker :initform 'package)
   (abbreviation :initform 'D03AGNT)
   (comment :initform (list
     "d03AgentsPackage contains a set of computational agents"
     "for use with Partial Differential Equation solvers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d03AgentsPackage|
  (progn
    (push '|d03AgentsPackage| *Packages*)
    (make-instance '|d03AgentsPackageType|)))

\end{chunk}

\section{E}

\subsection{EigenPackage}
\index[pkg]{EigenPackage!Domain}
\index[pkg]{Domain!EigenPackage}
\index[pkg]{EP}
\begin{chunk}{defclass EigenPackageType}
(defclass |EigenPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "EigenPackage")
   (marker :initform 'package)
   (abbreviation :initform 'EP)
   (comment :initform (list
     "This is a package for the exact computation of eigenvalues and eigenvectors."
     "This package can be made to work for matrices with coefficients which are"
     "rational functions over a ring where we can factor polynomials."
     "Rational eigenvalues are always explicitly computed while the"
     "non-rational ones are expressed in terms of their minimal polynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |EigenPackage|
  (progn
    (push '|EigenPackage| *Packages*)
    (make-instance '|EigenPackageType|)))

\end{chunk}

\subsection{ElementaryFunction}
\index[pkg]{ElementaryFunction!Domain}
\index[pkg]{Domain!ElementaryFunction}
\index[pkg]{EF}
\begin{chunk}{defclass ElementaryFunctionType}
(defclass |ElementaryFunctionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ElementaryFunction")
   (marker :initform 'package)
   (abbreviation :initform 'EF)
   (comment :initform (list
     "Provides elementary functions over an integral domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ElementaryFunction|
  (progn
    (push '|ElementaryFunction| *Packages*)
    (make-instance '|ElementaryFunctionType|)))

\end{chunk}

\subsection{ElementaryFunctionDefiniteIntegration}
\index[pkg]{ElementaryFunctionDefiniteIntegration!Domain}
\index[pkg]{Domain!ElementaryFunctionDefiniteIntegration}
\index[pkg]{DEFINTEF}
\begin{chunk}{defclass ElementaryFunctionDefiniteIntegrationType}
(defclass |ElementaryFunctionDefiniteIntegrationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ElementaryFunctionDefiniteIntegration")
   (marker :initform 'package)
   (abbreviation :initform 'DEFINTEF)
   (comment :initform (list
     "RationalFunctionDefiniteIntegration provides functions to"
     "compute definite integrals of rational functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ElementaryFunctionDefiniteIntegration|
  (progn
    (push '|ElementaryFunctionDefiniteIntegration| *Packages*)
    (make-instance '|ElementaryFunctionDefiniteIntegrationType|)))

\end{chunk}

\subsection{ElementaryFunctionLODESolver}
\index[pkg]{ElementaryFunctionLODESolver!Domain}
\index[pkg]{Domain!ElementaryFunctionLODESolver}
\index[pkg]{LODEEF}
\begin{chunk}{defclass ElementaryFunctionLODESolverType}
(defclass |ElementaryFunctionLODESolverType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ElementaryFunctionLODESolver")
   (marker :initform 'package)
   (abbreviation :initform 'LODEEF)
   (comment :initform (list
     "ElementaryFunctionLODESolver provides the top-level"
     "functions for finding closed form solutions of linear ordinary"
     "differential equations and initial value problems."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ElementaryFunctionLODESolver|
  (progn
    (push '|ElementaryFunctionLODESolver| *Packages*)
    (make-instance '|ElementaryFunctionLODESolverType|)))

\end{chunk}

\subsection{ElementaryFunctionODESolver}
\index[pkg]{ElementaryFunctionODESolver!Domain}
\index[pkg]{Domain!ElementaryFunctionODESolver}
\index[pkg]{ODEEF}
\begin{chunk}{defclass ElementaryFunctionODESolverType}
(defclass |ElementaryFunctionODESolverType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ElementaryFunctionODESolver")
   (marker :initform 'package)
   (abbreviation :initform 'ODEEF)
   (comment :initform (list
     "ElementaryFunctionODESolver provides the top-level"
     "functions for finding closed form solutions of ordinary"
     "differential equations and initial value problems."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ElementaryFunctionODESolver|
  (progn
    (push '|ElementaryFunctionODESolver| *Packages*)
    (make-instance '|ElementaryFunctionODESolverType|)))

\end{chunk}

\subsection{ElementaryFunctionSign}
\index[pkg]{ElementaryFunctionSign!Domain}
\index[pkg]{Domain!ElementaryFunctionSign}
\index[pkg]{SIGNEF}
\begin{chunk}{defclass ElementaryFunctionSignType}
(defclass |ElementaryFunctionSignType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ElementaryFunctionSign")
   (marker :initform 'package)
   (abbreviation :initform 'SIGNEF)
   (comment :initform (list
     "This package provides functions to determine the sign of an"
     "elementary function around a point or infinity."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ElementaryFunctionSign|
  (progn
    (push '|ElementaryFunctionSign| *Packages*)
    (make-instance '|ElementaryFunctionSignType|)))

\end{chunk}

\subsection{ElementaryFunctionStructurePackage}
\index[pkg]{ElementaryFunctionStructurePackage!Domain}
\index[pkg]{Domain!ElementaryFunctionStructurePackage}
\index[pkg]{EFSTRUC}
\begin{chunk}{defclass ElementaryFunctionStructurePackageType}
(defclass |ElementaryFunctionStructurePackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ElementaryFunctionStructurePackage")
   (marker :initform 'package)
   (abbreviation :initform 'EFSTRUC)
   (comment :initform (list
     "ElementaryFunctionStructurePackage provides functions to test the"
     "algebraic independence of various elementary functions, using the"
     "Risch structure theorem (real and complex versions)."
     "It also provides transformations on elementary functions"
     "which are not considered simplifications."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ElementaryFunctionStructurePackage|
  (progn
    (push '|ElementaryFunctionStructurePackage| *Packages*)
    (make-instance '|ElementaryFunctionStructurePackageType|)))

\end{chunk}

\subsection{ElementaryIntegration}
\index[pkg]{ElementaryIntegration!Domain}
\index[pkg]{Domain!ElementaryIntegration}
\index[pkg]{INTEF}
\begin{chunk}{defclass ElementaryIntegrationType}
(defclass |ElementaryIntegrationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ElementaryIntegration")
   (marker :initform 'package)
   (abbreviation :initform 'INTEF)
   (comment :initform (list
     "This package provides functions for integration, limited integration,"
     "extended integration and the risch differential equation for"
     "elementary functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ElementaryIntegration|
  (progn
    (push '|ElementaryIntegration| *Packages*)
    (make-instance '|ElementaryIntegrationType|)))

\end{chunk}

\subsection{ElementaryRischDE}
\index[pkg]{ElementaryRischDE!Domain}
\index[pkg]{Domain!ElementaryRischDE}
\index[pkg]{RDEEF}
\begin{chunk}{defclass ElementaryRischDEType}
(defclass |ElementaryRischDEType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ElementaryRischDE")
   (marker :initform 'package)
   (abbreviation :initform 'RDEEF)
   (comment :initform (list
     "Risch differential equation, elementary case."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ElementaryRischDE|
  (progn
    (push '|ElementaryRischDE| *Packages*)
    (make-instance '|ElementaryRischDEType|)))

\end{chunk}

\subsection{ElementaryRischDESystem}
\index[pkg]{ElementaryRischDESystem!Domain}
\index[pkg]{Domain!ElementaryRischDESystem}
\index[pkg]{RDEEFS}
\begin{chunk}{defclass ElementaryRischDESystemType}
(defclass |ElementaryRischDESystemType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ElementaryRischDESystem")
   (marker :initform 'package)
   (abbreviation :initform 'RDEEFS)
   (comment :initform (list
     "Risch differential equation, elementary case."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ElementaryRischDESystem|
  (progn
    (push '|ElementaryRischDESystem| *Packages*)
    (make-instance '|ElementaryRischDESystemType|)))

\end{chunk}

\subsection{EllipticFunctionsUnivariateTaylorSeries}
\index[pkg]{EllipticFunctionsUnivariateTaylorSeries!Domain}
\index[pkg]{Domain!EllipticFunctionsUnivariateTaylorSeries}
\index[pkg]{ELFUTS}
\begin{chunk}{defclass EllipticFunctionsUnivariateTaylorSeriesType}
(defclass |EllipticFunctionsUnivariateTaylorSeriesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "EllipticFunctionsUnivariateTaylorSeries")
   (marker :initform 'package)
   (abbreviation :initform 'ELFUTS)
   (comment :initform (list
     "The elliptic functions sn, sc and dn are expanded as Taylor series."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |EllipticFunctionsUnivariateTaylorSeries|
  (progn
    (push '|EllipticFunctionsUnivariateTaylorSeries| *Packages*)
    (make-instance '|EllipticFunctionsUnivariateTaylorSeriesType|)))

\end{chunk}

\subsection{EquationFunctions2}
\index[pkg]{EquationFunctions2!Domain}
\index[pkg]{Domain!EquationFunctions2}
\index[pkg]{EQ2}
\begin{chunk}{defclass EquationFunctions2Type}
(defclass |EquationFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "EquationFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'EQ2)
   (comment :initform (list
     "This package provides operations for mapping the sides of equations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |EquationFunctions2|
  (progn
    (push '|EquationFunctions2| *Packages*)
    (make-instance '|EquationFunctions2Type|)))

\end{chunk}

\subsection{ErrorFunctions}
\index[pkg]{ErrorFunctions!Domain}
\index[pkg]{Domain!ErrorFunctions}
\index[pkg]{ERROR}
\begin{chunk}{defclass ErrorFunctionsType}
(defclass |ErrorFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ErrorFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'ERROR)
   (comment :initform (list
     "ErrorFunctions implements error functions callable from the system"
     "interpreter.  Typically, these functions would be called in user"
     "functions.  The simple forms of the functions take one argument"
     "which is either a string (an error message) or a list of strings"
     "which all together make up a message.  The list can contain"
     "formatting codes (see below).  The more sophisticated versions takes"
     "two arguments where the first argument is the name of the function"
     "from which the error was invoked and the second argument is either a"
     "string or a list of strings, as above.  When you use the one"
     "argument version in an interpreter function, the system will"
     "automatically insert the name of the function as the new first"
     "argument.  Thus in the user interpreter function"
     "     f x == if x < 0 then error 'negative argument' else x"
     "the call to error will actually be of the form"
     "     error('f','negative argument')"
     "because the interpreter will have created a new first argument."
     " "
     "Formatting codes:  error messages may contain the following"
     "formatting codes (they should either start or end a string or"
     "else have blanks around them):"
     "%l      start a new line"
     "%ceon   start centering message lines"
     "%ceoff  stop  centering message lines"
     "%rjon   start displaying lines 'ragged left'"
     "%rjoff  stop  displaying lines 'ragged left'"
     "%i      indent   following lines 3 additional spaces"
     "%u      unindent following lines 3 additional spaces"
     "%xN    insert N blanks (eg, %x10 inserts 10 blanks)"
     " "
     "Examples:"
     "1.error 'Whoops, you made a %l %ceon big %ceoff %l mistake!'"
     "2.error ['Whoops, you made a','%l %ceon ','big',"
     "         '%d %ceoff %l','mistake!']"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ErrorFunctions|
  (progn
    (push '|ErrorFunctions| *Packages*)
    (make-instance '|ErrorFunctionsType|)))

\end{chunk}

\subsection{EuclideanGroebnerBasisPackage}
\index[pkg]{EuclideanGroebnerBasisPackage!Domain}
\index[pkg]{Domain!EuclideanGroebnerBasisPackage}
\index[pkg]{GBEUCLID}
\begin{chunk}{defclass EuclideanGroebnerBasisPackageType}
(defclass |EuclideanGroebnerBasisPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "EuclideanGroebnerBasisPackage")
   (marker :initform 'package)
   (abbreviation :initform 'GBEUCLID)
   (comment :initform (list
     "EuclideanGroebnerBasisPackage computes groebner"
     "bases for polynomial ideals over euclidean domains."
     "The basic computation provides"
     "a distinguished set of generators for these ideals."
     "This basis allows an easy test for membership: the operation"
     "euclideanNormalForm returns zero on ideal members. The string"
     "'info' and 'redcrit' can be given as additional args to provide"
     "incremental information during the computation. If 'info' is given,"
     "a computational summary is given for each s-polynomial. If 'redcrit'"
     "is given, the reduced critical pairs are printed. The term ordering"
     "is determined by the polynomial type used. Suggested types include"
     "DistributedMultivariatePolynomial,"
     "HomogeneousDistributedMultivariatePolynomial,"
     "GeneralDistributedMultivariatePolynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |EuclideanGroebnerBasisPackage|
  (progn
    (push '|EuclideanGroebnerBasisPackage| *Packages*)
    (make-instance '|EuclideanGroebnerBasisPackageType|)))

\end{chunk}

\subsection{EvaluateCycleIndicators}
\index[pkg]{EvaluateCycleIndicators!Domain}
\index[pkg]{Domain!EvaluateCycleIndicators}
\index[pkg]{EVALCYC}
\begin{chunk}{defclass EvaluateCycleIndicatorsType}
(defclass |EvaluateCycleIndicatorsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "EvaluateCycleIndicators")
   (marker :initform 'package)
   (abbreviation :initform 'EVALCYC)
   (comment :initform (list
     "This package is to be used in conjuction with the CycleIndicators package."
     "It provides an evaluation function for SymmetricPolynomials."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |EvaluateCycleIndicators|
  (progn
    (push '|EvaluateCycleIndicators| *Packages*)
    (make-instance '|EvaluateCycleIndicatorsType|)))

\end{chunk}

\subsection{ExpertSystemContinuityPackage}
\index[pkg]{ExpertSystemContinuityPackage!Domain}
\index[pkg]{Domain!ExpertSystemContinuityPackage}
\index[pkg]{ESCONT}
\begin{chunk}{defclass ExpertSystemContinuityPackageType}
(defclass |ExpertSystemContinuityPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ExpertSystemContinuityPackage")
   (marker :initform 'package)
   (abbreviation :initform 'ESCONT)
   (comment :initform (list
     "ExpertSystemContinuityPackage is a package of functions for the use of"
     "domains belonging to the category NumericalIntegration."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExpertSystemContinuityPackage|
  (progn
    (push '|ExpertSystemContinuityPackage| *Packages*)
    (make-instance '|ExpertSystemContinuityPackageType|)))

\end{chunk}

\subsection{ExpertSystemContinuityPackage1}
\index[pkg]{ExpertSystemContinuityPackage1!Domain}
\index[pkg]{Domain!ExpertSystemContinuityPackage1}
\index[pkg]{ESCONT1}
\begin{chunk}{defclass ExpertSystemContinuityPackage1Type}
(defclass |ExpertSystemContinuityPackage1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ExpertSystemContinuityPackage1")
   (marker :initform 'package)
   (abbreviation :initform 'ESCONT1)
   (comment :initform (list
     "ExpertSystemContinuityPackage1 exports a function to check range inclusion"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExpertSystemContinuityPackage1|
  (progn
    (push '|ExpertSystemContinuityPackage1| *Packages*)
    (make-instance '|ExpertSystemContinuityPackage1Type|)))

\end{chunk}

\subsection{ExpertSystemToolsPackage}
\index[pkg]{ExpertSystemToolsPackage!Domain}
\index[pkg]{Domain!ExpertSystemToolsPackage}
\index[pkg]{ESTOOLS}
\begin{chunk}{defclass ExpertSystemToolsPackageType}
(defclass |ExpertSystemToolsPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ExpertSystemToolsPackage")
   (marker :initform 'package)
   (abbreviation :initform 'ESTOOLS)
   (comment :initform (list
     "ExpertSystemToolsPackage contains some useful functions for use"
     "by the computational agents of numerical solvers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExpertSystemToolsPackage|
  (progn
    (push '|ExpertSystemToolsPackage| *Packages*)
    (make-instance '|ExpertSystemToolsPackageType|)))

\end{chunk}

\subsection{ExpertSystemToolsPackage1}
\index[pkg]{ExpertSystemToolsPackage1!Domain}
\index[pkg]{Domain!ExpertSystemToolsPackage1}
\index[pkg]{ESTOOLS1}
\begin{chunk}{defclass ExpertSystemToolsPackage1Type}
(defclass |ExpertSystemToolsPackage1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ExpertSystemToolsPackage1")
   (marker :initform 'package)
   (abbreviation :initform 'ESTOOLS1)
   (comment :initform (list
     "ExpertSystemToolsPackage1 contains some useful functions for use"
     "by the computational agents of Ordinary Differential Equation solvers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExpertSystemToolsPackage1|
  (progn
    (push '|ExpertSystemToolsPackage1| *Packages*)
    (make-instance '|ExpertSystemToolsPackage1Type|)))

\end{chunk}

\subsection{ExpertSystemToolsPackage2}
\index[pkg]{ExpertSystemToolsPackage2!Domain}
\index[pkg]{Domain!ExpertSystemToolsPackage2}
\index[pkg]{ESTOOLS2}
\begin{chunk}{defclass ExpertSystemToolsPackage2Type}
(defclass |ExpertSystemToolsPackage2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ExpertSystemToolsPackage2")
   (marker :initform 'package)
   (abbreviation :initform 'ESTOOLS2)
   (comment :initform (list
     "ExpertSystemToolsPackage2 contains some useful functions for use"
     "by the computational agents of Ordinary Differential Equation solvers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExpertSystemToolsPackage2|
  (progn
    (push '|ExpertSystemToolsPackage2| *Packages*)
    (make-instance '|ExpertSystemToolsPackage2Type|)))

\end{chunk}

\subsection{ExpressionFunctions2}
\index[pkg]{ExpressionFunctions2!Domain}
\index[pkg]{Domain!ExpressionFunctions2}
\index[pkg]{EXPR2}
\begin{chunk}{defclass ExpressionFunctions2Type}
(defclass |ExpressionFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ExpressionFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'EXPR2)
   (comment :initform (list
     "Lifting of maps to Expressions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExpressionFunctions2|
  (progn
    (push '|ExpressionFunctions2| *Packages*)
    (make-instance '|ExpressionFunctions2Type|)))

\end{chunk}

\subsection{ExpressionSolve}
\index[pkg]{ExpressionSolve!Domain}
\index[pkg]{Domain!ExpressionSolve}
\index[pkg]{EXPRSOL}
\begin{chunk}{defclass ExpressionSolveType}
(defclass |ExpressionSolveType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ExpressionSolve")
   (marker :initform 'package)
   (abbreviation :initform 'EXPRSOL)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExpressionSolve|
  (progn
    (push '|ExpressionSolve| *Packages*)
    (make-instance '|ExpressionSolveType|)))

\end{chunk}

\subsection{ExpressionSpaceFunctions1}
\index[pkg]{ExpressionSpaceFunctions1!Domain}
\index[pkg]{Domain!ExpressionSpaceFunctions1}
\index[pkg]{ES1}
\begin{chunk}{defclass ExpressionSpaceFunctions1Type}
(defclass |ExpressionSpaceFunctions1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ExpressionSpaceFunctions1")
   (marker :initform 'package)
   (abbreviation :initform 'ES1)
   (comment :initform (list
     "This package allows a map from any expression space into any object"
     "to be lifted to a kernel over the expression set, using a given"
     "property of the operator of the kernel."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExpressionSpaceFunctions1|
  (progn
    (push '|ExpressionSpaceFunctions1| *Packages*)
    (make-instance '|ExpressionSpaceFunctions1Type|)))

\end{chunk}

\subsection{ExpressionSpaceFunctions2}
\index[pkg]{ExpressionSpaceFunctions2!Domain}
\index[pkg]{Domain!ExpressionSpaceFunctions2}
\index[pkg]{ES2}
\begin{chunk}{defclass ExpressionSpaceFunctions2Type}
(defclass |ExpressionSpaceFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ExpressionSpaceFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'ES2)
   (comment :initform (list
     "This package allows a mapping E -> F to be lifted to a kernel over E"
     "This lifting can fail if the operator of the kernel cannot be applied"
     "in F; Do not use this package with E = F, since this may"
     "drop some properties of the operators."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExpressionSpaceFunctions2|
  (progn
    (push '|ExpressionSpaceFunctions2| *Packages*)
    (make-instance '|ExpressionSpaceFunctions2Type|)))

\end{chunk}

\subsection{ExpressionSpaceODESolver}
\index[pkg]{ExpressionSpaceODESolver!Domain}
\index[pkg]{Domain!ExpressionSpaceODESolver}
\index[pkg]{EXPRODE}
\begin{chunk}{defclass ExpressionSpaceODESolverType}
(defclass |ExpressionSpaceODESolverType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ExpressionSpaceODESolver")
   (marker :initform 'package)
   (abbreviation :initform 'EXPRODE)
   (comment :initform (list
     "Taylor series solutions of explicit ODE's"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExpressionSpaceODESolver|
  (progn
    (push '|ExpressionSpaceODESolver| *Packages*)
    (make-instance '|ExpressionSpaceODESolverType|)))

\end{chunk}

\subsection{ExpressionToOpenMath}
\index[pkg]{ExpressionToOpenMath!Domain}
\index[pkg]{Domain!ExpressionToOpenMath}
\index[pkg]{OMEXPR}
\begin{chunk}{defclass ExpressionToOpenMathType}
(defclass |ExpressionToOpenMathType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ExpressionToOpenMath")
   (marker :initform 'package)
   (abbreviation :initform 'OMEXPR)
   (comment :initform (list
     "ExpressionToOpenMath provides support for"
     "converting objects of type Expression into OpenMath."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExpressionToOpenMath|
  (progn
    (push '|ExpressionToOpenMath| *Packages*)
    (make-instance '|ExpressionToOpenMathType|)))

\end{chunk}

\subsection{ExpressionToUnivariatePowerSeries}
\index[pkg]{ExpressionToUnivariatePowerSeries!Domain}
\index[pkg]{Domain!ExpressionToUnivariatePowerSeries}
\index[pkg]{EXPR2UPS}
\begin{chunk}{defclass ExpressionToUnivariatePowerSeriesType}
(defclass |ExpressionToUnivariatePowerSeriesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ExpressionToUnivariatePowerSeries")
   (marker :initform 'package)
   (abbreviation :initform 'EXPR2UPS)
   (comment :initform (list
     "This package provides functions to convert functional expressions"
     "to power series."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExpressionToUnivariatePowerSeries|
  (progn
    (push '|ExpressionToUnivariatePowerSeries| *Packages*)
    (make-instance '|ExpressionToUnivariatePowerSeriesType|)))

\end{chunk}

\subsection{ExpressionTubePlot}
\index[pkg]{ExpressionTubePlot!Domain}
\index[pkg]{Domain!ExpressionTubePlot}
\index[pkg]{EXPRTUBE}
\begin{chunk}{defclass ExpressionTubePlotType}
(defclass |ExpressionTubePlotType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ExpressionTubePlot")
   (marker :initform 'package)
   (abbreviation :initform 'EXPRTUBE)
   (comment :initform (list
     "Package for constructing tubes around 3-dimensional parametric curves."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExpressionTubePlot|
  (progn
    (push '|ExpressionTubePlot| *Packages*)
    (make-instance '|ExpressionTubePlotType|)))

\end{chunk}

\subsection{Export3D}
\index[pkg]{Export3D!Domain}
\index[pkg]{Domain!Export3D}
\index[pkg]{EXP3D}
\begin{chunk}{defclass Export3DType}
(defclass |Export3DType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "Export3D")
   (marker :initform 'package)
   (abbreviation :initform 'EXP3D)
   (comment :initform (list
     "This package provides support for exporting SubSpace and"
     "ThreeSpace structures to files."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Export3D|
  (progn
    (push '|Export3D| *Packages*)
    (make-instance '|Export3DType|)))

\end{chunk}

\subsection{e04AgentsPackage}
\index[pkg]{e04AgentsPackage!Domain}
\index[pkg]{Domain!e04AgentsPackage}
\index[pkg]{E04AGNT}
\begin{chunk}{defclass e04AgentsPackageType}
(defclass |e04AgentsPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "e04AgentsPackage")
   (marker :initform 'package)
   (abbreviation :initform 'E04AGNT)
   (comment :initform (list
     "e04AgentsPackage is a package of numerical agents to be used"
     "to investigate attributes of an input function so as to decide the"
     "measure of an appropriate numerical optimization routine."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |e04AgentsPackage|
  (progn
    (push '|e04AgentsPackage| *Packages*)
    (make-instance '|e04AgentsPackageType|)))

\end{chunk}

\section{F}

\subsection{FactoredFunctions}
\index[pkg]{FactoredFunctions!Domain}
\index[pkg]{Domain!FactoredFunctions}
\index[pkg]{FACTFUNC}
\begin{chunk}{defclass FactoredFunctionsType}
(defclass |FactoredFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FactoredFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'FACTFUNC)
   (comment :initform (list
     "Computes various functions on factored arguments."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FactoredFunctions|
  (progn
    (push '|FactoredFunctions| *Packages*)
    (make-instance '|FactoredFunctionsType|)))

\end{chunk}

\subsection{FactoredFunctions2}
\index[pkg]{FactoredFunctions2!Domain}
\index[pkg]{Domain!FactoredFunctions2}
\index[pkg]{FR2}
\begin{chunk}{defclass FactoredFunctions2Type}
(defclass |FactoredFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FactoredFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'FR2)
   (comment :initform (list
     "FactoredFunctions2 contains functions that involve"
     "factored objects whose underlying domains may not be the same."
     "For example, map might be used to coerce an object of"
     "type Factored(Integer) to Factored(Complex(Integer))."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FactoredFunctions2|
  (progn
    (push '|FactoredFunctions2| *Packages*)
    (make-instance '|FactoredFunctions2Type|)))

\end{chunk}

\subsection{FactoredFunctionUtilities}
\index[pkg]{FactoredFunctionUtilities!Domain}
\index[pkg]{Domain!FactoredFunctionUtilities}
\index[pkg]{FRUTIL}
\begin{chunk}{defclass FactoredFunctionUtilitiesType}
(defclass |FactoredFunctionUtilitiesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FactoredFunctionUtilities")
   (marker :initform 'package)
   (abbreviation :initform 'FRUTIL)
   (comment :initform (list
     "FactoredFunctionUtilities implements some utility"
     "functions for manipulating factored objects."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FactoredFunctionUtilities|
  (progn
    (push '|FactoredFunctionUtilities| *Packages*)
    (make-instance '|FactoredFunctionUtilitiesType|)))

\end{chunk}

\subsection{FactoringUtilities}
\index[pkg]{FactoringUtilities!Domain}
\index[pkg]{Domain!FactoringUtilities}
\index[pkg]{FACUTIL}
\begin{chunk}{defclass FactoringUtilitiesType}
(defclass |FactoringUtilitiesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FactoringUtilities")
   (marker :initform 'package)
   (abbreviation :initform 'FACUTIL)
   (comment :initform (list
     "This package provides utilities used by the factorizers"
     "which operate on polynomials represented as univariate polynomials"
     "with multivariate coefficients."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FactoringUtilities|
  (progn
    (push '|FactoringUtilities| *Packages*)
    (make-instance '|FactoringUtilitiesType|)))

\end{chunk}

\subsection{FactorisationOverPseudoAlgebraicClosureOfAlgExtOfRationalNumber}
\index[pkg]{FactorisationOverPseudoAlgebraicClosureOfAlgExtOfRationalNumber!Domain}
\index[pkg]{Domain!FactorisationOverPseudoAlgebraicClosureOfAlgExtOfRationalNumber}
\index[pkg]{FACTEXT}
\begin{chunk}{defclass FactorisationOverPseudoAlgebraicClosureOfAlgExtOfRationalNumberType}
(defclass |FactorisationOverPseudoAlgebraicClosureOfAlgExtOfRationalNumberType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FactorisationOverPseudoAlgebraicClosureOfAlgExtOfRationalNumber")
   (marker :initform 'package)
   (abbreviation :initform 'FACTEXT)
   (comment :initform (list
     "Part of the Package for Algebraic Function Fields in one variable PAFF"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FactorisationOverPseudoAlgebraicClosureOfAlgExtOfRationalNumber|
  (progn
    (push '|FactorisationOverPseudoAlgebraicClosureOfAlgExtOfRationalNumber| *Packages*)
    (make-instance '|FactorisationOverPseudoAlgebraicClosureOfAlgExtOfRationalNumberType|)))

\end{chunk}

\subsection{FactorisationOverPseudoAlgebraicClosureOfRationalNumber}
\index[pkg]{FactorisationOverPseudoAlgebraicClosureOfRationalNumber!Domain}
\index[pkg]{Domain!FactorisationOverPseudoAlgebraicClosureOfRationalNumber}
\index[pkg]{FACTRN}
\begin{chunk}{defclass FactorisationOverPseudoAlgebraicClosureOfRationalNumberType}
(defclass |FactorisationOverPseudoAlgebraicClosureOfRationalNumberType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FactorisationOverPseudoAlgebraicClosureOfRationalNumber")
   (marker :initform 'package)
   (abbreviation :initform 'FACTRN)
   (comment :initform (list
     "Part of the Package for Algebraic Function Fields in one variable PAFF"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FactorisationOverPseudoAlgebraicClosureOfRationalNumber|
  (progn
    (push '|FactorisationOverPseudoAlgebraicClosureOfRationalNumber| *Packages*)
    (make-instance '|FactorisationOverPseudoAlgebraicClosureOfRationalNumberType|)))

\end{chunk}

\subsection{FGLMIfCanPackage}
\index[pkg]{FGLMIfCanPackage!Domain}
\index[pkg]{Domain!FGLMIfCanPackage}
\index[pkg]{FGLMICPK}
\begin{chunk}{defclass FGLMIfCanPackageType}
(defclass |FGLMIfCanPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FGLMIfCanPackage")
   (marker :initform 'package)
   (abbreviation :initform 'FGLMICPK)
   (comment :initform (list
     "This is just an interface between several packages and domains."
     "The goal is to compute lexicographical Groebner bases"
     "of sets of polynomial with type Polynomial R"
     "by the FGLM algorithm if this is possible"
     "(if the input system generates a zero-dimensional ideal)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FGLMIfCanPackage|
  (progn
    (push '|FGLMIfCanPackage| *Packages*)
    (make-instance '|FGLMIfCanPackageType|)))

\end{chunk}

\subsection{FindOrderFinite}
\index[pkg]{FindOrderFinite!Domain}
\index[pkg]{Domain!FindOrderFinite}
\index[pkg]{FORDER}
\begin{chunk}{defclass FindOrderFiniteType}
(defclass |FindOrderFiniteType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FindOrderFinite")
   (marker :initform 'package)
   (abbreviation :initform 'FORDER)
   (comment :initform (list
     "Finds the order of a divisor over a finite field"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FindOrderFinite|
  (progn
    (push '|FindOrderFinite| *Packages*)
    (make-instance '|FindOrderFiniteType|)))

\end{chunk}

\subsection{FiniteAbelianMonoidRingFunctions2}
\index[pkg]{FiniteAbelianMonoidRingFunctions2!Domain}
\index[pkg]{Domain!FiniteAbelianMonoidRingFunctions2}
\index[pkg]{FAMR2}
\begin{chunk}{defclass FiniteAbelianMonoidRingFunctions2Type}
(defclass |FiniteAbelianMonoidRingFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FiniteAbelianMonoidRingFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'FAMR2)
   (comment :initform (list
     "This package provides a mapping function for FiniteAbelianMonoidRing"
     "The packages defined in this file provide fast fraction free rational"
     "interpolation algorithms. (see FAMR2, FFFG, FFFGF, NEWTON)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteAbelianMonoidRingFunctions2|
  (progn
    (push '|FiniteAbelianMonoidRingFunctions2| *Packages*)
    (make-instance '|FiniteAbelianMonoidRingFunctions2Type|)))

\end{chunk}

\subsection{FiniteDivisorFunctions2}
\index[pkg]{FiniteDivisorFunctions2!Domain}
\index[pkg]{Domain!FiniteDivisorFunctions2}
\index[pkg]{FDIV2}
\begin{chunk}{defclass FiniteDivisorFunctions2Type}
(defclass |FiniteDivisorFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FiniteDivisorFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'FDIV2)
   (comment :initform (list
     "Lift a map to finite divisors."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteDivisorFunctions2|
  (progn
    (push '|FiniteDivisorFunctions2| *Packages*)
    (make-instance '|FiniteDivisorFunctions2Type|)))

\end{chunk}

\subsection{FiniteFieldFactorization}
\index[pkg]{FiniteFieldFactorization!Domain}
\index[pkg]{Domain!FiniteFieldFactorization}
\index[pkg]{FFFACTOR}
\begin{chunk}{defclass FiniteFieldFactorizationType}
(defclass |FiniteFieldFactorizationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FiniteFieldFactorization")
   (marker :initform 'package)
   (abbreviation :initform 'FFFACTOR)
   (comment :initform (list
     "Part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldFactorization|
  (progn
    (push '|FiniteFieldFactorization| *Packages*)
    (make-instance '|FiniteFieldFactorizationType|)))

\end{chunk}

\subsection{FiniteFieldFactorizationWithSizeParseBySideEffect}
\index[pkg]{FiniteFieldFactorizationWithSizeParseBySideEffect!Domain}
\index[pkg]{Domain!FiniteFieldFactorizationWithSizeParseBySideEffect}
\index[pkg]{FFFACTSE}
\begin{chunk}{defclass FiniteFieldFactorizationWithSizeParseBySideEffectType}
(defclass |FiniteFieldFactorizationWithSizeParseBySideEffectType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FiniteFieldFactorizationWithSizeParseBySideEffect")
   (marker :initform 'package)
   (abbreviation :initform 'FFFACTSE)
   (comment :initform (list
     "Part of the package for Algebraic Function Fields in one variable (PAFF)"
     "It has been modified (very slitely) so that each time the 'factor'"
     "function is used, the variable related to the size of the field"
     "over which the polynomial is factorized is reset. This is done in"
     "order to be used with a 'dynamic extension field' which size is not"
     "fixed but set before calling the 'factor' function and which is"
     "parse by side effect to this package via the function 'size'. See"
     "the local function initialize' of this package."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldFactorizationWithSizeParseBySideEffect|
  (progn
    (push '|FiniteFieldFactorizationWithSizeParseBySideEffect| *Packages*)
    (make-instance '|FiniteFieldFactorizationWithSizeParseBySideEffectType|)))

\end{chunk}

\subsection{FiniteFieldFunctions}
\index[pkg]{FiniteFieldFunctions!Domain}
\index[pkg]{Domain!FiniteFieldFunctions}
\index[pkg]{FFF}
\begin{chunk}{defclass FiniteFieldFunctionsType}
(defclass |FiniteFieldFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FiniteFieldFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'FFF)
   (comment :initform (list
     "FiniteFieldFunctions(GF) is a package with functions"
     "concerning finite extension fields of the finite ground field GF,"
     "for example, Zech logarithms."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldFunctions|
  (progn
    (push '|FiniteFieldFunctions| *Packages*)
    (make-instance '|FiniteFieldFunctionsType|)))

\end{chunk}

\subsection{FiniteFieldHomomorphisms}
\index[pkg]{FiniteFieldHomomorphisms!Domain}
\index[pkg]{Domain!FiniteFieldHomomorphisms}
\index[pkg]{FFHOM}
\begin{chunk}{defclass FiniteFieldHomomorphismsType}
(defclass |FiniteFieldHomomorphismsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FiniteFieldHomomorphisms")
   (marker :initform 'package)
   (abbreviation :initform 'FFHOM)
   (comment :initform (list
     "FiniteFieldHomomorphisms(F1,GF,F2) exports coercion functions of"
     "elements between the fields F1 and F2, which both must be"
     "finite simple algebraic extensions of the finite ground field GF."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldHomomorphisms|
  (progn
    (push '|FiniteFieldHomomorphisms| *Packages*)
    (make-instance '|FiniteFieldHomomorphismsType|)))

\end{chunk}

\subsection{FiniteFieldPolynomialPackage}
\index[pkg]{FiniteFieldPolynomialPackage!Domain}
\index[pkg]{Domain!FiniteFieldPolynomialPackage}
\index[pkg]{FFPOLY}
\begin{chunk}{defclass FiniteFieldPolynomialPackageType}
(defclass |FiniteFieldPolynomialPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FiniteFieldPolynomialPackage")
   (marker :initform 'package)
   (abbreviation :initform 'FFPOLY)
   (comment :initform (list
     "This package provides a number of functions for generating, counting"
     "and testing irreducible, normal, primitive, random polynomials"
     "over finite fields."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldPolynomialPackage|
  (progn
    (push '|FiniteFieldPolynomialPackage| *Packages*)
    (make-instance '|FiniteFieldPolynomialPackageType|)))

\end{chunk}

\subsection{FiniteFieldPolynomialPackage2}
\index[pkg]{FiniteFieldPolynomialPackage2!Domain}
\index[pkg]{Domain!FiniteFieldPolynomialPackage2}
\index[pkg]{FFPOLY2}
\begin{chunk}{defclass FiniteFieldPolynomialPackage2Type}
(defclass |FiniteFieldPolynomialPackage2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FiniteFieldPolynomialPackage2")
   (marker :initform 'package)
   (abbreviation :initform 'FFPOLY2)
   (comment :initform (list
     "FiniteFieldPolynomialPackage2(F,GF) exports some functions concerning"
     "finite fields, which depend on a finite field GF and an"
     "algebraic extension F of GF, for example, a zero of a polynomial"
     "over GF in F."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldPolynomialPackage2|
  (progn
    (push '|FiniteFieldPolynomialPackage2| *Packages*)
    (make-instance '|FiniteFieldPolynomialPackage2Type|)))

\end{chunk}

\subsection{FiniteFieldSolveLinearPolynomialEquation}
\index[pkg]{FiniteFieldSolveLinearPolynomialEquation!Domain}
\index[pkg]{Domain!FiniteFieldSolveLinearPolynomialEquation}
\index[pkg]{FFSLPE}
\begin{chunk}{defclass FiniteFieldSolveLinearPolynomialEquationType}
(defclass |FiniteFieldSolveLinearPolynomialEquationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FiniteFieldSolveLinearPolynomialEquation")
   (marker :initform 'package)
   (abbreviation :initform 'FFSLPE)
   (comment :initform (list
     "This package solves linear diophantine equations for Bivariate polynomials"
     "over finite fields"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldSolveLinearPolynomialEquation|
  (progn
    (push '|FiniteFieldSolveLinearPolynomialEquation| *Packages*)
    (make-instance '|FiniteFieldSolveLinearPolynomialEquationType|)))

\end{chunk}

\subsection{FiniteFieldSquareFreeDecomposition}
\index[pkg]{FiniteFieldSquareFreeDecomposition!Domain}
\index[pkg]{Domain!FiniteFieldSquareFreeDecomposition}
\index[pkg]{FFSQFR}
\begin{chunk}{defclass FiniteFieldSquareFreeDecompositionType}
(defclass |FiniteFieldSquareFreeDecompositionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FiniteFieldSquareFreeDecomposition")
   (marker :initform 'package)
   (abbreviation :initform 'FFSQFR)
   (comment :initform (list
     "Part of the package for Algebraic Function Fields in one variable (PAFF)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldSquareFreeDecomposition|
  (progn
    (push '|FiniteFieldSquareFreeDecomposition| *Packages*)
    (make-instance '|FiniteFieldSquareFreeDecompositionType|)))

\end{chunk}

\subsection{FiniteLinearAggregateFunctions2}
\index[pkg]{FiniteLinearAggregateFunctions2!Domain}
\index[pkg]{Domain!FiniteLinearAggregateFunctions2}
\index[pkg]{FLAGG2}
\begin{chunk}{defclass FiniteLinearAggregateFunctions2Type}
(defclass |FiniteLinearAggregateFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FiniteLinearAggregateFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'FLAGG2)
   (comment :initform (list
     "FiniteLinearAggregateFunctions2 provides functions involving two"
     "FiniteLinearAggregates where the underlying domains might be"
     "different. An example of this might be creating a list of rational"
     "numbers by mapping a function across a list of integers where the"
     "function divides each integer by 1000."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteLinearAggregateFunctions2|
  (progn
    (push '|FiniteLinearAggregateFunctions2| *Packages*)
    (make-instance '|FiniteLinearAggregateFunctions2Type|)))

\end{chunk}

\subsection{FiniteLinearAggregateSort}
\index[pkg]{FiniteLinearAggregateSort!Domain}
\index[pkg]{Domain!FiniteLinearAggregateSort}
\index[pkg]{FLASORT}
\begin{chunk}{defclass FiniteLinearAggregateSortType}
(defclass |FiniteLinearAggregateSortType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FiniteLinearAggregateSort")
   (marker :initform 'package)
   (abbreviation :initform 'FLASORT)
   (comment :initform (list
     "This package exports 3 sorting algorithms which work over"
     "FiniteLinearAggregates."
     "Sort package (in-place) for shallowlyMutable Finite Linear Aggregates"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteLinearAggregateSort|
  (progn
    (push '|FiniteLinearAggregateSort| *Packages*)
    (make-instance '|FiniteLinearAggregateSortType|)))

\end{chunk}

\subsection{FiniteSetAggregateFunctions2}
\index[pkg]{FiniteSetAggregateFunctions2!Domain}
\index[pkg]{Domain!FiniteSetAggregateFunctions2}
\index[pkg]{FSAGG2}
\begin{chunk}{defclass FiniteSetAggregateFunctions2Type}
(defclass |FiniteSetAggregateFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FiniteSetAggregateFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'FSAGG2)
   (comment :initform (list
     "FiniteSetAggregateFunctions2 provides functions involving two"
     "finite set aggregates where the underlying domains might be"
     "different. An example of this is to create a set of rational"
     "numbers by mapping a function across a set of integers, where the"
     "function divides each integer by 1000."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteSetAggregateFunctions2|
  (progn
    (push '|FiniteSetAggregateFunctions2| *Packages*)
    (make-instance '|FiniteSetAggregateFunctions2Type|)))

\end{chunk}

\subsection{FloatingComplexPackage}
\index[pkg]{FloatingComplexPackage!Domain}
\index[pkg]{Domain!FloatingComplexPackage}
\index[pkg]{FLOATCP}
\begin{chunk}{defclass FloatingComplexPackageType}
(defclass |FloatingComplexPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FloatingComplexPackage")
   (marker :initform 'package)
   (abbreviation :initform 'FLOATCP)
   (comment :initform (list
     "This is a package for the approximation of complex solutions for"
     "systems of equations of rational functions with complex rational"
     "coefficients. The results are expressed as either complex rational"
     "numbers or complex floats depending on the type of the precision"
     "parameter which can be either a rational number or a floating point number."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FloatingComplexPackage|
  (progn
    (push '|FloatingComplexPackage| *Packages*)
    (make-instance '|FloatingComplexPackageType|)))

\end{chunk}

\subsection{FloatingRealPackage}
\index[pkg]{FloatingRealPackage!Domain}
\index[pkg]{Domain!FloatingRealPackage}
\index[pkg]{FLOATRP}
\begin{chunk}{defclass FloatingRealPackageType}
(defclass |FloatingRealPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FloatingRealPackage")
   (marker :initform 'package)
   (abbreviation :initform 'FLOATRP)
   (comment :initform (list
     "This is a package for the approximation of real solutions for"
     "systems of polynomial equations over the rational numbers."
     "The results are expressed as either rational numbers or floats"
     "depending on the type of the precision parameter which can be"
     "either a rational number or a floating point number."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FloatingRealPackage|
  (progn
    (push '|FloatingRealPackage| *Packages*)
    (make-instance '|FloatingRealPackageType|)))

\end{chunk}

\subsection{FloatSpecialFunctions}
\index[pkg]{FloatSpecialFunctions!Domain}
\index[pkg]{Domain!FloatSpecialFunctions}
\index[pkg]{FSFUN}
\begin{chunk}{defclass FloatSpecialFunctionsType}
(defclass |FloatSpecialFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FloatSpecialFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'FSFUN)
   (comment :initform nil)
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FloatSpecialFunctions|
  (progn
    (push '|FloatSpecialFunctions| *Packages*)
    (make-instance '|FloatSpecialFunctionsType|)))

\end{chunk}

\subsection{FortranCodePackage1}
\index[pkg]{FortranCodePackage1!Domain}
\index[pkg]{Domain!FortranCodePackage1}
\index[pkg]{FCPAK1}
\begin{chunk}{defclass FortranCodePackage1Type}
(defclass |FortranCodePackage1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FortranCodePackage1")
   (marker :initform 'package)
   (abbreviation :initform 'FCPAK1)
   (comment :initform (list
     "FortranCodePackage1 provides some utilities for"
     "producing useful objects in FortranCode domain."
     "The Package may be used with the FortranCode domain and its"
     "printCode or possibly via an outputAsFortran."
     "(The package provides items of use in connection with ASPs"
     "in the AXIOM-NAG link and, where appropriate, naming accords"
     "with that in IRENA.)"
     "The easy-to-use functions use Fortran loop variables I1, I2,"
     "and it is users' responsibility to check that this is sensible."
     "The advanced functions use SegmentBinding to allow users control"
     "over Fortran loop variable names."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FortranCodePackage1|
  (progn
    (push '|FortranCodePackage1| *Packages*)
    (make-instance '|FortranCodePackage1Type|)))

\end{chunk}

\subsection{FortranOutputStackPackage}
\index[pkg]{FortranOutputStackPackage!Domain}
\index[pkg]{Domain!FortranOutputStackPackage}
\index[pkg]{FOP}
\begin{chunk}{defclass FortranOutputStackPackageType}
(defclass |FortranOutputStackPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FortranOutputStackPackage")
   (marker :initform 'package)
   (abbreviation :initform 'FOP)
   (comment :initform (list
     "Code to manipulate Fortran Output Stack"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FortranOutputStackPackage|
  (progn
    (push '|FortranOutputStackPackage| *Packages*)
    (make-instance '|FortranOutputStackPackageType|)))

\end{chunk}

\subsection{FortranPackage}
\index[pkg]{FortranPackage!Domain}
\index[pkg]{Domain!FortranPackage}
\index[pkg]{FORT}
\begin{chunk}{defclass FortranPackageType}
(defclass |FortranPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FortranPackage")
   (marker :initform 'package)
   (abbreviation :initform 'FORT)
   (comment :initform (list
     "Provides an interface to the boot code for calling Fortran"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FortranPackage|
  (progn
    (push '|FortranPackage| *Packages*)
    (make-instance '|FortranPackageType|)))

\end{chunk}

\subsection{FractionalIdealFunctions2}
\index[pkg]{FractionalIdealFunctions2!Domain}
\index[pkg]{Domain!FractionalIdealFunctions2}
\index[pkg]{FRIDEAL2}
\begin{chunk}{defclass FractionalIdealFunctions2Type}
(defclass |FractionalIdealFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FractionalIdealFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'FRIDEAL2)
   (comment :initform (list
     "Lifting of morphisms to fractional ideals."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FractionalIdealFunctions2|
  (progn
    (push '|FractionalIdealFunctions2| *Packages*)
    (make-instance '|FractionalIdealFunctions2Type|)))

\end{chunk}

\subsection{FractionFreeFastGaussian}
\index[pkg]{FractionFreeFastGaussian!Domain}
\index[pkg]{Domain!FractionFreeFastGaussian}
\index[pkg]{FFFG}
\begin{chunk}{defclass FractionFreeFastGaussianType}
(defclass |FractionFreeFastGaussianType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FractionFreeFastGaussian")
   (marker :initform 'package)
   (abbreviation :initform 'FFFG)
   (comment :initform (list
     "This package implements the interpolation algorithm proposed in Beckermann,"
     "Bernhard and Labahn, George, Fraction-free computation of matrix rational"
     "interpolants and matrix GCDs, SIAM Journal on Matrix Analysis and"
     "Applications 22."
     "The packages defined in this file provide fast fraction free rational"
     "interpolation algorithms. (see FAMR2, FFFG, FFFGF, NEWTON)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FractionFreeFastGaussian|
  (progn
    (push '|FractionFreeFastGaussian| *Packages*)
    (make-instance '|FractionFreeFastGaussianType|)))

\end{chunk}

\subsection{FractionFreeFastGaussianFractions}
\index[pkg]{FractionFreeFastGaussianFractions!Domain}
\index[pkg]{Domain!FractionFreeFastGaussianFractions}
\index[pkg]{FFFGF}
\begin{chunk}{defclass FractionFreeFastGaussianFractionsType}
(defclass |FractionFreeFastGaussianFractionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FractionFreeFastGaussianFractions")
   (marker :initform 'package)
   (abbreviation :initform 'FFFGF)
   (comment :initform (list
     "This package lifts the interpolation functions from"
     "FractionFreeFastGaussian to fractions."
     "The packages defined in this file provide fast fraction free rational"
     "interpolation algorithms. (see FAMR2, FFFG, FFFGF, NEWTON)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FractionFreeFastGaussianFractions|
  (progn
    (push '|FractionFreeFastGaussianFractions| *Packages*)
    (make-instance '|FractionFreeFastGaussianFractionsType|)))

\end{chunk}

\subsection{FractionFunctions2}
\index[pkg]{FractionFunctions2!Domain}
\index[pkg]{Domain!FractionFunctions2}
\index[pkg]{FRAC2}
\begin{chunk}{defclass FractionFunctions2Type}
(defclass |FractionFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FractionFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'FRAC2)
   (comment :initform (list
     "This package extends a map between integral domains to"
     "a map between Fractions over those domains by applying the map to the"
     "numerators and denominators."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FractionFunctions2|
  (progn
    (push '|FractionFunctions2| *Packages*)
    (make-instance '|FractionFunctions2Type|)))

\end{chunk}

\subsection{FramedNonAssociativeAlgebraFunctions2}
\index[pkg]{FramedNonAssociativeAlgebraFunctions2!Domain}
\index[pkg]{Domain!FramedNonAssociativeAlgebraFunctions2}
\index[pkg]{FRNAAF2}
\begin{chunk}{defclass FramedNonAssociativeAlgebraFunctions2Type}
(defclass |FramedNonAssociativeAlgebraFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FramedNonAssociativeAlgebraFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'FRNAAF2)
   (comment :initform (list
     "FramedNonAssociativeAlgebraFunctions2 implements functions between"
     "two framed non associative algebra domains defined over different rings."
     "The function map is used to coerce between algebras over different"
     "domains having the same structural constants."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FramedNonAssociativeAlgebraFunctions2|
  (progn
    (push '|FramedNonAssociativeAlgebraFunctions2| *Packages*)
    (make-instance '|FramedNonAssociativeAlgebraFunctions2Type|)))

\end{chunk}

\subsection{FunctionalSpecialFunction}
\index[pkg]{FunctionalSpecialFunction!Domain}
\index[pkg]{Domain!FunctionalSpecialFunction}
\index[pkg]{FSPECF}
\begin{chunk}{defclass FunctionalSpecialFunctionType}
(defclass |FunctionalSpecialFunctionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FunctionalSpecialFunction")
   (marker :initform 'package)
   (abbreviation :initform 'FSPECF)
   (comment :initform (list
     "Provides some special functions over an integral domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionalSpecialFunction|
  (progn
    (push '|FunctionalSpecialFunction| *Packages*)
    (make-instance '|FunctionalSpecialFunctionType|)))

\end{chunk}

\subsection{FunctionFieldCategoryFunctions2}
\index[pkg]{FunctionFieldCategoryFunctions2!Domain}
\index[pkg]{Domain!FunctionFieldCategoryFunctions2}
\index[pkg]{FFCAT2}
\begin{chunk}{defclass FunctionFieldCategoryFunctions2Type}
(defclass |FunctionFieldCategoryFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FunctionFieldCategoryFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'FFCAT2)
   (comment :initform (list
     "Lifts a map from rings to function fields over them."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionFieldCategoryFunctions2|
  (progn
    (push '|FunctionFieldCategoryFunctions2| *Packages*)
    (make-instance '|FunctionFieldCategoryFunctions2Type|)))

\end{chunk}

\subsection{FunctionFieldIntegralBasis}
\index[pkg]{FunctionFieldIntegralBasis!Domain}
\index[pkg]{Domain!FunctionFieldIntegralBasis}
\index[pkg]{FFINTBAS}
\begin{chunk}{defclass FunctionFieldIntegralBasisType}
(defclass |FunctionFieldIntegralBasisType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FunctionFieldIntegralBasis")
   (marker :initform 'package)
   (abbreviation :initform 'FFINTBAS)
   (comment :initform (list
     "Integral bases for function fields of dimension one"
     "In this package R is a Euclidean domain and F is a framed algebra"
     "over R.  The package provides functions to compute the integral"
     "closure of R in the quotient field of F.  It is assumed that"
     "char(R/P) = char(R) for any prime P of R.  A typical instance of"
     "this is when R = K[x] and F is a function field over R."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionFieldIntegralBasis|
  (progn
    (push '|FunctionFieldIntegralBasis| *Packages*)
    (make-instance '|FunctionFieldIntegralBasisType|)))

\end{chunk}

\subsection{FunctionSpaceAssertions}
\index[pkg]{FunctionSpaceAssertions!Domain}
\index[pkg]{Domain!FunctionSpaceAssertions}
\index[pkg]{PMASSFS}
\begin{chunk}{defclass FunctionSpaceAssertionsType}
(defclass |FunctionSpaceAssertionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FunctionSpaceAssertions")
   (marker :initform 'package)
   (abbreviation :initform 'PMASSFS)
   (comment :initform (list
     "Attaching assertions to symbols for pattern matching"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionSpaceAssertions|
  (progn
    (push '|FunctionSpaceAssertions| *Packages*)
    (make-instance '|FunctionSpaceAssertionsType|)))

\end{chunk}

\subsection{FunctionSpaceAttachPredicates}
\index[pkg]{FunctionSpaceAttachPredicates!Domain}
\index[pkg]{Domain!FunctionSpaceAttachPredicates}
\index[pkg]{PMPREDFS}
\begin{chunk}{defclass FunctionSpaceAttachPredicatesType}
(defclass |FunctionSpaceAttachPredicatesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FunctionSpaceAttachPredicates")
   (marker :initform 'package)
   (abbreviation :initform 'PMPREDFS)
   (comment :initform (list
     "Attaching predicates to symbols for pattern matching."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionSpaceAttachPredicates|
  (progn
    (push '|FunctionSpaceAttachPredicates| *Packages*)
    (make-instance '|FunctionSpaceAttachPredicatesType|)))

\end{chunk}

\subsection{FunctionSpaceComplexIntegration}
\index[pkg]{FunctionSpaceComplexIntegration!Domain}
\index[pkg]{Domain!FunctionSpaceComplexIntegration}
\index[pkg]{FSCINT}
\begin{chunk}{defclass FunctionSpaceComplexIntegrationType}
(defclass |FunctionSpaceComplexIntegrationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FunctionSpaceComplexIntegration")
   (marker :initform 'package)
   (abbreviation :initform 'FSCINT)
   (comment :initform (list
     "FunctionSpaceComplexIntegration provides functions for the"
     "indefinite integration of complex-valued functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionSpaceComplexIntegration|
  (progn
    (push '|FunctionSpaceComplexIntegration| *Packages*)
    (make-instance '|FunctionSpaceComplexIntegrationType|)))

\end{chunk}

\subsection{FunctionSpaceFunctions2}
\index[pkg]{FunctionSpaceFunctions2!Domain}
\index[pkg]{Domain!FunctionSpaceFunctions2}
\index[pkg]{FS2}
\begin{chunk}{defclass FunctionSpaceFunctions2Type}
(defclass |FunctionSpaceFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FunctionSpaceFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'FS2)
   (comment :initform (list
     "This package allows a mapping R -> S to be lifted to a mapping"
     "from a function space over R to a function space over S"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionSpaceFunctions2|
  (progn
    (push '|FunctionSpaceFunctions2| *Packages*)
    (make-instance '|FunctionSpaceFunctions2Type|)))

\end{chunk}

\subsection{FunctionSpaceIntegration}
\index[pkg]{FunctionSpaceIntegration!Domain}
\index[pkg]{Domain!FunctionSpaceIntegration}
\index[pkg]{FSINT}
\begin{chunk}{defclass FunctionSpaceIntegrationType}
(defclass |FunctionSpaceIntegrationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FunctionSpaceIntegration")
   (marker :initform 'package)
   (abbreviation :initform 'FSINT)
   (comment :initform (list
     "Top-level real function integration"
     "FunctionSpaceIntegration provides functions for the"
     "indefinite integration of real-valued functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionSpaceIntegration|
  (progn
    (push '|FunctionSpaceIntegration| *Packages*)
    (make-instance '|FunctionSpaceIntegrationType|)))

\end{chunk}

\subsection{FunctionSpacePrimitiveElement}
\index[pkg]{FunctionSpacePrimitiveElement!Domain}
\index[pkg]{Domain!FunctionSpacePrimitiveElement}
\index[pkg]{FSPRMELT}
\begin{chunk}{defclass FunctionSpacePrimitiveElementType}
(defclass |FunctionSpacePrimitiveElementType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FunctionSpacePrimitiveElement")
   (marker :initform 'package)
   (abbreviation :initform 'FSPRMELT)
   (comment :initform (list
     "FunctionsSpacePrimitiveElement provides functions to compute"
     "primitive elements in functions spaces"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionSpacePrimitiveElement|
  (progn
    (push '|FunctionSpacePrimitiveElement| *Packages*)
    (make-instance '|FunctionSpacePrimitiveElementType|)))

\end{chunk}

\subsection{FunctionSpaceReduce}
\index[pkg]{FunctionSpaceReduce!Domain}
\index[pkg]{Domain!FunctionSpaceReduce}
\index[pkg]{FSRED}
\begin{chunk}{defclass FunctionSpaceReduceType}
(defclass |FunctionSpaceReduceType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FunctionSpaceReduce")
   (marker :initform 'package)
   (abbreviation :initform 'FSRED)
   (comment :initform (list
     "Reduction from a function space to the rational numbers"
     "This package provides function which replaces transcendental kernels"
     "in a function space by random integers. The correspondence between"
     "the kernels and the integers is fixed between calls to new()."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionSpaceReduce|
  (progn
    (push '|FunctionSpaceReduce| *Packages*)
    (make-instance '|FunctionSpaceReduceType|)))

\end{chunk}

\subsection{FunctionSpaceSum}
\index[pkg]{FunctionSpaceSum!Domain}
\index[pkg]{Domain!FunctionSpaceSum}
\index[pkg]{SUMFS}
\begin{chunk}{defclass FunctionSpaceSumType}
(defclass |FunctionSpaceSumType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FunctionSpaceSum")
   (marker :initform 'package)
   (abbreviation :initform 'SUMFS)
   (comment :initform (list
     "Computes sums of top-level expressions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionSpaceSum|
  (progn
    (push '|FunctionSpaceSum| *Packages*)
    (make-instance '|FunctionSpaceSumType|)))

\end{chunk}

\subsection{FunctionSpaceToExponentialExpansion}
\index[pkg]{FunctionSpaceToExponentialExpansion!Domain}
\index[pkg]{Domain!FunctionSpaceToExponentialExpansion}
\index[pkg]{FS2EXPXP}
\begin{chunk}{defclass FunctionSpaceToExponentialExpansionType}
(defclass |FunctionSpaceToExponentialExpansionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FunctionSpaceToExponentialExpansion")
   (marker :initform 'package)
   (abbreviation :initform 'FS2EXPXP)
   (comment :initform (list
     "This package converts expressions in some function space to exponential"
     "expansions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionSpaceToExponentialExpansion|
  (progn
    (push '|FunctionSpaceToExponentialExpansion| *Packages*)
    (make-instance '|FunctionSpaceToExponentialExpansionType|)))

\end{chunk}

\subsection{FunctionSpaceToUnivariatePowerSeries}
\index[pkg]{FunctionSpaceToUnivariatePowerSeries!Domain}
\index[pkg]{Domain!FunctionSpaceToUnivariatePowerSeries}
\index[pkg]{FS2UPS}
\begin{chunk}{defclass FunctionSpaceToUnivariatePowerSeriesType}
(defclass |FunctionSpaceToUnivariatePowerSeriesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FunctionSpaceToUnivariatePowerSeries")
   (marker :initform 'package)
   (abbreviation :initform 'FS2UPS)
   (comment :initform (list
     "This package converts expressions in some function space to power"
     "series in a variable x with coefficients in that function space."
     "The function exprToUPS converts expressions to power series"
     "whose coefficients do not contain the variable x. The function"
     "exprToGenUPS converts functional expressions to power series"
     "whose coefficients may involve functions of log(x)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionSpaceToUnivariatePowerSeries|
  (progn
    (push '|FunctionSpaceToUnivariatePowerSeries| *Packages*)
    (make-instance '|FunctionSpaceToUnivariatePowerSeriesType|)))

\end{chunk}

\subsection{FunctionSpaceUnivariatePolynomialFactor}
\index[pkg]{FunctionSpaceUnivariatePolynomialFactor!Domain}
\index[pkg]{Domain!FunctionSpaceUnivariatePolynomialFactor}
\index[pkg]{FSUPFACT}
\begin{chunk}{defclass FunctionSpaceUnivariatePolynomialFactorType}
(defclass |FunctionSpaceUnivariatePolynomialFactorType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FunctionSpaceUnivariatePolynomialFactor")
   (marker :initform 'package)
   (abbreviation :initform 'FSUPFACT)
   (comment :initform (list
     "This package is used internally by IR2F"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionSpaceUnivariatePolynomialFactor|
  (progn
    (push '|FunctionSpaceUnivariatePolynomialFactor| *Packages*)
    (make-instance '|FunctionSpaceUnivariatePolynomialFactorType|)))

\end{chunk}

\section{G}

\subsection{GaloisGroupFactorizationUtilities}
\index[pkg]{GaloisGroupFactorizationUtilities!Domain}
\index[pkg]{Domain!GaloisGroupFactorizationUtilities}
\index[pkg]{GALFACTU}
\begin{chunk}{defclass GaloisGroupFactorizationUtilitiesType}
(defclass |GaloisGroupFactorizationUtilitiesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GaloisGroupFactorizationUtilities")
   (marker :initform 'package)
   (abbreviation :initform 'GALFACTU)
   (comment :initform (list
     "GaloisGroupFactorizationUtilities provides functions"
     "that will be used by the factorizer."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GaloisGroupFactorizationUtilities|
  (progn
    (push '|GaloisGroupFactorizationUtilities| *Packages*)
    (make-instance '|GaloisGroupFactorizationUtilitiesType|)))

\end{chunk}

\subsection{GaloisGroupFactorizer}
\index[pkg]{GaloisGroupFactorizer!Domain}
\index[pkg]{Domain!GaloisGroupFactorizer}
\index[pkg]{GALFACT}
\begin{chunk}{defclass GaloisGroupFactorizerType}
(defclass |GaloisGroupFactorizerType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GaloisGroupFactorizer")
   (marker :initform 'package)
   (abbreviation :initform 'GALFACT)
   (comment :initform (list
     "GaloisGroupFactorizationUtilities provides functions"
     "that will be used by the factorizer."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GaloisGroupFactorizer|
  (progn
    (push '|GaloisGroupFactorizer| *Packages*)
    (make-instance '|GaloisGroupFactorizerType|)))

\end{chunk}

\subsection{GaloisGroupPolynomialUtilities}
\index[pkg]{GaloisGroupPolynomialUtilities!Domain}
\index[pkg]{Domain!GaloisGroupPolynomialUtilities}
\index[pkg]{GALPOLYU}
\begin{chunk}{defclass GaloisGroupPolynomialUtilitiesType}
(defclass |GaloisGroupPolynomialUtilitiesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GaloisGroupPolynomialUtilities")
   (marker :initform 'package)
   (abbreviation :initform 'GALPOLYU)
   (comment :initform (list
     "GaloisGroupPolynomialUtilities provides useful"
     "functions for univariate polynomials which should be added to"
     "UnivariatePolynomialCategory or to Factored"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GaloisGroupPolynomialUtilities|
  (progn
    (push '|GaloisGroupPolynomialUtilities| *Packages*)
    (make-instance '|GaloisGroupPolynomialUtilitiesType|)))

\end{chunk}

\subsection{GaloisGroupUtilities}
\index[pkg]{GaloisGroupUtilities!Domain}
\index[pkg]{Domain!GaloisGroupUtilities}
\index[pkg]{GALUTIL}
\begin{chunk}{defclass GaloisGroupUtilitiesType}
(defclass |GaloisGroupUtilitiesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GaloisGroupUtilities")
   (marker :initform 'package)
   (abbreviation :initform 'GALUTIL)
   (comment :initform (list
     "GaloisGroupUtilities provides several useful functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GaloisGroupUtilities|
  (progn
    (push '|GaloisGroupUtilities| *Packages*)
    (make-instance '|GaloisGroupUtilitiesType|)))

\end{chunk}

\subsection{GaussianFactorizationPackage}
\index[pkg]{GaussianFactorizationPackage!Domain}
\index[pkg]{Domain!GaussianFactorizationPackage}
\index[pkg]{GAUSSFAC}
\begin{chunk}{defclass GaussianFactorizationPackageType}
(defclass |GaussianFactorizationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GaussianFactorizationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'GAUSSFAC)
   (comment :initform (list
     "Package for the factorization of complex or gaussian integers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GaussianFactorizationPackage|
  (progn
    (push '|GaussianFactorizationPackage| *Packages*)
    (make-instance '|GaussianFactorizationPackageType|)))

\end{chunk}

\subsection{GeneralHenselPackage}
\index[pkg]{GeneralHenselPackage!Domain}
\index[pkg]{Domain!GeneralHenselPackage}
\index[pkg]{GHENSEL}
\begin{chunk}{defclass GeneralHenselPackageType}
(defclass |GeneralHenselPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GeneralHenselPackage")
   (marker :initform 'package)
   (abbreviation :initform 'GHENSEL)
   (comment :initform (list
     "Used for Factorization of bivariate polynomials over a finite field."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GeneralHenselPackage|
  (progn
    (push '|GeneralHenselPackage| *Packages*)
    (make-instance '|GeneralHenselPackageType|)))

\end{chunk}

\subsection{GeneralizedMultivariateFactorize}
\index[pkg]{GeneralizedMultivariateFactorize!Domain}
\index[pkg]{Domain!GeneralizedMultivariateFactorize}
\index[pkg]{GENMFACT}
\begin{chunk}{defclass GeneralizedMultivariateFactorizeType}
(defclass |GeneralizedMultivariateFactorizeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GeneralizedMultivariateFactorize")
   (marker :initform 'package)
   (abbreviation :initform 'GENMFACT)
   (comment :initform (list
     "This is the top level package for doing multivariate factorization"
     "over basic domains like Integer or Fraction Integer."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GeneralizedMultivariateFactorize|
  (progn
    (push '|GeneralizedMultivariateFactorize| *Packages*)
    (make-instance '|GeneralizedMultivariateFactorizeType|)))

\end{chunk}

\subsection{GeneralPackageForAlgebraicFunctionField}
\index[pkg]{GeneralPackageForAlgebraicFunctionField!Domain}
\index[pkg]{Domain!GeneralPackageForAlgebraicFunctionField}
\index[pkg]{GPAFF}
\begin{chunk}{defclass GeneralPackageForAlgebraicFunctionFieldType}
(defclass |GeneralPackageForAlgebraicFunctionFieldType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GeneralPackageForAlgebraicFunctionField")
   (marker :initform 'package)
   (abbreviation :initform 'GPAFF)
   (comment :initform (list
     "A package that implements the Brill-Noether algorithm. Part of the"
     "PAFF package."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GeneralPackageForAlgebraicFunctionField|
  (progn
    (push '|GeneralPackageForAlgebraicFunctionField| *Packages*)
    (make-instance '|GeneralPackageForAlgebraicFunctionFieldType|)))

\end{chunk}

\subsection{GeneralPolynomialGcdPackage}
\index[pkg]{GeneralPolynomialGcdPackage!Domain}
\index[pkg]{Domain!GeneralPolynomialGcdPackage}
\index[pkg]{GENPGCD}
\begin{chunk}{defclass GeneralPolynomialGcdPackageType}
(defclass |GeneralPolynomialGcdPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GeneralPolynomialGcdPackage")
   (marker :initform 'package)
   (abbreviation :initform 'GENPGCD)
   (comment :initform nil)
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GeneralPolynomialGcdPackage|
  (progn
    (push '|GeneralPolynomialGcdPackage| *Packages*)
    (make-instance '|GeneralPolynomialGcdPackageType|)))

\end{chunk}

\subsection{GenerateUnivariatePowerSeries}
\index[pkg]{GenerateUnivariatePowerSeries!Domain}
\index[pkg]{Domain!GenerateUnivariatePowerSeries}
\index[pkg]{GENUPS}
\begin{chunk}{defclass GenerateUnivariatePowerSeriesType}
(defclass |GenerateUnivariatePowerSeriesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GenerateUnivariatePowerSeries")
   (marker :initform 'package)
   (abbreviation :initform 'GENUPS)
   (comment :initform (list
     "GenerateUnivariatePowerSeries provides functions that create"
     "power series from explicit formulas for their nth coefficient."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GenerateUnivariatePowerSeries|
  (progn
    (push '|GenerateUnivariatePowerSeries| *Packages*)
    (make-instance '|GenerateUnivariatePowerSeriesType|)))

\end{chunk}

\subsection{GenExEuclid}
\index[pkg]{GenExEuclid!Domain}
\index[pkg]{Domain!GenExEuclid}
\index[pkg]{GENEEZ}
\begin{chunk}{defclass GenExEuclidType}
(defclass |GenExEuclidType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GenExEuclid")
   (marker :initform 'package)
   (abbreviation :initform 'GENEEZ)
   (comment :initform nil)
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GenExEuclid|
  (progn
    (push '|GenExEuclid| *Packages*)
    (make-instance '|GenExEuclidType|)))

\end{chunk}

\subsection{GenUFactorize}
\index[pkg]{GenUFactorize!Domain}
\index[pkg]{Domain!GenUFactorize}
\index[pkg]{GENUFACT}
\begin{chunk}{defclass GenUFactorizeType}
(defclass |GenUFactorizeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GenUFactorize")
   (marker :initform 'package)
   (abbreviation :initform 'GENUFACT)
   (comment :initform (list
     "This package provides operations for the factorization"
     "of univariate polynomials with integer"
     "coefficients. The factorization is done by 'lifting' the"
     "finite 'berlekamp's factorization"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GenUFactorize|
  (progn
    (push '|GenUFactorize| *Packages*)
    (make-instance '|GenUFactorizeType|)))

\end{chunk}

\subsection{GenusZeroIntegration}
\index[pkg]{GenusZeroIntegration!Domain}
\index[pkg]{Domain!GenusZeroIntegration}
\index[pkg]{INTG0}
\begin{chunk}{defclass GenusZeroIntegrationType}
(defclass |GenusZeroIntegrationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GenusZeroIntegration")
   (marker :initform 'package)
   (abbreviation :initform 'INTG0)
   (comment :initform (list
     "Rationalization of several types of genus 0 integrands"
     "This internal package rationalises integrands on curves of the form"
     "     y\^2 = a x\^2 + b x + c"
     "     y\^2 = (a x + b) / (c x + d)"
     "     f(x, y) = 0 where f has degree 1 in x"
     "The rationalization is done for integration, limited integration,"
     "extended integration and the risch differential equation"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GenusZeroIntegration|
  (progn
    (push '|GenusZeroIntegration| *Packages*)
    (make-instance '|GenusZeroIntegrationType|)))

\end{chunk}

\subsection{GnuDraw}
\index[pkg]{GnuDraw!Domain}
\index[pkg]{Domain!GnuDraw}
\index[pkg]{GDRAW}
\begin{chunk}{defclass GnuDrawType}
(defclass |GnuDrawType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GnuDraw")
   (marker :initform 'package)
   (abbreviation :initform 'GDRAW)
   (comment :initform (list
     "This package provides support for gnuplot. These routines"
     "generate output files contain gnuplot scripts that may be"
     "processed directly by gnuplot. This is especially convenient"
     "in the axiom-wiki environment where gnuplot is called from"
     "LaTeX via gnuplottex."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GnuDraw|
  (progn
    (push '|GnuDraw| *Packages*)
    (make-instance '|GnuDrawType|)))

\end{chunk}

\subsection{GosperSummationMethod}
\index[pkg]{GosperSummationMethod!Domain}
\index[pkg]{Domain!GosperSummationMethod}
\index[pkg]{GOSPER}
\begin{chunk}{defclass GosperSummationMethodType}
(defclass |GosperSummationMethodType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GosperSummationMethod")
   (marker :initform 'package)
   (abbreviation :initform 'GOSPER)
   (comment :initform (list
     "Gosper's summation algorithm."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GosperSummationMethod|
  (progn
    (push '|GosperSummationMethod| *Packages*)
    (make-instance '|GosperSummationMethodType|)))

\end{chunk}

\subsection{GraphicsDefaults}
\index[pkg]{GraphicsDefaults!Domain}
\index[pkg]{Domain!GraphicsDefaults}
\index[pkg]{GRDEF}
\begin{chunk}{defclass GraphicsDefaultsType}
(defclass |GraphicsDefaultsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GraphicsDefaults")
   (marker :initform 'package)
   (abbreviation :initform 'GRDEF)
   (comment :initform (list
     "TwoDimensionalPlotSettings sets global flags and constants"
     "for 2-dimensional plotting."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GraphicsDefaults|
  (progn
    (push '|GraphicsDefaults| *Packages*)
    (make-instance '|GraphicsDefaultsType|)))

\end{chunk}

\subsection{Graphviz}
\index[pkg]{Graphviz!Domain}
\index[pkg]{Domain!Graphviz}
\index[pkg]{GRAPHVIZ}
\begin{chunk}{defclass GraphvizType}
(defclass |GraphvizType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "Graphviz")
   (marker :initform 'package)
   (abbreviation :initform 'GRAPHVIZ)
   (comment :initform (list
     "Low level tools for creating and viewing graphs using graphviz"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Graphviz|
  (progn
    (push '|Graphviz| *Packages*)
    (make-instance '|GraphvizType|)))

\end{chunk}

\subsection{GrayCode}
\index[pkg]{GrayCode!Domain}
\index[pkg]{Domain!GrayCode}
\index[pkg]{GRAY}
\begin{chunk}{defclass GrayCodeType}
(defclass |GrayCodeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GrayCode")
   (marker :initform 'package)
   (abbreviation :initform 'GRAY)
   (comment :initform (list
     "GrayCode provides a function for efficiently running"
     "through all subsets of a finite set, only changing one element"
     "by another one."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GrayCode|
  (progn
    (push '|GrayCode| *Packages*)
    (make-instance '|GrayCodeType|)))

\end{chunk}

\subsection{GroebnerFactorizationPackage}
\index[pkg]{GroebnerFactorizationPackage!Domain}
\index[pkg]{Domain!GroebnerFactorizationPackage}
\index[pkg]{GBF}
\begin{chunk}{defclass GroebnerFactorizationPackageType}
(defclass |GroebnerFactorizationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GroebnerFactorizationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'GBF)
   (comment :initform (list
     "GroebnerFactorizationPackage provides the function"
     "groebnerFactor which uses the factorization routines of Axiom to"
     "factor each polynomial under consideration while doing the groebner basis"
     "algorithm. Then it writes the ideal as an intersection of ideals"
     "determined by the irreducible factors. Note that the whole ring may"
     "occur as well as other redundancies. We also use the fact, that from the"
     "second factor on we can assume that the preceding factors are"
     "not equal to 0 and we divide all polynomials under considerations"
     "by the elements of this list of 'nonZeroRestrictions'."
     "The result is a list of groebner bases, whose union of solutions"
     "of the corresponding systems of equations is the solution of"
     "the system of equation corresponding to the input list."
     "The term ordering is determined by the polynomial type used."
     "Suggested types include"
     "DistributedMultivariatePolynomial,"
     "HomogeneousDistributedMultivariatePolynomial,"
     "GeneralDistributedMultivariatePolynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GroebnerFactorizationPackage|
  (progn
    (push '|GroebnerFactorizationPackage| *Packages*)
    (make-instance '|GroebnerFactorizationPackageType|)))

\end{chunk}

\subsection{GroebnerInternalPackage}
\index[pkg]{GroebnerInternalPackage!Domain}
\index[pkg]{Domain!GroebnerInternalPackage}
\index[pkg]{GBINTERN}
\begin{chunk}{defclass GroebnerInternalPackageType}
(defclass |GroebnerInternalPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GroebnerInternalPackage")
   (marker :initform 'package)
   (abbreviation :initform 'GBINTERN)
   (comment :initform (list
     "This package provides low level tools for Groebner basis computations"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GroebnerInternalPackage|
  (progn
    (push '|GroebnerInternalPackage| *Packages*)
    (make-instance '|GroebnerInternalPackageType|)))

\end{chunk}

\subsection{GroebnerPackage}
\index[pkg]{GroebnerPackage!Domain}
\index[pkg]{Domain!GroebnerPackage}
\index[pkg]{GB}
\begin{chunk}{defclass GroebnerPackageType}
(defclass |GroebnerPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GroebnerPackage")
   (marker :initform 'package)
   (abbreviation :initform 'GB)
   (comment :initform (list
     "GroebnerPackage computes groebner"
     "bases for polynomial ideals. The basic computation provides a distinguished"
     "set of generators for polynomial ideals over fields. This basis allows an"
     "easy test for membership: the operation normalForm"
     "returns zero on ideal members. When the provided coefficient domain, Dom,"
     "is not a field, the result is equivalent to considering the extended"
     "ideal with Fraction(Dom) as coefficients, but considerably more"
     "efficient since all calculations are performed in Dom. Additional"
     "argument 'info' and 'redcrit' can be given to provide incremental"
     "information during computation. Argument 'info' produces a computational"
     "summary for each s-polynomial."
     "Argument 'redcrit' prints out the reduced critical pairs. The term ordering"
     "is determined by the polynomial type used. Suggested types include"
     "DistributedMultivariatePolynomial,"
     "HomogeneousDistributedMultivariatePolynomial,"
     "GeneralDistributedMultivariatePolynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GroebnerPackage|
  (progn
    (push '|GroebnerPackage| *Packages*)
    (make-instance '|GroebnerPackageType|)))

\end{chunk}

\subsection{GroebnerSolve}
\index[pkg]{GroebnerSolve!Domain}
\index[pkg]{Domain!GroebnerSolve}
\index[pkg]{GROEBSOL}
\begin{chunk}{defclass GroebnerSolveType}
(defclass |GroebnerSolveType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GroebnerSolve")
   (marker :initform 'package)
   (abbreviation :initform 'GROEBSOL)
   (comment :initform (list
     "Solve systems of polynomial equations using Groebner bases"
     "Total order Groebner bases are computed and then converted to lex ones"
     "This package is mostly intended for internal use."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GroebnerSolve|
  (progn
    (push '|GroebnerSolve| *Packages*)
    (make-instance '|GroebnerSolveType|)))

\end{chunk}

\subsection{Guess}
\index[pkg]{Guess!Domain}
\index[pkg]{Domain!Guess}
\index[pkg]{GUESS}
\begin{chunk}{defclass GuessType}
(defclass |GuessType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "Guess")
   (marker :initform 'package)
   (abbreviation :initform 'GUESS)
   (comment :initform (list
     "This package implements guessing of sequences. Packages for the"
     "most common cases are provided as GuessInteger,"
     "GuessPolynomial, etc."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Guess|
  (progn
    (push '|Guess| *Packages*)
    (make-instance '|GuessType|)))

\end{chunk}

\subsection{GuessAlgebraicNumber}
\index[pkg]{GuessAlgebraicNumber!Domain}
\index[pkg]{Domain!GuessAlgebraicNumber}
\index[pkg]{GUESSAN}
\begin{chunk}{defclass GuessAlgebraicNumberType}
(defclass |GuessAlgebraicNumberType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GuessAlgebraicNumber")
   (marker :initform 'package)
   (abbreviation :initform 'GUESSAN)
   (comment :initform (list
     "This package exports guessing of sequences of rational functions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GuessAlgebraicNumber|
  (progn
    (push '|GuessAlgebraicNumber| *Packages*)
    (make-instance '|GuessAlgebraicNumberType|)))

\end{chunk}

\subsection{GuessFinite}
\index[pkg]{GuessFinite!Domain}
\index[pkg]{Domain!GuessFinite}
\index[pkg]{GUESSF}
\begin{chunk}{defclass GuessFiniteType}
(defclass |GuessFiniteType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GuessFinite")
   (marker :initform 'package)
   (abbreviation :initform 'GUESSF)
   (comment :initform (list
     "This package exports guessing of sequences of numbers in a finite field"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GuessFinite|
  (progn
    (push '|GuessFinite| *Packages*)
    (make-instance '|GuessFiniteType|)))

\end{chunk}

\subsection{GuessFiniteFunctions}
\index[pkg]{GuessFiniteFunctions!Domain}
\index[pkg]{Domain!GuessFiniteFunctions}
\index[pkg]{GUESSF1}
\begin{chunk}{defclass GuessFiniteFunctionsType}
(defclass |GuessFiniteFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GuessFiniteFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'GUESSF1)
   (comment :initform (list
     "This package exports guessing of sequences of numbers in a finite field"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GuessFiniteFunctions|
  (progn
    (push '|GuessFiniteFunctions| *Packages*)
    (make-instance '|GuessFiniteFunctionsType|)))

\end{chunk}

\subsection{GuessInteger}
\index[pkg]{GuessInteger!Domain}
\index[pkg]{Domain!GuessInteger}
\index[pkg]{GUESSINT}
\begin{chunk}{defclass GuessIntegerType}
(defclass |GuessIntegerType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GuessInteger")
   (marker :initform 'package)
   (abbreviation :initform 'GUESSINT)
   (comment :initform (list
     "This package exports guessing of sequences of rational numbers"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GuessInteger|
  (progn
    (push '|GuessInteger| *Packages*)
    (make-instance '|GuessIntegerType|)))

\end{chunk}

\subsection{GuessPolynomial}
\index[pkg]{GuessPolynomial!Domain}
\index[pkg]{Domain!GuessPolynomial}
\index[pkg]{GUESSP}
\begin{chunk}{defclass GuessPolynomialType}
(defclass |GuessPolynomialType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GuessPolynomial")
   (marker :initform 'package)
   (abbreviation :initform 'GUESSP)
   (comment :initform (list
     "This package exports guessing of sequences of rational functions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GuessPolynomial|
  (progn
    (push '|GuessPolynomial| *Packages*)
    (make-instance '|GuessPolynomialType|)))

\end{chunk}

\subsection{GuessUnivariatePolynomial}
\index[pkg]{GuessUnivariatePolynomial!Domain}
\index[pkg]{Domain!GuessUnivariatePolynomial}
\index[pkg]{GUESSUP}
\begin{chunk}{defclass GuessUnivariatePolynomialType}
(defclass |GuessUnivariatePolynomialType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GuessUnivariatePolynomial")
   (marker :initform 'package)
   (abbreviation :initform 'GUESSUP)
   (comment :initform (list
     "This package exports guessing of sequences of univariate rational functions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GuessUnivariatePolynomial|
  (progn
    (push '|GuessUnivariatePolynomial| *Packages*)
    (make-instance '|GuessUnivariatePolynomialType|)))

\end{chunk}

\section{H}

\subsection{HallBasis}
\index[pkg]{HallBasis!Domain}
\index[pkg]{Domain!HallBasis}
\index[pkg]{HB}
\begin{chunk}{defclass HallBasisType}
(defclass |HallBasisType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "HallBasis")
   (marker :initform 'package)
   (abbreviation :initform 'HB)
   (comment :initform (list
     "Generate a basis for the free Lie algebra on n"
     "generators over a ring R with identity up to basic commutators"
     "of length c using the algorithm of P. Hall as given in Serre's"
     "book Lie Groups -- Lie Algebras"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |HallBasis|
  (progn
    (push '|HallBasis| *Packages*)
    (make-instance '|HallBasisType|)))

\end{chunk}

\subsection{HeuGcd}
\index[pkg]{HeuGcd!Domain}
\index[pkg]{Domain!HeuGcd}
\index[pkg]{HEUGCD}
\begin{chunk}{defclass HeuGcdType}
(defclass |HeuGcdType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "HeuGcd")
   (marker :initform 'package)
   (abbreviation :initform 'HEUGCD)
   (comment :initform (list
     "This package provides the functions for the heuristic integer gcd."
     "Geddes's algorithm,for univariate polynomials with integer coefficients"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |HeuGcd|
  (progn
    (push '|HeuGcd| *Packages*)
    (make-instance '|HeuGcdType|)))

\end{chunk}

\section{I}

\subsection{IdealDecompositionPackage}
\index[pkg]{IdealDecompositionPackage!Domain}
\index[pkg]{Domain!IdealDecompositionPackage}
\index[pkg]{IDECOMP}
\begin{chunk}{defclass IdealDecompositionPackageType}
(defclass |IdealDecompositionPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IdealDecompositionPackage")
   (marker :initform 'package)
   (abbreviation :initform 'IDECOMP)
   (comment :initform (list
     "This package provides functions for the primary decomposition of"
     "polynomial ideals over the rational numbers. The ideals are members"
     "of the PolynomialIdeals domain, and the polynomial generators are"
     "required to be from the DistributedMultivariatePolynomial domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IdealDecompositionPackage|
  (progn
    (push '|IdealDecompositionPackage| *Packages*)
    (make-instance '|IdealDecompositionPackageType|)))

\end{chunk}

\subsection{IncrementingMaps}
\index[pkg]{IncrementingMaps!Domain}
\index[pkg]{Domain!IncrementingMaps}
\index[pkg]{INCRMAPS}
\begin{chunk}{defclass IncrementingMapsType}
(defclass |IncrementingMapsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IncrementingMaps")
   (marker :initform 'package)
   (abbreviation :initform 'INCRMAPS)
   (comment :initform (list
     "This package provides operations to create incrementing functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IncrementingMaps|
  (progn
    (push '|IncrementingMaps| *Packages*)
    (make-instance '|IncrementingMapsType|)))

\end{chunk}

\subsection{InfiniteProductCharacteristicZero}
\index[pkg]{InfiniteProductCharacteristicZero!Domain}
\index[pkg]{Domain!InfiniteProductCharacteristicZero}
\index[pkg]{INFPROD0}
\begin{chunk}{defclass InfiniteProductCharacteristicZeroType}
(defclass |InfiniteProductCharacteristicZeroType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InfiniteProductCharacteristicZero")
   (marker :initform 'package)
   (abbreviation :initform 'INFPROD0)
   (comment :initform (list
     "This package computes infinite products of univariate Taylor series"
     "over an integral domain of characteristic 0."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InfiniteProductCharacteristicZero|
  (progn
    (push '|InfiniteProductCharacteristicZero| *Packages*)
    (make-instance '|InfiniteProductCharacteristicZeroType|)))

\end{chunk}

\subsection{InfiniteProductFiniteField}
\index[pkg]{InfiniteProductFiniteField!Domain}
\index[pkg]{Domain!InfiniteProductFiniteField}
\index[pkg]{INPRODFF}
\begin{chunk}{defclass InfiniteProductFiniteFieldType}
(defclass |InfiniteProductFiniteFieldType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InfiniteProductFiniteField")
   (marker :initform 'package)
   (abbreviation :initform 'INPRODFF)
   (comment :initform (list
     "This package computes infinite products of univariate Taylor series"
     "over an arbitrary finite field."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InfiniteProductFiniteField|
  (progn
    (push '|InfiniteProductFiniteField| *Packages*)
    (make-instance '|InfiniteProductFiniteFieldType|)))

\end{chunk}

\subsection{InfiniteProductPrimeField}
\index[pkg]{InfiniteProductPrimeField!Domain}
\index[pkg]{Domain!InfiniteProductPrimeField}
\index[pkg]{INPRODPF}
\begin{chunk}{defclass InfiniteProductPrimeFieldType}
(defclass |InfiniteProductPrimeFieldType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InfiniteProductPrimeField")
   (marker :initform 'package)
   (abbreviation :initform 'INPRODPF)
   (comment :initform (list
     "This package computes infinite products of univariate Taylor series"
     "over a field of prime order."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InfiniteProductPrimeField|
  (progn
    (push '|InfiniteProductPrimeField| *Packages*)
    (make-instance '|InfiniteProductPrimeFieldType|)))

\end{chunk}

\subsection{InfiniteTupleFunctions2}
\index[pkg]{InfiniteTupleFunctions2!Domain}
\index[pkg]{Domain!InfiniteTupleFunctions2}
\index[pkg]{ITFUN2}
\begin{chunk}{defclass InfiniteTupleFunctions2Type}
(defclass |InfiniteTupleFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InfiniteTupleFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'ITFUN2)
   (comment :initform (list
     "Functions defined on streams with entries in two sets."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InfiniteTupleFunctions2|
  (progn
    (push '|InfiniteTupleFunctions2| *Packages*)
    (make-instance '|InfiniteTupleFunctions2Type|)))

\end{chunk}

\subsection{InfiniteTupleFunctions3}
\index[pkg]{InfiniteTupleFunctions3!Domain}
\index[pkg]{Domain!InfiniteTupleFunctions3}
\index[pkg]{ITFUN3}
\begin{chunk}{defclass InfiniteTupleFunctions3Type}
(defclass |InfiniteTupleFunctions3Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InfiniteTupleFunctions3")
   (marker :initform 'package)
   (abbreviation :initform 'ITFUN3)
   (comment :initform (list
     "Functions defined on streams with entries in two sets."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InfiniteTupleFunctions3|
  (progn
    (push '|InfiniteTupleFunctions3| *Packages*)
    (make-instance '|InfiniteTupleFunctions3Type|)))

\end{chunk}

\subsection{Infinity}
\index[pkg]{Infinity!Domain}
\index[pkg]{Domain!Infinity}
\index[pkg]{INFINITY}
\begin{chunk}{defclass InfinityType}
(defclass |InfinityType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "Infinity")
   (marker :initform 'package)
   (abbreviation :initform 'INFINITY)
   (comment :initform (list
     "Default infinity signatures for the interpreter"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Infinity|
  (progn
    (push '|Infinity| *Packages*)
    (make-instance '|InfinityType|)))

\end{chunk}

\subsection{InnerAlgFactor}
\index[pkg]{InnerAlgFactor!Domain}
\index[pkg]{Domain!InnerAlgFactor}
\index[pkg]{IALGFACT}
\begin{chunk}{defclass InnerAlgFactorType}
(defclass |InnerAlgFactorType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InnerAlgFactor")
   (marker :initform 'package)
   (abbreviation :initform 'IALGFACT)
   (comment :initform (list
     "Factorisation in a simple algebraic extension"
     "Factorization of univariate polynomials with coefficients in an"
     "algebraic extension of a field over which we can factor UP's"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerAlgFactor|
  (progn
    (push '|InnerAlgFactor| *Packages*)
    (make-instance '|InnerAlgFactorType|)))

\end{chunk}

\subsection{InnerCommonDenominator}
\index[pkg]{InnerCommonDenominator!Domain}
\index[pkg]{Domain!InnerCommonDenominator}
\index[pkg]{ICDEN}
\begin{chunk}{defclass InnerCommonDenominatorType}
(defclass |InnerCommonDenominatorType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InnerCommonDenominator")
   (marker :initform 'package)
   (abbreviation :initform 'ICDEN)
   (comment :initform (list
     "InnerCommonDenominator provides functions to compute"
     "the common denominator of a finite linear aggregate of elements"
     "of the quotient field of an integral domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerCommonDenominator|
  (progn
    (push '|InnerCommonDenominator| *Packages*)
    (make-instance '|InnerCommonDenominatorType|)))

\end{chunk}

\subsection{InnerMatrixLinearAlgebraFunctions}
\index[pkg]{InnerMatrixLinearAlgebraFunctions!Domain}
\index[pkg]{Domain!InnerMatrixLinearAlgebraFunctions}
\index[pkg]{IMATLIN}
\begin{chunk}{defclass InnerMatrixLinearAlgebraFunctionsType}
(defclass |InnerMatrixLinearAlgebraFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InnerMatrixLinearAlgebraFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'IMATLIN)
   (comment :initform (list
     "InnerMatrixLinearAlgebraFunctions is an internal package"
     "which provides standard linear algebra functions on domains in"
     "MatrixCategory"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerMatrixLinearAlgebraFunctions|
  (progn
    (push '|InnerMatrixLinearAlgebraFunctions| *Packages*)
    (make-instance '|InnerMatrixLinearAlgebraFunctionsType|)))

\end{chunk}

\subsection{InnerMatrixQuotientFieldFunctions}
\index[pkg]{InnerMatrixQuotientFieldFunctions!Domain}
\index[pkg]{Domain!InnerMatrixQuotientFieldFunctions}
\index[pkg]{IMATQF}
\begin{chunk}{defclass InnerMatrixQuotientFieldFunctionsType}
(defclass |InnerMatrixQuotientFieldFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InnerMatrixQuotientFieldFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'IMATQF)
   (comment :initform (list
     "InnerMatrixQuotientFieldFunctions provides functions on matrices"
     "over an integral domain which involve the quotient field of that integral"
     "domain.  The functions rowEchelon and inverse return matrices with"
     "entries in the quotient field."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerMatrixQuotientFieldFunctions|
  (progn
    (push '|InnerMatrixQuotientFieldFunctions| *Packages*)
    (make-instance '|InnerMatrixQuotientFieldFunctionsType|)))

\end{chunk}

\subsection{InnerModularGcd}
\index[pkg]{InnerModularGcd!Domain}
\index[pkg]{Domain!InnerModularGcd}
\index[pkg]{INMODGCD}
\begin{chunk}{defclass InnerModularGcdType}
(defclass |InnerModularGcdType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InnerModularGcd")
   (marker :initform 'package)
   (abbreviation :initform 'INMODGCD)
   (comment :initform (list
     "This file contains the functions for modular gcd algorithm"
     "for univariate polynomials with coefficients in a"
     "non-trivial euclidean domain (not a field)."
     "The package parametrised by the coefficient domain,"
     "the polynomial domain, a prime, and a function for choosing the next prime"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerModularGcd|
  (progn
    (push '|InnerModularGcd| *Packages*)
    (make-instance '|InnerModularGcdType|)))

\end{chunk}

\subsection{InnerMultFact}
\index[pkg]{InnerMultFact!Domain}
\index[pkg]{Domain!InnerMultFact}
\index[pkg]{INNMFACT}
\begin{chunk}{defclass InnerMultFactType}
(defclass |InnerMultFactType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InnerMultFact")
   (marker :initform 'package)
   (abbreviation :initform 'INNMFACT)
   (comment :initform (list
     "This is an inner package for factoring multivariate polynomials"
     "over various coefficient domains in characteristic 0."
     "The univariate factor operation is passed as a parameter."
     "Multivariate hensel lifting is used to lift the univariate"
     "factorization"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerMultFact|
  (progn
    (push '|InnerMultFact| *Packages*)
    (make-instance '|InnerMultFactType|)))

\end{chunk}

\subsection{InnerNormalBasisFieldFunctions}
\index[pkg]{InnerNormalBasisFieldFunctions!Domain}
\index[pkg]{Domain!InnerNormalBasisFieldFunctions}
\index[pkg]{INBFF}
\begin{chunk}{defclass InnerNormalBasisFieldFunctionsType}
(defclass |InnerNormalBasisFieldFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InnerNormalBasisFieldFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'INBFF)
   (comment :initform (list
     "InnerNormalBasisFieldFunctions(GF) (unexposed)"
     "This package has functions used by"
     "every normal basis finite field extension domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerNormalBasisFieldFunctions|
  (progn
    (push '|InnerNormalBasisFieldFunctions| *Packages*)
    (make-instance '|InnerNormalBasisFieldFunctionsType|)))

\end{chunk}

\subsection{InnerNumericEigenPackage}
\index[pkg]{InnerNumericEigenPackage!Domain}
\index[pkg]{Domain!InnerNumericEigenPackage}
\index[pkg]{INEP}
\begin{chunk}{defclass InnerNumericEigenPackageType}
(defclass |InnerNumericEigenPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InnerNumericEigenPackage")
   (marker :initform 'package)
   (abbreviation :initform 'INEP)
   (comment :initform (list
     "This package is the inner package to be used by NumericRealEigenPackage"
     "and NumericComplexEigenPackage for the computation of numeric"
     "eigenvalues and eigenvectors."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerNumericEigenPackage|
  (progn
    (push '|InnerNumericEigenPackage| *Packages*)
    (make-instance '|InnerNumericEigenPackageType|)))

\end{chunk}

\subsection{InnerNumericFloatSolvePackage}
\index[pkg]{InnerNumericFloatSolvePackage!Domain}
\index[pkg]{Domain!InnerNumericFloatSolvePackage}
\index[pkg]{INFSP}
\begin{chunk}{defclass InnerNumericFloatSolvePackageType}
(defclass |InnerNumericFloatSolvePackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InnerNumericFloatSolvePackage")
   (marker :initform 'package)
   (abbreviation :initform 'INFSP)
   (comment :initform (list
     "This is an internal package"
     "for computing approximate solutions to systems of polynomial equations."
     "The parameter K specifies the coefficient field of the input polynomials"
     "and must be either \spad{Fraction(Integer)} or"
     "Complex(Fraction Integer)."
     "The parameter F specifies where the solutions must lie and can"
     "be one of the following: Float, Fraction(Integer), Complex(Float),"
     "Complex(Fraction Integer). The last parameter specifies the type"
     "of the precision operand and must be either Fraction(Integer) or"
     "Float."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerNumericFloatSolvePackage|
  (progn
    (push '|InnerNumericFloatSolvePackage| *Packages*)
    (make-instance '|InnerNumericFloatSolvePackageType|)))

\end{chunk}

\subsection{InnerPolySign}
\index[pkg]{InnerPolySign!Domain}
\index[pkg]{Domain!InnerPolySign}
\index[pkg]{INPSIGN}
\begin{chunk}{defclass InnerPolySignType}
(defclass |InnerPolySignType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InnerPolySign")
   (marker :initform 'package)
   (abbreviation :initform 'INPSIGN)
   (comment :initform (list
     "Find the sign of a polynomial around a point or infinity."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerPolySign|
  (progn
    (push '|InnerPolySign| *Packages*)
    (make-instance '|InnerPolySignType|)))

\end{chunk}

\subsection{InnerPolySum}
\index[pkg]{InnerPolySum!Domain}
\index[pkg]{Domain!InnerPolySum}
\index[pkg]{ISUMP}
\begin{chunk}{defclass InnerPolySumType}
(defclass |InnerPolySumType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InnerPolySum")
   (marker :initform 'package)
   (abbreviation :initform 'ISUMP)
   (comment :initform (list
     "Tools for the summation packages of polynomials"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerPolySum|
  (progn
    (push '|InnerPolySum| *Packages*)
    (make-instance '|InnerPolySumType|)))

\end{chunk}

\subsection{InnerTrigonometricManipulations}
\index[pkg]{InnerTrigonometricManipulations!Domain}
\index[pkg]{Domain!InnerTrigonometricManipulations}
\index[pkg]{ITRIGMNP}
\begin{chunk}{defclass InnerTrigonometricManipulationsType}
(defclass |InnerTrigonometricManipulationsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InnerTrigonometricManipulations")
   (marker :initform 'package)
   (abbreviation :initform 'ITRIGMNP)
   (comment :initform (list
     "This package provides transformations from trigonometric functions"
     "to exponentials and logarithms, and back."
     "F and FG should be the same type of function space."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerTrigonometricManipulations|
  (progn
    (push '|InnerTrigonometricManipulations| *Packages*)
    (make-instance '|InnerTrigonometricManipulationsType|)))

\end{chunk}

\subsection{InputFormFunctions1}
\index[pkg]{InputFormFunctions1!Domain}
\index[pkg]{Domain!InputFormFunctions1}
\index[pkg]{INFORM1}
\begin{chunk}{defclass InputFormFunctions1Type}
(defclass |InputFormFunctions1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InputFormFunctions1")
   (marker :initform 'package)
   (abbreviation :initform 'INFORM1)
   (comment :initform (list
     "Tools for manipulating input forms."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InputFormFunctions1|
  (progn
    (push '|InputFormFunctions1| *Packages*)
    (make-instance '|InputFormFunctions1Type|)))

\end{chunk}

\subsection{InterfaceGroebnerPackage}
\index[pkg]{InterfaceGroebnerPackage!Domain}
\index[pkg]{Domain!InterfaceGroebnerPackage}
\index[pkg]{INTERGB}
\begin{chunk}{defclass InterfaceGroebnerPackageType}
(defclass |InterfaceGroebnerPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InterfaceGroebnerPackage")
   (marker :initform 'package)
   (abbreviation :initform 'INTERGB)
   (comment :initform (list
     "Part of the Package for Algebraic Function Fields in one variable PAFF"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InterfaceGroebnerPackage|
  (progn
    (push '|InterfaceGroebnerPackage| *Packages*)
    (make-instance '|InterfaceGroebnerPackageType|)))

\end{chunk}

\subsection{IntegerBits}
\index[pkg]{IntegerBits!Domain}
\index[pkg]{Domain!IntegerBits}
\index[pkg]{INTBIT}
\begin{chunk}{defclass IntegerBitsType}
(defclass |IntegerBitsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IntegerBits")
   (marker :initform 'package)
   (abbreviation :initform 'INTBIT)
   (comment :initform (list
     "This  package provides functions to lookup bits in integers "))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegerBits|
  (progn
    (push '|IntegerBits| *Packages*)
    (make-instance '|IntegerBitsType|)))

\end{chunk}

\subsection{IntegerCombinatoricFunctions}
\index[pkg]{IntegerCombinatoricFunctions!Domain}
\index[pkg]{Domain!IntegerCombinatoricFunctions}
\index[pkg]{COMBINAT}
\begin{chunk}{defclass IntegerCombinatoricFunctionsType}
(defclass |IntegerCombinatoricFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IntegerCombinatoricFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'COMBINAT)
   (comment :initform (list
     "The IntegerCombinatoricFunctions package provides some"
     "standard functions in combinatorics."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegerCombinatoricFunctions|
  (progn
    (push '|IntegerCombinatoricFunctions| *Packages*)
    (make-instance '|IntegerCombinatoricFunctionsType|)))

\end{chunk}

\subsection{IntegerFactorizationPackage}
\index[pkg]{IntegerFactorizationPackage!Domain}
\index[pkg]{Domain!IntegerFactorizationPackage}
\index[pkg]{INTFACT}
\begin{chunk}{defclass IntegerFactorizationPackageType}
(defclass |IntegerFactorizationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IntegerFactorizationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'INTFACT)
   (comment :initform (list
     "This Package contains basic methods for integer factorization."
     "The factor operation employs trial division up to 10,000.  It"
     "then tests to see if n is a perfect power before using Pollards"
     "rho method.  Because Pollards method may fail, the result"
     "of factor may contain composite factors.  We should also employ"
     "Lenstra's eliptic curve method."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegerFactorizationPackage|
  (progn
    (push '|IntegerFactorizationPackage| *Packages*)
    (make-instance '|IntegerFactorizationPackageType|)))

\end{chunk}

\subsection{IntegerLinearDependence}
\index[pkg]{IntegerLinearDependence!Domain}
\index[pkg]{Domain!IntegerLinearDependence}
\index[pkg]{ZLINDEP}
\begin{chunk}{defclass IntegerLinearDependenceType}
(defclass |IntegerLinearDependenceType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IntegerLinearDependence")
   (marker :initform 'package)
   (abbreviation :initform 'ZLINDEP)
   (comment :initform (list
     "Test for linear dependence over the integers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegerLinearDependence|
  (progn
    (push '|IntegerLinearDependence| *Packages*)
    (make-instance '|IntegerLinearDependenceType|)))

\end{chunk}

\subsection{IntegerNumberTheoryFunctions}
\index[pkg]{IntegerNumberTheoryFunctions!Domain}
\index[pkg]{Domain!IntegerNumberTheoryFunctions}
\index[pkg]{INTHEORY}
\begin{chunk}{defclass IntegerNumberTheoryFunctionsType}
(defclass |IntegerNumberTheoryFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IntegerNumberTheoryFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'INTHEORY)
   (comment :initform (list
     "This package provides various number theoretic functions on the integers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegerNumberTheoryFunctions|
  (progn
    (push '|IntegerNumberTheoryFunctions| *Packages*)
    (make-instance '|IntegerNumberTheoryFunctionsType|)))

\end{chunk}

\subsection{IntegerPrimesPackage}
\index[pkg]{IntegerPrimesPackage!Domain}
\index[pkg]{Domain!IntegerPrimesPackage}
\index[pkg]{PRIMES}
\begin{chunk}{defclass IntegerPrimesPackageType}
(defclass |IntegerPrimesPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IntegerPrimesPackage")
   (marker :initform 'package)
   (abbreviation :initform 'PRIMES)
   (comment :initform (list
     "The IntegerPrimesPackage implements a modification of"
     "Rabin's probabilistic"
     "primality test and the utility functions nextPrime,"
     "prevPrime and primes."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegerPrimesPackage|
  (progn
    (push '|IntegerPrimesPackage| *Packages*)
    (make-instance '|IntegerPrimesPackageType|)))

\end{chunk}

\subsection{IntegerRetractions}
\index[pkg]{IntegerRetractions!Domain}
\index[pkg]{Domain!IntegerRetractions}
\index[pkg]{INTRET}
\begin{chunk}{defclass IntegerRetractionsType}
(defclass |IntegerRetractionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IntegerRetractions")
   (marker :initform 'package)
   (abbreviation :initform 'INTRET)
   (comment :initform (list
     "Provides integer testing and retraction functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegerRetractions|
  (progn
    (push '|IntegerRetractions| *Packages*)
    (make-instance '|IntegerRetractionsType|)))

\end{chunk}

\subsection{IntegerRoots}
\index[pkg]{IntegerRoots!Domain}
\index[pkg]{Domain!IntegerRoots}
\index[pkg]{IROOT}
\begin{chunk}{defclass IntegerRootsType}
(defclass |IntegerRootsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IntegerRoots")
   (marker :initform 'package)
   (abbreviation :initform 'IROOT)
   (comment :initform (list
     "The IntegerRoots package computes square roots and"
     "nth roots of integers efficiently."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegerRoots|
  (progn
    (push '|IntegerRoots| *Packages*)
    (make-instance '|IntegerRootsType|)))

\end{chunk}

\subsection{IntegerSolveLinearPolynomialEquation}
\index[pkg]{IntegerSolveLinearPolynomialEquation!Domain}
\index[pkg]{Domain!IntegerSolveLinearPolynomialEquation}
\index[pkg]{INTSLPE}
\begin{chunk}{defclass IntegerSolveLinearPolynomialEquationType}
(defclass |IntegerSolveLinearPolynomialEquationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IntegerSolveLinearPolynomialEquation")
   (marker :initform 'package)
   (abbreviation :initform 'INTSLPE)
   (comment :initform (list
     "This package provides the implementation for the"
     "solveLinearPolynomialEquation"
     "operation over the integers. It uses a lifting technique"
     "from the package GenExEuclid"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegerSolveLinearPolynomialEquation|
  (progn
    (push '|IntegerSolveLinearPolynomialEquation| *Packages*)
    (make-instance '|IntegerSolveLinearPolynomialEquationType|)))

\end{chunk}

\subsection{IntegralBasisTools}
\index[pkg]{IntegralBasisTools!Domain}
\index[pkg]{Domain!IntegralBasisTools}
\index[pkg]{IBATOOL}
\begin{chunk}{defclass IntegralBasisToolsType}
(defclass |IntegralBasisToolsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IntegralBasisTools")
   (marker :initform 'package)
   (abbreviation :initform 'IBATOOL)
   (comment :initform (list
     "This package contains functions used in the packages"
     "FunctionFieldIntegralBasis and NumberFieldIntegralBasis."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegralBasisTools|
  (progn
    (push '|IntegralBasisTools| *Packages*)
    (make-instance '|IntegralBasisToolsType|)))

\end{chunk}

\subsection{IntegralBasisPolynomialTools}
\index[pkg]{IntegralBasisPolynomialTools!Domain}
\index[pkg]{Domain!IntegralBasisPolynomialTools}
\index[pkg]{IBPTOOLS}
\begin{chunk}{defclass IntegralBasisPolynomialToolsType}
(defclass |IntegralBasisPolynomialToolsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IntegralBasisPolynomialTools")
   (marker :initform 'package)
   (abbreviation :initform 'IBPTOOLS)
   (comment :initform (list
     "IntegralBasisPolynomialTools provides functions for mapping functions"
     "on the coefficients of univariate and bivariate polynomials."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegralBasisPolynomialTools|
  (progn
    (push '|IntegralBasisPolynomialTools| *Packages*)
    (make-instance '|IntegralBasisPolynomialToolsType|)))

\end{chunk}

\subsection{IntegrationResultFunctions2}
\index[pkg]{IntegrationResultFunctions2!Domain}
\index[pkg]{Domain!IntegrationResultFunctions2}
\index[pkg]{IR2}
\begin{chunk}{defclass IntegrationResultFunctions2Type}
(defclass |IntegrationResultFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IntegrationResultFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'IR2)
   (comment :initform (list
     "Internally used by the integration packages"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegrationResultFunctions2|
  (progn
    (push '|IntegrationResultFunctions2| *Packages*)
    (make-instance '|IntegrationResultFunctions2Type|)))

\end{chunk}

\subsection{IntegrationResultRFToFunction}
\index[pkg]{IntegrationResultRFToFunction!Domain}
\index[pkg]{Domain!IntegrationResultRFToFunction}
\index[pkg]{IRRF2F}
\begin{chunk}{defclass IntegrationResultRFToFunctionType}
(defclass |IntegrationResultRFToFunctionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IntegrationResultRFToFunction")
   (marker :initform 'package)
   (abbreviation :initform 'IRRF2F)
   (comment :initform (list
     "Conversion of integration results to top-level expressions."
     "This package allows a sum of logs over the roots of a polynomial"
     "to be expressed as explicit logarithms and arc tangents, provided"
     "that the indexing polynomial can be factored into quadratics."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegrationResultRFToFunction|
  (progn
    (push '|IntegrationResultRFToFunction| *Packages*)
    (make-instance '|IntegrationResultRFToFunctionType|)))

\end{chunk}

\subsection{IntegrationResultToFunction}
\index[pkg]{IntegrationResultToFunction!Domain}
\index[pkg]{Domain!IntegrationResultToFunction}
\index[pkg]{IR2F}
\begin{chunk}{defclass IntegrationResultToFunctionType}
(defclass |IntegrationResultToFunctionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IntegrationResultToFunction")
   (marker :initform 'package)
   (abbreviation :initform 'IR2F)
   (comment :initform (list
     "Conversion of integration results to top-level expressions"
     "This package allows a sum of logs over the roots of a polynomial"
     "to be expressed as explicit logarithms and arc tangents, provided"
     "that the indexing polynomial can be factored into quadratics."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegrationResultToFunction|
  (progn
    (push '|IntegrationResultToFunction| *Packages*)
    (make-instance '|IntegrationResultToFunctionType|)))

\end{chunk}

\subsection{IntegrationTools}
\index[pkg]{IntegrationTools!Domain}
\index[pkg]{Domain!IntegrationTools}
\index[pkg]{INTTOOLS}
\begin{chunk}{defclass IntegrationToolsType}
(defclass |IntegrationToolsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IntegrationTools")
   (marker :initform 'package)
   (abbreviation :initform 'INTTOOLS)
   (comment :initform (list
     "Tools for the integrator"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegrationTools|
  (progn
    (push '|IntegrationTools| *Packages*)
    (make-instance '|IntegrationToolsType|)))

\end{chunk}

\subsection{InternalPrintPackage}
\index[pkg]{InternalPrintPackage!Domain}
\index[pkg]{Domain!InternalPrintPackage}
\index[pkg]{IPRNTPK}
\begin{chunk}{defclass InternalPrintPackageType}
(defclass |InternalPrintPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InternalPrintPackage")
   (marker :initform 'package)
   (abbreviation :initform 'IPRNTPK)
   (comment :initform (list
     "A package to print strings without line-feed nor carriage-return."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InternalPrintPackage|
  (progn
    (push '|InternalPrintPackage| *Packages*)
    (make-instance '|InternalPrintPackageType|)))

\end{chunk}

\subsection{InternalRationalUnivariateRepresentationPackage}
\index[pkg]{InternalRationalUnivariateRepresentationPackage!Domain}
\index[pkg]{Domain!InternalRationalUnivariateRepresentationPackage}
\index[pkg]{IRURPK}
\begin{chunk}{defclass InternalRationalUnivariateRepresentationPackageType}
(defclass |InternalRationalUnivariateRepresentationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InternalRationalUnivariateRepresentationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'IRURPK)
   (comment :initform nil)
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InternalRationalUnivariateRepresentationPackage|
  (progn
    (push '|InternalRationalUnivariateRepresentationPackage| *Packages*)
    (make-instance '|InternalRationalUnivariateRepresentationPackageType|)))

\end{chunk}

\subsection{InterpolateFormsPackage}
\index[pkg]{InterpolateFormsPackage!Domain}
\index[pkg]{Domain!InterpolateFormsPackage}
\index[pkg]{INTFRSP}
\begin{chunk}{defclass InterpolateFormsPackageType}
(defclass |InterpolateFormsPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InterpolateFormsPackage")
   (marker :initform 'package)
   (abbreviation :initform 'INTFRSP)
   (comment :initform (list
     "The following is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InterpolateFormsPackage|
  (progn
    (push '|InterpolateFormsPackage| *Packages*)
    (make-instance '|InterpolateFormsPackageType|)))

\end{chunk}

\subsection{IntersectionDivisorPackage}
\index[pkg]{IntersectionDivisorPackage!Domain}
\index[pkg]{Domain!IntersectionDivisorPackage}
\index[pkg]{INTDIVP}
\begin{chunk}{defclass IntersectionDivisorPackageType}
(defclass |IntersectionDivisorPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IntersectionDivisorPackage")
   (marker :initform 'package)
   (abbreviation :initform 'INTDIVP)
   (comment :initform (list
     "The following is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntersectionDivisorPackage|
  (progn
    (push '|IntersectionDivisorPackage| *Packages*)
    (make-instance '|IntersectionDivisorPackageType|)))

\end{chunk}

\subsection{IrredPolyOverFiniteField}
\index[pkg]{IrredPolyOverFiniteField!Domain}
\index[pkg]{Domain!IrredPolyOverFiniteField}
\index[pkg]{IRREDFFX}
\begin{chunk}{defclass IrredPolyOverFiniteFieldType}
(defclass |IrredPolyOverFiniteFieldType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IrredPolyOverFiniteField")
   (marker :initform 'package)
   (abbreviation :initform 'IRREDFFX)
   (comment :initform (list
     "This package exports the function generateIrredPoly that computes"
     "a monic irreducible polynomial of degree n over a finite field."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IrredPolyOverFiniteField|
  (progn
    (push '|IrredPolyOverFiniteField| *Packages*)
    (make-instance '|IrredPolyOverFiniteFieldType|)))

\end{chunk}

\subsection{IrrRepSymNatPackage}
\index[pkg]{IrrRepSymNatPackage!Domain}
\index[pkg]{Domain!IrrRepSymNatPackage}
\index[pkg]{IRSN}
\begin{chunk}{defclass IrrRepSymNatPackageType}
(defclass |IrrRepSymNatPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IrrRepSymNatPackage")
   (marker :initform 'package)
   (abbreviation :initform 'IRSN)
   (comment :initform (list
     "IrrRepSymNatPackage contains functions for computing"
     "the ordinary irreducible representations of symmetric groups on"
     "n letters {1,2,...,n} in Young's natural form and their dimensions."
     "These representations can be labelled by number partitions of n,"
     "a weakly decreasing sequence of integers summing up to n, for"
     "example, [3,3,3,1] labels an irreducible representation for n equals 10."
     "Note that whenever a List Integer appears in a signature,"
     "a partition required."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IrrRepSymNatPackage|
  (progn
    (push '|IrrRepSymNatPackage| *Packages*)
    (make-instance '|IrrRepSymNatPackageType|)))

\end{chunk}

\subsection{InverseLaplaceTransform}
\index[pkg]{InverseLaplaceTransform!Domain}
\index[pkg]{Domain!InverseLaplaceTransform}
\index[pkg]{INVLAPLA}
\begin{chunk}{defclass InverseLaplaceTransformType}
(defclass |InverseLaplaceTransformType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InverseLaplaceTransform")
   (marker :initform 'package)
   (abbreviation :initform 'INVLAPLA)
   (comment :initform (list
     "This package computes the inverse Laplace Transform."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InverseLaplaceTransform|
  (progn
    (push '|InverseLaplaceTransform| *Packages*)
    (make-instance '|InverseLaplaceTransformType|)))

\end{chunk}

\section{K}

\subsection{KernelFunctions2}
\index[pkg]{KernelFunctions2!Domain}
\index[pkg]{Domain!KernelFunctions2}
\index[pkg]{KERNEL2}
\begin{chunk}{defclass KernelFunctions2Type}
(defclass |KernelFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "KernelFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'KERNEL2)
   (comment :initform (list
     "This package exports some auxiliary functions on kernels"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |KernelFunctions2|
  (progn
    (push '|KernelFunctions2| *Packages*)
    (make-instance '|KernelFunctions2Type|)))

\end{chunk}

\subsection{Kovacic}
\index[pkg]{Kovacic!Domain}
\index[pkg]{Domain!Kovacic}
\index[pkg]{KOVACIC}
\begin{chunk}{defclass KovacicType}
(defclass |KovacicType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "Kovacic")
   (marker :initform 'package)
   (abbreviation :initform 'KOVACIC)
   (comment :initform (list
     "Kovacic provides a modified Kovacic's algorithm for"
     "solving explicitely irreducible 2nd order linear ordinary"
     "differential equations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Kovacic|
  (progn
    (push '|Kovacic| *Packages*)
    (make-instance '|KovacicType|)))

\end{chunk}

\section{L}

\subsection{LaplaceTransform}
\index[pkg]{LaplaceTransform!Domain}
\index[pkg]{Domain!LaplaceTransform}
\index[pkg]{LAPLACE}
\begin{chunk}{defclass LaplaceTransformType}
(defclass |LaplaceTransformType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LaplaceTransform")
   (marker :initform 'package)
   (abbreviation :initform 'LAPLACE)
   (comment :initform (list
     "This package computes the forward Laplace Transform."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LaplaceTransform|
  (progn
    (push '|LaplaceTransform| *Packages*)
    (make-instance '|LaplaceTransformType|)))

\end{chunk}

\subsection{LazardSetSolvingPackage}
\index[pkg]{LazardSetSolvingPackage!Domain}
\index[pkg]{Domain!LazardSetSolvingPackage}
\index[pkg]{LAZM3PK}
\begin{chunk}{defclass LazardSetSolvingPackageType}
(defclass |LazardSetSolvingPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LazardSetSolvingPackage")
   (marker :initform 'package)
   (abbreviation :initform 'LAZM3PK)
   (comment :initform (list
     "A package for solving polynomial systems by means of Lazard triangular"
     "sets. This package provides two operations. One for solving in the sense"
     "of the regular zeros, and the other for solving in the sense of"
     "the Zariski closure. Both produce square-free regular sets."
     "Moreover, the decompositions do not contain any redundant component."
     "However, only zero-dimensional regular sets are normalized, since"
     "normalization may be time consumming in positive dimension."
     "The decomposition process is that of [2]."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LazardSetSolvingPackage|
  (progn
    (push '|LazardSetSolvingPackage| *Packages*)
    (make-instance '|LazardSetSolvingPackageType|)))

\end{chunk}

\subsection{LeadingCoefDetermination}
\index[pkg]{LeadingCoefDetermination!Domain}
\index[pkg]{Domain!LeadingCoefDetermination}
\index[pkg]{LEADCDET}
\begin{chunk}{defclass LeadingCoefDeterminationType}
(defclass |LeadingCoefDeterminationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LeadingCoefDetermination")
   (marker :initform 'package)
   (abbreviation :initform 'LEADCDET)
   (comment :initform (list
     "Package for leading coefficient determination in the lifting step."
     "Package working for every R euclidean with property 'F'."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LeadingCoefDetermination|
  (progn
    (push '|LeadingCoefDetermination| *Packages*)
    (make-instance '|LeadingCoefDeterminationType|)))

\end{chunk}

\subsection{LexTriangularPackage}
\index[pkg]{LexTriangularPackage!Domain}
\index[pkg]{Domain!LexTriangularPackage}
\index[pkg]{LEXTRIPK}
\begin{chunk}{defclass LexTriangularPackageType}
(defclass |LexTriangularPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LexTriangularPackage")
   (marker :initform 'package)
   (abbreviation :initform 'LEXTRIPK)
   (comment :initform (list
     "A package for solving polynomial systems with finitely many solutions."
     "The decompositions are given by means of regular triangular sets."
     "The computations use lexicographical Groebner bases."
     "The main operations are lexTriangular"
     "and squareFreeLexTriangular. The second one provide decompositions by"
     "means of square-free regular triangular sets."
     "Both are based on the lexTriangular method described in [1]."
     "They differ from the algorithm described in [2] by the fact that"
     "multiplicities of the roots are not kept."
     "With the squareFreeLexTriangular operation all multiciplities are removed."
     "With the other operation some multiciplities may remain. Both operations"
     "admit an optional argument to produce normalized triangular sets."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LexTriangularPackage|
  (progn
    (push '|LexTriangularPackage| *Packages*)
    (make-instance '|LexTriangularPackageType|)))

\end{chunk}

\subsection{LinearDependence}
\index[pkg]{LinearDependence!Domain}
\index[pkg]{Domain!LinearDependence}
\index[pkg]{LINDEP}
\begin{chunk}{defclass LinearDependenceType}
(defclass |LinearDependenceType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LinearDependence")
   (marker :initform 'package)
   (abbreviation :initform 'LINDEP)
   (comment :initform (list
     "Test for linear dependence."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LinearDependence|
  (progn
    (push '|LinearDependence| *Packages*)
    (make-instance '|LinearDependenceType|)))

\end{chunk}

\subsection{LinearOrdinaryDifferentialOperatorFactorizer}
\index[pkg]{LinearOrdinaryDifferentialOperatorFactorizer!Domain}
\index[pkg]{Domain!LinearOrdinaryDifferentialOperatorFactorizer}
\index[pkg]{LODOF}
\begin{chunk}{defclass LinearOrdinaryDifferentialOperatorFactorizerType}
(defclass |LinearOrdinaryDifferentialOperatorFactorizerType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LinearOrdinaryDifferentialOperatorFactorizer")
   (marker :initform 'package)
   (abbreviation :initform 'LODOF)
   (comment :initform (list
     "LinearOrdinaryDifferentialOperatorFactorizer provides a"
     "factorizer for linear ordinary differential operators whose coefficients"
     "are rational functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LinearOrdinaryDifferentialOperatorFactorizer|
  (progn
    (push '|LinearOrdinaryDifferentialOperatorFactorizer| *Packages*)
    (make-instance '|LinearOrdinaryDifferentialOperatorFactorizerType|)))

\end{chunk}

\subsection{LinearOrdinaryDifferentialOperatorsOps}
\index[pkg]{LinearOrdinaryDifferentialOperatorsOps!Domain}
\index[pkg]{Domain!LinearOrdinaryDifferentialOperatorsOps}
\index[pkg]{LODOOPS}
\begin{chunk}{defclass LinearOrdinaryDifferentialOperatorsOpsType}
(defclass |LinearOrdinaryDifferentialOperatorsOpsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LinearOrdinaryDifferentialOperatorsOps")
   (marker :initform 'package)
   (abbreviation :initform 'LODOOPS)
   (comment :initform (list
     "LinearOrdinaryDifferentialOperatorsOps provides symmetric"
     "products and sums for linear ordinary differential operators."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LinearOrdinaryDifferentialOperatorsOps|
  (progn
    (push '|LinearOrdinaryDifferentialOperatorsOps| *Packages*)
    (make-instance '|LinearOrdinaryDifferentialOperatorsOpsType|)))

\end{chunk}

\subsection{LinearPolynomialEquationByFractions}
\index[pkg]{LinearPolynomialEquationByFractions!Domain}
\index[pkg]{Domain!LinearPolynomialEquationByFractions}
\index[pkg]{LPEFRAC}
\begin{chunk}{defclass LinearPolynomialEquationByFractionsType}
(defclass |LinearPolynomialEquationByFractionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LinearPolynomialEquationByFractions")
   (marker :initform 'package)
   (abbreviation :initform 'LPEFRAC)
   (comment :initform (list
     "Given a PolynomialFactorizationExplicit ring, this package"
     "provides a defaulting rule for the solveLinearPolynomialEquation"
     "operation, by moving into the field of fractions, and solving it there"
     "via the multiEuclidean operation."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LinearPolynomialEquationByFractions|
  (progn
    (push '|LinearPolynomialEquationByFractions| *Packages*)
    (make-instance '|LinearPolynomialEquationByFractionsType|)))

\end{chunk}

\subsection{LinearSystemFromPowerSeriesPackage}
\index[pkg]{LinearSystemFromPowerSeriesPackage!Domain}
\index[pkg]{Domain!LinearSystemFromPowerSeriesPackage}
\index[pkg]{LISYSER}
\begin{chunk}{defclass LinearSystemFromPowerSeriesPackageType}
(defclass |LinearSystemFromPowerSeriesPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LinearSystemFromPowerSeriesPackage")
   (marker :initform 'package)
   (abbreviation :initform 'LISYSER)
   (comment :initform (list
     "Part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LinearSystemFromPowerSeriesPackage|
  (progn
    (push '|LinearSystemFromPowerSeriesPackage| *Packages*)
    (make-instance '|LinearSystemFromPowerSeriesPackageType|)))

\end{chunk}

\subsection{LinearSystemMatrixPackage}
\index[pkg]{LinearSystemMatrixPackage!Domain}
\index[pkg]{Domain!LinearSystemMatrixPackage}
\index[pkg]{LSMP}
\begin{chunk}{defclass LinearSystemMatrixPackageType}
(defclass |LinearSystemMatrixPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LinearSystemMatrixPackage")
   (marker :initform 'package)
   (abbreviation :initform 'LSMP)
   (comment :initform (list
     "This package solves linear system in the matrix form AX = B."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LinearSystemMatrixPackage|
  (progn
    (push '|LinearSystemMatrixPackage| *Packages*)
    (make-instance '|LinearSystemMatrixPackageType|)))

\end{chunk}

\subsection{LinearSystemMatrixPackage1}
\index[pkg]{LinearSystemMatrixPackage1!Domain}
\index[pkg]{Domain!LinearSystemMatrixPackage1}
\index[pkg]{LSMP1}
\begin{chunk}{defclass LinearSystemMatrixPackage1Type}
(defclass |LinearSystemMatrixPackage1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LinearSystemMatrixPackage1")
   (marker :initform 'package)
   (abbreviation :initform 'LSMP1)
   (comment :initform (list
     "This package solves linear system in the matrix form AX = B."
     "It is essentially a particular instantiation of the package"
     "LinearSystemMatrixPackage for Matrix and Vector. This"
     "package's existence makes it easier to use solve in the"
     "AXIOM interpreter."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LinearSystemMatrixPackage1|
  (progn
    (push '|LinearSystemMatrixPackage1| *Packages*)
    (make-instance '|LinearSystemMatrixPackage1Type|)))

\end{chunk}

\subsection{LinearSystemPolynomialPackage}
\index[pkg]{LinearSystemPolynomialPackage!Domain}
\index[pkg]{Domain!LinearSystemPolynomialPackage}
\index[pkg]{LSPP}
\begin{chunk}{defclass LinearSystemPolynomialPackageType}
(defclass |LinearSystemPolynomialPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LinearSystemPolynomialPackage")
   (marker :initform 'package)
   (abbreviation :initform 'LSPP)
   (comment :initform (list
     "This package finds the solutions of linear systems presented as a"
     "list of polynomials."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LinearSystemPolynomialPackage|
  (progn
    (push '|LinearSystemPolynomialPackage| *Packages*)
    (make-instance '|LinearSystemPolynomialPackageType|)))

\end{chunk}

\subsection{LinGroebnerPackage}
\index[pkg]{LinGroebnerPackage!Domain}
\index[pkg]{Domain!LinGroebnerPackage}
\index[pkg]{LGROBP}
\begin{chunk}{defclass LinGroebnerPackageType}
(defclass |LinGroebnerPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LinGroebnerPackage")
   (marker :initform 'package)
   (abbreviation :initform 'LGROBP)
   (comment :initform (list
     "Given a Groebner basis B with respect to the total degree ordering for"
     "a zero-dimensional ideal I, compute"
     "a Groebner basis with respect to the lexicographical ordering by using"
     "linear algebra."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LinGroebnerPackage|
  (progn
    (push '|LinGroebnerPackage| *Packages*)
    (make-instance '|LinGroebnerPackageType|)))

\end{chunk}

\subsection{LinesOpPack}
\index[pkg]{LinesOpPack!Domain}
\index[pkg]{Domain!LinesOpPack}
\index[pkg]{LOP}
\begin{chunk}{defclass LinesOpPackType}
(defclass |LinesOpPackType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LinesOpPack")
   (marker :initform 'package)
   (abbreviation :initform 'LOP)
   (comment :initform (list
     "A package that exports several linear algebra operations over lines"
     "of matrices. Part of the PAFF package."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LinesOpPack|
  (progn
    (push '|LinesOpPack| *Packages*)
    (make-instance '|LinesOpPackType|)))

\end{chunk}

\subsection{LiouvillianFunction}
\index[pkg]{LiouvillianFunction!Domain}
\index[pkg]{Domain!LiouvillianFunction}
\index[pkg]{LF}
\begin{chunk}{defclass LiouvillianFunctionType}
(defclass |LiouvillianFunctionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LiouvillianFunction")
   (marker :initform 'package)
   (abbreviation :initform 'LF)
   (comment :initform (list
     "This package provides liouvillian functions over an integral domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LiouvillianFunction|
  (progn
    (push '|LiouvillianFunction| *Packages*)
    (make-instance '|LiouvillianFunctionType|)))

\end{chunk}

\subsection{ListFunctions2}
\index[pkg]{ListFunctions2!Domain}
\index[pkg]{Domain!ListFunctions2}
\index[pkg]{LIST2}
\begin{chunk}{defclass ListFunctions2Type}
(defclass |ListFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ListFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'LIST2)
   (comment :initform (list
     "ListFunctions2 implements utility functions that"
     "operate on two kinds of lists, each with a possibly different"
     "type of element."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ListFunctions2|
  (progn
    (push '|ListFunctions2| *Packages*)
    (make-instance '|ListFunctions2Type|)))

\end{chunk}

\subsection{ListFunctions3}
\index[pkg]{ListFunctions3!Domain}
\index[pkg]{Domain!ListFunctions3}
\index[pkg]{LIST3}
\begin{chunk}{defclass ListFunctions3Type}
(defclass |ListFunctions3Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ListFunctions3")
   (marker :initform 'package)
   (abbreviation :initform 'LIST3)
   (comment :initform (list
     "ListFunctions3 implements utility functions that"
     "operate on three kinds of lists, each with a possibly different"
     "type of element."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ListFunctions3|
  (progn
    (push '|ListFunctions3| *Packages*)
    (make-instance '|ListFunctions3Type|)))

\end{chunk}

\subsection{ListToMap}
\index[pkg]{ListToMap!Domain}
\index[pkg]{Domain!ListToMap}
\index[pkg]{LIST2MAP}
\begin{chunk}{defclass ListToMapType}
(defclass |ListToMapType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ListToMap")
   (marker :initform 'package)
   (abbreviation :initform 'LIST2MAP)
   (comment :initform (list
     "ListToMap allows mappings to be described by a pair of"
     "lists of equal lengths.  The image of an element x,"
     "which appears in position n in the first list, is then"
     "the nth element of the second list.  A default value or"
     "default function can be specified to be used when x"
     "does not appear in the first list.  In the absence of defaults,"
     "an error will occur in that case."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ListToMap|
  (progn
    (push '|ListToMap| *Packages*)
    (make-instance '|ListToMapType|)))

\end{chunk}

\subsection{LocalParametrizationOfSimplePointPackage}
\index[pkg]{LocalParametrizationOfSimplePointPackage!Domain}
\index[pkg]{Domain!LocalParametrizationOfSimplePointPackage}
\index[pkg]{LPARSPT}
\begin{chunk}{defclass LocalParametrizationOfSimplePointPackageType}
(defclass |LocalParametrizationOfSimplePointPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LocalParametrizationOfSimplePointPackage")
   (marker :initform 'package)
   (abbreviation :initform 'LPARSPT)
   (comment :initform (list
     "This package is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LocalParametrizationOfSimplePointPackage|
  (progn
    (push '|LocalParametrizationOfSimplePointPackage| *Packages*)
    (make-instance '|LocalParametrizationOfSimplePointPackageType|)))

\end{chunk}

\section{M}

\subsection{MakeBinaryCompiledFunction}
\index[pkg]{MakeBinaryCompiledFunction!Domain}
\index[pkg]{Domain!MakeBinaryCompiledFunction}
\index[pkg]{MKBCFUNC}
\begin{chunk}{defclass MakeBinaryCompiledFunctionType}
(defclass |MakeBinaryCompiledFunctionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MakeBinaryCompiledFunction")
   (marker :initform 'package)
   (abbreviation :initform 'MKBCFUNC)
   (comment :initform (list
     "Tools and transforms for making compiled functions from"
     "top-level expressions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MakeBinaryCompiledFunction|
  (progn
    (push '|MakeBinaryCompiledFunction| *Packages*)
    (make-instance '|MakeBinaryCompiledFunctionType|)))

\end{chunk}

\subsection{MakeFloatCompiledFunction}
\index[pkg]{MakeFloatCompiledFunction!Domain}
\index[pkg]{Domain!MakeFloatCompiledFunction}
\index[pkg]{MKFLCFN}
\begin{chunk}{defclass MakeFloatCompiledFunctionType}
(defclass |MakeFloatCompiledFunctionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MakeFloatCompiledFunction")
   (marker :initform 'package)
   (abbreviation :initform 'MKFLCFN)
   (comment :initform (list
     "Tools for making compiled functions from top-level expressions"
     "MakeFloatCompiledFunction transforms top-level objects into"
     "compiled Lisp functions whose arguments are Lisp floats."
     "This by-passes the Axiom compiler and interpreter,"
     "thereby gaining several orders of magnitude."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MakeFloatCompiledFunction|
  (progn
    (push '|MakeFloatCompiledFunction| *Packages*)
    (make-instance '|MakeFloatCompiledFunctionType|)))

\end{chunk}

\subsection{MakeFunction}
\index[pkg]{MakeFunction!Domain}
\index[pkg]{Domain!MakeFunction}
\index[pkg]{MKFUNC}
\begin{chunk}{defclass MakeFunctionType}
(defclass |MakeFunctionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MakeFunction")
   (marker :initform 'package)
   (abbreviation :initform 'MKFUNC)
   (comment :initform (list
     "Tools for making interpreter functions from top-level expressions"
     "Transforms top-level objects into interpreter functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MakeFunction|
  (progn
    (push '|MakeFunction| *Packages*)
    (make-instance '|MakeFunctionType|)))

\end{chunk}

\subsection{MakeRecord}
\index[pkg]{MakeRecord!Domain}
\index[pkg]{Domain!MakeRecord}
\index[pkg]{MKRECORD}
\begin{chunk}{defclass MakeRecordType}
(defclass |MakeRecordType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MakeRecord")
   (marker :initform 'package)
   (abbreviation :initform 'MKRECORD)
   (comment :initform (list
     "MakeRecord is used internally by the interpreter to create record"
     "types which are used for doing parallel iterations on streams."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MakeRecord|
  (progn
    (push '|MakeRecord| *Packages*)
    (make-instance '|MakeRecordType|)))

\end{chunk}

\subsection{MakeUnaryCompiledFunction}
\index[pkg]{MakeUnaryCompiledFunction!Domain}
\index[pkg]{Domain!MakeUnaryCompiledFunction}
\index[pkg]{MKUCFUNC}
\begin{chunk}{defclass MakeUnaryCompiledFunctionType}
(defclass |MakeUnaryCompiledFunctionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MakeUnaryCompiledFunction")
   (marker :initform 'package)
   (abbreviation :initform 'MKUCFUNC)
   (comment :initform (list
     "Tools for making compiled functions from top-level expressions"
     "Transforms top-level objects into compiled functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MakeUnaryCompiledFunction|
  (progn
    (push '|MakeUnaryCompiledFunction| *Packages*)
    (make-instance '|MakeUnaryCompiledFunctionType|)))

\end{chunk}

\subsection{MappingPackageInternalHacks1}
\index[pkg]{MappingPackageInternalHacks1!Domain}
\index[pkg]{Domain!MappingPackageInternalHacks1}
\index[pkg]{MAPHACK1}
\begin{chunk}{defclass MappingPackageInternalHacks1Type}
(defclass |MappingPackageInternalHacks1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MappingPackageInternalHacks1")
   (marker :initform 'package)
   (abbreviation :initform 'MAPHACK1)
   (comment :initform (list
     "Various Currying operations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MappingPackageInternalHacks1|
  (progn
    (push '|MappingPackageInternalHacks1| *Packages*)
    (make-instance '|MappingPackageInternalHacks1Type|)))

\end{chunk}

\subsection{MappingPackageInternalHacks2}
\index[pkg]{MappingPackageInternalHacks2!Domain}
\index[pkg]{Domain!MappingPackageInternalHacks2}
\index[pkg]{MAPHACK2}
\begin{chunk}{defclass MappingPackageInternalHacks2Type}
(defclass |MappingPackageInternalHacks2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MappingPackageInternalHacks2")
   (marker :initform 'package)
   (abbreviation :initform 'MAPHACK2)
   (comment :initform (list
     "Various Currying operations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MappingPackageInternalHacks2|
  (progn
    (push '|MappingPackageInternalHacks2| *Packages*)
    (make-instance '|MappingPackageInternalHacks2Type|)))

\end{chunk}

\subsection{MappingPackageInternalHacks3}
\index[pkg]{MappingPackageInternalHacks3!Domain}
\index[pkg]{Domain!MappingPackageInternalHacks3}
\index[pkg]{MAPHACK3}
\begin{chunk}{defclass MappingPackageInternalHacks3Type}
(defclass |MappingPackageInternalHacks3Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MappingPackageInternalHacks3")
   (marker :initform 'package)
   (abbreviation :initform 'MAPHACK3)
   (comment :initform (list
     "Various Currying operations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MappingPackageInternalHacks3|
  (progn
    (push '|MappingPackageInternalHacks3| *Packages*)
    (make-instance '|MappingPackageInternalHacks3Type|)))

\end{chunk}

\subsection{MappingPackage1}
\index[pkg]{MappingPackage1!Domain}
\index[pkg]{Domain!MappingPackage1}
\index[pkg]{MAPPKG1}
\begin{chunk}{defclass MappingPackage1Type}
(defclass |MappingPackage1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MappingPackage1")
   (marker :initform 'package)
   (abbreviation :initform 'MAPPKG1)
   (comment :initform (list
     "Various Currying operations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MappingPackage1|
  (progn
    (push '|MappingPackage1| *Packages*)
    (make-instance '|MappingPackage1Type|)))

\end{chunk}

\subsection{MappingPackage2}
\index[pkg]{MappingPackage2!Domain}
\index[pkg]{Domain!MappingPackage2}
\index[pkg]{MAPPKG2}
\begin{chunk}{defclass MappingPackage2Type}
(defclass |MappingPackage2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MappingPackage2")
   (marker :initform 'package)
   (abbreviation :initform 'MAPPKG2)
   (comment :initform (list
     "Various Currying operations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MappingPackage2|
  (progn
    (push '|MappingPackage2| *Packages*)
    (make-instance '|MappingPackage2Type|)))

\end{chunk}

\subsection{MappingPackage3}
\index[pkg]{MappingPackage3!Domain}
\index[pkg]{Domain!MappingPackage3}
\index[pkg]{MAPPKG3}
\begin{chunk}{defclass MappingPackage3Type}
(defclass |MappingPackage3Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MappingPackage3")
   (marker :initform 'package)
   (abbreviation :initform 'MAPPKG3)
   (comment :initform (list
     "Various Currying operations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MappingPackage3|
  (progn
    (push '|MappingPackage3| *Packages*)
    (make-instance '|MappingPackage3Type|)))

\end{chunk}

\subsection{MappingPackage4}
\index[pkg]{MappingPackage4!Domain}
\index[pkg]{Domain!MappingPackage4}
\index[pkg]{MAPPKG4}
\begin{chunk}{defclass MappingPackage4Type}
(defclass |MappingPackage4Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MappingPackage4")
   (marker :initform 'package)
   (abbreviation :initform 'MAPPKG4)
   (comment :initform (list
     "Functional Composition."
     "Given functions f and g, returns the applicable closure"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MappingPackage4|
  (progn
    (push '|MappingPackage4| *Packages*)
    (make-instance '|MappingPackage4Type|)))

\end{chunk}

\subsection{MatrixCategoryFunctions2}
\index[pkg]{MatrixCategoryFunctions2!Domain}
\index[pkg]{Domain!MatrixCategoryFunctions2}
\index[pkg]{MATCAT2}
\begin{chunk}{defclass MatrixCategoryFunctions2Type}
(defclass |MatrixCategoryFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MatrixCategoryFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'MATCAT2)
   (comment :initform (list
     "MatrixCategoryFunctions2 provides functions between two matrix"
     "domains.  The functions provided are map and reduce."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MatrixCategoryFunctions2|
  (progn
    (push '|MatrixCategoryFunctions2| *Packages*)
    (make-instance '|MatrixCategoryFunctions2Type|)))

\end{chunk}

\subsection{MatrixCommonDenominator}
\index[pkg]{MatrixCommonDenominator!Domain}
\index[pkg]{Domain!MatrixCommonDenominator}
\index[pkg]{MCDEN}
\begin{chunk}{defclass MatrixCommonDenominatorType}
(defclass |MatrixCommonDenominatorType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MatrixCommonDenominator")
   (marker :initform 'package)
   (abbreviation :initform 'MCDEN)
   (comment :initform (list
     "MatrixCommonDenominator provides functions to"
     "compute the common denominator of a matrix of elements of the"
     "quotient field of an integral domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MatrixCommonDenominator|
  (progn
    (push '|MatrixCommonDenominator| *Packages*)
    (make-instance '|MatrixCommonDenominatorType|)))

\end{chunk}

\subsection{MatrixLinearAlgebraFunctions}
\index[pkg]{MatrixLinearAlgebraFunctions!Domain}
\index[pkg]{Domain!MatrixLinearAlgebraFunctions}
\index[pkg]{MATLIN}
\begin{chunk}{defclass MatrixLinearAlgebraFunctionsType}
(defclass |MatrixLinearAlgebraFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MatrixLinearAlgebraFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'MATLIN)
   (comment :initform (list
     "MatrixLinearAlgebraFunctions provides functions to compute"
     "inverses and canonical forms."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MatrixLinearAlgebraFunctions|
  (progn
    (push '|MatrixLinearAlgebraFunctions| *Packages*)
    (make-instance '|MatrixLinearAlgebraFunctionsType|)))

\end{chunk}

\subsection{MatrixManipulation}
\index[pkg]{MatrixManipulation!Domain}
\index[pkg]{Domain!MatrixManipulation}
\index[pkg]{MAMA}
\begin{chunk}{defclass MatrixManipulationType}
(defclass |MatrixManipulationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MatrixManipulation")
   (marker :initform 'package)
   (abbreviation :initform 'MAMA)
   (comment :initform (list
     "Some functions for manipulating (dense) matrices."
     "Supported are various kinds of slicing, splitting and stacking of"
     "matrices. The functions resemble operations often used in numerical"
     "linear algebra algorithms."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MatrixManipulation|
  (progn
    (push '|MatrixManipulation| *Packages*)
    (make-instance '|MatrixManipulationType|)))

\end{chunk}

\subsection{MergeThing}
\index[pkg]{MergeThing!Domain}
\index[pkg]{Domain!MergeThing}
\index[pkg]{MTHING}
\begin{chunk}{defclass MergeThingType}
(defclass |MergeThingType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MergeThing")
   (marker :initform 'package)
   (abbreviation :initform 'MTHING)
   (comment :initform (list
     "This package exports tools for merging lists"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MergeThing|
  (progn
    (push '|MergeThing| *Packages*)
    (make-instance '|MergeThingType|)))

\end{chunk}

\subsection{MeshCreationRoutinesForThreeDimensions}
\index[pkg]{MeshCreationRoutinesForThreeDimensions!Domain}
\index[pkg]{Domain!MeshCreationRoutinesForThreeDimensions}
\index[pkg]{MESH}
\begin{chunk}{defclass MeshCreationRoutinesForThreeDimensionsType}
(defclass |MeshCreationRoutinesForThreeDimensionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MeshCreationRoutinesForThreeDimensions")
   (marker :initform 'package)
   (abbreviation :initform 'MESH)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MeshCreationRoutinesForThreeDimensions|
  (progn
    (push '|MeshCreationRoutinesForThreeDimensions| *Packages*)
    (make-instance '|MeshCreationRoutinesForThreeDimensionsType|)))

\end{chunk}

\subsection{ModularDistinctDegreeFactorizer}
\index[pkg]{ModularDistinctDegreeFactorizer!Domain}
\index[pkg]{Domain!ModularDistinctDegreeFactorizer}
\index[pkg]{MDDFACT}
\begin{chunk}{defclass ModularDistinctDegreeFactorizerType}
(defclass |ModularDistinctDegreeFactorizerType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ModularDistinctDegreeFactorizer")
   (marker :initform 'package)
   (abbreviation :initform 'MDDFACT)
   (comment :initform (list
     "This package supports factorization and gcds"
     "of univariate polynomials over the integers modulo different"
     "primes. The inputs are given as polynomials over the integers"
     "with the prime passed explicitly as an extra argument."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ModularDistinctDegreeFactorizer|
  (progn
    (push '|ModularDistinctDegreeFactorizer| *Packages*)
    (make-instance '|ModularDistinctDegreeFactorizerType|)))

\end{chunk}

\subsection{ModularHermitianRowReduction}
\index[pkg]{ModularHermitianRowReduction!Domain}
\index[pkg]{Domain!ModularHermitianRowReduction}
\index[pkg]{MHROWRED}
\begin{chunk}{defclass ModularHermitianRowReductionType}
(defclass |ModularHermitianRowReductionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ModularHermitianRowReduction")
   (marker :initform 'package)
   (abbreviation :initform 'MHROWRED)
   (comment :initform (list
     "Modular hermitian row reduction."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ModularHermitianRowReduction|
  (progn
    (push '|ModularHermitianRowReduction| *Packages*)
    (make-instance '|ModularHermitianRowReductionType|)))

\end{chunk}

\subsection{MonoidRingFunctions2}
\index[pkg]{MonoidRingFunctions2!Domain}
\index[pkg]{Domain!MonoidRingFunctions2}
\index[pkg]{MRF2}
\begin{chunk}{defclass MonoidRingFunctions2Type}
(defclass |MonoidRingFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MonoidRingFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'MRF2)
   (comment :initform (list
     "MonoidRingFunctions2 implements functions between"
     "two monoid rings defined with the same monoid over different rings."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MonoidRingFunctions2|
  (progn
    (push '|MonoidRingFunctions2| *Packages*)
    (make-instance '|MonoidRingFunctions2Type|)))

\end{chunk}

\subsection{MonomialExtensionTools}
\index[pkg]{MonomialExtensionTools!Domain}
\index[pkg]{Domain!MonomialExtensionTools}
\index[pkg]{MONOTOOL}
\begin{chunk}{defclass MonomialExtensionToolsType}
(defclass |MonomialExtensionToolsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MonomialExtensionTools")
   (marker :initform 'package)
   (abbreviation :initform 'MONOTOOL)
   (comment :initform (list
     "Tools for handling monomial extensions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MonomialExtensionTools|
  (progn
    (push '|MonomialExtensionTools| *Packages*)
    (make-instance '|MonomialExtensionToolsType|)))

\end{chunk}

\subsection{MoreSystemCommands}
\index[pkg]{MoreSystemCommands!Domain}
\index[pkg]{Domain!MoreSystemCommands}
\index[pkg]{MSYSCMD}
\begin{chunk}{defclass MoreSystemCommandsType}
(defclass |MoreSystemCommandsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MoreSystemCommands")
   (marker :initform 'package)
   (abbreviation :initform 'MSYSCMD)
   (comment :initform (list
     "MoreSystemCommands implements an interface with the"
     "system command facility. These are the commands that are issued"
     "from source files or the system interpreter and they start with"
     "a close parenthesis, for example, the 'what' commands."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MoreSystemCommands|
  (progn
    (push '|MoreSystemCommands| *Packages*)
    (make-instance '|MoreSystemCommandsType|)))

\end{chunk}

\subsection{MPolyCatPolyFactorizer}
\index[pkg]{MPolyCatPolyFactorizer!Domain}
\index[pkg]{Domain!MPolyCatPolyFactorizer}
\index[pkg]{MPCPF}
\begin{chunk}{defclass MPolyCatPolyFactorizerType}
(defclass |MPolyCatPolyFactorizerType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MPolyCatPolyFactorizer")
   (marker :initform 'package)
   (abbreviation :initform 'MPCPF)
   (comment :initform (list
     "This package exports a factor operation for multivariate polynomials"
     "with coefficients which are polynomials over"
     "some ring R over which we can factor. It is used internally by packages"
     "such as the solve package which need to work with polynomials in a specific"
     "set of variables with coefficients which are polynomials in all the other"
     "variables."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MPolyCatPolyFactorizer|
  (progn
    (push '|MPolyCatPolyFactorizer| *Packages*)
    (make-instance '|MPolyCatPolyFactorizerType|)))

\end{chunk}

\subsection{MPolyCatRationalFunctionFactorizer}
\index[pkg]{MPolyCatRationalFunctionFactorizer!Domain}
\index[pkg]{Domain!MPolyCatRationalFunctionFactorizer}
\index[pkg]{MPRFF}
\begin{chunk}{defclass MPolyCatRationalFunctionFactorizerType}
(defclass |MPolyCatRationalFunctionFactorizerType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MPolyCatRationalFunctionFactorizer")
   (marker :initform 'package)
   (abbreviation :initform 'MPRFF)
   (comment :initform (list
     "This package exports a factor operation for multivariate polynomials"
     "with coefficients which are rational functions over"
     "some ring R over which we can factor. It is used internally by packages"
     "such as primary decomposition which need to work with polynomials"
     "with rational function coefficients, themselves fractions of"
     "polynomials."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MPolyCatRationalFunctionFactorizer|
  (progn
    (push '|MPolyCatRationalFunctionFactorizer| *Packages*)
    (make-instance '|MPolyCatRationalFunctionFactorizerType|)))

\end{chunk}

\subsection{MPolyCatFunctions2}
\index[pkg]{MPolyCatFunctions2!Domain}
\index[pkg]{Domain!MPolyCatFunctions2}
\index[pkg]{MPC2}
\begin{chunk}{defclass MPolyCatFunctions2Type}
(defclass |MPolyCatFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MPolyCatFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'MPC2)
   (comment :initform (list
     "Utilities for MPolyCat"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MPolyCatFunctions2|
  (progn
    (push '|MPolyCatFunctions2| *Packages*)
    (make-instance '|MPolyCatFunctions2Type|)))

\end{chunk}

\subsection{MPolyCatFunctions3}
\index[pkg]{MPolyCatFunctions3!Domain}
\index[pkg]{Domain!MPolyCatFunctions3}
\index[pkg]{MPC3}
\begin{chunk}{defclass MPolyCatFunctions3Type}
(defclass |MPolyCatFunctions3Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MPolyCatFunctions3")
   (marker :initform 'package)
   (abbreviation :initform 'MPC3)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MPolyCatFunctions3|
  (progn
    (push '|MPolyCatFunctions3| *Packages*)
    (make-instance '|MPolyCatFunctions3Type|)))

\end{chunk}

\subsection{MRationalFactorize}
\index[pkg]{MRationalFactorize!Domain}
\index[pkg]{Domain!MRationalFactorize}
\index[pkg]{MRATFAC}
\begin{chunk}{defclass MRationalFactorizeType}
(defclass |MRationalFactorizeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MRationalFactorize")
   (marker :initform 'package)
   (abbreviation :initform 'MRATFAC)
   (comment :initform (list
     "MRationalFactorize contains the factor function for multivariate"
     "polynomials over the quotient field of a ring R such that the package"
     "MultivariateFactorize can factor multivariate polynomials over R."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MRationalFactorize|
  (progn
    (push '|MRationalFactorize| *Packages*)
    (make-instance '|MRationalFactorizeType|)))

\end{chunk}

\subsection{MultFiniteFactorize}
\index[pkg]{MultFiniteFactorize!Domain}
\index[pkg]{Domain!MultFiniteFactorize}
\index[pkg]{MFINFACT}
\begin{chunk}{defclass MultFiniteFactorizeType}
(defclass |MultFiniteFactorizeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MultFiniteFactorize")
   (marker :initform 'package)
   (abbreviation :initform 'MFINFACT)
   (comment :initform (list
     "Package for factorization of multivariate polynomials over finite fields."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MultFiniteFactorize|
  (progn
    (push '|MultFiniteFactorize| *Packages*)
    (make-instance '|MultFiniteFactorizeType|)))

\end{chunk}

\subsection{MultipleMap}
\index[pkg]{MultipleMap!Domain}
\index[pkg]{Domain!MultipleMap}
\index[pkg]{MMAP}
\begin{chunk}{defclass MultipleMapType}
(defclass |MultipleMapType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MultipleMap")
   (marker :initform 'package)
   (abbreviation :initform 'MMAP)
   (comment :initform (list
     "Lifting of a map through 2 levels of polynomials"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MultipleMap|
  (progn
    (push '|MultipleMap| *Packages*)
    (make-instance '|MultipleMapType|)))

\end{chunk}

\subsection{MultiVariableCalculusFunctions}
\index[pkg]{MultiVariableCalculusFunctions!Domain}
\index[pkg]{Domain!MultiVariableCalculusFunctions}
\index[pkg]{MCALCFN}
\begin{chunk}{defclass MultiVariableCalculusFunctionsType}
(defclass |MultiVariableCalculusFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MultiVariableCalculusFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'MCALCFN)
   (comment :initform (list
     "MultiVariableCalculusFunctions Package provides several"
     "functions for multivariable calculus."
     "These include gradient, hessian and jacobian, divergence and laplacian."
     "Various forms for banded and sparse storage of matrices are included."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MultiVariableCalculusFunctions|
  (progn
    (push '|MultiVariableCalculusFunctions| *Packages*)
    (make-instance '|MultiVariableCalculusFunctionsType|)))

\end{chunk}

\subsection{MultivariateFactorize}
\index[pkg]{MultivariateFactorize!Domain}
\index[pkg]{Domain!MultivariateFactorize}
\index[pkg]{MULTFACT}
\begin{chunk}{defclass MultivariateFactorizeType}
(defclass |MultivariateFactorizeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MultivariateFactorize")
   (marker :initform 'package)
   (abbreviation :initform 'MULTFACT)
   (comment :initform (list
     "This is the top level package for doing multivariate factorization"
     "over basic domains like Integer or Fraction Integer."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MultivariateFactorize|
  (progn
    (push '|MultivariateFactorize| *Packages*)
    (make-instance '|MultivariateFactorizeType|)))

\end{chunk}

\subsection{MultivariateLifting}
\index[pkg]{MultivariateLifting!Domain}
\index[pkg]{Domain!MultivariateLifting}
\index[pkg]{MLIFT}
\begin{chunk}{defclass MultivariateLiftingType}
(defclass |MultivariateLiftingType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MultivariateLifting")
   (marker :initform 'package)
   (abbreviation :initform 'MLIFT)
   (comment :initform (list
     "This package provides the functions for the multivariate 'lifting', using"
     "an algorithm of Paul Wang."
     "This package will work for every euclidean domain R which has property"
     "F, there exists a factor operation in R[x]."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MultivariateLifting|
  (progn
    (push '|MultivariateLifting| *Packages*)
    (make-instance '|MultivariateLiftingType|)))

\end{chunk}

\subsection{MultivariateSquareFree}
\index[pkg]{MultivariateSquareFree!Domain}
\index[pkg]{Domain!MultivariateSquareFree}
\index[pkg]{MULTSQFR}
\begin{chunk}{defclass MultivariateSquareFreeType}
(defclass |MultivariateSquareFreeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MultivariateSquareFree")
   (marker :initform 'package)
   (abbreviation :initform 'MULTSQFR)
   (comment :initform (list
     "This package provides the functions for the computation of the square"
     "free decomposition of a multivariate polynomial."
     "It uses the package GenExEuclid for the resolution of"
     "the equation Af + Bg = h and its generalization to n polynomials"
     "over an integral domain and the package MultivariateLifting"
     "for the 'multivariate' lifting."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MultivariateSquareFree|
  (progn
    (push '|MultivariateSquareFree| *Packages*)
    (make-instance '|MultivariateSquareFreeType|)))

\end{chunk}

\section{N}

\subsection{NagEigenPackage}
\index[pkg]{NagEigenPackage!Domain}
\index[pkg]{Domain!NagEigenPackage}
\index[pkg]{NAGF02}
\begin{chunk}{defclass NagEigenPackageType}
(defclass |NagEigenPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NagEigenPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NAGF02)
   (comment :initform (list
     "This package uses the NAG Library to compute"
     "     eigenvalues and eigenvectors of a matrix"
     "     eigenvalues and eigenvectors of generalized matrix"
     "eigenvalue problems"
     "     singular values and singular vectors of a matrix."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NagEigenPackage|
  (progn
    (push '|NagEigenPackage| *Packages*)
    (make-instance '|NagEigenPackageType|)))

\end{chunk}

\subsection{NagFittingPackage}
\index[pkg]{NagFittingPackage!Domain}
\index[pkg]{Domain!NagFittingPackage}
\index[pkg]{NAGE02}
\begin{chunk}{defclass NagFittingPackageType}
(defclass |NagFittingPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NagFittingPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NAGE02)
   (comment :initform (list
     "This package uses the NAG Library to find a"
     "function which approximates a set of data points. Typically the"
     "data contain random errors, as of experimental measurement, which"
     "need to be smoothed out. To seek an approximation to the data, it"
     "is first necessary to specify for the approximating function a"
     "mathematical form (a polynomial, for example) which contains a"
     "number of unspecified coefficients: the appropriate fitting"
     "routine then derives for the coefficients the values which"
     "provide the best fit of that particular form. The package deals"
     "mainly with curve and surface fitting (fitting with"
     "functions of one and of two variables) when a polynomial or a"
     "cubic spline is used as the fitting function, since these cover"
     "the most common needs. However, fitting with other functions"
     "and/or more variables can be undertaken by means of general"
     "linear or nonlinear routines (some of which are contained in"
     "other packages) depending on whether the coefficients in the"
     "function occur linearly or nonlinearly. Cases where a graph"
     "rather than a set of data points is given can be treated simply"
     "by first reading a suitable set of points from the graph."
     "The package also contains routines for evaluating,"
     "differentiating and integrating polynomial and spline curves and"
     "surfaces, once the numerical values of their coefficients have"
     "been determined."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NagFittingPackage|
  (progn
    (push '|NagFittingPackage| *Packages*)
    (make-instance '|NagFittingPackageType|)))

\end{chunk}

\subsection{NagLinearEquationSolvingPackage}
\index[pkg]{NagLinearEquationSolvingPackage!Domain}
\index[pkg]{Domain!NagLinearEquationSolvingPackage}
\index[pkg]{NAGF04}
\begin{chunk}{defclass NagLinearEquationSolvingPackageType}
(defclass |NagLinearEquationSolvingPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NagLinearEquationSolvingPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NAGF04)
   (comment :initform (list
     "This package uses the NAG Library to solve the matrix equation"
     "     AX=B, where B"
     "may be a single vector or a matrix of multiple right-hand sides."
     "The matrix A may be real, complex, symmetric, Hermitian positive-"
     "definite, or sparse. It may also be rectangular, in which case a"
     "least-squares solution is obtained."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NagLinearEquationSolvingPackage|
  (progn
    (push '|NagLinearEquationSolvingPackage| *Packages*)
    (make-instance '|NagLinearEquationSolvingPackageType|)))

\end{chunk}

\subsection{NAGLinkSupportPackage}
\index[pkg]{NAGLinkSupportPackage!Domain}
\index[pkg]{Domain!NAGLinkSupportPackage}
\index[pkg]{NAGSP}
\begin{chunk}{defclass NAGLinkSupportPackageType}
(defclass |NAGLinkSupportPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NAGLinkSupportPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NAGSP)
   (comment :initform (list
     "Support functions for the NAG Library Link functions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NAGLinkSupportPackage|
  (progn
    (push '|NAGLinkSupportPackage| *Packages*)
    (make-instance '|NAGLinkSupportPackageType|)))

\end{chunk}

\subsection{NagIntegrationPackage}
\index[pkg]{NagIntegrationPackage!Domain}
\index[pkg]{Domain!NagIntegrationPackage}
\index[pkg]{NAGD01}
\begin{chunk}{defclass NagIntegrationPackageType}
(defclass |NagIntegrationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NagIntegrationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NAGD01)
   (comment :initform (list
     "This package uses the NAG Library to calculate the numerical value of"
     "definite integrals in one or more dimensions and to evaluate"
     "weights and abscissae of integration rules."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NagIntegrationPackage|
  (progn
    (push '|NagIntegrationPackage| *Packages*)
    (make-instance '|NagIntegrationPackageType|)))

\end{chunk}

\subsection{NagInterpolationPackage}
\index[pkg]{NagInterpolationPackage!Domain}
\index[pkg]{Domain!NagInterpolationPackage}
\index[pkg]{NAGE01}
\begin{chunk}{defclass NagInterpolationPackageType}
(defclass |NagInterpolationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NagInterpolationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NAGE01)
   (comment :initform (list
     "This package uses the NAG Library to calculate the interpolation of a"
     "function of one or two variables. When provided with the value of the"
     "function (and possibly one or more of its lowest-order"
     "derivatives) at each of a number of values of the variable(s),"
     "the routines provide either an interpolating function or an"
     "interpolated value. For some of the interpolating functions,"
     "there are supporting routines to evaluate, differentiate or"
     "integrate them."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NagInterpolationPackage|
  (progn
    (push '|NagInterpolationPackage| *Packages*)
    (make-instance '|NagInterpolationPackageType|)))

\end{chunk}

\subsection{NagLapack}
\index[pkg]{NagLapack!Domain}
\index[pkg]{Domain!NagLapack}
\index[pkg]{NAGF07}
\begin{chunk}{defclass NagLapackType}
(defclass |NagLapackType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NagLapack")
   (marker :initform 'package)
   (abbreviation :initform 'NAGF07)
   (comment :initform (list
     "This package uses the NAG Library to compute matrix"
     "factorizations, and to solve systems of linear equations"
     "following the matrix factorizations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NagLapack|
  (progn
    (push '|NagLapack| *Packages*)
    (make-instance '|NagLapackType|)))

\end{chunk}

\subsection{NagMatrixOperationsPackage}
\index[pkg]{NagMatrixOperationsPackage!Domain}
\index[pkg]{Domain!NagMatrixOperationsPackage}
\index[pkg]{NAGF01}
\begin{chunk}{defclass NagMatrixOperationsPackageType}
(defclass |NagMatrixOperationsPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NagMatrixOperationsPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NAGF01)
   (comment :initform (list
     "This package uses the NAG Library to provide facilities for matrix"
     "factorizations and associated transformations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NagMatrixOperationsPackage|
  (progn
    (push '|NagMatrixOperationsPackage| *Packages*)
    (make-instance '|NagMatrixOperationsPackageType|)))

\end{chunk}

\subsection{NagOptimisationPackage}
\index[pkg]{NagOptimisationPackage!Domain}
\index[pkg]{Domain!NagOptimisationPackage}
\index[pkg]{NAGE04}
\begin{chunk}{defclass NagOptimisationPackageType}
(defclass |NagOptimisationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NagOptimisationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NAGE04)
   (comment :initform (list
     "This package uses the NAG Library to perform optimization."
     "An optimization problem involves minimizing a function (called"
     "the objective function) of several variables, possibly subject to"
     "restrictions on the values of the variables defined by a set of"
     "constraint functions. The routines in the NAG Foundation Library"
     "are concerned with function minimization only, since the problem"
     "of maximizing a given function can be transformed into a"
     "minimization problem simply by multiplying the function by -1."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NagOptimisationPackage|
  (progn
    (push '|NagOptimisationPackage| *Packages*)
    (make-instance '|NagOptimisationPackageType|)))

\end{chunk}

\subsection{NagOrdinaryDifferentialEquationsPackage}
\index[pkg]{NagOrdinaryDifferentialEquationsPackage!Domain}
\index[pkg]{Domain!NagOrdinaryDifferentialEquationsPackage}
\index[pkg]{NAGD02}
\begin{chunk}{defclass NagOrdinaryDifferentialEquationsPackageType}
(defclass |NagOrdinaryDifferentialEquationsPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NagOrdinaryDifferentialEquationsPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NAGD02)
   (comment :initform (list
     "This package uses the NAG Library to calculate the numerical solution of"
     "ordinary differential equations. There are two main types of problem,"
     "those in which all boundary conditions are specified at one point"
     "(initial-value problems), and those in which the boundary"
     "conditions are distributed between two or more points (boundary-"
     "value problems and eigenvalue problems). Routines are available"
     "for initial-value problems, two-point boundary-value problems and"
     "Sturm-Liouville eigenvalue problems."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NagOrdinaryDifferentialEquationsPackage|
  (progn
    (push '|NagOrdinaryDifferentialEquationsPackage| *Packages*)
    (make-instance '|NagOrdinaryDifferentialEquationsPackageType|)))

\end{chunk}

\subsection{NagPartialDifferentialEquationsPackage}
\index[pkg]{NagPartialDifferentialEquationsPackage!Domain}
\index[pkg]{Domain!NagPartialDifferentialEquationsPackage}
\index[pkg]{NAGD03}
\begin{chunk}{defclass NagPartialDifferentialEquationsPackageType}
(defclass |NagPartialDifferentialEquationsPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NagPartialDifferentialEquationsPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NAGD03)
   (comment :initform (list
     "This package uses the NAG Library to solve partial"
     "differential equations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NagPartialDifferentialEquationsPackage|
  (progn
    (push '|NagPartialDifferentialEquationsPackage| *Packages*)
    (make-instance '|NagPartialDifferentialEquationsPackageType|)))

\end{chunk}

\subsection{NagPolynomialRootsPackage}
\index[pkg]{NagPolynomialRootsPackage!Domain}
\index[pkg]{Domain!NagPolynomialRootsPackage}
\index[pkg]{NAGC02}
\begin{chunk}{defclass NagPolynomialRootsPackageType}
(defclass |NagPolynomialRootsPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NagPolynomialRootsPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NAGC02)
   (comment :initform (list
     "This package uses the NAG Library to compute the zeros of a"
     "polynomial with real or complex coefficients."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NagPolynomialRootsPackage|
  (progn
    (push '|NagPolynomialRootsPackage| *Packages*)
    (make-instance '|NagPolynomialRootsPackageType|)))

\end{chunk}

\subsection{NagRootFindingPackage}
\index[pkg]{NagRootFindingPackage!Domain}
\index[pkg]{Domain!NagRootFindingPackage}
\index[pkg]{NAGC05}
\begin{chunk}{defclass NagRootFindingPackageType}
(defclass |NagRootFindingPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NagRootFindingPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NAGC05)
   (comment :initform (list
     "This package uses the NAG Library to calculate real zeros of"
     "continuous real functions of one or more variables. (Complex"
     "equations must be expressed in terms of the equivalent larger"
     "system of real equations.)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NagRootFindingPackage|
  (progn
    (push '|NagRootFindingPackage| *Packages*)
    (make-instance '|NagRootFindingPackageType|)))

\end{chunk}

\subsection{NagSeriesSummationPackage}
\index[pkg]{NagSeriesSummationPackage!Domain}
\index[pkg]{Domain!NagSeriesSummationPackage}
\index[pkg]{NAGC06}
\begin{chunk}{defclass NagSeriesSummationPackageType}
(defclass |NagSeriesSummationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NagSeriesSummationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NAGC06)
   (comment :initform (list
     "This package uses the NAG Library to calculate the discrete Fourier"
     "transform of a sequence of real or complex data values, and"
     "applies it to calculate convolutions and correlations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NagSeriesSummationPackage|
  (progn
    (push '|NagSeriesSummationPackage| *Packages*)
    (make-instance '|NagSeriesSummationPackageType|)))

\end{chunk}

\subsection{NagSpecialFunctionsPackage}
\index[pkg]{NagSpecialFunctionsPackage!Domain}
\index[pkg]{Domain!NagSpecialFunctionsPackage}
\index[pkg]{NAGS}
\begin{chunk}{defclass NagSpecialFunctionsPackageType}
(defclass |NagSpecialFunctionsPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NagSpecialFunctionsPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NAGS)
   (comment :initform (list
     "This package uses the NAG Library to compute some commonly"
     "occurring physical and mathematical functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NagSpecialFunctionsPackage|
  (progn
    (push '|NagSpecialFunctionsPackage| *Packages*)
    (make-instance '|NagSpecialFunctionsPackageType|)))

\end{chunk}

\subsection{NewSparseUnivariatePolynomialFunctions2}
\index[pkg]{NewSparseUnivariatePolynomialFunctions2!Domain}
\index[pkg]{Domain!NewSparseUnivariatePolynomialFunctions2}
\index[pkg]{NSUP2}
\begin{chunk}{defclass NewSparseUnivariatePolynomialFunctions2Type}
(defclass |NewSparseUnivariatePolynomialFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NewSparseUnivariatePolynomialFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'NSUP2)
   (comment :initform (list
     "This package lifts a mapping from coefficient rings R to S to"
     "a mapping from sparse univariate polynomial over R to"
     "a sparse univariate polynomial over S."
     "Note that the mapping is assumed"
     "to send zero to zero, since it will only be applied to the non-zero"
     "coefficients of the polynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NewSparseUnivariatePolynomialFunctions2|
  (progn
    (push '|NewSparseUnivariatePolynomialFunctions2| *Packages*)
    (make-instance '|NewSparseUnivariatePolynomialFunctions2Type|)))

\end{chunk}

\subsection{NewtonInterpolation}
\index[pkg]{NewtonInterpolation!Domain}
\index[pkg]{Domain!NewtonInterpolation}
\index[pkg]{NEWTON}
\begin{chunk}{defclass NewtonInterpolationType}
(defclass |NewtonInterpolationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NewtonInterpolation")
   (marker :initform 'package)
   (abbreviation :initform 'NEWTON)
   (comment :initform (list
     "This package exports Newton interpolation for the special case where the"
     "result is known to be in the original integral domain"
     "The packages defined in this file provide fast fraction free rational"
     "interpolation algorithms. (see FAMR2, FFFG, FFFGF, NEWTON)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NewtonInterpolation|
  (progn
    (push '|NewtonInterpolation| *Packages*)
    (make-instance '|NewtonInterpolationType|)))

\end{chunk}

\subsection{NewtonPolygon}
\index[pkg]{NewtonPolygon!Domain}
\index[pkg]{Domain!NewtonPolygon}
\index[pkg]{NPOLYGON}
\begin{chunk}{defclass NewtonPolygonType}
(defclass |NewtonPolygonType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NewtonPolygon")
   (marker :initform 'package)
   (abbreviation :initform 'NPOLYGON)
   (comment :initform (list
     "The following is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NewtonPolygon|
  (progn
    (push '|NewtonPolygon| *Packages*)
    (make-instance '|NewtonPolygonType|)))

\end{chunk}

\subsection{NonCommutativeOperatorDivision}
\index[pkg]{NonCommutativeOperatorDivision!Domain}
\index[pkg]{Domain!NonCommutativeOperatorDivision}
\index[pkg]{NCODIV}
\begin{chunk}{defclass NonCommutativeOperatorDivisionType}
(defclass |NonCommutativeOperatorDivisionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NonCommutativeOperatorDivision")
   (marker :initform 'package)
   (abbreviation :initform 'NCODIV)
   (comment :initform (list
     "This package provides a division and related operations for"
     "MonogenicLinearOperators over a Field."
     "Since the multiplication is in general non-commutative,"
     "these operations all have left- and right-hand versions."
     "This package provides the operations based on left-division."
     "  [q,r] = leftDivide(a,b) means a=b*q+r"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NonCommutativeOperatorDivision|
  (progn
    (push '|NonCommutativeOperatorDivision| *Packages*)
    (make-instance '|NonCommutativeOperatorDivisionType|)))

\end{chunk}

\subsection{NoneFunctions1}
\index[pkg]{NoneFunctions1!Domain}
\index[pkg]{Domain!NoneFunctions1}
\index[pkg]{NONE1}
\begin{chunk}{defclass NoneFunctions1Type}
(defclass |NoneFunctions1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NoneFunctions1")
   (marker :initform 'package)
   (abbreviation :initform 'NONE1)
   (comment :initform (list
     "NoneFunctions1 implements functions on None."
     "It particular it includes a particulary dangerous coercion from"
     "any other type to None."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NoneFunctions1|
  (progn
    (push '|NoneFunctions1| *Packages*)
    (make-instance '|NoneFunctions1Type|)))

\end{chunk}

\subsection{NonLinearFirstOrderODESolver}
\index[pkg]{NonLinearFirstOrderODESolver!Domain}
\index[pkg]{Domain!NonLinearFirstOrderODESolver}
\index[pkg]{NODE1}
\begin{chunk}{defclass NonLinearFirstOrderODESolverType}
(defclass |NonLinearFirstOrderODESolverType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NonLinearFirstOrderODESolver")
   (marker :initform 'package)
   (abbreviation :initform 'NODE1)
   (comment :initform (list
     "NonLinearFirstOrderODESolver provides a function"
     "for finding closed form first integrals of nonlinear ordinary"
     "differential equations of order 1."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NonLinearFirstOrderODESolver|
  (progn
    (push '|NonLinearFirstOrderODESolver| *Packages*)
    (make-instance '|NonLinearFirstOrderODESolverType|)))

\end{chunk}

\subsection{NonLinearSolvePackage}
\index[pkg]{NonLinearSolvePackage!Domain}
\index[pkg]{Domain!NonLinearSolvePackage}
\index[pkg]{NLINSOL}
\begin{chunk}{defclass NonLinearSolvePackageType}
(defclass |NonLinearSolvePackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NonLinearSolvePackage")
   (marker :initform 'package)
   (abbreviation :initform 'NLINSOL)
   (comment :initform (list
     "NonLinearSolvePackage is an interface to SystemSolvePackage"
     "that attempts to retract the coefficients of the equations before"
     "solving. The solutions are given in the algebraic closure of R whenever"
     "possible."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NonLinearSolvePackage|
  (progn
    (push '|NonLinearSolvePackage| *Packages*)
    (make-instance '|NonLinearSolvePackageType|)))

\end{chunk}

\subsection{NormalizationPackage}
\index[pkg]{NormalizationPackage!Domain}
\index[pkg]{Domain!NormalizationPackage}
\index[pkg]{NORMPK}
\begin{chunk}{defclass NormalizationPackageType}
(defclass |NormalizationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NormalizationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NORMPK)
   (comment :initform (list
     "A package for computing normalized assocites of univariate polynomials"
     "with coefficients in a tower of simple extensions of a field."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NormalizationPackage|
  (progn
    (push '|NormalizationPackage| *Packages*)
    (make-instance '|NormalizationPackageType|)))

\end{chunk}

\subsection{NormInMonogenicAlgebra}
\index[pkg]{NormInMonogenicAlgebra!Domain}
\index[pkg]{Domain!NormInMonogenicAlgebra}
\index[pkg]{NORMMA}
\begin{chunk}{defclass NormInMonogenicAlgebraType}
(defclass |NormInMonogenicAlgebraType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NormInMonogenicAlgebra")
   (marker :initform 'package)
   (abbreviation :initform 'NORMMA)
   (comment :initform (list
     "This package implements the norm of a polynomial with coefficients"
     "in a monogenic algebra (using resultants)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NormInMonogenicAlgebra|
  (progn
    (push '|NormInMonogenicAlgebra| *Packages*)
    (make-instance '|NormInMonogenicAlgebraType|)))

\end{chunk}

\subsection{NormRetractPackage}
\index[pkg]{NormRetractPackage!Domain}
\index[pkg]{Domain!NormRetractPackage}
\index[pkg]{NORMRETR}
\begin{chunk}{defclass NormRetractPackageType}
(defclass |NormRetractPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NormRetractPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NORMRETR)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NormRetractPackage|
  (progn
    (push '|NormRetractPackage| *Packages*)
    (make-instance '|NormRetractPackageType|)))

\end{chunk}

\subsection{NPCoef}
\index[pkg]{NPCoef!Domain}
\index[pkg]{Domain!NPCoef}
\index[pkg]{NPCOEF}
\begin{chunk}{defclass NPCoefType}
(defclass |NPCoefType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NPCoef")
   (marker :initform 'package)
   (abbreviation :initform 'NPCOEF)
   (comment :initform (list
     "Package for the determination of the coefficients in the lifting"
     "process. Used by MultivariateLifting."
     "This package will work for every euclidean domain R which has property"
     "F, there exists a factor operation in R[x]."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NPCoef|
  (progn
    (push '|NPCoef| *Packages*)
    (make-instance '|NPCoefType|)))

\end{chunk}

\subsection{NumberFieldIntegralBasis}
\index[pkg]{NumberFieldIntegralBasis!Domain}
\index[pkg]{Domain!NumberFieldIntegralBasis}
\index[pkg]{NFINTBAS}
\begin{chunk}{defclass NumberFieldIntegralBasisType}
(defclass |NumberFieldIntegralBasisType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NumberFieldIntegralBasis")
   (marker :initform 'package)
   (abbreviation :initform 'NFINTBAS)
   (comment :initform (list
     "In this package F is a framed algebra over the integers (typically"
     "F = Z[a] for some algebraic integer a).  The package provides"
     "functions to compute the integral closure of Z in the quotient"
     "quotient field of F."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NumberFieldIntegralBasis|
  (progn
    (push '|NumberFieldIntegralBasis| *Packages*)
    (make-instance '|NumberFieldIntegralBasisType|)))

\end{chunk}

\subsection{NumberFormats}
\index[pkg]{NumberFormats!Domain}
\index[pkg]{Domain!NumberFormats}
\index[pkg]{NUMFMT}
\begin{chunk}{defclass NumberFormatsType}
(defclass |NumberFormatsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NumberFormats")
   (marker :initform 'package)
   (abbreviation :initform 'NUMFMT)
   (comment :initform (list
     "NumberFormats provides function to format and read arabic and"
     "roman numbers, to convert numbers to strings and to read"
     "floating-point numbers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NumberFormats|
  (progn
    (push '|NumberFormats| *Packages*)
    (make-instance '|NumberFormatsType|)))

\end{chunk}

\subsection{NumberTheoreticPolynomialFunctions}
\index[pkg]{NumberTheoreticPolynomialFunctions!Domain}
\index[pkg]{Domain!NumberTheoreticPolynomialFunctions}
\index[pkg]{NTPOLFN}
\begin{chunk}{defclass NumberTheoreticPolynomialFunctionsType}
(defclass |NumberTheoreticPolynomialFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NumberTheoreticPolynomialFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'NTPOLFN)
   (comment :initform (list
     "This package provides polynomials as functions on a ring."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NumberTheoreticPolynomialFunctions|
  (progn
    (push '|NumberTheoreticPolynomialFunctions| *Packages*)
    (make-instance '|NumberTheoreticPolynomialFunctionsType|)))

\end{chunk}

\subsection{Numeric}
\index[pkg]{Numeric!Domain}
\index[pkg]{Domain!Numeric}
\index[pkg]{NUMERIC}
\begin{chunk}{defclass NumericType}
(defclass |NumericType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "Numeric")
   (marker :initform 'package)
   (abbreviation :initform 'NUMERIC)
   (comment :initform (list
     "Numeric provides real and complex numerical evaluation"
     "functions for various symbolic types."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Numeric|
  (progn
    (push '|Numeric| *Packages*)
    (make-instance '|NumericType|)))

\end{chunk}

\subsection{NumericalOrdinaryDifferentialEquations}
\index[pkg]{NumericalOrdinaryDifferentialEquations!Domain}
\index[pkg]{Domain!NumericalOrdinaryDifferentialEquations}
\index[pkg]{NUMODE}
\begin{chunk}{defclass NumericalOrdinaryDifferentialEquationsType}
(defclass |NumericalOrdinaryDifferentialEquationsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NumericalOrdinaryDifferentialEquations")
   (marker :initform 'package)
   (abbreviation :initform 'NUMODE)
   (comment :initform (list
     "This package is a suite of functions for the numerical integration of an"
     "ordinary differential equation of n variables:"
     "     dy/dx = f(y,x)\tab{5}y is an n-vector"
     "All the routines are based on a 4-th order Runge-Kutta kernel."
     "These routines generally have as arguments:"
     "n, the number of dependent variables"
     "x1, the initial point"
     "h, the step size"
     "y, a vector of initial conditions of length n"
     "which upon exit contains the solution at x1 + h"
     " "
     "derivs, a function which computes the right hand side of the"
     "ordinary differential equation: derivs(dydx,y,x) computes"
     "dydx, a vector which contains the derivative information."
     " "
     "In order of increasing complexity"
     "     rk4(y,n,x1,h,derivs) advances the solution vector to"
     "     {x1 + h} and return the values in y."
     " "
     "     {rk4(y,n,x1,h,derivs,t1,t2,t3,t4)} is the same as"
     "     {rk4(y,n,x1,h,derivs)} except that you must provide 4 scratch"
     "     arrays t1-t4 of size n."
     " "
     "     Starting with y at x1, rk4f(y,n,x1,x2,ns,derivs)"
     "     uses ns fixed steps of a 4-th order Runge-Kutta"
     "     integrator to advance the solution vector to x2 and return"
     "     the values in y.  Argument x2, is the final point, and"
     "     ns, the number of steps to take."
     " "
     "rk4qc(y,n,x1,step,eps,yscal,derivs) takes a 5-th order"
     "Runge-Kutta step with monitoring of local truncation to ensure"
     "accuracy and adjust stepsize."
     "The function takes two half steps and one full step and scales"
     "the difference in solutions at the final point. If the error is"
     "within eps, the step is taken and the result is returned."
     "If the error is not within eps, the stepsize if decreased"
     "and the procedure is tried again until the desired accuracy is"
     "reached. Upon input, an trial step size must be given and upon"
     "return, an estimate of the next step size to use is returned as"
     "well as the step size which produced the desired accuracy."
     "The scaled error is computed as"
     "     error = MAX(ABS((y2steps(i) - y1step(i))/yscal(i)))"
     "and this is compared against eps. If this is greater"
     "than eps, the step size is reduced accordingly to"
     "     hnew = 0.9 * hdid * (error/eps)**(-1/4)"
     "If the error criterion is satisfied, then we check if the"
     "step size was too fine and return a more efficient one. If"
     "error > \spad{eps} * (6.0E-04) then the next step size should be"
     "     hnext = 0.9 * hdid * (error/\spad{eps})**(-1/5)"
     "Otherwise hnext = 4.0 * hdid is returned."
     "A more detailed discussion of this and related topics can be"
     "found in the book 'Numerical Recipies' by W.Press, B.P. Flannery,"
     "S.A. Teukolsky, W.T. Vetterling published by Cambridge University Press."
     " "
     "Argument step is a record of 3 floating point"
     "numbers (try , did , next),"
     "eps is the required accuracy,"
     "yscal is the scaling vector for the difference in solutions."
     "On input, step.try should be the guess at a step"
     "size to achieve the accuracy."
     "On output, step.did contains the step size which achieved the"
     "accuracy and step.next is the next step size to use."
     " "
     "rk4qc(y,n,x1,step,eps,yscal,derivs,t1,t2,t3,t4,t5,t6,t7) is the"
     "same as rk4qc(y,n,x1,step,eps,yscal,derivs) except that the user"
     "must provide the 7 scratch arrays t1-t7 of size n."
     " "
     "rk4a(y,n,x1,x2,eps,h,ns,derivs)"
     "is a driver program which uses rk4qc to integrate n ordinary"
     "differential equations starting at x1 to x2, keeping the local"
     "truncation error to within eps by changing the local step size."
     "The scaling vector is defined as"
     "     yscal(i) = abs(y(i)) + abs(h*dydx(i)) + tiny"
     "where y(i) is the solution at location x, dydx is the"
     "ordinary differential equation's right hand side, h is the current"
     "step size and tiny is 10 times the"
     "smallest positive number representable."
     " "
     "The user must supply an estimate for a trial step size and"
     "the maximum number of calls to rk4qc to use."
     "Argument x2 is the final point,"
     "eps is local truncation,"
     "ns is the maximum number of call to rk4qc to use."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NumericalOrdinaryDifferentialEquations|
  (progn
    (push '|NumericalOrdinaryDifferentialEquations| *Packages*)
    (make-instance '|NumericalOrdinaryDifferentialEquationsType|)))

\end{chunk}

\subsection{NumericalQuadrature}
\index[pkg]{NumericalQuadrature!Domain}
\index[pkg]{Domain!NumericalQuadrature}
\index[pkg]{NUMQUAD}
\begin{chunk}{defclass NumericalQuadratureType}
(defclass |NumericalQuadratureType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NumericalQuadrature")
   (marker :initform 'package)
   (abbreviation :initform 'NUMQUAD)
   (comment :initform (list
     "This suite of routines performs numerical quadrature using"
     "algorithms derived from the basic trapezoidal rule. Because"
     "the error term of this rule contains only even powers of the"
     "step size (for open and closed versions), fast convergence"
     "can be obtained if the integrand is sufficiently smooth."
     " "
     "Each routine returns a Record of type TrapAns, which contains"
     "value Float: estimate of the integral"
     "error Float: estimate of the error in the computation"
     "totalpts Integer: total number of function evaluations"
     "success Boolean: if the integral was computed within the user"
     "specified error criterion"
     "To produce this estimate, each routine generates an internal"
     "sequence of sub-estimates, denoted by S(i), depending on the"
     "routine, to which the various convergence criteria are applied."
     "The user must supply a relative accuracy, eps_r, and an absolute"
     "accuracy, \spad{eps_a}. Convergence is obtained when either"
     "     ABS(S(i) - S(i-1)) < eps_r * ABS(S(i-1))"
     "     or ABS(S(i) - S(i-1)) < eps_a"
     "are true statements."
     " "
     "The routines come in three families and three flavors:"
     "closed: romberg, simpson, trapezoidal"
     "open: rombergo, simpsono, trapezoidalo"
     "adaptive closed: aromberg, asimpson, atrapezoidal"
     " "
     "The S(i) for the trapezoidal family is the value of the"
     "integral using an equally spaced absicca trapezoidal rule for"
     "that level of refinement."
     " "
     "The S(i) for the simpson family is the value of the integral"
     "using an equally spaced absicca simpson rule for that level of"
     "refinement."
     " "
     "The S(i) for the romberg family is the estimate of the integral"
     "using an equally spaced absicca romberg method. For"
     "the i-th level, this is an appropriate combination of all the"
     "previous trapezodial estimates so that the error term starts"
     "with the 2*(i+1) power only."
     " "
     "The three families come in a closed version, where the formulas"
     "include the endpoints, an open version where the formulas do not"
     "include the endpoints and an adaptive version, where the user"
     "is required to input the number of subintervals over which the"
     "appropriate closed family integrator will apply with the usual"
     "convergence parmeters for each subinterval. This is useful"
     "where a large number of points are needed only in a small fraction"
     "of the entire domain."
     " "
     "Each routine takes as arguments:"
     "f integrand"
     "a starting point"
     "b ending point"
     "eps_r relative error"
     "eps_a absolute error"
     "nmin refinement level when to start checking for convergence (> 1)"
     "nmax maximum level of refinement"
     " "
     "The adaptive routines take as an additional parameter,"
     "nint, the number of independent intervals to apply a closed"
     "family integrator of the same name."
     " "
     "Notes:"
     "Closed family level i uses 1 + 2**i points."
     "Open family level i uses 1 + 3**i points."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NumericalQuadrature|
  (progn
    (push '|NumericalQuadrature| *Packages*)
    (make-instance '|NumericalQuadratureType|)))

\end{chunk}

\subsection{NumericComplexEigenPackage}
\index[pkg]{NumericComplexEigenPackage!Domain}
\index[pkg]{Domain!NumericComplexEigenPackage}
\index[pkg]{NCEP}
\begin{chunk}{defclass NumericComplexEigenPackageType}
(defclass |NumericComplexEigenPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NumericComplexEigenPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NCEP)
   (comment :initform (list
     "This package computes explicitly eigenvalues and eigenvectors of"
     "matrices with entries over the complex rational numbers."
     "The results are expressed either as complex floating numbers or as"
     "complex rational numbers depending on the type of the precision parameter."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NumericComplexEigenPackage|
  (progn
    (push '|NumericComplexEigenPackage| *Packages*)
    (make-instance '|NumericComplexEigenPackageType|)))

\end{chunk}

\subsection{NumericContinuedFraction}
\index[pkg]{NumericContinuedFraction!Domain}
\index[pkg]{Domain!NumericContinuedFraction}
\index[pkg]{NCNTFRAC}
\begin{chunk}{defclass NumericContinuedFractionType}
(defclass |NumericContinuedFractionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NumericContinuedFraction")
   (marker :initform 'package)
   (abbreviation :initform 'NCNTFRAC)
   (comment :initform (list
     "NumericContinuedFraction provides functions"
     "for converting floating point numbers to continued fractions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NumericContinuedFraction|
  (progn
    (push '|NumericContinuedFraction| *Packages*)
    (make-instance '|NumericContinuedFractionType|)))

\end{chunk}

\subsection{NumericRealEigenPackage}
\index[pkg]{NumericRealEigenPackage!Domain}
\index[pkg]{Domain!NumericRealEigenPackage}
\index[pkg]{NREP}
\begin{chunk}{defclass NumericRealEigenPackageType}
(defclass |NumericRealEigenPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NumericRealEigenPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NREP)
   (comment :initform (list
     "This package computes explicitly eigenvalues and eigenvectors of"
     "matrices with entries over the Rational Numbers."
     "The results are expressed as floating numbers or as rational numbers"
     "depending on the type of the parameter Par."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NumericRealEigenPackage|
  (progn
    (push '|NumericRealEigenPackage| *Packages*)
    (make-instance '|NumericRealEigenPackageType|)))

\end{chunk}

\subsection{NumericTubePlot}
\index[pkg]{NumericTubePlot!Domain}
\index[pkg]{Domain!NumericTubePlot}
\index[pkg]{NUMTUBE}
\begin{chunk}{defclass NumericTubePlotType}
(defclass |NumericTubePlotType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NumericTubePlot")
   (marker :initform 'package)
   (abbreviation :initform 'NUMTUBE)
   (comment :initform (list
     "Package for constructing tubes around 3-dimensional parametric curves."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NumericTubePlot|
  (progn
    (push '|NumericTubePlot| *Packages*)
    (make-instance '|NumericTubePlotType|)))

\end{chunk}

\section{O}

\subsection{OctonionCategoryFunctions2}
\index[pkg]{OctonionCategoryFunctions2!Domain}
\index[pkg]{Domain!OctonionCategoryFunctions2}
\index[pkg]{OCTCT2}
\begin{chunk}{defclass OctonionCategoryFunctions2Type}
(defclass |OctonionCategoryFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "OctonionCategoryFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'OCTCT2)
   (comment :initform (list
     "OctonionCategoryFunctions2 implements functions between"
     "two octonion domains defined over different rings."
     "The function map is used to coerce between octonion types."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OctonionCategoryFunctions2|
  (progn
    (push '|OctonionCategoryFunctions2| *Packages*)
    (make-instance '|OctonionCategoryFunctions2Type|)))

\end{chunk}

\subsection{ODEIntegration}
\index[pkg]{ODEIntegration!Domain}
\index[pkg]{Domain!ODEIntegration}
\index[pkg]{ODEINT}
\begin{chunk}{defclass ODEIntegrationType}
(defclass |ODEIntegrationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ODEIntegration")
   (marker :initform 'package)
   (abbreviation :initform 'ODEINT)
   (comment :initform (list
     "ODEIntegration provides an interface to the integrator."
     "This package is intended for use"
     "by the differential equations solver but not at top-level."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ODEIntegration|
  (progn
    (push '|ODEIntegration| *Packages*)
    (make-instance '|ODEIntegrationType|)))

\end{chunk}

\subsection{ODETools}
\index[pkg]{ODETools!Domain}
\index[pkg]{Domain!ODETools}
\index[pkg]{ODETOOLS}
\begin{chunk}{defclass ODEToolsType}
(defclass |ODEToolsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ODETools")
   (marker :initform 'package)
   (abbreviation :initform 'ODETOOLS)
   (comment :initform (list
     "ODETools provides tools for the linear ODE solver."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ODETools|
  (progn
    (push '|ODETools| *Packages*)
    (make-instance '|ODEToolsType|)))

\end{chunk}

\subsection{OneDimensionalArrayFunctions2}
\index[pkg]{OneDimensionalArrayFunctions2!Domain}
\index[pkg]{Domain!OneDimensionalArrayFunctions2}
\index[pkg]{ARRAY12}
\begin{chunk}{defclass OneDimensionalArrayFunctions2Type}
(defclass |OneDimensionalArrayFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "OneDimensionalArrayFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'ARRAY12)
   (comment :initform (list
     "This package provides tools for operating on one-dimensional arrays"
     "with unary and binary functions involving different underlying types"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OneDimensionalArrayFunctions2|
  (progn
    (push '|OneDimensionalArrayFunctions2| *Packages*)
    (make-instance '|OneDimensionalArrayFunctions2Type|)))

\end{chunk}

\subsection{OnePointCompletionFunctions2}
\index[pkg]{OnePointCompletionFunctions2!Domain}
\index[pkg]{Domain!OnePointCompletionFunctions2}
\index[pkg]{ONECOMP2}
\begin{chunk}{defclass OnePointCompletionFunctions2Type}
(defclass |OnePointCompletionFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "OnePointCompletionFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'ONECOMP2)
   (comment :initform (list
     "Lifting of maps to one-point completions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OnePointCompletionFunctions2|
  (progn
    (push '|OnePointCompletionFunctions2| *Packages*)
    (make-instance '|OnePointCompletionFunctions2Type|)))

\end{chunk}

\subsection{OpenMathPackage}
\index[pkg]{OpenMathPackage!Domain}
\index[pkg]{Domain!OpenMathPackage}
\index[pkg]{OMPKG}
\begin{chunk}{defclass OpenMathPackageType}
(defclass |OpenMathPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "OpenMathPackage")
   (marker :initform 'package)
   (abbreviation :initform 'OMPKG)
   (comment :initform (list
     "OpenMathPackage provides some simple utilities"
     "to make reading OpenMath objects easier."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OpenMathPackage|
  (progn
    (push '|OpenMathPackage| *Packages*)
    (make-instance '|OpenMathPackageType|)))

\end{chunk}

\subsection{OpenMathServerPackage}
\index[pkg]{OpenMathServerPackage!Domain}
\index[pkg]{Domain!OpenMathServerPackage}
\index[pkg]{OMSERVER}
\begin{chunk}{defclass OpenMathServerPackageType}
(defclass |OpenMathServerPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "OpenMathServerPackage")
   (marker :initform 'package)
   (abbreviation :initform 'OMSERVER)
   (comment :initform (list
     "OpenMathServerPackage provides the necessary"
     "operations to run AXIOM as an OpenMath server, reading/writing objects"
     "to/from a port.  Please note the facilities available here are very basic."
     "The idea is that a user calls, for example, Omserve(4000,60) and then"
     "another process sends OpenMath objects to port 4000 and reads the result."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OpenMathServerPackage|
  (progn
    (push '|OpenMathServerPackage| *Packages*)
    (make-instance '|OpenMathServerPackageType|)))

\end{chunk}

\subsection{OperationsQuery}
\index[pkg]{OperationsQuery!Domain}
\index[pkg]{Domain!OperationsQuery}
\index[pkg]{OPQUERY}
\begin{chunk}{defclass OperationsQueryType}
(defclass |OperationsQueryType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "OperationsQuery")
   (marker :initform 'package)
   (abbreviation :initform 'OPQUERY)
   (comment :initform (list
     "This package exports tools to create AXIOM Library information databases."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OperationsQuery|
  (progn
    (push '|OperationsQuery| *Packages*)
    (make-instance '|OperationsQueryType|)))

\end{chunk}

\subsection{OrderedCompletionFunctions2}
\index[pkg]{OrderedCompletionFunctions2!Domain}
\index[pkg]{Domain!OrderedCompletionFunctions2}
\index[pkg]{ORDCOMP2}
\begin{chunk}{defclass OrderedCompletionFunctions2Type}
(defclass |OrderedCompletionFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "OrderedCompletionFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'ORDCOMP2)
   (comment :initform (list
     "Lifting of maps to ordered completions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderedCompletionFunctions2|
  (progn
    (push '|OrderedCompletionFunctions2| *Packages*)
    (make-instance '|OrderedCompletionFunctions2Type|)))

\end{chunk}

\subsection{OrderingFunctions}
\index[pkg]{OrderingFunctions!Domain}
\index[pkg]{Domain!OrderingFunctions}
\index[pkg]{ORDFUNS}
\begin{chunk}{defclass OrderingFunctionsType}
(defclass |OrderingFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "OrderingFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'ORDFUNS)
   (comment :initform (list
     "This package provides ordering functions on vectors which"
     "are suitable parameters for OrderedDirectProduct."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderingFunctions|
  (progn
    (push '|OrderingFunctions| *Packages*)
    (make-instance '|OrderingFunctionsType|)))

\end{chunk}

\subsection{OrthogonalPolynomialFunctions}
\index[pkg]{OrthogonalPolynomialFunctions!Domain}
\index[pkg]{Domain!OrthogonalPolynomialFunctions}
\index[pkg]{ORTHPOL}
\begin{chunk}{defclass OrthogonalPolynomialFunctionsType}
(defclass |OrthogonalPolynomialFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "OrthogonalPolynomialFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'ORTHPOL)
   (comment :initform (list
     "This package provides orthogonal polynomials as functions on a ring."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrthogonalPolynomialFunctions|
  (progn
    (push '|OrthogonalPolynomialFunctions| *Packages*)
    (make-instance '|OrthogonalPolynomialFunctionsType|)))

\end{chunk}

\subsection{OutputPackage}
\index[pkg]{OutputPackage!Domain}
\index[pkg]{Domain!OutputPackage}
\index[pkg]{OUT}
\begin{chunk}{defclass OutputPackageType}
(defclass |OutputPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "OutputPackage")
   (marker :initform 'package)
   (abbreviation :initform 'OUT)
   (comment :initform (list
     "OutPackage allows pretty-printing from programs."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OutputPackage|
  (progn
    (push '|OutputPackage| *Packages*)
    (make-instance '|OutputPackageType|)))

\end{chunk}

\section{P}

\subsection{PackageForAlgebraicFunctionField}
\index[pkg]{PackageForAlgebraicFunctionField!Domain}
\index[pkg]{Domain!PackageForAlgebraicFunctionField}
\index[pkg]{PAFF}
\begin{chunk}{defclass PackageForAlgebraicFunctionFieldType}
(defclass |PackageForAlgebraicFunctionFieldType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PackageForAlgebraicFunctionField")
   (marker :initform 'package)
   (abbreviation :initform 'PAFF)
   (comment :initform (list
     "A package that implements the Brill-Noether algorithm."
     "Part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PackageForAlgebraicFunctionField|
  (progn
    (push '|PackageForAlgebraicFunctionField| *Packages*)
    (make-instance '|PackageForAlgebraicFunctionFieldType|)))

\end{chunk}

\subsection{PackageForAlgebraicFunctionFieldOverFiniteField}
\index[pkg]{PackageForAlgebraicFunctionFieldOverFiniteField!Domain}
\index[pkg]{Domain!PackageForAlgebraicFunctionFieldOverFiniteField}
\index[pkg]{PAFFFF}
\begin{chunk}{defclass PackageForAlgebraicFunctionFieldOverFiniteFieldType}
(defclass |PackageForAlgebraicFunctionFieldOverFiniteFieldType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PackageForAlgebraicFunctionFieldOverFiniteField")
   (marker :initform 'package)
   (abbreviation :initform 'PAFFFF)
   (comment :initform (list
     "A package that implements the Brill-Noether algorithm."
     "Part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PackageForAlgebraicFunctionFieldOverFiniteField|
  (progn
    (push '|PackageForAlgebraicFunctionFieldOverFiniteField| *Packages*)
    (make-instance '|PackageForAlgebraicFunctionFieldOverFiniteFieldType|)))

\end{chunk}

\subsection{PackageForPoly}
\index[pkg]{PackageForPoly!Domain}
\index[pkg]{Domain!PackageForPoly}
\index[pkg]{PFORP}
\begin{chunk}{defclass PackageForPolyType}
(defclass |PackageForPolyType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PackageForPoly")
   (marker :initform 'package)
   (abbreviation :initform 'PFORP)
   (comment :initform (list
     "The following is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PackageForPoly|
  (progn
    (push '|PackageForPoly| *Packages*)
    (make-instance '|PackageForPolyType|)))

\end{chunk}

\subsection{PadeApproximantPackage}
\index[pkg]{PadeApproximantPackage!Domain}
\index[pkg]{Domain!PadeApproximantPackage}
\index[pkg]{PADEPAC}
\begin{chunk}{defclass PadeApproximantPackageType}
(defclass |PadeApproximantPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PadeApproximantPackage")
   (marker :initform 'package)
   (abbreviation :initform 'PADEPAC)
   (comment :initform (list
     "This package computes reliable Pad&ea. approximants using"
     "a generalized Viskovatov continued fraction algorithm."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PadeApproximantPackage|
  (progn
    (push '|PadeApproximantPackage| *Packages*)
    (make-instance '|PadeApproximantPackageType|)))

\end{chunk}

\subsection{PadeApproximants}
\index[pkg]{PadeApproximants!Domain}
\index[pkg]{Domain!PadeApproximants}
\index[pkg]{PADE}
\begin{chunk}{defclass PadeApproximantsType}
(defclass |PadeApproximantsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PadeApproximants")
   (marker :initform 'package)
   (abbreviation :initform 'PADE)
   (comment :initform (list
     "This package computes reliable Pad&ea. approximants using"
     "a generalized Viskovatov continued fraction algorithm."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PadeApproximants|
  (progn
    (push '|PadeApproximants| *Packages*)
    (make-instance '|PadeApproximantsType|)))

\end{chunk}

\subsection{PAdicWildFunctionFieldIntegralBasis}
\index[pkg]{PAdicWildFunctionFieldIntegralBasis!Domain}
\index[pkg]{Domain!PAdicWildFunctionFieldIntegralBasis}
\index[pkg]{PWFFINTB}
\begin{chunk}{defclass PAdicWildFunctionFieldIntegralBasisType}
(defclass |PAdicWildFunctionFieldIntegralBasisType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PAdicWildFunctionFieldIntegralBasis")
   (marker :initform 'package)
   (abbreviation :initform 'PWFFINTB)
   (comment :initform (list
     "In this package K is a finite field, R is a ring of univariate"
     "polynomials over K, and F is a monogenic algebra over R."
     "We require that F is monogenic, that F = K[x,y]/(f(x,y)),"
     "because the integral basis algorithm used will factor the polynomial"
     "f(x,y).  The package provides a function to compute the integral"
     "closure of R in the quotient field of F as well as a function to compute"
     "a 'local integral basis' at a specific prime."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PAdicWildFunctionFieldIntegralBasis|
  (progn
    (push '|PAdicWildFunctionFieldIntegralBasis| *Packages*)
    (make-instance '|PAdicWildFunctionFieldIntegralBasisType|)))

\end{chunk}

\subsection{ParadoxicalCombinatorsForStreams}
\index[pkg]{ParadoxicalCombinatorsForStreams!Domain}
\index[pkg]{Domain!ParadoxicalCombinatorsForStreams}
\index[pkg]{YSTREAM}
\begin{chunk}{defclass ParadoxicalCombinatorsForStreamsType}
(defclass |ParadoxicalCombinatorsForStreamsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ParadoxicalCombinatorsForStreams")
   (marker :initform 'package)
   (abbreviation :initform 'YSTREAM)
   (comment :initform (list
     "Computation of fixed points of mappings on streams"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ParadoxicalCombinatorsForStreams|
  (progn
    (push '|ParadoxicalCombinatorsForStreams| *Packages*)
    (make-instance '|ParadoxicalCombinatorsForStreamsType|)))

\end{chunk}

\subsection{ParametricLinearEquations}
\index[pkg]{ParametricLinearEquations!Domain}
\index[pkg]{Domain!ParametricLinearEquations}
\index[pkg]{PLEQN}
\begin{chunk}{defclass ParametricLinearEquationsType}
(defclass |ParametricLinearEquationsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ParametricLinearEquations")
   (marker :initform 'package)
   (abbreviation :initform 'PLEQN)
   (comment :initform (list
     "This package completely solves a parametric linear system of equations"
     "by decomposing the set of all parametric values for which the linear"
     "system is consistent into a union of quasi-algebraic  sets (which need"
     "not be irredundant, but most of the time is). Each quasi-algebraic"
     "set is described by a list of polynomials that vanish on the set, and"
     "a list of polynomials that vanish at no point of the set."
     "For each quasi-algebraic set, the solution of the linear system"
     "is given, as a particular solution and  a basis of the homogeneous"
     "system."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ParametricLinearEquations|
  (progn
    (push '|ParametricLinearEquations| *Packages*)
    (make-instance '|ParametricLinearEquationsType|)))

\end{chunk}

\subsection{ParametricPlaneCurveFunctions2}
\index[pkg]{ParametricPlaneCurveFunctions2!Domain}
\index[pkg]{Domain!ParametricPlaneCurveFunctions2}
\index[pkg]{PARPC2}
\begin{chunk}{defclass ParametricPlaneCurveFunctions2Type}
(defclass |ParametricPlaneCurveFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ParametricPlaneCurveFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'PARPC2)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ParametricPlaneCurveFunctions2|
  (progn
    (push '|ParametricPlaneCurveFunctions2| *Packages*)
    (make-instance '|ParametricPlaneCurveFunctions2Type|)))

\end{chunk}

\subsection{ParametricSpaceCurveFunctions2}
\index[pkg]{ParametricSpaceCurveFunctions2!Domain}
\index[pkg]{Domain!ParametricSpaceCurveFunctions2}
\index[pkg]{PARSC2}
\begin{chunk}{defclass ParametricSpaceCurveFunctions2Type}
(defclass |ParametricSpaceCurveFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ParametricSpaceCurveFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'PARSC2)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ParametricSpaceCurveFunctions2|
  (progn
    (push '|ParametricSpaceCurveFunctions2| *Packages*)
    (make-instance '|ParametricSpaceCurveFunctions2Type|)))

\end{chunk}

\subsection{ParametricSurfaceFunctions2}
\index[pkg]{ParametricSurfaceFunctions2!Domain}
\index[pkg]{Domain!ParametricSurfaceFunctions2}
\index[pkg]{PARSU2}
\begin{chunk}{defclass ParametricSurfaceFunctions2Type}
(defclass |ParametricSurfaceFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ParametricSurfaceFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'PARSU2)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ParametricSurfaceFunctions2|
  (progn
    (push '|ParametricSurfaceFunctions2| *Packages*)
    (make-instance '|ParametricSurfaceFunctions2Type|)))

\end{chunk}

\subsection{ParametrizationPackage}
\index[pkg]{ParametrizationPackage!Domain}
\index[pkg]{Domain!ParametrizationPackage}
\index[pkg]{PARAMP}
\begin{chunk}{defclass ParametrizationPackageType}
(defclass |ParametrizationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ParametrizationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'PARAMP)
   (comment :initform (list
     "The following is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ParametrizationPackage|
  (progn
    (push '|ParametrizationPackage| *Packages*)
    (make-instance '|ParametrizationPackageType|)))

\end{chunk}

\subsection{PartialFractionPackage}
\index[pkg]{PartialFractionPackage!Domain}
\index[pkg]{Domain!PartialFractionPackage}
\index[pkg]{PFRPAC}
\begin{chunk}{defclass PartialFractionPackageType}
(defclass |PartialFractionPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PartialFractionPackage")
   (marker :initform 'package)
   (abbreviation :initform 'PFRPAC)
   (comment :initform (list
     "The package PartialFractionPackage gives an easier"
     "to use interfact the domain PartialFraction."
     "The user gives a fraction of polynomials, and a variable and"
     "the package converts it to the proper datatype for the"
     "PartialFraction domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PartialFractionPackage|
  (progn
    (push '|PartialFractionPackage| *Packages*)
    (make-instance '|PartialFractionPackageType|)))

\end{chunk}

\subsection{PartitionsAndPermutations}
\index[pkg]{PartitionsAndPermutations!Domain}
\index[pkg]{Domain!PartitionsAndPermutations}
\index[pkg]{PARTPERM}
\begin{chunk}{defclass PartitionsAndPermutationsType}
(defclass |PartitionsAndPermutationsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PartitionsAndPermutations")
   (marker :initform 'package)
   (abbreviation :initform 'PARTPERM)
   (comment :initform (list
     "PartitionsAndPermutations contains functions for generating streams of"
     "integer partitions, and streams of sequences of integers"
     "composed from a multi-set."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PartitionsAndPermutations|
  (progn
    (push '|PartitionsAndPermutations| *Packages*)
    (make-instance '|PartitionsAndPermutationsType|)))

\end{chunk}

\subsection{PatternFunctions1}
\index[pkg]{PatternFunctions1!Domain}
\index[pkg]{Domain!PatternFunctions1}
\index[pkg]{PATTERN1}
\begin{chunk}{defclass PatternFunctions1Type}
(defclass |PatternFunctions1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PatternFunctions1")
   (marker :initform 'package)
   (abbreviation :initform 'PATTERN1)
   (comment :initform (list
     "Utilities for handling patterns"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternFunctions1|
  (progn
    (push '|PatternFunctions1| *Packages*)
    (make-instance '|PatternFunctions1Type|)))

\end{chunk}

\subsection{PatternFunctions2}
\index[pkg]{PatternFunctions2!Domain}
\index[pkg]{Domain!PatternFunctions2}
\index[pkg]{PATTERN2}
\begin{chunk}{defclass PatternFunctions2Type}
(defclass |PatternFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PatternFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'PATTERN2)
   (comment :initform (list
     "Lifts maps to patterns"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternFunctions2|
  (progn
    (push '|PatternFunctions2| *Packages*)
    (make-instance '|PatternFunctions2Type|)))

\end{chunk}

\subsection{PatternMatch}
\index[pkg]{PatternMatch!Domain}
\index[pkg]{Domain!PatternMatch}
\index[pkg]{PATMATCH}
\begin{chunk}{defclass PatternMatchType}
(defclass |PatternMatchType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PatternMatch")
   (marker :initform 'package)
   (abbreviation :initform 'PATMATCH)
   (comment :initform (list
     "This package provides the top-level pattern macthing functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternMatch|
  (progn
    (push '|PatternMatch| *Packages*)
    (make-instance '|PatternMatchType|)))

\end{chunk}

\subsection{PatternMatchAssertions}
\index[pkg]{PatternMatchAssertions!Domain}
\index[pkg]{Domain!PatternMatchAssertions}
\index[pkg]{PMASS}
\begin{chunk}{defclass PatternMatchAssertionsType}
(defclass |PatternMatchAssertionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PatternMatchAssertions")
   (marker :initform 'package)
   (abbreviation :initform 'PMASS)
   (comment :initform (list
     "Attaching assertions to symbols for pattern matching;"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternMatchAssertions|
  (progn
    (push '|PatternMatchAssertions| *Packages*)
    (make-instance '|PatternMatchAssertionsType|)))

\end{chunk}

\subsection{PatternMatchFunctionSpace}
\index[pkg]{PatternMatchFunctionSpace!Domain}
\index[pkg]{Domain!PatternMatchFunctionSpace}
\index[pkg]{PMFS}
\begin{chunk}{defclass PatternMatchFunctionSpaceType}
(defclass |PatternMatchFunctionSpaceType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PatternMatchFunctionSpace")
   (marker :initform 'package)
   (abbreviation :initform 'PMFS)
   (comment :initform (list
     "This package provides pattern matching functions on function spaces."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternMatchFunctionSpace|
  (progn
    (push '|PatternMatchFunctionSpace| *Packages*)
    (make-instance '|PatternMatchFunctionSpaceType|)))

\end{chunk}

\subsection{PatternMatchIntegerNumberSystem}
\index[pkg]{PatternMatchIntegerNumberSystem!Domain}
\index[pkg]{Domain!PatternMatchIntegerNumberSystem}
\index[pkg]{PMINS}
\begin{chunk}{defclass PatternMatchIntegerNumberSystemType}
(defclass |PatternMatchIntegerNumberSystemType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PatternMatchIntegerNumberSystem")
   (marker :initform 'package)
   (abbreviation :initform 'PMINS)
   (comment :initform (list
     "This package provides pattern matching functions on integers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternMatchIntegerNumberSystem|
  (progn
    (push '|PatternMatchIntegerNumberSystem| *Packages*)
    (make-instance '|PatternMatchIntegerNumberSystemType|)))

\end{chunk}

\subsection{PatternMatchIntegration}
\index[pkg]{PatternMatchIntegration!Domain}
\index[pkg]{Domain!PatternMatchIntegration}
\index[pkg]{INTPM}
\begin{chunk}{defclass PatternMatchIntegrationType}
(defclass |PatternMatchIntegrationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PatternMatchIntegration")
   (marker :initform 'package)
   (abbreviation :initform 'INTPM)
   (comment :initform (list
     "PatternMatchIntegration provides functions that use"
     "the pattern matcher to find some indefinite and definite integrals"
     "involving special functions and found in the litterature."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternMatchIntegration|
  (progn
    (push '|PatternMatchIntegration| *Packages*)
    (make-instance '|PatternMatchIntegrationType|)))

\end{chunk}

\subsection{PatternMatchKernel}
\index[pkg]{PatternMatchKernel!Domain}
\index[pkg]{Domain!PatternMatchKernel}
\index[pkg]{PMKERNEL}
\begin{chunk}{defclass PatternMatchKernelType}
(defclass |PatternMatchKernelType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PatternMatchKernel")
   (marker :initform 'package)
   (abbreviation :initform 'PMKERNEL)
   (comment :initform (list
     "This package provides pattern matching functions on kernels."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternMatchKernel|
  (progn
    (push '|PatternMatchKernel| *Packages*)
    (make-instance '|PatternMatchKernelType|)))

\end{chunk}

\subsection{PatternMatchListAggregate}
\index[pkg]{PatternMatchListAggregate!Domain}
\index[pkg]{Domain!PatternMatchListAggregate}
\index[pkg]{PMLSAGG}
\begin{chunk}{defclass PatternMatchListAggregateType}
(defclass |PatternMatchListAggregateType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PatternMatchListAggregate")
   (marker :initform 'package)
   (abbreviation :initform 'PMLSAGG)
   (comment :initform (list
     "This package provides pattern matching functions on lists."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternMatchListAggregate|
  (progn
    (push '|PatternMatchListAggregate| *Packages*)
    (make-instance '|PatternMatchListAggregateType|)))

\end{chunk}

\subsection{PatternMatchPolynomialCategory}
\index[pkg]{PatternMatchPolynomialCategory!Domain}
\index[pkg]{Domain!PatternMatchPolynomialCategory}
\index[pkg]{PMPLCAT}
\begin{chunk}{defclass PatternMatchPolynomialCategoryType}
(defclass |PatternMatchPolynomialCategoryType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PatternMatchPolynomialCategory")
   (marker :initform 'package)
   (abbreviation :initform 'PMPLCAT)
   (comment :initform (list
     "This package provides pattern matching functions on polynomials."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternMatchPolynomialCategory|
  (progn
    (push '|PatternMatchPolynomialCategory| *Packages*)
    (make-instance '|PatternMatchPolynomialCategoryType|)))

\end{chunk}

\subsection{PatternMatchPushDown}
\index[pkg]{PatternMatchPushDown!Domain}
\index[pkg]{Domain!PatternMatchPushDown}
\index[pkg]{PMDOWN}
\begin{chunk}{defclass PatternMatchPushDownType}
(defclass |PatternMatchPushDownType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PatternMatchPushDown")
   (marker :initform 'package)
   (abbreviation :initform 'PMDOWN)
   (comment :initform (list
     "This packages provides tools for matching recursively in type towers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternMatchPushDown|
  (progn
    (push '|PatternMatchPushDown| *Packages*)
    (make-instance '|PatternMatchPushDownType|)))

\end{chunk}

\subsection{PatternMatchQuotientFieldCategory}
\index[pkg]{PatternMatchQuotientFieldCategory!Domain}
\index[pkg]{Domain!PatternMatchQuotientFieldCategory}
\index[pkg]{PMQFCAT}
\begin{chunk}{defclass PatternMatchQuotientFieldCategoryType}
(defclass |PatternMatchQuotientFieldCategoryType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PatternMatchQuotientFieldCategory")
   (marker :initform 'package)
   (abbreviation :initform 'PMQFCAT)
   (comment :initform (list
     "This package provides pattern matching functions on quotients."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternMatchQuotientFieldCategory|
  (progn
    (push '|PatternMatchQuotientFieldCategory| *Packages*)
    (make-instance '|PatternMatchQuotientFieldCategoryType|)))

\end{chunk}

\subsection{PatternMatchResultFunctions2}
\index[pkg]{PatternMatchResultFunctions2!Domain}
\index[pkg]{Domain!PatternMatchResultFunctions2}
\index[pkg]{PATRES2}
\begin{chunk}{defclass PatternMatchResultFunctions2Type}
(defclass |PatternMatchResultFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PatternMatchResultFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'PATRES2)
   (comment :initform (list
     "Lifts maps to pattern matching results."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternMatchResultFunctions2|
  (progn
    (push '|PatternMatchResultFunctions2| *Packages*)
    (make-instance '|PatternMatchResultFunctions2Type|)))

\end{chunk}

\subsection{PatternMatchSymbol}
\index[pkg]{PatternMatchSymbol!Domain}
\index[pkg]{Domain!PatternMatchSymbol}
\index[pkg]{PMSYM}
\begin{chunk}{defclass PatternMatchSymbolType}
(defclass |PatternMatchSymbolType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PatternMatchSymbol")
   (marker :initform 'package)
   (abbreviation :initform 'PMSYM)
   (comment :initform (list
     "This package provides pattern matching functions on symbols."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternMatchSymbol|
  (progn
    (push '|PatternMatchSymbol| *Packages*)
    (make-instance '|PatternMatchSymbolType|)))

\end{chunk}

\subsection{PatternMatchTools}
\index[pkg]{PatternMatchTools!Domain}
\index[pkg]{Domain!PatternMatchTools}
\index[pkg]{PMTOOLS}
\begin{chunk}{defclass PatternMatchToolsType}
(defclass |PatternMatchToolsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PatternMatchTools")
   (marker :initform 'package)
   (abbreviation :initform 'PMTOOLS)
   (comment :initform (list
     "This package provides tools for the pattern matcher."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternMatchTools|
  (progn
    (push '|PatternMatchTools| *Packages*)
    (make-instance '|PatternMatchToolsType|)))

\end{chunk}

\subsection{Permanent}
\index[pkg]{Permanent!Domain}
\index[pkg]{Domain!Permanent}
\index[pkg]{PERMAN}
\begin{chunk}{defclass PermanentType}
(defclass |PermanentType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "Permanent")
   (marker :initform 'package)
   (abbreviation :initform 'PERMAN)
   (comment :initform (list
     "Permanent implements the functions permanent, the"
     "permanent for square matrices."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Permanent|
  (progn
    (push '|Permanent| *Packages*)
    (make-instance '|PermanentType|)))

\end{chunk}

\subsection{PermutationGroupExamples}
\index[pkg]{PermutationGroupExamples!Domain}
\index[pkg]{Domain!PermutationGroupExamples}
\index[pkg]{PGE}
\begin{chunk}{defclass PermutationGroupExamplesType}
(defclass |PermutationGroupExamplesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PermutationGroupExamples")
   (marker :initform 'package)
   (abbreviation :initform 'PGE)
   (comment :initform (list
     "PermutationGroupExamples provides permutation groups for"
     "some classes of groups: symmetric, alternating, dihedral, cyclic,"
     "direct products of cyclic, which are in fact the finite abelian groups"
     "of symmetric groups called Young subgroups."
     "Furthermore, Rubik's group as permutation group of 48 integers and a list"
     "of sporadic simple groups derived from the atlas of finite groups."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PermutationGroupExamples|
  (progn
    (push '|PermutationGroupExamples| *Packages*)
    (make-instance '|PermutationGroupExamplesType|)))

\end{chunk}

\subsection{PiCoercions}
\index[pkg]{PiCoercions!Domain}
\index[pkg]{Domain!PiCoercions}
\index[pkg]{PICOERCE}
\begin{chunk}{defclass PiCoercionsType}
(defclass |PiCoercionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PiCoercions")
   (marker :initform 'package)
   (abbreviation :initform 'PICOERCE)
   (comment :initform (list
     "Provides a coercion from the symbolic fractions in %pi with"
     "integer coefficients to any Expression type."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PiCoercions|
  (progn
    (push '|PiCoercions| *Packages*)
    (make-instance '|PiCoercionsType|)))

\end{chunk}

\subsection{PlotFunctions1}
\index[pkg]{PlotFunctions1!Domain}
\index[pkg]{Domain!PlotFunctions1}
\index[pkg]{PLOT1}
\begin{chunk}{defclass PlotFunctions1Type}
(defclass |PlotFunctions1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PlotFunctions1")
   (marker :initform 'package)
   (abbreviation :initform 'PLOT1)
   (comment :initform (list
     "PlotFunctions1 provides facilities for plotting curves"
     "where functions SF -> SF are specified by giving an expression"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PlotFunctions1|
  (progn
    (push '|PlotFunctions1| *Packages*)
    (make-instance '|PlotFunctions1Type|)))

\end{chunk}

\subsection{PlotTools}
\index[pkg]{PlotTools!Domain}
\index[pkg]{Domain!PlotTools}
\index[pkg]{PLOTTOOL}
\begin{chunk}{defclass PlotToolsType}
(defclass |PlotToolsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PlotTools")
   (marker :initform 'package)
   (abbreviation :initform 'PLOTTOOL)
   (comment :initform (list
     "This package exports plotting tools"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PlotTools|
  (progn
    (push '|PlotTools| *Packages*)
    (make-instance '|PlotToolsType|)))

\end{chunk}

\subsection{ProjectiveAlgebraicSetPackage}
\index[pkg]{ProjectiveAlgebraicSetPackage!Domain}
\index[pkg]{Domain!ProjectiveAlgebraicSetPackage}
\index[pkg]{PRJALGPK}
\begin{chunk}{defclass ProjectiveAlgebraicSetPackageType}
(defclass |ProjectiveAlgebraicSetPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ProjectiveAlgebraicSetPackage")
   (marker :initform 'package)
   (abbreviation :initform 'PRJALGPK)
   (comment :initform (list
     "The following is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ProjectiveAlgebraicSetPackage|
  (progn
    (push '|ProjectiveAlgebraicSetPackage| *Packages*)
    (make-instance '|ProjectiveAlgebraicSetPackageType|)))

\end{chunk}

\subsection{PointFunctions2}
\index[pkg]{PointFunctions2!Domain}
\index[pkg]{Domain!PointFunctions2}
\index[pkg]{PTFUNC2}
\begin{chunk}{defclass PointFunctions2Type}
(defclass |PointFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PointFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'PTFUNC2)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PointFunctions2|
  (progn
    (push '|PointFunctions2| *Packages*)
    (make-instance '|PointFunctions2Type|)))

\end{chunk}

\subsection{PointPackage}
\index[pkg]{PointPackage!Domain}
\index[pkg]{Domain!PointPackage}
\index[pkg]{PTPACK}
\begin{chunk}{defclass PointPackageType}
(defclass |PointPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PointPackage")
   (marker :initform 'package)
   (abbreviation :initform 'PTPACK)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PointPackage|
  (progn
    (push '|PointPackage| *Packages*)
    (make-instance '|PointPackageType|)))

\end{chunk}

\subsection{PointsOfFiniteOrder}
\index[pkg]{PointsOfFiniteOrder!Domain}
\index[pkg]{Domain!PointsOfFiniteOrder}
\index[pkg]{PFO}
\begin{chunk}{defclass PointsOfFiniteOrderType}
(defclass |PointsOfFiniteOrderType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PointsOfFiniteOrder")
   (marker :initform 'package)
   (abbreviation :initform 'PFO)
   (comment :initform (list
     "This package provides function for testing whether a divisor on a"
     "curve is a torsion divisor."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PointsOfFiniteOrder|
  (progn
    (push '|PointsOfFiniteOrder| *Packages*)
    (make-instance '|PointsOfFiniteOrderType|)))

\end{chunk}

\subsection{PointsOfFiniteOrderRational}
\index[pkg]{PointsOfFiniteOrderRational!Domain}
\index[pkg]{Domain!PointsOfFiniteOrderRational}
\index[pkg]{PFOQ}
\begin{chunk}{defclass PointsOfFiniteOrderRationalType}
(defclass |PointsOfFiniteOrderRationalType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PointsOfFiniteOrderRational")
   (marker :initform 'package)
   (abbreviation :initform 'PFOQ)
   (comment :initform (list
     "This package provides function for testing whether a divisor on a"
     "curve is a torsion divisor."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PointsOfFiniteOrderRational|
  (progn
    (push '|PointsOfFiniteOrderRational| *Packages*)
    (make-instance '|PointsOfFiniteOrderRationalType|)))

\end{chunk}

\subsection{PointsOfFiniteOrderTools}
\index[pkg]{PointsOfFiniteOrderTools!Domain}
\index[pkg]{Domain!PointsOfFiniteOrderTools}
\index[pkg]{PFOTOOLS}
\begin{chunk}{defclass PointsOfFiniteOrderToolsType}
(defclass |PointsOfFiniteOrderToolsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PointsOfFiniteOrderTools")
   (marker :initform 'package)
   (abbreviation :initform 'PFOTOOLS)
   (comment :initform (list
     "Utilities for PFOQ and PFO"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PointsOfFiniteOrderTools|
  (progn
    (push '|PointsOfFiniteOrderTools| *Packages*)
    (make-instance '|PointsOfFiniteOrderToolsType|)))

\end{chunk}

\subsection{PolynomialPackageForCurve}
\index[pkg]{PolynomialPackageForCurve!Domain}
\index[pkg]{Domain!PolynomialPackageForCurve}
\index[pkg]{PLPKCRV}
\begin{chunk}{defclass PolynomialPackageForCurveType}
(defclass |PolynomialPackageForCurveType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialPackageForCurve")
   (marker :initform 'package)
   (abbreviation :initform 'PLPKCRV)
   (comment :initform (list
     "The following is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialPackageForCurve|
  (progn
    (push '|PolynomialPackageForCurve| *Packages*)
    (make-instance '|PolynomialPackageForCurveType|)))

\end{chunk}

\subsection{PolToPol}
\index[pkg]{PolToPol!Domain}
\index[pkg]{Domain!PolToPol}
\index[pkg]{POLTOPOL}
\begin{chunk}{defclass PolToPolType}
(defclass |PolToPolType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolToPol")
   (marker :initform 'package)
   (abbreviation :initform 'POLTOPOL)
   (comment :initform (list
     "Package with the conversion functions among different kind of polynomials"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolToPol|
  (progn
    (push '|PolToPol| *Packages*)
    (make-instance '|PolToPolType|)))

\end{chunk}

\subsection{PolyGroebner}
\index[pkg]{PolyGroebner!Domain}
\index[pkg]{Domain!PolyGroebner}
\index[pkg]{PGROEB}
\begin{chunk}{defclass PolyGroebnerType}
(defclass |PolyGroebnerType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolyGroebner")
   (marker :initform 'package)
   (abbreviation :initform 'PGROEB)
   (comment :initform (list
     "Groebner functions for P F"
     "This package is an interface package to the groebner basis"
     "package which allows you to compute groebner bases for polynomials"
     "in either lexicographic ordering or total degree ordering refined"
     "by reverse lex. The input is the ordinary polynomial type which"
     "is internally converted to a type with the required ordering."
     "The resulting grobner basis is converted back to ordinary polynomials."
     "The ordering among the variables is controlled by an explicit list"
     "of variables which is passed as a second argument. The coefficient"
     "domain is allowed to be any gcd domain, but the groebner basis is"
     "computed as if the polynomials were over a field."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolyGroebner|
  (progn
    (push '|PolyGroebner| *Packages*)
    (make-instance '|PolyGroebnerType|)))

\end{chunk}

\subsection{PolynomialAN2Expression}
\index[pkg]{PolynomialAN2Expression!Domain}
\index[pkg]{Domain!PolynomialAN2Expression}
\index[pkg]{PAN2EXPR}
\begin{chunk}{defclass PolynomialAN2ExpressionType}
(defclass |PolynomialAN2ExpressionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialAN2Expression")
   (marker :initform 'package)
   (abbreviation :initform 'PAN2EXPR)
   (comment :initform (list
     "This package provides a coerce from polynomials over"
     "algebraic numbers to Expression AlgebraicNumber."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialAN2Expression|
  (progn
    (push '|PolynomialAN2Expression| *Packages*)
    (make-instance '|PolynomialAN2ExpressionType|)))

\end{chunk}

\subsection{PolynomialCategoryLifting}
\index[pkg]{PolynomialCategoryLifting!Domain}
\index[pkg]{Domain!PolynomialCategoryLifting}
\index[pkg]{POLYLIFT}
\begin{chunk}{defclass PolynomialCategoryLiftingType}
(defclass |PolynomialCategoryLiftingType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialCategoryLifting")
   (marker :initform 'package)
   (abbreviation :initform 'POLYLIFT)
   (comment :initform (list
     "This package provides a very general map function, which"
     "given a set S and polynomials over R with maps from the"
     "variables into S and the coefficients into S, maps polynomials"
     "into S. S is assumed to support +, * and **."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialCategoryLifting|
  (progn
    (push '|PolynomialCategoryLifting| *Packages*)
    (make-instance '|PolynomialCategoryLiftingType|)))

\end{chunk}

\subsection{PolynomialCategoryQuotientFunctions}
\index[pkg]{PolynomialCategoryQuotientFunctions!Domain}
\index[pkg]{Domain!PolynomialCategoryQuotientFunctions}
\index[pkg]{POLYCATQ}
\begin{chunk}{defclass PolynomialCategoryQuotientFunctionsType}
(defclass |PolynomialCategoryQuotientFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialCategoryQuotientFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'POLYCATQ)
   (comment :initform (list
     "Manipulations on polynomial quotients"
     "This package transforms multivariate polynomials or fractions into"
     "univariate polynomials or fractions, and back."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialCategoryQuotientFunctions|
  (progn
    (push '|PolynomialCategoryQuotientFunctions| *Packages*)
    (make-instance '|PolynomialCategoryQuotientFunctionsType|)))

\end{chunk}

\subsection{PolynomialComposition}
\index[pkg]{PolynomialComposition!Domain}
\index[pkg]{Domain!PolynomialComposition}
\index[pkg]{PCOMP}
\begin{chunk}{defclass PolynomialCompositionType}
(defclass |PolynomialCompositionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialComposition")
   (marker :initform 'package)
   (abbreviation :initform 'PCOMP)
   (comment :initform (list
     "Polynomial composition and decomposition functions"
     "If f = g o h then g=leftFactor(f,h) and h=rightFactor(f,g)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialComposition|
  (progn
    (push '|PolynomialComposition| *Packages*)
    (make-instance '|PolynomialCompositionType|)))

\end{chunk}

\subsection{PolynomialDecomposition}
\index[pkg]{PolynomialDecomposition!Domain}
\index[pkg]{Domain!PolynomialDecomposition}
\index[pkg]{PDECOMP}
\begin{chunk}{defclass PolynomialDecompositionType}
(defclass |PolynomialDecompositionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialDecomposition")
   (marker :initform 'package)
   (abbreviation :initform 'PDECOMP)
   (comment :initform (list
     "Polynomial composition and decomposition functions"
     "If f = g o h then g=leftFactor(f,h) and h=rightFactor(f,g)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialDecomposition|
  (progn
    (push '|PolynomialDecomposition| *Packages*)
    (make-instance '|PolynomialDecompositionType|)))

\end{chunk}

\subsection{PolynomialFactorizationByRecursion}
\index[pkg]{PolynomialFactorizationByRecursion!Domain}
\index[pkg]{Domain!PolynomialFactorizationByRecursion}
\index[pkg]{PFBR}
\begin{chunk}{defclass PolynomialFactorizationByRecursionType}
(defclass |PolynomialFactorizationByRecursionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialFactorizationByRecursion")
   (marker :initform 'package)
   (abbreviation :initform 'PFBR)
   (comment :initform (list
     "PolynomialFactorizationByRecursion(R,E,VarSet,S)"
     "is used for factorization of sparse univariate polynomials over"
     "a domain S of multivariate polynomials over R."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialFactorizationByRecursion|
  (progn
    (push '|PolynomialFactorizationByRecursion| *Packages*)
    (make-instance '|PolynomialFactorizationByRecursionType|)))

\end{chunk}

\subsection{PolynomialFactorizationByRecursionUnivariate}
\index[pkg]{PolynomialFactorizationByRecursionUnivariate!Domain}
\index[pkg]{Domain!PolynomialFactorizationByRecursionUnivariate}
\index[pkg]{PFBRU}
\begin{chunk}{defclass PolynomialFactorizationByRecursionUnivariateType}
(defclass |PolynomialFactorizationByRecursionUnivariateType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialFactorizationByRecursionUnivariate")
   (marker :initform 'package)
   (abbreviation :initform 'PFBRU)
   (comment :initform (list
     "PolynomialFactorizationByRecursionUnivariate"
     "R is a PolynomialFactorizationExplicit domain,"
     "S is univariate polynomials over R"
     "We are interested in handling SparseUnivariatePolynomials over"
     "S, is a variable we shall call z"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialFactorizationByRecursionUnivariate|
  (progn
    (push '|PolynomialFactorizationByRecursionUnivariate| *Packages*)
    (make-instance '|PolynomialFactorizationByRecursionUnivariateType|)))

\end{chunk}

\subsection{PolynomialFunctions2}
\index[pkg]{PolynomialFunctions2!Domain}
\index[pkg]{Domain!PolynomialFunctions2}
\index[pkg]{POLY2}
\begin{chunk}{defclass PolynomialFunctions2Type}
(defclass |PolynomialFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'POLY2)
   (comment :initform (list
     "This package takes a mapping between coefficient rings, and lifts"
     "it to a mapping between polynomials over those rings."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialFunctions2|
  (progn
    (push '|PolynomialFunctions2| *Packages*)
    (make-instance '|PolynomialFunctions2Type|)))

\end{chunk}

\subsection{PolynomialGcdPackage}
\index[pkg]{PolynomialGcdPackage!Domain}
\index[pkg]{Domain!PolynomialGcdPackage}
\index[pkg]{PGCD}
\begin{chunk}{defclass PolynomialGcdPackageType}
(defclass |PolynomialGcdPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialGcdPackage")
   (marker :initform 'package)
   (abbreviation :initform 'PGCD)
   (comment :initform (list
     "This package computes multivariate polynomial gcd's using"
     "a hensel lifting strategy. The constraint on the coefficient"
     "domain is imposed by the lifting strategy. It is assumed that"
     "the coefficient domain has the property that almost all specializations"
     "preserve the degree of the gcd."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialGcdPackage|
  (progn
    (push '|PolynomialGcdPackage| *Packages*)
    (make-instance '|PolynomialGcdPackageType|)))

\end{chunk}

\subsection{PolynomialInterpolation}
\index[pkg]{PolynomialInterpolation!Domain}
\index[pkg]{Domain!PolynomialInterpolation}
\index[pkg]{PINTERP}
\begin{chunk}{defclass PolynomialInterpolationType}
(defclass |PolynomialInterpolationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialInterpolation")
   (marker :initform 'package)
   (abbreviation :initform 'PINTERP)
   (comment :initform (list
     "This package exports interpolation algorithms"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialInterpolation|
  (progn
    (push '|PolynomialInterpolation| *Packages*)
    (make-instance '|PolynomialInterpolationType|)))

\end{chunk}

\subsection{PolynomialInterpolationAlgorithms}
\index[pkg]{PolynomialInterpolationAlgorithms!Domain}
\index[pkg]{Domain!PolynomialInterpolationAlgorithms}
\index[pkg]{PINTERPA}
\begin{chunk}{defclass PolynomialInterpolationAlgorithmsType}
(defclass |PolynomialInterpolationAlgorithmsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialInterpolationAlgorithms")
   (marker :initform 'package)
   (abbreviation :initform 'PINTERPA)
   (comment :initform (list
     "This package exports interpolation algorithms"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialInterpolationAlgorithms|
  (progn
    (push '|PolynomialInterpolationAlgorithms| *Packages*)
    (make-instance '|PolynomialInterpolationAlgorithmsType|)))

\end{chunk}

\subsection{PolynomialNumberTheoryFunctions}
\index[pkg]{PolynomialNumberTheoryFunctions!Domain}
\index[pkg]{Domain!PolynomialNumberTheoryFunctions}
\index[pkg]{PNTHEORY}
\begin{chunk}{defclass PolynomialNumberTheoryFunctionsType}
(defclass |PolynomialNumberTheoryFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialNumberTheoryFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'PNTHEORY)
   (comment :initform (list
     "This package provides various polynomial number theoretic functions"
     "over the integers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialNumberTheoryFunctions|
  (progn
    (push '|PolynomialNumberTheoryFunctions| *Packages*)
    (make-instance '|PolynomialNumberTheoryFunctionsType|)))

\end{chunk}

\subsection{PolynomialRoots}
\index[pkg]{PolynomialRoots!Domain}
\index[pkg]{Domain!PolynomialRoots}
\index[pkg]{POLYROOT}
\begin{chunk}{defclass PolynomialRootsType}
(defclass |PolynomialRootsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialRoots")
   (marker :initform 'package)
   (abbreviation :initform 'POLYROOT)
   (comment :initform (list
     "Computes n-th roots of quotients of multivariate polynomials"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialRoots|
  (progn
    (push '|PolynomialRoots| *Packages*)
    (make-instance '|PolynomialRootsType|)))

\end{chunk}

\subsection{PolynomialSetUtilitiesPackage}
\index[pkg]{PolynomialSetUtilitiesPackage!Domain}
\index[pkg]{Domain!PolynomialSetUtilitiesPackage}
\index[pkg]{PSETPK}
\begin{chunk}{defclass PolynomialSetUtilitiesPackageType}
(defclass |PolynomialSetUtilitiesPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialSetUtilitiesPackage")
   (marker :initform 'package)
   (abbreviation :initform 'PSETPK)
   (comment :initform (list
     "This package provides modest routines for polynomial system solving."
     "The aim of many of the operations of this package is to remove certain"
     "factors in some polynomials in order to avoid unnecessary computations"
     "in algorithms involving splitting techniques by partial factorization."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialSetUtilitiesPackage|
  (progn
    (push '|PolynomialSetUtilitiesPackage| *Packages*)
    (make-instance '|PolynomialSetUtilitiesPackageType|)))

\end{chunk}

\subsection{PolynomialSolveByFormulas}
\index[pkg]{PolynomialSolveByFormulas!Domain}
\index[pkg]{Domain!PolynomialSolveByFormulas}
\index[pkg]{SOLVEFOR}
\begin{chunk}{defclass PolynomialSolveByFormulasType}
(defclass |PolynomialSolveByFormulasType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialSolveByFormulas")
   (marker :initform 'package)
   (abbreviation :initform 'SOLVEFOR)
   (comment :initform (list
     "This package factors the formulas out of the general solve code,"
     "allowing their recursive use over different domains."
     "Care is taken to introduce few radicals so that radical extension"
     "domains can more easily simplify the results."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialSolveByFormulas|
  (progn
    (push '|PolynomialSolveByFormulas| *Packages*)
    (make-instance '|PolynomialSolveByFormulasType|)))

\end{chunk}

\subsection{PolynomialSquareFree}
\index[pkg]{PolynomialSquareFree!Domain}
\index[pkg]{Domain!PolynomialSquareFree}
\index[pkg]{PSQFR}
\begin{chunk}{defclass PolynomialSquareFreeType}
(defclass |PolynomialSquareFreeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialSquareFree")
   (marker :initform 'package)
   (abbreviation :initform 'PSQFR)
   (comment :initform (list
     "This package computes square-free decomposition of multivariate"
     "polynomials over a coefficient ring which is an arbitrary gcd domain."
     "The requirement on the coefficient domain guarantees that the"
     "content can be"
     "removed so that factors will be primitive as well as square-free."
     "Over an infinite ring of finite characteristic,it may not be possible to"
     "guarantee that the factors are square-free."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialSquareFree|
  (progn
    (push '|PolynomialSquareFree| *Packages*)
    (make-instance '|PolynomialSquareFreeType|)))

\end{chunk}

\subsection{PolynomialToUnivariatePolynomial}
\index[pkg]{PolynomialToUnivariatePolynomial!Domain}
\index[pkg]{Domain!PolynomialToUnivariatePolynomial}
\index[pkg]{POLY2UP}
\begin{chunk}{defclass PolynomialToUnivariatePolynomialType}
(defclass |PolynomialToUnivariatePolynomialType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialToUnivariatePolynomial")
   (marker :initform 'package)
   (abbreviation :initform 'POLY2UP)
   (comment :initform (list
     "This package is primarily to help the interpreter do coercions."
     "It allows you to view a polynomial as a"
     "univariate polynomial in one of its variables with"
     "coefficients which are again a polynomial in all the"
     "other variables."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialToUnivariatePolynomial|
  (progn
    (push '|PolynomialToUnivariatePolynomial| *Packages*)
    (make-instance '|PolynomialToUnivariatePolynomialType|)))

\end{chunk}

\subsection{PowerSeriesLimitPackage}
\index[pkg]{PowerSeriesLimitPackage!Domain}
\index[pkg]{Domain!PowerSeriesLimitPackage}
\index[pkg]{LIMITPS}
\begin{chunk}{defclass PowerSeriesLimitPackageType}
(defclass |PowerSeriesLimitPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PowerSeriesLimitPackage")
   (marker :initform 'package)
   (abbreviation :initform 'LIMITPS)
   (comment :initform (list
     "PowerSeriesLimitPackage implements limits of expressions"
     "in one or more variables as one of the variables approaches a"
     "limiting value.  Included are two-sided limits, left- and right-"
     "hand limits, and limits at plus or minus infinity."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PowerSeriesLimitPackage|
  (progn
    (push '|PowerSeriesLimitPackage| *Packages*)
    (make-instance '|PowerSeriesLimitPackageType|)))

\end{chunk}

\subsection{PrecomputedAssociatedEquations}
\index[pkg]{PrecomputedAssociatedEquations!Domain}
\index[pkg]{Domain!PrecomputedAssociatedEquations}
\index[pkg]{PREASSOC}
\begin{chunk}{defclass PrecomputedAssociatedEquationsType}
(defclass |PrecomputedAssociatedEquationsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PrecomputedAssociatedEquations")
   (marker :initform 'package)
   (abbreviation :initform 'PREASSOC)
   (comment :initform (list
     "PrecomputedAssociatedEquations stores some generic"
     "precomputations which speed up the computations of the"
     "associated equations needed for factoring operators."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PrecomputedAssociatedEquations|
  (progn
    (push '|PrecomputedAssociatedEquations| *Packages*)
    (make-instance '|PrecomputedAssociatedEquationsType|)))

\end{chunk}

\subsection{PrimitiveArrayFunctions2}
\index[pkg]{PrimitiveArrayFunctions2!Domain}
\index[pkg]{Domain!PrimitiveArrayFunctions2}
\index[pkg]{PRIMARR2}
\begin{chunk}{defclass PrimitiveArrayFunctions2Type}
(defclass |PrimitiveArrayFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PrimitiveArrayFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'PRIMARR2)
   (comment :initform (list
     "This package provides tools for operating on primitive arrays"
     "with unary and binary functions involving different underlying types"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PrimitiveArrayFunctions2|
  (progn
    (push '|PrimitiveArrayFunctions2| *Packages*)
    (make-instance '|PrimitiveArrayFunctions2Type|)))

\end{chunk}

\subsection{PrimitiveElement}
\index[pkg]{PrimitiveElement!Domain}
\index[pkg]{Domain!PrimitiveElement}
\index[pkg]{PRIMELT}
\begin{chunk}{defclass PrimitiveElementType}
(defclass |PrimitiveElementType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PrimitiveElement")
   (marker :initform 'package)
   (abbreviation :initform 'PRIMELT)
   (comment :initform (list
     "PrimitiveElement provides functions to compute primitive elements"
     "in algebraic extensions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PrimitiveElement|
  (progn
    (push '|PrimitiveElement| *Packages*)
    (make-instance '|PrimitiveElementType|)))

\end{chunk}

\subsection{PrimitiveRatDE}
\index[pkg]{PrimitiveRatDE!Domain}
\index[pkg]{Domain!PrimitiveRatDE}
\index[pkg]{ODEPRIM}
\begin{chunk}{defclass PrimitiveRatDEType}
(defclass |PrimitiveRatDEType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PrimitiveRatDE")
   (marker :initform 'package)
   (abbreviation :initform 'ODEPRIM)
   (comment :initform (list
     "PrimitiveRatDE provides functions for in-field solutions of linear"
     "ordinary differential equations, in the transcendental case."
     "The derivation to use is given by the parameter L."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PrimitiveRatDE|
  (progn
    (push '|PrimitiveRatDE| *Packages*)
    (make-instance '|PrimitiveRatDEType|)))

\end{chunk}

\subsection{PrimitiveRatRicDE}
\index[pkg]{PrimitiveRatRicDE!Domain}
\index[pkg]{Domain!PrimitiveRatRicDE}
\index[pkg]{ODEPRRIC}
\begin{chunk}{defclass PrimitiveRatRicDEType}
(defclass |PrimitiveRatRicDEType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PrimitiveRatRicDE")
   (marker :initform 'package)
   (abbreviation :initform 'ODEPRRIC)
   (comment :initform (list
     "In-field solution of Riccati equations, primitive case."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PrimitiveRatRicDE|
  (progn
    (push '|PrimitiveRatRicDE| *Packages*)
    (make-instance '|PrimitiveRatRicDEType|)))

\end{chunk}

\subsection{PrintPackage}
\index[pkg]{PrintPackage!Domain}
\index[pkg]{Domain!PrintPackage}
\index[pkg]{PRINT}
\begin{chunk}{defclass PrintPackageType}
(defclass |PrintPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PrintPackage")
   (marker :initform 'package)
   (abbreviation :initform 'PRINT)
   (comment :initform (list
     "PrintPackage provides a print function for output forms."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PrintPackage|
  (progn
    (push '|PrintPackage| *Packages*)
    (make-instance '|PrintPackageType|)))

\end{chunk}

\subsection{PseudoLinearNormalForm}
\index[pkg]{PseudoLinearNormalForm!Domain}
\index[pkg]{Domain!PseudoLinearNormalForm}
\index[pkg]{PSEUDLIN}
\begin{chunk}{defclass PseudoLinearNormalFormType}
(defclass |PseudoLinearNormalFormType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PseudoLinearNormalForm")
   (marker :initform 'package)
   (abbreviation :initform 'PSEUDLIN)
   (comment :initform (list
     "PseudoLinearNormalForm provides a function for computing a block-companion"
     "form for pseudo-linear operators."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PseudoLinearNormalForm|
  (progn
    (push '|PseudoLinearNormalForm| *Packages*)
    (make-instance '|PseudoLinearNormalFormType|)))

\end{chunk}

\subsection{PseudoRemainderSequence}
\index[pkg]{PseudoRemainderSequence!Domain}
\index[pkg]{Domain!PseudoRemainderSequence}
\index[pkg]{PRS}
\begin{chunk}{defclass PseudoRemainderSequenceType}
(defclass |PseudoRemainderSequenceType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PseudoRemainderSequence")
   (marker :initform 'package)
   (abbreviation :initform 'PRS)
   (comment :initform (list
     "This package contains some functions: discriminant, resultant,"
     "subResultantGcd, chainSubResultants, degreeSubResultant, lastSubResultant,"
     "resultantEuclidean, subResultantGcdEuclidean, semiSubResultantGcdEuclidean1,"
     "semiSubResultantGcdEuclidean2"
     "These procedures come from improvements of the subresultants algorithm."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PseudoRemainderSequence|
  (progn
    (push '|PseudoRemainderSequence| *Packages*)
    (make-instance '|PseudoRemainderSequenceType|)))

\end{chunk}

\subsection{PureAlgebraicIntegration}
\index[pkg]{PureAlgebraicIntegration!Domain}
\index[pkg]{Domain!PureAlgebraicIntegration}
\index[pkg]{INTPAF}
\begin{chunk}{defclass PureAlgebraicIntegrationType}
(defclass |PureAlgebraicIntegrationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PureAlgebraicIntegration")
   (marker :initform 'package)
   (abbreviation :initform 'INTPAF)
   (comment :initform (list
     "Integration of pure algebraic functions."
     "This package provides functions for integration, limited integration,"
     "extended integration and the risch differential equation for"
     "pure algebraic integrands."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PureAlgebraicIntegration|
  (progn
    (push '|PureAlgebraicIntegration| *Packages*)
    (make-instance '|PureAlgebraicIntegrationType|)))

\end{chunk}

\subsection{PureAlgebraicLODE}
\index[pkg]{PureAlgebraicLODE!Domain}
\index[pkg]{Domain!PureAlgebraicLODE}
\index[pkg]{ODEPAL}
\begin{chunk}{defclass PureAlgebraicLODEType}
(defclass |PureAlgebraicLODEType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PureAlgebraicLODE")
   (marker :initform 'package)
   (abbreviation :initform 'ODEPAL)
   (comment :initform (list
     "In-field solution of an linear ordinary differential equation,"
     "pure algebraic case."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PureAlgebraicLODE|
  (progn
    (push '|PureAlgebraicLODE| *Packages*)
    (make-instance '|PureAlgebraicLODEType|)))

\end{chunk}

\subsection{PushVariables}
\index[pkg]{PushVariables!Domain}
\index[pkg]{Domain!PushVariables}
\index[pkg]{PUSHVAR}
\begin{chunk}{defclass PushVariablesType}
(defclass |PushVariablesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PushVariables")
   (marker :initform 'package)
   (abbreviation :initform 'PUSHVAR)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PushVariables|
  (progn
    (push '|PushVariables| *Packages*)
    (make-instance '|PushVariablesType|)))

\end{chunk}

\section{Q}

\subsection{QuasiAlgebraicSet2}
\index[pkg]{QuasiAlgebraicSet2!Domain}
\index[pkg]{Domain!QuasiAlgebraicSet2}
\index[pkg]{QALGSET2}
\begin{chunk}{defclass QuasiAlgebraicSet2Type}
(defclass |QuasiAlgebraicSet2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "QuasiAlgebraicSet2")
   (marker :initform 'package)
   (abbreviation :initform 'QALGSET2)
   (comment :initform (list
     "QuasiAlgebraicSet2 adds a function radicalSimplify"
     "which uses IdealDecompositionPackage to simplify"
     "the representation of a quasi-algebraic set.  A quasi-algebraic set"
     "is the intersection of a Zariski"
     "closed set, defined as the common zeros of a given list of"
     "polynomials (the defining polynomials for equations), and a principal"
     "Zariski open set, defined as the complement of the common"
     "zeros of a polynomial f (the defining polynomial for the inequation)."
     "Quasi-algebraic sets are implemented in the domain"
     "QuasiAlgebraicSet, where two simplification routines are"
     "provided:"
     "idealSimplify and simplify."
     "The function"
     "radicalSimplify is added"
     "for comparison study only.  Because the domain"
     "IdealDecompositionPackage provides facilities for"
     "computing with radical ideals, it is necessary to restrict"
     "the ground ring to the domain Fraction Integer,"
     "and the polynomial ring to be of type"
     "DistributedMultivariatePolynomial."
     "The routine radicalSimplify uses these to compute groebner"
     "basis of radical ideals and"
     "is inefficient and restricted when compared to the"
     "two in QuasiAlgebraicSet."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |QuasiAlgebraicSet2|
  (progn
    (push '|QuasiAlgebraicSet2| *Packages*)
    (make-instance '|QuasiAlgebraicSet2Type|)))

\end{chunk}

\subsection{QuasiComponentPackage}
\index[pkg]{QuasiComponentPackage!Domain}
\index[pkg]{Domain!QuasiComponentPackage}
\index[pkg]{QCMPACK}
\begin{chunk}{defclass QuasiComponentPackageType}
(defclass |QuasiComponentPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "QuasiComponentPackage")
   (marker :initform 'package)
   (abbreviation :initform 'QCMPACK)
   (comment :initform (list
     "A package for removing redundant quasi-components and redundant"
     "branches when decomposing a variety by means of quasi-components"
     "of regular triangular sets."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |QuasiComponentPackage|
  (progn
    (push '|QuasiComponentPackage| *Packages*)
    (make-instance '|QuasiComponentPackageType|)))

\end{chunk}

\subsection{QuotientFieldCategoryFunctions2}
\index[pkg]{QuotientFieldCategoryFunctions2!Domain}
\index[pkg]{Domain!QuotientFieldCategoryFunctions2}
\index[pkg]{QFCAT2}
\begin{chunk}{defclass QuotientFieldCategoryFunctions2Type}
(defclass |QuotientFieldCategoryFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "QuotientFieldCategoryFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'QFCAT2)
   (comment :initform (list
     "This package extends a function between integral domains"
     "to a mapping between their quotient fields."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |QuotientFieldCategoryFunctions2|
  (progn
    (push '|QuotientFieldCategoryFunctions2| *Packages*)
    (make-instance '|QuotientFieldCategoryFunctions2Type|)))

\end{chunk}

\subsection{QuaternionCategoryFunctions2}
\index[pkg]{QuaternionCategoryFunctions2!Domain}
\index[pkg]{Domain!QuaternionCategoryFunctions2}
\index[pkg]{QUATCT2}
\begin{chunk}{defclass QuaternionCategoryFunctions2Type}
(defclass |QuaternionCategoryFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "QuaternionCategoryFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'QUATCT2)
   (comment :initform (list
     "QuaternionCategoryFunctions2 implements functions between"
     "two quaternion domains.  The function map is used by"
     "the system interpreter to coerce between quaternion types."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |QuaternionCategoryFunctions2|
  (progn
    (push '|QuaternionCategoryFunctions2| *Packages*)
    (make-instance '|QuaternionCategoryFunctions2Type|)))

\end{chunk}

\section{R}

\subsection{RadicalEigenPackage}
\index[pkg]{RadicalEigenPackage!Domain}
\index[pkg]{Domain!RadicalEigenPackage}
\index[pkg]{REP}
\begin{chunk}{defclass RadicalEigenPackageType}
(defclass |RadicalEigenPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RadicalEigenPackage")
   (marker :initform 'package)
   (abbreviation :initform 'REP)
   (comment :initform (list
     "Package for the computation of eigenvalues and eigenvectors."
     "This package works for matrices with coefficients which are"
     "rational functions over the integers."
     "(see Fraction Polynomial Integer)."
     "The eigenvalues and eigenvectors are expressed in terms of radicals."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RadicalEigenPackage|
  (progn
    (push '|RadicalEigenPackage| *Packages*)
    (make-instance '|RadicalEigenPackageType|)))

\end{chunk}

\subsection{RadicalSolvePackage}
\index[pkg]{RadicalSolvePackage!Domain}
\index[pkg]{Domain!RadicalSolvePackage}
\index[pkg]{SOLVERAD}
\begin{chunk}{defclass RadicalSolvePackageType}
(defclass |RadicalSolvePackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RadicalSolvePackage")
   (marker :initform 'package)
   (abbreviation :initform 'SOLVERAD)
   (comment :initform (list
     "This package tries to find solutions"
     "expressed in terms of radicals for systems of equations"
     "of rational functions with coefficients in an integral domain R."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RadicalSolvePackage|
  (progn
    (push '|RadicalSolvePackage| *Packages*)
    (make-instance '|RadicalSolvePackageType|)))

\end{chunk}

\subsection{RadixUtilities}
\index[pkg]{RadixUtilities!Domain}
\index[pkg]{Domain!RadixUtilities}
\index[pkg]{RADUTIL}
\begin{chunk}{defclass RadixUtilitiesType}
(defclass |RadixUtilitiesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RadixUtilities")
   (marker :initform 'package)
   (abbreviation :initform 'RADUTIL)
   (comment :initform (list
     "This package provides tools for creating radix expansions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RadixUtilities|
  (progn
    (push '|RadixUtilities| *Packages*)
    (make-instance '|RadixUtilitiesType|)))

\end{chunk}

\subsection{RandomDistributions}
\index[pkg]{RandomDistributions!Domain}
\index[pkg]{Domain!RandomDistributions}
\index[pkg]{RDIST}
\begin{chunk}{defclass RandomDistributionsType}
(defclass |RandomDistributionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RandomDistributions")
   (marker :initform 'package)
   (abbreviation :initform 'RDIST)
   (comment :initform (list
     "This package exports random distributions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RandomDistributions|
  (progn
    (push '|RandomDistributions| *Packages*)
    (make-instance '|RandomDistributionsType|)))

\end{chunk}

\subsection{RandomFloatDistributions}
\index[pkg]{RandomFloatDistributions!Domain}
\index[pkg]{Domain!RandomFloatDistributions}
\index[pkg]{RFDIST}
\begin{chunk}{defclass RandomFloatDistributionsType}
(defclass |RandomFloatDistributionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RandomFloatDistributions")
   (marker :initform 'package)
   (abbreviation :initform 'RFDIST)
   (comment :initform (list
     "This package exports random floating-point distributions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RandomFloatDistributions|
  (progn
    (push '|RandomFloatDistributions| *Packages*)
    (make-instance '|RandomFloatDistributionsType|)))

\end{chunk}

\subsection{RandomIntegerDistributions}
\index[pkg]{RandomIntegerDistributions!Domain}
\index[pkg]{Domain!RandomIntegerDistributions}
\index[pkg]{RIDIST}
\begin{chunk}{defclass RandomIntegerDistributionsType}
(defclass |RandomIntegerDistributionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RandomIntegerDistributions")
   (marker :initform 'package)
   (abbreviation :initform 'RIDIST)
   (comment :initform (list
     "This package exports integer distributions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RandomIntegerDistributions|
  (progn
    (push '|RandomIntegerDistributions| *Packages*)
    (make-instance '|RandomIntegerDistributionsType|)))

\end{chunk}

\subsection{RandomNumberSource}
\index[pkg]{RandomNumberSource!Domain}
\index[pkg]{Domain!RandomNumberSource}
\index[pkg]{RANDSRC}
\begin{chunk}{defclass RandomNumberSourceType}
(defclass |RandomNumberSourceType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RandomNumberSource")
   (marker :initform 'package)
   (abbreviation :initform 'RANDSRC)
   (comment :initform (list
     "Random number generators."
     "All random numbers used in the system should originate from"
     "the same generator.  This package is intended to be the source."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RandomNumberSource|
  (progn
    (push '|RandomNumberSource| *Packages*)
    (make-instance '|RandomNumberSourceType|)))

\end{chunk}

\subsection{RationalFactorize}
\index[pkg]{RationalFactorize!Domain}
\index[pkg]{Domain!RationalFactorize}
\index[pkg]{RATFACT}
\begin{chunk}{defclass RationalFactorizeType}
(defclass |RationalFactorizeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RationalFactorize")
   (marker :initform 'package)
   (abbreviation :initform 'RATFACT)
   (comment :initform (list
     "Factorization of extended polynomials with rational coefficients."
     "This package implements factorization of extended polynomials"
     "whose coefficients are rational numbers. It does this by taking the"
     "lcm of the coefficients of the polynomial and creating a polynomial"
     "with integer coefficients. The algorithm in"
     "GaloisGroupFactorizer is then"
     "used to factor the integer polynomial. The result is normalized"
     "with respect to the original lcm of the denominators."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RationalFactorize|
  (progn
    (push '|RationalFactorize| *Packages*)
    (make-instance '|RationalFactorizeType|)))

\end{chunk}

\subsection{RationalFunction}
\index[pkg]{RationalFunction!Domain}
\index[pkg]{Domain!RationalFunction}
\index[pkg]{RF}
\begin{chunk}{defclass RationalFunctionType}
(defclass |RationalFunctionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RationalFunction")
   (marker :initform 'package)
   (abbreviation :initform 'RF)
   (comment :initform (list
     "Utilities that provide the same top-level manipulations on"
     "fractions than on polynomials."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RationalFunction|
  (progn
    (push '|RationalFunction| *Packages*)
    (make-instance '|RationalFunctionType|)))

\end{chunk}

\subsection{RationalFunctionDefiniteIntegration}
\index[pkg]{RationalFunctionDefiniteIntegration!Domain}
\index[pkg]{Domain!RationalFunctionDefiniteIntegration}
\index[pkg]{DEFINTRF}
\begin{chunk}{defclass RationalFunctionDefiniteIntegrationType}
(defclass |RationalFunctionDefiniteIntegrationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RationalFunctionDefiniteIntegration")
   (marker :initform 'package)
   (abbreviation :initform 'DEFINTRF)
   (comment :initform (list
     "Definite integration of rational functions."
     "RationalFunctionDefiniteIntegration provides functions to"
     "compute definite integrals of rational functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RationalFunctionDefiniteIntegration|
  (progn
    (push '|RationalFunctionDefiniteIntegration| *Packages*)
    (make-instance '|RationalFunctionDefiniteIntegrationType|)))

\end{chunk}

\subsection{RationalFunctionFactor}
\index[pkg]{RationalFunctionFactor!Domain}
\index[pkg]{Domain!RationalFunctionFactor}
\index[pkg]{RFFACT}
\begin{chunk}{defclass RationalFunctionFactorType}
(defclass |RationalFunctionFactorType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RationalFunctionFactor")
   (marker :initform 'package)
   (abbreviation :initform 'RFFACT)
   (comment :initform (list
     "Factorization of univariate polynomials with coefficients which"
     "are rational functions with integer coefficients."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RationalFunctionFactor|
  (progn
    (push '|RationalFunctionFactor| *Packages*)
    (make-instance '|RationalFunctionFactorType|)))

\end{chunk}

\subsection{RationalFunctionFactorizer}
\index[pkg]{RationalFunctionFactorizer!Domain}
\index[pkg]{Domain!RationalFunctionFactorizer}
\index[pkg]{RFFACTOR}
\begin{chunk}{defclass RationalFunctionFactorizerType}
(defclass |RationalFunctionFactorizerType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RationalFunctionFactorizer")
   (marker :initform 'package)
   (abbreviation :initform 'RFFACTOR)
   (comment :initform (list
     "\spadtype{RationalFunctionFactorizer} contains the factor function"
     "(called factorFraction) which factors fractions of polynomials by factoring"
     "the numerator and denominator. Since any non zero fraction is a unit"
     "the usual factor operation will just return the original fraction."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RationalFunctionFactorizer|
  (progn
    (push '|RationalFunctionFactorizer| *Packages*)
    (make-instance '|RationalFunctionFactorizerType|)))

\end{chunk}

\subsection{RationalFunctionIntegration}
\index[pkg]{RationalFunctionIntegration!Domain}
\index[pkg]{Domain!RationalFunctionIntegration}
\index[pkg]{INTRF}
\begin{chunk}{defclass RationalFunctionIntegrationType}
(defclass |RationalFunctionIntegrationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RationalFunctionIntegration")
   (marker :initform 'package)
   (abbreviation :initform 'INTRF)
   (comment :initform (list
     "This package provides functions for the integration of rational functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RationalFunctionIntegration|
  (progn
    (push '|RationalFunctionIntegration| *Packages*)
    (make-instance '|RationalFunctionIntegrationType|)))

\end{chunk}

\subsection{RationalFunctionLimitPackage}
\index[pkg]{RationalFunctionLimitPackage!Domain}
\index[pkg]{Domain!RationalFunctionLimitPackage}
\index[pkg]{LIMITRF}
\begin{chunk}{defclass RationalFunctionLimitPackageType}
(defclass |RationalFunctionLimitPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RationalFunctionLimitPackage")
   (marker :initform 'package)
   (abbreviation :initform 'LIMITRF)
   (comment :initform (list
     "Computation of limits for rational functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RationalFunctionLimitPackage|
  (progn
    (push '|RationalFunctionLimitPackage| *Packages*)
    (make-instance '|RationalFunctionLimitPackageType|)))

\end{chunk}

\subsection{RationalFunctionSign}
\index[pkg]{RationalFunctionSign!Domain}
\index[pkg]{Domain!RationalFunctionSign}
\index[pkg]{SIGNRF}
\begin{chunk}{defclass RationalFunctionSignType}
(defclass |RationalFunctionSignType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RationalFunctionSign")
   (marker :initform 'package)
   (abbreviation :initform 'SIGNRF)
   (comment :initform (list
     "Find the sign of a rational function around a point or infinity."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RationalFunctionSign|
  (progn
    (push '|RationalFunctionSign| *Packages*)
    (make-instance '|RationalFunctionSignType|)))

\end{chunk}

\subsection{RationalFunctionSum}
\index[pkg]{RationalFunctionSum!Domain}
\index[pkg]{Domain!RationalFunctionSum}
\index[pkg]{SUMRF}
\begin{chunk}{defclass RationalFunctionSumType}
(defclass |RationalFunctionSumType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RationalFunctionSum")
   (marker :initform 'package)
   (abbreviation :initform 'SUMRF)
   (comment :initform (list
     "Computes sums of rational functions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RationalFunctionSum|
  (progn
    (push '|RationalFunctionSum| *Packages*)
    (make-instance '|RationalFunctionSumType|)))

\end{chunk}

\subsection{RationalIntegration}
\index[pkg]{RationalIntegration!Domain}
\index[pkg]{Domain!RationalIntegration}
\index[pkg]{INTRAT}
\begin{chunk}{defclass RationalIntegrationType}
(defclass |RationalIntegrationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RationalIntegration")
   (marker :initform 'package)
   (abbreviation :initform 'INTRAT)
   (comment :initform (list
     "This package provides functions for the base case of the Risch algorithm."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RationalIntegration|
  (progn
    (push '|RationalIntegration| *Packages*)
    (make-instance '|RationalIntegrationType|)))

\end{chunk}

\subsection{RationalInterpolation}
\index[pkg]{RationalInterpolation!Domain}
\index[pkg]{Domain!RationalInterpolation}
\index[pkg]{RINTERP}
\begin{chunk}{defclass RationalInterpolationType}
(defclass |RationalInterpolationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RationalInterpolation")
   (marker :initform 'package)
   (abbreviation :initform 'RINTERP)
   (comment :initform (list
     "This package exports rational interpolation algorithms"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RationalInterpolation|
  (progn
    (push '|RationalInterpolation| *Packages*)
    (make-instance '|RationalInterpolationType|)))

\end{chunk}

\subsection{RationalLODE}
\index[pkg]{RationalLODE!Domain}
\index[pkg]{Domain!RationalLODE}
\index[pkg]{ODERAT}
\begin{chunk}{defclass RationalLODEType}
(defclass |RationalLODEType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RationalLODE")
   (marker :initform 'package)
   (abbreviation :initform 'ODERAT)
   (comment :initform (list
     "RationalLODE provides functions for in-field solutions of linear"
     "ordinary differential equations, in the rational case."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RationalLODE|
  (progn
    (push '|RationalLODE| *Packages*)
    (make-instance '|RationalLODEType|)))

\end{chunk}

\subsection{RationalRetractions}
\index[pkg]{RationalRetractions!Domain}
\index[pkg]{Domain!RationalRetractions}
\index[pkg]{RATRET}
\begin{chunk}{defclass RationalRetractionsType}
(defclass |RationalRetractionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RationalRetractions")
   (marker :initform 'package)
   (abbreviation :initform 'RATRET)
   (comment :initform (list
     "Rational number testing and retraction functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RationalRetractions|
  (progn
    (push '|RationalRetractions| *Packages*)
    (make-instance '|RationalRetractionsType|)))

\end{chunk}

\subsection{RationalRicDE}
\index[pkg]{RationalRicDE!Domain}
\index[pkg]{Domain!RationalRicDE}
\index[pkg]{ODERTRIC}
\begin{chunk}{defclass RationalRicDEType}
(defclass |RationalRicDEType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RationalRicDE")
   (marker :initform 'package)
   (abbreviation :initform 'ODERTRIC)
   (comment :initform (list
     "In-field solution of Riccati equations, rational case."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RationalRicDE|
  (progn
    (push '|RationalRicDE| *Packages*)
    (make-instance '|RationalRicDEType|)))

\end{chunk}

\subsection{RationalUnivariateRepresentationPackage}
\index[pkg]{RationalUnivariateRepresentationPackage!Domain}
\index[pkg]{Domain!RationalUnivariateRepresentationPackage}
\index[pkg]{RURPK}
\begin{chunk}{defclass RationalUnivariateRepresentationPackageType}
(defclass |RationalUnivariateRepresentationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RationalUnivariateRepresentationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'RURPK)
   (comment :initform (list
     "A package for computing the rational univariate representation"
     "of a zero-dimensional algebraic variety given by a regular"
     "triangular set. This package is essentially an interface for the"
     "InternalRationalUnivariateRepresentationPackage constructor."
     "It is used in the ZeroDimensionalSolvePackage"
     "for solving polynomial systems with finitely many solutions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RationalUnivariateRepresentationPackage|
  (progn
    (push '|RationalUnivariateRepresentationPackage| *Packages*)
    (make-instance '|RationalUnivariateRepresentationPackageType|)))

\end{chunk}

\subsection{RealPolynomialUtilitiesPackage}
\index[pkg]{RealPolynomialUtilitiesPackage!Domain}
\index[pkg]{Domain!RealPolynomialUtilitiesPackage}
\index[pkg]{POLUTIL}
\begin{chunk}{defclass RealPolynomialUtilitiesPackageType}
(defclass |RealPolynomialUtilitiesPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RealPolynomialUtilitiesPackage")
   (marker :initform 'package)
   (abbreviation :initform 'POLUTIL)
   (comment :initform (list
     "RealPolynomialUtilitiesPackage provides common functions used"
     "by interval coding."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RealPolynomialUtilitiesPackage|
  (progn
    (push '|RealPolynomialUtilitiesPackage| *Packages*)
    (make-instance '|RealPolynomialUtilitiesPackageType|)))

\end{chunk}

\subsection{RealSolvePackage}
\index[pkg]{RealSolvePackage!Domain}
\index[pkg]{Domain!RealSolvePackage}
\index[pkg]{REALSOLV}
\begin{chunk}{defclass RealSolvePackageType}
(defclass |RealSolvePackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RealSolvePackage")
   (marker :initform 'package)
   (abbreviation :initform 'REALSOLV)
   (comment :initform (list
     "This package provides numerical solutions of systems of"
     "polynomial equations for use in ACPLOT"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RealSolvePackage|
  (progn
    (push '|RealSolvePackage| *Packages*)
    (make-instance '|RealSolvePackageType|)))

\end{chunk}

\subsection{RealZeroPackage}
\index[pkg]{RealZeroPackage!Domain}
\index[pkg]{Domain!RealZeroPackage}
\index[pkg]{REAL0}
\begin{chunk}{defclass RealZeroPackageType}
(defclass |RealZeroPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RealZeroPackage")
   (marker :initform 'package)
   (abbreviation :initform 'REAL0)
   (comment :initform (list
     "This package provides functions for finding the real zeros"
     "of univariate polynomials over the integers to arbitrary user-specified"
     "precision. The results are returned as a list of"
     "isolating intervals which are expressed as records with"
     "'left' and 'right' rational number components."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RealZeroPackage|
  (progn
    (push '|RealZeroPackage| *Packages*)
    (make-instance '|RealZeroPackageType|)))

\end{chunk}

\subsection{RealZeroPackageQ}
\index[pkg]{RealZeroPackageQ!Domain}
\index[pkg]{Domain!RealZeroPackageQ}
\index[pkg]{REAL0Q}
\begin{chunk}{defclass RealZeroPackageQType}
(defclass |RealZeroPackageQType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RealZeroPackageQ")
   (marker :initform 'package)
   (abbreviation :initform 'REAL0Q)
   (comment :initform (list
     "This package provides functions for finding the real zeros of univariate"
     "polynomials over the rational numbers to arbitrary user-specified"
     "precision. The results are returned as a list of isolating intervals,"
     "expressed as records with 'left' and 'right' rational number components."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RealZeroPackageQ|
  (progn
    (push '|RealZeroPackageQ| *Packages*)
    (make-instance '|RealZeroPackageQType|)))

\end{chunk}

\subsection{RectangularMatrixCategoryFunctions2}
\index[pkg]{RectangularMatrixCategoryFunctions2!Domain}
\index[pkg]{Domain!RectangularMatrixCategoryFunctions2}
\index[pkg]{RMCAT2}
\begin{chunk}{defclass RectangularMatrixCategoryFunctions2Type}
(defclass |RectangularMatrixCategoryFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RectangularMatrixCategoryFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'RMCAT2)
   (comment :initform (list
     "RectangularMatrixCategoryFunctions2 provides functions between"
     "two matrix domains.  The functions provided are map and"
     "reduce."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RectangularMatrixCategoryFunctions2|
  (progn
    (push '|RectangularMatrixCategoryFunctions2| *Packages*)
    (make-instance '|RectangularMatrixCategoryFunctions2Type|)))

\end{chunk}

\subsection{RecurrenceOperator}
\index[pkg]{RecurrenceOperator!Domain}
\index[pkg]{Domain!RecurrenceOperator}
\index[pkg]{RECOP}
\begin{chunk}{defclass RecurrenceOperatorType}
(defclass |RecurrenceOperatorType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RecurrenceOperator")
   (marker :initform 'package)
   (abbreviation :initform 'RECOP)
   (comment :initform (list
     "This package provides an operator for the n-th term of a recurrence and an"
     "operator for the coefficient of x^n in a function specified by a functional"
     "equation."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RecurrenceOperator|
  (progn
    (push '|RecurrenceOperator| *Packages*)
    (make-instance '|RecurrenceOperatorType|)))

\end{chunk}

\subsection{ReducedDivisor}
\index[pkg]{ReducedDivisor!Domain}
\index[pkg]{Domain!ReducedDivisor}
\index[pkg]{RDIV}
\begin{chunk}{defclass ReducedDivisorType}
(defclass |ReducedDivisorType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ReducedDivisor")
   (marker :initform 'package)
   (abbreviation :initform 'RDIV)
   (comment :initform (list
     "Finds the order of a divisor over a finite field"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ReducedDivisor|
  (progn
    (push '|ReducedDivisor| *Packages*)
    (make-instance '|ReducedDivisorType|)))

\end{chunk}

\subsection{ReduceLODE}
\index[pkg]{ReduceLODE!Domain}
\index[pkg]{Domain!ReduceLODE}
\index[pkg]{ODERED}
\begin{chunk}{defclass ReduceLODEType}
(defclass |ReduceLODEType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ReduceLODE")
   (marker :initform 'package)
   (abbreviation :initform 'ODERED)
   (comment :initform (list
     "Elimination of an algebraic from the coefficentss"
     "of a linear ordinary differential equation."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ReduceLODE|
  (progn
    (push '|ReduceLODE| *Packages*)
    (make-instance '|ReduceLODEType|)))

\end{chunk}

\subsection{ReductionOfOrder}
\index[pkg]{ReductionOfOrder!Domain}
\index[pkg]{Domain!ReductionOfOrder}
\index[pkg]{REDORDER}
\begin{chunk}{defclass ReductionOfOrderType}
(defclass |ReductionOfOrderType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ReductionOfOrder")
   (marker :initform 'package)
   (abbreviation :initform 'REDORDER)
   (comment :initform (list
     "ReductionOfOrder provides"
     "functions for reducing the order of linear ordinary differential equations"
     "once some solutions are known."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ReductionOfOrder|
  (progn
    (push '|ReductionOfOrder| *Packages*)
    (make-instance '|ReductionOfOrderType|)))

\end{chunk}

\subsection{RegularSetDecompositionPackage}
\index[pkg]{RegularSetDecompositionPackage!Domain}
\index[pkg]{Domain!RegularSetDecompositionPackage}
\index[pkg]{RSDCMPK}
\begin{chunk}{defclass RegularSetDecompositionPackageType}
(defclass |RegularSetDecompositionPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RegularSetDecompositionPackage")
   (marker :initform 'package)
   (abbreviation :initform 'RSDCMPK)
   (comment :initform (list
     "A package providing a new algorithm for solving polynomial systems"
     "by means of regular chains. Two ways of solving are proposed:"
     "in the sense of Zariski closure (like in Kalkbrener's algorithm)"
     "or in the sense of the regular zeros (like in Wu, Wang or Lazard"
     "methods). This algorithm is valid for any type"
     "of regular set. It does not care about the way a polynomial is"
     "added in an regular set, or how two quasi-components are compared"
     "(by an inclusion-test), or how the invertibility test is made in"
     "the tower of simple extensions associated with a regular set."
     "These operations are realized respectively by the domain TS"
     "and the packages"
     "QCMPACK(R,E,V,P,TS) and RSETGCD(R,E,V,P,TS)."
     "The same way it does not care about the way univariate polynomial"
     "gcd (with coefficients in the tower of simple extensions associated"
     "with a regular set) are computed. The only requirement is that these"
     "gcd need to have invertible initials (normalized or not)."
     "WARNING. There is no need for a user to call directly any operation"
     "of this package since they can be accessed by the domain TS."
     "Thus, the operations of this package are not documented."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RegularSetDecompositionPackage|
  (progn
    (push '|RegularSetDecompositionPackage| *Packages*)
    (make-instance '|RegularSetDecompositionPackageType|)))

\end{chunk}

\subsection{RegularTriangularSetGcdPackage}
\index[pkg]{RegularTriangularSetGcdPackage!Domain}
\index[pkg]{Domain!RegularTriangularSetGcdPackage}
\index[pkg]{RSETGCD}
\begin{chunk}{defclass RegularTriangularSetGcdPackageType}
(defclass |RegularTriangularSetGcdPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RegularTriangularSetGcdPackage")
   (marker :initform 'package)
   (abbreviation :initform 'RSETGCD)
   (comment :initform (list
     "An internal package for computing gcds and resultants of univariate"
     "polynomials with coefficients in a tower of simple extensions of a field."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RegularTriangularSetGcdPackage|
  (progn
    (push '|RegularTriangularSetGcdPackage| *Packages*)
    (make-instance '|RegularTriangularSetGcdPackageType|)))

\end{chunk}

\subsection{RepeatedDoubling}
\index[pkg]{RepeatedDoubling!Domain}
\index[pkg]{Domain!RepeatedDoubling}
\index[pkg]{REPDB}
\begin{chunk}{defclass RepeatedDoublingType}
(defclass |RepeatedDoublingType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RepeatedDoubling")
   (marker :initform 'package)
   (abbreviation :initform 'REPDB)
   (comment :initform (list
     "Implements multiplication by repeated addition"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RepeatedDoubling|
  (progn
    (push '|RepeatedDoubling| *Packages*)
    (make-instance '|RepeatedDoublingType|)))

\end{chunk}

\subsection{RepeatedSquaring}
\index[pkg]{RepeatedSquaring!Domain}
\index[pkg]{Domain!RepeatedSquaring}
\index[pkg]{REPSQ}
\begin{chunk}{defclass RepeatedSquaringType}
(defclass |RepeatedSquaringType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RepeatedSquaring")
   (marker :initform 'package)
   (abbreviation :initform 'REPSQ)
   (comment :initform (list
     "Implements exponentiation by repeated squaring"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RepeatedSquaring|
  (progn
    (push '|RepeatedSquaring| *Packages*)
    (make-instance '|RepeatedSquaringType|)))

\end{chunk}

\subsection{RepresentationPackage1}
\index[pkg]{RepresentationPackage1!Domain}
\index[pkg]{Domain!RepresentationPackage1}
\index[pkg]{REP1}
\begin{chunk}{defclass RepresentationPackage1Type}
(defclass |RepresentationPackage1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RepresentationPackage1")
   (marker :initform 'package)
   (abbreviation :initform 'REP1)
   (comment :initform (list
     "RepresentationPackage1 provides functions for representation theory"
     "for finite groups and algebras."
     "The package creates permutation representations and uses tensor products"
     "and its symmetric and antisymmetric components to create new"
     "representations of larger degree from given ones."
     "Note that instead of having parameters from Permutation"
     "this package allows list notation of permutations as well:"
     "for example [1,4,3,2] denotes permutes 2 and 4 and fixes 1 and 3."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RepresentationPackage1|
  (progn
    (push '|RepresentationPackage1| *Packages*)
    (make-instance '|RepresentationPackage1Type|)))

\end{chunk}

\subsection{RepresentationPackage2}
\index[pkg]{RepresentationPackage2!Domain}
\index[pkg]{Domain!RepresentationPackage2}
\index[pkg]{REP2}
\begin{chunk}{defclass RepresentationPackage2Type}
(defclass |RepresentationPackage2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RepresentationPackage2")
   (marker :initform 'package)
   (abbreviation :initform 'REP2)
   (comment :initform (list
     "RepresentationPackage2 provides functions for working with"
     "modular representations of finite groups and algebra."
     "The routines in this package are created, using ideas of R. Parker,"
     "(the meat-Axe) to get smaller representations from bigger ones,"
     "finding sub- and factormodules, or to show, that such the"
     "representations are irreducible."
     "Note that most functions are randomized functions of Las Vegas type"
     "every answer is correct, but with small probability"
     "the algorithm fails to get an answer."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RepresentationPackage2|
  (progn
    (push '|RepresentationPackage2| *Packages*)
    (make-instance '|RepresentationPackage2Type|)))

\end{chunk}

\subsection{ResolveLatticeCompletion}
\index[pkg]{ResolveLatticeCompletion!Domain}
\index[pkg]{Domain!ResolveLatticeCompletion}
\index[pkg]{RESLATC}
\begin{chunk}{defclass ResolveLatticeCompletionType}
(defclass |ResolveLatticeCompletionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ResolveLatticeCompletion")
   (marker :initform 'package)
   (abbreviation :initform 'RESLATC)
   (comment :initform (list
     "This package provides coercions for the special types Exit"
     "and Void."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ResolveLatticeCompletion|
  (progn
    (push '|ResolveLatticeCompletion| *Packages*)
    (make-instance '|ResolveLatticeCompletionType|)))

\end{chunk}

\subsection{RetractSolvePackage}
\index[pkg]{RetractSolvePackage!Domain}
\index[pkg]{Domain!RetractSolvePackage}
\index[pkg]{RETSOL}
\begin{chunk}{defclass RetractSolvePackageType}
(defclass |RetractSolvePackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RetractSolvePackage")
   (marker :initform 'package)
   (abbreviation :initform 'RETSOL)
   (comment :initform (list
     "RetractSolvePackage is an interface to SystemSolvePackage"
     "that attempts to retract the coefficients of the equations before"
     "solving."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RetractSolvePackage|
  (progn
    (push '|RetractSolvePackage| *Packages*)
    (make-instance '|RetractSolvePackageType|)))

\end{chunk}

\subsection{RootsFindingPackage}
\index[pkg]{RootsFindingPackage!Domain}
\index[pkg]{Domain!RootsFindingPackage}
\index[pkg]{RFP}
\begin{chunk}{defclass RootsFindingPackageType}
(defclass |RootsFindingPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RootsFindingPackage")
   (marker :initform 'package)
   (abbreviation :initform 'RFP)
   (comment :initform (list
     "This pacackage finds all the roots of a polynomial. If the constant field is"
     "not large enough then it returns the list of found zeros and the degree"
     "of the extension need to find the other roots missing. If the return"
     "degree is 1 then all the roots have been found. If 0 is return"
     "for the extension degree then there are an infinite number of zeros,"
     "that is you ask for the zeroes of 0. In the case of infinite field"
     "a list of all found zeros is kept and for each other call of a function"
     "that finds zeroes, a check is made on that list; this is to keep"
     "a kind of 'canonical' representation of the elements."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RootsFindingPackage|
  (progn
    (push '|RootsFindingPackage| *Packages*)
    (make-instance '|RootsFindingPackageType|)))

\end{chunk}

\section{S}

\subsection{SAERationalFunctionAlgFactor}
\index[pkg]{SAERationalFunctionAlgFactor!Domain}
\index[pkg]{Domain!SAERationalFunctionAlgFactor}
\index[pkg]{SAERFFC}
\begin{chunk}{defclass SAERationalFunctionAlgFactorType}
(defclass |SAERationalFunctionAlgFactorType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SAERationalFunctionAlgFactor")
   (marker :initform 'package)
   (abbreviation :initform 'SAERFFC)
   (comment :initform (list
     "Factorization of univariate polynomials with coefficients in an"
     "algebraic extension of \spadtype{Fraction Polynomial Integer}."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SAERationalFunctionAlgFactor|
  (progn
    (push '|SAERationalFunctionAlgFactor| *Packages*)
    (make-instance '|SAERationalFunctionAlgFactorType|)))

\end{chunk}

\subsection{ScriptFormulaFormat1}
\index[pkg]{ScriptFormulaFormat1!Domain}
\index[pkg]{Domain!ScriptFormulaFormat1}
\index[pkg]{FORMULA1}
\begin{chunk}{defclass ScriptFormulaFormat1Type}
(defclass |ScriptFormulaFormat1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ScriptFormulaFormat1")
   (marker :initform 'package)
   (abbreviation :initform 'FORMULA1)
   (comment :initform (list
     "ScriptFormulaFormat1 provides a utility coercion for"
     "changing to SCRIPT formula format anything that has a coercion to"
     "the standard output format."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ScriptFormulaFormat1|
  (progn
    (push '|ScriptFormulaFormat1| *Packages*)
    (make-instance '|ScriptFormulaFormat1Type|)))

\end{chunk}

\subsection{SegmentBindingFunctions2}
\index[pkg]{SegmentBindingFunctions2!Domain}
\index[pkg]{Domain!SegmentBindingFunctions2}
\index[pkg]{SEGBIND2}
\begin{chunk}{defclass SegmentBindingFunctions2Type}
(defclass |SegmentBindingFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SegmentBindingFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'SEGBIND2)
   (comment :initform (list
     "This package provides operations for mapping functions onto"
     "SegmentBindings."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SegmentBindingFunctions2|
  (progn
    (push '|SegmentBindingFunctions2| *Packages*)
    (make-instance '|SegmentBindingFunctions2Type|)))

\end{chunk}

\subsection{SegmentFunctions2}
\index[pkg]{SegmentFunctions2!Domain}
\index[pkg]{Domain!SegmentFunctions2}
\index[pkg]{SEG2}
\begin{chunk}{defclass SegmentFunctions2Type}
(defclass |SegmentFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SegmentFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'SEG2)
   (comment :initform (list
     "This package provides operations for mapping functions onto segments."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SegmentFunctions2|
  (progn
    (push '|SegmentFunctions2| *Packages*)
    (make-instance '|SegmentFunctions2Type|)))

\end{chunk}

\subsection{SimpleAlgebraicExtensionAlgFactor}
\index[pkg]{SimpleAlgebraicExtensionAlgFactor!Domain}
\index[pkg]{Domain!SimpleAlgebraicExtensionAlgFactor}
\index[pkg]{SAEFACT}
\begin{chunk}{defclass SimpleAlgebraicExtensionAlgFactorType}
(defclass |SimpleAlgebraicExtensionAlgFactorType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SimpleAlgebraicExtensionAlgFactor")
   (marker :initform 'package)
   (abbreviation :initform 'SAEFACT)
   (comment :initform (list
     "Factorization of univariate polynomials with coefficients in an"
     "algebraic extension of the rational numbers (Fraction Integer)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SimpleAlgebraicExtensionAlgFactor|
  (progn
    (push '|SimpleAlgebraicExtensionAlgFactor| *Packages*)
    (make-instance '|SimpleAlgebraicExtensionAlgFactorType|)))

\end{chunk}

\subsection{SimplifyAlgebraicNumberConvertPackage}
\index[pkg]{SimplifyAlgebraicNumberConvertPackage!Domain}
\index[pkg]{Domain!SimplifyAlgebraicNumberConvertPackage}
\index[pkg]{SIMPAN}
\begin{chunk}{defclass SimplifyAlgebraicNumberConvertPackageType}
(defclass |SimplifyAlgebraicNumberConvertPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SimplifyAlgebraicNumberConvertPackage")
   (marker :initform 'package)
   (abbreviation :initform 'SIMPAN)
   (comment :initform (list
     "Package to allow simplify to be called on AlgebraicNumbers"
     "by converting to EXPR(INT)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SimplifyAlgebraicNumberConvertPackage|
  (progn
    (push '|SimplifyAlgebraicNumberConvertPackage| *Packages*)
    (make-instance '|SimplifyAlgebraicNumberConvertPackageType|)))

\end{chunk}

\subsection{SmithNormalForm}
\index[pkg]{SmithNormalForm!Domain}
\index[pkg]{Domain!SmithNormalForm}
\index[pkg]{SMITH}
\begin{chunk}{defclass SmithNormalFormType}
(defclass |SmithNormalFormType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SmithNormalForm")
   (marker :initform 'package)
   (abbreviation :initform 'SMITH)
   (comment :initform (list
     "SmithNormalForm is a package"
     "which provides some standard canonical forms for matrices."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SmithNormalForm|
  (progn
    (push '|SmithNormalForm| *Packages*)
    (make-instance '|SmithNormalFormType|)))

\end{chunk}

\subsection{SortedCache}
\index[pkg]{SortedCache!Domain}
\index[pkg]{Domain!SortedCache}
\index[pkg]{SCACHE}
\begin{chunk}{defclass SortedCacheType}
(defclass |SortedCacheType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SortedCache")
   (marker :initform 'package)
   (abbreviation :initform 'SCACHE)
   (comment :initform (list
     "A sorted cache of a cachable set S is a dynamic structure that"
     "keeps the elements of S sorted and assigns an integer to each"
     "element of S once it is in the cache. This way, equality and ordering"
     "on S are tested directly on the integers associated with the elements"
     "of S, once they have been entered in the cache."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SortedCache|
  (progn
    (push '|SortedCache| *Packages*)
    (make-instance '|SortedCacheType|)))

\end{chunk}

\subsection{SortPackage}
\index[pkg]{SortPackage!Domain}
\index[pkg]{Domain!SortPackage}
\index[pkg]{SORTPAK}
\begin{chunk}{defclass SortPackageType}
(defclass |SortPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SortPackage")
   (marker :initform 'package)
   (abbreviation :initform 'SORTPAK)
   (comment :initform (list
     "This package exports sorting algorithnms"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SortPackage|
  (progn
    (push '|SortPackage| *Packages*)
    (make-instance '|SortPackageType|)))

\end{chunk}

\subsection{SparseUnivariatePolynomialFunctions2}
\index[pkg]{SparseUnivariatePolynomialFunctions2!Domain}
\index[pkg]{Domain!SparseUnivariatePolynomialFunctions2}
\index[pkg]{SUP2}
\begin{chunk}{defclass SparseUnivariatePolynomialFunctions2Type}
(defclass |SparseUnivariatePolynomialFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SparseUnivariatePolynomialFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'SUP2)
   (comment :initform (list
     "This package lifts a mapping from coefficient rings R to S to"
     "a mapping from sparse univariate polynomial over R to"
     "a sparse univariate polynomial over S."
     "Note that the mapping is assumed"
     "to send zero to zero, since it will only be applied to the non-zero"
     "coefficients of the polynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SparseUnivariatePolynomialFunctions2|
  (progn
    (push '|SparseUnivariatePolynomialFunctions2| *Packages*)
    (make-instance '|SparseUnivariatePolynomialFunctions2Type|)))

\end{chunk}

\subsection{SpecialOutputPackage}
\index[pkg]{SpecialOutputPackage!Domain}
\index[pkg]{Domain!SpecialOutputPackage}
\index[pkg]{SPECOUT}
\begin{chunk}{defclass SpecialOutputPackageType}
(defclass |SpecialOutputPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SpecialOutputPackage")
   (marker :initform 'package)
   (abbreviation :initform 'SPECOUT)
   (comment :initform (list
     "SpecialOutputPackage allows FORTRAN, Tex and"
     "Script Formula Formatter output from programs."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SpecialOutputPackage|
  (progn
    (push '|SpecialOutputPackage| *Packages*)
    (make-instance '|SpecialOutputPackageType|)))

\end{chunk}

\subsection{SquareFreeQuasiComponentPackage}
\index[pkg]{SquareFreeQuasiComponentPackage!Domain}
\index[pkg]{Domain!SquareFreeQuasiComponentPackage}
\index[pkg]{SFQCMPK}
\begin{chunk}{defclass SquareFreeQuasiComponentPackageType}
(defclass |SquareFreeQuasiComponentPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SquareFreeQuasiComponentPackage")
   (marker :initform 'package)
   (abbreviation :initform 'SFQCMPK)
   (comment :initform (list
     "A internal package for removing redundant quasi-components and redundant"
     "branches when decomposing a variety by means of quasi-components"
     "of regular triangular sets."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SquareFreeQuasiComponentPackage|
  (progn
    (push '|SquareFreeQuasiComponentPackage| *Packages*)
    (make-instance '|SquareFreeQuasiComponentPackageType|)))

\end{chunk}

\subsection{SquareFreeRegularSetDecompositionPackage}
\index[pkg]{SquareFreeRegularSetDecompositionPackage!Domain}
\index[pkg]{Domain!SquareFreeRegularSetDecompositionPackage}
\index[pkg]{SRDCMPK}
\begin{chunk}{defclass SquareFreeRegularSetDecompositionPackageType}
(defclass |SquareFreeRegularSetDecompositionPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SquareFreeRegularSetDecompositionPackage")
   (marker :initform 'package)
   (abbreviation :initform 'SRDCMPK)
   (comment :initform (list
     "A package providing a new algorithm for solving polynomial systems"
     "by means of regular chains. Two ways of solving are provided:"
     "in the sense of Zariski closure (like in Kalkbrener's algorithm)"
     "or in the sense of the regular zeros (like in Wu, Wang or Lazard-"
     "Moreno methods). This algorithm is valid for any type"
     "of regular set. It does not care about the way a polynomial is"
     "added in an regular set, or how two quasi-components are compared"
     "(by an inclusion-test), or how the invertibility test is made in"
     "the tower of simple extensions associated with a regular set."
     "These operations are realized respectively by the domain TS"
     "and the packages QCMPPK(R,E,V,P,TS) and RSETGCD(R,E,V,P,TS)."
     "The same way it does not care about the way univariate polynomial"
     "gcds (with coefficients in the tower of simple extensions associated"
     "with a regular set) are computed. The only requirement is that these"
     "gcds need to have invertible initials (normalized or not)."
     "WARNING. There is no need for a user to call directly any operation"
     "of this package since they can be accessed by the domain TS."
     "Thus, the operations of this package are not documented."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SquareFreeRegularSetDecompositionPackage|
  (progn
    (push '|SquareFreeRegularSetDecompositionPackage| *Packages*)
    (make-instance '|SquareFreeRegularSetDecompositionPackageType|)))

\end{chunk}

\subsection{SquareFreeRegularTriangularSetGcdPackage}
\index[pkg]{SquareFreeRegularTriangularSetGcdPackage!Domain}
\index[pkg]{Domain!SquareFreeRegularTriangularSetGcdPackage}
\index[pkg]{SFRGCD}
\begin{chunk}{defclass SquareFreeRegularTriangularSetGcdPackageType}
(defclass |SquareFreeRegularTriangularSetGcdPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SquareFreeRegularTriangularSetGcdPackage")
   (marker :initform 'package)
   (abbreviation :initform 'SFRGCD)
   (comment :initform (list
     "A internal package for computing gcds and resultants of univariate"
     "polynomials with coefficients in a tower of simple extensions of a field."
     "There is no need to use directly this package since its main operations are"
     "available from TS."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SquareFreeRegularTriangularSetGcdPackage|
  (progn
    (push '|SquareFreeRegularTriangularSetGcdPackage| *Packages*)
    (make-instance '|SquareFreeRegularTriangularSetGcdPackageType|)))

\end{chunk}

\subsection{StorageEfficientMatrixOperations}
\index[pkg]{StorageEfficientMatrixOperations!Domain}
\index[pkg]{Domain!StorageEfficientMatrixOperations}
\index[pkg]{MATSTOR}
\begin{chunk}{defclass StorageEfficientMatrixOperationsType}
(defclass |StorageEfficientMatrixOperationsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "StorageEfficientMatrixOperations")
   (marker :initform 'package)
   (abbreviation :initform 'MATSTOR)
   (comment :initform (list
     "This package provides standard arithmetic operations on matrices."
     "The functions in this package store the results of computations"
     "in existing matrices, rather than creating new matrices.  This"
     "package works only for matrices of type Matrix and uses the"
     "internal representation of this type."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StorageEfficientMatrixOperations|
  (progn
    (push '|StorageEfficientMatrixOperations| *Packages*)
    (make-instance '|StorageEfficientMatrixOperationsType|)))

\end{chunk}

\subsection{StreamFunctions1}
\index[pkg]{StreamFunctions1!Domain}
\index[pkg]{Domain!StreamFunctions1}
\index[pkg]{STREAM1}
\begin{chunk}{defclass StreamFunctions1Type}
(defclass |StreamFunctions1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "StreamFunctions1")
   (marker :initform 'package)
   (abbreviation :initform 'STREAM1)
   (comment :initform (list
     "Functions defined on streams with entries in one set."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StreamFunctions1|
  (progn
    (push '|StreamFunctions1| *Packages*)
    (make-instance '|StreamFunctions1Type|)))

\end{chunk}

\subsection{StreamFunctions2}
\index[pkg]{StreamFunctions2!Domain}
\index[pkg]{Domain!StreamFunctions2}
\index[pkg]{STREAM2}
\begin{chunk}{defclass StreamFunctions2Type}
(defclass |StreamFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "StreamFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'STREAM2)
   (comment :initform (list
     "Functions defined on streams with entries in two sets."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StreamFunctions2|
  (progn
    (push '|StreamFunctions2| *Packages*)
    (make-instance '|StreamFunctions2Type|)))

\end{chunk}

\subsection{StreamFunctions3}
\index[pkg]{StreamFunctions3!Domain}
\index[pkg]{Domain!StreamFunctions3}
\index[pkg]{STREAM3}
\begin{chunk}{defclass StreamFunctions3Type}
(defclass |StreamFunctions3Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "StreamFunctions3")
   (marker :initform 'package)
   (abbreviation :initform 'STREAM3)
   (comment :initform (list
     "Functions defined on streams with entries in three sets."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StreamFunctions3|
  (progn
    (push '|StreamFunctions3| *Packages*)
    (make-instance '|StreamFunctions3Type|)))

\end{chunk}

\subsection{StreamInfiniteProduct}
\index[pkg]{StreamInfiniteProduct!Domain}
\index[pkg]{Domain!StreamInfiniteProduct}
\index[pkg]{STINPROD}
\begin{chunk}{defclass StreamInfiniteProductType}
(defclass |StreamInfiniteProductType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "StreamInfiniteProduct")
   (marker :initform 'package)
   (abbreviation :initform 'STINPROD)
   (comment :initform (list
     "This package computes infinite products of Taylor series over an"
     "integral domain of characteristic 0.  Here Taylor series are"
     "represented by streams of Taylor coefficients."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StreamInfiniteProduct|
  (progn
    (push '|StreamInfiniteProduct| *Packages*)
    (make-instance '|StreamInfiniteProductType|)))

\end{chunk}

\subsection{StreamTaylorSeriesOperations}
\index[pkg]{StreamTaylorSeriesOperations!Domain}
\index[pkg]{Domain!StreamTaylorSeriesOperations}
\index[pkg]{STTAYLOR}
\begin{chunk}{defclass StreamTaylorSeriesOperationsType}
(defclass |StreamTaylorSeriesOperationsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "StreamTaylorSeriesOperations")
   (marker :initform 'package)
   (abbreviation :initform 'STTAYLOR)
   (comment :initform (list
     "StreamTaylorSeriesOperations implements Taylor series arithmetic,"
     "where a Taylor series is represented by a stream of its coefficients."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StreamTaylorSeriesOperations|
  (progn
    (push '|StreamTaylorSeriesOperations| *Packages*)
    (make-instance '|StreamTaylorSeriesOperationsType|)))

\end{chunk}

\subsection{StreamTensor}
\index[pkg]{StreamTensor!Domain}
\index[pkg]{Domain!StreamTensor}
\index[pkg]{STNSR}
\begin{chunk}{defclass StreamTensorType}
(defclass |StreamTensorType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "StreamTensor")
   (marker :initform 'package)
   (abbreviation :initform 'STNSR)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StreamTensor|
  (progn
    (push '|StreamTensor| *Packages*)
    (make-instance '|StreamTensorType|)))

\end{chunk}

\subsection{StreamTranscendentalFunctions}
\index[pkg]{StreamTranscendentalFunctions!Domain}
\index[pkg]{Domain!StreamTranscendentalFunctions}
\index[pkg]{STTF}
\begin{chunk}{defclass StreamTranscendentalFunctionsType}
(defclass |StreamTranscendentalFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "StreamTranscendentalFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'STTF)
   (comment :initform (list
     "StreamTranscendentalFunctions implements transcendental functions on"
     "Taylor series, where a Taylor series is represented by a stream of"
     "its coefficients."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StreamTranscendentalFunctions|
  (progn
    (push '|StreamTranscendentalFunctions| *Packages*)
    (make-instance '|StreamTranscendentalFunctionsType|)))

\end{chunk}

\subsection{StreamTranscendentalFunctionsNonCommutative}
\index[pkg]{StreamTranscendentalFunctionsNonCommutative!Domain}
\index[pkg]{Domain!StreamTranscendentalFunctionsNonCommutative}
\index[pkg]{STTFNC}
\begin{chunk}{defclass StreamTranscendentalFunctionsNonCommutativeType}
(defclass |StreamTranscendentalFunctionsNonCommutativeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "StreamTranscendentalFunctionsNonCommutative")
   (marker :initform 'package)
   (abbreviation :initform 'STTFNC)
   (comment :initform (list
     "StreamTranscendentalFunctionsNonCommutative implements transcendental"
     "functions on Taylor series over a non-commutative ring, where a Taylor"
     "series is represented by a stream of its coefficients."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StreamTranscendentalFunctionsNonCommutative|
  (progn
    (push '|StreamTranscendentalFunctionsNonCommutative| *Packages*)
    (make-instance '|StreamTranscendentalFunctionsNonCommutativeType|)))

\end{chunk}

\subsection{StructuralConstantsPackage}
\index[pkg]{StructuralConstantsPackage!Domain}
\index[pkg]{Domain!StructuralConstantsPackage}
\index[pkg]{SCPKG}
\begin{chunk}{defclass StructuralConstantsPackageType}
(defclass |StructuralConstantsPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "StructuralConstantsPackage")
   (marker :initform 'package)
   (abbreviation :initform 'SCPKG)
   (comment :initform (list
     "StructuralConstantsPackage provides functions creating"
     "structural constants from a multiplication tables or a basis"
     "of a matrix algebra and other useful functions in this context."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StructuralConstantsPackage|
  (progn
    (push '|StructuralConstantsPackage| *Packages*)
    (make-instance '|StructuralConstantsPackageType|)))

\end{chunk}

\subsection{SturmHabichtPackage}
\index[pkg]{SturmHabichtPackage!Domain}
\index[pkg]{Domain!SturmHabichtPackage}
\index[pkg]{SHP}
\begin{chunk}{defclass SturmHabichtPackageType}
(defclass |SturmHabichtPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SturmHabichtPackage")
   (marker :initform 'package)
   (abbreviation :initform 'SHP)
   (comment :initform (list
     "This package produces functions for counting etc. real roots of univariate"
     "polynomials in x over R, which must be an OrderedIntegralDomain"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SturmHabichtPackage|
  (progn
    (push '|SturmHabichtPackage| *Packages*)
    (make-instance '|SturmHabichtPackageType|)))

\end{chunk}

\subsection{SubResultantPackage}
\index[pkg]{SubResultantPackage!Domain}
\index[pkg]{Domain!SubResultantPackage}
\index[pkg]{SUBRESP}
\begin{chunk}{defclass SubResultantPackageType}
(defclass |SubResultantPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SubResultantPackage")
   (marker :initform 'package)
   (abbreviation :initform 'SUBRESP)
   (comment :initform (list
     "This package computes the subresultants of two polynomials which is needed"
     "for the `Lazard Rioboo' enhancement to Tragers integrations formula"
     "For efficiency reasons this has been rewritten to call Lionel Ducos"
     "package which is currently the best one."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SubResultantPackage|
  (progn
    (push '|SubResultantPackage| *Packages*)
    (make-instance '|SubResultantPackageType|)))

\end{chunk}

\subsection{SupFractionFactorizer}
\index[pkg]{SupFractionFactorizer!Domain}
\index[pkg]{Domain!SupFractionFactorizer}
\index[pkg]{SUPFRACF}
\begin{chunk}{defclass SupFractionFactorizerType}
(defclass |SupFractionFactorizerType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SupFractionFactorizer")
   (marker :initform 'package)
   (abbreviation :initform 'SUPFRACF)
   (comment :initform (list
     "SupFractionFactorize  contains the factor function for univariate"
     "polynomials over the quotient field of a ring S such that the package"
     "MultivariateFactorize works for S"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SupFractionFactorizer|
  (progn
    (push '|SupFractionFactorizer| *Packages*)
    (make-instance '|SupFractionFactorizerType|)))

\end{chunk}

\subsection{SystemODESolver}
\index[pkg]{SystemODESolver!Domain}
\index[pkg]{Domain!SystemODESolver}
\index[pkg]{ODESYS}
\begin{chunk}{defclass SystemODESolverType}
(defclass |SystemODESolverType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SystemODESolver")
   (marker :initform 'package)
   (abbreviation :initform 'ODESYS)
   (comment :initform (list
     "SystemODESolver provides tools for triangulating"
     "and solving some systems of linear ordinary differential equations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SystemODESolver|
  (progn
    (push '|SystemODESolver| *Packages*)
    (make-instance '|SystemODESolverType|)))

\end{chunk}

\subsection{SystemSolvePackage}
\index[pkg]{SystemSolvePackage!Domain}
\index[pkg]{Domain!SystemSolvePackage}
\index[pkg]{SYSSOLP}
\begin{chunk}{defclass SystemSolvePackageType}
(defclass |SystemSolvePackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SystemSolvePackage")
   (marker :initform 'package)
   (abbreviation :initform 'SYSSOLP)
   (comment :initform (list
     "Symbolic solver for systems of rational functions with coefficients"
     "in an integral domain R."
     "The systems are solved in the field of rational functions over R."
     "Solutions are exact of the form variable = value when the value is"
     "a member of the coefficient domain R. Otherwise the solutions"
     "are implicitly expressed as roots of univariate polynomial equations over R."
     "Care is taken to guarantee that the denominators of the input"
     "equations do not vanish on the solution sets."
     "The arguments to solve can either be given as equations or"
     "as rational functions interpreted as equal"
     "to zero. The user can specify an explicit list of symbols to"
     "be solved for, treating all other symbols appearing as parameters"
     "or omit the list of symbols in which case the system tries to"
     "solve with respect to all symbols appearing in the input."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SystemSolvePackage|
  (progn
    (push '|SystemSolvePackage| *Packages*)
    (make-instance '|SystemSolvePackageType|)))

\end{chunk}

\subsection{SymmetricGroupCombinatoricFunctions}
\index[pkg]{SymmetricGroupCombinatoricFunctions!Domain}
\index[pkg]{Domain!SymmetricGroupCombinatoricFunctions}
\index[pkg]{SGCF}
\begin{chunk}{defclass SymmetricGroupCombinatoricFunctionsType}
(defclass |SymmetricGroupCombinatoricFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SymmetricGroupCombinatoricFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'SGCF)
   (comment :initform (list
     "SymmetricGroupCombinatoricFunctions contains combinatoric"
     "functions concerning symmetric groups and representation"
     "theory: list young tableaus, improper partitions, subsets"
     "bijection of Coleman."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SymmetricGroupCombinatoricFunctions|
  (progn
    (push '|SymmetricGroupCombinatoricFunctions| *Packages*)
    (make-instance '|SymmetricGroupCombinatoricFunctionsType|)))

\end{chunk}

\subsection{SymmetricFunctions}
\index[pkg]{SymmetricFunctions!Domain}
\index[pkg]{Domain!SymmetricFunctions}
\index[pkg]{SYMFUNC}
\begin{chunk}{defclass SymmetricFunctionsType}
(defclass |SymmetricFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SymmetricFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'SYMFUNC)
   (comment :initform (list
     "Computes all the symmetric functions in n variables."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SymmetricFunctions|
  (progn
    (push '|SymmetricFunctions| *Packages*)
    (make-instance '|SymmetricFunctionsType|)))

\end{chunk}

\section{T}

\subsection{TableauxBumpers}
\index[pkg]{TableauxBumpers!Domain}
\index[pkg]{Domain!TableauxBumpers}
\index[pkg]{TABLBUMP}
\begin{chunk}{defclass TableauxBumpersType}
(defclass |TableauxBumpersType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TableauxBumpers")
   (marker :initform 'package)
   (abbreviation :initform 'TABLBUMP)
   (comment :initform (list
     "TableauBumpers implements the Schenstead-Knuth"
     "correspondence between sequences and pairs of Young tableaux."
     "The 2 Young tableaux are represented as a single tableau with"
     "pairs as components."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TableauxBumpers|
  (progn
    (push '|TableauxBumpers| *Packages*)
    (make-instance '|TableauxBumpersType|)))

\end{chunk}

\subsection{TabulatedComputationPackage}
\index[pkg]{TabulatedComputationPackage!Domain}
\index[pkg]{Domain!TabulatedComputationPackage}
\index[pkg]{TBCMPPK}
\begin{chunk}{defclass TabulatedComputationPackageType}
(defclass |TabulatedComputationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TabulatedComputationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'TBCMPPK)
   (comment :initform (list
     "TabulatedComputationPackage(Key ,Entry) provides some modest support"
     "for dealing with operations with type Key -> Entry. The result of"
     "such operations can be stored and retrieved with this package by using"
     "a hash-table. The user does not need to worry about the management of"
     "this hash-table. However, onnly one hash-table is built by calling"
     "TabulatedComputationPackage(Key ,Entry)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TabulatedComputationPackage|
  (progn
    (push '|TabulatedComputationPackage| *Packages*)
    (make-instance '|TabulatedComputationPackageType|)))

\end{chunk}

\subsection{TangentExpansions}
\index[pkg]{TangentExpansions!Domain}
\index[pkg]{Domain!TangentExpansions}
\index[pkg]{TANEXP}
\begin{chunk}{defclass TangentExpansionsType}
(defclass |TangentExpansionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TangentExpansions")
   (marker :initform 'package)
   (abbreviation :initform 'TANEXP)
   (comment :initform (list
     "Expands tangents of sums and scalar products."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TangentExpansions|
  (progn
    (push '|TangentExpansions| *Packages*)
    (make-instance '|TangentExpansionsType|)))

\end{chunk}

\subsection{TaylorSolve}
\index[pkg]{TaylorSolve!Domain}
\index[pkg]{Domain!TaylorSolve}
\index[pkg]{UTSSOL}
\begin{chunk}{defclass TaylorSolveType}
(defclass |TaylorSolveType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TaylorSolve")
   (marker :initform 'package)
   (abbreviation :initform 'UTSSOL)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TaylorSolve|
  (progn
    (push '|TaylorSolve| *Packages*)
    (make-instance '|TaylorSolveType|)))

\end{chunk}

\subsection{TemplateUtilities}
\index[pkg]{TemplateUtilities!Domain}
\index[pkg]{Domain!TemplateUtilities}
\index[pkg]{TEMUTL}
\begin{chunk}{defclass TemplateUtilitiesType}
(defclass |TemplateUtilitiesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TemplateUtilities")
   (marker :initform 'package)
   (abbreviation :initform 'TEMUTL)
   (comment :initform (list
     "This package provides functions for template manipulation"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TemplateUtilities|
  (progn
    (push '|TemplateUtilities| *Packages*)
    (make-instance '|TemplateUtilitiesType|)))

\end{chunk}

\subsection{TexFormat1}
\index[pkg]{TexFormat1!Domain}
\index[pkg]{Domain!TexFormat1}
\index[pkg]{TEX1}
\begin{chunk}{defclass TexFormat1Type}
(defclass |TexFormat1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TexFormat1")
   (marker :initform 'package)
   (abbreviation :initform 'TEX1)
   (comment :initform (list
     "TexFormat1 provides a utility coercion for changing"
     "to TeX format anything that has a coercion to the standard output format."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TexFormat1|
  (progn
    (push '|TexFormat1| *Packages*)
    (make-instance '|TexFormat1Type|)))

\end{chunk}

\subsection{ToolsForSign}
\index[pkg]{ToolsForSign!Domain}
\index[pkg]{Domain!ToolsForSign}
\index[pkg]{TOOLSIGN}
\begin{chunk}{defclass ToolsForSignType}
(defclass |ToolsForSignType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ToolsForSign")
   (marker :initform 'package)
   (abbreviation :initform 'TOOLSIGN)
   (comment :initform (list
     "Tools for the sign finding utilities."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ToolsForSign|
  (progn
    (push '|ToolsForSign| *Packages*)
    (make-instance '|ToolsForSignType|)))

\end{chunk}

\subsection{TopLevelDrawFunctions}
\index[pkg]{TopLevelDrawFunctions!Domain}
\index[pkg]{Domain!TopLevelDrawFunctions}
\index[pkg]{DRAW}
\begin{chunk}{defclass TopLevelDrawFunctionsType}
(defclass |TopLevelDrawFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TopLevelDrawFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'DRAW)
   (comment :initform (list
     "TopLevelDrawFunctions provides top level functions for"
     "drawing graphics of expressions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TopLevelDrawFunctions|
  (progn
    (push '|TopLevelDrawFunctions| *Packages*)
    (make-instance '|TopLevelDrawFunctionsType|)))

\end{chunk}

\subsection{TopLevelDrawFunctionsForAlgebraicCurves}
\index[pkg]{TopLevelDrawFunctionsForAlgebraicCurves!Domain}
\index[pkg]{Domain!TopLevelDrawFunctionsForAlgebraicCurves}
\index[pkg]{DRAWCURV}
\begin{chunk}{defclass TopLevelDrawFunctionsForAlgebraicCurvesType}
(defclass |TopLevelDrawFunctionsForAlgebraicCurvesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TopLevelDrawFunctionsForAlgebraicCurves")
   (marker :initform 'package)
   (abbreviation :initform 'DRAWCURV)
   (comment :initform (list
     "TopLevelDrawFunctionsForAlgebraicCurves provides top level"
     "functions for drawing non-singular algebraic curves."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TopLevelDrawFunctionsForAlgebraicCurves|
  (progn
    (push '|TopLevelDrawFunctionsForAlgebraicCurves| *Packages*)
    (make-instance '|TopLevelDrawFunctionsForAlgebraicCurvesType|)))

\end{chunk}

\subsection{TopLevelDrawFunctionsForCompiledFunctions}
\index[pkg]{TopLevelDrawFunctionsForCompiledFunctions!Domain}
\index[pkg]{Domain!TopLevelDrawFunctionsForCompiledFunctions}
\index[pkg]{DRAWCFUN}
\begin{chunk}{defclass TopLevelDrawFunctionsForCompiledFunctionsType}
(defclass |TopLevelDrawFunctionsForCompiledFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TopLevelDrawFunctionsForCompiledFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'DRAWCFUN)
   (comment :initform (list
     "TopLevelDrawFunctionsForCompiledFunctions provides top level"
     "functions for drawing graphics of expressions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TopLevelDrawFunctionsForCompiledFunctions|
  (progn
    (push '|TopLevelDrawFunctionsForCompiledFunctions| *Packages*)
    (make-instance '|TopLevelDrawFunctionsForCompiledFunctionsType|)))

\end{chunk}

\subsection{TopLevelDrawFunctionsForPoints}
\index[pkg]{TopLevelDrawFunctionsForPoints!Domain}
\index[pkg]{Domain!TopLevelDrawFunctionsForPoints}
\index[pkg]{DRAWPT}
\begin{chunk}{defclass TopLevelDrawFunctionsForPointsType}
(defclass |TopLevelDrawFunctionsForPointsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TopLevelDrawFunctionsForPoints")
   (marker :initform 'package)
   (abbreviation :initform 'DRAWPT)
   (comment :initform (list
     "TopLevelDrawFunctionsForPoints provides top level functions"
     "for drawing curves and surfaces described by sets of points."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TopLevelDrawFunctionsForPoints|
  (progn
    (push '|TopLevelDrawFunctionsForPoints| *Packages*)
    (make-instance '|TopLevelDrawFunctionsForPointsType|)))

\end{chunk}

\subsection{TopLevelThreeSpace}
\index[pkg]{TopLevelThreeSpace!Domain}
\index[pkg]{Domain!TopLevelThreeSpace}
\index[pkg]{TOPSP}
\begin{chunk}{defclass TopLevelThreeSpaceType}
(defclass |TopLevelThreeSpaceType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TopLevelThreeSpace")
   (marker :initform 'package)
   (abbreviation :initform 'TOPSP)
   (comment :initform (list
     "This package exports a function for making a ThreeSpace"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TopLevelThreeSpace|
  (progn
    (push '|TopLevelThreeSpace| *Packages*)
    (make-instance '|TopLevelThreeSpaceType|)))

\end{chunk}

\subsection{TranscendentalHermiteIntegration}
\index[pkg]{TranscendentalHermiteIntegration!Domain}
\index[pkg]{Domain!TranscendentalHermiteIntegration}
\index[pkg]{INTHERTR}
\begin{chunk}{defclass TranscendentalHermiteIntegrationType}
(defclass |TranscendentalHermiteIntegrationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TranscendentalHermiteIntegration")
   (marker :initform 'package)
   (abbreviation :initform 'INTHERTR)
   (comment :initform (list
     "Hermite integration, transcendental case."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TranscendentalHermiteIntegration|
  (progn
    (push '|TranscendentalHermiteIntegration| *Packages*)
    (make-instance '|TranscendentalHermiteIntegrationType|)))

\end{chunk}

\subsection{TranscendentalIntegration}
\index[pkg]{TranscendentalIntegration!Domain}
\index[pkg]{Domain!TranscendentalIntegration}
\index[pkg]{INTTR}
\begin{chunk}{defclass TranscendentalIntegrationType}
(defclass |TranscendentalIntegrationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TranscendentalIntegration")
   (marker :initform 'package)
   (abbreviation :initform 'INTTR)
   (comment :initform (list
     "This package provides functions for the transcendental"
     "case of the Risch algorithm."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TranscendentalIntegration|
  (progn
    (push '|TranscendentalIntegration| *Packages*)
    (make-instance '|TranscendentalIntegrationType|)))

\end{chunk}

\subsection{TranscendentalManipulations}
\index[pkg]{TranscendentalManipulations!Domain}
\index[pkg]{Domain!TranscendentalManipulations}
\index[pkg]{TRMANIP}
\begin{chunk}{defclass TranscendentalManipulationsType}
(defclass |TranscendentalManipulationsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TranscendentalManipulations")
   (marker :initform 'package)
   (abbreviation :initform 'TRMANIP)
   (comment :initform (list
     "TranscendentalManipulations provides functions to simplify and"
     "expand expressions involving transcendental operators."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TranscendentalManipulations|
  (progn
    (push '|TranscendentalManipulations| *Packages*)
    (make-instance '|TranscendentalManipulationsType|)))

\end{chunk}

\subsection{TranscendentalRischDE}
\index[pkg]{TranscendentalRischDE!Domain}
\index[pkg]{Domain!TranscendentalRischDE}
\index[pkg]{RDETR}
\begin{chunk}{defclass TranscendentalRischDEType}
(defclass |TranscendentalRischDEType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TranscendentalRischDE")
   (marker :initform 'package)
   (abbreviation :initform 'RDETR)
   (comment :initform (list
     "Risch differential equation, transcendental case."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TranscendentalRischDE|
  (progn
    (push '|TranscendentalRischDE| *Packages*)
    (make-instance '|TranscendentalRischDEType|)))

\end{chunk}

\subsection{TranscendentalRischDESystem}
\index[pkg]{TranscendentalRischDESystem!Domain}
\index[pkg]{Domain!TranscendentalRischDESystem}
\index[pkg]{RDETRS}
\begin{chunk}{defclass TranscendentalRischDESystemType}
(defclass |TranscendentalRischDESystemType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TranscendentalRischDESystem")
   (marker :initform 'package)
   (abbreviation :initform 'RDETRS)
   (comment :initform (list
     "Risch differential equation system, transcendental case."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TranscendentalRischDESystem|
  (progn
    (push '|TranscendentalRischDESystem| *Packages*)
    (make-instance '|TranscendentalRischDESystemType|)))

\end{chunk}

\subsection{TransSolvePackage}
\index[pkg]{TransSolvePackage!Domain}
\index[pkg]{Domain!TransSolvePackage}
\index[pkg]{SOLVETRA}
\begin{chunk}{defclass TransSolvePackageType}
(defclass |TransSolvePackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TransSolvePackage")
   (marker :initform 'package)
   (abbreviation :initform 'SOLVETRA)
   (comment :initform (list
     "This package tries to find solutions of equations of type Expression(R)."
     "This means expressions involving transcendental, exponential, logarithmic"
     "and nthRoot functions."
     "After trying to transform different kernels to one kernel by applying"
     "several rules, it calls zerosOf for the SparseUnivariatePolynomial in"
     "the remaining kernel."
     "For example the expression sin(x)*cos(x)-2 will be transformed to"
     "-2 tan(x/2)**4 -2 tan(x/2)**3 -4 tan(x/2)**2 +2 tan(x/2) -2"
     "by using the function normalize and then to"
     "-2 tan(x)**2 + tan(x) -2"
     "with help of subsTan. This function tries to express the given function"
     "in terms of tan(x/2) to express in terms of tan(x)."
     "Other examples are the expressions sqrt(x+1)+sqrt(x+7)+1 or"
     "sqrt(sin(x))+1 ."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TransSolvePackage|
  (progn
    (push '|TransSolvePackage| *Packages*)
    (make-instance '|TransSolvePackageType|)))

\end{chunk}

\subsection{TransSolvePackageService}
\index[pkg]{TransSolvePackageService!Domain}
\index[pkg]{Domain!TransSolvePackageService}
\index[pkg]{SOLVESER}
\begin{chunk}{defclass TransSolvePackageServiceType}
(defclass |TransSolvePackageServiceType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TransSolvePackageService")
   (marker :initform 'package)
   (abbreviation :initform 'SOLVESER)
   (comment :initform (list
     "This package finds the function func3 where  func1 and func2"
     "are given and  func1 = func3(func2) .  If there is no solution then"
     "function func1 will be returned."
     "An example would be func1:= 8*X**3+32*X**2-14*X ::EXPR INT and"
     "func2:=2*X ::EXPR INT convert them via univariate"
     "to FRAC SUP EXPR INT and then the solution is func3:=X**3+X**2-X"
     "of type FRAC SUP EXPR INT"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TransSolvePackageService|
  (progn
    (push '|TransSolvePackageService| *Packages*)
    (make-instance '|TransSolvePackageServiceType|)))

\end{chunk}

\subsection{TriangularMatrixOperations}
\index[pkg]{TriangularMatrixOperations!Domain}
\index[pkg]{Domain!TriangularMatrixOperations}
\index[pkg]{TRIMAT}
\begin{chunk}{defclass TriangularMatrixOperationsType}
(defclass |TriangularMatrixOperationsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TriangularMatrixOperations")
   (marker :initform 'package)
   (abbreviation :initform 'TRIMAT)
   (comment :initform (list
     "This package provides functions that compute 'fraction-free'"
     "inverses of upper and lower triangular matrices over a integral"
     "domain.  By 'fraction-free inverses' we mean the following:"
     "given a matrix B with entries in R and an element d of R such that"
     "d * inv(B) also has entries in R, we return d * inv(B).  Thus,"
     "it is not necessary to pass to the quotient field in any of our"
     "computations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TriangularMatrixOperations|
  (progn
    (push '|TriangularMatrixOperations| *Packages*)
    (make-instance '|TriangularMatrixOperationsType|)))

\end{chunk}

\subsection{TrigonometricManipulations}
\index[pkg]{TrigonometricManipulations!Domain}
\index[pkg]{Domain!TrigonometricManipulations}
\index[pkg]{TRIGMNIP}
\begin{chunk}{defclass TrigonometricManipulationsType}
(defclass |TrigonometricManipulationsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TrigonometricManipulations")
   (marker :initform 'package)
   (abbreviation :initform 'TRIGMNIP)
   (comment :initform (list
     "TrigonometricManipulations provides transformations from"
     "trigonometric functions to complex exponentials and logarithms, and back."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TrigonometricManipulations|
  (progn
    (push '|TrigonometricManipulations| *Packages*)
    (make-instance '|TrigonometricManipulationsType|)))

\end{chunk}

\subsection{TubePlotTools}
\index[pkg]{TubePlotTools!Domain}
\index[pkg]{Domain!TubePlotTools}
\index[pkg]{TUBETOOL}
\begin{chunk}{defclass TubePlotToolsType}
(defclass |TubePlotToolsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TubePlotTools")
   (marker :initform 'package)
   (abbreviation :initform 'TUBETOOL)
   (comment :initform (list
     "Tools for constructing tubes around 3-dimensional parametric curves."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TubePlotTools|
  (progn
    (push '|TubePlotTools| *Packages*)
    (make-instance '|TubePlotToolsType|)))

\end{chunk}

\subsection{TwoDimensionalPlotClipping}
\index[pkg]{TwoDimensionalPlotClipping!Domain}
\index[pkg]{Domain!TwoDimensionalPlotClipping}
\index[pkg]{CLIP}
\begin{chunk}{defclass TwoDimensionalPlotClippingType}
(defclass |TwoDimensionalPlotClippingType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TwoDimensionalPlotClipping")
   (marker :initform 'package)
   (abbreviation :initform 'CLIP)
   (comment :initform (list
     "Automatic clipping for 2-dimensional plots"
     "The purpose of this package is to provide reasonable plots of"
     "functions with singularities."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TwoDimensionalPlotClipping|
  (progn
    (push '|TwoDimensionalPlotClipping| *Packages*)
    (make-instance '|TwoDimensionalPlotClippingType|)))

\end{chunk}

\subsection{TwoFactorize}
\index[pkg]{TwoFactorize!Domain}
\index[pkg]{Domain!TwoFactorize}
\index[pkg]{TWOFACT}
\begin{chunk}{defclass TwoFactorizeType}
(defclass |TwoFactorizeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TwoFactorize")
   (marker :initform 'package)
   (abbreviation :initform 'TWOFACT)
   (comment :initform (list
     "A basic package for the factorization of bivariate polynomials"
     "over a finite field."
     "The functions here represent the base step for the multivariate factorizer."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TwoFactorize|
  (progn
    (push '|TwoFactorize| *Packages*)
    (make-instance '|TwoFactorizeType|)))

\end{chunk}

\section{U}

\subsection{UnivariateFactorize}
\index[pkg]{UnivariateFactorize!Domain}
\index[pkg]{Domain!UnivariateFactorize}
\index[pkg]{UNIFACT}
\begin{chunk}{defclass UnivariateFactorizeType}
(defclass |UnivariateFactorizeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UnivariateFactorize")
   (marker :initform 'package)
   (abbreviation :initform 'UNIFACT)
   (comment :initform (list
     "Package for the factorization of univariate polynomials with integer"
     "coefficients. The factorization is done by 'lifting' (HENSEL) the"
     "factorization over a finite field."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariateFactorize|
  (progn
    (push '|UnivariateFactorize| *Packages*)
    (make-instance '|UnivariateFactorizeType|)))

\end{chunk}

\subsection{UnivariateFormalPowerSeriesFunctions}
\index[pkg]{UnivariateFormalPowerSeriesFunctions!Domain}
\index[pkg]{Domain!UnivariateFormalPowerSeriesFunctions}
\index[pkg]{UFPS1}
\begin{chunk}{defclass UnivariateFormalPowerSeriesFunctionsType}
(defclass |UnivariateFormalPowerSeriesFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UnivariateFormalPowerSeriesFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'UFPS1)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariateFormalPowerSeriesFunctions|
  (progn
    (push '|UnivariateFormalPowerSeriesFunctions| *Packages*)
    (make-instance '|UnivariateFormalPowerSeriesFunctionsType|)))

\end{chunk}

\subsection{UnivariateLaurentSeriesFunctions2}
\index[pkg]{UnivariateLaurentSeriesFunctions2!Domain}
\index[pkg]{Domain!UnivariateLaurentSeriesFunctions2}
\index[pkg]{ULS2}
\begin{chunk}{defclass UnivariateLaurentSeriesFunctions2Type}
(defclass |UnivariateLaurentSeriesFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UnivariateLaurentSeriesFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'ULS2)
   (comment :initform (list
     "Mapping package for univariate Laurent series"
     "This package allows one to apply a function to the coefficients of"
     "a univariate Laurent series."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariateLaurentSeriesFunctions2|
  (progn
    (push '|UnivariateLaurentSeriesFunctions2| *Packages*)
    (make-instance '|UnivariateLaurentSeriesFunctions2Type|)))

\end{chunk}

\subsection{UnivariatePolynomialCategoryFunctions2}
\index[pkg]{UnivariatePolynomialCategoryFunctions2!Domain}
\index[pkg]{Domain!UnivariatePolynomialCategoryFunctions2}
\index[pkg]{UPOLYC2}
\begin{chunk}{defclass UnivariatePolynomialCategoryFunctions2Type}
(defclass |UnivariatePolynomialCategoryFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UnivariatePolynomialCategoryFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'UPOLYC2)
   (comment :initform (list
     "Mapping from polynomials over R to polynomials over S"
     "given a map from R to S assumed to send zero to zero."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariatePolynomialCategoryFunctions2|
  (progn
    (push '|UnivariatePolynomialCategoryFunctions2| *Packages*)
    (make-instance '|UnivariatePolynomialCategoryFunctions2Type|)))

\end{chunk}

\subsection{UnivariatePolynomialCommonDenominator}
\index[pkg]{UnivariatePolynomialCommonDenominator!Domain}
\index[pkg]{Domain!UnivariatePolynomialCommonDenominator}
\index[pkg]{UPCDEN}
\begin{chunk}{defclass UnivariatePolynomialCommonDenominatorType}
(defclass |UnivariatePolynomialCommonDenominatorType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UnivariatePolynomialCommonDenominator")
   (marker :initform 'package)
   (abbreviation :initform 'UPCDEN)
   (comment :initform (list
     "UnivariatePolynomialCommonDenominator provides"
     "functions to compute the common denominator of the coefficients of"
     "univariate polynomials over the quotient field of a gcd domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariatePolynomialCommonDenominator|
  (progn
    (push '|UnivariatePolynomialCommonDenominator| *Packages*)
    (make-instance '|UnivariatePolynomialCommonDenominatorType|)))

\end{chunk}

\subsection{UnivariatePolynomialDecompositionPackage}
\index[pkg]{UnivariatePolynomialDecompositionPackage!Domain}
\index[pkg]{Domain!UnivariatePolynomialDecompositionPackage}
\index[pkg]{UPDECOMP}
\begin{chunk}{defclass UnivariatePolynomialDecompositionPackageType}
(defclass |UnivariatePolynomialDecompositionPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UnivariatePolynomialDecompositionPackage")
   (marker :initform 'package)
   (abbreviation :initform 'UPDECOMP)
   (comment :initform (list
     "UnivariatePolynomialDecompositionPackage implements"
     "functional decomposition of univariate polynomial with coefficients"
     "in an IntegralDomain of CharacteristicZero."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariatePolynomialDecompositionPackage|
  (progn
    (push '|UnivariatePolynomialDecompositionPackage| *Packages*)
    (make-instance '|UnivariatePolynomialDecompositionPackageType|)))

\end{chunk}

\subsection{UnivariatePolynomialDivisionPackage}
\index[pkg]{UnivariatePolynomialDivisionPackage!Domain}
\index[pkg]{Domain!UnivariatePolynomialDivisionPackage}
\index[pkg]{UPDIVP}
\begin{chunk}{defclass UnivariatePolynomialDivisionPackageType}
(defclass |UnivariatePolynomialDivisionPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UnivariatePolynomialDivisionPackage")
   (marker :initform 'package)
   (abbreviation :initform 'UPDIVP)
   (comment :initform (list
     "UnivariatePolynomialDivisionPackage provides a"
     "division for non monic univarite polynomials with coefficients in"
     "an IntegralDomain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariatePolynomialDivisionPackage|
  (progn
    (push '|UnivariatePolynomialDivisionPackage| *Packages*)
    (make-instance '|UnivariatePolynomialDivisionPackageType|)))

\end{chunk}

\subsection{UnivariatePolynomialFunctions2}
\index[pkg]{UnivariatePolynomialFunctions2!Domain}
\index[pkg]{Domain!UnivariatePolynomialFunctions2}
\index[pkg]{UP2}
\begin{chunk}{defclass UnivariatePolynomialFunctions2Type}
(defclass |UnivariatePolynomialFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UnivariatePolynomialFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'UP2)
   (comment :initform (list
     "This package lifts a mapping from coefficient rings R to S to"
     "a mapping from UnivariatePolynomial(x,R) to"
     "UnivariatePolynomial(y,S). Note that the mapping is assumed"
     "to send zero to zero, since it will only be applied to the non-zero"
     "coefficients of the polynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariatePolynomialFunctions2|
  (progn
    (push '|UnivariatePolynomialFunctions2| *Packages*)
    (make-instance '|UnivariatePolynomialFunctions2Type|)))

\end{chunk}

\subsection{UnivariatePolynomialMultiplicationPackage}
\index[pkg]{UnivariatePolynomialMultiplicationPackage!Domain}
\index[pkg]{Domain!UnivariatePolynomialMultiplicationPackage}
\index[pkg]{UPMP}
\begin{chunk}{defclass UnivariatePolynomialMultiplicationPackageType}
(defclass |UnivariatePolynomialMultiplicationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UnivariatePolynomialMultiplicationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'UPMP)
   (comment :initform (list
     "This package implements Karatsuba's trick for multiplying"
     "(large) univariate polynomials. It could be improved with"
     "a version doing the work on place and also with a special"
     "case for squares. We've done this in Basicmath, but we"
     "believe that this out of the scope of AXIOM."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariatePolynomialMultiplicationPackage|
  (progn
    (push '|UnivariatePolynomialMultiplicationPackage| *Packages*)
    (make-instance '|UnivariatePolynomialMultiplicationPackageType|)))

\end{chunk}

\subsection{UnivariatePolynomialSquareFree}
\index[pkg]{UnivariatePolynomialSquareFree!Domain}
\index[pkg]{Domain!UnivariatePolynomialSquareFree}
\index[pkg]{UPSQFREE}
\begin{chunk}{defclass UnivariatePolynomialSquareFreeType}
(defclass |UnivariatePolynomialSquareFreeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UnivariatePolynomialSquareFree")
   (marker :initform 'package)
   (abbreviation :initform 'UPSQFREE)
   (comment :initform (list
     "This package provides for square-free decomposition of"
     "univariate polynomials over arbitrary rings,"
     "a partial factorization such that each factor is a product"
     "of irreducibles with multiplicity one and the factors are"
     "pairwise relatively prime. If the ring"
     "has characteristic zero, the result is guaranteed to satisfy"
     "this condition. If the ring is an infinite ring of"
     "finite characteristic, then it may not be possible to decide when"
     "polynomials contain factors which are pth powers. In this"
     "case, the flag associated with that polynomial is set to 'nil'"
     "(meaning that that polynomials are not guaranteed to be square-free)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariatePolynomialSquareFree|
  (progn
    (push '|UnivariatePolynomialSquareFree| *Packages*)
    (make-instance '|UnivariatePolynomialSquareFreeType|)))

\end{chunk}

\subsection{UnivariatePuiseuxSeriesFunctions2}
\index[pkg]{UnivariatePuiseuxSeriesFunctions2!Domain}
\index[pkg]{Domain!UnivariatePuiseuxSeriesFunctions2}
\index[pkg]{UPXS2}
\begin{chunk}{defclass UnivariatePuiseuxSeriesFunctions2Type}
(defclass |UnivariatePuiseuxSeriesFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UnivariatePuiseuxSeriesFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'UPXS2)
   (comment :initform (list
     "Mapping package for univariate Puiseux series."
     "This package allows one to apply a function to the coefficients of"
     "a univariate Puiseux series."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariatePuiseuxSeriesFunctions2|
  (progn
    (push '|UnivariatePuiseuxSeriesFunctions2| *Packages*)
    (make-instance '|UnivariatePuiseuxSeriesFunctions2Type|)))

\end{chunk}

\subsection{UnivariateSkewPolynomialCategoryOps}
\index[pkg]{UnivariateSkewPolynomialCategoryOps!Domain}
\index[pkg]{Domain!UnivariateSkewPolynomialCategoryOps}
\index[pkg]{OREPCTO}
\begin{chunk}{defclass UnivariateSkewPolynomialCategoryOpsType}
(defclass |UnivariateSkewPolynomialCategoryOpsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UnivariateSkewPolynomialCategoryOps")
   (marker :initform 'package)
   (abbreviation :initform 'OREPCTO)
   (comment :initform (list
     "UnivariateSkewPolynomialCategoryOps provides products and"
     "divisions of univariate skew polynomials."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariateSkewPolynomialCategoryOps|
  (progn
    (push '|UnivariateSkewPolynomialCategoryOps| *Packages*)
    (make-instance '|UnivariateSkewPolynomialCategoryOpsType|)))

\end{chunk}

\subsection{UnivariateTaylorSeriesFunctions2}
\index[pkg]{UnivariateTaylorSeriesFunctions2!Domain}
\index[pkg]{Domain!UnivariateTaylorSeriesFunctions2}
\index[pkg]{UTS2}
\begin{chunk}{defclass UnivariateTaylorSeriesFunctions2Type}
(defclass |UnivariateTaylorSeriesFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UnivariateTaylorSeriesFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'UTS2)
   (comment :initform (list
     "Mapping package for univariate Taylor series."
     "This package allows one to apply a function to the coefficients of"
     "a univariate Taylor series."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariateTaylorSeriesFunctions2|
  (progn
    (push '|UnivariateTaylorSeriesFunctions2| *Packages*)
    (make-instance '|UnivariateTaylorSeriesFunctions2Type|)))

\end{chunk}

\subsection{UnivariateTaylorSeriesODESolver}
\index[pkg]{UnivariateTaylorSeriesODESolver!Domain}
\index[pkg]{Domain!UnivariateTaylorSeriesODESolver}
\index[pkg]{UTSODE}
\begin{chunk}{defclass UnivariateTaylorSeriesODESolverType}
(defclass |UnivariateTaylorSeriesODESolverType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UnivariateTaylorSeriesODESolver")
   (marker :initform 'package)
   (abbreviation :initform 'UTSODE)
   (comment :initform (list
     "Taylor series solutions of explicit ODE's."
     "This package provides Taylor series solutions to regular"
     "linear or non-linear ordinary differential equations of"
     "arbitrary order."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariateTaylorSeriesODESolver|
  (progn
    (push '|UnivariateTaylorSeriesODESolver| *Packages*)
    (make-instance '|UnivariateTaylorSeriesODESolverType|)))

\end{chunk}

\subsection{UniversalSegmentFunctions2}
\index[pkg]{UniversalSegmentFunctions2!Domain}
\index[pkg]{Domain!UniversalSegmentFunctions2}
\index[pkg]{UNISEG2}
\begin{chunk}{defclass UniversalSegmentFunctions2Type}
(defclass |UniversalSegmentFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UniversalSegmentFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'UNISEG2)
   (comment :initform (list
     "This package provides operations for mapping functions onto segments."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UniversalSegmentFunctions2|
  (progn
    (push '|UniversalSegmentFunctions2| *Packages*)
    (make-instance '|UniversalSegmentFunctions2Type|)))

\end{chunk}

\subsection{UserDefinedPartialOrdering}
\index[pkg]{UserDefinedPartialOrdering!Domain}
\index[pkg]{Domain!UserDefinedPartialOrdering}
\index[pkg]{UDPO}
\begin{chunk}{defclass UserDefinedPartialOrderingType}
(defclass |UserDefinedPartialOrderingType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UserDefinedPartialOrdering")
   (marker :initform 'package)
   (abbreviation :initform 'UDPO)
   (comment :initform (list
     "Provides functions to force a partial ordering on any set."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UserDefinedPartialOrdering|
  (progn
    (push '|UserDefinedPartialOrdering| *Packages*)
    (make-instance '|UserDefinedPartialOrderingType|)))

\end{chunk}

\subsection{UserDefinedVariableOrdering}
\index[pkg]{UserDefinedVariableOrdering!Domain}
\index[pkg]{Domain!UserDefinedVariableOrdering}
\index[pkg]{UDVO}
\begin{chunk}{defclass UserDefinedVariableOrderingType}
(defclass |UserDefinedVariableOrderingType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UserDefinedVariableOrdering")
   (marker :initform 'package)
   (abbreviation :initform 'UDVO)
   (comment :initform (list
     "This packages provides functions to allow the user to select the ordering"
     "on the variables and operators for displaying polynomials,"
     "fractions and expressions. The ordering affects the display"
     "only and not the computations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UserDefinedVariableOrdering|
  (progn
    (push '|UserDefinedVariableOrdering| *Packages*)
    (make-instance '|UserDefinedVariableOrderingType|)))

\end{chunk}

\subsection{UTSodetools}
\index[pkg]{UTSodetools!Domain}
\index[pkg]{Domain!UTSodetools}
\index[pkg]{UTSODETL}
\begin{chunk}{defclass UTSodetoolsType}
(defclass |UTSodetoolsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UTSodetools")
   (marker :initform 'package)
   (abbreviation :initform 'UTSODETL)
   (comment :initform (list
     "RUTSodetools provides tools to interface with the series"
     "ODE solver when presented with linear ODEs."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UTSodetools|
  (progn
    (push '|UTSodetools| *Packages*)
    (make-instance '|UTSodetoolsType|)))

\end{chunk}

\subsection{U32VectorPolynomialOperations}
\index[pkg]{U32VectorPolynomialOperations!Domain}
\index[pkg]{Domain!U32VectorPolynomialOperations}
\index[pkg]{POLYVEC}
\begin{chunk}{defclass U32VectorPolynomialOperationsType}
(defclass |U32VectorPolynomialOperationsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "U32VectorPolynomialOperations")
   (marker :initform 'package)
   (abbreviation :initform 'POLYVEC)
   (comment :initform (list
     "This is a low-level package which implements operations"
     "on vectors treated as univariate modular polynomials.  Most"
     "operations takes modulus as parameter.  Modulus is machine"
     "sized prime which should be small enough to avoid overflow"
     "in intermediate calculations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |U32VectorPolynomialOperations|
  (progn
    (push '|U32VectorPolynomialOperations| *Packages*)
    (make-instance '|U32VectorPolynomialOperationsType|)))

\end{chunk}

\section{V}

\subsection{VectorFunctions2}
\index[pkg]{VectorFunctions2!Domain}
\index[pkg]{Domain!VectorFunctions2}
\index[pkg]{VECTOR2}
\begin{chunk}{defclass VectorFunctions2Type}
(defclass |VectorFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "VectorFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'VECTOR2)
   (comment :initform (list
     "This package provides operations which all take as arguments"
     "vectors of elements of some type A and functions from A to"
     "another of type B. The operations all iterate over their vector argument"
     "and either return a value of type B or a vector over B."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |VectorFunctions2|
  (progn
    (push '|VectorFunctions2| *Packages*)
    (make-instance '|VectorFunctions2Type|)))

\end{chunk}

\subsection{ViewDefaultsPackage}
\index[pkg]{ViewDefaultsPackage!Domain}
\index[pkg]{Domain!ViewDefaultsPackage}
\index[pkg]{VIEWDEF}
\begin{chunk}{defclass ViewDefaultsPackageType}
(defclass |ViewDefaultsPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ViewDefaultsPackage")
   (marker :initform 'package)
   (abbreviation :initform 'VIEWDEF)
   (comment :initform (list
     "ViewportDefaultsPackage describes default and user definable"
     "values for graphics"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ViewDefaultsPackage|
  (progn
    (push '|ViewDefaultsPackage| *Packages*)
    (make-instance '|ViewDefaultsPackageType|)))

\end{chunk}

\subsection{ViewportPackage}
\index[pkg]{ViewportPackage!Domain}
\index[pkg]{Domain!ViewportPackage}
\index[pkg]{VIEW}
\begin{chunk}{defclass ViewportPackageType}
(defclass |ViewportPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ViewportPackage")
   (marker :initform 'package)
   (abbreviation :initform 'VIEW)
   (comment :initform (list
     "ViewportPackage provides functions for creating GraphImages"
     "and TwoDimensionalViewports from lists of lists of points."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ViewportPackage|
  (progn
    (push '|ViewportPackage| *Packages*)
    (make-instance '|ViewportPackageType|)))

\end{chunk}

\section{W}

\subsection{WeierstrassPreparation}
\index[pkg]{WeierstrassPreparation!Domain}
\index[pkg]{Domain!WeierstrassPreparation}
\index[pkg]{WEIER}
\begin{chunk}{defclass WeierstrassPreparationType}
(defclass |WeierstrassPreparationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "WeierstrassPreparation")
   (marker :initform 'package)
   (abbreviation :initform 'WEIER)
   (comment :initform (list
     "This package implements the Weierstrass preparation"
     "theorem f or multivariate power series."
     "weierstrass(v,p) where v is a variable, and p is a"
     "TaylorSeries(R) in which the terms"
     "of lowest degree s must include c*v**s where c is a constant,s>0,"
     "is a list of TaylorSeries coefficients A[i] of the equivalent polynomial"
     "A = A[0] + A[1]*v + A[2]*v**2 + ... + A[s-1]*v**(s-1) + v**s"
     "such that p=A*B , B being a TaylorSeries of minimum degree 0"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |WeierstrassPreparation|
  (progn
    (push '|WeierstrassPreparation| *Packages*)
    (make-instance '|WeierstrassPreparationType|)))

\end{chunk}

\subsection{WildFunctionFieldIntegralBasis}
\index[pkg]{WildFunctionFieldIntegralBasis!Domain}
\index[pkg]{Domain!WildFunctionFieldIntegralBasis}
\index[pkg]{WFFINTBS}
\begin{chunk}{defclass WildFunctionFieldIntegralBasisType}
(defclass |WildFunctionFieldIntegralBasisType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "WildFunctionFieldIntegralBasis")
   (marker :initform 'package)
   (abbreviation :initform 'WFFINTBS)
   (comment :initform (list
     "In this package K is a finite field, R is a ring of univariate"
     "polynomials over K, and F is a framed algebra over R.  The package"
     "provides a function to compute the integral closure of R in the quotient"
     "field of F as well as a function to compute a 'local integral basis'"
     "at a specific prime."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |WildFunctionFieldIntegralBasis|
  (progn
    (push '|WildFunctionFieldIntegralBasis| *Packages*)
    (make-instance '|WildFunctionFieldIntegralBasisType|)))

\end{chunk}

\section{X}

\subsection{XExponentialPackage}
\index[pkg]{XExponentialPackage!Domain}
\index[pkg]{Domain!XExponentialPackage}
\index[pkg]{XIXPPKG}
\begin{chunk}{defclass XExponentialPackageType}
(defclass |XExponentialPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "XExponentialPackage")
   (marker :initform 'package)
   (abbreviation :initform 'XEXPPKG)
   (comment :initform (list
     "This package provides computations of logarithms and exponentials"
     "for polynomials in non-commutative variables."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |XExponentialPackage|
  (progn
    (push '|XExponentialPackage| *Packages*)
    (make-instance '|XExponentialPackageType|)))

\end{chunk}

\section{Z}

\subsection{ZeroDimensionalSolvePackage}
\index[pkg]{ZeroDimensionalSolvePackage!Domain}
\index[pkg]{Domain!ZeroDimensionalSolvePackage}
\index[pkg]{ZDSOLVE}
\begin{chunk}{defclass ZeroDimensionalSolvePackageType}
(defclass |ZeroDimensionalSolvePackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ZeroDimensionalSolvePackage")
   (marker :initform 'package)
   (abbreviation :initform 'ZDSOLVE)
   (comment :initform (list
     "A package for computing symbolically the complex and real roots of"
     "zero-dimensional algebraic systems over the integer or rational"
     "numbers. Complex roots are given by means of univariate representations"
     "of irreducible regular chains. Real roots are given by means of tuples"
     "of coordinates lying in the RealClosure of the coefficient ring."
     "This constructor takes three arguments. The first one R is the"
     "coefficient ring. The second one ls is the list of variables"
     "involved in the systems to solve. The third one must be concat(ls,s)"
     "where s is an additional symbol used for the univariate"
     "representations."
     "WARNING. The third argument is not checked."
     "All operations are based on triangular decompositions."
     "The default is to compute these decompositions directly from the input"
     "system by using the RegularChain domain constructor."
     "The lexTriangular algorithm can also be used for computing these"
     "decompositions (see LexTriangularPackage package constructor)."
     "For that purpose, the operations univariateSolve, realSolve and"
     "positiveSolve admit an optional argument."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list 
     (make-signature '|triangSolve| '(List |RegularChain| R ls) '(LP B B)
       (list
        "binomial(n,r) returns the \spad{(n,r)} binomial coefficient"
        "(often denoted in the literature by \spad{C(n,r)})."
        "Note that \spad{C(n,r) = n!/(r!(n-r)!)} where \spad{n >= r >= 0}.")
       (list
        "[binomial(5,i) for i in 0..5]"))
     (make-signature '|triangSolve| '(List |RegularChain| R ls) '(LP B)
       (list
         "factorial(n) computes the factorial of n"
         "(denoted in the literature by \spad{n!})"
         "Note that \spad{n! = n (n-1)! when n > 0}; also, \spad{0! = 1}."))
     (make-signature '|triangSolve| '(List |RegularChain| R ls) '(LP)
       (list
         "factorial(n) computes the factorial of n"
         "(denoted in the literature by \spad{n!})"
         "Note that \spad{n! = n (n-1)! when n > 0}; also, \spad{0! = 1}."))
     (make-signature '|permutation| '% '(% %)
       (list
         "permutation(n, m) returns the number of"
         "permutations of n objects taken m at a time."
         "Note that \spad{permutation(n,m) = n!/(n-m)!}."))))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ZeroDimensionalSolvePackage|
  (progn
    (push '|ZeroDimensionalSolvePackage| *Packages*)
    (make-instance '|ZeroDimensionalSolvePackageType|)))

\end{chunk}

\chapter{Support code}

The {\bf SigSort} function is called {\bf during build} 
\index[doc]{SigSort}
from the Makefile to sort the
{\bf signature.tex} file. The {\bf signatures.tex} file contains
lines like:
\begin{verbatim}
  \hyperpage {46}\hskip 1em\relax pretty : treeform $\rightarrow $ values
\end{verbatim}
which is the tex code to generate the signature for the function
{\bf pretty}
\[pretty : treeform \rightarrow values\]

The {\bf SigSort} function is called to sort these lines. The sort 
is by name so we select out the name, using it as a hash key to
remember the whole line. Finally we sort the hash keys and then
walk the sorted keys to output the sorted lines.

\index[code]{defun!SigSort}
\index[code]{SigSort!defun}
\begin{chunk}{defun.SigSort}
(defun SigSort ()
  (let ((point 0) (mark 0) name (table (make-hash-table)) keys)
    (with-open-file (sigOut "signatures.sort" :direction :output
                                              :if-exists :supersede)
      (with-open-file (sigIn "signatures.tex" :direction :input)
        (loop for line = (read-line sigIn nil nil)
          while line do
             (when (setq point (search "relax" line))
               (setq point (+ 6 point))
               (setq mark (- (1- (search ":" line)) point))
               (setq name (subseq line point (+ point mark)))
               (setf (gethash (string-downcase name) table) line))))
     (maphash #'(lambda (k v)
                  (declare (ignore v))
                  (push k keys)) table)
     (setq keys (sort keys #'string<))
     (loop for key in keys do
       (format sigOut "~a~%~%" (gethash key table))))))

(progn (SigSort) (quit))

\end{chunk}

\begin{chunk}{all}

(deftype Tnulllist () '(or null list))

\getchunk{defvar categories}
\getchunk{defvar domains}
\getchunk{defvar forcelongs}
\getchunk{defvar indent}
\getchunk{defun pretty}
\getchunk{defvar comptrace}
\getchunk{defvar infixOperations}
\getchunk{defvar packages}
\getchunk{defvar place}
\getchunk{defvar theparse}

\getchunk{defclass hasclause}
\getchunk{defclass haslist}
\getchunk{defclass AxiomClass}
\getchunk{defclass FSM-VAR}
\getchunk{defclass WithClass}
\getchunk{defclass AddClass}
\getchunk{defclass signature}
\getchunk{defclass amacro}
\getchunk{defclass operation}
\getchunk{defclass CDPSigClass}
\getchunk{defclass ParserClass}
\getchunk{defclass gather}
\getchunk{defclass sourcecode}
\getchunk{defclass abbreviation}
\getchunk{defclass specification}
\getchunk{defclass operation}

\getchunk{defgeneric showSig}
\getchunk{defgeneric operation-add}

\getchunk{defmethod print-object}
\getchunk{defmethod operation-add}
\getchunk{defmethod showSig}

\getchunk{defmacro birth}
\getchunk{defmacro defunt}
\getchunk{defmacro depthof}
\getchunk{defmacro expect}
\getchunk{defmacro FSM-abbname}
\getchunk{defmacro FSM-AND}
\getchunk{defmacro FSM-cdpname}
\getchunk{defmacro FSM-dword}
\getchunk{defmacro FSM-gather}
\getchunk{defmacro FSM-match}
\getchunk{defmacro FSM-OR}
\getchunk{defmacro FSM-startsWith}
\getchunk{defmacro FSM-uword}
\getchunk{defmacro FSM-word}
\getchunk{defmacro ll}
\getchunk{defmacro must}
\getchunk{defmacro nameof}
\getchunk{defmacro trim}

\getchunk{defun indent}
\getchunk{defun spawn}
\getchunk{defun splitchar}
\getchunk{defun pile2tree}
\getchunk{defun make-abbreviation}
\getchunk{defun joinsplit}

\getchunk{defun compileSpad}
\getchunk{defun explode}
\getchunk{defun FSM-abbrev}
\getchunk{defun FSM-gatherList}
\getchunk{defun FSM-gatherVars}
\getchunk{defun FSM-catBody}
\getchunk{defun FSM-cdpsig}
\getchunk{defun FSM-comment}
\getchunk{defun FSM-dpBody}
\getchunk{defun FSM-extract1Macro}
\getchunk{defun FSM-isCategory?}
\getchunk{defun FSM-macroNames}
\getchunk{defun FSM-macros}
\getchunk{defun FSM-variables}
\getchunk{defun FSMSIG}
\getchunk{defun getAncestors}
\getchunk{defun getDomains}
\getchunk{defun joinsplit}
\getchunk{defun leaves}
\getchunk{defun make-hasclause}
\getchunk{defun make-haslist}
\getchunk{defun make-operation}
\getchunk{defun make-Sourcecode}
\getchunk{defun make-signature}
\getchunk{defun operationToSignature}
\getchunk{defun operations-show}
\getchunk{defun Parse}
\getchunk{defun parseSignature}
\getchunk{defun sane}
\getchunk{defun signatureToOperation}

\getchunk{defvar level1}
\getchunk{defclass AdditiveValuationAttributeType}
\getchunk{defclass ApproximateAttributeType}
\getchunk{defclass ArbitraryExponentAttributeType}
\getchunk{defclass ArbitraryPrecisionAttributeType}
\getchunk{defclass ArcHyperbolicFunctionCategoryType}
\getchunk{defclass ArcTrigonometricFunctionCategoryType}
\getchunk{defclass AttributeRegistryType}
\getchunk{defclass BasicTypeType}
\getchunk{defclass CanonicalAttributeType}
\getchunk{defclass CanonicalClosedAttributeType}
\getchunk{defclass CanonicalUnitNormalAttributeType}
\getchunk{defclass CentralAttributeType}
\getchunk{defclass CoercibleToType}
\getchunk{defclass CombinatorialFunctionCategoryType}
\getchunk{defclass CommutativeStarAttributeType}
\getchunk{defclass ConvertibleToType}
\getchunk{defclass ElementaryFunctionCategoryType}
\getchunk{defclass EltableType}
\getchunk{defclass FiniteAggregateAttributeType}
\getchunk{defclass HyperbolicFunctionCategoryType}
\getchunk{defclass InnerEvalableType}
\getchunk{defclass JacobiIdentityAttributeType}
\getchunk{defclass LazyRepresentationAttributeType}
\getchunk{defclass LeftUnitaryAttributeType}
\getchunk{defclass ModularAlgebraicGcdOperationsType}
\getchunk{defclass MultiplicativeValuationAttributeType}
\getchunk{defclass NoZeroDivisorsAttributeType}
\getchunk{defclass NotherianAttributeType}
\getchunk{defclass NullSquareAttributeType}
\getchunk{defclass OpenMathType}
\getchunk{defclass PartialTranscendentalFunctionsType}
\getchunk{defclass PartiallyOrderedSetAttributeType}
\getchunk{defclass PrimitiveFunctionCategoryType}
\getchunk{defclass RadicalCategoryType}
\getchunk{defclass RetractableToType}
\getchunk{defclass RightUnitaryAttributeType}
\getchunk{defclass ShallowlyMutableAttributeType}
\getchunk{defclass SpecialFunctionCategoryType}
\getchunk{defclass TrigonometricFunctionCategoryType}
\getchunk{defclass TypeType}
\getchunk{defclass UnitsKnownAttributeType}

\getchunk{defvar level2}
\getchunk{defclass AggregateType}
\getchunk{defclass CombinatorialOpsCategoryType}
\getchunk{defclass EltableAggregateType}
\getchunk{defclass EvalableType}
\getchunk{defclass FortranProgramCategoryType}
\getchunk{defclass FullyRetractableToType}
\getchunk{defclass LogicType}
\getchunk{defclass PatternableType}
\getchunk{defclass PlottablePlaneCurveCategoryType}
\getchunk{defclass PlottableSpaceCurveCategoryType}
\getchunk{defclass RealConstantType}
\getchunk{defclass SegmentCategoryType}
\getchunk{defclass SetCategoryType}
\getchunk{defclass TranscendentalFunctionCategoryType}

\getchunk{defvar level3}
\getchunk{defclass AbelianSemiGroupType}
\getchunk{defclass BlowUpMethodCategoryType}
\getchunk{defclass ComparableType}
\getchunk{defclass FileCategoryType}
\getchunk{defclass FileNameCategoryType}
\getchunk{defclass FiniteType}
\getchunk{defclass FortranFunctionCategoryType}
\getchunk{defclass FortranMatrixCategoryType}
\getchunk{defclass FortranMatrixFunctionCategoryType}
\getchunk{defclass FortranVectorCategoryType}
\getchunk{defclass FortranVectorFunctionCategoryType}
\getchunk{defclass FullyEvalableOverType}
\getchunk{defclass GradedModuleType}
\getchunk{defclass HomogeneousAggregateType}
\getchunk{defclass IndexedDirectProductCategoryType}
\getchunk{defclass LiouvillianFunctionCategoryType}
\getchunk{defclass MonadType}
\getchunk{defclass NumericalIntegrationCategoryType}
\getchunk{defclass NumericalOptimizationCategoryType}
\getchunk{defclass OrderedSetType}
\getchunk{defclass OrdinaryDifferentialEquationsSolverCategoryType}
\getchunk{defclass PartialDifferentialEquationsSolverCategoryType}
\getchunk{defclass PatternMatchableType}
\getchunk{defclass RealRootCharacterizationCategoryType}
\getchunk{defclass SExpressionCategoryType}
\getchunk{defclass SegmentExpansionCategoryType}
\getchunk{defclass SemiGroupType}
\getchunk{defclass SetCategoryWithDegreeType}
\getchunk{defclass StepThroughType}
\getchunk{defclass ThreeSpaceCategoryType}

\getchunk{defvar level4}
\getchunk{defclass AbelianMonoidType}
\getchunk{defclass AffineSpaceCategoryType}
\getchunk{defclass BagAggregateType}
\getchunk{defclass CachableSetType}
\getchunk{defclass CollectionType}
\getchunk{defclass DifferentialVariableCategoryType}
\getchunk{defclass ExpressionSpaceType}
\getchunk{defclass FullyPatternMatchableType}
\getchunk{defclass GradedAlgebraType}
\getchunk{defclass IndexedAggregateType}
\getchunk{defclass InfinitlyClosePointCategoryType}
\getchunk{defclass MonadWithUnitType}
\getchunk{defclass MonoidType}
\getchunk{defclass |OrderedAbelianSemiGroupType}
\getchunk{defclass OrderedFiniteType}
\getchunk{defclass PlacesCategoryType}
\getchunk{defclass ProjectiveSpaceCategoryType}
\getchunk{defclass RecursiveAggregateType}
\getchunk{defclass TwoDimensionalArrayCategoryType}

\getchunk{defvar level5}
\getchunk{defclass BinaryRecursiveAggregateType}
\getchunk{defclass CancellationAbelianMonoidType}
\getchunk{defclass DesingTreeCategoryType}
\getchunk{defclass DoublyLinkedAggregateType}
\getchunk{defclass GroupType}
\getchunk{defclass LinearAggregateType}
\getchunk{defclass MatrixCategoryType}
\getchunk{defclass OrderedAbelianMonoidType}
\getchunk{defclass OrderedMonoidType}
\getchunk{defclass PolynomialSetCategoryType}
\getchunk{defclass PriorityQueueAggregateType}
\getchunk{defclass QueueAggregateType}
\getchunk{defclass SetAggregateType}
\getchunk{defclass StackAggregateType}
\getchunk{defclass UnaryRecursiveAggregateType}

\getchunk{defvar level6}
\getchunk{defclass AbelianGroupType}
\getchunk{defclass BinaryTreeCategoryType}
\getchunk{defclass DequeueAggregateType}
\getchunk{defclass DictionaryOperationsType}
\getchunk{defclass ExtensibleLinearAggregateType}
\getchunk{defclass FiniteLinearAggregateType}
\getchunk{defclass FreeAbelianMonoidCategoryType}
\getchunk{defclass OrderedCancellationAbelianMonoidType}
\getchunk{defclass PermutationCategoryType}
\getchunk{defclass StreamAggregateType}
\getchunk{defclass TriangularSetCategoryType}

\getchunk{defvar level7}
\getchunk{defclass DictionaryType}
\getchunk{defclass FiniteDivisorCategoryType}
\getchunk{defclass LazyStreamAggregateType}
\getchunk{defclass LeftModuleType}
\getchunk{defclass ListAggregateType}
\getchunk{defclass MultiDictionaryType}
\getchunk{defclass MultisetAggregateType}
\getchunk{defclass NonAssociativeRngType}
\getchunk{defclass OneDimensionalArrayAggregateType}
\getchunk{defclass OrderedAbelianGroupType}
\getchunk{defclass OrderedAbelianMonoidSupType}
\getchunk{defclass RegularTriangularSetCategoryType}
\getchunk{defclass RightModuleType}
\getchunk{defclass RngType}

\getchunk{defvar level8}
\getchunk{defclass BiModuleType}
\getchunk{defclass |BitAggregateType}
\getchunk{defclass FiniteSetAggregateType}
\getchunk{defclass KeyedDictionaryType}
\getchunk{defclass NonAssociativeRingType}
\getchunk{defclass NormalizedTriangularSetCategoryType}
\getchunk{defclass OrderedMultisetAggregateType}
\getchunk{defclass RingType}
\getchunk{defclass SquareFreeRegularTriangularSetCategoryType}
\getchunk{defclass StringAggregateType}
\getchunk{defclass |VectorCategoryType}

\getchunk{defvar level9}
\getchunk{defclass CharacteristicNonZeroType}
\getchunk{defclass CharacteristicZeroType}
\getchunk{defclass CommutativeRingType}
\getchunk{defclass DifferentialRingType}
\getchunk{defclass EntireRingType}
\getchunk{defclass LeftAlgebraType}
\getchunk{defclass LinearlyExplicitRingOverType}
\getchunk{defclass ModuleType}
\getchunk{defclass OrderedRingType}
\getchunk{defclass PartialDifferentialRingType}
\getchunk{defclass PointCategoryType}
\getchunk{defclass SquareFreeNormalizedTriangularSetCategoryType}
\getchunk{defclass StringCategoryType}
\getchunk{defclass TableAggregateType}

\getchunk{defvar level10}
\getchunk{defclass AlgebraType}
\getchunk{defclass AssociationListAggregateType}
\getchunk{defclass DifferentialExtensionType}
\getchunk{defclass DivisorCategoryType}
\getchunk{defclass FreeModuleCatType}
\getchunk{defclass FullyLinearlyExplicitRingOverType}
\getchunk{defclass LeftOreRingType}
\getchunk{defclass LieAlgebraType}
\getchunk{defclass NonAssociativeAlgebraType}
\getchunk{defclass RectangularMatrixCategoryType}
\getchunk{defclass VectorSpaceType}

\getchunk{defvar level11}
\getchunk{defclass DirectProductCategoryType}
\getchunk{defclass DivisionRingType}
\getchunk{defclass FiniteRankAlgebraType}
\getchunk{defclass FiniteRankNonAssociativeAlgebraType}
\getchunk{defclass FreeLieAlgebraType}
\getchunk{defclass IntegralDomainType}
\getchunk{defclass MonogenicLinearOperatorType}
\getchunk{defclass OctonionCategoryType}
\getchunk{defclass SquareMatrixCategoryType}
\getchunk{defclass UnivariateSkewPolynomialCategoryType}
\getchunk{defclass XAlgebraType}

\getchunk{defvar level12}
\getchunk{defclass AbelianMonoidRingType}
\getchunk{defclass FortranMachineTypeCategoryType}
\getchunk{defclass FramedAlgebraType}
\getchunk{defclass FramedNonAssociativeAlgebraType}
\getchunk{defclass GcdDomainType}
\getchunk{defclass LinearOrdinaryDifferentialOperatorCategoryType}
\getchunk{defclass OrderedIntegralDomainType}
\getchunk{defclass QuaternionCategoryType}
\getchunk{defclass XFreeAlgebraType}

\getchunk{defvar level13}
\getchunk{defclass FiniteAbelianMonoidRingType}
\getchunk{defclass IntervalCategoryType}
\getchunk{defclass PowerSeriesCategoryType}
\getchunk{defclass PrincipalIdealDomainType}
\getchunk{defclass UniqueFactorizationDomainType}
\getchunk{defclass XPolynomialsCatType}

\getchunk{defvar level14}
\getchunk{defclass EuclideanDomainType}
\getchunk{defclass MultivariateTaylorSeriesCategoryType}
\getchunk{defclass PolynomialFactorizationExplicitType}
\getchunk{defclass UnivariatePowerSeriesCategoryType}

\getchunk{defvar level15}
\getchunk{defclass FieldType}
\getchunk{defclass IntegerNumberSystemType}
\getchunk{defclass PAdicIntegerCategoryType}
\getchunk{defclass PolynomialCategoryType}
\getchunk{defclass UnivariateTaylorSeriesCategoryType}

\getchunk{defvar level16}
\getchunk{defclass AlgebraicallyClosedFieldType}
\getchunk{defclass DifferentialPolynomialCategoryType}
\getchunk{defclass FieldOfPrimeCharacteristicType}
\getchunk{defclass FunctionSpaceType}
\getchunk{defclass LocalPowerSeriesCategoryType}
\getchunk{defclass PseudoAlgebraicClosureOfPerfectFieldCategoryType}
\getchunk{defclass QuotientFieldCategoryType}
\getchunk{defclass RealClosedFieldType}
\getchunk{defclass RealNumberSystemType}
\getchunk{defclass RecursivePolynomialCategoryType}
\getchunk{defclass UnivariateLaurentSeriesCategoryType}
\getchunk{defclass UnivariatePolynomialCategoryType}
\getchunk{defclass UnivariatePuiseuxSeriesCategoryType}

\getchunk{defvar level17}
\getchunk{defclass AlgebraicallyClosedFunctionSpaceType}
\getchunk{defclass ExtensionFieldType}
\getchunk{defclass FiniteFieldCategoryType}
\getchunk{defclass FloatingPointSystemType}
\getchunk{defclass UnivariateLaurentSeriesConstructorCategoryType}
\getchunk{defclass UnivariatePuiseuxSeriesConstructorCategoryType}

\getchunk{defvar level18}
\getchunk{defclass FiniteAlgebraicExtensionFieldType}
\getchunk{defclass MonogenicAlgebraType}
\getchunk{defclass PseudoAlgebraicClosureOfFiniteFieldCategoryType}
\getchunk{defclass PseudoAlgebraicClosureOfRationalNumberCategoryType}

\getchunk{defvar level19}
\getchunk{defclass ComplexCategoryType}
\getchunk{defclass FunctionFieldCategoryType}
\getchunk{defclass PseudoAlgebraicClosureOfAlgExtOfRationalNumberCategoryType}
\getchunk{defclass AffinePlaneType}
\getchunk{defclass AffinePlaneOverPseudoAlgebraicClosureOfFiniteFieldType}
\getchunk{defclass AffineSpaceType}
\getchunk{defclass AlgebraGivenByStructuralConstantsType}
\getchunk{defclass AlgebraicFunctionFieldType}
\getchunk{defclass AlgebraicNumberType}
\getchunk{defclass AnonymousFunctionType}
\getchunk{defclass AntiSymmType}
\getchunk{defclass AnyType}
\getchunk{defclass ArrayStackType}
\getchunk{defclass Asp1Type}
\getchunk{defclass Asp10Type}
\getchunk{defclass |Asp12Type}
\getchunk{defclass Asp19Type}
\getchunk{defclass Asp20Type}
\getchunk{defclass Asp24Type}
\getchunk{defclass Asp27Type}
\getchunk{defclass Asp28Type}
\getchunk{defclass Asp29Type}
\getchunk{defclass Asp30Type}
\getchunk{defclass Asp31Type}
\getchunk{defclass Asp33Type}
\getchunk{defclass Asp34Type}
\getchunk{defclass Asp35Type}
\getchunk{defclass Asp4Type}
\getchunk{defclass Asp41Type}
\getchunk{defclass Asp42Type}
\getchunk{defclass Asp49Type}
\getchunk{defclass Asp50Type}
\getchunk{defclass Asp55Type}
\getchunk{defclass Asp6Type}
\getchunk{defclass Asp7Type}
\getchunk{defclass Asp73Type}
\getchunk{defclass Asp74Type}
\getchunk{defclass Asp77Type}
\getchunk{defclass Asp78Type}
\getchunk{defclass Asp8Type}
\getchunk{defclass Asp80Type}
\getchunk{defclass Asp9Type}
\getchunk{defclass AssociatedJordanAlgebraType}
\getchunk{defclass AssociatedLieAlgebraType}
\getchunk{defclass AssociationListType}
\getchunk{defclass AttributeButtonsType}
\getchunk{defclass AutomorphismType}
\getchunk{defclass BalancedBinaryTreeType}
\getchunk{defclass BalancedPAdicIntegerType}
\getchunk{defclass BalancedPAdicRationalType}
\getchunk{defclass BasicFunctionsType}
\getchunk{defclass BasicOperatorType}
\getchunk{defclass BasicStochasticDifferentialType}
\getchunk{defclass BinaryExpansionType}
\getchunk{defclass BinaryFileType}
\getchunk{defclass BinarySearchTreeType}
\getchunk{defclass BinaryTournamentType}
\getchunk{defclass BinaryTreeType}
\getchunk{defclass BitsType}
\getchunk{defclass BlowUpWithHamburgerNoetherType}
\getchunk{defclass BlowUpWithQuadTransType}
\getchunk{defclass BooleanType}
\getchunk{defclass CardinalNumberType}
\getchunk{defclass CartesianTensorType}
\getchunk{defclass CellType}
\getchunk{defclass CharacterType}
\getchunk{defclass CharacterClassType}
\getchunk{defclass CliffordAlgebraType}
\getchunk{defclass ColorType}
\getchunk{defclass CommutatorType}
\getchunk{defclass ComplexType}
\getchunk{defclass ComplexDoubleFloatMatrixType}
\getchunk{defclass ComplexDoubleFloatVectorType}
\getchunk{defclass ContinuedFractionType}
\getchunk{defclass DatabaseType}
\getchunk{defclass DataListType}
\getchunk{defclass DecimalExpansionType}
\getchunk{defclass DenavitHartenbergMatrixType}
\getchunk{defclass DequeueType}
\getchunk{defclass DeRhamComplexType}
\getchunk{defclass DesingTreeType}
\getchunk{defclass DifferentialSparseMultivariatePolynomialType}
\getchunk{defclass DirectProductType}
\getchunk{defclass DirectProductMatrixModuleType}
\getchunk{defclass DirectProductModuleType}
\getchunk{defclass DirichletRingType}
\getchunk{defclass DistributedMultivariatePolynomialType}
\getchunk{defclass DivisorType}
\getchunk{defclass DoubleFloatType}
\getchunk{defclass DoubleFloatMatrixType}
\getchunk{defclass DoubleFloatVectorType}
\getchunk{defclass DrawOptionType}
\getchunk{defclass d01ajfAnnaTypeType}
\getchunk{defclass d01akfAnnaTypeType}
\getchunk{defclass d01alfAnnaTypeType}
\getchunk{defclass d01amfAnnaTypeType}
\getchunk{defclass d01anfAnnaTypeType}
\getchunk{defclass d01apfAnnaTypeType}
\getchunk{defclass d01aqfAnnaTypeType}
\getchunk{defclass d01asfAnnaTypeType}
\getchunk{defclass d01fcfAnnaTypeType}
\getchunk{defclass d01gbfAnnaTypeType}
\getchunk{defclass d01TransformFunctionTypeType}
\getchunk{defclass d02bbfAnnaTypeType}
\getchunk{defclass d02bhfAnnaTypeType}
\getchunk{defclass d02cjfAnnaTypeType}
\getchunk{defclass d02ejfAnnaTypeType}
\getchunk{defclass d03eefAnnaTypeType}
\getchunk{defclass d03fafAnnaTypeType}
\getchunk{defclass ElementaryFunctionsUnivariateLaurentSeriesType}
\getchunk{defclass ElementaryFunctionsUnivariatePuiseuxSeriesType}
\getchunk{defclass EquationType}
\getchunk{defclass EqTableType}
\getchunk{defclass EuclideanModularRingType}
\getchunk{defclass ExitType}
\getchunk{defclass ExponentialExpansionType}
\getchunk{defclass ExpressionType}
\getchunk{defclass ExponentialOfUnivariatePuiseuxSeriesType}
\getchunk{defclass ExtAlgBasisType}
\getchunk{defclass e04dgfAnnaTypeType}
\getchunk{defclass e04fdfAnnaTypeType}
\getchunk{defclass e04gcfAnnaTypeType}
\getchunk{defclass e04jafAnnaTypeType}
\getchunk{defclass e04mbfAnnaTypeType}
\getchunk{defclass e04nafAnnaTypeType}
\getchunk{defclass e04ucfAnnaTypeType}
\getchunk{defclass FactoredType}
\getchunk{defclass FileType}
\getchunk{defclass FileNameType}
\getchunk{defclass FiniteDivisorType}
\getchunk{defclass FiniteFieldType}
\getchunk{defclass FiniteFieldCyclicGroupType}
\getchunk{defclass FiniteFieldCyclicGroupExtensionType}
\getchunk{defclass FiniteFieldCyclicGroupExtensionByPolynomialType}
\getchunk{defclass FiniteFieldExtensionType}
\getchunk{defclass FiniteFieldExtensionByPolynomialType}
\getchunk{defclass FiniteFieldNormalBasisType}
\getchunk{defclass FiniteFieldNormalBasisExtensionType}
\getchunk{defclass FiniteFieldNormalBasisExtensionByPolynomialType}
\getchunk{defclass FlexibleArrayType}
\getchunk{defclass FloatType}
\getchunk{defclass FortranCodeType}
\getchunk{defclass FortranExpressionType}
\getchunk{defclass FortranProgramType}
\getchunk{defclass FortranScalarTypeType}
\getchunk{defclass FortranTemplateType}
\getchunk{defclass FortranTypeType}
\getchunk{defclass FourierComponentType}
\getchunk{defclass FourierSeriesType}
\getchunk{defclass FractionType}
\getchunk{defclass FractionalIdealType}
\getchunk{defclass FramedModuleType}
\getchunk{defclass FreeAbelianGroupType}
\getchunk{defclass FreeAbelianMonoidType}
\getchunk{defclass FreeGroupType}
\getchunk{defclass FreeModuleType}
\getchunk{defclass FreeModule1Type}
\getchunk{defclass FreeMonoidType}
\getchunk{defclass FreeNilpotentLieType}
\getchunk{defclass FullPartialFractionExpansionType}
\getchunk{defclass FunctionCalledType}
\getchunk{defclass GeneralDistributedMultivariatePolynomialType}
\getchunk{defclass GeneralModulePolynomialType}
\getchunk{defclass GenericNonAssociativeAlgebraType}
\getchunk{defclass GeneralPolynomialSetType}
\getchunk{defclass GeneralSparseTableType}
\getchunk{defclass GeneralTriangularSetType}
\getchunk{defclass GeneralUnivariatePowerSeriesType}
\getchunk{defclass GraphImageType}
\getchunk{defclass GuessOptionType}
\getchunk{defclass GuessOptionFunctions0Type}
\getchunk{defclass HashTableType}
\getchunk{defclass HeapType}
\getchunk{defclass HexadecimalExpansionType}
\getchunk{defclass HTMLFormatType}
\getchunk{defclass HomogeneousDirectProductType}
\getchunk{defclass HomogeneousDistributedMultivariatePolynomialType}
\getchunk{defclass HyperellipticFiniteDivisorType}
\getchunk{defclass InfClsPtType}
\getchunk{defclass IndexCardType}
\getchunk{defclass IndexedBitsType}
\getchunk{defclass IndexedDirectProductAbelianGroupType}
\getchunk{defclass IndexedDirectProductAbelianMonoidType}
\getchunk{defclass IndexedDirectProductObjectType}
\getchunk{defclass IndexedDirectProductOrderedAbelianMonoidType}
\getchunk{defclass IndexedDirectProductOrderedAbelianMonoidSupType}
\getchunk{defclass IndexedExponentsType}
\getchunk{defclass IndexedFlexibleArrayType}
\getchunk{defclass IndexedListType}
\getchunk{defclass IndexedMatrixType}
\getchunk{defclass IndexedOneDimensionalArrayType}
\getchunk{defclass IndexedStringType}
\getchunk{defclass IndexedTwoDimensionalArrayType}
\getchunk{defclass IndexedVectorType}
\getchunk{defclass InfiniteTupleType}
\getchunk{defclass InfinitlyClosePointType}
\getchunk{defclass InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteFieldType}
\getchunk{defclass InnerAlgebraicNumberType}
\getchunk{defclass InnerFiniteFieldType}
\getchunk{defclass InnerFreeAbelianMonoidType}
\getchunk{defclass InnerIndexedTwoDimensionalArrayType}
\getchunk{defclass InnerPAdicIntegerType}
\getchunk{defclass InnerPrimeFieldType}
\getchunk{defclass InnerSparseUnivariatePowerSeriesType}
\getchunk{defclass InnerTableType}
\getchunk{defclass InnerTaylorSeriesType}
\getchunk{defclass InputFormType}
\getchunk{defclass IntegerType}
\getchunk{defclass IntegerModType}
\getchunk{defclass IntegrationFunctionsTableType}
\getchunk{defclass IntegrationResultType}
\getchunk{defclass IntervalType}
\getchunk{defclass KernelType}
\getchunk{defclass KeyedAccessFileType}
\getchunk{defclass LaurentPolynomialType}
\getchunk{defclass LibraryType}
\getchunk{defclass LieExponentialsType}
\getchunk{defclass LiePolynomialType}
\getchunk{defclass LieSquareMatrixType}
\getchunk{defclass LinearOrdinaryDifferentialOperatorType}
\getchunk{defclass LinearOrdinaryDifferentialOperator1Type}
\getchunk{defclass LinearOrdinaryDifferentialOperator2Type}
\getchunk{defclass ListType}
\getchunk{defclass ListMonoidOpsType}
\getchunk{defclass ListMultiDictionaryType}
\getchunk{defclass LocalAlgebraType}
\getchunk{defclass LocalizeType}
\getchunk{defclass LyndonWordType}
\getchunk{defclass MachineIntegerType}
\getchunk{defclass MagmaType}
\getchunk{defclass MakeCachableSetType}
\getchunk{defclass MathMLFormatType}
\getchunk{defclass MatrixType}
\getchunk{defclass ModMonicType}
\getchunk{defclass ModularFieldType}
\getchunk{defclass ModularRingType}
\getchunk{defclass ModuleMonomialType}
\getchunk{defclass ModuleOperatorType}
\getchunk{defclass MoebiusTransformType}
\getchunk{defclass MonoidRingType}
\getchunk{defclass MultisetType}
\getchunk{defclass MultivariatePolynomialType}
\getchunk{defclass MyExpressionType}
\getchunk{defclass MyUnivariatePolynomialType}
\getchunk{defclass NeitherSparseOrDensePowerSeriesType}
\getchunk{defclass NewSparseMultivariatePolynomialType}
\getchunk{defclass NewSparseUnivariatePolynomialType}
\getchunk{defclass NoneType}
\getchunk{defclass NonNegativeIntegerType}
\getchunk{defclass NottinghamGroupType}
\getchunk{defclass NumericalIntegrationProblemType}
\getchunk{defclass NumericalODEProblemType}
\getchunk{defclass NumericalOptimizationProblemType}
\getchunk{defclass NumericalPDEProblemType}
\getchunk{defclass OctonionType}
\getchunk{defclass ODEIntensityFunctionsTableType}
\getchunk{defclass OneDimensionalArrayType}
\getchunk{defclass OnePointCompletionType}
\getchunk{defclass OpenMathConnectionType}
\getchunk{defclass OpenMathDeviceType}
\getchunk{defclass OpenMathEncodingType}
\getchunk{defclass OpenMathErrorType}
\getchunk{defclass OpenMathErrorKindType}
\getchunk{defclass OperatorType}
\getchunk{defclass OppositeMonogenicLinearOperatorType}
\getchunk{defclass OrderedCompletionType}
\getchunk{defclass OrderedDirectProductType}
\getchunk{defclass OrderedFreeMonoidType}
\getchunk{defclass OrderedVariableListType}
\getchunk{defclass OrderlyDifferentialPolynomialType}
\getchunk{defclass OrderlyDifferentialVariableType}
\getchunk{defclass OrdinaryDifferentialRingType}
\getchunk{defclass OrdinaryWeightedPolynomialsType}
\getchunk{defclass OrdSetIntsType}
\getchunk{defclass OutputFormType}
\getchunk{defclass PAdicIntegerType}
\getchunk{defclass PAdicRationalType}
\getchunk{defclass PAdicRationalConstructorType}
\getchunk{defclass PaletteType}
\getchunk{defclass ParametricPlaneCurveType}
\getchunk{defclass ParametricSpaceCurveType}
\getchunk{defclass ParametricSurfaceType}
\getchunk{defclass PartialFractionType}
\getchunk{defclass PartitionType}
\getchunk{defclass PatternType}
\getchunk{defclass PatternMatchListResultType}
\getchunk{defclass PatternMatchResultType}
\getchunk{defclass PendantTreeType}
\getchunk{defclass PermutationType}
\getchunk{defclass PermutationGroupType}
\getchunk{defclass PiType}
\getchunk{defclass PlaneAlgebraicCurvePlotType}
\getchunk{defclass PlacesType}
\getchunk{defclass PlacesOverPseudoAlgebraicClosureOfFiniteFieldType}
\getchunk{defclass PlcsType}
\getchunk{defclass PlotType}
\getchunk{defclass Plot3DType}
\getchunk{defclass PoincareBirkhoffWittLyndonBasisType}
\getchunk{defclass PointType}
\getchunk{defclass PolynomialType}
\getchunk{defclass PolynomialIdealsType}
\getchunk{defclass PolynomialRingType}
\getchunk{defclass PositiveIntegerType}
\getchunk{defclass PrimeFieldType}
\getchunk{defclass PrimitiveArrayType}
\getchunk{defclass ProductType}
\getchunk{defclass ProjectivePlaneType}
\getchunk{defclass ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteFieldType}
\getchunk{defclass ProjectiveSpaceType}
\getchunk{defclass PseudoAlgebraicClosureOfAlgExtOfRationalNumberType}
\getchunk{defclass PseudoAlgebraicClosureOfFiniteFieldType}
\getchunk{defclass PseudoAlgebraicClosureOfRationalNumberType}
\getchunk{defclass QuadraticFormType}
\getchunk{defclass QuasiAlgebraicSetType}
\getchunk{defclass QuaternionType}
\getchunk{defclass QueryEquationType}
\getchunk{defclass QueueType}
\getchunk{defclass RadicalFunctionFieldType}
\getchunk{defclass RadixExpansionType}
\getchunk{defclass RealClosureType}
\getchunk{defclass RectangularMatrixType}
\getchunk{defclass ReferenceType}
\getchunk{defclass RegularChainType}
\getchunk{defclass RegularTriangularSetType}
\getchunk{defclass ResidueRingType}
\getchunk{defclass ResultType}
\getchunk{defclass RewriteRuleType}
\getchunk{defclass RightOpenIntervalRootCharacterizationType}
\getchunk{defclass RomanNumeralType}
\getchunk{defclass RoutinesTableType}
\getchunk{defclass RuleCalledType}
\getchunk{defclass RulesetType}
\getchunk{defclass ScriptFormulaFormatType}
\getchunk{defclass SegmentType}
\getchunk{defclass SegmentBindingType}
\getchunk{defclass SetType}
\getchunk{defclass SetOfMIntegersInOneToNType}
\getchunk{defclass SequentialDifferentialPolynomialType}
\getchunk{defclass SequentialDifferentialVariableType}
\getchunk{defclass SExpressionType}
\getchunk{defclass SExpressionOfType}
\getchunk{defclass SimpleAlgebraicExtensionType}
\getchunk{defclass SimpleCellType}
\getchunk{defclass SimpleFortranProgramType}
\getchunk{defclass SingleIntegerType}
\getchunk{defclass SingletonAsOrderedSetType}
\getchunk{defclass SparseEchelonMatrixType}
\getchunk{defclass SparseMultivariatePolynomialType}
\getchunk{defclass SparseMultivariateTaylorSeriesType}
\getchunk{defclass SparseTableType}
\getchunk{defclass SparseUnivariateLaurentSeriesType}
\getchunk{defclass SparseUnivariatePolynomialType}
\getchunk{defclass SparseUnivariatePolynomialExpressionsType}
\getchunk{defclass SparseUnivariatePuiseuxSeriesType}
\getchunk{defclass SparseUnivariateSkewPolynomialType}
\getchunk{defclass SparseUnivariateTaylorSeriesType}
\getchunk{defclass SplitHomogeneousDirectProductType}
\getchunk{defclass SplittingNodeType}
\getchunk{defclass SplittingTreeType}
\getchunk{defclass SquareFreeRegularTriangularSetType}
\getchunk{defclass SquareMatrixType}
\getchunk{defclass StackType}
\getchunk{defclass StochasticDifferentialType}
\getchunk{defclass StreamType}
\getchunk{defclass StringType}
\getchunk{defclass StringTableType}
\getchunk{defclass SubSpaceType}
\getchunk{defclass SubSpaceComponentPropertyType}
\getchunk{defclass SuchThatType}
\getchunk{defclass SwitchType}
\getchunk{defclass SymbolType}
\getchunk{defclass SymbolTableType}
\getchunk{defclass SymmetricPolynomialType}
\getchunk{defclass TableType}
\getchunk{defclass TableauType}
\getchunk{defclass TaylorSeriesoType}
\getchunk{defclass TexFormatType}
\getchunk{defclass TextFileType}
\getchunk{defclass TheSymbolTableType}
\getchunk{defclass ThreeDimensionalMatrixType}
\getchunk{defclass ThreeDimensionalViewportType}
\getchunk{defclass ThreeSpaceType}
\getchunk{defclass TreeType}
\getchunk{defclass TubePlotType}
\getchunk{defclass TupleType}
\getchunk{defclass TwoDimensionalArrayType}
\getchunk{defclass TwoDimensionalViewportType}
\getchunk{defclass UnivariateFormalPowerSeriesType}
\getchunk{defclass UnivariateLaurentSeriesType}
\getchunk{defclass UnivariateLaurentSeriesConstructorType}
\getchunk{defclass UnivariatePolynomialType}
\getchunk{defclass UnivariatePuiseuxSeriesType}
\getchunk{defclass UnivariatePuiseuxSeriesConstructorType}
\getchunk{defclass UnivariatePuiseuxSeriesWithExponentialSingularityType}
\getchunk{defclass UnivariateSkewPolynomialType}
\getchunk{defclass UnivariateTaylorSeriesType}
\getchunk{defclass UnivariateTaylorSeriesCZeroType}
\getchunk{defclass UniversalSegmentType}
\getchunk{defclass U8MatrixType}
\getchunk{defclass U16MatrixType}
\getchunk{defclass U32MatrixType}
\getchunk{defclass U8VectorType}
\getchunk{defclass U16VectorType}
\getchunk{defclass U32VectorType}
\getchunk{defclass VariableType}
\getchunk{defclass VectorType}
\getchunk{defclass VoidType}
\getchunk{defclass WeightedPolynomialsType}
\getchunk{defclass WuWenTsunTriangularSetType}
\getchunk{defclass XDistributedPolynomialType}
\getchunk{defclass XPBWPolynomialType}
\getchunk{defclass XPolynomialType}
\getchunk{defclass XPolynomialRingType}
\getchunk{defclass XRecursivePolynomialType}
\getchunk{defclass AffineAlgebraicSetComputeWithGroebnerBasisType}
\getchunk{defclass AffineAlgebraicSetComputeWithResultantType}
\getchunk{defclass AlgebraicFunctionType}
\getchunk{defclass AlgebraicHermiteIntegrationType}
\getchunk{defclass AlgebraicIntegrateType}
\getchunk{defclass AlgebraicIntegrationType}
\getchunk{defclass AlgebraicManipulationsType}
\getchunk{defclass AlgebraicMultFactType}
\getchunk{defclass AlgebraPackageType}
\getchunk{defclass AlgFactorType}
\getchunk{defclass AnnaNumericalIntegrationPackageType}
\getchunk{defclass AnnaNumericalOptimizationPackageType}
\getchunk{defclass AnnaOrdinaryDifferentialEquationPackageType}
\getchunk{defclass AnnaPartialDifferentialEquationPackageType}
\getchunk{defclass AnyFunctions1Type}
\getchunk{defclass ApplicationProgramInterfaceType}
\getchunk{defclass ApplyRulesType}
\getchunk{defclass ApplyUnivariateSkewPolynomialType}
\getchunk{defclass AssociatedEquationsType}
\getchunk{defclass AttachPredicatesType}
\getchunk{defclass AxiomServerType}
\getchunk{defclass BalancedFactorisationType}
\getchunk{defclass BasicOperatorFunctions1Type}
\getchunk{defclass BezierType}
\getchunk{defclass BezoutMatrixType}
\getchunk{defclass BlowUpPackageType}
\getchunk{defclass BoundIntegerRootsType}
\getchunk{defclass BrillhartTestsType}
\getchunk{defclass CartesianTensorFunctions2Type}
\getchunk{defclass ChangeOfVariableType}
\getchunk{defclass CharacteristicPolynomialInMonogenicalAlgebraType}
\getchunk{defclass CharacteristicPolynomialPackageType}
\getchunk{defclass ChineseRemainderToolsForIntegralBasesType}
\getchunk{defclass CoerceVectorMatrixPackageType}
\getchunk{defclass CombinatorialFunctionType}
\getchunk{defclass CommonDenominatorType}
\getchunk{defclass CommonOperatorsType}
\getchunk{defclass CommuteUnivariatePolynomialCategoryType}
\getchunk{defclass ComplexFactorizationType}
\getchunk{defclass ComplexFunctions2Type}
\getchunk{defclass ComplexIntegerSolveLinearPolynomialEquationType}
\getchunk{defclass ComplexPatternType}
\getchunk{defclass ComplexPatternMatchType}
\getchunk{defclass ComplexRootFindingPackageType}
\getchunk{defclass ComplexRootPackageType}
\getchunk{defclass ComplexTrigonometricManipulationsType}
\getchunk{defclass ConstantLODEType}
\getchunk{defclass CoordinateSystemsType}
\getchunk{defclass CRApackageType}
\getchunk{defclass CycleIndicatorsType}
\getchunk{defclass CyclicStreamToolsType}
\getchunk{defclass CyclotomicPolynomialPackageType}
\getchunk{defclass CylindricalAlgebraicDecompositionPackageType}
\getchunk{defclass CylindricalAlgebraicDecompositionUtilitiesType}
\getchunk{defclass DefiniteIntegrationToolsType}
\getchunk{defclass DegreeReductionPackageType}
\getchunk{defclass DesingTreePackageType}
\getchunk{defclass DiophantineSolutionPackageType}
\getchunk{defclass DirectProductFunctions2Type}
\getchunk{defclass DiscreteLogarithmPackageType}
\getchunk{defclass DisplayPackageType}
\getchunk{defclass DistinctDegreeFactorizeType}
\getchunk{defclass DoubleFloatSpecialFunctionsType}
\getchunk{defclass DoubleResultantPackageType}
\getchunk{defclass DrawComplexType}
\getchunk{defclass DrawNumericHackType}
\getchunk{defclass DrawOptionFunctions0Type}
\getchunk{defclass DrawOptionFunctions1Type}
\getchunk{defclass d01AgentsPackageType}
\getchunk{defclass d01WeightsPackageType}
\getchunk{defclass d02AgentsPackageType}
\getchunk{defclass d03AgentsPackageType}
\getchunk{defclass EigenPackageType}
\getchunk{defclass ElementaryFunctionType}
\getchunk{defclass ElementaryFunctionDefiniteIntegrationType}
\getchunk{defclass ElementaryFunctionLODESolverType}
\getchunk{defclass ElementaryFunctionODESolverType}
\getchunk{defclass ElementaryFunctionSignType}
\getchunk{defclass ElementaryFunctionStructurePackageType}
\getchunk{defclass ElementaryIntegrationType}
\getchunk{defclass ElementaryRischDEType}
\getchunk{defclass ElementaryRischDESystemType}
\getchunk{defclass EllipticFunctionsUnivariateTaylorSeriesType}
\getchunk{defclass EquationFunctions2Type}
\getchunk{defclass ErrorFunctionsType}
\getchunk{defclass EuclideanGroebnerBasisPackageType}
\getchunk{defclass EvaluateCycleIndicatorsType}
\getchunk{defclass ExpertSystemContinuityPackageType}
\getchunk{defclass ExpertSystemContinuityPackage1Type}
\getchunk{defclass ExpertSystemToolsPackageType}
\getchunk{defclass ExpertSystemToolsPackage1Type}
\getchunk{defclass ExpertSystemToolsPackage2Type}
\getchunk{defclass ExpressionFunctions2Type}
\getchunk{defclass ExpressionSolveType}
\getchunk{defclass ExpressionSpaceFunctions1Type}
\getchunk{defclass ExpressionSpaceFunctions2Type}
\getchunk{defclass ExpressionSpaceODESolverType}
\getchunk{defclass ExpressionToOpenMathType}
\getchunk{defclass ExpressionToUnivariatePowerSeriesType}
\getchunk{defclass ExpressionTubePlotType}
\getchunk{defclass Export3DType}
\getchunk{defclass e04AgentsPackageType}
\getchunk{defclass FactoredFunctionsType}
\getchunk{defclass FactoredFunctions2Type}
\getchunk{defclass FactoredFunctionUtilitiesType}
\getchunk{defclass FactoringUtilitiesType}
\getchunk{defclass FactorisationOverPseudoAlgebraicClosureOfAlgExtOfRationalNumberType}
\getchunk{defclass FactorisationOverPseudoAlgebraicClosureOfRationalNumberType}
\getchunk{defclass FGLMIfCanPackageType}
\getchunk{defclass FindOrderFiniteType}
\getchunk{defclass FiniteAbelianMonoidRingFunctions2Type}
\getchunk{defclass FiniteDivisorFunctions2Type}
\getchunk{defclass FiniteFieldFactorizationType}
\getchunk{defclass FiniteFieldFactorizationWithSizeParseBySideEffectType}
\getchunk{defclass FiniteFieldFunctionsType}
\getchunk{defclass FiniteFieldHomomorphismsType}
\getchunk{defclass FiniteFieldPolynomialPackageType}
\getchunk{defclass FiniteFieldPolynomialPackage2Type}
\getchunk{defclass FiniteFieldSolveLinearPolynomialEquationType}
\getchunk{defclass FiniteFieldSquareFreeDecompositionType}
\getchunk{defclass FiniteLinearAggregateFunctions2Type}
\getchunk{defclass FiniteLinearAggregateSortType}
\getchunk{defclass FiniteSetAggregateFunctions2Type}
\getchunk{defclass FloatingComplexPackageType}
\getchunk{defclass FloatingRealPackageType}
\getchunk{defclass FloatSpecialFunctionsType}
\getchunk{defclass FortranCodePackage1Type}
\getchunk{defclass FortranOutputStackPackageType}
\getchunk{defclass FortranPackageType}
\getchunk{defclass FractionalIdealFunctions2Type}
\getchunk{defclass FractionFreeFastGaussianType}
\getchunk{defclass FractionFreeFastGaussianFractionsType}
\getchunk{defclass FractionFunctions2Type}
\getchunk{defclass FramedNonAssociativeAlgebraFunctions2Type}
\getchunk{defclass FunctionalSpecialFunctionType}
\getchunk{defclass FunctionFieldCategoryFunctions2Type}
\getchunk{defclass FunctionFieldIntegralBasisType}
\getchunk{defclass FunctionSpaceAssertionsType}
\getchunk{defclass FunctionSpaceAttachPredicatesType}
\getchunk{defclass FunctionSpaceComplexIntegrationType}
\getchunk{defclass FunctionSpaceFunctions2Type}
\getchunk{defclass FunctionSpaceIntegrationType}
\getchunk{defclass FunctionSpacePrimitiveElementType}
\getchunk{defclass FunctionSpaceReduceType}
\getchunk{defclass FunctionSpaceSumType}
\getchunk{defclass FunctionSpaceToExponentialExpansionType}
\getchunk{defclass FunctionSpaceToUnivariatePowerSeriesType}
\getchunk{defclass FunctionSpaceUnivariatePolynomialFactorType}
\getchunk{defclass GaloisGroupFactorizationUtilitiesType}
\getchunk{defclass GaloisGroupFactorizerType}
\getchunk{defclass GaloisGroupPolynomialUtilitiesType}
\getchunk{defclass GaloisGroupUtilitiesType}
\getchunk{defclass GaussianFactorizationPackageType}
\getchunk{defclass GeneralHenselPackageType}
\getchunk{defclass GeneralizedMultivariateFactorizeType}
\getchunk{defclass GeneralPackageForAlgebraicFunctionFieldType}
\getchunk{defclass GeneralPolynomialGcdPackageType}
\getchunk{defclass GenerateUnivariatePowerSeriesType}
\getchunk{defclass GenExEuclidType}
\getchunk{defclass GenUFactorizeType}
\getchunk{defclass GenusZeroIntegrationType}
\getchunk{defclass GnuDrawType}
\getchunk{defclass GosperSummationMethodType}
\getchunk{defclass GraphicsDefaultsType}
\getchunk{defclass GraphvizType}
\getchunk{defclass GrayCodeType}
\getchunk{defclass GroebnerFactorizationPackageType}
\getchunk{defclass GroebnerInternalPackageType}
\getchunk{defclass GroebnerPackageType}
\getchunk{defclass GroebnerSolveType}
\getchunk{defclass GuessType}
\getchunk{defclass GuessAlgebraicNumberType}
\getchunk{defclass GuessFiniteType}
\getchunk{defclass GuessFiniteFunctionsType}
\getchunk{defclass GuessIntegerType}
\getchunk{defclass GuessPolynomialType}
\getchunk{defclass GuessUnivariatePolynomialType}
\getchunk{defclass HallBasisType}
\getchunk{defclass HeuGcdType}
\getchunk{defclass IdealDecompositionPackageType}
\getchunk{defclass IncrementingMapsType}
\getchunk{defclass InfiniteProductCharacteristicZeroType}
\getchunk{defclass InfiniteProductFiniteFieldType}
\getchunk{defclass InfiniteProductPrimeFieldType}
\getchunk{defclass InfiniteTupleFunctions2Type}
\getchunk{defclass InfiniteTupleFunctions3Type}
\getchunk{defclass InfinityType}
\getchunk{defclass InnerAlgFactorType}
\getchunk{defclass InnerCommonDenominatorType}
\getchunk{defclass InnerMatrixLinearAlgebraFunctionsType}
\getchunk{defclass InnerMatrixQuotientFieldFunctionsType}
\getchunk{defclass InnerModularGcdType}
\getchunk{defclass InnerMultFactType}
\getchunk{defclass InnerNormalBasisFieldFunctionsType}
\getchunk{defclass InnerNumericEigenPackageType}
\getchunk{defclass InnerNumericFloatSolvePackageType}
\getchunk{defclass InnerPolySignType}
\getchunk{defclass InnerPolySumType}
\getchunk{defclass InnerTrigonometricManipulationsType}
\getchunk{defclass InputFormFunctions1Type}
\getchunk{defclass InterfaceGroebnerPackageType}
\getchunk{defclass IntegerBitsType}
\getchunk{defclass IntegerCombinatoricFunctionsType}
\getchunk{defclass IntegerFactorizationPackageType}
\getchunk{defclass IntegerLinearDependenceType}
\getchunk{defclass IntegerNumberTheoryFunctionsType}
\getchunk{defclass IntegerPrimesPackageType}
\getchunk{defclass IntegerRetractionsType}
\getchunk{defclass IntegerRootsType}
\getchunk{defclass IntegerSolveLinearPolynomialEquationType}
\getchunk{defclass IntegralBasisToolsType}
\getchunk{defclass IntegralBasisPolynomialToolsType}
\getchunk{defclass IntegrationResultFunctions2Type}
\getchunk{defclass IntegrationResultRFToFunctionType}
\getchunk{defclass IntegrationResultToFunctionType}
\getchunk{defclass IntegrationToolsType}
\getchunk{defclass InternalPrintPackageType}
\getchunk{defclass InternalRationalUnivariateRepresentationPackageType}
\getchunk{defclass InterpolateFormsPackageType}
\getchunk{defclass IntersectionDivisorPackageType}
\getchunk{defclass IrredPolyOverFiniteFieldType}
\getchunk{defclass IrrRepSymNatPackageType}
\getchunk{defclass InverseLaplaceTransformType}
\getchunk{defclass KernelFunctions2Type}
\getchunk{defclass KovacicType}
\getchunk{defclass LaplaceTransformType}
\getchunk{defclass LazardSetSolvingPackageType}
\getchunk{defclass LeadingCoefDeterminationType}
\getchunk{defclass LexTriangularPackageType}
\getchunk{defclass LinearDependenceType}
\getchunk{defclass LinearOrdinaryDifferentialOperatorFactorizerType}
\getchunk{defclass LinearOrdinaryDifferentialOperatorsOpsType}
\getchunk{defclass LinearPolynomialEquationByFractionsType}
\getchunk{defclass LinearSystemFromPowerSeriesPackageType}
\getchunk{defclass LinearSystemMatrixPackageType}
\getchunk{defclass LinearSystemMatrixPackage1Type}
\getchunk{defclass LinearSystemPolynomialPackageType}
\getchunk{defclass LinGroebnerPackageType}
\getchunk{defclass LinesOpPackType}
\getchunk{defclass LiouvillianFunctionType}
\getchunk{defclass ListFunctions2Type}
\getchunk{defclass ListFunctions3Type}
\getchunk{defclass ListToMapType}
\getchunk{defclass LocalParametrizationOfSimplePointPackageType}
\getchunk{defclass MakeBinaryCompiledFunctionType}
\getchunk{defclass MakeFloatCompiledFunctionType}
\getchunk{defclass MakeFunctionType}
\getchunk{defclass MakeRecordType}
\getchunk{defclass MakeUnaryCompiledFunctionType}
\getchunk{defclass MappingPackageInternalHacks1Type}
\getchunk{defclass MappingPackageInternalHacks2Type}
\getchunk{defclass MappingPackageInternalHacks3Type}
\getchunk{defclass MappingPackage1Type}
\getchunk{defclass MappingPackage2Type}
\getchunk{defclass MappingPackage3Type}
\getchunk{defclass MappingPackage4Type}
\getchunk{defclass MatrixCategoryFunctions2Type}
\getchunk{defclass MatrixCommonDenominatorType}
\getchunk{defclass MatrixLinearAlgebraFunctionsType}
\getchunk{defclass MatrixManipulationType}
\getchunk{defclass MergeThingType}
\getchunk{defclass MeshCreationRoutinesForThreeDimensionsType}
\getchunk{defclass ModularDistinctDegreeFactorizerType}
\getchunk{defclass ModularHermitianRowReductionType}
\getchunk{defclass MonoidRingFunctions2Type}
\getchunk{defclass MonomialExtensionToolsType}
\getchunk{defclass MoreSystemCommandsType}
\getchunk{defclass MPolyCatPolyFactorizerType}
\getchunk{defclass MPolyCatRationalFunctionFactorizerType}
\getchunk{defclass MPolyCatFunctions2Type}
\getchunk{defclass MPolyCatFunctions3Type}
\getchunk{defclass MRationalFactorizeType}
\getchunk{defclass MultFiniteFactorizeType}
\getchunk{defclass MultipleMapType}
\getchunk{defclass MultiVariableCalculusFunctionsType}
\getchunk{defclass MultivariateFactorizeType}
\getchunk{defclass MultivariateLiftingType}
\getchunk{defclass MultivariateSquareFreeType}
\getchunk{defclass NagEigenPackageType}
\getchunk{defclass NagFittingPackageType}
\getchunk{defclass NagLinearEquationSolvingPackageType}
\getchunk{defclass NAGLinkSupportPackageType}
\getchunk{defclass NagIntegrationPackageType}
\getchunk{defclass NagInterpolationPackageType}
\getchunk{defclass NagLapackType}
\getchunk{defclass NagMatrixOperationsPackageType}
\getchunk{defclass NagOptimisationPackageType}
\getchunk{defclass NagOrdinaryDifferentialEquationsPackageType}
\getchunk{defclass NagPartialDifferentialEquationsPackageType}
\getchunk{defclass NagPolynomialRootsPackageType}
\getchunk{defclass NagRootFindingPackageType}
\getchunk{defclass NagSeriesSummationPackageType}
\getchunk{defclass NagSpecialFunctionsPackageType}
\getchunk{defclass NewSparseUnivariatePolynomialFunctions2Type}
\getchunk{defclass NewtonInterpolationType}
\getchunk{defclass NewtonPolygonType}
\getchunk{defclass NonCommutativeOperatorDivisionType}
\getchunk{defclass NoneFunctions1Type}
\getchunk{defclass NonLinearFirstOrderODESolverType}
\getchunk{defclass NonLinearSolvePackageType}
\getchunk{defclass NormalizationPackageType}
\getchunk{defclass NormInMonogenicAlgebraType}
\getchunk{defclass NormRetractPackageType}
\getchunk{defclass NPCoefType}
\getchunk{defclass NumberFieldIntegralBasisType}
\getchunk{defclass NumberFormatsType}
\getchunk{defclass NumberTheoreticPolynomialFunctionsType}
\getchunk{defclass NumericType}
\getchunk{defclass NumericalOrdinaryDifferentialEquationsType}
\getchunk{defclass NumericalQuadratureType}
\getchunk{defclass NumericComplexEigenPackageType}
\getchunk{defclass NumericContinuedFractionType}
\getchunk{defclass NumericRealEigenPackageType}
\getchunk{defclass NumericTubePlotType}
\getchunk{defclass OctonionCategoryFunctions2Type}
\getchunk{defclass ODEIntegrationType}
\getchunk{defclass ODEToolsType}
\getchunk{defclass OneDimensionalArrayFunctions2Type}
\getchunk{defclass OnePointCompletionFunctions2Type}
\getchunk{defclass OpenMathPackageType}
\getchunk{defclass OpenMathServerPackageType}
\getchunk{defclass OperationsQueryType}
\getchunk{defclass OrderedCompletionFunctions2Type}
\getchunk{defclass OrderingFunctionsType}
\getchunk{defclass OrthogonalPolynomialFunctionsType}
\getchunk{defclass OutputPackageType}
\getchunk{defclass PackageForAlgebraicFunctionFieldType}
\getchunk{defclass PackageForAlgebraicFunctionFieldOverFiniteFieldType}
\getchunk{defclass PackageForPolyType}
\getchunk{defclass PadeApproximantPackageType}
\getchunk{defclass PadeApproximantsType}
\getchunk{defclass PAdicWildFunctionFieldIntegralBasisType}
\getchunk{defclass ParadoxicalCombinatorsForStreamsType}
\getchunk{defclass ParametricLinearEquationsType}
\getchunk{defclass ParametricPlaneCurveFunctions2Type}
\getchunk{defclass ParametricSpaceCurveFunctions2Type}
\getchunk{defclass ParametricSurfaceFunctions2Type}
\getchunk{defclass ParametrizationPackageType}
\getchunk{defclass PartialFractionPackageType}
\getchunk{defclass PartitionsAndPermutationsType}
\getchunk{defclass PatternFunctions1Type}
\getchunk{defclass PatternFunctions2Type}
\getchunk{defclass PatternMatchType}
\getchunk{defclass PatternMatchAssertionsType}
\getchunk{defclass PatternMatchFunctionSpaceType}
\getchunk{defclass PatternMatchIntegerNumberSystemType}
\getchunk{defclass PatternMatchIntegrationType}
\getchunk{defclass PatternMatchKernelType}
\getchunk{defclass PatternMatchListAggregateType}
\getchunk{defclass PatternMatchPolynomialCategoryType}
\getchunk{defclass PatternMatchPushDownType}
\getchunk{defclass PatternMatchQuotientFieldCategoryType}
\getchunk{defclass PatternMatchResultFunctions2Type}
\getchunk{defclass PatternMatchSymbolType}
\getchunk{defclass PatternMatchToolsType}
\getchunk{defclass PermanentType}
\getchunk{defclass PermutationGroupExamplesType}
\getchunk{defclass PiCoercionsType}
\getchunk{defclass PlotFunctions1Type}
\getchunk{defclass PlotToolsType}
\getchunk{defclass ProjectiveAlgebraicSetPackageType}
\getchunk{defclass PointFunctions2Type}
\getchunk{defclass PointPackageType}
\getchunk{defclass PointsOfFiniteOrderType}
\getchunk{defclass PointsOfFiniteOrderRationalType}
\getchunk{defclass PointsOfFiniteOrderToolsType}
\getchunk{defclass PolynomialPackageForCurveType}
\getchunk{defclass PolToPolType}
\getchunk{defclass PolyGroebnerType}
\getchunk{defclass PolynomialAN2ExpressionType}
\getchunk{defclass PolynomialCategoryLiftingType}
\getchunk{defclass PolynomialCategoryQuotientFunctionsType}
\getchunk{defclass PolynomialCompositionType}
\getchunk{defclass PolynomialDecompositionType}
\getchunk{defclass PolynomialFactorizationByRecursionType}
\getchunk{defclass PolynomialFactorizationByRecursionUnivariateType}
\getchunk{defclass PolynomialFunctions2Type}
\getchunk{defclass PolynomialGcdPackageType}
\getchunk{defclass PolynomialInterpolationType}
\getchunk{defclass PolynomialInterpolationAlgorithmsType}
\getchunk{defclass PolynomialNumberTheoryFunctionsType}
\getchunk{defclass PolynomialRootsType}
\getchunk{defclass PolynomialSetUtilitiesPackageType}
\getchunk{defclass PolynomialSolveByFormulasType}
\getchunk{defclass PolynomialSquareFreeType}
\getchunk{defclass PolynomialToUnivariatePolynomialType}
\getchunk{defclass PowerSeriesLimitPackageType}
\getchunk{defclass PrecomputedAssociatedEquationsType}
\getchunk{defclass PrimitiveArrayFunctions2Type}
\getchunk{defclass PrimitiveElementType}
\getchunk{defclass PrimitiveRatDEType}
\getchunk{defclass PrimitiveRatRicDEType}
\getchunk{defclass PrintPackageType}
\getchunk{defclass PseudoLinearNormalFormType}
\getchunk{defclass PseudoRemainderSequenceType}
\getchunk{defclass PureAlgebraicIntegrationType}
\getchunk{defclass PureAlgebraicLODEType}
\getchunk{defclass PushVariablesType}
\getchunk{defclass QuasiAlgebraicSet2Type}
\getchunk{defclass QuasiComponentPackageType}
\getchunk{defclass QuotientFieldCategoryFunctions2Type}
\getchunk{defclass QuaternionCategoryFunctions2Type}
\getchunk{defclass RadicalEigenPackageType}
\getchunk{defclass RadicalSolvePackageType}
\getchunk{defclass RadixUtilitiesType}
\getchunk{defclass RandomDistributionsType}
\getchunk{defclass RandomFloatDistributionsType}
\getchunk{defclass RandomIntegerDistributionsType}
\getchunk{defclass RandomNumberSourceType}
\getchunk{defclass RationalFactorizeType}
\getchunk{defclass RationalFunctionType}
\getchunk{defclass RationalFunctionDefiniteIntegrationType}
\getchunk{defclass RationalFunctionFactorType}
\getchunk{defclass RationalFunctionFactorizerType}
\getchunk{defclass RationalFunctionIntegrationType}
\getchunk{defclass RationalFunctionLimitPackageType}
\getchunk{defclass RationalFunctionSignType}
\getchunk{defclass RationalFunctionSumType}
\getchunk{defclass RationalIntegrationType}
\getchunk{defclass RationalInterpolationType}
\getchunk{defclass RationalLODEType}
\getchunk{defclass RationalRetractionsType}
\getchunk{defclass RationalRicDEType}
\getchunk{defclass RationalUnivariateRepresentationPackageType}
\getchunk{defclass RealPolynomialUtilitiesPackageType}
\getchunk{defclass RealSolvePackageType}
\getchunk{defclass RealZeroPackageType}
\getchunk{defclass RealZeroPackageQType}
\getchunk{defclass RectangularMatrixCategoryFunctions2Type}
\getchunk{defclass RecurrenceOperatorType}
\getchunk{defclass ReducedDivisorType}
\getchunk{defclass ReduceLODEType}
\getchunk{defclass ReductionOfOrderType}
\getchunk{defclass RegularSetDecompositionPackageType}
\getchunk{defclass RegularTriangularSetGcdPackageType}
\getchunk{defclass RepeatedDoublingType}
\getchunk{defclass RepeatedSquaringType}
\getchunk{defclass RepresentationPackage1Type}
\getchunk{defclass RepresentationPackage2Type}
\getchunk{defclass ResolveLatticeCompletionType}
\getchunk{defclass RetractSolvePackageType}
\getchunk{defclass RootsFindingPackageType}
\getchunk{defclass SAERationalFunctionAlgFactorType}
\getchunk{defclass ScriptFormulaFormat1Type}
\getchunk{defclass SegmentBindingFunctions2Type}
\getchunk{defclass SegmentFunctions2Type}
\getchunk{defclass SimpleAlgebraicExtensionAlgFactorType}
\getchunk{defclass SimplifyAlgebraicNumberConvertPackageType}
\getchunk{defclass SmithNormalFormType}
\getchunk{defclass SortedCacheType}
\getchunk{defclass SortPackageType}
\getchunk{defclass SparseUnivariatePolynomialFunctions2Type}
\getchunk{defclass SpecialOutputPackageType}
\getchunk{defclass SquareFreeQuasiComponentPackageType}
\getchunk{defclass SquareFreeRegularSetDecompositionPackageType}
\getchunk{defclass SquareFreeRegularTriangularSetGcdPackageType}
\getchunk{defclass StorageEfficientMatrixOperationsType}
\getchunk{defclass StreamFunctions1Type}
\getchunk{defclass StreamFunctions2Type}
\getchunk{defclass StreamFunctions3Type}
\getchunk{defclass StreamInfiniteProductType}
\getchunk{defclass StreamTaylorSeriesOperationsType}
\getchunk{defclass StreamTensorType}
\getchunk{defclass StreamTranscendentalFunctionsType}
\getchunk{defclass StreamTranscendentalFunctionsNonCommutativeType}
\getchunk{defclass StructuralConstantsPackageType}
\getchunk{defclass SturmHabichtPackageType}
\getchunk{defclass SubResultantPackageType}
\getchunk{defclass SupFractionFactorizerType}
\getchunk{defclass SystemODESolverType}
\getchunk{defclass SystemSolvePackageType}
\getchunk{defclass SymmetricGroupCombinatoricFunctionsType}
\getchunk{defclass SymmetricFunctionsType}
\getchunk{defclass TableauxBumpersType}
\getchunk{defclass TabulatedComputationPackageType}
\getchunk{defclass TangentExpansionsType}
\getchunk{defclass TaylorSolveType}
\getchunk{defclass TemplateUtilitiesType}
\getchunk{defclass TexFormat1Type}
\getchunk{defclass ToolsForSignType}
\getchunk{defclass TopLevelDrawFunctionsType}
\getchunk{defclass TopLevelDrawFunctionsForAlgebraicCurvesType}
\getchunk{defclass TopLevelDrawFunctionsForCompiledFunctionsType}
\getchunk{defclass TopLevelDrawFunctionsForPointsType}
\getchunk{defclass TopLevelThreeSpaceType}
\getchunk{defclass TranscendentalHermiteIntegrationType}
\getchunk{defclass TranscendentalIntegrationType}
\getchunk{defclass TranscendentalManipulationsType}
\getchunk{defclass TranscendentalRischDEType}
\getchunk{defclass TranscendentalRischDESystemType}
\getchunk{defclass TransSolvePackageType}
\getchunk{defclass TransSolvePackageServiceType}
\getchunk{defclass TriangularMatrixOperationsType}
\getchunk{defclass TrigonometricManipulationsType}
\getchunk{defclass TubePlotToolsType}
\getchunk{defclass TwoDimensionalPlotClippingType}
\getchunk{defclass TwoFactorizeType}
\getchunk{defclass UnivariateFactorizeType}
\getchunk{defclass UnivariateFormalPowerSeriesFunctionsType}
\getchunk{defclass UnivariateLaurentSeriesFunctions2Type}
\getchunk{defclass UnivariatePolynomialCategoryFunctions2Type}
\getchunk{defclass UnivariatePolynomialCommonDenominatorType}
\getchunk{defclass UnivariatePolynomialDecompositionPackageType}
\getchunk{defclass UnivariatePolynomialDivisionPackageType}
\getchunk{defclass UnivariatePolynomialFunctions2Type}
\getchunk{defclass UnivariatePolynomialMultiplicationPackageType}
\getchunk{defclass UnivariatePolynomialSquareFreeType}
\getchunk{defclass UnivariatePuiseuxSeriesFunctions2Type}
\getchunk{defclass UnivariateSkewPolynomialCategoryOpsType}
\getchunk{defclass UnivariateTaylorSeriesFunctions2Type}
\getchunk{defclass UnivariateTaylorSeriesODESolverType}
\getchunk{defclass UniversalSegmentFunctions2Type}
\getchunk{defclass UserDefinedPartialOrderingType}
\getchunk{defclass UserDefinedVariableOrderingType}
\getchunk{defclass UTSodetoolsType}
\getchunk{defclass U32VectorPolynomialOperationsType}
\getchunk{defclass VectorFunctions2Type}
\getchunk{defclass ViewDefaultsPackageType}
\getchunk{defclass ViewportPackageType}
\getchunk{defclass WeierstrassPreparationType}
\getchunk{defclass WildFunctionFieldIntegralBasisType}
\getchunk{defclass XExponentialPackageType}
\getchunk{defclass ZeroDimensionalSolvePackageType}

\end{chunk}

\chapter{Musings}

This chapter contains snippets from the literature containing
ideas that need to be ``pondered''. They may or may not survive and
will almost certainly be modified beyond these notes. So this isn't
part of the document, but rather a collection of notes for later.

\section{Parsing and Printing Logic}

Harrison's book \cite{Harr09} has an appendix.

\section{Partial Types}

Robert Constable \cite{Cons12}

Partial Types as a type return value for functions that do not complete.

\section{Abstractions -- Hickey}

Rick Hickey \cite{Hick12a}

Make categories for data abstractions from clojure
Sorted, indexed, reversible, sequence 

\section{SELECT -- Hickey Spec}

Rich Hickey \cite{Hick18}

Given a tree, the {\bf select} function can extract anything from 
anywhere in the tree, root, inner nodes, or leaves to require that
those things are available to the type required by a function.

We define an address
\begin{verbatim}
(s/def ::street string?)
(s/def ::city string?)
(s/def ::state state-code?)
(s/def ::zip int?)
(s/def ::addr (s/schema [[::street ::city ::state ::zip]]))
\end{verbatim}

We define a user which has an address subtree
\begin{verbatim}
(s/def ::id int?)
(s/def ::first string?)
(s/def ::last string?)
(s/def ::user (s/schema [[::id ::first ::last ::addr]]))
\end{verbatim}

Not every function needs all of the fields so we create a select
function that ensures the needed fields exist.

Here we only need the zip from the address subtree
\begin{verbatim}
(get-movie-times user =>
  (s/select ::user [::id ::addr {::addr [::zip]}]))
\end{verbatim}

Here we need street, city, state, and zip from the address subtree
\begin{verbatim}
(place-order user =>
  (s/selct ::user
    [::first ::last ::addr
      {::addr [::street ::city ::state ::zip]}]))
\end{verbatim}

\section{A GCD proof}

Mao \cite{Maox20} gives the following proof.

Let $a=bq+r$, where $a$, $b$, $q$, and $r$ are integers. Then 
$gcd(a,b)=gcd(b,r)$.

{\bf Proof}

Supposed $d\vert a$ and $d\vert b$, then we have
\[\begin{array}{rcl}
a & = & dk_1\\
b & = & dk_2\
\end{array}\]
for some $k_1,k_2 \in \mathbb{N}$
\[\begin{array}{rcl}
r & = & a-bq\\
  & = & dk_1 - dk_2q\\
  & = & d(k_1-k_2q)
\end{array}\]

This means that any common divisor for $a$ and $b$ must also be a
divisor for $r$, and further any common divisor for $a$ and $b$ must
also be a common divisor for $b$ and $r$. So one of the common
divisors for $a$ and $b$, $gcd(a,b)$, is a common divisor for $b$ and
$r$. Since the greatest common divisor for $b$ and $r$ is $gcd(b,r)$,
then we have $gcd(a,b)\le gcd(b,r)$.

Similarly, we could prove that any common divisor for $b$ and $r$ must
also be a divisor for $a$, and further any common divisor for $b$ and
$r$ must also be a common divisor for $a$ and $b$. So one of the
common divisors for $b$ and $r$, $gcd(b,r)$, is a common divisor for
$a$ and $b$. Since the greatest common divisor for $a$ and $b$ is
$gcd(a,b)$, then we have $gcd(b,r)\le gcd(a,b)$.

Because $gcd(a,b)\le gcd(b,r)$ and
$gcd(b,r)\le gcd(a,b)$, we must have
$gcd(a,b)=gcd(b,r)$.

{\bf QED}

\section{Specification, partial correctness, and completeness}

In Kowalski \cite{Kowa84} we find:

We have shown that the program is partially correct by showing that it
is logically implied by its specification. This may be
counter-intuitive, and therefore requires explanation. Suppose a set
of sentences $S$ defines a relation $P(x y)$. (In a typical
application, $x$ might be input, $y$ output and $P(x y)$ an
input-output relation.) This means that
\begin{verbatim}
   (x y) is a relation in P
   iff
   S |- P(x y)
\end{verbatim}

Where $X \vdash Y$ means that conclusion $Y$ can be proved from
assumptions $X$. Thus not only does $S$ imply $P(x y)$, it also
'computes' it, in the sense that its instances can be derived by means
of a mechanical theorem-proving procedure. Suppose {\bf Spec} and 
{\bf Prog} are a complete specification and a program, respecitvely,
defining a relation $P(x y)$. Then to say that the program is
{\sl partially correct} relative to the specification is to say that
every instance of $P$ that is a consequence of {\bf Prog} is also a
consequence of {\bf Spec}, i.e.
\begin{verbatim}
   if Prog |- P(x y) then Spec |- P(x y)
\end{verbatim}

But this holds if
\begin{verbatim}
   Spec |- Prog
\end{verbatim}
by the transitivity of the proof predicate. If the converse holds,
i.e. 
\begin{verbatim}
   if Spec |- P(x y) then Prog |- P(x y)
\end{verbatim}
then the program is {\sl complete} in the sense that the program
derives every instance of $P$ that is defined by the
specification. This holds if
\begin{verbatim}
   Prog |- Spec
\end{verbatim}

Notice that to prove correctness or completeness we can replace either 
{\bf Spec} or {\bf Prog} by any stronger set of sentences that implies
the same atomic relations. This justifies the use of the iff form of
definitions and induction in such proofs. Thus it is closely related
to Hoare's identification of a program with the {\sl strongest}
predicate that describes its behavior.

Notice also that to prove a specification implies a program, we need
to show that the specification logically implies each clause in the
program. Thus the {\sl complexity} of proving partial correctness is
linear in the number of clauses of the program, and the complexity of
proving completeness is linear in the number of clause in the
specification.

\section{Rewrite loops into recursion}

Assuming loop structure where
\begin{itemize}
\item {\bf header} processing before the loop and newly declared
variables 
\item {\bf condition} when to stop the loop
\item {\bf loopbody} changes variables and pararmeters passed in
\item {\bf tail} what happens after the loop and return result
\end{itemize}

\begin{verbatim}
Iter(params) {
  header
  while (condition) {
    loopbody }
  return tail
}

becomes

Recur(params) {
  header
  return RecurInner(params, header_vars)
}

RecurInner(params, header_vars) {
  if (!condition) { return tail }
  loopbody
  return RecurInner(params, modified_header_vars)
}
\end{verbatim}

\section{Common Lisp Types}

Common lisp type system is a ``complemented lattice''

{\bf Common types} : integer, number, string, keyword, array, cons, list,
vector, macro, function, atom

{\bf Top} t has everything as an element

{\bf Unit} null has one element named nil

{\bf Bottom} nil has no elements at all

{\bf Union} (or $\tau_1\ldots \tau_n$) has elements any element in any
type $\tau$

{\bf Intersection} (and $\tau_1\ldots \tau_n$) has elements that are
in all the types $\tau$

{\bf Complement} (not $\tau$) has elements that are not of type $\tau$ 

{\bf Enumeration} (member $x_1\ldots x_n$) is the type consisting
of only the elements $x$

{\bf Singleton} (eql $x$) is the type with only the element $x$

{\bf Comprehension} (satisfies $p$) is the type of values that satisfy
predicate $p$

The universal type ``t'' has everything as its value
\begin{verbatim}
(typep 'x 't) ;; -> true
(typep 12 't) ;; -> true
\end{verbatim}

The empty type nil
\begin{verbatim}
(typep 'x 'nil) ;; -> false; nil has no values
\end{verbatim}

The type ``null'' contains the one value ``nil''
\begin{verbatim}
(typep nil 'null) ;; -> true
(typep () 'null)  ;; -> true
\end{verbatim}

``(eql x)'' is the singleton type consisting of only x
\begin{verbatim}
(typep 3 '(eql 3)) ;; -> true
(typep 4 '(eql 3)) ;; -> false
\end{verbatim}

``(member $x_0\ldots x_n$)'' denotes the enumerated type consisting of
only the $x_i$
\begin{verbatim}
(typep 3  '(member 3 x "c")) ;; -> true
(typep 'x '(member 3 x "c")) ;; -> true
(typep 'y '(member 3 x "c")) ;; -> false
\end{verbatim}

``(satisfies p)'' is the type of vaues that satisfy predicate p
\begin{verbatim}
(typep 12 '(satisfies (lambda (x) (oddp x)))) ;; -> false
(typep 12 '(satisfies (evenp))                ;; -> true
\end{verbatim}

\begin{verbatim}
(booleanp x) = (typep x '(member t nil))
(booleanp 2)   ;; -> false
(booleanp nil) ;; -> true
\end{verbatim}

The {\tt check-type} will return nil if the type passes, otherwise it
throws an error
\begin{verbatim}
(setq x 12)
(check-type x integer)             ;; -> nil
(check-type x (or symbol integer)) ;; -> nil
(check-type x (or symbol string))  ;; -> error  
\end{verbatim}

Type annotation using ``the''
\begin{verbatim}
(the integer 3) ;; -> 3
(the string 3)  ;; -> error
\end{verbatim}

Type coercion
\begin{verbatim}
(coerce 3 'float)   ;; -> 3.0
(coerce 'x integer) ;; -> error
\end{verbatim}

Using ``deftype''
\begin{verbatim}
(defun small-number-seq-p (thing)
  (and (listp thing)
       (every #'numberp thing)
       (every (lambda (x) (< x 10)) thing)))

(setq yes '(1 2 3))
(setq no  '(1 20 4))

(deftype small-number-seq ()
  `(satisfies small-number-seq-p))

(typep yes 'small-number-seq)
(typep no  'small-number-seq)
\end{verbatim}

also
\begin{verbatim}
(proclaim '(type (simple-array fixnum (4 4))) matrix)
\end{verbatim}

\section{Polymorphism}

\subsection{Polymorphism \cite{Lisk12}}

We don't just want a set, we want polymorphism or
generics, as they are called today. We wanted to
have a generic set which was paramaterized by type
so you could instantiate it as:

Set = [T:type] create, insert,...
  % representation for Set object
  % implementation of Set operations
  Set

Set[int] s := Set[int]$create()
Set[int]$insert(s,3)

We wanted a static solution to this problem. The
problem is, not every type makes sense as a parameter
to Set of T. For sets, per se, you need an equality
relation. If it has been a sorted set we would have
some ordering relation. And a type that didn't have
one of those things would not have been a legitamite
parameter. We needed a way of expressing that in a
compile-time, checkable manner. Otherwise we would
have had to resort to runtime checking.

Our solution was

Set = [T:  ] create, insert,...
  T equal: (T,T) (bool)


Our solution, what we call the ``where clause''. So we
added this to the header. The ``where clause'' tells you
what operations the parameter type has to have. 

If you have the ``where'' clause you can do the static
checking because when you instantiate, when you provide
an actual type, the compiler can check that the type has
the operations that are required. And then, when you write
the implementation of Set the compiler knows it's ok to
call those operations because you can guarantee they are
actually there when you get around to running.

Of course, you notice that there's just syntax here; there's
no semantics.

As I'm sure you all know, compile-time type checking is
basically a proof technique of a very limited sort and
this was about as far as we can push what you could get out of the
static analysis. To go further, where we would say that T,
in addition, has to be an equality relation, that requires
much more sophisticated techniques that, even today, are
beyond the capabilities of the compiler. 

\section{Hardware Proof Checking}

\subsection{Mealy/Moore equivalence \cite{Fade17}}

Prove that if a Mealy machine is strongly connected and completely
specified, the corresponding Moore machine will also be strongly
connected and completely specified.

As the Mealy Machine is completely specified, we have 2 cases for each
state:
\begin{enumerate}
\item All transitions coming into this state have the same output
\item At least 2 transitions coming into this state have different
outputs
\end{enumerate}

For case 1: The equivalent for this state would simply be changing the
notation, i.e. mark all transitions into this state simply by the
input symbols and just mention the output with the state as is.

Now, as the machine is completely specified, each such input
transition and its corresponding output will be defined, and the
states resulting due to such states will also have completely
specified transitions.

For case 2: The equivalent for such a state requires the
splitting/addition of new states such that each split state
corresponds to the different outputs that can be generated. We split a
state into 2 corresponding states.

Now, as the machine is completely specified, each such input
transition and its corresponding output will be defined, and the
states resulting due to such states will also have completely
specified transitions.

{\sl Strongly Connected Machine:} If for any two states $S_i$, $S_j$
of the machine, there exists a finite sequence of input characters
that can make the machine transition from $S_i$ to $S_j$, the machine
is strongly connected.

{\sl Completely Specified Machine:} Consider $M=(I,O,S,F,Z)$
\begin{itemize}
\item {\bf I} : Input Symbols
\item {\bf O} : Output Symbols
\item {\bf S} : Set of States
\item {\bf F} : Transition function $F : S \times I\rightarrow S$
\item {\bf Z} : Output function
\item {\bf Z} : $S\rightarrow O$ (Moore)
\item {\bf Z} : $S\times I\rightarrow O$ (Mealy)
\end{itemize}

Now, if for every $(p,x)$ such that $(p\in S, x\in I)$ there exist
some $q\in S$ and $y\in O$ such that $F(p,x)=q$ and $Z(p,x)=y$
(Mealy), $Z(p)=y$ (Moore).

Let $M=(Q,\Sigma,\Delta,\delta,\lambda,q_0)$ be a Mealy machine where
$\Delta$ is the output alphabet and $\lambda$ is the output function.

Denote states of the corresponding Mealy machine by $q_{ib}$ if there
is input $a$ and output $b$ such that $\delta(q_j,a)=(q_i,b)$. This
means if the Mealy machine enters a state $q$ by emitting more than
two different outputs then the state $q_i$ splits. Also, denote
corresponding Moore machine's transition function by $\delta^\prime$ 

Now consider two states $q_{ib_1}$ and $q_{jb_2}$ (of corresponding
Moore machine). Existence of the state $q_{jb_2}$ implies that there
is a states $q_k$ and input symbols $a$ such that
$\delta(q_k,a)=(q_j,b_2)$. Since we made the assumption that the Mealy
machine is strongly connected, there is a string $w$ such that
$\delta(q_i,w)=(q_k,b_k)$ for some output symbol $b_k$. So, we have
\[\delta^\prime(q_{ib_1},wa)=
\delta^\prime(\delta^\prime(q_{ib_1},w),a)=
\delta^\prime(q_{kb_k},a)=q_{jb_2}\]
This shows that the corresponding Moore machine is strongly connected.

As for the completely specification, let $q_{ib_1}$ be a state of the
Moore machine, and $a$ is an input symbol. Then
$\delta^\prime(q_{ib_1},a)=(q_{jb_2},b_2)$ where
$\delta(q_i,a)=(q_j,b_2)$, which shows it is completely specified.


\section{Specification}

\subsection{Binary Search \cite{Guen19}}

A Binary Search in OCaml
\begin{chunk}{BS}
(* Requires a to be a sorted array of integers.
   Returns k such that i <= k < j and a.(k) = v
   or -1 if there is no such k *)

let rec bsearch a v i j =
  if j <= i then -1
  else
    let k = i + (j - i) / 2 in
    if v = a.(k) then k
    else if v < a.(k) then bsearch a v i k
    else bsearch a v (k+1) j

\end{chunk}

There is an informal specification in the comments. The {\tt bsearch}
program takes as input an array of integers $a$ (which is assumed to be
sorted), a value $v$ which is the target of the search, and lower and
upper bounds $i$ and $j$. If $v$ can be found between indices $i$
(included) and $j$ (excluded), the {\tt bsearch} returns its index in
the array; otherwise it returns $-1$.

The Separation Logic specification for {\tt bsearch} is 

$\forall a~xs~v~i~j$\\
$0\le i\le |xs| \land 0 \le j \le |xs| \land {\tt sorted\ }xs\Rightarrow\\
\{a \leadsto {\tt Array\ } xs\} {\tt\ bsearch\ } a~v~i~j~
\{\lambda k.~a\leadsto {\tt Array\ }xs *
[{\tt bsearch\_correct\ }xs~v~i~j~k]\}$

This statement consists of a Hoare triple $(\{H\}~t~\{Q\})$, after
quantification (in the logic) over suitable arguments (the array
location $a$ and integers $v$, $i$, and $j$) as well as the logical
model of the array $xs$ (list of integers). Notice that we associate
Coq integers (with $v$, $i$, $j$) with OCaml integers. This is not an
abuse of notation but a feature of CFML, which reflects pure OCaml
values directly as corresponding values in Coq. We require the indices
$i$ and $j$ to be in bounds, and the contents of the array $xs$ to be
sorted. The Hoare triple which forms the conclusion of the statement
relates an OCaml expression (here, a call to {\tt bsearch},
"{\tt bsearch\ }$a~v~i~j$") with a pre-condition and post-condition
describing the state of the heap before and after the execution,
respectively. Both pre- and post-conditions are expressed using
Separation Logic assertions; the post-condition is additionally
parameterized by the value returned by the function (here, named $k$).

Generally speaking, Separation Logic assertions can be read in terms
of ownership. For instance, the Separation Logic formula
"$a\leadsto {\tt Array\ }xs$" asserts the unique ownership of an
heap-allocated array, starting at local $a$, whose contents are
described by the list $xs$. The operator $*$ should be read as a
conjunction; and $[\cdot]$ lifts an ordinary Coq proposition as a
Separation Logic assertion. To express the fact that the value
returned by {\tt bsearch} is indeed correct, we rely on an auxiliary
definition {\tt bsearch\_correct}, which expresses the functional
correctness property of {\tt bsearch}. Thereafter, we write "$xs[i]$",
where $xs$ is a Coq list and $i$ an integer, to denote the $i$-th
element of the list $xs$ (or a dummy value if $i$ is not a valid index).

{\bf Functional Correctness of {\tt bsearch}}

${\tt bsearch\_correct\ }xs~v~i~j~k \overset{\Delta}{=}\\
(k=-1 \land \forall~p.~i\le p < j \Rightarrow xs[p]\ne v)\\
\land (i\le k< j \land xs[k]=v)$

Assuming the preconditions, we have the following facts.
\begin{itemize}
\item {\tt bsearch} will run and terminate without crashing (a
consequence of the definition of Hoare triples)
\item {\tt bsearch} will not modify the contents of the input array 
("$a\leadsto {\tt Array\ }xs$" appears in both the pre- and
post-conditions, with the same $xs$)
\item {\tt bsearch} will return a correct result, according to the 
{\tt bsearch\_correct} predicate
\end{itemize}

A technical remark: one might wonder why the ``pure'' assumptions on
$i$, $j$ and $xs$ are not part of the triple precondition, and instead
are lifted as an implication at the meta-level (in the logic of
Coq). Formally speaking, these two options are equivalent. That is,
one could equivalently prove the following specification for
{\tt bsearch}

$\forall a~xs~v~i~j\\
\{a\leadsto {\tt Array\ }xs * [0\le i\le |xs| \land 
0\le j\le |xs| \land {\tt sorted\ }xs]\}\\
{\tt bsearch\ }a~v~i~j\\
\{\lambda k.~a\leadsto {\tt Array\ }xs * 
[{\tt bsearch\_correct\ }xs~v~i~j~k]\}$


\section{Parsing}

\subsection{Top Down Operator Precedence \cite{Prat73}\cite{Bend20}}

\begin{chunk}{TDOP}

def expression(rbp=0):
  global token
  t = token
  token = next()
  left = t.nud()
  while rbp < token.lbp:
    t = token
    token = next()
    left = t.led(left)
  return left

class literal_token(object):
  def __init__(self, value):
    self.value = int(value)
  def nud(self):
    return self.value

class operator_add_token(object):
  lbp = 10
   def led(self,left):
    right = expression(10)
    return left+right

class operator_mul_token(object):
  lbp = 20
  def led(self,left):
    return left * expression(20)

class end_token(object):
  lbp = 0

\end{chunk}

The tokenizer and parser

\begin{chunk}{TDOP}
import re
token_pat = re.compile("\s*(?:(\d+)|(.))")

def tokenize(program):
  for number, operator in token_pat.findall(program):
    if number:
      yield literal_token(number)
    elif
      yield operator_add_token()
    elif
      yield operator_mul_token()
    else:
      raise SyntaxError('unknown operator: %s', operator)
  yield end_token()

def parse(program):
  global token, next
  next = tokenize(program).next
  token = next()
  return expression()

\end{chunk}

The {\bf lbp} is the left binding power. For an infix operator, it
tells us how strongly the operator binds to the argument on its left.

The {\bf rbp} is the right binding power. 

The {\bf nud} (null denotation) is the prefix handler.

The {\bf led} (left denotation) is the left handler, used to handle
infix operators.

The {\bf expression} handler function does the work. Operator handlers
call it and pass in an {\bf rbp}. It consumes tokens until it meets a
token whose left binding power is equal or lower than the right
binding power, that is until {\bf lbp <= rbp}.

Handlers of operators call {\bf expression} to process their
arguments, providing it with their binding power to make user it gets
just the right tokens from the input. 

For example:
\begin{verbatim}
   3 + 1 * 2 * 4 + 5
\end{verbatim}
has the call trace
\begin{verbatim}
  expression with rbp 0
    literal nud = 3
    led of +
    expression with rbp 10
      literal nud = 1
      led of *
      expression with rbp 20
        literal nud = 2
      led of *
      expression with rbp 20
        literal nud = 4
    led of +
    expression with rbp 10
      literal nud = 5
\end{verbatim}

\[\begin{array}{|c|c|c|c|c|c|c|c|c|}
\hline
3 & + & 1 & * & 2  & * & 4   & + &  5\\
\hline
- & - & - & - &  0 & - & -   & - & - \\
  &   & - & - & 10 & - & -   &   & 10\\
  &   &   &   & 20 &   & 20  &   & \\
\hline
\end{array}\]

At each stage of the parser, there is an expression at each precedence
level that is active at the moment. This instance awaits the results
of the higher precedence instance and keeps going, until it has to
stop itself and return to its caller.

{\bf Handling Unary Operators}

TDOP makes an explicit distinction between unary and binary operators,
encoding the difference between the {\bf nud} and {\bf let} methods.
For example, the subtraction operator becomes
\begin{chunk}{TDOP}
class operator_sub_token(object):
  lbp = 10
  def nud(self):
    return -expression(100)
  def led(self, left):
    return left - expression(10)

\end{chunk}

The {\bf nud} handles the unary (prefix) form of minus. It has no left
argument (since it is a prefix), and it negates its right argument,
The binding power passed into {\bf expression} is high since infix
minus has a high precedence, higher than multiplication. The {\bf led}
handles the infix case similarly to the handlers of $+$ and $*$.

{\bf Right Associative Operators}



\section{Program proof}

See Altenkirch et al. ``Why Dependent Types Matter'' \cite{Alte05}

\section{Notation}

From Altenkirch \cite{Alte18}

\[A\rightarrow B \equiv \Pi n:N.A^n \equiv \forall(x:A),B\]
\[A\rightarrow B \equiv \Pi~-~:~A.B\]

\[List A \equiv \Sigma_n:N.A^n\]
\[A\times B \equiv \Sigma~-~:~A.B\]

\section{Data Description Language}

Jenkins \cite{Jenk18} proposes  combination of sum and product 
types, e.g.
\begin{verbatim}
data OrderResponse
  = PurchaseSuccessful
      { newOrder :: Order }
  | PaymentFailed
      { paymentProvider :: ProviderId,
        failureMessage  :: String }
  | NetworkError
      { statusCode :: Int,
        message    :: String
      }
\end{verbatim}

\section{Interactive Proof Semantics}

\subsection{Lean Semantics \cite{Carn19b}}

{\bf The Untyped Lambda Calculus}

\[e:=x~|~ e~e~|~\lambda~x.~e\]

\begin{prooftree}
\AxiomC{$e_1 \leadsto e_1^\prime$}
\UnaryInfC{$e_1~e_2 \leadsto e_1^\prime~e_2$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$e_2 \leadsto e_2^\prime$}
\UnaryInfC{$e_1~e_2 \leadsto e_1~e_2^\prime$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$(\lambda x.~e^\prime)~e \leadsto e^\prime[e/x]$}
\end{prooftree}

{\bf Simple Type Theory}

\[\tau ::= \iota~|~\tau \rightarrow \tau\]

\begin{prooftree}
\AxiomC{$(x:\tau)\in\Gamma$}
\UnaryInfC{$\Gamma \vdash x:\tau$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\vdash e_1 : \alpha\rightarrow\beta$}
\AxiomC{$\Gamma\vdash e_2 : \alpha$}
\BinaryInfC{$\Gamma\vdash e_1~e_2 : \beta$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma,x : \alpha\vdash e:\beta$}
\UnaryInfC{$\Gamma\vdash(\lambda x : \alpha.e) :
\alpha\rightarrow\beta$} 
\end{prooftree}

{\bf Dependent Type Theory}

\[\tau ::= \iota~|~\tau \rightarrow \tau\]

\[e ::= x~|~e~e~|~\lambda x : \tau.e\]

\begin{prooftree}
\AxiomC{$(x:\tau)\in \Gamma$}
\UnaryInfC{$\Gamma\vdash x:\tau$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\vdash e_1:\alpha\rightarrow\beta$}
\AxiomC{$\Gamma\vdash e_2:\alpha$}
\BinaryInfC{$\Gamma\vdash e_1~e_2:\beta$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma,x:\alpha\vdash e:\beta$}
\UnaryInfC{$\Gamma\vdash(\lambda x:\alpha.e):\alpha\rightarrow\beta$} 
\end{prooftree}

introducing $\forall x$:

\[\tau ::= \iota~|~\forall x : \tau.~\tau\]

\[e ::= x~|~e~e~|~\lambda x : \tau.e\]

\begin{prooftree}
\AxiomC{$(x:\tau)\in \Gamma$}
\UnaryInfC{$\Gamma\vdash x:\tau$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\vdash e_1:\forall x: \alpha.\beta$}
\AxiomC{$\Gamma\vdash e_2:\alpha$}
\BinaryInfC{$\Gamma\vdash e_1~e_2:\beta[e_2/x]$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma,x:\alpha\vdash e:\beta$}
\UnaryInfC{$\Gamma\vdash(\lambda x:\alpha.e):\forall x : \alpha.\beta$} 
\end{prooftree}

introducing universes:

\[\tau ::= \iota~|~\forall x : \tau.~\tau~|~U\]

\[e ::= x~|~e~e~|~\lambda x : \tau.e\]

\begin{prooftree}
\AxiomC{$(x:\tau)\in \Gamma$}
\UnaryInfC{$\Gamma\vdash x:\tau$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\vdash e_1:\forall x: \alpha.\beta$}
\AxiomC{$\Gamma\vdash e_2:\alpha$}
\BinaryInfC{$\Gamma\vdash e_1~e_2:\beta[e_2/x]$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma,x:\alpha\vdash e:\beta$}
\UnaryInfC{$\Gamma\vdash(\lambda x:\alpha.e):\forall x : \alpha.\beta$} 
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma\vdash \iota:U$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\vdash\alpha:U$}
\AxiomC{$\Gamma,x:\alpha\vdash\beta:U$}
\BinaryInfC{$\Gamma\vdash\forall x:\alpha.\beta:U$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma\vdash U:U$}
\end{prooftree}

\section{Small Step Operational Semantics}

\subsection{Sylvan Clebsch \cite{Cleb19}}

\[\begin{array}{lclcl}
x,y,z & \in & LocalID & &\\
\rho  & \in & Frame & = & LocalID \rightarrow Value\\
v     & \in & Value & = & Integer
\end{array}\]

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\rho,e \leadsto \rho^\prime,e^\prime \vert v$}
\end{prooftree}

To read a local variable:
\begin{prooftree}
\AxiomC{$x\in dom(\rho)$}
\UnaryInfC{$\rho,x \leadsto \rho,\rho(x)$}
\end{prooftree}

To assign $x$ a new value:
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\rho,x=v \leadsto \rho[x \mapsto v],v$}
\end{prooftree}

To copy a value of $y$ into $x$:
\begin{prooftree}
\AxiomC{$y\in dom(\rho)$}
\AxiomC{$v=\rho(y)$}
\BinaryInfC{$\rho,x=y \leadsto \rho[x\mapsto v],v$}
\end{prooftree}

Handling operators (e.g. $+$) (assuming integer $+$):
\begin{prooftree}
\AxiomC{$x\in dom(\rho)$}
\AxiomC{$y\in dom(\rho)$}
\AxiomC{$v=\rho(x)+\rho(y)$}
\TrinaryInfC{$\rho,z=x+y \leadsto \rho[z\mapsto v],v$}
\end{prooftree}

Small step semnatics allows us to take a single step and
then decide what to do next. These two rules allow that.

Given a sequence of expressions $e_1$ and $e_2$, if $e_1$ were to
evaluate to a new frame and an additional expression $e_3$ then the
next step in the operation is to operate over that modified frame with
$e_3$ followed by $e_2$:
\begin{prooftree}
\AxiomC{$\rho,e_1 \leadsto \rho^\prime,e_3$}
\UnaryInfC{$\rho,e_1;e_2 \leadsto \rho^\prime,e_3,e_2$}
\end{prooftree}

If $e_1$ evaluates all the way to a value $v$ then we are
done and can evaluate $e_2$:
\begin{prooftree}
\AxiomC{$\rho,e_1 \leadsto \rho^\prime,v$}
\UnaryInfC{$\rho,e_1;e_2 \leadsto \rho^\prime,e_2$}
\end{prooftree}

Assuming integer values only, if $x$ is not zero
then we evaluate to $e_1$ and drop $e_2$:
\begin{prooftree}
\AxiomC{$x\in dom(\rho)$}
\AxiomC{$\rho(x)\ne 0$}
\BinaryInfC{$\rho,{\tt if\ }(x)\ \{e_1\}{\tt\ else\ }\{e_2\}
\leadsto \rho,e_1$}
\end{prooftree}

The symmetric case, 
assuming integer values only, if $x$ is zero
then we evaluate to $e_1$ and drop $e_2$:
\begin{prooftree}
\AxiomC{$x\in dom(\rho)$}
\AxiomC{$\rho(x) = 0$}
\BinaryInfC{$\rho,{\tt if\ }(x)\ \{e_1\}{\tt\ else\ }\{e_2\}
\leadsto \rho,e_2$}
\end{prooftree}

These rules account for speculative execution.
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\rho,{\tt if\ }(*)\ \{e_1\}{\tt\ else\ }\{e_2\}
\leadsto \rho,e_1$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\rho,{\tt if\ }(*)\ \{e_1\}{\tt\ else\ }\{e_2\}
\leadsto \rho,e_2$}
\end{prooftree}

Loops
\begin{prooftree}
\AxiomC{$x\in dom(\rho)$}
\AxiomC{$\rho(x)\ne 0$}
\BinaryInfC{$\rho,{\tt while}(x)\{e\} \leadsto
\rho,e;{\tt\ while}(x)\{e\}$}
\end{prooftree}

Loop termination
\begin{prooftree}
\AxiomC{$x\in dom(\rho)$}
\AxiomC{$\rho(x)= 0$}
\BinaryInfC{$\rho,{\tt while}(x)\{e\} \leadsto \rho,0$}
\end{prooftree}

Heaps and Threads
\[\begin{array}{lclcl}
v      & \in & Value  & = & Integer\ \vert\ Address\\
\chi   & \in & Heap   & = & Address\ \vert\ Object\\
\sigma & \in & Stack  & = & \overline{Frame}\\
\theta & \in & Thread & = & Stack\times Expression\\
\end{array}\]

The expression gives us a new heap, stack, and frame.
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\chi,\sigma\cdot\rho,e\leadsto
\chi^\prime,\sigma^\prime\cdot\rho^\prime,e\vert v$}
\end{prooftree}
where $\cdot$ is sequencing. The $\cdot$ is there so
when we write preconditions we can talk about the Frame
we are in.

Parallel Execution. 

$\theta$ is a thread with a pair that is a stack
and an expression. The overbar annotation means a sequence.

We non-deterministically select the thread to execute. The first rule
is threads that are not done. The second rule is threads that are
done. We have a (possible empty) sequence of threads $\overline{\theta}$, 
a particular thread, and another (possibly empty) sequence of threads.
We select a thread to execute, which may terminate.

\begin{prooftree}
\AxiomC{$\chi,\sigma,e\leadsto\chi^\prime,\sigma^\prime,e^\prime$}
\UnaryInfC{$\chi,\overline{\theta},(\sigma,e)\cdot\overline{\theta^\prime}
\leadsto\chi^\prime,\overline{\theta}\cdot(\sigma^\prime,e^\prime)\cdot
\overline{\theta^\prime}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\chi,\sigma,e\leadsto\chi^\prime,\sigma^\prime,v$}
\UnaryInfC{$\chi,\overline{\theta},(\sigma,e)\cdot\overline{\theta^\prime}
\leadsto\chi^\prime,\overline{\theta}\cdot\overline{\theta^\prime}$}
\end{prooftree}

\section{Univalence and Homotopy Type Theory}

\subsection{Vladimir Voevodsky \cite{Gray18}}

The Univalence Axiom
\[(X = Y) \overset{\cong}{=} (X \cong Y)\]

``Equality is equivalent to equivalence''. In other words, if you have
an equivalence between X and Y then you can promote that to an
equality.

A function $f:X\rightarrow Y$ is an {\sl equivalence} if, for each $y$
in $Y$, there is just one $x$ in $X$ with $f(x) = y$.

The notation for a function being an equivalence is 
$f : X \overset{\overset{\cong}{=}}{\longrightarrow} Y$

The notation for the type of all equivalences between $X$ and $Y$ is
$X \overset{\cong}{=} Y$

In Coq (by Voevodsky \cite{Gray18a})

\begin{verbatim}
Definition eqweqmap {T1 T2 : UU} (e: paths T1 T2) : weq T1 T2.
Proof. intros, destruct e, apply idweq, Defined.

Axiom univalenceaxiom : forall T1 T2 : UU, isweq (@eqweqmap T1 T2).
\end{verbatim}
where {\tt isweq} is the $\overset{\cong}{=}$ relation

Voevodsky's definition of a group:

Let $U$ be a {\sl universe}

A {\sl group} in $U$ is a sequence
${(G,e,i,m,\lambda,\rho,\lambda^\prime,\rho^\prime,\alpha,\iota)}$,
where
\begin{itemize}
\item $G$ is a type of $U$
\item $e:G$
\item $i:G\rightarrow G$
\item $m:G\times G\rightarrow G$
\item $\lambda$ is a proof that for every $a:G, m(e,a)=a$
\item $\rho$ is a proof that for every $a:G, m(a,e)=a$
\item $\lambda^\prime$ is a proof that for every $a:G, m(i(a),a)=e$
\item $\rho^\prime$ is a proof that for every $a:G, m(a,i(a))=e$
\item $\alpha$ is a proof that for every 
$a,b,c:G:m(m(a,b),c)=m(a,m(b,c))$
\item $\iota$ is a proof that $G$ is a set
\end{itemize}

\begin{quote}
Why did he want Univalence? He knew from the beginning that it would
be very important to correlate the results of different authors who
were formalizing things in different ways. If you have one author
giving one definition of triangle and another author giving another
definition of triangle but they turn out to be equivalent then you
would want the theorems of the second author to be useable by the first
author and conversely. So you want some sort of mechanical way of
transporting theorems between equivalent situations for maximum
versatility. So what we have in mind here, from the start, is building
a huge repository of mathematical theorems and their proofs and using
that to build on forever. Using that as a daily aid to mathematicians
in their research so that today they are not nervous about what they
proved yesterday because they also formalized it in the computer.

What is needed is some sort of way to promote equivalences to
something that can be used in the logic of the language to transport
theorems between equivalent situations.
-- Dan Grayon \cite{Gray18}
\end{quote}

\section{Various Logics}

\subsection{Barendregt's Lambda cube \cite[p78]{Bare92}}

\begin{tikzpicture}
\matrix (m) [matrix of math nodes, row sep=3em, column sep=3em,
             text height=1.5ex, text depth=0.25ex]
  { & \lambda\omega & & \lambda P\omega \\
    \lambda 2 & & \lambda P 2 \\
    & \lambda\underline{\omega} & & \lambda P\underline{\omega} \\
    \lambda{\to} & & \lambda P\\
  };
\path[]
 (m-1-2) edge (m-1-4)
 (m-2-1) edge (m-2-3)
         edge (m-1-2)
 (m-3-2) edge (m-1-2)
         edge (m-3-4)
 (m-4-1) edge (m-2-1)
         edge (m-3-2)
         edge (m-4-3)
 (m-3-4) edge (m-1-4)
 (m-2-3) edge (m-1-4)
 (m-4-3) edge (m-3-4)
         edge (m-2-3);
\end{tikzpicture}

where
\[\begin{array}{|l|l|} 
\hline
{\tt System} & {\tt Logic} \\
\hline
\lambda{\to} & {\tt (First\ Order)\ Propositional\ Calculus}\\
\lambda 2    & {\tt Second\ Order\ Propositional\ Calculus}\\
\lambda\underline{\omega} & {\tt Weakly\ Higher\ Order\ Propositional\ Calculus}\\
\lambda\omega & {\tt Higher\ Order\ Predicate\ Calculus}\\
\lambda P & {\tt (First\ Order)\ Predicate\ Logic}\\
\lambda P2 & {\tt Second\ Order\ Predicate\ Calculus}\\
\lambda P\underline{\omega} & {\tt Weak\ Higher\ Order\ Predicate\ Calculus}\\
\lambda P\omega & {\tt Calculus\ of\ Constructions}\\
\hline
\end{array}\]

Moving along the X axis (left) $\rightarrow$ types depend on terms\\
Moving along the Y axis (up) $\rightarrow$ terms depend on types\\
Moving along the Z axis (back) $\rightarrow$ types depend on types

\section{Lean and Theorem Proving}

\subsection{Jason Rute \cite{Rute20}}

A trivial program to add a goal to the list of goals
from a command line input.
\begin{verbatim}
def experiment (s : string ) : lean.parser unit :=
do
  pe <- lean.parser.with_input interactive.types.texpr s, --parser monad
  e <- to_expr pe.1, -- tactic monad
  v <- mk_meta_var e,
  gs <- get_goals,
  set_goals $ v :: gs,
  t <- target
  trace t, -- should output the goal given by the string s
  return()

run_cmd experiment "true"
\end{verbatim}
  
\begin{verbatim}
def experiment (s : string ) : lean.parser unit :=
do
  pe <- lean.parser.with_input interactive.types.texpr s, --parser monad
  e <-  lean.parser.of_tactic (tactic.to_expr pe.1),
  v <-  lean.parser.of_tactic (tactic.mk_meta_var e),
  gs <- lean.parser.of_tactic (tactic.get_goals),
  lean.parser.of_tactic (tactic.set_goals $ v :: gs),
  t <- lean.parser.of_tactic tactic.target,
  lean.parser.of_tactic (tactic.trace t),
  return ()

run_cmd experiment "true"
\end{verbatim}

\begin{verbatim}
import system.io
open io

meta def serialize_expr (e : expr) : string := sorry
meta def deserialize_expr (s : string) : expr := sorry

meta def apply_tactic_to_goal (t : tactic unit) (goal : expr) : tactic (list expr) :=
do
  -- set expression as goal
  v <- tactic.mk_meta_var goal,
  tactic.set_goals $ [v],
  -- run tactic on goal
  t,
  -- return results
  gs <- tactic.get_goals,
  return gs

meta def read_eval_print (_ : unit) : io_core error (option unit) :=
do
  do
    --get serialized expression from stdin
    expr_str <- get_line,
    let e := deserialize_expr expr_str,
    -- run tactic (skep tactic in this case) on goal
    gs <- io.run_tactic (apply_tactic_to_goal tactic.skip e),
    -- print serialized goals to stdout
    let goal_strs := gs.map seriealize_expr,
    put_str (to_string goal_strs),
    return ()

meta def main : io unit :=
  -- loop forever
  do iterate () read_eval_print,
  return ()

\end{verbatim}
  
\subsection{Robert Y. Lewis \cite{Lewi20}}

This is an example from Lean 3. Note the use of the {\tt carrier}
which mirrors the Axiom Rep.

\noindent
structure submodule (R : Type u) (M : Type v) [semiring R]\\
\hspace*{0.2cm}\verb|[add_comm_monoid M] [module R M]| :=\\
(carrier : set M)\\
(zero : (0:M) $\in$ carrier)\\
(add : $\forall$ \{x,y\}, x $\in$ carrier $\rightarrow$
y $\in$ carrier $\rightarrow$ x + y $\in$ carrier)\\
(smul : $\forall$ (c:R) \{x\}, x $\in$ carrier $\rightarrow$
c : x $\in$ carrier)

Axiom NNI is
\begin{verbatim}
NonNegativeInteger() : SIG == CODE where

  SIG ==> Join(OrderedAbelianMonoidSup, Monoid) with

    _quo : (%, %) -> %
      ++ a quo b returns the quotient of \spad{a} and b, forgetting
      ++ the remainder.
  
    _rem : (%, %) -> %
      ++ a rem b returns the remainder of \spad{a} and b.
  
    gcd : (%, %) -> %
      ++ gcd(a, b) computes the greatest common divisor of two
      ++ non negative integers \spad{a} and b.
      ++
      ++X gcd(2415,945)
      ++X gcd(945,2415)
      ++X gcd(2415,0)
      ++X gcd(0,945)
      ++X gcd(15,15)
      ++X gcd(0,0)
  
    divide : (%, %) -> Record(quotient : %, remainder : %)
      ++ divide(a, b) returns a record containing both remainder and quotient.
  
    _exquo : (%,%) -> Union(%,"failed")
      ++ exquo(a,b) returns the quotient of \spad{a} and b, or "failed"
      ++ if b is zero or \spad{a} rem b is zero.
  
    shift : (%, Integer) -> %
      ++ shift(a, i) shift \spad{a} by i bits.
  
    random : % -> %
      ++ random(n) returns a random integer from 0 to \spad{n-1}.
  
    qcoerce : Integer -> %
      ++ qcoerce(n) coerces \spad{n} to \spad{%} trusting that
      ++ \spad{n} is nonnegative

  CODE ==> SubDomain(Integer, #1 >= 0) add

    x, y : %

    sup(x, y) == MAX(x, y)$Lisp

    shift(x : %, n : Integer) : % == ASH(x, n)$Lisp

    qcoerce(n) == n pretend %

    subtractIfCan(x, y) ==
      c : Integer := (x pretend Integer) - (y pretend Integer)
      c < 0 => "failed"
      c pretend %

    gcd(x,y) ==
      zero? x => y
      gcd(y rem x,x)
\end{verbatim}

The Axiom NNI operations are:
\begin{verbatim}
 ?*? : (%,%) -> %                     
 ?*? : (NonNegativeInteger,%) -> %
 ?*? : (PositiveInteger,%) -> %       
 ?**? : (%,PositiveInteger) -> %
 ?**? : (%,NonNegativeInteger) -> %   
 ?+? : (%,%) -> %
 ?<? : (%,%) -> Boolean               
 ?<=? : (%,%) -> Boolean
 ?=? : (%,%) -> Boolean               
 ?>? : (%,%) -> Boolean
 ?>=? : (%,%) -> Boolean              
 1 : () -> %
 0 : () -> %                          
 ?^? : (%,PositiveInteger) -> %
 ?^? : (%,NonNegativeInteger) -> %    
 coerce : % -> OutputForm
 gcd : (%,%) -> %                     
 hash : % -> SingleInteger
 latex : % -> String                  
 max : (%,%) -> %
 min : (%,%) -> %                     
 one? : % -> Boolean
 qcoerce : Integer -> %               
 ?quo? : (%,%) -> %
 random : % -> %                      
 recip : % -> Union(%,"failed")
 ?rem? : (%,%) -> %                   
 sample : () -> %
 shift : (%,Integer) -> %             
 sup : (%,%) -> %
 zero? : % -> Boolean                 
 ?~=? : (%,%) -> Boolean
 divide : (%,%) -> Record(quotient: %,remainder: %)
 exquo : (%,%) -> Union(%,"failed")
 subtractIfCan : (%,%) -> Union(%,"failed")
\end{verbatim}

So casting this in Lean might look like:\\
\noindent
structure NonNegativeInteger (R : Type u) (M : Type v) [semiring R]\\
\hspace*{0.2cm}\verb|[add_comm_monoid M] [module R M]| :=\\
(carrier : set M)\\
(zero : (0:M) $\in$ carrier)\\
(add : $\forall$ \{x,y\}, x $\in$ carrier $\rightarrow$
y $\in$ carrier $\rightarrow$ x + y $\in$ carrier)\\
(smul : $\forall$ (c:R) \{x\}, x $\in$ carrier $\rightarrow$
c : x $\in$ carrier)


\subsection{Andrej Bauer \cite{Baue07}}

Given General Indeuctive Types, the theory {\tt Branching}
describes that a branching type consists of a set $s$ and a set $t$
depending on $s$. The theory $W$ is parameterized by a branching type
$B$. It specifies a set $w$ of well-founded trees and a tree-forming
operation $tree$ with a dependent type\\
$\Pi_{s\in B.s}(B.t(x) \rightarrow w) \rightarrow w.$
Given a branching type $x$ and a map
$f~:~B.t(x) \rightarrow w$, $tree~x~f$ is the tree whose root has
branching type $x$ and whose successor labeled by $l\in~B.t(x)$ is the
tree $f(l)$. The inductive nature of $w$ is expressed with the axiom 
{\tt induction}, which states that for every property $M.p$, if $M.p$
is an inductive property then every tree satisfies it. A property is
said to be {\sl inductive} if a tree $tree~x~f$ satisfies it whenever
all its successors satisfy it.

Parameter W : [B : Branching] $\rightarrow$\\
thy\\
\hspace*{0.2cm}Parameter w : Set.\\
\hspace*{0.2cm}Parameter tree : [x : B.x] $\rightarrow$ 
(B.t x $\rightarrow$ w) $\rightarrow$ w.\\
\hspace*{0.2cm}Axiom induction:\\
\hspace*{0.4cm}$\forall$ M : thy Parameter p : w 
$\rightarrow$ Prop. end,\\
\hspace*{0.4cm}($\forall$ x : B.x, 
$\forall$ f : B.t x $\rightarrow$ w,\\
\hspace*{0.6cm}(($\forall$ y : B.t x, M.p (f y))
$\rightarrow$ M.p (tree x f))) $\rightarrow$\\
\hspace*{0.4cm}$\forall$ t : w, M.p t.\\
end.

A hand-written OCAML program is
\begin{verbatim}
module W (B : Branching) = struct
  type w = Tree of B.s * (B.t -> w)
  let tree x y = Tree (x, y)
  let rec induction f (Tree (x, g)) =
    f x g (fun y - induction f (g y))
end
\end{verbatim}


The RZ program generates:
\begin{verbatim}
module type Branching =
  sig
    type s
    (** predicate (=s=) : s -> s -> bool *)
    (** assertion symmetric_s : forall x:s, y:s, x =s= y -> y =s= x 
        assertion transitive_s :
          forall x:s, y:s, z:s, x =s= y /\ y =s= z -> x =s= z
    *)
    (** predicate ||s|| : s -> bool *)
    (** assertion total_def_s : forall x:s, x : ||s|| <-> x =s= x
    *)
    (** branching types *)
    type t
    (** predicate (=t=) : s -> t -> t -> bool *)
    (** assertion strict_t : forall x:s, y:t, z:t, y =(t x)= z -> x : ||s||
        assertion extensional_t :
          forall x:x, y:s, z:t, w:t, s =s= y -> z =(t x)= w -> z =(t y)= w
        assertion symetric_t :
          forall x:s, y:t z:t, y =(t x)= z -> z =(t x)= y
        assertion transitive_t :
          forall x:s, y:t, z:t, w:t, y =(t x)= z /\ z =(t x)= w ->
            y =(t x)= w
    *)
    (** predicate ||t|| : s -> t -> bool *)
    (** assertion total_def_t :
       forall x:s, y:t, y : ||t x|| <-> y =(t x)= y
    *)
    (** branch labels *)
  end

module W : functor (B : Branching) ->
sig
  type w
  (** prediate (=w=) : w -> w -> bool *)
  (** assertion symmetric_w :
       forall x:w, y:w, x =w= y -> y =w= x
      assertion transitive_w :
        forall x:w, y:w, z:w, x =w= y /\ y =w= z -> x =w= z
  *)
  (** predicate ||w|| : w -> bool *)
  (** assertion total_def_w : forall x:w, x : ||w|| <-> x =w= x
  *)
  val tree : B.s -> (B.t -> w) -> w
  (** assertion tree_support :
        forall x:B.s, y:B.s, x =B.s= y ->
          forall f:B.t -> w, g:B.t -> w,
            (forall z:B.t, t:B.t, z =(B.t x)= t -> f z =w= g t) ->
            tree x f =w= tree y g
  *)
  val induction : (B.s -> (B.t -> w) -> (B.t -> 'ty_p) -> 'ty_p) -> w -> 'ty_p
  (** assertion 'ty_p [p:w -> 'ty_p -> bool] induction :
        (forall x:w, a:'ty_p, p x a -> x : ||w||) ->
        (forall x:w, y:w, a:'ty_p, x =w= y -> p x a -> p y a) ->
        forall f:B.s -> (B.t -> w) -> (B.t -> 'ty_p) -> 'ty_p,
          (forall (x:||B.s||),
            forall f':B.t -> w,
              (forall y:B.t, z:B.t, y =(B.t x)= z ->
                f' y =w= f' z) ->
              forall g:B.t -> 'ty_p,
                (forall y:B.t, y : ||B.t x|| -> p (f' y) (g y)) ->
                p (tree x f') f x f' g)) ->
          forall (t:||w||), p t (induction f t)
  *)
end
\end{verbatim}

From Bauer \cite{Baue19}

\begin{itemize}
\item Type : Type ... a paradoxical universe of types
\item $\Pi (x : T_1), T_2$ ... dependent products
\item $\lambda (x : T) \rightarrow e$ ... functions
\item $e_1 e_2$ ... application
\item $e : T$ ... type ascriptions
\end{itemize}

\begin{itemize}
\item Definition x := e. ... define a value
\item Axiom x : T. ... assume a constant
\item Check e. ... check the type of an expression
\item Eval e. ... evaluate an expression
\item Load "{\tt <file>}". ... load a file
\end{itemize}

From Bauer \cite{Baue19a}

\begin{itemize}
\item $\Gamma \vdash A {\tt type}$ is a type
\item $\Gamma \vdash t : A$ is a term of type $A$
\item $\Gamma \vdash A \equiv B$ types $A$ and $B$ are equal
\item $\Gamma \vdash t \equiv u : A$ terms $t$ and $u$ of type $A$ are
equal 
\end{itemize}

From Bauer \cite{Baue19a}, Rules for dependent products
\begin{itemize}
\item rule $\Pi$ (A type) (\{x:A\} B type) type
\item rule $\lambda$ (A type) (\{x:A\} B type) 
 (\{x:A\} e : \{B\}) : $\Pi$ A B
\item app (A type) (\{x:A\} B type)
(S : $\Pi$ A B) (a : A) : B\{a\}
\item rule $\Pi\_\beta$ (A type) (\{x:A\} B type)
(\{x:A\} S : B\{x\}) (a : A)\\
: app A B ($\lambda$ A B S) a $\equiv$ S\{a\} : B\{a\}
\item rule Id (A type (a : A) (b : A) type
\item rule equality\_reflection\\
(A type (a:A0 (b:A) (p:Id A a b) : a $\equiv$ b : A
\end{itemize}

\section{Verbx Regular Expressions}

\begin{itemize}
\item \verb,.,    \verb,.  A.C,   match any character
\item \verb,[],   \verb,[ABab][A-Ca-c], match any character in list
\item \verb,[^],  \verb,[^Z][^a], match all except characters in list
\item \verb,^,    \verb,^C,       next token must be the first part of string
\item \verb,$,    \verb,[Ca]t$,   prev token must be the last part of string
\item \verb,*,    \verb,[ab]*,    match 0 or more copies
\item \verb,+,    \verb,[ab]+,    match 1 or more copies
\item \verb,\|,   \verb,c\|a,     match either the 1st token or the second
\item \verb,\(\), \verb,\(CA\)+,  combine multiple tokens into one
\end{itemize}

\subsection{methods \cite{verb20}}

\begin{chunk}{verbx}
(defun sanitize (str)
  (replace str "([.$*+?^()\[\]{}\\|])" "\\\\$1"))

\end{chunk}

{\bf add} -- Append a transformed value to internal expression that
will compiled. This method should be private.

{\bf startOfLine} -- append \verb,^, at start of expression

{\bf find} -- \verb,"(?:" + value + ")",

{\bf then} -- shorthand for {\bf find}

{\bf maybe} -- 0 or 1 times \verb,"(?:" + value + ")?",

{\bf anything} -- matches everything \verb,(?:.*),

\begin{chunk}{verbx}
(defun anything (verbx)
  (add verbx "(?:.*)"))

\end{chunk}

{\bf anythingBut} -- \verb,"(?:[^" + value + "]*)",

{\bf something} -- matches at least one char \verb,(?:.+),

\begin{chunk}{verbx}
(defun something (verbx)
  (add verbx "(?:.+)"))

\end{chunk}

{\bf somethingBut} -- matches at least one char not in value
\verb,"(?:[^"+value+"]+)",

{\bf replace} -- return replaced string

{\bf lineBreak} -- mathes linebreak \verb,"(?:(?:\n)|(?:\r\n))",

\begin{chunk}{verbx}
(defun lineBreak (verbx)
  (add verbx "(?:(?:\n)|(?:\r\n))"))

\end{chunk}

{\bf br} -- shorthand for {\bf linebreak}

\begin{chunk}{axiom.bib}
(defmacro br (verbx)
  `(lineBreak ,verbx))

\end{chunk}

{\bf tab} -- match tab character \verb,"\t",

{\bf word} -- atches at least one word \verb,"\w+",

{\bf anyOf} -- matches any char in value \verb,"(?:["+value+"])",

{\bf any} -- shorthand for {\bf anyOf}

\begin{chunk}{axiom.bib}
(defmacro any (verbx)
  `(anyOf ,verbx))

\end{chunk}

{\bf range}

{\bf withAnyCase} -- append modifier \verb,"i",

{\bf stopAtFirst} -- remove modifier \verb,"g", if \verb,"true",,
else append modifier \verb,"g",

{\bf searchOneLine} -- if true, remove modifier \verb,"m",

{\bf multiple}

{\bf or} -- split expression with \verb,|,

{\bf beginCapture} -- initiate capture

{\bf endCapture} -- stop capturing elements

{\bf whitespace} -- \verb,\\s,

{\bf oneOrMore} -- repeats the previous at least once.




\chapter{Quote collections}

\begin{quote}
{\bf The best programs are written so that computing machines can
perform them quickly and so that human beings can understand them
clearly. A programmer is ideally an essayist who works with
traditional aesthetic and literary forms as well as mathematical
concepts, to communicate the way that an algorithm works and to
convince a reader that the results will be correct}\\
-- Donald Knuth, Selected Papers on Computer Science
\end{quote}

\begin{quote}
{\bf Programmers are not mathematicians, no matter how much we wish
and wish for it}\\
-- Richard P. Gabriel
\end{quote}

\begin{quote}
{\bf Literate programs are a form of conversation, not docuentation}\\
-- Tim Daly
\end{quote}

\begin{quote}
{\bf Say not 'This is the truth' but 'So it seems to me to be as I now
see the things I think I see'}\\
-- David Love 
\end{quote}

\begin{quote}
{\bf Beware of bugs in the above code. I have only proved it correct,
not tried it.}\\
-- Donald Knuth
\end{quote}

\begin{quote}
{\bf No loop should be written down without providing proof of 
termination nor without stating the invariaant that will not be 
destroyed by the execution of the repeatable statement}\\
-- Edsger Dijkstra \cite{Dijk72}
\end{quote}

\begin{quote}
{\bf The only effective way to raise the confidence level of a program
significantly is to give a convincing proof of its correctness.}\\
-- Edsger Dijkstra \cite{Dijk72}
\end{quote}

\begin{quote}
{\bf The competent programmer is fully aware of the strictly limited
size of his own skull, therefore he approaches the programming task in
full humility.}\\
-- Edsger Dijkstra \cite{Dijk72}
\end{quote}

\begin{quote}
{\bf For any perceived shortcoming of Common Lisp you can write a
macro that fixes it for less effort than it takes to complain about it}
\end{quote}

\begin{quote}
{\bf A program without a specification cannot be incorrect, it can
only be surprising}\\
-- J.J. Horning
\end{quote}

\begin{quote}
{\bf A proof assistant is what happens if you spend all your time
developing a type checker for your language and forget that programs
also need to be run.}\\
-- Vladislav Zavialov \cite{Zavi}
\end{quote}

\begin{quote}
{\bf Mathematicians are notoriously bad at given the complete context
needed for definitions. One definition in the formal proof of the
Kepler conjecture took 40 revisions to get right}\\
-- Thomas Hales 
\end{quote}

\begin{quote}
{\bf It would be a good thing to buy books if one could also buy the
time to read them; but one usually confuses the purchase of books with
the acquisition of their contents. To desire that a man should retain
everything he has ever read, is the same as wishing him to retain in
his stomach all that he has ever eaten.}\\
-- Arthur Schopenhauer \cite{Scho16}
\end{quote}

\begin{quote}
{\bf When one considers how hard it is to write a computer program
even approaching the intellectual scope of a good mathematical paper,
and how much greater time and effort have to be put into it to make it
``almost'' formally correct, it is preposterous to claim that
mathematics as we practice it is anywhere near formally correct.}\\
-- William P. Thurston \cite{Thur94}
\end{quote}

\begin{quote}
{\bf Given the concepts 0, {\sl number}, and {\sl successor} 
and the rules
\begin{enumerate}
\item 0 is a {\sl number}
\item the {\sl successor} of any {\sl number} is a {\sl number}
\item no two {\sl numbers} have the same {\sl successor}
\item 0 is not the {\sl successor} of any {\sl number}
\item any property which belongs to 0 and also to the {\sl succesor}
of every {\sl number} which has the property, belongs to all the
{\sl numbers}
\end{enumerate}}

-- Giuseppe Peano \cite{Russ1920}
\end{quote}

\begin{quote}
{\bf I WANT a type theory with this strange property.\\
Well, then you deserve it.}\\
-- Andrej Bauer \cite{Baue19a}
\end{quote}

\begin{quote}
{\bf The Axiom Sane effort is, to quote Alan Kay, ``the simplest thing that
is qualitatively different from where we are''.}\\
-- Tim Daly \cite{Kayx19}
\end{quote}

\begin{quote}
{\bf I am a biological copying machine.}\\
-- Tim Daly
\end{quote}

\begin{quote}
{\bf Computers are intellectual mirrors. To program, you must be the
machine.}\\
-- Tim Daly
\end{quote}

\begin{quote}
{\bf From a certain point of view, having a convenient representation
of one's behavior available for modification is what is meant by
consciousness.}\\
-- John McCarthy \cite{Mcca63}
\end{quote}

\begin{quote}
{\bf Even when I write a one-shot program I write it in a literate way
because I get it right faster that way.}\\
-- Donald Knuth \cite{Knut19}
\end{quote}

\begin{quote}
{\bf ... the realization came over me with full force that a good part
of theremainder of my life was going to be spent in finding errors in
my own programs.}\\
-- Maurice Wilkes \cite{Mack01}
\end{quote}

\begin{quote}
{\bf Computer programming is an exact science in that all the
properties of a program and all the consequences of executing it in a
given environment can, in principle, be found out from the text of the
program itself by means of purely deductive reasoning. Deductive
reasoning involves the application of valid rules of inference to sets
of valid axioms. It is therefore desirable and interesting to
elucidate the axioms and rules of inference which underlie our
reasoning about computer programs.}\\
-- C. A. R. Hoare \cite{Hoar69}
\end{quote}

\begin{quote}
{\bf Let us avoid wasting those funds on pseudo mathematicians with
computers and use them to support a few real live mathematicians.}\\
--Frank Bonsall \cite{Mack01}
\end{quote}

\begin{quote}
{\bf Dependent types realize a continuum of precision up to a complete
specification of the program's behaviour. Dependently typed programs
are, by their nature, proof carrying code.}\\
-- Thorston AltenKirch, Conor McBride, James McKenna \cite{Alte05}
\end{quote}

\begin{quote}
{\bf Anything you can learn by a complete set of rules isn't worth
knowing.}\\
-- Danial I.A. Cohen \cite{Mack01}
\end{quote}

\begin{quote}
{\bf Bought a mechanical keyboard with more resistance so my code will
be strongly typed.}
-- Jason Karns \cite{Warn19}
\end{quote}

\begin{quote}
{\bf DSL -- A domain specific language, where code is written in one
language and errors are given in another.}\\
-- Unknown \cite{Unkn20}
\end{quote}

\begin{quote}
{\bf Computers have enabled people to make more mistakes faster than
almost any invention in history ... with the possible exception of
tequila and hand guns.}\\
-- Ratcliffe \cite{Brad20}
\end{quote}

\begin{quote}
{\bf Me: There are a lot of 'Axiom' things around.\\
Simon: Of course. That's why we have the Axiom of Choice}\\
-- Simon Cruanes \cite{Crua20}
\end{quote}

\begin{quote}
{\bf Never trust a type theorist who has not changed their 
mind about equality at least once}\\
-- Conor McBride \cite{Baze14}
\end{quote} 

\begin{quote}
{\bf A tecnnical argument by a trusted author, which is hard to check
and looks similar to arguments known to be correct, is hardly ever
checked in detail.}\\
-- Vladimir Voevodsky \cite{Gray18}
\end{quote}

\begin{quote}
{\bf We're all on earth to help others -- what I can't figure out is
what the others are here for}\\
-- Marvin Minsky \cite{Mcco79}
\end{quote}

\begin{quote}
{\bf If I ask a student whether her design is as good as Chartres, she
often smiles tolerantly at me as if to say ``Of course not, that isn't
what I am trying to do... I could never do that.'' Then, I express my
disagreement, and tell her: ``That standard {\sl must} be ur
standard.''}\\
-- Christopher Alexander \cite{Gabr96}
\end{quote}

\begin{quote}
{\bf The distance is commonly very great between actual performances
and speculative possibility. It is natural to suppose that as much as
has been done today may be done tomorrow: but on the morrow some
difficuty emerges, or some external impediment obstructs. Indolence,
interruption, business, and pleasure, all take their turns of
retardation; and every long work is lengthened by a thousand causes
that can, and ten thousand that cannot, be recounted. Perhaps no
extensive and multifarious performance was ever effected within the
term originally fixed in the undertaker's mind. He that runs against
Time has an antagonist not subject to casualties.}\\
-- Samuel Johnson \cite{Gabr85}
\end{quote}

\begin{quote}
{\bf I cannot claim to offer anything other than the notions of myself
that I have formed over the space of roughly forty years, and their
only singularity, it semms to me, is that they are not flattering.}\\
-- Peter Hogarth \cite{Lemx68}
\end{quote}

\begin{quote}
{\bf The shame of a genius may be his intellectual futility, the
knowledge of how uncertain is all that he has accomplished.}\\
-- Peter Hogarth \cite{Lemx68}
\end{quote}

\begin{quote}
{\bf Ants that encounter in their path a dead philosopher may make
good use of him}\\
-- Peter Hogarth \cite{Lemx68}
\end{quote}

\begin{quote}
{\bf Something must be done.\\
I am doing something.\\
Therefore something was done.}\\
-- Cory Doctorow \cite{Doct11}
\end{quote}

\begin{quote}
{\bf Ten years ago, researchers into formal methods (and I was the
most mistaken among them) predicted that the programming world would
embrace with gratitude every assistance promised by formalisation to
solve the problems of reliability that arise when programs get large
and more safety-critical.
Programs have now got very large and very critical -- well beyound the
scale which can be comfortably tackled by formal methods. There have
been many problems and failures, but these have nearly always been
attributable to inadequate analysis of requirements or inadequate
management control. It has turned out that the world just does not
suffer significantly from the kind of problem that our research was
originally intended to solve.}\\
-- Tony Hoare \cite{Hoar95}
\end{quote}

\begin{quote}
{\bf There is no such thing as just-in-time research.}\\
-- Tony Hoare \cite{Hoar95}
\end{quote}

\begin{quote}
{\bf It has often been said that we would not recognize an alien
intelligence because it will be so different that it does not fit into
our ``rational categories''. As an emergent force, the internet is
certainly evolving into something that cannot be ``rationally
reduced'' by looking at the pieces.}\\
-- Tim Daly (email to Stuart Russell on May 28, 2020)
\end{quote}

\begin{quote}
{\bf Programs should be written and polished until they acquire
publication quality. It is infinitely more demanding to design a
publishable program than one that ``runs''. Programs should be written
for human readers as well as for computers.}\\
-- Niklaus Wirth \cite{Wirt95}
\end{quote}

\begin{quote}
{\bf I have regarded it as the highest goal of programming language
design to enable good ideas to be elegantly expressed}\\
-- Charles Antony Richard Hoare \cite{Hoar81}
\end{quote}

\begin{quote}
{\bf You know, you shouldn't trust us intelligent programmers. We can
think up such good arguments for convincing ourselves and each other
of the utterly absurd. Especially don't believe us when we promise to
repeat an earlier success, only bigger and better next time.}\\
-- Charles Antony Richard Hoare \cite{Hoar81}
\end{quote}

\begin{quote}
{\bf How can one check a large routine in the sense of making sure
that it's right? In order that the man who checks may not have too
difficult a task, the programmer should make a number of definite
assertions which can be checked individually, and from which the
correctness of the whole program easily follows.}\\
-- Alan Turing \cite{Turi49}
\end{quote}

\begin{quote}
{\bf When you show that a program meets its specifications, all you
have done is to show that two formal descriptions, slightly different
in character, are compatible. This is why I think it is somewhere
between misleading and immoral for computer scientists to call this
``correctness''. What is called a proof of correctness is really a
proof of the compatibility or consistency between two formal objects
of an extremely similar sort: program and specification. As a
community, we computer scientists should call this relative
consistency, and drop the word 'correctness' completely.}\\
-- Brian Cantwell Smith \cite{Smit60}
\end{quote}

\begin{quote}
{\bf A person's reach should exceed their grasp,
or what's a computer for?}\\
-- Tim Daly
\end{quote}

\begin{quote}
{\bf The problem is that we are attempting to build systems that are
beyond our ability to intellectually manage.}\\
-- Nancy Leveson \cite{Leve11}
\end{quote}

\begin{quote}
{\bf Ideas that require people to unlearn what they've learned and
think in new ways, there is often an enormous amount of resistance.}\\
-- Bret Victor \cite{Vict13}
\end{quote}

\begin{quote}
{\bf The most dangerous thought you can have as a creative person is
to think you know what you're doing.}\\
-- Bret Victor \cite{Vict13}
\end{quote}

\begin{quote}
{\bf It is a Hungarian hobby to get deeply into the proof without 
stating the theorem.}\\
-- Mario Szegedy \cite{Szed14}
\end{quote}

\begin{quote}
{\bf I think we should redefine the ``Hamming Distance'' as the
distance between an idea and its implementation.}\\
-- Tim Daly
\end{quote}

\begin{quote}
{\bf Consciousness is an emergent phenomenon, like a traffic jam.
It requires a certain level of complexity to achieve a certain
level of intelligence. Thus, it is not contained within a logic
nor bounded by Turing restrictions.}\\
-- Tim Daly
\end{quote}

\begin{quote}
\begin{itemize}
\item {\bf Writing a program is difficult}
\item {\bf Writing a correct program is even more so}
\item {\bf Writing a publishable program is exacting}
\end{itemize}
-- Niklaus Wirth \cite{Wirt20}
\end{quote}

\begin{quote}
{\bf ...books should be written presenting actually operational
systems rather than half-baked, abstract principles.}\\
-- C.A.R.Hoare \cite{Wirt13}
\end{quote}

\begin{quote}
{\bf In exactly the same way a small change in axioms (of which we
cannot be completely sure) is capable, generally speaking, of leading
to completely different conclusions than those that are obtained from
theorems which have been deduced from the accepted axioms. The longer
and fancier is the chain of deductions (``proofs''), the less reliable
is the final result.}\\
-- V. I. Arnold \cite{Arno98}
\end{quote}

\begin{quote}
{\bf Worse-is-better, even in its straw-man form, has better survivial
characteristics thatn the-right-thing.}\\
-- Richard Gabriel \cite{Gabr91}
\end{quote}

\begin{quote}
{\bf Don't you think it's ironic that type theorists, who want to talk
about strongly typed language in a rigorous manner, talk to
themselves with an untyped language that has no rigorous specification?}\\
-- Guy Steele \cite{Stee17}
\end{quote}

\begin{quote}
{\bf Mathematics may be defined as the subject in which we never know
what we are talking about, nor whether what we are saying is true.}\\
-- Bertrand Russell \cite{Hick17}
\end{quote}

\begin{quote}
{\bf Complexity is a bug lamp for smart people}\\
-- Maciej Ceglowski \cite{Cegl19}
\end{quote}

\begin{quote}
{\bf The programmer does not differ from any other craftsman: unless he
loves his tools it is highly improbable that he will ever create
something of superior quality.}\\
-- Edsgar Dijkstra \cite{Dijk12}
\end{quote}

\begin{quote}
{\bf What does it all mean? It means nothing but itself}\\
-- Edward Morgan Forster \cite{Fors11}
\end{quote}

\begin{quote}
{\bf Time is only linear for Engineers and Referees}\\
-- Craig Ferguson \cite{Ferg06}
\end{quote}

\begin{quote}
{\bf How slowly grinds the whetstone that sharpens the human mind.}\\
-- Hope Jahren \cite{Jahr20}
\end{quote}

\begin{quote}
{\bf I now do all my mathematics with a proof assistant and do not
have to worry all the time about mistakes in my arguments or about how
to convince others that my arguments are correct.

But I think that the sense of urgency that pushed me to hurry with the
program remains. Sooner or later computer proof assistants will become
the norm, but the longer this process takes the more misery associated
with mistakes and with unnecessary self-verification the practitioners
of the field will have to endure.}\\
-- Vladimir Voevodsky \cite{Voev14}
\end{quote}

\begin{quote}
{\bf You don't know what you are taling about until you understand it
all three ways (type theory, proof theory, category theory)}\\
-- Robert Harper \cite{Harp12}
\end{quote}

\begin{quote}
{\bf Modern algebra and programming languages with strong typing are
useful, but not panaceas in the realm of algebraic manipulation
systems. It appears that we are neither sufficiently sophisticated in
algebra, nor in programming languages to solve all the problems
mentioned here.}\\
-- Richard Fateman \cite{Fate94}
\end{quote}

\includegraphics[scale=0.5]{ps/PreciseSpec.eps}\\
\cite{Comm16}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix

\newpage
\phantomsection
{\huge Coq Example Code}
\addcontentsline{toc}{chapter}{Coq Example Code}
\label{Coq Example Code}

\url{https://github.com/k-vs-coq-language-frameworks/coq/imp.v}

\begin{verbatim}

(* Based on the imp example in coind,
   extracted to a single-file.
 *)
(* Developed with Coq 8.9.1 *)

Require Import String.
Require Import ZArith.
Require Import List.

Set Implicit Arguments.

Local Open Scope Z.
Import List.ListNotations.
Local Open Scope list.
Local Open Scope string.

(** * The syntax of IMP programs *)

Inductive AExp :=
  | var : string -> AExp
  | con : Z -> AExp
  | div : AExp -> AExp -> AExp
  | plus : AExp -> AExp -> AExp
  .

Inductive BExp :=
  | bcon : bool -> BExp
  | le : AExp -> AExp -> BExp
  | not : BExp -> BExp
  | and : BExp -> BExp -> BExp
  .

Inductive Stmt :=
  | assign : string -> AExp -> Stmt
  | cond : BExp -> Stmt -> Stmt -> Stmt
  | while : BExp -> Stmt -> Stmt
  | seq : Stmt -> Stmt -> Stmt
  | skip : Stmt
  .

Inductive Pgm :=
    pgm : list string -> Stmt -> Pgm.

(** Here is the sum program *)
Definition sum_pgm N : Pgm :=
 pgm ["n"; "sum"]
(seq (assign "n" (con N))
(seq (assign "sum" (con 0))
     (while (not (le (var "n") (con 0)))
     (seq (assign "sum" (plus (var "sum") (var "n")))
          (assign "n" (plus (var "n") (con (-1)))))))).

(** * The semantics of IMP programs *)

Definition Env := list (string * Z).
Definition empty_env : Env := [].
Fixpoint get x (env:Env) :=
  match env with
  | [] => None
  | (x',v)::env' =>
    if string_dec x x' then Some v else get x env'
  end.
Fixpoint set x v (env:Env) :=
  match env with
  | [] => []
  | (x',v')::env' =>
    if string_dec x x' then (x,v)::env' else (x',v')::set x v env'
  end.
  (* "simpl" should reduce set if concrete values are given for both variables *)

(* ** These "step" types together define single execution steps  *)
Inductive step_e : (AExp * Env) -> (AExp * Env) -> Prop :=
  | step_var: forall v x env, get v env = Some x ->
      step_e (var v, env) (con x, env)
  | step_plus: forall x y env,
      step_e (plus (con x) (con y), env) (con (Z.add x y), env)
  | step_div: forall x y env,
      y <> 0%Z ->
      step_e (div (con x) (con y), env) (con (Z.div x y), env)
  | cong_plus_r: forall e1 e2 e2' env env',
      step_e (e2, env) (e2', env') ->
      step_e (plus e1 e2, env) (plus e1 e2', env')
  | cong_plus_l: forall e2 e1 e1' env env',
      step_e (e1, env) (e1', env') ->
      step_e (plus e1 e2, env) (plus e1' e2, env')
  | cong_div_r: forall e1 e2 e2' env env',
      step_e (e2, env) (e2', env') ->
      step_e (div e1 e2, env) (div e1 e2', env')
  | cong_div_l: forall e2 e1 e1' env env',
      step_e (e1, env) (e1', env') ->
      step_e (div e1 e2, env) (div e1' e2, env')
  .

(* These abbreviations capture the pattern of the congruence rules *)
Notation cong_l op R1 R2 :=
  (forall a env a' env', R1 (a,env) (a',env') ->
   forall b, R2 (op a b, env) (op a' b, env')).
Notation cong_r op nf R1 R2 :=
  (forall b env b' env', R1 (b,env) (b',env') ->
   forall a, R2 (op (nf a) b, env) (op (nf a) b', env')).
Notation cong_1 op R1 R2 :=
  (forall a env a' env', R1 (a,env) (a',env') -> R2 (op a, env) (op a', env')).

Inductive step_b : (BExp * Env) -> (BExp * Env) -> Prop :=
  | eval_le : forall v1 v2 env,
      step_b (le (con v1) (con v2), env) (bcon (Z.leb v1 v2), env)
  | eval_not : forall b env,
      step_b (not (bcon b), env) (bcon (negb b), env)
  | eval_and : forall b e env,
      step_b (and (bcon b) e, env) (if b then e else bcon false, env)
  | cong_le_r : cong_r le con step_e step_b
  | cong_le_l : cong_l le step_e step_b
  | cong_not : cong_1 not step_b step_b
  | cong_and : cong_l and step_b step_b
  .

Inductive step_s : (Stmt * Env) -> (Stmt * Env) -> Prop :=
  | exec_assign : forall x v v0 env,  get x env = Some v0 ->
      step_s (assign x (con v),env) (skip, set x v env)
  | cong_assign : forall x,
      cong_1 (assign x) step_e step_s
  | exec_seq : forall s env,
      step_s (seq skip s,env) (s,env)
  | cong_seq : cong_l seq step_s step_s
  | exec_cond : forall b s1 s2 env,
      step_s (cond (bcon b) s1 s2, env) (if b then s1 else s2, env)
  | cong_cond : forall b b' env env' s1 s2, step_b (b,env) (b',env') ->
      step_s (cond b s1 s2,env) (cond b' s1 s2,env')
  | exec_while : forall b s env,
      step_s (while b s,env) (cond b (seq s (while b s)) skip, env)
  .

Inductive step_p : (Pgm * Env) -> (Pgm * Env) -> Prop :=
  | exec_init: forall x xs s env,
      step_p (pgm (x::xs) s,env) (pgm xs s, (x,0)::env)
  | exec_body: forall s env s' env',
      step_s (s, env) (s', env') ->
      step_p (pgm nil s, env) (pgm nil s', env')
  .

(** Now we verify the program *)
Require Import proof_system.

(** The claim about the loop says that running the loop in any enviroment
    with a non-negative n finishes with n set to zero, and sum increased
    from it's original value by the sum of numbers 0+1+...+n.
 *)
Inductive sum_spec : Spec (Pgm * Env) :=
 | sum_claim: forall n, 0 <= n ->
   sum_spec
     (pgm ["n"; "sum"]
       (seq (assign "n" (con n))
       (seq (assign "sum" (con 0))
            (while (not (le (var "n") (con 0)))
            (seq (assign "sum" (plus (var "sum") (var "n")))
                 (assign "n" (plus (var "n") (con (-1))))))))
     ,[])
     (fun cfg' => cfg' = (pgm [] skip, [("sum",((n + 1) * n)/2);("n",0)]))
 | sum_loop_claim : forall env n, get "n" env = Some n -> 0 <= n ->
                    forall s, get "sum" env = Some s ->
      sum_spec
         (pgm []
           (while (not (le (var "n") (con 0)))
             (seq (assign "sum" (plus (var "sum") (var "n")))
                  (assign "n" (plus (var "n") (con (-1))))))
         ,env)
      (fun cfg' => fst cfg' = pgm [] skip /\
         snd cfg' = set "n" 0 (set "sum" (s + ((n + 1) * n)/2) env)).

(* Some lemmas about enviroment stuff *)
Ltac env_ind_tac env :=
  induction env as [|[]];try reflexivity;simpl;
  repeat match goal with
  | [ |- context [string_dec ?a ?b]] => destruct (string_dec a b);simpl;try congruence
  end.

Lemma env_set_id: forall x v env,
    get x env = Some v ->
    set x v env = env.
Proof.
  env_ind_tac env.
  intro. f_equal. tauto.
Qed.

Lemma env_set_eq:
  forall x v1 v2 env,
    set x v1 (set x v2 env) = set x v1 env.
Proof. env_ind_tac env. Qed.

Lemma env_set_ne_comm:
  forall x1 x2, x1 <> x2 ->
  forall v1 v2 env,
    set x1 v1 (set x2 v2 env) = set x2 v2 (set x1 v1 env).
Proof. env_ind_tac env. Qed.

Lemma env_set_set: forall x1 x2 v1 v2 env,
    set x1 v1 (set x2 v2 env) =
    if string_dec x1 x2
    then set x1 v1 env
    else set x2 v2 (set x1 v1 env).
Proof. env_ind_tac env. Qed.

Definition env_has x env: bool :=
  match get x env with
  | Some _ => true
  | None => false
  end.

Lemma env_has_get x v env:
  get x env = Some v ->
  env_has x env = true.
Proof.
  unfold env_has;intros ->;reflexivity.
Qed.

Lemma env_get_set x x' v env:
  get x (set x' v env) =
  if string_dec x x'
  then if env_has x env then Some v else None
  else get x env.
Proof. unfold env_has; env_ind_tac env. Qed.

Lemma env_has_set x x' v env:
  env_has x (set x' v env) = env_has x env.
Proof.
  unfold env_has.
  rewrite env_get_set.
  unfold env_has.
  destruct (string_dec x x');[|reflexivity].
  destruct (get x env);reflexivity.
Qed.

Ltac step_tac :=
  match goal with
  | [ |- step_p _ _] => econstructor;step_tac
  | [ |- step_s _ _] => econstructor;step_tac
  | [ |- step_b _ _] => econstructor;step_tac
  | [ |- step_e _ _] => econstructor;step_tac
  | [ |- get _ _ = _] => rewrite ?env_get_set;(reflexivity || eassumption)
  end.

Ltac run := repeat first[
   eapply dtrans;[constructor|]
  |eapply ddone;simpl;split;[reflexivity|]
  |eapply dstep;[step_tac|]].

Require Import Recdef.
Function sum_to (n:Z) { wf (fun x y => 0 <= x < y) n } : Z :=
  if Z_lt_ge_dec 0 n then n + sum_to (n - 1) else 0.
intros;omega.
exact (Z.lt_wf 0).
Defined.

Lemma sum_algebra: forall s n, 0 < n ->
  s + n + (n + -1 + 1) * (n + -1) / 2
           = s + (n + 1) * n / 2.
Proof.
  intros s n H.
  rewrite <- Z.add_assoc.
  f_equal.
  rewrite <- Z.add_assoc, Z.add_0_r.
  rewrite <- Z.div_add_l by omega.
  f_equal.
  rewrite Z.mul_add_distr_r, Z.mul_add_distr_l.
  omega.
Qed.

Lemma sum_ok : sound step_p sum_spec.
apply proved_sound;destruct 1.

{ (* Overall claim, easily proved with loop claim *)
  eapply sstep;[solve[step_tac]|].
  run;[reflexivity || assumption ..|].
  destruct k';simpl.
  destruct 1 as [-> ->].
  apply ddone.
  reflexivity.
}


eapply sstep;[solve[step_tac]|].
run.
destruct (Z.leb_spec n 0);simpl.

(* when n = 0, loop exits.
   To conclude, need to prove that the initial
   environment env is an acceptable result *)
run.
replace n with 0 in H |- * by auto with zarith.
rewrite (env_set_id "sum") by (rewrite H1;f_equal;auto with zarith).
rewrite (env_set_id "n") by assumption.
reflexivity.

(* when n > 0, execution goes through the loop body,
   then sum_loop_claim is applied by transitivity,
   which takes us to a state satisfying the goal *)
run.
{ rewrite env_get_set, ?env_has_set.
  simpl.
  erewrite env_has_get by eassumption;reflexivity. }
  omega.
{ rewrite !env_get_set.
  simpl.
  erewrite env_has_get by eassumption;reflexivity. }
destruct k';simpl;intros [-> ->].

run.
rewrite (env_set_set "sum" "n"). simpl.
rewrite 2 env_set_eq.
f_equal.
f_equal.
apply sum_algebra.
assumption.
Qed.

\end{verbatim}

The proof
\begin{verbatim}
Require Import String.
Require Import ZArith.
Require Import imp.

Local Open Scope Z.
Import List.ListNotations.
Local Open Scope list.
Local Open Scope string.

(** An execution trace is a sequence of zero or more steps.
    We will take the reflexive-transitive closure of the step
    relation using the library type clos_refl_trans_1n *)
Import Relation_Operators.

(** Execution tests can be written as a theorem claiming that
    an initial state reaches an expected final state *)
Lemma test_execution :
  clos_refl_trans_1n _ step_p (sum_pgm 100,[]) (pgm nil skip,[("sum",5050);("n",0)]).
Proof.
  Time repeat (eapply rt1n_trans;[once solve[repeat econstructor]|];simpl).
  apply rt1n_refl.
Time Qed.

(** The final state can also be filled in by the search.
    This statement uses a sort of existential quantification over the
    final environment e2 *)
Lemma test_execution2 :
  {e2:Env | clos_refl_trans_1n _ step_p (sum_pgm 100,[]) (pgm nil skip,e2)}.
Proof.
  eexists.
  Time repeat (eapply rt1n_trans;[once solve[repeat econstructor]|simpl]).
  apply rt1n_refl.
Time Defined.

(** The final environment can be extracted from this trace *)
Eval simpl in proj1_sig test_execution2.

\end{verbatim}

Proving reachability

\begin{verbatim}
(*
  This file contains the main soundness proof allowing
  the reachability logic proof strategy to be used in Coq.

  'reaches x P' holds
  if any execution path from configuration x is either infinite or
  reaches a configuration satisfying P.

  'reaches' is shown to be the greatest fixpoint of the 'step' function.

  'stable_sound' is plain coinduction theorem for 'reaches' and 'step',
  'proved_sound' is the generalized coinduction theorem also allowing
  the "proof" rules defined in 'trans'.
 *)
Set Implicit Arguments.

Section relations.
Variables (cfg : Type) (cstep : cfg -> cfg -> Prop).

Definition Spec : Type := cfg -> (cfg -> Prop) -> Prop.

(* Soundness *)
CoInductive reaches (k : cfg) (P : cfg -> Prop) : Prop :=
  (* reaches : Spec, but defining k and P as parameters
     gives a cleaner definition and induction principle. *)
| rdone : P k -> reaches k P
| rstep : forall k', cstep k k' -> reaches k' P -> reaches k P.

Definition sound (Rules : Spec) : Prop :=
  forall x P, Rules x P -> reaches x P.

Inductive step (X : Spec) (k : cfg) (P : cfg -> Prop) : Prop :=
  (* step : Spec -> Spec *)
| sdone : P k -> step X k P
| sstep : forall k', cstep k k' -> X k' P -> step X k P.

Lemma reaches_stable :
  (forall x P, reaches x P -> step reaches x P).
Proof. destruct 1;econstructor;eassumption. Qed.

CoFixpoint stable_sound (Rules : Spec)
  (Hstable : forall x P, Rules x P -> step Rules x P)
  : sound Rules :=
  fun x P H =>
  match Hstable _ _ H with
    | sdone _ _ _ pf => rdone _ _ pf
    | sstep _ _ Hstep H' =>
        rstep Hstep (stable_sound Hstable _ _ H')
  end.

(*
Inductive derived (X : Spec) k P : Prop :=
| dclaim : X k P -> derived X k P
| ddone : P k -> derived X k P
| dstep : forall k', cstep k k' -> derived X k' P -> derived X k P
| dtrans' : forall Q, derived X k Q -> (forall k', Q k' -> derived X k' P)
    -> derived X k P
| dproved : reaches k P -> derived X k P.
*)

Inductive trans (X : Spec) (k : cfg) (P : cfg -> Prop) : Prop :=
  (* trans : Spec -> Spec *)
  | ddone : P k -> trans X k P
  | dtrans' : forall Q, trans X k Q -> (forall k', Q k' -> trans X k' P) -> trans X k P
  | drule : X k P -> trans X k P
  | dstep : forall k', cstep k k' -> trans X k' P -> trans X k P
  | dvalid : reaches k P -> trans X k P
  .
Definition dtrans_valid (X : Spec) (k : cfg) (P Q : cfg -> Prop)
  (rule : reaches k Q) (rest : forall k', Q k' -> trans X k' P) : trans X k P :=
  @dtrans' X k P Q (dvalid _ rule) rest.
Definition dtrans (X : Spec) (k : cfg) (P Q : cfg -> Prop)
  (rule : X k Q) (rest : forall k', Q k' -> trans X k' P) : trans X k P :=
  @dtrans' X k P Q (drule _ _ _ rule) rest.

Lemma trans_stable (Rules : Spec) :
  (forall x P, Rules x P -> step (trans Rules) x P)
  -> (forall x P, trans Rules x P -> step (trans Rules) x P).
induction 2;eauto using step.
destruct IHtrans; eauto using step, dtrans'.
destruct H0; eauto using step,dvalid.
Qed.

Lemma proved_sound (Rules : Spec) :
  (forall x P, Rules x P -> step (trans Rules) x P)
  -> sound Rules.
unfold sound.
intros H x P R.
eapply stable_sound.
apply trans_stable. eassumption.
apply drule. assumption.
Qed.

End relations.

\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Bibliography}
We have made every effort to consult and reference primary
sources. (See \cite{Rekd14}).
\bibliographystyle{axiom}
\bibliography{axiom}

\newpage
\phantomsection
{\huge Signatures Index}
\addcontentsline{toc}{chapter}{Signatures Index}
\immediate\closeout\sigfile
\vskip 1cm
\input{signatures.sort}

\newpage
\phantomsection
\addcontentsline{toc}{chapter}{Figure Index}
\renewcommand{\indexname}{Figure Index}
\printindex[fig]

\newpage
\phantomsection
\addcontentsline{toc}{chapter}{Documentation Index}
\renewcommand{\indexname}{Documentation Index}
\printindex[doc]

\newpage
\phantomsection
\addcontentsline{toc}{chapter}{Code Index}
\renewcommand{\indexname}{Code Index}
\printindex[code]

\newpage
\phantomsection
\addcontentsline{toc}{chapter}{Error Index}
\renewcommand{\indexname}{Error Index}
\printindex[err]

\newpage
\phantomsection
\addcontentsline{toc}{chapter}{Category Index}
\renewcommand{\indexname}{Category Index}
\printindex[cat]

\newpage
\phantomsection
\addcontentsline{toc}{chapter}{Domain Index}
\renewcommand{\indexname}{Domain Index}
\printindex[dom]

\newpage
\phantomsection
\addcontentsline{toc}{chapter}{Package Index}
\renewcommand{\indexname}{Package Index}
\printindex[pkg]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}

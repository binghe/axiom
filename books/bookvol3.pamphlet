\documentclass[dvipdfmx]{book}
\newcommand{\VolumeName}{Volume 3: Axiom Programmers Guide}
\input{bookheader.tex}
\pagenumbering{arabic}
\mainmatter
\setcounter{chapter}{0} % Chapter 1
\chapter[A Language for Computational Algebra]
{A Language for Computational Algebra by Jenks and Trager}

\section{Introduction}

Jenks and Trager\cite{Jenk81} describe a language with parameterized
types and generic operators particularly suited to computational algebra.
A flexible framework is given for building algebraic structures and
defining algorithms which work in as general a setting as possible.
This section will be an overview of our main concepts: ``domains''
and ``categories''.

A language for computational algebra should be able to express algorithms
for dealing with algebraic objects at their most natural level of abstraction.
We can illustrate this concept with two simple algorithms. First, we wish
to write a function {\sl max} which computes the maximum of two elements
of any set on which an ordering predicate is defined. One approach to this
problem is to explicitly pass the ordering predicate as an additional
argument to max. Thus max might be defined by
\begin{verbatim}
   max(x,y,lessThan) == if lessThan(x,y) then y else x
\end{verbatim}
where lessThan is the ordering predicate. In more complicated algorithms,
the number of additional arguments required gets out of hand. Our approach
is instead to require the arguments $x$ and $y$ of max to be elements
of some specific algebraic structure which has a ``less than'' operation
'$<$' implemented by some function. We will call such algebraic structures
{\bf domains}. Thus '$<$' is a ``generic'' operation which has different
function definitions for different domains. Our definition of max, with
suitable declarations, becomes:
\begin{verbatim}
   max(x,y) == if x < y then y else x
\end{verbatim}

The requirement that a generic operation have a particular name does not
characterize its algebraic properties. In the above definition of max,
it is implicitly assumed that '$<$' provides a total ordering on the
elements of its domain. To this end, our domains will also have a set of
{\sl attributes} which permit a description of the algebraic properties
of its operations (e.g. so as to distinguish between totally-ordered and
partially-ordered sets).

As a second example, we examine the classical algorithm for computing the
{\sl gcd}, the greatest common divisor, of two integers:
\begin{verbatim}
   gcd(x,y) == if x = 0 then y else gcd(y,remainder(x,y))
\end{verbatim}

Although this algorithm was originally intended to be used only on integers,
a cursory examination shows that only a few properties of the integers are
actually required. In fact, the same algorithm can be used on gaussian
integers, polynomials over fields, or any other domain which has an
appropriate remainder function. We wish to specify the minimum requirements
of an algebraic structure for the gcd algorithm to be applicable. To do this,
we introduce a grouping of domains called a {\bf category}, in this case,
``the category of Euclidean domains''. Any domain of this category will be
an integral domain with a generic function {\sl remainder} satisfying two
requirements. The first is that 
\begin{verbatim}
   remainder(x,y) = x - q*x*y
\end{verbatim}
for some $q$ in the domain as this implies
\begin{verbatim}
   gcd(x,y) - gcd(y,remainder(x,y))
\end{verbatim}
The remainder function must also have the property that the remainder
sequence generated by any two elements of the domain always reaches 0 in a
finite number of steps. These two requirements are sufficient to guarantee
the correctness of our gcd algorithm.

Categories provide a set of required generic operations together with a
set of attributes describing the required algebraic properties of these
operations. Domains provide specific functions which implement the 
operations and satisfy the attributes. Thus we may speak of ``the category
of totally-ordered sets'' as the class of all domains which have the above
'$<$' operation with specific algebraic properties, and ``the domain of
the integers'' as an example of a member of that category since it has a
function 'integer$<$' which provides that operation and satisfies those
properties.

Once an abstract algorithm has been written, its author specifies the
category of domains to which it applies, either by explicitly listing
the operations and attributes it requires or by referencing a predefined
category. For example, having defined the category EuclideanDomain
(``the category of Euclidean domains''), a complete definition of the gcd
function could be written:
\begin{verbatim}
   gcd(x:R,y:R):R where R:EuclideanDomain ==
       if x=0 then y else gcd(y,remainder(x,y))
\end{verbatim}

Expressions of the form ``A:B'' are called {\sl declarations}. The
arguments $x$ and $y$ of gcd are {\sl declared} to be elements of some
domain R which, in turn, is declared to be a member of EuclideanDomain.
Declaring ``A:B'' means ``A is a member of B'' in the following sense.
Declaring a domain to be a member of a category indicates that all the
operations of the category are implemented in that domain as functions
which satisfy the attributes of the category. Similarly declaring an
object to be a member of a domain means that all the functions provided
in that domain are applicable to the object.

Domains and categories are both computed objects that can be assigned to
a variable, passed as arguments, and returned from functions. A category
may be produced by explicitly listing operations and attributes, or by
invoking a function which returns a category. Categories may be augmented,
diminished, or ``joined'' with other categories to produce a new category
containing all of the operations and attributes of the individual categories.

A domain is always created by a function which we call a {\bf functor}.
Some simple domains are ``the integers'' and ``the booleans'' which are
produced by functors of no arguments. Other domains such as ``the integers
mod 7'' are produced by functors which take arguments (such as the modulus
7). Most algebraic domains are built up from other domains which, along
with other parameters, are passed as arguments to the functors that construct
them. For example, the domain ``polynomials in X over the integers'' is
created by a polynomial functor which takes a variable (e.g. ``X'') and an
underlying domain (e.g. ``the integers'') as arguments. With the few 
exceptions noted in the next section, 
functors and categories are definable in the
language and may be freely modified. A user is free to introduce new 
categories and define new functors in order to make more domains available
for computation.

Max and gcd were both defined in terms of generic operations from domains
implicitly passed as arguments. As required by some algebraic algorithms,
domains are dynamically created and assigned to local variables. Objects
of these newly created local domains can be created, manipulated, and
converted to objects of other domains.

\begin{center} 
Figure 1: Algebraic Categories\\
\begin{tabular}{|l|l|l|}
\hline
{\bf category}            & {\bf extends}    & {\bf operations}\\
\hline
Set                       &                  & $=$\\
AbelianGroup              & Set              & $0,+,-$\\
OrderedSet                & Set              & $<$\\
QuotientObject(S:Set)     & Set              & reduce,lift\\
SemiGroup                 & Set              & $\times$\\
Finite                    & Set              & size,random\\
Monoid                    & SemiGroup        & 1\\
Group                     & Monoid           & inv\\
Ring                      & (Monoid,AG)      & characteristic, recip\\
Module(R:Ring)            & AbelianGroup     & scalar$\times$\\
Algebra(R:Ring)           & (Ring,Module(R)) &\\
DifferentialRing          & Ring             & deriv\\
IntegralDomain            & Ring             & isAssociate./ /\\
SkewField                 & Ring             & /\\
UniqueFactorizationDomain & IntegralDomain   & gcd, factor, isPrime\\
EuclideanDomain           & UFD              & size<, quo, rem\\
Field                     & (ED, SkewField)  &\\
GaloisField               & (Field, Finite)  &\\
VectorSpace(S:Field)      & Module(S)        &\\
\hline
\end{tabular}
\end{center}

Both categories and domains may be organized into hierarchies. Figure 1
shows an algebraic hierarchy of categories, listing the operations (but
not the attributes) introduced by the successive categories. Set is a
category with a single operation '$=$'. SemiGroup extends Set by adding
an operation '$\times$'  etc. More complicated cases will be discussed
in the next section. We will also allow one domain to extend another. 

For example, one can write a ``free-module functor'' to provide the 
module-theoretic aspects of a polynomial ring (additon and multiplication
by scalars). One can then write various polynomial, algebraic-extension,
and sparse-matrix functors as extensions of the free-module functor. The 
polynomial functor, for example, would augment the functions provided
by the free-module functor, adding explicit definitions only for the other
polynomal functions such as multiplication. Similarly, a ``localization
functor'' can be written to provide computations where denominators may be 
from a different domain than that of the numerator, such as ``the odd
integers'', ``powers of 2'', ``products of factored polynomials in X''.
The localization functor is thus a function of two arguments, one for
the numerator domain, the other for the denominator domain. A ``quotient
field functor'' can then be written which extends the localization functor
for the special case when the two argument domains are the same integral
domain. From the quotient field functor, one can produce all of the rational
function domains and ``the rational numbers'' as special cases.

To summarize, our language design provides the useful notions of ``domains''
and ``categories'' for the abstract description of algorithms for 
computational algebra. The facility for categories is unique to our
language and its use seems to be invaluable for describing algorithms
for computational algebra. Our domains are similar to ``modes'' in
EL1\cite{Wegb74} and ``types'' in RUSSELL\cite{Deme79} and ADAPT\cite{Leve80}.
As in EL1, but in contrast to Ada\cite{ADAx83}, domains are computed values.
Our notions of categories and functors are based on concepts in universal
algebra \cite{Cohn65} developed by the ADJ group \cite{That82} and Burstall
and Goguen \cite{Burs77}. In addition, categories extend the idea of
``type constraint'' in CLU \cite{Lisk79} and Alphard \cite{Wulf76} where
functions can require that their arguments have certain operations available
to them. For related work in computer algebra, see \cite{Ausi79}, 
\cite{Gris76}, \cite{Jenk74}, and \cite{Loos74}.

\section{Concepts}

In this section, we give precise definitions and examples of the concepts
of domain, category, and functor.

{\bf Domain}. By a {\sl domain of computation}, or, simply, {\bf domain},
we mean:
\begin{enumerate}
\item a set of generic {\bf operations}
\item a {\bf representation}
\item a set of {\bf functions} which implement the operations in terms
of the representation
\item a set of {\bf attributes}, which designate useful facts such as
axioms and mathematical theorems which are true for the operations as
implemented by the functions.
\end{enumerate}

The simplest examples of domains are those corresponding to the basic
data-types offered by the underlying system, such as Integer (``the
integers''), Boolean (``the booleans''), etc. Other examples of domains
are RationalNumber (``the rational numbers''), Matrix(Integer)
(``rectangular matrices with integer coefficients''), and 
Polynomial(X,RationalNumber) (``the polynomials in X with rational
number coefficients'').

The generic operations are given by {\bf signatures}, expressions consisting
of an {\sl operation name}, a {\sl source}, and a {\sl target}. The domain
Integer, for example, has the operation ``less than'' expressed by the
signture:
\[`<`: ({\rm Integer},{\rm Integer}) \rightarrow {\rm Boolean}\]
with '$<$' as operation name, (Integer,Integer) as source, and Boolean
as target. The source part of the signature is any sequence of domains,
and the target part is any domain.

The representation for a domain describes a data structure used to 
represent the objects of the domain.

The functions component is a set of compiled functions providing a
domain-specific implementation for each generic operation. For example,
domain Integer has a function ``Integer$<$'' which implements ``less than''.
If a domain has an operation signature 
\[{\rm op:}(D_1,\ldots,Dn) \rightarrow D_0\]
then the associated function must take arguments from the representations
of $D_1,\ldots,D_n$ respectively and return a result in the representation
of $D_0$.

The attribute component of a domain is described either by a name, e.g.
``finite'', or by a form with operator names as parameters, e.g. 
``distributive('$\times$','$+$')''. The purpose of attributes is not to
provide complete axiomatic descriptions of an operation, rather to assert
facts which programs can query.

{\bf Category} A ``category'' designates a class of domains with common
operations and attributes but with different functions and representations.
The categories of interest here will be those of algebraic structures such
as Ring (``the class of all rings''), Field (``the class of all fields''),
and Set (``the class of all sets'').

By a {\bf category} we mean:
\begin{enumerate}
\item a set of generic {\bf operations}
\item a set of {\bf attributes}, which designate facts which must be
true for any implementation of the operations.
\end{enumerate}

As with domains, the generic operations of categories are given by
signatures, consisting of an operation name, a source, and a target.
In addition to the domains which may appear in the source and target, a
special symbol \$ (or, later \%) is used to designate an arbitrary member
domain of the category. The set of operations and attributes are those 
which member domains have in common. A simple example of a category is Set,
a category which has one operation 
\[=: (\$,\$) \rightarrow Boolean\]
and no attributes. Another is SemiGroup, which besides the '$=$'
operation, has the operation
\[\times: (\$,\$) \rightarrow \$\]
and the attribute associative('$\times$').

We say a domain D is ``a member of'' a category C, equivalently, D is of C,
if D contains every operation and attribute of C with \$ replaced by D.
For example, Integer is of Set because it contains an operation 
\[=: ({\rm Integer},{\rm Integer}) \rightarrow {\rm Boolean}\]
We say that a category B extends a category A if all of the operations and
attributes of A are contained in B. SemiGroup extends Set since all of the
operations ('$=$') of Set are contained in SemiGroup.

\begin{center}
Figure 2. Examples of Category Definitions
\end{center}

\hrulefill

Set: Category == {\bf category}\\
\hbox{\hskip 0.5cm} [{\sl operations}] =:(\$,\$) $\rightarrow$ Boolean

SemiGroup: Category == Set with\\
\hbox{\hskip 0.5cm} [{\sl operations}] $\times$:(\$,\$) $\rightarrow$ \$\\
\hbox{\hskip 0.5cm} [{\sl attributes}] {\rm associative}('$\times$')
[($x \times y) \times z = x \times (y \times z)$]

\hrulefill

Figure 2 illustrate our language for defining categories. Set is defined
by explicitly listing its operations ('$=$') and its attributes (none).
SemiGroup is defined as an extension of Set. Square-bracketed expressions
are comments. The '$==$' signifies a rewrite-rule definition for the
category Set. Evaluation of ``Set'' causes ``Set'' to be rewritten by the
category value indicated to the right of the '$==$'. Evaluation of
``SemiGroup'' similary causes ``SemiGroup'' to be rewritten by the
corresponding right-hand expression. Further evaluation causes Set to be 
replaced by its value, a category to which the '$\times$' operation and
associative('$\times$') attribute are added by the {\bf with} operation.
As implied by this evaluation mechanism, two categories are equivalent
iff they have equivalent sets of operations and attributes, irrespecitive
of how they were created.

\begin{center}
Figure 3. Examples of Category Definitions
\end{center}

\hrulefill

Module(R:Ring) : Category == AbelianGroup with\\
\hbox{\hskip 0.5cm} [{\sl operations}] $\times$:(R,\$) $\rightarrow$ \$\\
\hbox{\hskip 0.5cm} [{\sl attributes}] $\ldots$

Algebra(R:Ring) : Category == (Ring,Module(R)) with\\
\hbox{\hskip 0.5cm} [{\sl attributes}] $\ldots$

\hrulefill

Figure 3 gives two examples of parameterized categories, that is, categories
that are produced by functions of one or more arguments. The function
Module creates the category of all R-modules, that is, modules over a given
ring R. For example, the function Module applied to Integer produces the
category of all $Z$-modules, domains D which are abelian groups with
the additional operations 
\[\times: ({\rm Integer,D}) \rightarrow {\rm Integer}\].

This category includes domain Integer since Integer is an abelian group
and has the operation 
\[\times: ({\rm Integer,Integer}) \rightarrow {\rm Integer}\].

The function Algebra(R) extends the {\sl join} of a Ring and a Module(R),
written (Ring,Module(R)). The join designates the category formed by
directly combining the operations and attributes of Ring with those of
Module(R).

Another way of parameterizing categories is by operator names. For example,
the above definition of SemiGroup could be extended to take a binary operation
as a parameter:\\
\hbox{\hskip 0.5cm}SemiGroup(op) : Category == Set with\\
\hbox{\hskip 1.0cm}[{\sl operations}] op: (\$,\$) $\rightarrow$ \$\\
\hbox{\hskip 1.0cm}[{\sl attributes}] associative(op)
[$op(op(x,y),z) = op(x,op(y,z))$]

after which we may refer to the multiplicative form of SemiGroup in 
Figure 2 by SemiGroup('$\times$').

{\bf Functor} By a {\bf functor} we mean any function which returns a
domain. A functor creates a domain, a member of some category. A category
never creates anything: it simply acts as a template for domains,
describing which operations and attributes must be present. A functor 
creates a domain by storing functions into a template given by its
target category. Categories never specify representations for objects;
functors always do.

Domains can only be produced by functors. Basic domains (e.g. ``the
integers'') are produced through functors bound to identifiers (e.g.
Integer). In addition, four built-in functors, List Vector, Struct, and
Union, build aggregate domains from other domains passed as arguments.
The functor List can be applied to any domain (e.g. Integer) to produce
a composite domain (e.g. List(Integer)) with a set of functions which
provide operations on lists (e.g. first, rest, cons). The functor
Vector takes two arguments, a positive integer $n$ and a domain $D$,
and produces the domain ``the set of all vectors of length $n$ with
elements from $D$''. Struct produces a domain represented by a set of
name-value pairs, e.g. Struct(real:Integer,imag:Integer) describes
an appropriate representation for ``the Gaussian integers''. 
Union(A,$\ldots$,B) creates a new domain $D$ form the domains $A,\ldots,B$
which is the disjoint union of the domains $A,\ldots,B$.

The language permits the building of new functors from these basic
functors. A simple example is FiniteField in Figure 4.
\begin{center}
Figure 4. Example of Functor Definition
\end{center}

\hrulefill

FiniteField(p:PrimeNumber) : GaloisField ==\\
\hbox{\hskip 0.5cm} {\bf capsule}\\
\hbox{\hskip 1.0cm} [{\sl representation}]\\
\hbox{\hskip 1.5cm} Rep := Integer\\
\hbox{\hskip 1.0cm} [{\sl declarations}]\\
\hbox{\hskip 1.5cm} x,y : \$\\
\hbox{\hskip 1.0cm} [{\sl definitions}]\\
\hbox{\hskip 1.5cm} 0 == Integer.0\\
\hbox{\hskip 1.5cm} 1 == Integer.1\\
\hbox{\hskip 1.5cm} x+y == {\bf if} (w $\leftarrow$ x Integer.$+$ y) $>$ p\\
\hbox{\hskip 3.0cm} {\bf then} w - p\\
\hbox{\hskip 3.0cm} {\bf else} w\\
\hbox{\hskip 1.5cm} $\cdots$

\hrulefill

The functor FiniteField applied to p, a prime number, creates a domain
``the integers modulo p'', a member of its target category GaloisField
(``the class of all Galois fields''). The set of operations and 
attributes of this domain are given by GaloisField, the representation
and set of functions, by the {\sl capsule} part of the definition which
appears to the right of the `$==$'. The representation is always defined
by the distinguished symbol Rep in terms of a ``lower level'' functor.
For FiniteFields, Rep is defined to be Integer (meaning that elements
of a finite field are represented by integers). In a more complicated
example, Rep might be defined in terms of a functor Matrix, whose Rep, 
in turn, might be defined in terms of the built-in functor Vector.
\begin{center}
Figure 5. Example of Functor Definition
\end{center}

\hrulefill

IntegerMod(m:Integer | m $>$ 1): T == C {\bf where}\\
\hbox{\hskip 0.5cm} T == (Ring,Finite) {\bf with}\\
\hbox{\hskip 2.5cm} {\bf if} isPrime m {\bf then} GaloisField\\
\hbox{\hskip 0.5cm} C == {\bf capsule}\\
\hbox{\hskip 1.5cm} $\cdots$\\
\hbox{\hskip 1.0cm} [{\sl definitions}]\\
\hbox{\hskip 1.5cm} {\bf if} isPrime m {\bf then}\\
\hbox{\hskip 2.0cm} x / y == $\ldots$\\
\hbox{\hskip 1.5cm} $\cdots$

\hrulefill

Figure 5 illustrates the use of conditional expressions to make the target
category of a functor depend upon the paramters of the functor. Here the
FiniteField functor of Figure 4 is generalized to IntegerMod, a functor
which produces the domain ``the integers modulo m'' for any positive
integer (modulus) m. The domain produced by the IntegerMod functor will
be a Galois field if m is prime, a finite ring, if it is not. Conditional
expressions are also used in the capsule part of a functor to conditionally
provide functions (e.g the operation '/' will be provided by IntegerMod
only if m is prime), or to provide alternative versions of functions 
(e.g. more efficient implementations for some functions when the modulus
is small).

Figure 6 illustrates a series of functors for localization which illustrate
how domains, like categories, can be extended. Localize takes an R-module
M, and a denominator domain D which is a monoid contained within R. It
produces an R-module of ``fractions''. LocalAlgebra augments this with a
definition of multiplication for fractions producing the localization of
an R-algebra. QuotientField uses LocalAlgebra to produce a ``field of
fractions'' in the special situation where the numerators and 
denominators both come from the same integral domain. When R has a gcd
function, QuotientField redefines the arithmetic operations (supplied by
LocalAlgebra) to produce reduced fractions. Similarly, if R has a
derivation defined for it, QuotientField extends this derivation to the
field of fractions.

{\bf Conclusions} Our language provides the useful notions of ``domains''
and ``categories'' for the abstract description of algorithms for
computational algebra. Domains are the algebraic structures on which 
computation is performed. Categories are groupings of domains with common
operations and attributes.

There are several advantages to our design. Algorithms can be written
to operate over any group, ring, or field, independently of how that
algebraic structure is defined or represented in the computer. The
algorithm implementor need not know about which domains have actually
been created. Rather they need only specify a category which gives the
required operations and essential algebraic properties of the algorithm.
Also, as required by many algebraic algorithms, domains and categories
are dynamically computed objects.

The language we have presented leads to a computer algebra system which is
easily extended by any user. All categories are defined in the language
and are available for user modification. All domains are created by 
functions which, with the exception of a few that are built-in, are also
defined in the language and can be changed by the user. New domains and
categories can be designed and implemented with minimal effort by extending
or combining existing structures.

The language permits considerable code economy. An algorithm is 
implemented by a single function which is applicable to any domain of a
declared category. A matrix functor, for example, will use the same
compiled function to compute the product of two matrices, regardless of
whether the actual matrix coefficents are integers, polynomials, or
other matrices. Parameterized functors help to minimize redundant code by
providing a set of pre-compiled functions for all domains they can produce.
The universal applicability of such functors as QuotientField provide
powerful methods for constructing new algebraic objects.

Our primary goal in presenting a language which deals with algebraic
objects was to take advantage of as much of the structure implicit in the
problem domain as possible. The natural algebraic notions of domains
extending one another, and collecting domains with common properties
into categories have been show to be useful computational devices. By
preserving this natural structure, we hope to have eased the task of 
finding computational models for algebraic structures.

\newpage 
\begin{center}
Figure 6. Definition of Localization Functors
\end{center}
\vskip -0.2cm
\hrulefill

Localize(isZeroDivisor,M,D) : Module(R) == C {\bf where}\\
\hbox{\hskip 0.5cm} R:Ring\\
\hbox{\hskip 0.5cm} M: Module(R)\\
\hbox{\hskip 0.5cm} D: Monoid $\vert$ D $\subseteq$ R\\
\hbox{\hskip 0.5cm} isZeroDivisor: M $\rightarrow$ Boolean\\
\hbox{\hskip 0.5cm} C == {\bf capsule} $\ldots$\\
\hbox{\hskip 1.5cm} [{\sl representation}]\\
\hbox{\hskip 2.0cm} Rep := Struct(num:M, den:D)\\
\hbox{\hskip 1.5cm} [{\sl declarations}]\\
\hbox{\hskip 2.0cm} x,y: \$\\
\hbox{\hskip 2.0cm} n: Integer\\
\hbox{\hskip 2.0cm} r:R ; d:D\\
\hbox{\hskip 1.5cm} [{\sl definitions}]\\
\hbox{\hskip 2.0cm} 0 == Rep(0,1)\\
\hbox{\hskip 2.0cm} -x == Rep(-x.num,x.den)\\
\hbox{\hskip 2.0cm} x=y == isZeroDivisor(y.den $\times$ x.num - 
x.den $\times$ y.num)\\
\hbox{\hskip 2.0cm} x+y == Rep(y.den $\times$ x.num + x.den $\times$ y.num,
x.den $\times$ y.den)\\
\hbox{\hskip 2.0cm} n $\times$ x == Rep(n $\times$ x.num,x.den)\\
\hbox{\hskip 2.0cm} r $\times$ x == {\bf if} r=x.den {\bf then}
Rep(x.num,1) {\bf else} Rep(r $\times$ x.num,x.den)\\
\hbox{\hskip 2.0cm} x / d == Rep(x.num,d $\times$ x.den)
\vskip 0.2cm
LocalAlgebra(isZeroDivisor,A,D): T == C {\bf where}\\
\hbox{\hskip 0.5cm} R: Ring\\
\hbox{\hskip 0.5cm} A: Algebra(R)\\
\hbox{\hskip 0.5cm} isZeroDivisor: A $\rightarrow$ Boolean\\
\hbox{\hskip 0.5cm} D: Monoid $\vert$ D $\subseteq$ R\\
\hbox{\hskip 0.5cm} T == Algebra(R) {\bf with if} A {\bf has}
commutative('$\times$') {\bf then} commutative('$\times$')\\
\hbox{\hskip 0.5cm} C == Localize(isZeroDivisor,A,D) {\bf add} $\ldots$\\
\hbox{\hskip 2.0cm} 1 == Rep(1,1)\\
\hbox{\hskip 2.0cm} x $\times$ y == Rep(x.num $\times$ y.num,
x.den $\times$ y.den)\\
\hbox{\hskip 2.0cm} characteristic == A.characteristic
\vskip 0.2cm
QuotientField(R; IntegralDomain) : T == C {\bf where}\\
\hbox{\hskip 0.5cm} T == (Field,Algebra(R)) {\bf with if}
R of DifferentialRing {\bf then} DifferentialRing\\
\hbox{\hskip 0.5cm} C == LocalAlgebra(\$1 = 0,R,R) {\bf add} $\ldots$\\
\hbox{\hskip 2.0cm} {\bf if} R {\bf has} gcd: (R,R) $\rightarrow$ R 
{\bf then}\\
\hbox{\hskip 2.5cm} x + y == $\ldots$\\
\hbox{\hskip 2.5cm} x $\times$ y == $\ldots$\\
\hbox{\hskip 2.5cm} {\bf where} cancelGcd(x:\$):\$ == $\ldots$\\
\hbox{\hskip 2.0cm} {\bf if} R of DifferentialRing {\bf then}\\
\hbox{\hskip 2.5cm} {\bf if} R {\bf has} gcd: (R,R) $\rightarrow$ R\\
\hbox{\hskip 3.0cm} {\bf then} deriv(x) == $\ldots$\\
\hbox{\hskip 3.0cm} {\bf else} deriv(x) == $\ldots$
\vskip 0.2cm
RationalFunction(x:Expression, R:Ring) == QuotientField(Polynomial(x,R))
\vskip 0.2cm
RationalNumber == QuotientField(Integer)
\vskip -0.2cm
\hrulefill


\chapter{Details for Programmers}
Axiom maintains internal representations for domains.
There are functions for examining the internals of objects of
a particular domain. 
\section{Examining Internals}
One useful function is {\bf devaluate} which takes an object
and returns a Lisp pair. The CAR of the pair is the Axiom type.
The CDR of the pair is the object representation.
For instances, consider the session where we create a list of 
objects using the domain {\bf List(Any)}.
\begin{verbatim}
(1) -> w:=[1,7.2,"luanne",3*x^2+5,_
           (3*x^2+5)::FRAC(POLY(INT)),_
           (3*x^2+5)::POLY(FRAC(INT)),_
           (3*x^2+5)::EXPR(INT)]$LIST(ANY)

                          2       2       2       2
   (1)  [1,7.2,"luanne",3x  + 5,3x  + 5,3x  + 5,3x  + 5]
                                                              Type: List(Any)

\end{verbatim}
The first object, {\bf 1} is a primitive object that has the domain
{\bf PI} and uses the underlying Lisp representation for the number.
\begin{verbatim}
(2) -> devaluate(1)$Lisp

   (2)  1
                                                            Type: SExpression
\end{verbatim}
The second object, {\bf 7.2} is a primitive object that has the domain
{\bf FLOAT} and uses the underlying Lisp representation for the number,
in this case, itself a pair whose CAR is the floating point base and whose
CDR is the mantissa,
\begin{verbatim}
(3) -> devaluate(7.2)$Lisp

   (3)  (265633114661417543270 . - 65)
                                                            Type: SExpression
\end{verbatim}
The third object, {\tt {\bf "luanne"}} is from the domain {\bf STRING}
and uses the Lisp string representation.
\begin{verbatim}
(4) -> devaluate("luanne")$Lisp

   (4)  luanne
                                                            Type: SExpression
\end{verbatim}

Now we get more complicated. We illustrate various ways to store the
formula $3x^2+5$ in different domains. Each domain has a chosen 
representation. 

\begin{verbatim}
(5) -> devaluate(3*x^2+5)$Lisp

   (5)  (1 x (2 0 . 3) (0 0 . 5))
                                                            Type: SExpression
\end{verbatim}
The fourth object, $3x^2+5$ is from the domain {\bf POLY(INT)}. It is stored
as the list
\begin{verbatim}
   (1 x (2 0 . 3) (0 0 . 5))
\end{verbatim}
From the domain {\bf POLY} (Vol 10.3, POLY) we see that
\begin{verbatim}
   Polynomial(R:Ring): ...
      == SparseMultivariatePolynomial(R, Symbol) add ...
\end{verbatim}
So objects from this domain are represented as {\bf SMP(INT,SYMBOL)}. 
From this domain we ss that 
\begin{verbatim}
   SparseMultivariatePolynomial(R: Ring,VarSet: OrderedSet): ...
     == add
       --representations
       D := SparseUnivariatePolynomial(%)
\end{verbatim}
So objects from this domain are represented as a {\bf SUP(INT)}
\begin{verbatim}
   SparseUnivariatePolynomial(R:Ring): ...
     == PolynomialRing(R,NonNegativeInteger) add
\end{verbatim}
So objects from this domain are represented as {\bf PR(INT,NNI)}
\begin{verbatim}
   PolynomialRing(R:Ring,E:OrderedAbelianMonoid): ...
     FreeModule(R,E) add
       --representations
       Term:=  Record(k:E,c:R)
       Rep:=  List Term
\end{verbatim}
So objects from this domain are represented as {\bf FM(INT,NNI)}
\begin{verbatim}
   FreeModule(R:Ring,S:OrderedSet):
      == IndexedDirectProductAbelianGroup(R,S) add
        --representations
        Term:=  Record(k:S,c:R)
        Rep:=  List Term
\end{verbatim}
So objects from this domain are represented as {\bf IDPAG(INT,NNI)}
\begin{verbatim}
   IndexedDirectProductAbelianGroup(A:AbelianGroup,S:OrderedSet):
     ==  IndexedDirectProductAbelianMonoid(A,S) add
\end{verbatim}
So objects from this domain are represented as {\bf IDPAM(INT,NNI)}
\begin{verbatim}
   IndexedDirectProductAbelianMonoid(A:AbelianMonoid,S:OrderedSet):
     ==  IndexedDirectProductObject(A,S) add
       --representations
       Term:=  Record(k:S,c:A)
       Rep:=  List Term
\end{verbatim}
So objects from this domain are represented as {\bf IDPO(INT,NNI)}
\begin{verbatim}
IndexedDirectProductObject(A:SetCategory,S:OrderedSet):
 == add
       -- representations
       Term:=  Record(k:S,c:A)
       Rep:=  List Term
\end{verbatim}

\begin{verbatim}
(6) -> devaluate((3*x^2+5)::FRAC(POLY(INT)))$Lisp

   (6)  ((1 x (2 0 . 3) (0 0 . 5)) 0 . 1)
                                                            Type: SExpression
\end{verbatim}
\begin{verbatim}
(7) -> devaluate((3*x^2+5)::POLY(FRAC(INT)))$Lisp

   (7)  (1 x (2 0 3 . 1) (0 0 5 . 1))
                                                            Type: SExpression
\end{verbatim}
\begin{verbatim}
(8) -> devaluate((3*x^2+5)::EXPR(INT))$Lisp

   (8)  ((1 [[x,0,%symbol()()()],NIL,1,1024] (2 0 . 3) (0 0 . 5)) 0 . 1)
                                                            Type: SExpression
\end{verbatim}
\begin{verbatim}
(9) -> devaluate(w)$Lisp

   (9)
   (((PositiveInteger) . 1)  ((Float) 265633114661417543270 . - 65)
    ((String) . luanne)  ((Polynomial (Integer)) 1 x (2 0 . 3) (0 0 . 5))
    ((Fraction (Polynomial (Integer))) (1 x (2 0 . 3) (0 0 . 5)) 0 . 1)
    ((Polynomial (Fraction (Integer))) 1 x (2 0 3 . 1) (0 0 5 . 1))

     ((Expression (Integer))
      (1 [[x,0,%symbol()()()],NIL,1,1024] (2 0 . 3) (0 0 . 5))  0  .  1)
     )
                                                            Type: SExpression
\end{verbatim}


\section{Makefile}
This book is actually a literate program\cite{Knut92} and can contain 
executable source code. In particular, the Makefile for this book
is part of the source of the book and is included below. 
\eject
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{axiom}
\bibliography{axiom}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Index}
\printindex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
